This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: GPT5_ANALYSIS_REQUEST.md, src/reflaxe/elixir/ast/ElixirAST.hx, src/reflaxe/elixir/ast/ElixirASTPrinter.hx, src/reflaxe/elixir/ast/ElixirASTTransformer.hx, src/reflaxe/elixir/ast/transformers/DropTempNilAssignTransforms.hx, src/reflaxe/elixir/ast/transformers/EFnTempChainSimplifyTransforms.hx, src/reflaxe/elixir/ast/transformers/FunctionArgBlockToIIFETransforms.hx, src/reflaxe/elixir/ast/transformers/EctoQueryIIFEInlineTransforms.hx, src/reflaxe/elixir/ast/transformers/registry/groups/HygieneFinal.hx, src/reflaxe/elixir/ast/builders/FunctionBuilder.hx, examples/todo-app/lib/todo_app_web/todo_live.ex
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  reflaxe/
    elixir/
      ast/
        builders/
          FunctionBuilder.hx
        transformers/
          registry/
            groups/
              HygieneFinal.hx
          DropTempNilAssignTransforms.hx
          EctoQueryIIFEInlineTransforms.hx
          EFnTempChainSimplifyTransforms.hx
          FunctionArgBlockToIIFETransforms.hx
        ElixirAST.hx
        ElixirASTPrinter.hx
        ElixirASTTransformer.hx
GPT5_ANALYSIS_REQUEST.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/reflaxe/elixir/ast/transformers/DropTempNilAssignTransforms.hx">
package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * DropTempNilAssignTransforms
 *
 * WHAT
 * - Drop assignments of the form `thisN = nil` and `_thisN = nil` in any block/EFn bodies.
 *
 * WHY
 * - These are compiler-generated sentinels that trigger unused-variable warnings.
 */
class DropTempNilAssignTransforms {
    public static function pass(ast: ElixirAST): ElixirAST {
        #if sys Sys.println('[DropTempNilAssign] PASS START'); #end
        return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case EBlock(stmts):
                    #if sys Sys.println('[DropTempNilAssign] Found EBlock with ' + stmts.length + ' stmts'); #end
                    makeASTWithMeta(EBlock(filter(stmts)), n.metadata, n.pos);
                case EDo(stmts2):
                    #if sys Sys.println('[DropTempNilAssign] Found EDo with ' + stmts2.length + ' stmts'); #end
                    makeASTWithMeta(EDo(filter(stmts2)), n.metadata, n.pos);
                case EFn(clauses):
                    #if sys Sys.println('[DropTempNilAssign] Found EFn with ' + clauses.length + ' clauses'); #end
                    var newClauses = [];
                    for (cl in clauses) {
                        var b = cl.body;
                        #if sys Sys.println('[DropTempNilAssign] EFn body type: ' + Type.enumConstructor(b.def)); #end
                        var nb = switch (b.def) {
                            case EBlock(ss):
                                #if sys Sys.println('[DropTempNilAssign] EFn body is EBlock with ' + ss.length + ' stmts'); #end
                                makeASTWithMeta(EBlock(filter(ss)), b.metadata, b.pos);
                            case EDo(ss2):
                                #if sys Sys.println('[DropTempNilAssign] EFn body is EDo with ' + ss2.length + ' stmts'); #end
                                makeASTWithMeta(EDo(filter(ss2)), b.metadata, b.pos);
                            default:
                                #if sys Sys.println('[DropTempNilAssign] EFn body is OTHER - passing through unchanged'); #end
                                b;
                        };
                        newClauses.push({ args: cl.args, guard: cl.guard, body: nb });
                    }
                    makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);
                default:
                    n;
            }
        });
    }

    static function filter(stmts:Array<ElixirAST>): Array<ElixirAST> {
        var out:Array<ElixirAST> = [];
        for (s in stmts) switch (s.def) {
            case EBinary(Match, left, rhs):
                var isTemp = switch (left.def) { case EVar(nm): isTempName(nm); default: false; };
                var isNil = isNilValue(rhs);
                if (!(isTemp && isNil)) out.push(s);
            case EMatch(pat, rhs2):
                var isTemp2 = switch (pat) { case PVar(n2): isTempName(n2); default: false; };
                var isNil2 = isNilValue(rhs2);
                if (!(isTemp2 && isNil2)) out.push(s);
            default:
                out.push(s);
        }
        return out;
    }

    // Check for nil in both ENil and EAtom("nil") representations
    static function isNilValue(ast:ElixirAST):Bool {
        if (ast == null || ast.def == null) return false;
        return switch (ast.def) {
            case ENil: true;
            case EAtom(a): a == "nil";
            default: false;
        };
    }

    static function isTempName(nm:String):Bool {
        if (nm == null) return false;
        if (nm.indexOf("this") == 0) return true;
        if (nm.indexOf("_this") == 0) return true;
        return false;
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/transformers/EctoQueryIIFEInlineTransforms.hx">
package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * EctoQueryIIFEInlineTransforms
 *
 * WHAT
 * - Inlines immediately-invoked anonymous functions (IIFEs) used to construct
 *   the query argument of Ecto.Query.where/2 into their final expression,
 *   removing scaffolding like `(fn -> query3 = from(...); this1 = query3; this1 end).()`
 *
 * WHY
 * - Upstream extraction passes can introduce inner-lambda wrappers around
 *   `from/2` to preserve sequencing. For Ecto DSL, this is non-idiomatic and
 *   harms readability. The queryable should be `from(t in Schema, ...)` directly.
 *
 * HOW
 * - Detect `ERemoteCall(Ecto.Query, "where", [q, binding, cond])` where `q`
 *   is an IIFE: `ECall((EFn ...), [])` (possibly wrapped in EParen).
 * - Inspect the function body. If it returns a variable `v`, locate the most
 *   recent assignment to `v` within the body. If that assignment's RHS is a
 *   `ERemoteCall(_, "from", _)`, use that RHS to replace `q`.
 * - Conservative: Only rewrite when a clear `from/2` RHS is found. Otherwise
 *   leave the node untouched.
 *
 * EXAMPLES
 * Elixir (before):
 *   Ecto.Query.where((fn -> query3 = Ecto.Query.from(t in App.Todo, []); this1 = nil; this1 = query3; this1 end).(), [t], ...)
 * Elixir (after):
 *   Ecto.Query.where(Ecto.Query.from(t in App.Todo, []), [t], ...)
 */
class EctoQueryIIFEInlineTransforms {
    static function unwrapParen(e: ElixirAST): ElixirAST {
        return switch (e.def) {
            case EParen(inner): unwrapParen(inner);
            default: e;
        }
    }

    static function lastExprOf(body: ElixirAST): Null<ElixirAST> {
        return switch (body.def) {
            case EBlock(exprs) if (exprs.length > 0): exprs[exprs.length - 1];
            default: body;
        }
    }

    static function findAssignment(name: String, body: ElixirAST): Null<ElixirAST> {
        // Scan block statements from end to start to find the last assignment to name
        return switch (body.def) {
            case EBlock(exprs):
                var i = exprs.length - 1;
                while (i >= 0) {
                    switch (exprs[i].def) {
                        case EMatch(PVar(v), rhs) if (v == name):
                            return rhs;
                        default:
                    }
                    i--;
                }
                null;
            default:
                null;
        }
    }

    static function inlineIIFE(iface: ElixirAST): Null<ElixirAST> {
        // Expect ECall(targetFn, "", []) where targetFn is EFn (possibly parenthesized)
        return switch (iface.def) {
            case ECall(fnTarget, func, args) if (func == "" && (args == null || args.length == 0)):
                var t = unwrapParen(fnTarget);
                switch (t.def) {
                    case EFn(clauses) if (clauses.length > 0):
                        var body = clauses[0].body;
                        var last = lastExprOf(body);
                        switch (last.def) {
                            case EVar(retName):
                                // Follow assignments retName := ... until we find from/2
                                var rhs = findAssignment(retName, body);
                                var guard = 0;
                                while (rhs != null && guard++ < 5) {
                                    switch (rhs.def) {
                                        case ERemoteCall(mod, fn, args) if (fn == "from"):
                                            return rhs; // Found the from/2 call to inline
                                        case EVar(nextName):
                                            rhs = findAssignment(nextName, body);
                                        default:
                                            // Not a supported pattern
                                            return null;
                                    }
                                }
                                null;
                            default:
                                null;
                        }
                    default:
                        null;
                }
            default:
                null;
        }
    }

    static function inlineBlock(qarg: ElixirAST): Null<ElixirAST> {
        // When the query arg is an EBlock, the printer will emit an IIFE. Try to collapse it.
        return switch (qarg.def) {
            case EBlock(_):
                var last = lastExprOf(qarg);
                switch (last.def) {
                    case EVar(retName):
                        var rhs = findAssignment(retName, qarg);
                        var guard = 0;
                        while (rhs != null && guard++ < 5) {
                            switch (rhs.def) {
                                case ERemoteCall(mod, fn, args) if (fn == "from"):
                                    return rhs;
                                case EVar(nextName):
                                    rhs = findAssignment(nextName, qarg);
                                default:
                                    return null;
                            }
                        }
                        null;
                    default:
                        null;
                }
            default:
                null;
        }
    }

    public static function transformPass(ast: ElixirAST): ElixirAST {
        return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case ERemoteCall(mod, func, args) if (func == "where" && args != null && args.length >= 1):
                    // Ensure module is Ecto.Query
                    var modStr = switch (mod.def) {
                        case EVar(m): m;
                        default: reflaxe.elixir.ast.ElixirASTPrinter.printAST(mod);
                    };
                    if (modStr != "Ecto.Query") return n;
                    var qArg = args[0];
                    var simplified = inlineIIFE(qArg);
                    if (simplified == null) simplified = inlineBlock(qArg);
                    if (simplified != null) {
                        var newArgs = args.copy();
                        newArgs[0] = simplified;
                        makeASTWithMeta(ERemoteCall(mod, func, newArgs), n.metadata, n.pos);
                    } else n;
                default:
                    n;
            }
        });
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/transformers/EFnTempChainSimplifyTransforms.hx">
package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * EFnTempChainSimplifyTransforms
 *
 * WHAT
 * - Inside single-clause anonymous functions (EFn), collapse temp chains:
 *   `var = nil; var = expr; var` → `expr`. Also tolerates intervening statements
 *   as long as the last two references are `var = expr` then trailing `var`.
 *
 * WHY
 * - Lowerings and pattern rewrites often introduce sentinel assigns and trailing
 *   temps in reduce bodies, leading to warnings and noise. Collapsing yields
 *   idiomatic, concise Elixir expressions and helps achieve WAE=0.
 *
 * HOW
 * - For single-clause EFn: if the last expression is `EVar(name)`, scan backwards
 *   to find the most recent assignment to that name (EMatch or EBinary Match) and
 *   replace the tail with the RHS, dropping intervening `name = nil` sentinels.
 *
 * EXAMPLES
 * Before: fn -> this1 = nil; this1 = build(); this1 end
 * After:  fn -> build() end
 */
class EFnTempChainSimplifyTransforms {
    public static function pass(ast: ElixirAST): ElixirAST {
        #if debug_efn_temp_chain
        trace("[EFnTempChainSimplify] PASS START");
        #end
        return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case EFn(clauses) if (clauses.length == 1):
                    #if debug_efn_temp_chain
                    trace("[EFnTempChainSimplify] Found EFn with 1 clause");
                    #end
                    var cl = clauses[0];
                    var b = cl.body;
                    var nb = switch (b.def) {
                        case EBlock(stmts):
                            #if debug_efn_temp_chain
                            trace('[EFnTempChainSimplify] Body is EBlock with ${stmts.length} stmts');
                            for (i in 0...stmts.length) {
                                trace('[EFnTempChainSimplify]   stmt[$i]: ${Type.enumConstructor(stmts[i].def)}');
                            }
                            #end
                            makeASTWithMeta(EBlock(simplify(stmts, b.metadata, b.pos)), b.metadata, b.pos);
                        default:
                            #if debug_efn_temp_chain
                            trace('[EFnTempChainSimplify] Body is NOT EBlock: ${Type.enumConstructor(b.def)}');
                            #end
                            b;
                    };
                    makeASTWithMeta(EFn([{ args: cl.args, guard: cl.guard, body: nb }]), n.metadata, n.pos);
                default:
                    n;
            }
        });
    }

    /**
     * simplify
     *
     * WHAT
     * - Implements the chain collapse within an EFn body.
     *
     * WHY INLINE DROPS
     * - We drop only the shape `name = nil` for the identified `name`. This is a
     *   precise sentinel cleanup that preserves other side effects and ordering.
     */
    static function simplify(stmts:Array<ElixirAST>, meta:Dynamic, pos:Dynamic): Array<ElixirAST> {
        #if debug_efn_temp_chain
        trace('[EFnTempChainSimplify.simplify] Called with ${stmts.length} stmts');
        #end
        if (stmts.length >= 2) {
            var last = stmts[stmts.length - 1];
            #if debug_efn_temp_chain
            trace('[EFnTempChainSimplify.simplify] Last stmt: ${Type.enumConstructor(last.def)}');
            #end
            switch (last.def) {
                case EVar(name):
                    #if debug_efn_temp_chain
                    trace('[EFnTempChainSimplify.simplify] Last is EVar("$name") - looking for assignment');
                    #end
                    // Find last assignment to name
                    var assignIdx = -1;
                    var rhs:Null<ElixirAST> = null;
                    for (i in 0...stmts.length - 1) {
                        var idx = (stmts.length - 2) - i;
                        switch (stmts[idx].def) {
                            case EBinary(Match, left, r):
                                switch (left.def) { case EVar(nm) if (nm == name): assignIdx = idx; rhs = r; default: }
                            case EMatch(pat, r2):
                                switch (pat) { case PVar(nm2) if (nm2 == name): assignIdx = idx; rhs = r2; default: }
                            default:
                        }
                        if (assignIdx != -1) break;
                    }
                    #if debug_efn_temp_chain
                    trace('[EFnTempChainSimplify.simplify] assignIdx=$assignIdx, hasRhs=${rhs != null}');
                    #end
                    if (assignIdx != -1 && rhs != null) {
                        var out:Array<ElixirAST> = [];
                        for (j in 0...assignIdx) out.push(stmts[j]);
                        // Drop any prior 'name = nil' sentinels
                        for (j in assignIdx + 1...stmts.length - 1) {
                            var d = stmts[j].def;
                            var dropped = false;
                            switch (d) {
                                case EBinary(Match, left2, rnil):
                                    var isNil = switch (rnil.def) { case ENil: true; default: false; };
                                    if (isNil) switch (left2.def) { case EVar(nm3) if (nm3 == name): dropped = true; default: }
                                case EMatch(pat2, rnil2):
                                    var isNil2 = switch (rnil2.def) { case ENil: true; default: false; };
                                    if (isNil2) switch (pat2) { case PVar(nm4) if (nm4 == name): dropped = true; default: }
                                default:
                            }
                            if (!dropped) out.push(stmts[j]);
                        }
                        out.push(rhs);
                        #if debug_efn_temp_chain
                        trace('[EFnTempChainSimplify.simplify] SIMPLIFIED: ${stmts.length} -> ${out.length} stmts');
                        #end
                        return out;
                    }
                default:
                    #if debug_efn_temp_chain
                    trace('[EFnTempChainSimplify.simplify] Last is NOT EVar, no simplification');
                    #end
            }
        }
        return stmts;
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/ElixirAST.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Type.TypedExpr;
import haxe.macro.Expr.Position;
import reflaxe.elixir.ast.naming.ElixirAtom;

/**
 * ElixirAST: Strongly-Typed Intermediate AST for Reflaxe.Elixir
 *
 * WHY: Replace string manipulation with type-safe AST operations to enable:
 * - Semantic understanding of code structure
 * - Independent transformation passes
 * - Better debugging and inspection
 * - Context preservation through metadata
 *
 * WHAT: Complete representation of Elixir language constructs with:
 * - All syntax nodes (modules, functions, expressions, patterns)
 * - Rich metadata for each node
 * - Zero Dynamic types - everything strongly typed
 * - Support for all Elixir idioms and Phoenix patterns
 *
 * HOW: Three-phase compilation pipeline uses this AST:
 * 1. ElixirASTBuilder converts TypedExpr → ElixirAST
 * 2. ElixirASTTransformer applies idiom/framework transformations
 * 3. ElixirPrinter generates string output
 *
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */

// ============================================================================
// Variable Origin Tracking (January 2025)
// ============================================================================

/**
 * Variable origin enum for distinguishing between different variable sources
 *
 * WHY: To solve false positive detection where legitimate variables like "g" in RGB(r,g,b)
 *      are incorrectly treated as temp variables
 *
 * WHAT: Tracks where a variable came from in the compilation pipeline
 *
 * HOW: Set during ElixirASTBuilder phase, consulted during transformation and printing
 */
enum VarOrigin {
    /** Variable introduced by a user pattern (e.g., r, g, b in RGB pattern) */
    PatternBinder;

    /** Temporary variable generated for TEnumParameter extraction (g, g1, g2) */
    ExtractionTemp;

    /** Other compiler-synthesized locals */
    Synthesized;

    /** User-defined variable from source code */
    UserDefined;
}

// ============================================================================
// Core AST Definition
// ============================================================================

/**
 * Main AST node enum containing all Elixir language constructs
 */
enum ElixirASTDef {
    // ========================================================================
    // Modules and Structure
    // ========================================================================
    
    /** Elixir module definition with attributes and body */
    EModule(name: String, attributes: Array<EAttribute>, body: Array<ElixirAST>);
    
    /** Defmodule block */
    EDefmodule(name: String, doBlock: ElixirAST);
    
    // ========================================================================
    // Functions
    // ========================================================================
    
    /** Public function definition */
    EDef(name: String, args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST);
    
    /** Private function definition */
    EDefp(name: String, args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST);
    
    /** Macro definition */
    EDefmacro(name: String, args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST);
    
    /** Private macro definition */
    EDefmacrop(name: String, args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST);
    
    // ========================================================================
    // Pattern Matching
    // ========================================================================
    
    /** Case expression with pattern matching */
    ECase(expr: ElixirAST, clauses: Array<ECaseClause>);
    
    /** Cond expression for condition chains */
    ECond(clauses: Array<ECondClause>);
    
    /** Pattern match (=) operator */
    EMatch(pattern: EPattern, expr: ElixirAST);
    
    /** With expression for chained pattern matching */
    EWith(clauses: Array<EWithClause>, doBlock: ElixirAST, elseBlock: Null<ElixirAST>);
    
    // ========================================================================
    // Control Flow
    // ========================================================================
    
    /** If expression */
    EIf(condition: ElixirAST, thenBranch: ElixirAST, elseBranch: Null<ElixirAST>);
    
    /** Unless expression (negative if) */
    EUnless(condition: ElixirAST, body: ElixirAST, elseBranch: Null<ElixirAST>);
    
    /** Try-rescue-catch-after expression */
    ETry(body: ElixirAST, rescue: Array<ERescueClause>, catchClauses: Array<ECatchClause>, 
         afterBlock: Null<ElixirAST>, elseBlock: Null<ElixirAST>);
    
    /** Raise exception */
    ERaise(exception: ElixirAST, attributes: Null<ElixirAST>);
    
    /** Throw expression */
    EThrow(value: ElixirAST);
    
    // ========================================================================
    // Data Structures
    // ========================================================================
    
    /** List literal [] */
    EList(elements: Array<ElixirAST>);
    
    /** Tuple literal {} */
    ETuple(elements: Array<ElixirAST>);
    
    /** Map literal %{} */
    EMap(pairs: Array<EMapPair>);
    
    /** Struct literal %Module{} */
    EStruct(module: String, fields: Array<EStructField>);
    
    /** Struct update %{struct | field: value} */
    EStructUpdate(struct: ElixirAST, fields: Array<EStructField>);
    
    /** Keyword list [key: value] */
    EKeywordList(pairs: Array<EKeywordPair>);
    
    /** Binary/Bitstring <<>> */
    EBitstring(segments: Array<EBinarySegment>);
    
    // ========================================================================
    // Expressions
    // ========================================================================
    
    /** Function call */
    ECall(target: Null<ElixirAST>, funcName: String, args: Array<ElixirAST>);
    
    /** Macro call with do-block (like schema, defmodule, etc.) */
    EMacroCall(macroName: String, args: Array<ElixirAST>, doBlock: ElixirAST);
    
    /** Remote call Module.function() */
    ERemoteCall(module: ElixirAST, funcName: String, args: Array<ElixirAST>);
    
    /** Pipe operator |> */
    EPipe(left: ElixirAST, right: ElixirAST);
    
    /** Binary operator */
    EBinary(op: EBinaryOp, left: ElixirAST, right: ElixirAST);
    
    /** Unary operator */
    EUnary(op: EUnaryOp, expr: ElixirAST);
    
    /** Dot access for maps/structs */
    EField(target: ElixirAST, field: String);
    
    /** Bracket access [] */
    EAccess(target: ElixirAST, key: ElixirAST);
    
    /** Range operator .. or ... */
    ERange(start: ElixirAST, end: ElixirAST, exclusive: Bool);
    
    // ========================================================================
    // Literals
    // ========================================================================
    
    /** Atom literal */
    EAtom(value: ElixirAtom);
    
    /** String literal */
    EString(value: String);
    
    /** Integer literal */
    EInteger(value: Int);
    
    /** Float literal */
    EFloat(value: Float);
    
    /** Boolean literal */
    EBoolean(value: Bool);
    
    /** Nil literal */
    ENil;
    
    /** Charlist literal */
    ECharlist(value: String);
    
    // ========================================================================
    // Variables and Binding
    // ========================================================================
    
    /** Variable reference */
    EVar(name: String);
    
    /** Pin operator ^ */
    EPin(expr: ElixirAST);
    
    /** Underscore pattern _ */
    EUnderscore;
    
    // ========================================================================
    // Comprehensions
    // ========================================================================
    
    /** For comprehension */
    EFor(generators: Array<EGenerator>, filters: Array<ElixirAST>, 
         body: ElixirAST, into: Null<ElixirAST>, uniq: Bool);
    
    // ========================================================================
    // Anonymous Functions
    // ========================================================================
    
    /** Anonymous function fn -> end */
    EFn(clauses: Array<EFnClause>);
    
    /** Capture operator & with optional arity for function references */
    ECapture(expr: ElixirAST, ?arity: Int);
    
    // ========================================================================
    // Module Directives
    // ========================================================================
    
    /** Alias directive */
    EAlias(module: String, as: Null<String>);
    
    /** Import directive */
    EImport(module: String, only: Null<Array<EImportOption>>, except: Null<Array<EImportOption>>);
    
    /** Use macro */
    EUse(module: String, options: Array<ElixirAST>);
    
    /** Require directive */
    ERequire(module: String, as: Null<String>);
    
    // ========================================================================
    // Special Forms
    // ========================================================================
    
    /** Quote expression */
    EQuote(options: Array<ElixirAST>, expr: ElixirAST);
    
    /** Unquote expression */
    EUnquote(expr: ElixirAST);
    
    /** Unquote splicing */
    EUnquoteSplicing(expr: ElixirAST);
    
    /** Receive block for message passing */
    EReceive(clauses: Array<ECaseClause>, after: Null<EAfterClause>);
    
    /** Send message */
    ESend(target: ElixirAST, message: ElixirAST);
    
    // ========================================================================
    // Blocks and Grouping
    // ========================================================================
    
    /** Block of expressions */
    EBlock(expressions: Array<ElixirAST>);
    
    /** Parenthesized expression */
    EParen(expr: ElixirAST);
    
    /** Do-end block */
    EDo(body: Array<ElixirAST>);
    
    // ========================================================================
    // Documentation & Module Attributes
    // ========================================================================
    
    /** Module attribute (e.g., @my_constant "value") */
    EModuleAttribute(name: String, value: ElixirAST);
    
    /** @moduledoc documentation */
    EModuledoc(content: String);
    
    /** @doc documentation */
    EDoc(content: String);
    
    /** @spec type specification */
    ESpec(signature: String);
    
    /** @type type definition */
    ETypeDef(name: String, definition: String);
    
    // ========================================================================
    // Phoenix/Framework Specific (for transformation phase)
    // ========================================================================
    
    /** Sigil (like ~H for HEEx templates) */
    ESigil(type: String, content: String, modifiers: String);
    
    /** Raw Elixir code injection (for __elixir__ calls) */
    ERaw(code: String);
    
    /** Attribute @ (for assigns in templates) */
    EAssign(name: String);
    
    /** Fragment for template composition */
    EFragment(tag: String, attributes: Array<EAttribute>, children: Array<ElixirAST>);
}

// ============================================================================
// Supporting Types
// ============================================================================

/**
 * Pattern types for pattern matching contexts
 */
enum EPattern {
    /** Variable pattern */
    PVar(name: String);
    
    /** Literal pattern */
    PLiteral(value: ElixirAST);
    
    /** Tuple pattern */
    PTuple(elements: Array<EPattern>);
    
    /** List pattern */
    PList(elements: Array<EPattern>);
    
    /** Cons pattern [head | tail] */
    PCons(head: EPattern, tail: EPattern);
    
    /** Map pattern */
    PMap(pairs: Array<{key: ElixirAST, value: EPattern}>);
    
    /** Struct pattern */
    PStruct(module: String, fields: Array<{key: String, value: EPattern}>);
    
    /** Pin pattern ^variable */
    PPin(pattern: EPattern);
    
    /** Underscore/wildcard pattern */
    PWildcard;
    
    /** Alias pattern (var = pattern) */
    PAlias(varName: String, pattern: EPattern);
    
    /** Binary pattern */
    PBinary(segments: Array<PBinarySegment>);
}

/**
 * Case clause for case/receive expressions
 */
typedef ECaseClause = {
    pattern: EPattern,
    ?guard: ElixirAST,
    body: ElixirAST
}

/**
 * Cond clause for cond expressions
 */
typedef ECondClause = {
    condition: ElixirAST,
    body: ElixirAST
}

/**
 * With clause for with expressions
 */
typedef EWithClause = {
    pattern: EPattern,
    expr: ElixirAST
}

/**
 * Function clause for anonymous functions
 */
typedef EFnClause = {
    args: Array<EPattern>,
    ?guard: ElixirAST,
    body: ElixirAST
}

/**
 * Rescue clause for try expressions
 */
typedef ERescueClause = {
    pattern: EPattern,
    ?varName: String,
    body: ElixirAST
}

/**
 * Catch clause for try expressions
 */
typedef ECatchClause = {
    kind: ECatchKind,
    pattern: EPattern,
    body: ElixirAST
}

/**
 * After clause for receive expressions
 */
typedef EAfterClause = {
    timeout: ElixirAST,
    body: ElixirAST
}

/**
 * Generator for comprehensions
 */
typedef EGenerator = {
    pattern: EPattern,
    expr: ElixirAST
}

/**
 * Module attribute
 */
typedef EAttribute = {
    name: String,
    value: ElixirAST
}

/**
 * Map pair
 */
typedef EMapPair = {
    key: ElixirAST,
    value: ElixirAST
}

/**
 * Struct field
 */
typedef EStructField = {
    key: String,
    value: ElixirAST
}

/**
 * Keyword pair
 */
typedef EKeywordPair = {
    key: String,
    value: ElixirAST
}

/**
 * Binary segment for binary patterns
 */
typedef EBinarySegment = {
    value: ElixirAST,
    ?size: ElixirAST,
    ?type: String,
    ?modifiers: Array<String>
}

/**
 * Binary pattern segment
 */
typedef PBinarySegment = {
    pattern: EPattern,
    ?size: ElixirAST,
    ?type: String,
    ?modifiers: Array<String>
}

/**
 * Import option for import directive
 */
typedef EImportOption = {
    name: String,
    arity: Int
}

/**
 * Guard branch for guard condition flattening
 * Represents a single guard condition with its associated body
 */
typedef GuardBranch = {
    pattern: EPattern,          // The pattern being matched (e.g., RGB(r, g, b))
    guard: ElixirAST,           // The guard condition (e.g., r > 200)
    body: ElixirAST,            // The expression body when guard matches
    ?originalIfElse: ElixirAST, // Optional: Original if-else for debugging
    ?depth: Int                 // Optional: Nesting depth for debugging
}

/**
 * Validation result for guard condition grouping
 * Used by GuardGroupValidator to report groupability status
 */
typedef ValidationResult = {
    canGroup: Bool,             // Whether conditions can be grouped in a cond
    reason: String,             // Explanation of decision
    groupKey: String,           // Pattern signature for grouping (e.g., "RGB(r,g,b)")
    patterns: Array<String>     // All patterns found in this group
}

/**
 * Binary operators
 */
enum EBinaryOp {
    // Arithmetic
    Add;        // +
    Subtract;   // -
    Multiply;   // *
    Divide;     // /
    Remainder;  // rem
    Power;      // **
    
    // Comparison
    Equal;      // ==
    NotEqual;   // !=
    StrictEqual;    // ===
    StrictNotEqual; // !==
    Less;       // <
    Greater;    // >
    LessEqual;  // <=
    GreaterEqual; // >=
    
    // Logical
    And;        // and
    Or;         // or
    AndAlso;    // &&
    OrElse;     // ||
    
    // Binary
    BitwiseAnd; // &&&
    BitwiseOr;  // |||
    BitwiseXor; // ^^^
    ShiftLeft;  // <<<
    ShiftRight; // >>>
    
    // List
    Concat;     // ++
    ListSubtract;   // --
    
    // String
    StringConcat;   // <>
    
    // Membership
    In;         // in
    
    // Other
    Match;      // =
    Pipe;       // |>
    TypeCheck;  // ::
    When;       // when (guards)
}

/**
 * Unary operators
 */
enum EUnaryOp {
    Not;        // not
    Negate;     // -
    Positive;   // +
    BitwiseNot; // ~~~
    Bang;       // !
}

/**
 * Catch kinds for try-catch
 */
enum ECatchKind {
    Error;
    Exit;
    Throw;
    Any;
}

// ============================================================================
// Context Types
// ============================================================================

/**
 * Phoenix-specific context for LiveView, Router, etc.
 */
enum PhoenixContext {
    LiveView;
    LiveComponent;
    Controller;
    Router;
    Channel;
    Endpoint;
    None;
}

/**
 * Ecto-specific context for schemas, queries, etc.
 */
enum EctoContext {
    Schema;
    Query;
    Changeset;
    Repo;
    Migration;
    None;
}

/**
 * Access pattern hints for optimization
 */
enum AccessPattern {
    Sequential;
    Random;
    WriteOnly;
    ReadOnly;
    ReadWrite;
}

// ============================================================================
// Main AST Type with Metadata
// ============================================================================

/**
 * AST node with metadata for context and optimization
 */
typedef ElixirAST = {
    /** The actual AST node */
    def: ElixirASTDef,
    
    /** Rich metadata for transformation and optimization */
    metadata: ElixirMetadata,
    
    /** Source position for error reporting */
    ?pos: Position
}

/**
 * Comprehensive metadata structure for AST nodes
 */
/**
 * Loop context information for metadata preservation
 * 
 * WHY THIS EXISTS: When Haxe's analyzer optimization is enabled (-D analyzer-optimize),
 * it replaces loop variables with literal values during compilation. For example,
 * `"Cell (" + i + "," + j + ")"` becomes `"Cell (0,1)"` before our compiler sees it.
 * This structure preserves the original loop context so we can restore variable names.
 * 
 * WHAT IT RELATES TO:
 * - Created in: ElixirASTBuilder.hx when processing TFor nodes
 * - Attached to: ElixirAST nodes via metadata field
 * - Consumed by: LoopVariableRestorer.hx to restore variable names in strings
 * 
 * HOW IT WORKS: Each loop creates a context that travels with the AST through all
 * transformation passes, allowing late-stage restoration of variable names.
 */
typedef LoopContext = {
    var variableName: String;         // Original loop variable name from Haxe source (i, j, k)
    var rangeMin: Int;               // Start of range (0 in "0...5") - used to identify which literals to replace
    var rangeMax: Int;               // End of range (4 in "0...5") - helps detect loop-generated values
    var depth: Int;                  // Nesting level (0=outermost, 1=first nested) - handles nested loops
    var iteratorExpr: String;        // Original iterator expression - for debugging and complex cases
}

typedef ElixirMetadata = {
    // Source Information
    ?sourceExpr: haxe.macro.Type.TypedExpr,        // Original Haxe expression
    ?sourceLine: Int,               // Line number in Haxe source
    ?sourceFile: String,            // Source file path
    ?sourceVarId: Int,             // Original TVar.id for variable resolution
    
    // Type Information
    ?type: Type,                   // Haxe type information
    ?elixirType: String,           // Inferred Elixir type
    
    // Semantic Information
    ?purity: Bool,                 // Is expression pure?
    ?tailPosition: Bool,           // Is in tail position?
    ?async: Bool,                  // Is async operation?
    
    // Transformation Hints
    ?requiresReturn: Bool,         // Needs explicit return value
    ?requiresTempVar: Bool,        // Needs temporary variable
    ?inPipeline: Bool,            // Part of pipe chain
    ?inComprehension: Bool,       // Inside for comprehension
    ?inGuard: Bool,               // Inside guard clause
    ?redundantEnumExtraction: Bool, // Marks redundant enum extraction for removal
    
    // Array Comprehension Reconstruction
    ?isUnrolledComprehension: Bool, // Block contains unrolled array comprehension
    ?comprehensionElements: Int,    // Number of elements in unrolled comprehension
    
    // Variable Resolution
    ?varIdToName: Map<Int, String>, // Clause-local variable renaming mappings
    ?requiresIdiomaticTransform: Bool,  // Enum needs idiomatic compilation
    
    // Inheritance Information
    ?parentModule: String,         // Parent class module name for inheritance
    ?isException: Bool,            // Whether this class extends haxe.Exception
    ?idiomaticEnumType: String,   // Name of the idiomatic enum type
    ?hasEnumBindingPlan: Bool,    // M0.5: Case has proper enum parameter mappings
    ?enumBindingPlanId: String,   // Unique ID linking to EnumBindingPlan in context
    ?parentHasBindingPlan: Bool,  // Propagated flag from parent ECase

    // Variable Origin Tracking (January 2025)
    ?varOrigin: VarOrigin,         // Where this variable came from
    ?varId: Int,                   // Unique Haxe TVar ID for identity tracking
    ?tempToBinderMap: Map<Int, Int>, // Maps extraction temp var IDs to pattern binder IDs
    ?isUnused: Bool,               // Whether this variable is actually used in the code

    // Phoenix/Framework Specific
    ?phoenixContext: PhoenixContext,  // LiveView, Router, etc.
    ?ectoContext: EctoContext,        // Schema, Query, etc.
    
    // Ecto-specific hints
    ?ectoPinnedNilGuard: Bool,     // Marks Kernel.is_nil(^var) guard injected for Ecto != semantics
    
    // Annotation-based Module Types
    ?isEndpoint: Bool,            // @:endpoint Phoenix.Endpoint
    ?isLiveView: Bool,            // @:liveview Phoenix.LiveView
    ?isSchema: Bool,              // @:schema Ecto.Schema
    ?isRepo: Bool,                // @:repo Ecto.Repo
    ?isSupervisor: Bool,          // @:supervisor OTP Supervisor
    ?isKeep: Bool,                // @:keep - Prevent dead code elimination
    ?isPostgrexTypes: Bool,       // @:postgrexTypes Postgrex precompiled types module (sugar)
    ?isDbTypes: Bool,             // @:dbTypes generic DB types module
    ?dbAdapter: String,           // Adapter name (e.g., "postgrex")
    ?extensions: Array<String>,   // Optional extensions for types define
    ?isApplication: Bool,         // @:application OTP Application
    ?isGenServer: Bool,           // @:genserver GenServer behavior
    ?isRouter: Bool,              // @:router Phoenix.Router
    ?isController: Bool,          // @:controller Phoenix.Controller
    ?isPresence: Bool,            // @:presence Phoenix.Presence
    ?isPhoenixWeb: Bool,          // @:phoenixWeb AppNameWeb module with macros
    ?isExunit: Bool,              // @:exunit ExUnit.Case test module
    ?isTest: Bool,                // @:test on a method in ExUnit module
    ?isSetup: Bool,               // @:setup on a method in ExUnit module
    ?isSetupAll: Bool,            // @:setupAll on a method in ExUnit module
    ?isTeardown: Bool,            // @:teardown on a method in ExUnit module
    ?isTeardownAll: Bool,         // @:teardownAll on a method in ExUnit module
    ?describeBlock: String,       // @:describe block name for grouping tests
    ?isAsync: Bool,               // @:async for async ExUnit tests
    ?testTags: Array<String>,     // @:tag values for test tagging
    ?appName: String,             // Application name for OTP/Phoenix
    ?tableName: String,           // Table name for Ecto schemas
    ?jsonModule: String,          // JSON library module name for Postgrex.Types.define
    ?poolSize: Int,               // Connection pool size for Repo
    ?needsPostgrexTypes: Bool,    // Whether to generate companion PostgrexTypes module

    // HEEx/HXX annotation (experimental; analysis only)
    ?heexFragments: Array<HeexFragmentMeta>, // Parsed fragments from ~H content for analysis (not used for emission)

    // Schema metadata (for @:schema)
    // haxeFqcn: Fully Qualified Class Name of the original Haxe type that produced this module.
    // Why string: metadata travels outside macro-only phases; we resolve it later when needed.
    // Example: "server.schemas.Todo". Transformers can use this to locate schema info deterministically.
    ?haxeFqcn: String,
    // schemaFields: pre-extracted field list from the Haxe class, used by transformers to emit Ecto fields.
    // Each entry contains the original Haxe field name and a normalized type hint (String, Int, Bool, Date, etc.).
    // Transformers apply name conversion (snake_case) and map types to Ecto atoms (e.g., Int -> :integer).
    ?schemaFields: Array<{ name: String, type: String }>,
    // Whether the original Haxe class had @:timestamps annotation
    ?hasTimestamps: Bool,
    
    // Loop Expression Preservation (Critical for idiomatic Elixir generation)
    // WHY: Haxe's optimizer replaces loop variables with literals BEFORE our compiler runs
    // WHAT: These fields preserve loop information from the original TypedExpr
    // RELATES TO: Loop variable substitution bug (see LOOP_VARIABLE_FIX_PRD.md)
    
    ?originalLoopExpression: String,  // Captures loop body expression before optimization ("i * 2 + 1" not "0 * 2 + 1")
                                     // USED BY: String reconstruction in transformer passes
    
    ?loopVariableName: String,        // Preserves original variable name ("i", "j", "k")
                                     // USED BY: Legacy compatibility with existing restorer code
    
    ?loopContextStack: Array<LoopContext>, // Stack of all enclosing loop contexts for nested loops
                                          // WHY: Nested loops need access to all parent loop variables
                                          // USED BY: LoopVariableRestorer to handle multi-level nesting
    
    ?isWithinLoop: Bool,              // Marks nodes that are inside a loop body
                                     // WHY: Only restore variables in loop contexts, not everywhere
                                     // USED BY: Transformation passes to enable/disable restoration
    
    ?parentLoopVar: String,           // Direct parent loop variable for simple nested detection
                                     // WHY: Quick check for immediate parent without full stack traversal
                                     // USED BY: Optimization passes for common two-level nesting
    
    // Optimization Hints
    ?canInline: Bool,             // Can be inlined
    ?keepInlineInAssignment: Bool, // Keep inline when assigned (e.g., null coalescing)
    ?isConstant: Bool,            // Compile-time constant
    ?accessPattern: AccessPattern, // How value is accessed
    ?sideEffects: Bool,           // Has side effects
    
    // User Annotations
    ?annotations: Array<String>,   // @:native, @:inline, etc.
    ?documentation: String,        // Doc comments
    
    // Variable Context
    ?variableScope: String,        // Current scope identifier
    ?capturedVars: Array<String>, // Variables captured by closure
    
    // Error Handling
    ?canRaise: Bool,              // Can raise exceptions
    ?errorContext: String,        // Error handling context
    
    // Static Extern Method Handling (Added 2025-09-05)
    ?isStaticExternMethod: Bool,  // Marks a static method on an extern class
    ?nativeModule: String,        // The full module path from @:native annotation
    ?methodName: String,          // The method name being called
    
    // Function Reference Handling (Added 2025-09-05)
    ?isFunctionReference: Bool,   // Marks a function being passed as a reference
    ?arity: Int,                  // Function arity for capture operator
    
    // Fluent API Detection (Added 2025-09-10)
    ?isFluentMethod: Bool,         // Method returns 'this' for chaining
    ?mutatesFields: Array<String>, // Fields mutated in this method (e.g., ["columns", "indexes"])
    ?fieldMutations: Array<{field: String, expr: ElixirAST}>, // Field mutation operations
    ?returnsThis: Bool,           // Method returns 'this' for fluent chaining

    // Dead Code Elimination (Added January 2025)
    ?unusedPrivateFunctions: Array<String>,  // List of unused private function names in the module
    ?unusedPrivateFunctionsWithArity: Array<{name: String, arity: Int}>,  // List with arities for @compile directive
    
    // Guard Condition Grouping (Added January 2025)
    ?patternKey: String,          // Normalized pattern signature for grouping (e.g., "tuple:rgb:3")
    ?boundVars: Array<String>,    // Variables bound by this pattern (e.g., ["r", "g", "b"])
    ?hasGuard: Bool,              // Whether this clause has a guard condition

    // HEEx typed AST (Builder-attached; analysis only)
    // WHAT: Typed EFragment/EAssign-based AST parsed from ~H content.
    // WHY: Enable attribute-level static analysis (e.g., assigns lints) without relying on
    //      brittle string scanning. Keeps final emission as ~H while providing structured shape.
    // HOW: ElixirASTBuilder parses ESigil("H", ...) content using HeexFragmentBuilder and
    //      attaches the resulting top-level nodes here. Printer ignores this; transformers/linters
    //      may prefer it over heexFragments when present.
    ?heexAST: Array<ElixirAST>
}

/** Minimal HEEx fragment metadata for analysis (not used for emission) */
typedef HeexFragmentMeta = {
    tag: String,
    attributes: Array<HeexAttributeMeta>,
    childrenText: String
}

typedef HeexAttributeMeta = {
    name: String,
    valueExpr: String,
    isDynamic: Bool
}

// ============================================================================
// Utility Functions (to be implemented by users of this AST)
// ============================================================================

/**
 * Create an empty metadata object
 */
inline function emptyMetadata(): ElixirMetadata {
    return {};
}

/**
 * Create an AST node with empty metadata
 */
inline function makeAST(def: ElixirASTDef, ?pos: Position): ElixirAST {
    return {
        def: def,
        metadata: emptyMetadata(),
        pos: pos
    };
}

/**
 * Create an AST node with specific metadata
 */
inline function makeASTWithMeta(def: ElixirASTDef, meta: ElixirMetadata, ?pos: Position): ElixirAST {
    return {
        def: def,
        metadata: meta,
        pos: pos
    };
}

// ============================================================================
// Shared Transformation Utilities
// ============================================================================

/**
 * Applies idiomatic Elixir transformations to enum constructor calls
 * 
 * WHY: Haxe enums naturally compile to tuples {:constructor, args...} but many
 * Elixir patterns expect different forms (bare atoms, unwrapped values, OTP tuples).
 * This shared utility ensures consistent transformation across the AST pipeline.
 * 
 * WHAT: Detects patterns by structure and arity, transforming enum constructors to:
 * - 0 args: Bare atom (e.g., :telemetry for standalone markers)
 * - 1 arg: Unwrapped value (e.g., "MyModule" for module references)
 * - 2 args with keyword list: OTP tuple {Module, config} for child specs
 * 
 * HOW: Convention-based detection using argument count and type inspection.
 * No hardcoded enum names - works for any enum marked with @:elixirIdiomatic.
 * 
 * @param node The AST node to potentially transform
 * @return Transformed node or original if no transformation applies
 */
function applyIdiomaticEnumTransformation(node: ElixirAST): ElixirAST {
    // Only transform tuples that are enum constructors
    var elements = switch(node.def) {
        case ETuple(els): els;
        default: return node; // Not a tuple, no transformation
    };
    
    if (elements.length == 0) return node;
    
    // First element should be the constructor tag (atom)
    var tag = switch(elements[0].def) {
        case EAtom(name): name; // name is now ElixirAtom
        default: return node; // Not an enum constructor pattern
    };
    
    // Extract constructor arguments (everything after the tag)
    var args = elements.slice(1);
    var argCount = args.length;
    
    // Convention-based transformation based on arity
    switch(argCount) {
        case 0:
            // Zero arguments → bare atom
            // Example: Telemetry() → :telemetry
            return makeASTWithMeta(EAtom(tag), node.metadata, node.pos);
            
        case 1:
            // Single argument → unwrap the value
            // Special handling for module names (strings that look like modules)
            var unwrapped = switch(args[0].def) {
                case EString(s) if (isModuleName(s)):
                    // Module names should be bare identifiers, not strings
                    makeAST(EVar(s), args[0].pos);
                default: 
                    args[0];
            };
            return makeASTWithMeta(unwrapped.def, node.metadata, node.pos);
            
        case 2:
            // Two arguments → check for OTP child spec pattern (Module, config)
            // Transform ModuleWithConfig("Phoenix.PubSub", config) → {Phoenix.PubSub, config}
            
            // First arg should be a module name
            var moduleArg = switch(args[0].def) {
                case EString(s) if (isModuleName(s)):
                    // Convert string module name to bare module reference
                    makeAST(EVar(s), args[0].pos);
                default:
                    args[0];
            };
            
            // Second arg should be config - transform to keyword list if needed
            var configArg = switch(args[1].def) {
                case EKeywordList(_): 
                    // Already a keyword list
                    args[1];
                    
                case EList(elements):
                    // Check if it's a list of {key: "...", value: ...} structures that should be keyword pairs
                    var keywordPairs: Array<EKeywordPair> = [];
                    var isKeyValueConfig = true;
                    
                    for (elem in elements) {
                        switch(elem.def) {
                            case EMap(pairs):
                                // Look for {key: "name", value: data} pattern
                                var keyName: String = null;
                                var keyValue: ElixirAST = null;
                                
                                for (pair in pairs) {
                                    switch(pair.key.def) {
                                        case EAtom(atom) if (atom == "key"):
                                            // Extract the key name from the value
                                            switch(pair.value.def) {
                                                case EString(s): keyName = s;
                                                default: isKeyValueConfig = false;
                                            }
                                        case EAtom(atom) if (atom == "value"):
                                            // This is the actual value
                                            keyValue = pair.value;
                                        default:
                                            // Not the pattern we're looking for
                                            isKeyValueConfig = false;
                                    }
                                }
                                
                                if (keyName != null && keyValue != null) {
                                    // For certain keys, convert strings to appropriate references
                                    var finalValue = if (keyName == "name") {
                                        switch(keyValue.def) {
                                            case EString(s) if (isModuleName(s)):
                                                // Convert module name string to module reference (unquoted)
                                                // Use EVar for module references like TodoApp.PubSub
                                                makeAST(EVar(s), keyValue.pos);
                                            default:
                                                keyValue;
                                        }
                                    } else if (keyName == "keys") {
                                        // Registry keys option should be an atom (:unique or :duplicate)
                                        switch(keyValue.def) {
                                            case EString(s) if (s == "unique" || s == "duplicate"):
                                                // Convert to atom for Registry configuration
                                                makeAST(EAtom(ElixirAtom.raw(s)), keyValue.pos);
                                            default:
                                                keyValue;
                                        }
                                    } else {
                                        keyValue;
                                    };
                                    keywordPairs.push({key: keyName, value: finalValue});
                                } else {
                                    isKeyValueConfig = false;
                                }
                                
                            default:
                                isKeyValueConfig = false;
                        }
                    }
                    
                    if (isKeyValueConfig && keywordPairs.length > 0) {
                        // Convert to keyword list
                        makeAST(EKeywordList(keywordPairs), args[1].pos);
                    } else {
                        args[1];
                    }
                    
                default:
                    args[1];
            };
            
            // For OTP child specs, return a 2-tuple with module and config
            return makeASTWithMeta(
                ETuple([moduleArg, configArg]),
                node.metadata,
                node.pos
            );
    }
    
    // No convention matched, return original
    return node;
}

/**
 * Checks if a string looks like an Elixir module name
 * 
 * @param s String to check
 * @return True if it matches module naming pattern
 */
function isModuleName(s: String): Bool {
    // Module names start with uppercase and can contain dots
    // Examples: "Phoenix.PubSub", "MyApp.Repo", "Task.Supervisor"
    if (s.length == 0) return false;
    
    var firstChar = s.charAt(0);
    if (firstChar != firstChar.toUpperCase()) return false;
    
    // Check if it's a valid module name pattern
    // Allow dots for nested modules, alphanumeric and underscores
    for (i in 0...s.length) {
        var char = s.charAt(i);
        if (!isAlphaNumeric(char) && char != "." && char != "_") {
            return false;
        }
    }
    
    return true;
}

/**
 * Helper to check if a character is alphanumeric
 */
function isAlphaNumeric(char: String): Bool {
    var code = char.charCodeAt(0);
    return (code >= 48 && code <= 57) ||  // 0-9
           (code >= 65 && code <= 90) ||  // A-Z
           (code >= 97 && code <= 122);   // a-z
}

#end
</file>

<file path="GPT5_ANALYSIS_REQUEST.md">
# Reflaxe.Elixir Compiler - GPT5-Pro Analysis Request

## What is Reflaxe.Elixir?

Reflaxe.Elixir is a **Haxe-to-Elixir transpiler** built on the Reflaxe framework. It enables developers to write type-safe Haxe code that compiles to idiomatic Elixir, with deep integration for Phoenix, Ecto, and OTP patterns.

### Architecture Overview

```
Haxe Source (.hx) → Haxe Parser → TypedExpr → ElixirASTBuilder → ElixirAST → ElixirASTTransformer → ElixirASTPrinter → Elixir Code (.ex)
```

The compilation pipeline has three main phases:
1. **Builder Phase** (`ElixirASTBuilder.hx`): Converts Haxe TypedExpr to ElixirAST nodes
2. **Transformer Phase** (`ElixirASTTransformer.hx`): Applies transformation passes to optimize/clean the AST
3. **Printer Phase** (`ElixirASTPrinter.hx`): Converts ElixirAST to Elixir source code strings

## Current State

### What Works
- Core Haxe-to-Elixir transpilation
- Phoenix LiveView integration
- Ecto schema and changeset generation
- OTP patterns (GenServer, Supervisor)
- Pattern matching compilation
- Most AST transformations

### What's NOT Working - The `this1` Warning Problem

We have **unused variable warnings** in generated Elixir code that we cannot eliminate. The most persistent is the `this1` pattern.

## The Core Problem

### Generated Code Pattern (WRONG)
```elixir
TodoApp.Repo.all((fn ->
  query = Ecto.Query.where((fn ->
    query = Ecto.Query.from(t in TodoApp.Todo, [])
    this1 = nil           # <-- WARNING: unused variable
    this1 = query
    this1
  end).(), [t], t.user_id == ^(user_id))
  this1 = nil             # <-- WARNING: unused variable
  this1 = query
  this1
end).())
```

### Expected Code Pattern (CORRECT)
```elixir
TodoApp.Repo.all(
  Ecto.Query.where(
    Ecto.Query.from(t in TodoApp.Todo, []),
    [t],
    t.user_id == ^(user_id)
  )
)
```

Or at minimum, eliminating the `this1 = nil` sentinel:
```elixir
(fn ->
  query = Ecto.Query.from(t in TodoApp.Todo, [])
  query   # Direct return, no this1
end).()
```

## Why This Is Hard

### The Fundamental Issue: Dual IIFE Creation Paths

IIFEs (Immediately-Invoked Function Expressions) like `(fn -> ... end).()` are created in **TWO different places**:

#### Path 1: AST-Level (Transformable)
In `FunctionArgBlockToIIFETransforms.hx`:
```haxe
static inline function makeIIFE(block: ElixirAST): ElixirAST {
    return makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: block }])), "", []));
}
```
This creates proper AST nodes: `ECall(EFn([{body: EBlock}]), "", [])`

#### Path 2: String-Level (NOT Transformable)
In `ElixirASTPrinter.hx` (50+ locations!):
```haxe
'(fn -> ' + print(e, 0).rtrim() + ' end).()'
```
This creates IIFEs as **string concatenation at print time**, AFTER all AST transforms have run.

### The Timing Problem

```
AST Transforms Run Here
         ↓
┌─────────────────────────┐
│  ElixirASTTransformer   │ ← Can see AST-level IIFEs
│  (Pass Registry)        │ ← CANNOT see string-level IIFEs
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│  ElixirASTPrinter       │ ← Creates string-level IIFEs HERE
│  (50+ locations)        │ ← Too late for transforms!
└─────────────────────────┘
         ↓
    Generated .ex file
```

## Existing Cleanup Passes (All Failing)

### 1. `removeRedundantNilInitPass` (ElixirASTTransformer.hx:5116-5482)
- Comprehensive pass that handles EBlock, EFn, EParen
- Should detect `this1 = nil; this1 = value; this1` pattern
- **Status**: Not catching the IIFEs

### 2. `DropTempNilAssignTransforms` (separate file)
- Registered 3 times in pass registry (lines 81-84, 99-102, 2540-2543)
- Filters `thisN = nil` from EBlock and EFn bodies
- **Status**: Debug shows "Found EBlock" but NOT "Found EFn"

### 3. `EFnTempChainSimplifyTransforms`
- Designed to simplify `fn -> this1 = nil; this1 = expr; this1 end` → `fn -> expr end`
- **Status**: Not working on the problematic patterns

## Key Files to Analyze

### Core Problem Files
1. `src/reflaxe/elixir/ast/ElixirASTPrinter.hx` - Where string-level IIFEs are created
2. `src/reflaxe/elixir/ast/ElixirASTTransformer.hx` - The `removeRedundantNilInitPass` and `transformNode`
3. `src/reflaxe/elixir/ast/transformers/DropTempNilAssignTransforms.hx` - The failing cleanup pass
4. `src/reflaxe/elixir/ast/transformers/EFnTempChainSimplifyTransforms.hx` - Another cleanup pass
5. `src/reflaxe/elixir/ast/transformers/FunctionArgBlockToIIFETransforms.hx` - AST-level IIFE creation

### Pass Registry
6. `src/reflaxe/elixir/ast/transformers/registry/groups/HygieneFinal.hx` - Pass registration order
7. `src/reflaxe/elixir/ast/transformers/registry/ElixirASTPassRegistry.hx` - Main registry (large file)

### Generated Problem Code
8. `examples/todo-app/lib/todo_app_web/todo_live.ex` - Shows the actual `this1 = nil` warnings

## Questions for Analysis

1. **Why are string-level IIFEs being created at print time instead of AST level?**
   - Can we refactor the printer to create proper AST nodes that transforms can see?
   - Or should cleanup happen at print time?

2. **Why does `transformNode` visit EBlock but not EFn inside IIFEs?**
   - The code looks correct: ECall targets are transformed, EFn bodies are transformed
   - But debug shows EBlock visited, EFn NOT visited

3. **What's the correct architectural fix?**
   - Move IIFE creation to AST level (builder/transformer phase)?
   - Add string-level cleanup in printer?
   - Fix the pass ordering?

4. **Where does `this1 = nil` originate?**
   - Abstract type constructors generate these sentinels
   - The pattern `var = nil; var = value; var` is a Haxe idiom that doesn't translate well

## Reproduction Steps

```bash
cd examples/todo-app
npx haxe build-server.hxml
mix compile 2>&1 | grep -i "warning.*unused"
```

Expected output shows `this1` unused variable warnings.

## Constraints

- **NO band-aid fixes**: Must fix root cause, not post-process strings
- **NO hardcoded patterns**: Must be general, not specific to `this1`
- **Idiomatic output**: Generated Elixir should look hand-written
- **All tests must pass**: `npm test` from project root

## Summary

The core issue is an **architectural split** between AST-level and string-level IIFE creation. The cleanup passes can only see AST-level IIFEs, but many IIFEs are created as strings at print time. We need either:

1. **Unified IIFE creation at AST level** - All IIFEs as proper nodes
2. **String-level cleanup in printer** - Handle cleanup where IIFEs are created
3. **Pass ordering fix** - Ensure cleanup runs at the right time

This is a fundamental architectural issue, not a simple bug fix.
</file>

<file path="src/reflaxe/elixir/ast/builders/FunctionBuilder.hx">
package reflaxe.elixir.ast.builders;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.ElixirASTDef;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST.EPattern;
import reflaxe.elixir.CompilationContext;
import reflaxe.elixir.ast.analyzers.VariableAnalyzer;
import reflaxe.elixir.ast.ElixirASTHelpers;
import reflaxe.elixir.ast.naming.ElixirNaming;
import reflaxe.elixir.helpers.PatternDetector;
import reflaxe.elixir.helpers.UsageDetector;

using StringTools;

/**
 * FunctionBuilder: Handles Lambda and Anonymous Function Compilation
 * 
 * WHY: Functions (lambdas/anonymous functions) need sophisticated handling for:
 * - Parameter naming and unused parameter detection
 * - Fluent API pattern detection
 * - Variable shadowing and renaming
 * - Abstract "this" parameter handling
 * - Function-local variable scope management
 * 
 * WHAT: Builds ElixirAST function nodes (EFn) from Haxe TFunction expressions
 * - Processes function parameters with proper naming conventions
 * - Detects unused parameters and prefixes with underscore
 * - Handles parameter renaming for shadowed variables
 * - Manages function-local variable scope
 * - Detects and annotates fluent API patterns
 * 
 * HOW: Analyzes function structure and generates idiomatic Elixir functions
 * - Extracts parameter information and detects usage
 * - Converts parameter names to snake_case
 * - Applies underscore prefixing for unused parameters
 * - Builds function body with proper variable mappings
 * - Adds metadata for special patterns (fluent API, etc.)
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Focused solely on function compilation
 * - Reduces ElixirASTBuilder complexity
 * - Centralizes function-specific logic
 * - Testability: Function compilation can be tested independently
 * - Maintainability: Clear boundaries for function handling code
 * 
 * EDGE CASES:
 * - Abstract method "this" parameters (renamed to "this1" by Haxe)
 * - Shadowed parameters with numeric suffixes
 * - Reserved Elixir keywords in parameter names
 * - Empty function bodies
 * - Fluent API patterns returning modified "this"
 */
@:nullSafety(Off)
class FunctionBuilder {
    
    /**
     * Build lambda/anonymous function expression
     * 
     * WHY: Functions are fundamental building blocks that need proper parameter handling
     * WHAT: Converts TFunction to Elixir EFn with proper parameter processing
     * HOW: Analyzes parameters, detects usage, builds body with mappings
     * 
     * @param f The function definition from Haxe
     * @param context Build context with compilation state
     * @return ElixirASTDef for the function or null if cannot build
     */
    public static function build(f: TFunc, context: CompilationContext): Null<ElixirASTDef> {
        #if debug_ast_builder
        trace('[FunctionBuilder] Building function with ${f.args.length} parameters');
        #end
        
        // Detect fluent API patterns (for future use when metadata is extended)
        var fluentPattern = PatternDetector.detectFluentAPIPattern(f);
        
        var args = [];
        var paramRenaming = new Map<String, String>();
        
        // Store the old rename map and create new one for function scope
        var oldTempVarRenameMap = context.tempVarRenameMap;
        context.tempVarRenameMap = new Map();
        for (key in oldTempVarRenameMap.keys()) {
            context.tempVarRenameMap.set(key, oldTempVarRenameMap.get(key));
        }
        
        // Process all parameters
        var isFirstParam = true;
        for (arg in f.args) {
            var processedParam = processParameter(arg, f.expr, context, isFirstParam);
            
            // Add to function signature
            args.push(PVar(processedParam.finalName));
            
            // Track parameter mappings
            if (processedParam.originalName != processedParam.finalName) {
                paramRenaming.set(processedParam.originalName, processedParam.finalName);
            }
            
            // Handle abstract "this" parameters
            if (processedParam.originalName == "this1") {
                paramRenaming.set("this", processedParam.finalName);
                // CRITICAL FIX: Set currentReceiverParamName so VariableBuilder can resolve "this" references
                // Pattern reuse from existing infrastructure - VariableBuilder.hx:434 checks this field
                context.currentReceiverParamName = processedParam.finalName;
            }
            
            isFirstParam = false;
        }
        
        // Build function body with context
        var body = if (context.compiler != null) {
            // CRITICAL FIX: Call ElixirASTBuilder.buildFromTypedExpr directly to preserve context
            // Using compiler.compileExpressionImpl creates a NEW context, losing ClauseContext registrations
            reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(f.expr, context);
        } else {
            null;
        };
        
        // Restore original rename map and clean up
        context.tempVarRenameMap = oldTempVarRenameMap;
        context.currentReceiverParamName = null; // Clear abstract "this" context after function
        for (arg in f.args) {
            context.functionParameterIds.remove(Std.string(arg.v.id));
        }
        
        // Apply parameter renaming if needed
        if (paramRenaming.keys().hasNext() && body != null) {
            body = applyParameterRenaming(body, paramRenaming);
        }
        
        // Create function AST
        var fnAst = makeAST(EFn([{
            args: args,
            guard: null,
            body: body
        }]));
        
        // Note: Fluent API pattern detection is complete but metadata support needs to be added
        // to ElixirMetadata typedef before we can attach this information to the AST node.
        // For now, the pattern is detected but not used in transformation.
        
        return fnAst.def;
    }
    
    /**
     * Process a single function parameter
     * 
     * WHY: Parameters need proper naming, usage detection, and mapping
     * WHAT: Analyzes parameter and returns processing information
     * HOW: Detects usage, handles renaming, applies conventions
     */
    static function processParameter(arg: {v:TVar, value:Null<TypedExpr>}, 
                                    body: Null<TypedExpr>, 
                                    context: CompilationContext,
                                    isFirstParam: Bool): {originalName:String, finalName:String} {
        var originalName = arg.v.name;
        var idKey = Std.string(arg.v.id);
        
        #if debug_variable_renaming
        trace('[FunctionBuilder] Processing parameter "$originalName" (ID: ${arg.v.id})');
        #end
        
        // Detect unused parameters
        var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
            true;  // Marked by Reflaxe preprocessor
        } else if (body != null) {
            !UsageDetector.isParameterUsed(arg.v, body);
        } else {
            // When body is unavailable (macro/analysis edge-cases), fall back to conservative
            // defaults for common Phoenix shapes to keep output idiomatic and warning-free.
            // Specifically, treat typical environment params as unused by default.
            var oname = arg.v.name;
            (oname == "socket" || oname == "_socket" || oname == "conn" || oname == "_conn");
        };
        
        // Check for numeric suffix (parameter shadowing)
        var strippedName = stripNumericSuffix(originalName);
        var hasNumericSuffix = (strippedName != originalName);

        #if debug_variable_renaming
        if (hasNumericSuffix) {
            trace('[FunctionBuilder] Stripped suffix: "$originalName" -> "$strippedName"');
        }
        #end
        
        // Convert to snake_case
        var baseName = ElixirASTHelpers.toElixirVarName(strippedName);
        
        // Check for reserved keywords
        // Use ElixirNaming.isReserved() for complete and consistent keyword detection
        if (ElixirNaming.isReserved(baseName)) {
            baseName = baseName + "_param";
        }
        
        // Prefix with underscore if unused
        var finalName = if (isActuallyUnused && !baseName.startsWith("_")) {
            "_" + baseName;
        } else {
            baseName;
        };
        
        // Register mapping in context with dual-key storage
        if (!context.tempVarRenameMap.exists(idKey)) {
            // Dual-key storage: ID for pattern positions, name for EVar references
            context.tempVarRenameMap.set(idKey, finalName);           // ID-based (pattern matching)
            context.tempVarRenameMap.set(originalName, finalName);    // NAME-based (EVar renaming)

            #if debug_hygiene
            trace('[Hygiene] Dual-key registered: id=$idKey name=$originalName -> $finalName');
            #end
        }
        
        // Register renamed variable if suffix was stripped
        if (hasNumericSuffix && context.astContext != null) {
            context.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);
        }
        
        // Track first parameter as receiver for instance methods
        if (isFirstParam && context.isInClassMethodContext) {
            context.currentReceiverParamName = finalName;
        }
        
        // Mark as function parameter
        context.functionParameterIds.set(idKey, true);
        
        return {
            originalName: originalName,
            finalName: finalName
        };
    }
    
    /**
     * Strip numeric suffix from shadowed parameter names
     * 
     * WHY: Haxe adds numeric suffixes to handle shadowing
     * WHAT: Removes suffixes like "2" or "3" from common field names
     * HOW: Pattern matches and checks against common field names
     */
    static function stripNumericSuffix(name: String): String {
        var pattern = ~/^(.+?)(\d+)$/;
        if (!pattern.match(name)) {
            return name;
        }
        
        var base = pattern.matched(1);
        var suffix = pattern.matched(2);
        
        // Common field names that get shadowed
        var commonFieldNames = ["options", "columns", "name", "value",
                               "type", "data", "fields", "items", "priority"];
        
        // Only strip if it looks like shadowing
        if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(base) >= 0) {
            return base;
        }
        
        return name;
    }

    /**
     * Apply parameter renaming to function body
     * 
     * WHY: Parameter names might change, body needs updating
     * WHAT: Replaces variable references with renamed versions
     * HOW: Traverses AST and updates EVar nodes
     */
    static function applyParameterRenaming(ast: ElixirAST, renaming: Map<String, String>): ElixirAST {
        if (ast == null) return null;
        
        var def = switch(ast.def) {
            case EVar(name):
                if (renaming.exists(name)) {
                    EVar(renaming.get(name));
                } else {
                    ast.def;
                }
                
            case EBlock(exprs):
                EBlock([for (e in exprs) applyParameterRenaming(e, renaming)]);
                
            case EIf(cond, then, els):
                EIf(applyParameterRenaming(cond, renaming),
                    applyParameterRenaming(then, renaming),
                    applyParameterRenaming(els, renaming));
                
            default:
                // For other cases, return as-is
                // A more complete implementation would traverse all node types
                ast.def;
        };
        
        return makeAST(def);
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/transformers/registry/groups/HygieneFinal.hx">
package reflaxe.elixir.ast.transformers.registry.groups;

#if (macro || reflaxe_runtime)
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * HygieneFinal
 *
 * WHAT
 * - Ultra-late hygiene/safety/sweep passes extracted from the registry with no behavior change.
 * - Includes numeric-sentinel cleanup, assignment-chain simplifications, usage-driven binder fixes,
 *   late query binder handling, and small runtime-safe normalizations.
 *
 * WHY
 * - Keep the central registry readable by modularizing large late-stage cleanup logic while preserving order.
 * - Makes the deterministic registry order document easier to audit.
 *
 * HOW
 * - Returns the exact PassConfig list previously pushed inline, in the identical order.
 * - Some passes reference runAfter constraints that remain valid across groups; ordering is preserved
 *   by the registry’s stable topological sort.
 */
class HygieneFinal {
  public static function build():Array<ElixirASTTransformer.PassConfig> {
    var passes:Array<ElixirASTTransformer.PassConfig> = [];

    passes.push({
      name: "AccAliasLateRewrite",
      description: "Rewrite alias self-append to acc within any two-arg EFn (ultra-final safety)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.AccAliasLateRewriteTransforms.transformPass
    });

    passes.push({
      name: "ReduceStrictSelfAppendRewrite",
      description: "Rebuild reduce body to acc concat when alias self-append detected (structural)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ReduceStrictSelfAppendRewriteTransforms.transformPass
    });

    // ERaw reduce canonicalization
    passes.push({
      name: "ReduceERawAliasCanonicalize",
      description: "Canonicalize alias concat and binder alias inside ERaw Enum.reduce bodies (ultra-final)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ReduceERawAliasCanonicalizeTransforms.transformPass
    });

    // Case binder hygiene
    passes.push({
      name: "CaseBinderRebindUnderscore",
      description: "In case arms, underscore binders that are immediately rebound before use",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.CaseBinderRebindUnderscoreTransforms.pass
    });

    // Pin existing bindings in case patterns to avoid shadowing
    passes.push({
      name: "CaseClausePinExistingBindings",
      description: "Pin variables in case clause patterns when matching existing in-scope bindings",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.CaseClausePinExistingBindingsTransforms.pass
    });

    // Normalize list concat into direct list literal for nested match patterns
    passes.push({
      name: "ConcatListLiteralNormalize",
      description: "Rewrite lhs = _ = [] ++ [expr] and lhs = [] ++ [expr] into lhs = [expr]",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ConcatListLiteralNormalizeTransforms.pass
    });

    // Numeric sentinel and temp-nil cleanup
    passes.push({
      name: "DropStandaloneLiteralOne",
      description: "Drop stray 1/0/0.0 literals in blocks, do-blocks, EFn bodies (ultra-final)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DropStandaloneLiteralOneTransforms.dropPass
    });
    passes.push({
      name: "DropTempNilAssign",
      description: "Drop thisN/_thisN = nil sentinel assignments",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DropTempNilAssignTransforms.pass
    });
    passes.push({
      name: "ReduceResultUnusedUnderscore",
      description: "Underscore binders in reduce/reduce_while result match when unused later in block",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ReduceResultUnusedUnderscoreTransforms.transformPass
    });
    passes.push({
      name: "ReduceWhileSentinelCleanup",
      description: "Final sweep: drop numeric sentinel literals inside reduce_while bodies",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ReduceWhileSentinelCleanupTransforms.transformPass
    });
    passes.push({
      name: "DropTempNilAssign",
      description: "Last guard: drop thisN/_thisN = nil sentinels if any got reintroduced",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DropTempNilAssignTransforms.pass
    });

    // Late scoped underscore (disabled; keep for parity)
    passes.push({
      name: "LocalAssignUnderscoreLate",
      description: "Underscore local assigns when unused later; also nested inner assigns",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.LocalAssignUnderscoreLateTransforms.pass
    });

    // EFn and assignment-chain simplifications
    passes.push({
      name: "EFnTempChainSimplify",
      description: "Inside EFn, rewrite var=nil; var=expr; var → expr",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.EFnTempChainSimplifyTransforms.pass
    });
    passes.push({
      name: "TrailingTempReturnSimplify",
      description: "Replace trailing temp returns with the rhs expression",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.TrailingTempReturnSimplifyTransforms.pass
    });
    // Move NestedAssignCollapseGlobal to the very end to catch any reintroduced chains
    passes.push({
      name: "NestedAssignCollapseGlobal",
      description: "(disabled here; re-added at end) Collapse nested chain assignments outer=(inner=expr) → outer=expr",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.NestedAssignCollapseGlobalTransforms.pass
    });
    passes.push({
      name: "DefTrailingAssignedVarReturn",
      description: "Append trailing var when last statement is assignment to non-temp",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DefTrailingAssignedVarReturnTransforms.pass
    });
    passes.push({
      name: "EctoChangesetReturnFix",
      description: "(disabled) Legacy fix that appended cs; superseded by ChangesetEnsureReturn",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.EctoChangesetReturnFixTransforms.pass
    });
    passes.push({
      name: "ChangesetChainCleanup",
      description: "Collapse changeset nested assigns cs/thisN → direct cs assign",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ChangesetChainCleanupTransforms.pass
    });

    // Late query binder handling
    passes.push({
      name: "QueryBinderSynthesisLate",
      description: "Insert `query = String.downcase(search_query)` before Enum.filter when predicate uses `query` and no prior binder exists",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.QueryBinderSynthesisLateTransforms.transformPass
    });
    passes.push({
      name: "FilterPredicateInlineQuery",
      description: "Inline `query` to `String.downcase(search_query)` inside Enum.filter predicates",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.FilterPredicateInlineQueryTransforms.transformPass
    });
    passes.push({
      name: "FilterPredicateQueryInline_UltraFinal",
      description: "Ultra-final safeguard to inline `query` in Enum.filter predicates when only search_query exists",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.FilterPredicateQueryInlineUltraFinalTransforms.pass
    });
    passes.push({
      name: "QueryBinderSynthesis_UltraFinal",
      description: "Ultra-final: insert `query = String.downcase(search_query)` before Enum.filter when predicate uses `query` and no prior binder exists",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.QueryBinderSynthesisUltraFinalTransforms.pass
    });

    // Debug (kept enabled as in registry)
    passes.push({
      name: "DebugCaseBinderUndefScan",
      description: "Debug-only: log binder and undefined locals in case clauses",
      enabled: #if debug_case_binder_undef_scan true #else false #end,
      pass: reflaxe.elixir.ast.transformers.DebugCaseBinderUndefScanTransforms.pass
    });

    // Optional discards
    passes.push({
      name: "BlockUnusedAssignmentDiscard",
      description: "Rewrite var = expr to _ = expr in function bodies when var unused later",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.BlockUnusedAssignmentDiscardTransforms.pass
    });

    // Changeset return/binder repairs
    passes.push({
      name: "DropUnusedDowncaseWildcardAssign",
      description: "Drop `_ = String.downcase(search_query)` in blocks (pure, unused)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DropUnusedDowncaseWildcardAssignTransforms.transformPass
    });
    passes.push({
      name: "ChangesetEnsureReturn",
      description: "Ensure functions building Ecto.Changeset return last assigned var",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ChangesetEnsureReturnTransforms.pass
    });
    passes.push({
      name: "ChangesetBareCsRepair",
      description: "Repair changeset/2 bodies reduced to bare cs by reconstructing change(p1, p2)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ChangesetBareCsRepairTransforms.pass
    });
    passes.push({
      name: "LateEnsureCsBinder",
      description: "Ensure `cs` binder exists by rewriting earliest cast/change producer to `cs = ...` (late)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.LateEnsureCsBinderTransforms.pass
    });

    // Global temp/Repo helpers
    passes.push({
      name: "TempAssignFlattenGlobal",
      description: "Flatten temp alias chains globally: outer=(temp=expr) → outer=expr",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.TempAssignFlattenGlobalTransforms.pass
    });
    passes.push({
      name: "RepoGetBinderRepair",
      description: "Rewrite bodies that return an undeclared var v to Repo.get(schema(v), firstParam)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.pass
    });
    passes.push({
      name: "BareGetterRepoGetRepair",
      description: "For bare-var function bodies in Repo modules, rewrite to Repo.get(:var, id)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.BareGetterRepoGetRepairTransforms.pass
    });

    // Param hygiene
    passes.push({
      name: "DefParamUnusedUnderscoreSafe",
      description: "Underscore unused def parameters when truly unused (safe)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DefParamUnusedUnderscoreSafeTransforms.pass
    });
    passes.push({
      name: "DefParamUnusedUnderscoreGlobalSafe",
      description: "Globally underscore unused function params when provably unused (disabled)",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.DefParamUnusedUnderscoreGlobalSafeTransforms.pass
    });
    passes.push({
      name: "ParamUnderscoreUsedRepair",
      description: "Rename `_name` to `name` for parameters used in function body (disabled for runtime stabilization)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ParamUnderscoreUsedRepairTransforms.pass
    });
    passes.push({
      name: "ChangesetParamUsedRepair",
      description: "In changeset/2, rename underscored params to base names when body uses base (disabled for stabilization)",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.ChangesetParamUsedRepairTransforms.pass
    });
    passes.push({
      name: "ChangesetBodyAlignToParam",
      description: "Rewrite body vars user/attrs to _user/_attrs when params are underscored (disabled for stabilization)",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.ChangesetBodyAlignToParamTransforms.pass
    });
    passes.push({
      name: "ChangesetParamUnderscore",
      description: "Prefix unused params with underscore in changeset functions (final order)",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.ChangesetParamUnderscoreTransforms.pass
    });

    // App start helper
    passes.push({
      name: "ApplicationEnsureStartLink",
      description: "Ensure Application.start/2 appends Supervisor.start_link(children, opts) (ultra final)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.ApplicationEnsureStartLinkTransforms.transformPass
    });

    // Wildcard and pinned var promotions
    passes.push({
      name: "WildcardPromoteByUndeclaredUse",
      description: "Final promotion of `_ = rhs` to binder by targeted usage (length/assign/DateTime)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.WildcardPromoteByUndeclaredUseTransforms.pass
    });
    passes.push({
      name: "PinnedVarBinderPromote",
      description: "Promote `_ = <literal>` to `<name> = <literal>` when a unique ^(name) is used later",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.PinnedVarBinderPromoteTransforms.pass
    });
    passes.push({
      name: "EctoWherePinnedBinderRepair",
      description: "Repair wildcard literal binder before where/2 that pins its value later",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.EctoWherePinnedBinderRepairTransforms.pass
    });

    // Post-final query binder enforcement and cleanup
    passes.push({
      name: "QueryBinderFinalization",
      description: "Enforce `query = String.downcase(search_query)` at the very end when a different binder name slipped through",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.QueryBinderFinalizationTransforms.transformPass
    });
    passes.push({
      name: "DropResidualWildcardDowncase",
      description: "Drop stray `_ = String.downcase(search_query)` after establishing `query` binder (post-final)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DropResidualWildcardDowncasePostTransforms.transformPass
    });

    // Ultimate EFns and small global safety helpers
    passes.push({
      name: "EFnNumericSentinelCleanup",
      description: "Ultimate pass to remove 0/1/0.0 numeric sentinel statements inside EFns",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.EFnNumericSentinelCleanupTransforms.cleanupPass
    });
    passes.push({
      name: "SelfAssignCompression",
      description: "Ultimate replay: compress duplicated self-assignments x = x = expr to x = expr",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.BinderTransforms.selfAssignCompressionPass
    });
    passes.push({
      name: "DuplicateEffectfulCallPrune",
      description: "Remove immediately duplicated effectful calls prior to case on same call",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DuplicateEffectfulCallPruneTransforms.pass
    });
    passes.push({
      name: "DuplicateCaseAssignFold",
      description: "Fold var = _ = call; case call do ... end -> var = case call do ... end",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.DuplicateCaseAssignFoldTransforms.pass
    });
    passes.push({
      name: "SafePubSubAliasInject",
      description: "Ultimate alias injection for Phoenix.SafePubSub as SafePubSub",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.SafePubSubAliasInjectTransforms.injectPass
    });
    passes.push({
      name: "SafePubSubConverterCapture",
      description: "Ensure parse_with_converter/2 receives a function capture (&mod.func/1)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.SafePubSubConverterCaptureTransforms.pass
    });
    passes.push({
      name: "UnderscoreTempInlineDowncase",
      description: "Inline _tmp followed by String.downcase(_tmp) to String.downcase(rhs)",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.UnderscoreTempInlineDowncaseTransforms.pass,
      runAfter: ["LocalUnderscoreBinderPromotionWhenUsed_Final"]
    });
    // (Concat identity normalization folded into existing loop transforms; no extra pass here)
    passes.push({
      name: "DowncaseInlineFromPriorAssign_Final",
      description: "Inline prior assignments into String.downcase(var) and drop the assignment when safe",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.DowncaseInlineFromPriorAssignTransforms.pass,
      runAfter: ["UnderscoreTempInlineDowncase"]
    });
    passes.push({
      name: "LocalAssignUnusedUnderscore_Global_Final",
      description: "Absolute-final: underscore unused local assignment binders across blocks/functions",
      enabled: false,
      pass: reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreGlobalFinalTransforms.pass,
      runAfter: ["DowncaseInlineFromPriorAssign_Final"]
    });

    // Re-add NestedAssignCollapseGlobal as absolute-final cleanup
    passes.push({
      name: "NestedAssignCollapseGlobal_Final",
      description: "Absolute-final: collapse nested assignments outer=(inner=expr) → outer=expr across all nodes",
      enabled: true,
      pass: reflaxe.elixir.ast.transformers.NestedAssignCollapseGlobalTransforms.pass
    });

    // NOTE: FinalUnderscoreRepair is registered in ElixirASTPassRegistry.hx (outside fast_boot guard)
    // to ensure it runs even in fast_boot mode since it's a critical Phase 1.3 fix

    return passes;
  }
}
#end
</file>

<file path="src/reflaxe/elixir/ast/transformers/FunctionArgBlockToIIFETransforms.hx">
package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * FunctionArgBlockToIIFETransforms
 *
 * WHAT
 * - Ensures any multi-statement block used as a function argument is converted
 *   to an immediately-invoked anonymous function (IIFE), yielding a single
 *   valid expression in argument position.
 *
 * WHY
 * - Raw multi-statement blocks are invalid in argument position and lead to
 *   syntax errors (e.g., in Enum.join(<block>, ",")). Wrapping as an IIFE is
 *   idiomatic and preserves semantics.
 *
 * HOW
 * - Walk ECall/ERemoteCall nodes and wrap any argument whose def is EBlock
 *   with two or more statements: (fn -> <block> end).()
 */
class FunctionArgBlockToIIFETransforms {
    public static function pass(ast: ElixirAST): ElixirAST {
        return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case ECall(target, name, args):
                    var newArgs = [];
                    for (a in args) if (shouldWrap(a)) {
                        #if debug_iife
                        trace('[FunctionArgBlockToIIFE] wrapping arg for ' + (name == null ? '<anon>' : name));
                        #end
                        newArgs.push(makeIIFE(unwrapParens(a)));
                    } else newArgs.push(a);
                    if (newArgs != args) makeAST(ECall(target, name, newArgs)) else n;
                case ERemoteCall(mod, fnName, argsList):
                    var rewrittenArgs = [];
                    for (argNode in argsList) if (shouldWrap(argNode)) {
                        #if debug_iife
                        trace('[FunctionArgBlockToIIFE] wrapping arg for remote ' + fnName);
                        #end
                        rewrittenArgs.push(makeIIFE(unwrapParens(argNode)));
                    } else rewrittenArgs.push(argNode);
                    if (rewrittenArgs != argsList) makeAST(ERemoteCall(mod, fnName, rewrittenArgs)) else n;
                default:
                    n;
            }
        });
    }

    static inline function unwrapParens(e: ElixirAST): ElixirAST {
        return switch (e.def) {
            case EParen(inner): inner;
            default: e;
        }
    }

    static inline function isNumericSentinel(e: ElixirAST): Bool {
        return switch (e.def) {
            case EInteger(v) if (v == 0 || v == 1): true;
            case EFloat(f) if (f == 0.0): true;
            default: false;
        }
    }

    static inline function shouldWrap(a: ElixirAST): Bool {
        function needsWrapFor(sts:Array<ElixirAST>):Bool {
            if (sts == null) return false;
            // Ignore bare numeric sentinels often emitted by earlier passes
            var filtered = [];
            for (s in sts) if (!isNumericSentinel(s)) filtered.push(s);
            // If any top-level element is already an anonymous function, don't wrap
            for (s in filtered) switch (s.def) { case EFn(_): return false; default: }
            // Otherwise, wrap only if there are multiple meaningful statements
            return filtered.length > 1;
        }

        return switch (a.def) {
            case EBlock(sts): needsWrapFor(sts);
            case EDo(statements): needsWrapFor(statements);
            case EParen(inner):
                switch (inner.def) {
                    case EBlock(es): needsWrapFor(es);
                    case EDo(exprs): needsWrapFor(exprs);
                    default: false;
                }
            default: false;
        }
    }

    static inline function makeIIFE(block: ElixirAST): ElixirAST {
        return makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: block }])), "", []));
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/ElixirASTPrinter.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTBuilder;
using StringTools;

/**
 * ElixirASTPrinter: ElixirAST to String Generator (Generation Phase)
 * 
 * WHY: Final phase of the three-phase pipeline, converts AST to code
 * - Pure string generation with no logic or transformation
 * - Maintains Elixir syntax rules and formatting conventions
 * - Separates formatting concerns from compilation logic
 * - Enables consistent output regardless of AST source
 * 
 * WHAT: Converts ElixirAST nodes to properly formatted Elixir code
 * - Handles all AST node types with appropriate syntax
 * - Manages indentation and line breaks for readability
 * - Respects Elixir conventions (snake_case, atoms, etc.)
 * - Produces idiomatic, human-readable Elixir code
 * 
 * HOW: Recursive traversal with string building
 * - Pattern matches on AST node types
 * - Builds strings with proper formatting
 * - Handles operator precedence and parenthesization
 * - Manages indentation state through recursion
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Only handles string generation
 * - Testability: Output can be validated against expected strings
 * - Maintainability: Formatting changes isolated from logic
 * - Flexibility: Can easily adjust output style without touching compiler
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTPrinter {

    // Counter for generating unique loop function names
    static var loopIdCounter: Int = 0;

    // Track current module's unused functions for dead code elimination
    static var currentUnusedFunctions: Null<Array<String>> = null;
    
    /**
     * Public API for printing a single AST (used by ElixirASTBuilder for injection)
     *
     * WHY: ElixirASTBuilder needs to convert AST nodes to strings for __elixir__ parameter substitution
     * WHAT: Converts a single ElixirAST node to string without indentation
     * HOW: Calls main print function with zero indentation
     */
    public static function printAST(ast: ElixirAST, ?context: reflaxe.elixir.CompilationContext): String {
        // Context will be used in future for context-aware printing
        return print(ast, 0);
    }
    
    /**
     * Main entry point: Convert ElixirAST to formatted string
     *
     * WHY: Single public interface for all printing needs
     * WHAT: Recursively converts AST tree to formatted Elixir code
     * HOW: Delegates to specific handlers based on node type
     */
    // Track current module name to enable context-aware printing (e.g., Repo qualification)
    static var currentModuleName: Null<String> = null;
    static var observedAppPrefix: Null<String> = null;

    public static function print(ast: ElixirAST, indent: Int = 0): String {
        // Handle null nodes
        if (ast == null) {
            return "";
        }

        #if debug_ast_printer
        trace('[XRay AST Printer] Printing node: ${ast.def}');
        #end

        // Handle EDefmodule and EModule specially to access metadata
        var result = switch(ast.def) {
            case EDefmodule(name, doBlock):
                // Extract unused functions from metadata if available
                if (ast.metadata != null && ast.metadata.unusedPrivateFunctions != null) {
                    currentUnusedFunctions = ast.metadata.unusedPrivateFunctions;
                }

                var moduleContent = '';

                // Add @compile directive to silence unused private functions (late sweep)
                // Compute defp names/arity directly from doBlock
                var nowarnList: Array<String> = [];
                // Unwrap parentheses around the module do-block to avoid stray parentheses lines
                var doBlockUnwrapped = switch (doBlock.def) { case EParen(inner): inner; default: doBlock; };
                switch (doBlockUnwrapped.def) {
                    case EBlock(stmts):
                        for (s in stmts) switch (s.def) {
                            case EDefp(fnName, fnArgs, _, _):
                                var arity = fnArgs.length;
                                nowarnList.push(fnName + ': ' + arity);
                            default:
                        }
                    default:
                }
                // Printer de-semanticization: do not inject @compile here; handled by transforms if needed

                // Preserve and set current module context
                var prevModule = currentModuleName;
                currentModuleName = name;

                // Capture observed app prefix if this is an <App>.Repo module
                if (observedAppPrefix == null) {
                    var idxCap = name.indexOf(".Repo");
                    if (idxCap > 0) observedAppPrefix = name.substring(0, idxCap);
                    var idxWeb = name.indexOf("Web");
                    if (idxWeb > 0) observedAppPrefix = name.substring(0, idxWeb);
                }

                // Optional alias injection for Repo in non-Web modules
                inline function needsRepoAliasInBlock(block: ElixirAST): Bool {
                    var hasAlias = false;
                    var hasBare = false;
                    switch (block.def) {
                        case EBlock(stmts):
                            for (s in stmts) switch (s.def) {
                                case EAlias(module, as) if ((as == null || as == "Repo")):
                                    if (module != null && module.indexOf(".Repo") > 0) hasAlias = true;
                                default:
                            }
                            // scan for bare repo like above
                            function scan(n: ElixirAST): Void {
                                if (n == null || n.def == null || hasBare) return;
                                switch (n.def) {
                                    case ERemoteCall({def: EVar(m)}, _, _): if (m == "Repo") hasBare = true;
                                    case ECall({def: EVar(m)}, _, _): if (m == "Repo") hasBare = true;
                                    case EBlock(es): for (e in es) scan(e);
                                    case EIf(c, t, e): scan(c); scan(t); if (e != null) scan(e);
                                    case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                                    case ECond(cs): for (cl in cs) { scan(cl.condition); scan(cl.body); }
                                    case EMatch(_, rhs): scan(rhs);
                                    case EBinary(_, l, r): scan(l); scan(r);
                                    case ERemoteCall(m, _, args): scan(m); for (a in args) scan(a);
                                    case ECall(t, _, args): if (t != null) scan(t); for (a in args) scan(a);
                                    default:
                                }
                            }
                            for (s in stmts) scan(s);
                        default:
                    }
                    return (hasBare && !hasAlias);
                }
                // Printer de-semanticization: do not inject Repo alias here

                // Ensure alias Phoenix.SafePubSub as SafePubSub when bare SafePubSub references exist
                inline function needsSafePubSubAliasInBlock(block: ElixirAST): Bool {
                    var hasAlias = false;
                    var needs = false;
                    switch (block.def) {
                        case EBlock(stmts) | EDo(stmts):
                            for (s in stmts) switch (s.def) {
                                case EAlias(module, as) if (as == "SafePubSub" || module == "Phoenix.SafePubSub"): hasAlias = true;
                                default:
                            }
                            function scan(n: ElixirAST): Void {
                                if (n == null || n.def == null || needs) return;
                                switch (n.def) {
                                    case ERemoteCall({def: EVar(m)}, _, _) if (m == "SafePubSub"): needs = true;
                                    case ECall({def: EVar(m2)}, _, _) if (m2 == "SafePubSub"): needs = true;
                                    case EVar(v) if (v == "SafePubSub"): needs = true;
                                    case ERaw(code): if (code != null && code.indexOf("SafePubSub.") != -1) needs = true;
                                    case EDef(_, _, _, b): scan(b);
                                    case EDefp(_, _, _, privateBody): scan(privateBody);
                                    case EBlock(es): for (e in es) scan(e);
                                    case EIf(c, t, e): scan(c); scan(t); if (e != null) scan(e);
                                    case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                                    case EBinary(_, l, r): scan(l); scan(r);
                                    case ERemoteCall(m,_,as): scan(m); if (as != null) for (a in as) scan(a);
                                    case ECall(t,_,argsList): if (t != null) scan(t); if (argsList != null) for (a in argsList) scan(a);
                                    default:
                                }
                            }
                            for (s in stmts) scan(s);
                        default:
                    }
                    return needs && !hasAlias;
                }
                // Printer de-semanticization: SafePubSub alias handled by transforms

                // Ensure `require Ecto.Query` in Web modules (LiveView/Controller often use Ecto DSL)
                // This avoids macro-availability errors; harmless if unused
                // Printer de-semanticization: Ecto.Query require handled by transforms

                // Ensure `require Ecto.Query` when Ecto.Query macros are used in the module body
                inline function needsEctoRequireInBlock(block: ElixirAST): Bool {
                    var needs = false;
                    var has = false;
                    switch (block.def) {
                        case EBlock(stmts) | EDo(stmts):
                            for (s in stmts) switch (s.def) {
                                case ERequire(mod, _): if (mod == "Ecto.Query") has = true;
                                default:
                            }
                            function scan(n: ElixirAST): Void {
                                if (n == null || n.def == null || needs) return;
                                switch (n.def) {
                                    case ERemoteCall({def: EVar(m)}, _, _): if (m == "Ecto.Query") needs = true;
                                    case ECall(t, _, args): if (t != null) scan(t); for (a in args) scan(a);
                                    case EDef(_, _, _, body): scan(body);
                                    case EDefp(_, _, _, body): scan(body);
                                    case EBlock(es): for (e in es) scan(e);
                                    case EIf(c,t,e): scan(c); scan(t); if (e != null) scan(e);
                                    case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                                    case EBinary(_, l, r): scan(l); scan(r);
                                    case EFn(cs): for (cl in cs) scan(cl.body);
                                    default:
                                }
                            }
                            for (s in stmts) scan(s);
                        default:
                    }
                    return needs && !has;
                }
                // Printer de-semanticization: Ecto.Query require handled by transforms

                // Inject `require Ecto.Query` when remote Ecto.Query macros are present in the body
                if (needsEctoRequireInBlock(doBlockUnwrapped)) {
                    moduleContent += indentStr(indent + 1) + 'require Ecto.Query\n';
                }

                // Special-case: if the do-block is a raw block (EBlock with single ERaw),
                // print its contents directly without extra parentheses or indentation.
                moduleContent += (switch (doBlockUnwrapped.def) {
                    case EBlock(stmts) if (stmts.length == 1):
                        switch (stmts[0].def) {
                            case ERaw(code):
                                var c = code;
                                if (!StringTools.endsWith(c, "\n")) c += "\n";
                                c;
                            default:
                                indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);
                        }
                    default:
                        indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);
                });

                // Restore context
                currentModuleName = prevModule;

                var moduleResult = 'defmodule ${name} do\n' +
                    moduleContent + '\n' +
                    indentStr(indent) + 'end\n';

                // Clear unused functions after module is printed
                currentUnusedFunctions = null;
                moduleResult;

            case EModule(name, attributes, body):
                // Check if this is an exception class
                var isException = ast.metadata != null && ast.metadata.isException == true;
                
                if (isException) {
                    // For exceptions, use defmodule with defexception inside
                    // This is the proper Elixir pattern for custom exceptions
                    var result = 'defmodule ${name} do\n';
                    result += indentStr(indent + 1) + 'defexception [:message]\n';
                    // Set module context while printing body for proper qualification
                    var prevModuleCtx = currentModuleName;
                    currentModuleName = name;
                    
                    // Print any other methods (like toString)
                    for (expr in body) {
                        // Skip defstruct calls as defexception handles that
                        var exprStr = print(expr, indent + 1);
                        if (!exprStr.startsWith("defstruct")) {
                            result += '\n' + indentStr(indent + 1) + exprStr + '\n';
                        }
                    }
                    // Restore printer module context
                    currentModuleName = prevModuleCtx;
                    
                    result += indentStr(indent) + 'end\n';
                    result;
                } else {
                    // Regular module
                    var result = 'defmodule ${name} do\n';
                    // Printer de-semanticization: do not inject @compile here; handled by transforms if needed
                    // Preserve and set current module context for body printing
                    var prevModuleCtx = currentModuleName;
                    currentModuleName = name;

                    // Inject alias Phoenix.SafePubSub as SafePubSub when bare references exist in EModule body
                    inline function moduleNeedsSafePubSubAlias(stmts: Array<ElixirAST>): Bool {
                        var hasAlias = false;
                        var needs = false;
                        for (s in stmts) switch (s.def) {
                            case EAlias(module, as) if (as == 'SafePubSub' || module == 'Phoenix.SafePubSub'): hasAlias = true;
                            default:
                        }
                        function scan(n: ElixirAST): Void {
                            if (needs || n == null || n.def == null) return;
                            switch (n.def) {
                                case ERemoteCall({def: EVar(m)}, _, _) if (m == 'SafePubSub'): needs = true;
                                case ECall({def: EVar(m2)}, _, _) if (m2 == 'SafePubSub'): needs = true;
                                case EVar(v) if (v == 'SafePubSub'): needs = true;
                                case ERaw(code): if (code != null && code.indexOf('SafePubSub.') != -1) needs = true;
                                case EDef(_, _, _, b): scan(b);
                                case EDefp(_, _, _, privateBody): scan(privateBody);
                                case EBlock(es): for (e in es) scan(e);
                                case EIf(c, t, e): scan(c); scan(t); if (e != null) scan(e);
                                case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                                case EBinary(_, l, r): scan(l); scan(r);
                                case ERemoteCall(m,_,as): scan(m); if (as != null) for (a in as) scan(a);
                                case ECall(t,_,argsList): if (t != null) scan(t); if (argsList != null) for (a in argsList) scan(a);
                                default:
                            }
                        }
                        for (s in stmts) scan(s);
                        return needs && !hasAlias;
                    }
                    // Printer de-semanticization: SafePubSub alias handled by transforms
                    
                    // Print attributes
                    for (attr in attributes) {
                        result += indentStr(indent + 1) + printAttribute(attr) + '\n';
                    }
                    
                    if (attributes.length > 0 && body.length > 0) {
                        result += '\n';
                    }
                    
                    // Capture observed app prefix if this is an <App>.Repo module
                    if (observedAppPrefix == null) {
                        var idxCap2 = name.indexOf(".Repo");
                        if (idxCap2 > 0) observedAppPrefix = name.substring(0, idxCap2);
                        var idxWeb2 = name.indexOf("Web");
                        if (idxWeb2 > 0) observedAppPrefix = name.substring(0, idxWeb2);
                    }
                    // In Web modules, proactively require Ecto.Query for macro usage
                    // Printer de-semanticization: Ecto.Query require handled by transforms
                    // Inject `require Ecto.Query` when remote Ecto.Query macros are present in the body
                    var needsEcto = (function():Bool {
                        // Local helper for EModule body
                        inline function bodyHasEctoRemote(stmts:Array<ElixirAST>): Bool {
                            var found = false;
                            function scan(n: ElixirAST): Void {
                                if (found || n == null || n.def == null) return;
                                switch (n.def) {
                                    case ERequire(mod, _): // ignore existing requires for detection
                                    case ERemoteCall(mod, _, args):
                                        switch (mod.def) { case EVar(m) if (m == 'Ecto.Query'): found = true; default: }
                                        if (args != null) for (a in args) scan(a);
                                    case ERaw(code): if (code != null && code.indexOf('Ecto.Query.') != -1) found = true;
                                    case ECall(t,_,as): if (t != null) scan(t); if (as != null) for (a in as) scan(a);
                                    case EBlock(es): for (e in es) scan(e);
                                    case EDo(es2): for (e in es2) scan(e);
                                    case EIf(c,t,e): scan(c); scan(t); if (e != null) scan(e);
                                    case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                                    case EBinary(_, l, r): scan(l); scan(r);
                                    case EFn(cs): for (cl in cs) scan(cl.body);
                                    case EDef(_,_,_,b): scan(b);
                                    case EDefp(_,_,_,privateBody): scan(privateBody);
                                    default:
                                }
                            }
                            for (s in stmts) scan(s);
                            return found;
                        }
                        return bodyHasEctoRemote(body);
                    })();
                    if (needsEcto) {
                        result += indentStr(indent + 1) + 'require Ecto.Query\n';
                    }

                    // Print body
                    for (expr in body) {
                        // Unwrap raw EBlock([ERaw(...)]) bodies to avoid stray parentheses and double indentation
                        switch (expr.def) {
                            case EBlock(stmts) if (stmts.length == 1):
                                switch (stmts[0].def) {
                                    case ERaw(code):
                                        var c = code;
                                        if (!StringTools.endsWith(c, "\n")) c += "\n";
                                        result += c; // code already contains its own indentation
                                    default:
                                        result += indentStr(indent + 1) + print(expr, indent + 1) + '\n';
                                }
                            default:
                                result += indentStr(indent + 1) + print(expr, indent + 1) + '\n';
                        }
                    }
                    // Restore printer module context
                    currentModuleName = prevModuleCtx;
                    
                    result += indentStr(indent) + 'end\n';
                    result;
                }

            default:
                printNode(ast.def, indent);
        };

        #if debug_ast_printer
        trace('[XRay AST Printer] Generated: ${result.substring(0, 100)}...');
        #end

        return result;
    }
    
    /**
     * Print a single AST node
     */
    static function printNode(node: ElixirASTDef, indent: Int): String {
        return switch(node) {
            // ================================================================
            // Modules and Structure
            // ================================================================
            case EModule(name, attributes, body):
                // Check if this is an exception class from metadata
                // Note: We need access to the full AST node to check metadata
                // This is handled in the main print() function, not here
                // For now, generate regular defmodule
                var result = 'defmodule ${name} do\n';
                // Preserve and set current module name while printing this module body
                var prevModuleCtx = currentModuleName;
                currentModuleName = name;
                
                // Print attributes
                for (attr in attributes) {
                    result += indentStr(indent + 1) + printAttribute(attr) + '\n';
                }
                
                if (attributes.length > 0 && body.length > 0) {
                    result += '\n';
                }
                
                // Inject alias <App>.Repo as Repo in non-Web modules when bare Repo.* is referenced
                inline function needsRepoAlias(stmts: Array<ElixirAST>): Bool {
                    var hasAlias = false;
                    var hasBare = false;
                    for (s in stmts) switch (s.def) {
                        case EAlias(module, as) if ((as == null || as == "Repo")):
                            // Any alias to *.Repo counts
                            if (module != null && module.indexOf(".Repo") > 0) hasAlias = true;
                        default:
                    }
                    // Scan for bare Repo usage by walking AST
                    function scan(n: ElixirAST): Void {
                        if (n == null || n.def == null || hasBare) return;
                        switch (n.def) {
                            case ERemoteCall({def: EVar(m)}, _, _): if (m == "Repo") hasBare = true;
                            case ECall({def: EVar(m)}, _, _): if (m == "Repo") hasBare = true;
                            case EDef(_, _, _, body): scan(body);
                            case EDefp(_, _, _, body): scan(body);
                            case EBlock(es): for (e in es) scan(e);
                            case EIf(c, t, e): scan(c); scan(t); if (e != null) scan(e);
                            case ECase(e, cs): scan(e); for (cl in cs) { if (cl.guard != null) scan(cl.guard); scan(cl.body); }
                            case ECond(cs): for (cl in cs) { scan(cl.condition); scan(cl.body); }
                            case EMatch(pat, rhs): scan(rhs);
                            case EBinary(_, l, r): scan(l); scan(r);
                            case ERemoteCall(m, _, args): scan(m); for (a in args) scan(a);
                            case ECall(t, _, args): if (t != null) scan(t); for (a in args) scan(a);
                            case ETuple(elts): for (e in elts) scan(e);
                            case EMap(pairs): for (p in pairs) { scan(p.key); scan(p.value); }
                            case EKeywordList(pairs): for (p in pairs) { scan(p.value); }
                            case EStructUpdate(st, fields): scan(st); for (f in fields) scan(f.value);
                            default:
                        }
                    }
                    for (s in stmts) scan(s);
                    return (hasBare && !hasAlias);
                }
                // Printer de-semanticization: Repo alias handled by transforms

                // Print body, unwrapping any top-level parentheses
                for (expr in body) {
                    var e2 = switch (expr.def) { case EParen(inner): inner; default: expr; };
                    result += indentStr(indent + 1) + print(e2, indent + 1) + '\n';
                }
                
                // Restore module context
                currentModuleName = prevModuleCtx;

                result += indentStr(indent) + 'end\n';
                result;
                
            case EDefmodule(name, doBlock):
                // This case is handled in the main print function to access metadata
                // Should not reach here, but provide fallback
                'defmodule ${name} do\n' +
                indentStr(indent + 1) + print(doBlock, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            // ================================================================
            // Functions
            // ================================================================
            case EDef(name, args, guards, body):
                var argStr = printPatterns(args);
                var guardStr = guards != null ? ' when ' + print(guards, 0) : '';
                'def ${name}(${argStr})${guardStr} do\n' +
                indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            case EDefp(name, args, guards, body):
                // M0 STABILIZATION: Disable underscore prefixing temporarily
                var funcName = name;
                /* Disabled to prevent variable mismatches
                if (currentUnusedFunctions != null && currentUnusedFunctions.indexOf(name) != -1) {
                    // Don't double-prefix if already starts with underscore
                    if (!name.startsWith("_")) {
                        funcName = "_" + name;
                    }
                }
                */

                var argStr = printPatterns(args);
                var guardStr = guards != null ? ' when ' + print(guards, 0) : '';
                'defp ${funcName}(${argStr})${guardStr} do\n' +
                indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            case EDefmacro(name, args, guards, body):
                var argStr = printPatterns(args);
                var guardStr = guards != null ? ' when ' + print(guards, 0) : '';
                'defmacro ${name}(${argStr})${guardStr} do\n' +
                indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            case EDefmacrop(name, args, guards, body):
                var argStr = printPatterns(args);
                var guardStr = guards != null ? ' when ' + print(guards, 0) : '';
                'defmacrop ${name}(${argStr})${guardStr} do\n' +
                indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            // ================================================================
            // Pattern Matching
            // ================================================================
            case ECase(expr, clauses):
                '(' + (
                    'case ' + print(expr, 0) + ' do\n' +
                    [for (clause in clauses) 
                        indentStr(indent + 1) + printCaseClause(clause, indent + 1)
                    ].join('\n') + '\n' +
                    indentStr(indent) + 'end'
                ) + ')';
                
            case ECond(clauses):
                var clauseStrs = [];
                for (clause in clauses) {
                    var conditionStr = print(clause.condition, 0);
                    var bodyStr = print(clause.body, indent + 2);
                    
                    // Check if body needs multi-line formatting
                    var isMultiLine = switch(clause.body.def) {
                        case EIf(_, _, _): true;
                        case ECase(_, _): true;
                        case ECond(_): true;
                        case EWith(_, _, _): true;
                        case EBlock(exprs) if (exprs.length > 1): true;
                        case _: bodyStr.indexOf('\n') >= 0;
                    };
                    
                    if (isMultiLine) {
                        // Multi-line format: condition on one line, body indented on next
                        clauseStrs.push(
                            indentStr(indent + 1) + conditionStr + ' ->\n' +
                            indentStr(indent + 2) + bodyStr
                        );
                    } else {
                        // Single-line format: condition and body on same line
                        clauseStrs.push(
                            indentStr(indent + 1) + conditionStr + ' -> ' + bodyStr
                        );
                    }
                }
                'cond do\n' + clauseStrs.join('\n') + '\n' + indentStr(indent) + 'end';
                
            case EMatch(pattern, expr):
                var patternStr = printPattern(pattern);
                // Check if the expression has metadata indicating it should stay inline
                // This is used for null coalescing patterns that need to stay on one line
                var keepInline = expr != null && expr.metadata != null && 
                                expr.metadata.keepInlineInAssignment == true;

                // Normalize numeric-sentinel call assigns: `0 = call(...)` → `call(...)`
                var isZeroPat = switch (pattern) { case PLiteral({def: EInteger(v)}) if (v == 0): true; default: false; };
                if (isZeroPat && expr != null) {
                    switch (expr.def) {
                        case ECall(_,_,_) | ERemoteCall(_,_,_): return print(expr, 0);
                        case EParen(inner):
                            switch (inner.def) {
                                case ECall(_,_,_) | ERemoteCall(_,_,_): return print(inner, 0);
                                default:
                            }
                        default:
                    }
                }

                switch(pattern) {
                    case PVar(name):
                        var rhsName = switch(expr != null ? expr.def : null) {
                            case EVar(varName): varName;
                            default: null;
                        };

                        // Only skip printing if the RHS is the same variable (self-assignment)
                        // and NOT a temporary pattern variable that will be used later
                        if (rhsName != null && rhsName == name && !ElixirASTBuilder.isTempPatternVarName(name)) {
                            return '';
                        }

                        // IMPORTANT: Haxe-generated temporary variables (g, g1, _g, etc.) MUST be printed
                        // These are created by Haxe during compilation for switch expressions and other patterns.
                        // Example: switch(parseMessage(msg)) becomes _g = parseMessage(msg); switch(_g)
                        // Without printing these assignments, we get "undefined variable 'g'" errors in Elixir.
                        // See ElixirASTBuilder.isTempPatternVarName for full documentation on these variables.
                    default:
                }

                // Collapse self-assignment chains in RHS: pattern = (pattern = expr) or pattern = pattern = expr
                // String-level and AST-level guards
                switch (pattern) {
                    case PVar(name):
                        if (expr != null) {
                            switch (expr.def) {
                        case EBinary(Match, innerLeft, rhsExpr):
                            var innerLeftStr = print(innerLeft, 0);
                            if (innerLeftStr == name) {
                                return name + ' = ' + print(rhsExpr, indent);
                            }
                        case EMatch(innerPattern, rhsExpr2):
                            switch (innerPattern) { case PVar(innerName) if (innerName == name): return name + ' = ' + print(rhsExpr2, indent); default: }
                                default:
                            }
                            var rhsPrinted = print(expr, indent);
                            if (rhsPrinted != null) {
                                var trimmed = StringTools.trim(rhsPrinted);
                                var prefix = name + ' = ';
                                if (StringTools.startsWith(trimmed, prefix)) {
                                    var rest = StringTools.trim(trimmed.substr(prefix.length));
                                    return name + ' = ' + rest;
                                }
                            }
                        }
                    default:
                }

                // Numeric-sentinel assignment normalization: `0 = call(...)` → print call only
                var isZeroPat = switch (pattern) { case PLiteral({def: EInteger(v)}) if (v == 0): true; default: false; };
                if (isZeroPat && expr != null) {
                    switch (expr.def) {
                        case ECall(_,_,_) | ERemoteCall(_,_,_): return print(expr, 0);
                        case EParen(inner):
                            switch (inner.def) {
                                case ECall(_,_,_) | ERemoteCall(_,_,_): return print(inner, 0);
                                default:
                            }
                        default:
                    }
                }

                if (keepInline) {
                    // Force inline format for the expression
                    // This ensures null coalescing stays on one line to avoid syntax errors
                    patternStr + ' = ' + print(expr, 0);
                } else {
                    // Regular assignment - pass indent for proper nesting of block expressions (case, cond, etc.)
                    patternStr + ' = ' + print(expr, indent);
                }
                
            case EWith(clauses, doBlock, elseBlock):
                var withClauses = [for (clause in clauses)
                    printPattern(clause.pattern) + ' <- ' + print(clause.expr, 0)
                ].join(',\n' + indentStr(indent + 1));
                
                var result = 'with ' + withClauses + ' do\n' +
                    indentStr(indent + 1) + print(doBlock, indent + 1) + '\n';
                
                if (elseBlock != null) {
                    result += indentStr(indent) + 'else\n' +
                        indentStr(indent + 1) + print(elseBlock, indent + 1) + '\n';
                }
                
                result + indentStr(indent) + 'end';
                
            // ================================================================
            // Control Flow
            // ================================================================
            case EIf(condition, thenBranch, elseBranch):
                // Check if this should be an inline if expression
                // Use inline format when the branches are simple expressions
                var isInline = isSimpleExpression(thenBranch) && 
                               (elseBranch == null || isSimpleExpression(elseBranch));
                
                #if debug_inline_if
                trace('[XRay InlineIf] Checking if statement');
                trace('[XRay InlineIf] Then branch def: ${thenBranch.def}');
                trace('[XRay InlineIf] isSimpleExpression(thenBranch): ${isSimpleExpression(thenBranch)}');
                trace('[XRay InlineIf] isInline decision: $isInline');
                #end
                
                // Print condition without unnecessary parentheses
                // Always parenthesize the condition to avoid parser ambiguity in complex shapes
                var conditionStr = '(' + print(condition, 0) + ')';
                
                if (isInline && elseBranch != null) {
                    // Inline if-else expression: if condition, do: then_val, else: else_val
                    'if ' + conditionStr + ', do: ' + print(thenBranch, 0) + ', else: ' + print(elseBranch, 0);
                } else if (elseBranch != null) {
                    // Multi-line if-else block
                    'if ' + conditionStr + ' do\n' +
                    indentStr(indent + 1) + print(thenBranch, indent + 1) + '\n' +
                    indentStr(indent) + 'else\n' +
                    indentStr(indent + 1) + print(elseBranch, indent + 1) + '\n' +
                    indentStr(indent) + 'end';
                } else if (isInline) {
                    // Inline if without else: if condition, do: then_val
                    // Special-case increment shapes to avoid operator-warning when result is ignored
                    var thenStr = switch (thenBranch.def) {
                        case EBinary(Add, {def: EVar(v)}, rhs): v + ' = ' + v + ' + ' + print(rhs, 0);
                        default: print(thenBranch, 0);
                    };
                    'if ' + conditionStr + ', do: ' + thenStr;
                } else {
                    // Multi-line if without else
                    'if ' + conditionStr + ' do\n' +
                    indentStr(indent + 1) + print(thenBranch, indent + 1) + '\n' +
                    indentStr(indent) + 'end';
                }
                
            case EUnless(condition, body, elseBranch):
                if (elseBranch != null) {
                    'unless ' + print(condition, 0) + ' do\n' +
                    indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                    indentStr(indent) + 'else\n' +
                    indentStr(indent + 1) + print(elseBranch, indent + 1) + '\n' +
                    indentStr(indent) + 'end';
                } else {
                    'unless ' + print(condition, 0) + ' do\n' +
                    indentStr(indent + 1) + print(body, indent + 1) + '\n' +
                    indentStr(indent) + 'end';
                }
                
            case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
                var result = 'try do\n' +
                    indentStr(indent + 1) + print(body, indent + 1) + '\n';
                
                if (rescue.length > 0) {
                    result += indentStr(indent) + 'rescue\n';
                    for (r in rescue) {
                        result += indentStr(indent + 1) + printRescueClause(r, indent + 1) + '\n';
                    }
                }
                
                if (catchClauses.length > 0) {
                    result += indentStr(indent) + 'catch\n';
                    for (c in catchClauses) {
                        result += indentStr(indent + 1) + printCatchClause(c, indent + 1) + '\n';
                    }
                }
                
                if (elseBlock != null) {
                    result += indentStr(indent) + 'else\n' +
                        indentStr(indent + 1) + print(elseBlock, indent + 1) + '\n';
                }
                
                if (afterBlock != null) {
                    result += indentStr(indent) + 'after\n' +
                        indentStr(indent + 1) + print(afterBlock, indent + 1) + '\n';
                }
                
                result + indentStr(indent) + 'end';
                
            case ERaise(exception, attributes):
                if (attributes != null) {
                    'raise ' + print(exception, 0) + ', ' + print(attributes, 0);
                } else {
                    'raise ' + print(exception, 0);
                }
                
            case EThrow(value):
                // Ensure throw arguments are printed as single-line expressions
                // to avoid syntax errors with complex string concatenation
                var valueStr = switch(value.def) {
                    case EBinary(StringConcat, left, right):
                        // For string concatenation with complex expressions,
                        // ensure everything stays on one line
                        var leftStr = print(left, 0);
                        var rightStr = print(right, 0);
                        // Remove any line breaks that might have been introduced
                        leftStr = leftStr.split('\n').join(' ');
                        rightStr = rightStr.split('\n').join(' ');
                        leftStr + ' <> ' + rightStr;
                    default:
                        // For other expressions, print normally but ensure single line
                        var result = print(value, 0);
                        result.split('\n').join(' ');
                };
                'throw(' + valueStr + ')';
                
            // ================================================================
            // Data Structures
            // ================================================================
            case EList(elements):
                // Multi-statement blocks inside list literals need special handling
                // Invalid Elixir: [g = [], g ++ [0], g]  
                // Valid Elixir: [(fn -> g = []; g = g ++ [0]; g end).()]
                // Even better: Use proper comprehension [for i <- 0..1, do: i]
                // Attempt to recover list-building blocks into proper list literals
                inline function tryListFromBlock(block: ElixirAST): Null<Array<ElixirAST>> {
                    inline function normalizeName(n:String): String {
                        var i = 0; while (i < n.length && n.charAt(i) == "_") i++;
                        return i > 0 ? n.substr(i) : n;
                    }
                    return switch (block.def) {
                        case EBlock(stmts) if (stmts.length >= 2):
                            var accName: Null<String> = null;
                            // Detect initializer: acc = [] or acc <- []
                            switch (stmts[0].def) {
                                case EBinary(Match, {def: EVar(v)}, {def: EList(initEls)}) if (initEls.length == 0): accName = v;
                                case EMatch(PVar(varName), {def: EList(initElems)}) if (initElems.length == 0): accName = varName;
                                default:
                            }
                            if (accName == null) return null;
                            var accNorm = normalizeName(accName);
                            var outVals: Array<ElixirAST> = [];
                            for (i in 1...stmts.length) {
                                switch (stmts[i].def) {
                                    case EBinary(Match, {def: EVar(lhs)}, rhs) if (normalizeName(lhs) == accNorm):
                                        // acc = Enum.concat(acc, [value]) or acc = acc ++ [value]
                                        switch (rhs.def) {
                                            case ERemoteCall({def: EVar(m)}, "concat", cargs) if (m == "Enum" && cargs.length == 2):
                                                switch (cargs[0].def) {
                                                    case EVar(v) if (normalizeName(v) == accNorm):
                                                        switch (cargs[1].def) {
                                                            case EList(listElts) if (listElts.length == 1):
                                                                outVals.push(listElts[0]);
                                                            default:
                                                        }
                                                    default:
                                                }
                                            case EBinary(Add, {def: EVar(accVar)}, rhsExpr) if (normalizeName(accVar) == accNorm):
                                                switch (rhsExpr.def) {
                                                    case EList(listElements) if (listElements.length == 1):
                                                        outVals.push(listElements[0]);
                                                    default:
                                                }
                                            default:
                                        }
                                    default:
                                }
                            }
                            return outVals.length > 0 ? outVals : null;
                        default:
                            null;
                    }
                }
                '[' + [for (e in elements) {
                    switch (e.def) {
                        // Parenthesize for-comprehensions inside list literals to avoid
                        // ambiguity with keyword arguments (do:) in container contexts.
                        case EFor(_, _, _, _, _):
                            '(' + print(e, 0) + ')';
                        case EBlock(exprs) if (exprs.length > 1):
                            var recovered = tryListFromBlock(e);
                            if (recovered != null) {
                                '[' + [for (v in recovered) print(v, 0)].join(', ') + ']';
                            } else {
                                '(fn -> ' + print(e, 0).rtrim() + ' end).()';
                            }
                        case EParen(inner) if (switch (inner.def) { case EBlock(es) if (es.length > 1): true; default: false; }):
                            // Attempt recovery just like EBlock case
                            var recovered2 = tryListFromBlock(inner);
                            if (recovered2 != null) {
                                '[' + [for (v in recovered2) print(v, 0)].join(', ') + ']';
                            } else {
                                // Fallback: a parenthesized multi-statement block still needs wrapping
                                var innerStr = print(inner, 0).rtrim();
                                if (StringTools.startsWith(innerStr, "(") && StringTools.endsWith(innerStr, ")")) {
                                    innerStr = innerStr.substr(1, innerStr.length - 2);
                                }
                                '(fn -> ' + innerStr + ' end).()';
                            }
                        case EBlock(_):
                            print(e, 0);
                        default:
                            print(e, 0);
                    }
                }].join(', ') + ']';
                
            case ETuple(elements):
                '{' + [for (e in elements) print(e, 0)].join(', ') + '}';
                
            case EMap(pairs):
                '%{' + [for (p in pairs) {
                    var key = print(p.key, 0);
                    var value = p.value;
                    
                    // Check if value is an inline if-else that needs parentheses
                    var valueStr = switch(value.def) {
                        case EBlock(exprs) if (exprs.length > 1):
                            // Fallback: ensure single expression in map field
                            // Wrap multi-statement block in zero-arity anonymous function call
                            '(fn -> ' + print(value, 0).rtrim() + ' end).()';
                        case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && 
                            isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
                            // Wrap inline if-else in parentheses for map context
                            '(' + print(value, 0) + ')';
                        case _:
                            print(value, 0);
                    };
                    
                    key + ' => ' + valueStr;
                }].join(', ') + '}';
                
            case EStruct(module, fields):
                // Qualify bare struct module with <App> prefix when inside <App>Web.*
                var qualifiedModule = (function() {
                    if (module.indexOf('.') != -1) return module;
                    inline function appPrefix(): Null<String> {
                        if (currentModuleName == null) return observedAppPrefix;
                        var idx = currentModuleName.indexOf("Web");
                        return idx > 0 ? currentModuleName.substring(0, idx) : observedAppPrefix;
                    }
                    var p = appPrefix();
                    return (p != null ? p + '.' + module : module);
                })();
                '%' + qualifiedModule + '{' + 
                [for (f in fields) {
                    var value = f.value;
                    
                    // Check if value is an inline if-else that needs parentheses
                    var valueStr = switch(value.def) {
                        case EBlock(exprs) if (exprs.length > 1):
                            // Fallback for multi-statement in struct field
                            '(fn -> ' + print(value, 0).rtrim() + ' end).()';
                        case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && 
                            isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
                            // Wrap inline if-else in parentheses for struct context
                            '(' + print(value, 0) + ')';
                        case _:
                            print(value, 0);
                    };
                    
                    f.key + ': ' + valueStr;
                }].join(', ') + '}';
                
            case EStructUpdate(struct, fields):
                // Struct update syntax: %{struct | field: value, ...}
                '%{' + print(struct, 0) + ' | ' +
                [for (f in fields) {
                    var value = f.value;
                    
                    // Check if value is an inline if-else that needs parentheses
                    var valueStr = switch(value.def) {
                        case EBlock(exprs) if (exprs.length > 1):
                            '(fn -> ' + print(value, 0).rtrim() + ' end).()';
                        case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && 
                            isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
                            // Wrap inline if-else in parentheses for struct update context
                            '(' + print(value, 0) + ')';
                        case _:
                            print(value, 0);
                    };
                    
                    f.key + ': ' + valueStr;
                }].join(', ') + '}';
                
            case EKeywordList(pairs):
                '[' + [for (p in pairs) {
                    var value = p.value;
                    
                    // Check if value is an inline if-else that needs parentheses
                    var valueStr = switch(value.def) {
                        case EBlock(exprs) if (exprs.length > 1):
                            '(fn -> ' + print(value, 0).rtrim() + ' end).()';
                        case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && 
                            isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
                            // Wrap inline if-else in parentheses for keyword list context
                            '(' + print(value, 0) + ')';
                        case _:
                            print(value, 0);
                    };
                    
                    p.key + ': ' + valueStr;
                }].join(', ') + ']';
                
            case EBitstring(segments):
                '<<' + [for (s in segments) printBinarySegment(s)].join(', ') + '>>';
                
            // ================================================================
            // Expressions
            // ================================================================
            case ECall(target, funcName, args):
                /**
                 * CRITICAL BUG FIX (2025-09-01): Method Call Indentation
                 * 
                 * ISSUE: Method calls were losing all indentation, appearing at column 0
                 * regardless of their nesting level. This caused invalid Elixir syntax
                 * when method calls appeared inside blocks, lambdas, or if-statements.
                 * 
                 * ROOT CAUSE: The printer was using `print(target, 0)` which reset
                 * indentation to 0, instead of `print(target, indent)` which preserves
                 * the current indentation level.
                 * 
                 * SYMPTOMS:
                 * - In Bytes module: `s.cca(index)` appeared with no indentation
                 * - Compilation error: "cannot invoke remote function inside a match"
                 * - Method calls inside nested contexts lost their position
                 * 
                 * EXAMPLE OF BUG:
                 * ```elixir
                 * if condition do
                 *   c = index = i = i + 1
                 * s.cca(index)  # <- NO INDENTATION (wrong!)
                 * end
                 * ```
                 * 
                 * FIXED OUTPUT:
                 * ```elixir
                 * if condition do
                 *   c = index = i = i + 1
                 *   s.cca(index)  # <- PROPER INDENTATION
                 * end
                 * ```
                 * 
                 * LESSON LEARNED:
                 * - Always pass the indent parameter through when recursively printing
                 * - Never hardcode indent=0 unless specifically needed for inline contexts
                 * - Test nested expressions thoroughly, especially in lambda bodies
                 * - Indentation bugs can cause syntax errors that seem unrelated
                 * 
                 * This bug affected ALL method calls in nested contexts and was
                 * particularly problematic for inline expansion of standard library
                 * functions like String.charCodeAt.
                 */
                // Special handling for Phoenix function name mappings
                // Transform assign_multiple to assign (Phoenix.Component only has assign/2)
                if (funcName == "assign_multiple" && target == null) {
                    funcName = "assign";
                }
                
                // Special handling for while loop placeholders
                if (funcName == "while_loop" && target == null && args.length == 2) {
                    // Generate an immediately invoked recursive function for while loops
                    // This creates a local recursive function that implements the loop
                    var condition = args[0];
                    var body = args[1];
                    var loopFuncName = "loop_" + (loopIdCounter++);
                    
                    // Generate: (fn -> loop_x = fn -> if condition do body; loop_x.() else :ok end end; loop_x.() end).()
                    var lines = [];
                    lines.push('(fn ->');
                    lines.push('  ' + loopFuncName + ' = fn ' + loopFuncName + ' ->');
                    lines.push('    if ' + print(condition, 0) + ' do');
                    lines.push('      ' + print(body, 3));
                    lines.push('      ' + loopFuncName + '.(' + loopFuncName + ')');
                    lines.push('    else');
                    lines.push('      :ok');
                    lines.push('    end');
                    lines.push('  end');
                    lines.push('  ' + loopFuncName + '.(' + loopFuncName + ')');
                    lines.push('end).()');
                    lines.join('\n' + indentStr(indent));
                } else {
                    // Normal function call
                    var argStr = (function(){
                        var parts: Array<String> = [];
                        for (a in args) {
                            var printed = printFunctionArg(a, indent + 1);
                            parts.push(sanitizeArgPrinted(printed, indent + 1));
                        }
                        return parts.join(', ');
                    })();
                    if (target != null) {
                        // Fallback: Module.new() -> %<App>.Module{}
                        if (funcName == "new" && args.length == 0) {
                            inline function appPrefix(): Null<String> {
                                if (currentModuleName == null) return observedAppPrefix;
                                var idx = currentModuleName.indexOf("Web");
                                return idx > 0 ? currentModuleName.substring(0, idx) : observedAppPrefix;
                            }
                            switch (target.def) {
                                case EVar(n):
                                    var modStr = (function(){
                                        if (n.indexOf('.') == -1) {
                                            var p = appPrefix();
                                            return (p != null ? p + '.' + n : n);
                                        } else {
                                            return n;
                                        }
                                    })();
                                    return '%'+modStr+'{}';
                                default:
                            }
                        }
                        // Check if this is a function variable call (marked with empty funcName)
                        if (funcName == "") {
                            // Function variable call - ensure target is parenthesized when needed, then use .() syntax
                            var tStr = switch (target.def) {
                                case EFn(_): '(' + print(target, indent) + ')';
                                case EParen(_): print(target, indent);
                                default: print(target, indent);
                            };
                            tStr + '.(' + argStr + ')';
                        } else {
                            // Transform method call syntax to proper Elixir module calls
                            // Elixir doesn't support obj.method() - use Module.function(obj, args)

                            // Check if this is an Enum method (map, filter, reduce, etc.)
                            var isEnumMethod = switch(funcName) {
                                case "map" | "filter" | "reduce" | "each" | "find" |
                                     "reject" | "take" | "drop" | "any" | "all" |
                                     "count" | "member" | "sort" | "reverse" | "zip" |
                                     "concat" | "flat_map" | "group_by" | "split" |
                                     "join" | "at" | "fetch" | "empty" | "sum" |
                                     "min" | "max" | "uniq" | "with_index":
                                    true;
                                default:
                                    false;
                            };

                            if (isEnumMethod) {
                                // Transform: list.map(fn) → Enum.map(list, fn)
                                // Special-case join: ensure first arg is a single expression (wrap via IIFE if needed),
                                // mirroring the remote-call branch handling to avoid leaking multi-statement builders.
                                var receiverPrinted = print(target, indent);
                                var firstArgStr = (function(){
                                    if (funcName == "join") {
                                        var trimmed = StringTools.trim(receiverPrinted);
                                        return StringTools.startsWith(trimmed, '(fn ->') ? receiverPrinted : '(fn -> ' + receiverPrinted + ' end).()';
                                    } else {
                                        return receiverPrinted;
                                    }
                                })();
                                var enumCall = 'Enum.' + funcName + '(' + firstArgStr;
                                if (argStr.length > 0) {
                                    enumCall + ', ' + argStr + ')';
                                } else {
                                    enumCall + ')';
                                }
                            } else {
                                // Special-case: to_iso8601 on Date/NaiveDateTime values
                                if (funcName == "to_iso8601") {
                                    // Generate explicit module call to preserve ISO8601 formatting
                                    // and avoid implicit String.Chars conversions.
                                    // We default to DateTime for runtime Date values.
                                    var tstr = print(target, indent);
                                    return 'DateTime.to_iso8601(' + tstr + ')';
                                }
                                // Special-case: list.push(elem) → list = Enum.concat(list, [elem])
                                if (funcName == "push") {
                                    // Only when target is a simple variable (lowercase start)
                                    switch (target.def) {
                                        case EVar(varName):
                                            var first = varName.charAt(0);
                                            if (first == first.toLowerCase()) {
                                                // Use the first argument only
                                                var printedArg = args.length > 0 ? printFunctionArg(args[0]) : "";
                                                return varName + ' = Enum.concat(' + varName + ', [' + printedArg + '])';
                                            }
                                        default:
                                    }
                                }
                                // Check if target is a block expression that needs parentheses
                                var targetStr = switch(target.def) {
                                    case ECase(_, _) | ECond(_) | EWith(_, _, _):
                                        // Block expressions need parentheses when used as method call targets
                                        // Generate: (case...end) |> Module.function()
                                        '(' + print(target, indent) + ') |> Kernel.' + funcName;
                                    case EIf(_, _, elseBranch) if (elseBranch != null):
                                        // If expressions with else branches need parentheses too
                                        '(' + print(target, indent) + ') |> Kernel.' + funcName;
                                    default:
                                        // Regular expressions can be method call targets directly
                                        // Qualify bare Repo.* to <App>.Repo.* within <App>Web modules
                                        var modStr = switch(target.def) {
                                            case EVar(name) if (name == "Repo"):
                                                var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
                                                if (idx > 0) currentModuleName.substring(0, idx) + ".Repo" else {
                                                    if (observedAppPrefix != null) observedAppPrefix + ".Repo" else {
                                                        try {
                                                            var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
                                                            if (app != null && app.length > 0) app + ".Repo" else name;
                                                        } catch (e:Dynamic) {
                                                            name;
                                                        }
                                                    }
                                                };
                                            case EVar(name):
                                                // If target looks like a module (UpperCamel) and we're inside <App>Web.*,
                                                // qualify to <App>.<Name> (fallback for cases missed by AST pass)
                                                var first = name.charAt(0);
                                                var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
                                                var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
                                                inline function isStdModule(n: String): Bool {
                                                    return switch (n) {
                                                        case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" |
                                                             "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" |
                                                             "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" |
                                                             "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" |
                                                             "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
                                                            true;
                                                        default:
                                                            false;
                                                    };
                                                }
                                                if (isUpper && idx > 0 && !isStdModule(name)) currentModuleName.substring(0, idx) + "." + name else name;
                                            default:
                                                print(target, indent);
                                        };
                                        modStr + '.' + funcName;
                                };
                                targetStr + '(' + argStr + ')';
                            }
                        }
                    } else {
                        funcName + '(' + argStr + ')';
                    }
                }
                
            case EMacroCall(macroName, args, doBlock):
                // Macro calls with do-blocks don't use parentheses
                // e.g., "schema 'users' do ... end"
                var argStr = [for (a in args) print(a, 0)].join(', ');
                var unwrappedDo = switch (doBlock.def) { case EParen(inner): inner; default: doBlock; };
                macroName + (args.length > 0 ? ' ' + argStr : '') + ' do\n' +
                indentStr(indent + 1) + print(unwrappedDo, indent + 1) + '\n' +
                indentStr(indent) + 'end';
                
            case ERemoteCall(module, funcName, args):
                // Special remappings before generic remote call printing
                switch (module.def) {
                    case EVar(m) if (m == "Date_Impl_"):
                        // Date_Impl_.get_time(x) -> DateTime.to_unix(x, :millisecond)
                        if (funcName == "get_time" && args.length == 1) {
                            return 'DateTime.to_unix(' + printFunctionArg(args[0], indent) + ', :millisecond)';
                        }
                        // Date_Impl_.from_string(x) -> x
                        if (funcName == "from_string" && args.length == 1) {
                            return printFunctionArg(args[0], indent);
                        }
                    default:
                }
                // Module.new() → %Module{} is handled by AST passes (ModuleNewToStructLiteral)
                // Printer no longer rewrites new/0 to struct literal to avoid generating invalid
                // structs for non-schema modules (e.g., BalancedTree). Rely on AST transform stage.
                // Qualify struct literal in changeset/2 to match remote module
                var argStr = (function(){
                    // Aggressive stabilization for Assert boolean assertions: wrap first arg in IIFE to
                    // guarantee single-expression semantics even when inline expansions introduce multiple statements.
                    // Shape-agnostic and limited to Assert.is_true/2 and Assert.is_false/2.
                    switch (module.def) {
                        case EVar(m) if (m == "Assert" && (funcName == "is_true" || funcName == "is_false") && args.length >= 1):
                            var parts: Array<String> = [];
                            var firstPrinted = '(fn -> ' + print(args[0], indent) + ' end).()';
                            parts.push(firstPrinted);
                            for (i in 1...args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
                            return parts.join(', ');
                        default:
                    }
                    if (funcName == "changeset" && args.length >= 1) {
                        var parts: Array<String> = [];
                        // Force first arg to %<RemoteModule>{} when it's a bare struct literal
                        // Inspect printed first arg; if it is a bare %Module{} with no prefix,
                        // replace with %<RemoteModule>{} to avoid __struct__/1 undefined.
                        var firstPrinted = print(args[0], 0);
                        var needsQual = false;
                        if (StringTools.startsWith(firstPrinted, "%")) {
                            var open = firstPrinted.indexOf("{");
                            var closeDot = firstPrinted.indexOf(".");
                            needsQual = (open > 1 && (closeDot == -1 || closeDot > open));
                        }
                        if (needsQual) {
                            var remote = printQualifiedModule(module);
                            parts.push('%' + remote + '{}');
                        } else {
                            parts.push(firstPrinted);
                        }
                        for (i in 1...args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
                        return parts.join(', ');
                    } else {
                        var s: String;
                        // Special handling: ensure Enum.join first argument is a single valid expression
                        // Some upstream shapes produce multi-statement fragments as the first argument.
                        // Wrap such cases in an IIFE at print-time as a last resort for validity.
                        var mstrTmp = printQualifiedModule(module);
                        if (mstrTmp == "Enum" && funcName == "join" && args.length >= 1) {
                            var parts: Array<String> = [];
                            var firstPrintedRaw = print(args[0], indent);
                            var trimmed = StringTools.trim(firstPrintedRaw);
                            var firstPrinted = StringTools.startsWith(trimmed, '(fn ->') ? firstPrintedRaw : '(fn -> ' + firstPrintedRaw + ' end).()';
                            parts.push(firstPrinted);
                            for (i in 1...args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
                            s = parts.join(', ');
                        } else {
                            s = [for (a in args) sanitizeArgPrinted(printFunctionArg(a, indent), indent)].join(', ');
                        }
                        // Ecto.Query.from(t in :table, ...) -> qualify atom to <App>.CamelCase
                        var mstr = printQualifiedModule(module);
                        if (mstr == "Ecto.Query" && funcName == "from") {
                            inline function camelize(x: String): String {
                                var parts = x.split("_");
                                var out = [];
                                for (p in parts) if (p.length > 0) out.push(p.charAt(0).toUpperCase() + p.substr(1));
                                return out.join("");
                            }
                            var idxIn = s.indexOf(" in :");
                            if (idxIn != -1) {
                                var start = idxIn + 6; // after " in :"
                                var j = start;
                                while (j < s.length) {
                                    var ch = s.charAt(j);
                                    var isAlnum = ~/^[A-Za-z0-9_]$/.match(ch);
                                    if (!isAlnum) break;
                                    j++;
                                }
                                var raw = s.substr(start, j - start);
                                if (raw.length > 0) {
                                    var app = (function(){
                                        var pfx: Null<String> = null;
                                        if (currentModuleName != null) {
                                            var w = currentModuleName.indexOf("Web");
                                            if (w > 0) pfx = currentModuleName.substring(0, w);
                                        }
                                        if (pfx == null) pfx = observedAppPrefix;
                                        if (pfx == null) { try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch (e:Dynamic) {} }
                                        return pfx;
                                    })();
                                    if (app != null && app.length > 0) {
                                        s = s.substr(0, idxIn + 4) + ' ' + app + '.' + camelize(raw) + s.substr(j);
                                    }
                                }
                            }
                        }
                        // Repo.get/one bare module arg qualification: Repo.get(Todo, id) → Repo.get(<App>.Todo, id)
                        if ((mstr == reflaxe.elixir.PhoenixMapper.getAppModuleName() + ".Repo" || StringTools.endsWith(mstr, ".Repo")) && (funcName == "get" || funcName == "one")) {
                            var comma = s.indexOf(',');
                            var firstArg = comma != -1 ? s.substr(0, comma) : s;
                            var trimmed = StringTools.trim(firstArg);
                            inline function isBareModule(name:String):Bool {
                                return name.length > 0 && name.indexOf('.') == -1 && ~/^[A-Z][A-Za-z0-9_]*$/.match(name);
                            }
                            var app = (function(){
                                var pfx: Null<String> = null;
                                if (currentModuleName != null) {
                                    var w = currentModuleName.indexOf("Web");
                                    if (w > 0) pfx = currentModuleName.substring(0, w);
                                }
                                if (pfx == null) pfx = observedAppPrefix;
                                if (pfx == null) { try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch (e:Dynamic) {} }
                                return pfx;
                            })();
                            if (app != null && isBareModule(trimmed)) {
                                var rest = comma != -1 ? s.substr(comma) : "";
                                s = app + "." + trimmed + rest;
                            }
                        }
                        return s;
                    }
                })();
                var moduleStr = printQualifiedModule(module);
                moduleStr + '.' + funcName + '(' + argStr + ')';
                
            case EPipe(left, right):
                print(left, 0) + ' |> ' + print(right, 0);
                
            /**
             * BINARY OPERATION PRINTING
             * 
             * WHY: If expressions in binary operations require parentheses in Elixir
             * - Without parentheses: `if x, do: 1, else: 2 > 3` is ambiguous
             * - With parentheses: `(if x, do: 1, else: 2) > 3` is clear
             * - Haxe's inline function expansion creates complex if expressions in comparisons
             * 
             * WHAT: Wrap if expressions when they appear as binary operation operands
             * - Detect if expressions in left/right operands
             * - Add parentheses around if expressions
             * - Preserve existing parenthesization logic for the whole expression
             * 
             * HOW: Check operand types before printing
             * - If operand is EIf: wrap in parentheses
             * - Otherwise: print normally
             * - Apply outer parentheses if needed by context
             * 
             * EXAMPLES:
             * - `(if a, do: 1, else: 2) > (if b, do: 3, else: 4)`
             * - `x + y` (no parentheses needed for simple operands)
             * - `(if cond, do: val1, else: val2) + 5`
             */
            case EBinary(op, left, right):
                // Special handling for operators that are functions in Elixir, not infix
                if (op == Remainder) {
                    // Generate rem(n, 2) instead of n rem 2
                    var leftStr = print(left, 0);
                    var rightStr = print(right, 0);
                    'rem(' + leftStr + ', ' + rightStr + ')';
                } else if (isBitwiseOp(op)) {
                    // Bitwise operators require Bitwise module functions
                    // Generate: Bitwise.band(n, 15) instead of n &&& 15
                    var funcName = bitwiseOpToFunction(op);
                    var leftStr = print(left, 0);
                    var rightStr = print(right, 0);
                    'Bitwise.' + funcName + '(' + leftStr + ', ' + rightStr + ')';
                } else {
                    // De-duplication: collapse x = (x = expr) and x = x = expr
                    if (op == Match) {
                        // Normalize numeric-sentinel call assigns: `0 = call(...)` → `call(...)`
                        var isZeroLhs = switch (left.def) { case EInteger(v) if (v == 0): true; default: false; };
                        if (isZeroLhs) {
                            switch (right.def) {
                                case ECall(_,_,_) | ERemoteCall(_,_,_):
                                    return print(right, 0);
                                case EParen(innerP):
                                    switch (innerP.def) {
                                        case ECall(_,_,_) | ERemoteCall(_,_,_): return print(innerP, 0);
                                        default:
                                    }
                                default:
                            }
                        }
                        var leftStr0 = print(left, 0);
                        // Guard against blank/whitespace LHS; normalize to discard `_`
                        if (leftStr0 == null || StringTools.trim(leftStr0).length == 0) leftStr0 = "_";
                        switch (right.def) {
                            case EBinary(Match, innerLeft, rhsExpr):
                                var innerLeftStr = print(innerLeft, 0);
                                if (innerLeftStr == leftStr0) {
                                    return leftStr0 + ' = ' + print(rhsExpr, 0);
                                }
                            case EMatch(innerPattern, rhsExpr2):
                                var lhsName: Null<String> = switch (innerPattern) { case PVar(nm): nm; default: null; };
                                if (lhsName != null && lhsName == leftStr0) {
                                    return leftStr0 + ' = ' + print(rhsExpr2, 0);
                                }
                            default:
                        }
                        // String-level guard: collapse when RHS starts with redundant "<lhs> ="
                        var rightPrinted0 = print(right, 0);
                        if (rightPrinted0 != null) {
                            var trimmed = StringTools.trim(rightPrinted0);
                            var prefix = leftStr0 + ' = ';
                            if (StringTools.startsWith(trimmed, prefix)) {
                                var rest = StringTools.trim(trimmed.substr(prefix.length));
                                return leftStr0 + ' = ' + rest;
                            }
                        }
                    }
                    // Constant folding for simple arithmetic to avoid no-op operator warnings
                    if (op == Add) {
                        switch (left.def) {
                            case EInteger(a):
                                switch (right.def) {
                                    case EInteger(b):
                                        return Std.string(a + b);
                                    default:
                                }
                            default:
                        }
                    }
                    var needsParens = needsParentheses(node);
                    var opStr = binaryOpToString(op);

                    // Check if operands need parentheses (e.g., if expressions in comparisons)
                    var leftStr = switch(left.def) {
                        case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_,_,_):
                            // If expressions in binary operations need parentheses
                            '(' + print(left, 0) + ')';
                        default:
                            print(left, 0);
                    };

                    var rightStr = switch(right) {
                        case null:
                            '0';
                        case _:
                            switch(right.def) {
                        case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_,_,_):
                            // In assignments, prefer no extra parens around case/cond/if on RHS
                            if (op == Match) print(right, 0) else '(' + print(right, 0) + ')';
                        default:
                            print(right, 0);
                            }
                    };
                    
                    // Defensive: avoid invalid syntax if an operand prints empty (or whitespace-only)
                    if (leftStr == null || leftStr.length == 0 || StringTools.trim(leftStr).length == 0) {
                        // For assignments, prefer wildcard '_' instead of numeric sentinel
                        if (op == Match) leftStr = '_'; else leftStr = '0';
                    }
                    if (rightStr == null || rightStr.length == 0) rightStr = '0';
                    var result = leftStr + ' ' + opStr + ' ' + rightStr;
                    needsParens ? '(' + result + ')' : result;
                }
                
            case EUnary(op, expr):
                #if debug_ast_printer
                switch(expr.def) {
                    case EBlock(stmts):
                        trace('[XRay Printer] WARNING: EBlock inside EUnary! ${stmts.length} statements');
                    default:
                }
                #end
                unaryOpToString(op) + print(expr, 0);
                
            case EField(target, field):
                // Special-case: list.length -> length(list)
                if (field == "length") {
                    return 'length(' + print(target, 0) + ')';
                }
                // Special-case: now.to_iso8601 -> DateTime.to_iso8601(now)
                if (field == "to_iso8601") {
                    return 'DateTime.to_iso8601(' + print(target, 0) + ')';
                }
                // If target is an atom, combine into a single atom with proper quoting
                switch (target.def) {
                    case EAtom(atomBase):
                        // Render as a single atom: :"atomBase.Field"
                        var combined = atomBase + '.' + field;
                        // Reuse EAtom printing rules by constructing a synthetic EAtom
                        var tmp = makeAST(EAtom(combined));
                        print(tmp, 0);
                    default:
                        print(target, 0) + '.' + field;
                }
                
            case EAccess(target, key):
                print(target, 0) + '[' + print(key, 0) + ']';
                
            case ERange(start, end, exclusive):
                print(start, 0) + (exclusive ? '...' : '..') + print(end, 0);
                
            // ================================================================
            // Literals
            // ================================================================
            case EAtom(value):
                // Atoms need quotes only if they contain special characters or don't follow
                // the simple identifier pattern (letters, numbers, underscore, optionally ending with ! or ?)
                // Examples needing quotes: :"TodoApp.PubSub", :"my-atom", :"123start"
                // Examples NOT needing quotes: :title, :ok, :valid?, :save!
                var atomStr: String = value; // ElixirAtom has implicit to String conversion
                // Defensive normalization: strip an accidental leading ':' if present in the atom payload
                if (atomStr != null && atomStr.length > 0 && atomStr.charAt(0) == ':') {
                    atomStr = atomStr.substr(1);
                }
                
                // Check if atom needs quotes using Elixir's rules:
                // Valid without quotes: starts with letter or underscore, contains only
                // alphanumeric and underscore, optionally ends with ! or ?
                var needsQuotes = false;
                
                // Special case: empty string always needs quotes
                if (atomStr.length == 0) {
                    needsQuotes = true;
                } else {
                    // Check first character: must be letter or underscore
                    var firstChar = atomStr.charAt(0);
                    if (!isLetter(firstChar) && firstChar != '_') {
                        needsQuotes = true;
                    } else {
                        // Check rest of characters (except possibly last)
                        var i = 1;
                        var len = atomStr.length;
                        
                        // Check if ends with ! or ?
                        var lastChar = atomStr.charAt(len - 1);
                        var endsWithBangOrQuestion = (lastChar == '!' || lastChar == '?');
                        var checkUntil = endsWithBangOrQuestion ? len - 1 : len;
                        
                        // Check middle characters
                        while (i < checkUntil && !needsQuotes) {
                            var c = atomStr.charAt(i);
                            if (!isLetter(c) && !isDigit(c) && c != '_') {
                                needsQuotes = true;
                            }
                            i++;
                        }
                    }
                }
                
                if (needsQuotes) {
                    ':"' + atomStr + '"';
                } else {
                    ':' + atomStr;
                }
                
            case EString(value):
                // Sanitize interpolated strings that contain Enum.join(<multi-stmt>, sep)
                // by wrapping the first argument in an IIFE to ensure valid syntax.
                inline function sanitizeJoinArgInInterpolatedString(s:String):String {
                    if (s == null || s.indexOf("#{") == -1 || s.indexOf("Enum.join(") == -1) return s;
                    var out = new StringBuf();
                    var i = 0;
                    while (i < s.length) {
                        var open = s.indexOf("#{", i);
                        if (open == -1) { out.add(s.substr(i)); break; }
                        out.add(s.substr(i, open - i));
                        var k = open + 2; var depth = 1;
                        while (k < s.length && depth > 0) {
                            var ch = s.charAt(k);
                            if (ch == '{') depth++; else if (ch == '}') depth--; k++;
                        }
                        var inner = s.substr(open + 2, (k - 1) - (open + 2));
                        // Only wrap when needed and avoid double IIFEs
                        var innerTrim = StringTools.trim(inner);
                        var needsWrap = (inner.indexOf('\n') != -1) || (inner.indexOf('=') != -1 && inner.indexOf("==") == -1);
                        if (needsWrap && !StringTools.startsWith(innerTrim, '(fn ->')) {
                            inner = '(fn -> ' + inner + ' end).()';
                        }
                        out.add("#{" + inner + "}");
                        i = k;
                    }
                    return out.toString();
                }
                // Snapshot parity: wrap all #{...} inner expressions in an IIFE, unless already wrapped.
                inline function sanitizeInterpolationsInString(src:String):String {
                    if (src == null || src.indexOf("#{") == -1) return src;
                    var buf = new StringBuf();
                    var i0 = 0;
                    while (i0 < src.length) {
                        var o = src.indexOf("#{", i0);
                        if (o == -1) { buf.add(src.substr(i0)); break; }
                        buf.add(src.substr(i0, o - i0));
                        var k0 = o + 2; var dep = 1;
                        while (k0 < src.length && dep > 0) {
                            var ch2 = src.charAt(k0);
                            if (ch2 == '{') dep++; else if (ch2 == '}') dep--; k0++;
                        }
                        var inner2 = src.substr(o + 2, (k0 - 1) - (o + 2));
                        var trimmed2 = StringTools.trim(inner2);
                        var already = StringTools.startsWith(trimmed2, '(fn ->');
                        var outInner = already ? inner2 : '(fn -> ' + inner2 + ' end).()';
                        buf.add("#{" + outInner + "}");
                        i0 = k0;
                    }
                    return buf.toString();
                }
                var strVal = sanitizeJoinArgInInterpolatedString(value);
                strVal = sanitizeInterpolationsInString(strVal);
                '"' + escapeString(strVal) + '"';
                
            case EInteger(value):
                Std.string(value);
                
            case EFloat(value):
                Std.string(value);
                
            case EBoolean(value):
                value ? 'true' : 'false';
                
            case ENil:
                'nil';
                
            case ECharlist(value):
                "'" + escapeString(value) + "'";
                
            // ================================================================
            // Variables and Binding
            // ================================================================
            case EVar(name):
                #if debug_ast_pipeline
                if (name.indexOf("priority") >= 0) {
                    trace('[AST Printer] Printing EVar: ${name}');
                }
                #end

                #if debug_infrastructure_vars
                if (name == "g" || name == "_g" || ~/^_?g\d+$/.match(name)) {
                    trace('[AST Printer EVar] Printing infrastructure variable: $name');
                }
                #end

                // Normalize preserved switch result name to avoid leading underscores
                inline function safeIdent(nm:String):String {
                    return switch (nm) {
                        case "fn" | "do" | "end" | "case" | "cond" | "try" | "rescue" | "catch" | "after" | "receive" | "quote" | "unquote" | "when" | "and" | "or" | "not": nm + "_";
                        default: nm;
                    }
                }
                var printed = safeIdent(name);
                if (name != null && name.length >= 23 && name.substr(0,23) == "__elixir_switch_result_") {
                    printed = "switch_result_" + name.substr(23);
                }
                printed;
                
            case EPin(expr):
                '^' + print(expr, 0);
                
            case EUnderscore:
                '_';
                
            // ================================================================
            // Comprehensions
            // ================================================================
            case EFor(generators, filters, body, into, uniq):
                var genStr = [for (g in generators) 
                    printPattern(g.pattern) + ' <- ' + print(g.expr, 0)
                ].join(', ');
                
                var filterStr = filters.length > 0 
                    ? ', ' + [for (f in filters) print(f, 0)].join(', ')
                    : '';
                
                var options = [];
                if (into != null) options.push('into: ' + print(into, 0));
                if (uniq) options.push('uniq: true');
                var optStr = options.length > 0 ? ', ' + options.join(', ') : '';
                
                'for ' + genStr + filterStr + optStr + ', do: ' + print(body, 0);
                
            // ================================================================
            // Anonymous Functions
            // ================================================================
            /**
             * LESSON LEARNED: Anonymous Function Body Indentation
             * 
             * PROBLEM: When printing anonymous functions with complex bodies (like if statements
             * containing blocks), the body was printed with indent level 0, causing nested
             * expressions to lose their indentation context.
             * 
             * SYMPTOMS:
             * - Method calls inside lambda bodies appeared at column 0
             * - Code like `s.cca(index)` had no indentation inside reduce_while lambdas
             * - Syntax errors in generated Elixir due to improper nesting
             * 
             * ROOT CAUSE: The single-line lambda format used `print(clause.body, 0)` which
             * reset the indentation context to 0, losing all nesting information.
             * 
             * SOLUTION: 
             * 1. Always pass proper indent level to body: `print(clause.body, indent + 1)`
             * 2. Detect when bodies are complex and need multi-line formatting
             * 3. Use multi-line format for if/case/cond/multi-expression blocks
             * 
             * This ensures that nested structures inside lambdas maintain proper indentation
             * throughout the entire AST printing process.
             */
            case EFn(clauses):
                #if debug_loop_builder
                if (clauses.length > 0) {
                    trace('[XRay Printer] Printing EFn with ${clauses.length} clauses');
                    var clause = clauses[0];
                    trace('[XRay Printer]   Clause body type: ${Type.enumConstructor(clause.body.def)}');
                    switch(clause.body.def) {
                        case EIf(cond, thenBranch, elseBranch):
                            trace('[XRay Printer]   Body is EIf - condition type: ${Type.enumConstructor(cond.def)}');
                            trace('[XRay Printer]   Then branch type: ${Type.enumConstructor(thenBranch.def)}');
                        case EBlock(exprs):
                            trace('[XRay Printer]   Body is EBlock with ${exprs.length} expressions');
                        default:
                            trace('[XRay Printer]   Body is: ${Type.enumConstructor(clause.body.def)}');
                    }
                }
                #end

                if (clauses.length == 1 && clauses[0].guard == null) {
                    var clause = clauses[0];
                    var argStr = printPatterns(clause.args);
                    // Handle empty parameter list properly (no extra space)
                    var paramPart = clause.args.length == 0 ? '' : ' ' + argStr;

                    // Check if body is complex and needs multi-line formatting
                    var bodyStr = print(clause.body, indent + 1);
                    // Remove bare numeric sentinel lines within anonymous function bodies
                    inline function stripBareNumericLines(s: String): String {
                        if (s == null || s.length == 0) return s;
                        var lines = s.split('\n');
                        var cleaned: Array<String> = [];
                        for (ln in lines) {
                            var t = StringTools.trim(ln);
                            if (t == '1' || t == '0') continue;
                            cleaned.push(ln);
                        }
                        return cleaned.join('\n');
                    }
                    bodyStr = stripBareNumericLines(bodyStr);

                    #if debug_loop_builder
                    trace('[XRay Printer]   Printed body string (first 200 chars): ${bodyStr.substring(0, bodyStr.length > 200 ? 200 : bodyStr.length)}');
                    #end
                    var isMultiLine = switch(clause.body.def) {
                        case EIf(_, _, _): true;
                        case ECase(_, _): true;
                        case ECond(_): true;
                        case EBlock(exprs) if (exprs.length > 1): true;
                        case _: bodyStr.indexOf('\n') >= 0;
                    };
                    
                    if (isMultiLine) {
                        // Multi-line format for complex bodies
                        'fn' + paramPart + ' ->\n' + 
                        indentStr(indent + 1) + bodyStr + '\n' +
                        indentStr(indent) + 'end';
                    } else {
                        // Single-line format for simple bodies
                        'fn' + paramPart + ' -> ' + bodyStr + ' end';
                    }
                } else {
                    'fn\n' +
                    [for (clause in clauses)
                        indentStr(indent + 1) + printPatterns(clause.args) +
                        (clause.guard != null ? ' when ' + print(clause.guard, 0) : '') +
                        ' ->\n' + indentStr(indent + 2) + print(clause.body, indent + 2)
                    ].join('\n') + '\n' +
                    indentStr(indent) + 'end';
                }
                
            case ECapture(expr, arity):
                // Function reference with arity: &Module.function/arity
                if (arity != null) {
                    '&' + print(expr, 0) + '/' + arity;
                } else {
                    // Regular capture without arity
                    '&' + print(expr, 0);
                }
                
            // ================================================================
            // Module Directives
            // ================================================================
            case EAlias(module, as):
                if (as != null) {
                    'alias ' + module + ', as: ' + as;
                } else {
                    'alias ' + module;
                }
                
            case EImport(module, only, except):
                var result = 'import ' + module;
                if (only != null) {
                    result += ', only: [' + 
                        [for (o in only) o.name + ': ' + o.arity].join(', ') + ']';
                } else if (except != null) {
                    result += ', except: [' +
                        [for (e in except) e.name + ': ' + e.arity].join(', ') + ']';
                }
                result;
                
            case EUse(module, options):
                // Special handling for keyword lists in use statements
                if (options.length == 1) {
                    switch(options[0].def) {
                        case EKeywordList(pairs):
                            // Print keyword list without brackets for use statement
                            'use ' + module + ', ' + [for (p in pairs) {
                                var value = switch(p.value.def) {
                                    case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && 
                                        isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
                                        '(' + print(p.value, 0) + ')';
                                    case _:
                                        print(p.value, 0);
                                };
                                p.key + ': ' + value;
                            }].join(', ');
                        case _:
                            'use ' + module + ', ' + print(options[0], 0);
                    }
                } else if (options.length > 0) {
                    'use ' + module + ', ' + [for (o in options) print(o, 0)].join(', ');
                } else {
                    'use ' + module;
                }
                
            case ERequire(module, as):
                if (as != null) {
                    'require ' + module + ', as: ' + as;
                } else {
                    'require ' + module;
                }
                
            // ================================================================
            // Special Forms
            // ================================================================
            case EQuote(options, expr):
                var optStr = options.length > 0 
                    ? ' ' + [for (o in options) print(o, 0)].join(', ') + ','
                    : '';
                // Use do-end block for multi-line quotes
                switch(expr.def) {
                    case EBlock(_):
                        'quote' + optStr + ' do\n' + indentStr(indent + 1) + print(expr, indent + 1) + '\n' + indentStr(indent) + 'end';
                    case _:
                        'quote' + optStr + ' do: ' + print(expr, 0);
                }
                
            case EUnquote(expr):
                'unquote(' + print(expr, 0) + ')';
                
            case EUnquoteSplicing(expr):
                'unquote_splicing(' + print(expr, 0) + ')';
                
            case EReceive(clauses, after):
                var result = 'receive do\n';
                for (clause in clauses) {
                    result += indentStr(indent + 1) + printCaseClause(clause, indent + 1) + '\n';
                }
                if (after != null) {
                    result += indentStr(indent) + 'after\n' +
                        indentStr(indent + 1) + print(after.timeout, 0) + ' ->\n' +
                        indentStr(indent + 2) + print(after.body, indent + 2) + '\n';
                }
                result + indentStr(indent) + 'end';
                
            case ESend(target, message):
                'send(' + print(target, 0) + ', ' + print(message, 0) + ')';
                
            // ================================================================
            // Blocks and Grouping
            // ================================================================
            case EBlock(expressions):
                // Drop standalone numeric sentinels (1/0/0.0) in statement position
                inline function isBareNumericSentinel(e: ElixirAST): Bool {
                    return switch (e.def) {
                        case EInteger(v) if (v == 0 || v == 1): true;
                        case EFloat(f) if (f == 0.0): true;
                        case ERaw(code) if (code != null && (StringTools.trim(code) == '1' || StringTools.trim(code) == '0')): true;
                        default: false;
                    }
                }
                var statements = [for (e in expressions) if (!isBareNumericSentinel(e)) e];
                if (statements.length == 0) {
                    // Empty blocks generate empty string (no code)
                    // This aligns with TypedExprPreprocessor's semantics where TBlock([])
                    // represents "generate nothing" (e.g., eliminated infrastructure variables)
                    '';
                } else if (statements.length == 1) {
                    print(statements[0], indent);
                } else {
                    var parts = [];
                    var printed: Array<String> = [];
                    for (expr in statements) {
                        var str = print(expr, indent);
                        if (str != null && str.trim().length > 0) {
                            printed.push(str);
                        }
                    }
                    for (i in 0...printed.length) {
                        parts.push(printed[i]);
                        if (i < printed.length - 1) {
                            parts.push('\n' + indentStr(indent));
                        }
                    }
                    parts.join('');
                }
                
            case EParen(expr):
                '(' + print(expr, 0) + ')';
                
            case EDo(body):
                inline function isBareNumericSentinelInDo(e: ElixirAST): Bool {
                    return switch (e.def) {
                        case EInteger(v) if (v == 0 || v == 1): true;
                        case EFloat(f) if (f == 0.0): true;
                        case ERaw(code) if (code != null && (StringTools.trim(code) == '1' || StringTools.trim(code) == '0')): true;
                        default: false;
                    }
                }
                var bodyStmts = [for (e in body) if (!isBareNumericSentinelInDo(e)) e];
                'do\n' +
                [for (expr in bodyStmts)
                    indentStr(indent + 1) + print(expr, indent + 1)
                ].join('\n') + '\n' +
                indentStr(indent) + 'end';
                
            // ================================================================
            // Documentation & Module Attributes
            // ================================================================
            case EModuleAttribute(name, value):
                '@' + name + ' ' + print(value, indent);
                
            case EModuledoc(content):
                '@moduledoc """' + '\n' + content + '\n' + '"""';
                
            case EDoc(content):
                '@doc """' + '\n' + content + '\n' + '"""';
                
            case ESpec(signature):
                '@spec ' + signature;
                
            case ETypeDef(name, definition):
                '@type ' + name + ' :: ' + definition;
                
            // ================================================================
            // Phoenix/Framework Specific
            // ================================================================
            case ESigil(type, content, modifiers):
                // HEEx indentation normalization (quiet when no-traces)
                inline function normalizeHeexIndent(s: String): String {
                    if (s == null || s.length == 0) return s;
                    // Split lines
                    var lines = s.split('\n');
                    // Trim leading/trailing blank lines
                    var start = 0;
                    while (start < lines.length && StringTools.trim(lines[start]) == "") start++;
                    var endIdx = lines.length - 1;
                    while (endIdx >= start && StringTools.trim(lines[endIdx]) == "") endIdx--;
                    if (start > endIdx) return ""; // all blank
                    var slice = lines.slice(start, endIdx + 1);
                    // Compute shared indent (spaces only for HEEx; tabs preserved if present)
                    var minIndent = 1000000;
                    for (ln in slice) {
                        if (StringTools.trim(ln) == "") continue;
                        var i = 0;
                        while (i < ln.length && ln.charAt(i) == ' ') i++;
                        if (i < minIndent) minIndent = i;
                    }
                    if (minIndent == 1000000) minIndent = 0;
                    // Strip shared indent
                    var out = new StringBuf();
                    for (i in 0...slice.length) {
                        var ln = slice[i];
                        if (minIndent > 0 && ln.length >= minIndent) ln = ln.substr(minIndent);
                        out.add(ln);
                        if (i < slice.length - 1) out.add('\n');
                    }
                    return out.toString();
                }
                inline function flattenNestedHeex(s:String):String {
                    if (s == null || s.indexOf("<%=") == -1) return s;
                    var out = new StringBuf(); var i = 0;
                    while (i < s.length) {
                        var o = s.indexOf("<% =".replace(" ",""), i); // '<%='
                        if (o == -1) { out.add(s.substr(i)); break; }
                        out.add(s.substr(i, o - i));
                        var c = s.indexOf("%>", o + 3); if (c == -1) { out.add(s.substr(o)); break; }
                        var inner = StringTools.trim(s.substr(o + 3, c - (o + 3)));
                        if (StringTools.startsWith(inner, "~H\"\"\"")) {
                            var st = inner.indexOf("\"\"\""); if (st != -1) {
                                var bs = st + 3; var be = inner.indexOf("\"\"\"", bs);
                                if (be != -1) { out.add(inner.substr(bs, be - bs)); i = c + 2; continue; }
                            }
                        }
                        // inline-if do/else normalization inside ~H
                        out.add(s.substr(o, (c + 2) - o)); i = c + 2;
                    }
                    var flattened = out.toString();
                    // Fallback: aggressively strip any residual `<%= ~H"""` and trailing `""" %>`
                    if (flattened.indexOf('<%= ~H"""') != -1) {
                        flattened = flattened.split('<%= ~H"""').join('');
                        flattened = flattened.split('""" %>').join('');
                    }
                    return flattened;
                }
                inline function rewriteInlineIfDoToBlock(s:String):String {
                    if (s == null || s.indexOf(", do:") == -1) return s;
                    var i = 0; var out = new StringBuf();
                    while (i < s.length) {
                        var o = s.indexOf("<% =".replace(" ",""), i); if (o == -1) { out.add(s.substr(i)); break; }
                        out.add(s.substr(i, o - i));
                        var c = s.indexOf("%>", o + 3); if (c == -1) { out.add(s.substr(o)); break; }
                        var inner = StringTools.trim(s.substr(o + 3, c - (o + 3)));
                        if (StringTools.startsWith(inner, "if ")) {
                            var rest = StringTools.trim(inner.substr(3));
                            var idx = rest.indexOf(", do: \""); var q = '"';
                            if (idx == -1) { idx = rest.indexOf(", do: '\'"); q = '\''; }
                            if (idx != -1) {
                            var cond = StringTools.trim(rest.substr(0, idx));
                            var after = rest.substr(idx + 7); if (q == '\'') after = rest.substr(idx + 7);
                                var endMark = (q == '"') ? '\"' + ", else:" : "'" + ", else:";
                                var ei = after.indexOf(endMark);
                                if (ei != -1) {
                                    var th = after.substr(0, ei);
                                    var rem = after.substr(ei + endMark.length);
                                    var el: String = null;
                                    if (rem.length >= 1 && rem.charAt(0) == q) {
                                        rem = rem.substr(1); var e2 = rem.indexOf((q == '"') ? '\"' : "'");
                                        if (e2 != -1) el = rem.substr(0, e2);
                                    }
                                    out.add('<%= if ' + cond + ' do %>'); out.add(th);
                                    if (el != null && el != "") { out.add('<% else %>' + el); }
                                    out.add('<% end %>'); i = c + 2; continue;
                                }
                            }
                        }
                        out.add(s.substr(o, (c + 2) - o)); i = c + 2;
                    }
                    return out.toString();
                }
                var normalized = normalizeHeexIndent(content);
                normalized = flattenNestedHeex(normalized);
                // Preserve inline-if forms inside ~H; avoid rewriting to block form here.
                '~' + type + '"""' + '\n' + normalized + '\n' + '"""' + modifiers;
                
            case ERaw(code):
                // Raw code injection with conservative Ecto.from atom→module qualification
                inline function camelize(s: String): String {
                    var parts = s.split("_");
                    var out = [];
                    for (p in parts) if (p.length > 0) out.push(p.charAt(0).toUpperCase() + p.substr(1));
                    return out.join("");
                }
                var out = code;
                if (out.indexOf("Ecto.Query.from(") != -1) {
                    var pfx: Null<String> = null;
                    if (currentModuleName != null) {
                        var idxA = currentModuleName.indexOf("Web");
                        if (idxA > 0) pfx = currentModuleName.substring(0, idxA) else {
                            var idxB = currentModuleName.indexOf(".Repo");
                            if (idxB > 0) pfx = currentModuleName.substring(0, idxB);
                        }
                    }
                    if (pfx == null && observedAppPrefix != null) pfx = observedAppPrefix;
                    if (pfx == null) { try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch (e:Dynamic) {} }
                    if (pfx != null && pfx.length > 0) {
                        var buf = new StringBuf();
                        var i = 0;
                        while (i < out.length) {
                            if (i + 5 < out.length && out.substr(i, 5) == " in :") {
                                var j = i + 5;
                                var name = new StringBuf();
                                while (j < out.length) {
                                    var ch = out.charAt(j);
                                    var isAlnum = ~/^[A-Za-z0-9_]$/.match(ch);
                                    if (!isAlnum) break;
                                    name.add(ch);
                                    j++;
                                }
                                var raw = name.toString();
                                if (raw.length > 0) {
                                    buf.add(" in "); buf.add(pfx); buf.add("."); buf.add(camelize(raw));
                                    i = j; continue;
                                }
                            }
                            buf.add(out.charAt(i));
                            i++;
                        }
                        out = buf.toString();
                    }
                }
                // Sanitize #{...} interpolations so each interpolation is a single valid expression
                inline function sanitizeInterpolationsInRawString(src:String):String {
                    if (src == null || src.indexOf("#{") == -1) return src;
                    var buf = new StringBuf();
                    var i0 = 0;
                    while (i0 < src.length) {
                        var o = src.indexOf("#{", i0);
                        if (o == -1) { buf.add(src.substr(i0)); break; }
                        buf.add(src.substr(i0, o - i0));
                        var k0 = o + 2; var dep = 1;
                        while (k0 < src.length && dep > 0) {
                            var ch = src.charAt(k0);
                            if (ch == '{') dep++; else if (ch == '}') dep--; k0++;
                        }
                        var inner = src.substr(o + 2, (k0 - 1) - (o + 2));
                        var trimmed = StringTools.trim(inner);
                        var alreadyIife = StringTools.startsWith(trimmed, '(fn ->');
                        // Snapshot parity: always wrap interpolation as a single expression via IIFE,
                        // unless it is already IIFE-wrapped.
                        var needsWrap = !alreadyIife;
                        var innerOut = needsWrap ? '(fn -> ' + inner + ' end).()' : inner;
                        buf.add("#{" + innerOut + "}");
                        i0 = k0;
                    }
                    return buf.toString();
                }
                out = sanitizeInterpolationsInRawString(out);
                // Do not add extra parentheses around multi-line strings; Elixir accepts them directly
                out;
                
            case EAssign(name):
                '@' + name;
                
            case EFragment(tag, attributes, children):
                '<' + tag + printAttributes(attributes) + '>' +
                [for (c in children) print(c, 0)].join('') +
                '</' + tag + '>';
        }
    }
    
    /**
     * Print a pattern
     */
    static function printPattern(pattern: EPattern): String {
        return switch(pattern) {
            case PVar(name):
                var nm = name;
                if (nm == null || StringTools.trim(nm).length == 0) nm = '_';
                nm;
            case PLiteral(value): print(value, 0);
            case PTuple(elements):
                #if debug_ast_printer
                trace('[ASTPrinter] Printing PTuple with ${elements.length} elements');
                for (i in 0...elements.length) {
                    var elem = elements[i];
                    switch(elem) {
                        case PVar(name): trace('[ASTPrinter]   Element $i: PVar("$name")');
                        case PLiteral(ast): trace('[ASTPrinter]   Element $i: PLiteral');
                        default: trace('[ASTPrinter]   Element $i: ${Type.enumConstructor(elem)}');
                    }
                }
                #end
                '{' + printPatterns(elements) + '}';
            case PList(elements): '[' + printPatterns(elements) + ']';
            case PCons(head, tail): '[' + printPattern(head) + ' | ' + printPattern(tail) + ']';
            case PMap(pairs): 
                '%{' + [for (p in pairs) print(p.key, 0) + ' => ' + printPattern(p.value)].join(', ') + '}';
            case PStruct(module, fields):
                '%' + module + '{' + [for (f in fields) f.key + ': ' + printPattern(f.value)].join(', ') + '}';
            case PPin(pattern): '^' + printPattern(pattern);
            case PWildcard: '_';
            case PAlias(varName, pattern): printPattern(pattern) + ' = ' + varName;
            case PBinary(segments): '<<' + [for (s in segments) printPatternBinarySegment(s)].join(', ') + '>>';
        }
    }
    
    /**
     * Print multiple patterns
     */
    static function printPatterns(patterns: Array<EPattern>): String {
        return [for (p in patterns) printPattern(p)].join(', ');
    }
    
    /**
     * Print a case clause
     */
    static function printCaseClause(clause: ECaseClause, indent: Int): String {
        var head = printPattern(clause.pattern);
        if (clause.guard != null) {
            head += ' when ' + print(clause.guard, 0);
        }

        // Prefer single-line format for simple bodies, multi-line for complex ones
        var body = clause.body;
        var bodyStr = print(body, indent + 1);
        if (StringTools.trim(bodyStr) == '') bodyStr = 'nil';

        var isBlock = switch (body.def) { case EBlock(_): true; default: false; };
        var isMulti = switch (body.def) {
            case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _): true;
            case ECall(_, _, _) | ERemoteCall(_, _, _): true; // prefer multi-line for calls for readability and snapshot parity
            case EBlock(exprs) if (exprs.length > 1): true;
            case _: bodyStr.indexOf('\n') >= 0;
        };
        var preferSingle = !isBlock && !isMulti && (bodyStr.length <= 120);

        if (!preferSingle && isMulti) {
            return head + ' ->\n' + indentStr(indent + 1) + bodyStr;
        } else {
            return head + ' -> ' + bodyStr;
        }
    }
    
    /**
     * Print a rescue clause
     */
    static function printRescueClause(clause: ERescueClause, indent: Int): String {
        var result = printPattern(clause.pattern);
        if (clause.varName != null) {
            result += ' -> ' + clause.varName;
        }
        result += ' ->\n' + indentStr(indent + 1) + print(clause.body, indent + 1);
        return result;
    }
    
    /**
     * Print a catch clause
     */
    static function printCatchClause(clause: ECatchClause, indent: Int): String {
        var kindStr = switch(clause.kind) {
            case Error: ':error';
            case Exit: ':exit';
            case Throw: ':throw';
            case Any: '_';
        };
        return kindStr + ', ' + printPattern(clause.pattern) + ' ->\n' +
            indentStr(indent + 1) + print(clause.body, indent + 1);
    }
    
    /**
     * Print an attribute
     */
    static function printAttribute(attr: EAttribute): String {
        return '@' + attr.name + ' ' + print(attr.value, 0);
    }
    
    /**
     * Print HTML-like attributes
     */
    static function printAttributes(attrs: Array<EAttribute>): String {
        if (attrs.length == 0) return '';
        var parts = [];
        for (a in attrs) {
            var rendered = switch (a.value.def) {
                case EString(v): '"' + v + '"';
                default: '{' + print(a.value, 0) + '}';
            };
            parts.push(a.name + '=' + rendered);
        }
        return ' ' + parts.join(' ');
    }
    
    /**
     * Print a binary segment
     */
    static function printBinarySegment(segment: EBinarySegment): String {
        var result = print(segment.value, 0);
        var specs = [];
        if (segment.size != null) specs.push('size(' + print(segment.size, 0) + ')');
        if (segment.type != null) specs.push(segment.type);
        if (segment.modifiers != null) specs = specs.concat(segment.modifiers);
        if (specs.length > 0) {
            result += '::' + specs.join('-');
        }
        return result;
    }
    
    /**
     * Print a pattern binary segment
     */
    static function printPatternBinarySegment(segment: PBinarySegment): String {
        var result = printPattern(segment.pattern);
        var specs = [];
        if (segment.size != null) specs.push('size(' + print(segment.size, 0) + ')');
        if (segment.type != null) specs.push(segment.type);
        if (segment.modifiers != null) specs = specs.concat(segment.modifiers);
        if (specs.length > 0) {
            result += '::' + specs.join('-');
        }
        return result;
    }
    
    /**
     * Convert binary operator to string
     */
    static function binaryOpToString(op: EBinaryOp): String {
        return switch(op) {
            case Add: '+';
            case Subtract: '-';
            case Multiply: '*';
            case Divide: '/';
            case Remainder: 'rem';
            case Power: '**';
            case Equal: '==';
            case NotEqual: '!=';
            case StrictEqual: '===';
            case StrictNotEqual: '!==';
            case Less: '<';
            case Greater: '>';
            case LessEqual: '<=';
            case GreaterEqual: '>=';
            case And: 'and';
            case Or: 'or';
            case AndAlso: '&&';
            case OrElse: '||';
            case BitwiseAnd: '&&&';
            case BitwiseOr: '|||';
            case BitwiseXor: '^^^';
            case ShiftLeft: '<<<';
            case ShiftRight: '>>>';
            case Concat: '++';
            case ListSubtract: '--';
            case In: 'in';
            case StringConcat: '<>';
            case Match: '=';
            case Pipe: '|>';
            case TypeCheck: '::';
            case When: 'when';
        }
    }
    
    /**
     * Check if operator is a bitwise operation
     *
     * WHY: Elixir doesn't support custom infix bitwise operators like Haxe
     * - The BEAM VM implements bitwise operations as module functions, not operators
     * - Unlike Haxe's & operator, Elixir requires explicit Bitwise.band() calls
     * - This design enables compile-time optimization and consistent function semantics
     *
     * WHAT: Returns true for all bitwise operators (&, |, ^, <<, >>)
     * - BitwiseAnd (&) requires Bitwise.band()
     * - BitwiseOr (|) requires Bitwise.bor()
     * - BitwiseXor (^) requires Bitwise.bxor()
     * - ShiftLeft (<<) requires Bitwise.bsl()
     * - ShiftRight (>>) requires Bitwise.bsr()
     *
     * HOW: Pattern matches on EBinaryOp enum variants
     * - Simple pattern match covers all 5 bitwise operators
     * - Returns false for all other operators (arithmetic, comparison, etc.)
     */
    static function isBitwiseOp(op: EBinaryOp): Bool {
        return switch(op) {
            case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight: true;
            default: false;
        };
    }

    /**
     * Convert bitwise operator to Bitwise module function name
     *
     * WHY: Elixir/BEAM architectural decision - bitwise ops as functions, not infix operators
     * - BEAM VM design: All bitwise operations implemented as module functions
     * - Type consistency: Functions provide clear integer-only type semantics
     * - Macro expansion: 'use Bitwise' imports these same function names
     * - Historical: Erlang uses 'band', 'bor', etc. - Elixir maintains compatibility
     * - Unlike arithmetic (+, -, *), bitwise ops are less common and don't justify operators
     *
     * WHAT: Maps Haxe bitwise operators to Elixir Bitwise module function names
     * - & (BitwiseAnd) → band (bitwise AND)
     * - | (BitwiseOr) → bor (bitwise OR)
     * - ^ (BitwiseXor) → bxor (bitwise XOR)
     * - << (ShiftLeft) → bsl (bitwise shift left)
     * - >> (ShiftRight) → bsr (bitwise shift right)
     *
     * HOW: Direct string mapping to official Bitwise module API
     * - Returns lowercase function names matching Elixir.Bitwise exports
     * - Throws for non-bitwise operators to catch programming errors
     * - Generated code: Bitwise.band(n, 15) instead of n & 15
     *
     * GENERATED CODE EXAMPLE:
     * ```haxe
     * // Haxe Input
     * var masked = value & 0xFF;
     * ```
     * ```elixir
     * # Generated Elixir
     * masked = Bitwise.band(value, 255)
     * ```
     *
     * ELIXIR DESIGN RATIONALE:
     * The Bitwise module approach provides several benefits:
     * 1. **Explicit imports**: 'use Bitwise' makes bitwise operations visible at module top
     * 2. **Type safety**: Functions enforce integer-only operations at compile-time
     * 3. **Performance**: BEAM can optimize function calls as efficiently as operators
     * 4. **Consistency**: Matches Erlang's band/bor/bxor naming convention
     * 5. **Discoverability**: Bitwise.band() is searchable, & syntax for bitwise is cryptic
     *
     * @see https://hexdocs.pm/elixir/Bitwise.html - Official Bitwise module documentation
     * @see https://www.erlang.org/doc/reference_manual/expressions.html#bitwise-expressions - Erlang bitwise expressions
     * @see test/snapshot/regression/bitwise_operations/ - Comprehensive test suite
     */
    static function bitwiseOpToFunction(op: EBinaryOp): String {
        return switch(op) {
            case BitwiseAnd: 'band';    // Bitwise AND: &
            case BitwiseOr: 'bor';      // Bitwise OR: |
            case BitwiseXor: 'bxor';    // Bitwise XOR: ^
            case ShiftLeft: 'bsl';      // Bitwise Shift Left: <<
            case ShiftRight: 'bsr';     // Bitwise Shift Right: >>
            default: throw 'Not a bitwise operator: $op';
        };
    }

    /**
     * Convert unary operator to string
     */
    static function unaryOpToString(op: EUnaryOp): String {
        return switch(op) {
            case Not: 'not ';
            case Negate: '-';
            case Positive: '+';
            case BitwiseNot: '~~~';
            case Bang: '!';
        }
    }
    
    /**
     * Check if expression needs parentheses
     */
    static function needsParentheses(node: ElixirASTDef): Bool {
        return switch(node) {
            // Subtraction needs parentheses in binary contexts to avoid match errors
            case EBinary(Subtract, _, _): true;
            // Other operations that might need parentheses in certain contexts
            case EBinary(op, _, _): 
                // Add more cases as needed
                false;
            default: false;
        };
    }
    
    /**
     * Escape string for Elixir
     */
    static function escapeString(s: String): String {
        return s.replace('\\', '\\\\')
                .replace('"', '\\"')
                .replace('\n', '\\n')
                .replace('\r', '\\r')
                .replace('\t', '\\t');
    }
    
    /**
     * Generate indentation string
     */
    static function indentStr(level: Int): String {
        var result = '';
        for (i in 0...level) {
            result += '  '; // 2 spaces per level
        }
        return result;
    }
    
    /**
     * Check if an expression is simple enough to be used inline
     */
    static function isSimpleExpression(ast: ElixirAST): Bool {
        if (ast == null) return false;
        
        return switch(ast.def) {
            case EVar(_) | EAtom(_) | ENil | EString(_) | 
                 EInteger(_) | EFloat(_) | EBoolean(_) | 
                 EField(_, _) | ETuple(_) | EList(_) | EMap(_):
                true;
            case ECall(_, _, args):
                // Simple function calls with few arguments
                args.length <= 2;
            case EBinary(op, left, right):
                // Assignment operations cannot be used in inline if-statements
                if (op == Match) {
                    false;
                } else {
                    // Other binary operations are simple if both operands are simple
                    isSimpleExpression(left) && isSimpleExpression(right);
                }
            case EMatch(_, _):
                // Assignments cannot be used in inline if-statements
                false;
            case EBlock(expressions):
                // Empty blocks MUST use block syntax (not inline)
                // This prevents invalid syntax: if c == nil, do: , else:
                if (expressions.length == 0) {
                    return false;  // Force block syntax for empty branches
                }

                // A block is not simple if it contains any assignments
                // This prevents inline if with blocks containing assignments
                for (expr in expressions) {
                    if (containsAssignment(expr)) {
                        return false;
                    }
                }
                // Even without assignments, blocks with multiple statements aren't simple
                expressions.length == 1 && isSimpleExpression(expressions[0]);
            case _:
                false;
        };
    }
    
    /**
     * Check if an expression contains any assignment operations
     */
    static function containsAssignment(ast: ElixirAST): Bool {
        if (ast == null) return false;
        
        return switch(ast.def) {
            case EMatch(_, _): true;
            case EBinary(op, _, _) if (op == Match): true;
            case EBlock(expressions):
                for (expr in expressions) {
                    if (containsAssignment(expr)) return true;
                }
                false;
            case EIf(_, thenBranch, elseBranch):
                containsAssignment(thenBranch) || 
                (elseBranch != null && containsAssignment(elseBranch));
            case _: false;
        };
    }
    
    /**
     * Print an if condition, avoiding unnecessary parentheses
     * In Elixir, simple variables don't need parentheses in if conditions
     */
    static function printIfCondition(condition: ElixirAST): String {
        if (condition == null) return "";
        
        // Check if this is a parenthesized simple expression
        switch(condition.def) {
            case EBinary(_, left, right):
                // Parenthesize when complex constructs appear; also wrap the entire expression for safety
                var needsLeft = switch (left.def) { case ECase(_, _) | ECond(_) | EWith(_,_,_) | EIf(_,_,_): true; default: false; };
                var needsRight = switch (right) { case null: false; case _: switch (right.def) { case ECase(_, _) | ECond(_) | EWith(_,_,_) | EIf(_,_,_): true; default: false; } };
                var leftStr = needsLeft ? '(' + print(left, 0) + ')' : print(left, 0);
                var opStr = binaryOpToString(switch (condition.def) { case EBinary(op, _, _): op; default: Add; });
                var rightStr = (right == null) ? '0' : (needsRight ? '(' + print(right, 0) + ')' : print(right, 0));
                var exprStr = leftStr + ' ' + opStr + ' ' + rightStr;
                // Always parenthesize binary expressions in if/unless conditions to prevent parser ambiguities
                return '(' + exprStr + ')';
            case EParen(inner):
                // If the inner expression is simple, don't add parentheses
                if (isSimpleVariable(inner)) {
                    return print(inner, 0);
                }
                // Otherwise keep the parentheses for complex expressions
                return '(' + print(inner, 0) + ')';
            default:
                var s = print(condition, 0);
                // Last-resort: if a block-form (case/cond/with) appears together with any comparison, parenthesize the entire condition
                var hasComplex = (s.indexOf('case ') != -1 || s.indexOf('cond ') != -1 || s.indexOf('with ') != -1);
                var hasCmpLoose = (s.indexOf('>') != -1 || s.indexOf('<') != -1 || s.indexOf('==') != -1 || s.indexOf('!=') != -1);
                if (hasComplex && hasCmpLoose && !StringTools.startsWith(StringTools.trim(s), '(')) {
                    return '(' + s + ')';
                }
                return s;
        }
    }
    
    /**
     * Check if an expression is a simple variable that doesn't need parentheses
     */
    static function isSimpleVariable(ast: ElixirAST): Bool {
        if (ast == null) return false;
        
        return switch(ast.def) {
            case EVar(_) | ENil | EBoolean(_):
                true;
            default:
                false;
        };
    }
    
    /**
     * Print a function argument, wrapping inline if expressions in parentheses
     * 
     * WHY: Elixir requires parentheses around inline if expressions when used as
     *      function arguments to resolve ambiguity in nested calls
     * WHAT: Detects inline if expressions and wraps them in parentheses
     * HOW: Checks if the argument is an inline if and wraps it if needed
     */
    static function printFunctionArg(arg: ElixirAST, indentLevel: Int = 0): String {
        if (arg == null) return "";
        
        // Check what kind of expression this is
        switch(arg.def) {
            case ERemoteCall(module, funcName, args) if (funcName == "new" && args.length == 0):
                var moduleStr = printQualifiedModule(module);
                return '%'+moduleStr+'{}';
            case ECall(module, funcName, args) if (module != null && funcName == "new" && args.length == 0):
                var moduleStr = printQualifiedModule(module);
                return '%'+moduleStr+'{}';
            case EIf(condition, thenBranch, elseBranch):
                // An if expression needs parentheses when used as a function argument
                // if it will be printed inline (single line)
                // We consider it inline if:
                // 1. It has the keepInlineInAssignment metadata (null coalescing)
                // 2. Or both branches are simple expressions (ternary operator)
                var needsParens = if (arg.metadata != null && arg.metadata.keepInlineInAssignment == true) {
                    true;
                } else {
                    // Check if branches are simple enough to be printed inline
                    var thenSimple = isSimpleExpression(thenBranch);
                    var elseSimple = elseBranch != null ? isSimpleExpression(elseBranch) : true;
                    thenSimple && elseSimple;
                };
                
                if (needsParens) {
                    return '(' + print(arg, indentLevel) + ')';
                } else {
                    return print(arg, indentLevel);
                }
            case ECase(_, _) | ECond(_) | EWith(_,_,_):
                // Always parenthesize case/cond/with when used as a function argument
                // to prevent accidental line breaks splitting the call site
                return '(' + print(arg, indentLevel) + ')';
            case EBinary(Match, _, _):
                // Parenthesize assignment when used directly as a function argument
                return '(' + print(arg, indentLevel) + ')';
                
            case EBlock(expressions) if (expressions.length > 1):
                // Multi-statement blocks in function arguments must be wrapped
                // in immediately-invoked anonymous functions
                return '(fn -> ' + print(arg, indentLevel).rtrim() + ' end).()';
            case EDo(stmts) if (stmts.length > 1):
                // Do-end blocks used as function arguments should also be wrapped
                return '(fn -> ' + print(arg, indentLevel).rtrim() + ' end).()';
            case EParen(inner) if (switch (inner.def) { case EBlock(exprs) if (exprs.length > 1): true; default: false; }):
                // Parenthesized multi-statement block as argument → wrap in IIFE too
                return '(fn -> ' + print(inner, indentLevel).rtrim() + ' end).()';
            
            default:
                return print(arg, indentLevel);
        }
    }

    // Ensure printed argument is a single safe expression.
    // If it contains line breaks and is not already wrapped (paren/IIFE),
    // wrap it in an IIFE to prevent splitting the call site.
    static function sanitizeArgPrinted(s: String, indent: Int): String {
        if (s == null) return "";
        var trimmed = StringTools.trim(s);
        if (trimmed.length == 0) return s;
        var hasBreak = (s.indexOf('\n') != -1);
        var alreadyIIFE = StringTools.startsWith(trimmed, "(fn ->");
        // Allow multi-line string literals as arguments without wrapping
        var isStringLiteral = StringTools.startsWith(trimmed, '"');
        if (hasBreak && !alreadyIIFE && !isStringLiteral) {
            return '(fn -> ' + s + ' end).()';
        }
        return s;
    }

    /**
     * Print a module reference with context-aware qualification rules
     * - Qualify bare Repo.* to <App>.Repo inside <App>Web.* modules
     */
    static function printQualifiedModule(module: ElixirAST): String {
        // Compute app prefix from current module name (e.g., TodoAppWeb.* -> TodoApp)
        inline function currentAppPrefix(): Null<String> {
            if (currentModuleName == null) return null;
            var idx = currentModuleName.indexOf("Web");
            return idx > 0 ? currentModuleName.substring(0, idx) : null;
        }

        switch (module.def) {
            case EVar(name) if (name == "Repo"):
                var prefix = currentAppPrefix();
                if (prefix != null) return prefix + ".Repo";
                if (observedAppPrefix != null) return observedAppPrefix + ".Repo";
                try {
                    var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
                    if (app != null && app.length > 0) return app + ".Repo";
                } catch (e:Dynamic) {}
                return name;
            case EVar(name) if (name == "Presence"):
                var prefix = currentAppPrefix();
                if (prefix != null) return prefix + "Web.Presence"; else return name;
            case EVar(n):
                // Never qualify standard/framework modules
                if (reflaxe.elixir.ast.StdModuleWhitelist.isWhitelistedQualified(n)) {
                    return print(module, 0);
                }
                // In <App>Web.* modules, qualify single-segment CamelCase roots to <App>.<Name>
                if (currentModuleName != null && currentModuleName.indexOf("Web") != -1) {
                    var idx = currentModuleName.indexOf("Web");
                    var app = idx > 0 ? currentModuleName.substring(0, idx) : null;
                    inline function isSingleSegmentCamel(name:String):Bool {
                        if (name == null || name.length == 0) return false;
                        return name.indexOf(".") == -1 && name.charAt(0).toUpperCase() == name.charAt(0) && name.charAt(0).toLowerCase() != name.charAt(0);
                    }
                    // Do not qualify the application web module itself (e.g., TodoAppWeb)
                    if (app != null && (n == app + "Web")) {
                        return n;
                    }
                    if (app != null && isSingleSegmentCamel(n)) {
                        return app + "." + n;
                    }
                }
                // Outside Web.* modules, conservatively qualify well-known Phoenix Web modules
                // e.g., TodoLive, HTML, CoreComponents, Layouts → <App>Web.<Name>
                inline function isSingleSegmentCamel(name:String):Bool {
                    if (name == null || name.length == 0) return false;
                    return name.indexOf(".") == -1 && name.charAt(0).toUpperCase() == name.charAt(0) && name.charAt(0).toLowerCase() != name.charAt(0);
                }
                inline function isPhoenixWebRoot(name:String):Bool {
                    return name == "Routes" || name == "Gettext" || name == "HTML" || name == "CoreComponents" || name == "Components" || name == "Layouts" || StringTools.endsWith(name, "Live");
                }
                var appPrefix = observedAppPrefix;
                if (appPrefix == null && currentModuleName != null) {
                    var idx2 = currentModuleName.indexOf("Web");
                    if (idx2 > 0) appPrefix = currentModuleName.substring(0, idx2);
                }
                if (appPrefix != null && isSingleSegmentCamel(n) && isPhoenixWebRoot(n)) {
                    return appPrefix + "Web." + n;
                }
                return print(module, 0);
            default:
                return print(module, 0);
        }
    }

    /**
     * Check if a string represents a module name
     * Module names start with uppercase and can contain dots
     * Examples: "Phoenix.PubSub", "TodoApp.Repo", "Task.Supervisor"
     */
    static function isModuleName(s: String): Bool {
        if (s.length == 0) return false;
        
        var firstChar = s.charAt(0);
        if (firstChar != firstChar.toUpperCase()) return false;
        
        // Check if all parts start with uppercase
        var parts = s.split('.');
        for (part in parts) {
            if (part.length == 0) return false;
            var first = part.charAt(0);
            if (first != first.toUpperCase() || !~/^[A-Z]/.match(first)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Check if an atom value is likely an application-specific module name
     * that should not be quoted even with dots.
     * 
     * This is a heuristic for Phoenix apps where module names like
     * TodoApp.PubSub or MyApp.Repo should not be quoted.
     */
    static function isAppModuleName(s: String): Bool {
        // First check if it's a valid module name format
        if (!isModuleName(s)) return false;
        
        // Check for common Phoenix/Elixir app patterns
        // App modules typically contain "App" or end with common suffixes
        return s.indexOf("App") != -1 || 
               s.endsWith(".PubSub") || 
               s.endsWith(".Repo") || 
               s.endsWith(".Endpoint") ||
               s.endsWith(".Telemetry") ||
               s.endsWith(".Supervisor") ||
               s.endsWith(".Application") ||
               s.endsWith("Web");
    }
    
    /**
     * Helper to check if a character is a letter (a-z or A-Z)
     */
    static function isLetter(c: String): Bool {
        if (c.length != 1) return false;
        var code = c.charCodeAt(0);
        return (code >= 65 && code <= 90) || // A-Z
               (code >= 97 && code <= 122);   // a-z
    }
    
    /**
     * Helper to check if a character is a digit (0-9)
     */
    static function isDigit(c: String): Bool {
        if (c.length != 1) return false;
        var code = c.charCodeAt(0);
        return code >= 48 && code <= 57; // 0-9
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/ElixirASTTransformer.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

#if macro
import haxe.macro.Context;
#end

import haxe.macro.Expr.Position;
import reflaxe.elixir.ast.ASTUtils;
import reflaxe.elixir.ast.ElixirAST.VarOrigin;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTBuilder;
import reflaxe.elixir.ast.naming.ElixirAtom;
import reflaxe.elixir.ast.transformers.GuardConditionFlattener;
import reflaxe.elixir.ast.transformers.LoopVariableRestorer;
import reflaxe.elixir.ast.transformers.PatternMatchingTransforms;
import reflaxe.elixir.ast.transformers.StructUpdateTransform;

using StringTools;

/**
 * Transformation pass function type
 * Takes an AST node and returns a transformed node
 *
 * WHY: Stateless transformations that don't need compilation context
 * WHEN: Use for passes that only need AST structure (pattern matching, syntax cleanup)
 */
typedef TransformPass = (ast: ElixirAST) -> ElixirAST;

/**
 * Contextual transformation pass function type
 * Takes an AST node and compilation context, returns a transformed node
 *
 * WHY: Enable passes to access shared compilation state (variable mappings, metadata)
 * WHEN: Use for passes that need:
 *   - Variable rename information (tempVarRenameMap)
 *   - Cross-expression state tracking
 *   - Coordination with builder phase decisions
 *
 * ARCHITECTURE:
 * - Context provides authoritative source of truth for variable naming
 * - Passes read from and write to context.tempVarRenameMap
 * - Ensures consistency between builder and transformer phases
 *
 * EXAMPLE: HygieneTransforms.usageAnalysisPass uses context to:
 *   - Read variable renames from builder phase
 *   - Apply consistent underscore prefixes
 *   - Ensure declarations match references
 */
typedef ContextualTransformPass = (ast: ElixirAST, context: reflaxe.elixir.CompilationContext) -> ElixirAST;

/**
 * Pass configuration
 *
 * WHY: Hybrid pattern supporting both stateless and contextual passes
 * WHAT: Each pass can provide either or both variants
 * HOW: transform() checks for contextualPass first, falls back to pass
 *
 * BACKWARD COMPATIBILITY:
 * - Existing passes continue to work with only 'pass' field
 * - New passes can use 'contextualPass' when context needed
 * - Migration is gradual, pass by pass
 */
typedef PassConfig = {
    name: String,
    description: String,
    enabled: Bool,
    pass: TransformPass,
    /**
     * Optional contextual variant of the pass (receives CompilationContext)
     */
    ?contextualPass: ContextualTransformPass,
    /**
     * Optional phase tag used for coarse ordering groups (e.g., "early", "post_interpolate").
     * When omitted, the pass remains in its original relative position unless constrained
     * by runAfter/runBefore.
     */
    ?phase: String,
    /**
     * Optional hard ordering constraints. Each entry indicates a pass name that this
     * pass must run AFTER. Multiple entries are allowed. Names not present in the registry
     * are ignored to keep ordering robust across optional builds.
     */
    ?runAfter: Array<String>,
    /**
     * Optional hard ordering constraints. Each entry indicates a pass name that this
     * pass must run BEFORE. Multiple entries are allowed. Unknown names are ignored.
     */
    ?runBefore: Array<String>
};

/**
 * ElixirASTTransformer: AST-to-AST Transformation Engine (Transformation Phase)
 * 
 * WHY: Central transformation phase for converting Haxe patterns to idiomatic Elixir
 * - Separates transformation logic from parsing and generation
 * - Enables multiple optimization and idiom conversion passes
 * - Makes transformations testable and composable
 * - Allows gradual addition of new transformations without breaking existing ones
 * 
 * WHAT: Applies a series of transformation passes to ElixirAST
 * - Each pass focuses on one specific transformation
 * - Passes can be enabled/disabled independently
 * - Transformations preserve semantics while improving idiomaticity
 * - Handles imperative→functional, mutable→immutable, loops→comprehensions
 * 
 * HOW: Pass-based architecture with recursive AST traversal
 * - Identity transformation as base (pass-through unchanged)
 * - Each pass is a separate function that pattern matches on AST nodes
 * - Passes are composed in a specific order for correctness
 * - Metadata preserved and enriched through transformations
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Each pass has one transformation goal
 * - Open/Closed: New passes can be added without modifying existing
 * - Composability: Passes can be combined and reordered
 * - Debuggability: Each pass can be tested in isolation
 * - Performance: Only enabled passes are executed
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTTransformer {
    // Public aliases for local transform passes (for registry access)
    public static var alias_abstractMethodThisPass: TransformPass = abstractMethodThisPass;
    public static var alias_arrayLengthFieldToFunctionPass: TransformPass = arrayLengthFieldToFunctionPass;
    public static var alias_bitwiseImportPass: TransformPass = bitwiseImportPass;
    public static var alias_comprehensionConversionPass: TransformPass = comprehensionConversionPass;
    public static var alias_conditionalReassignmentPass: TransformPass = conditionalReassignmentPass;
    public static var alias_constantFoldingPass: TransformPass = constantFoldingPass;
    public static var alias_ectoQueryRequirePass: TransformPass = ectoQueryRequirePass;
    public static var alias_fixBareConcatenationsPass: TransformPass = fixBareConcatenationsPass;
    public static var alias_fluentApiOptimizationPass: TransformPass = fluentApiOptimizationPass;
    public static var alias_functionReferenceTransformPass: TransformPass = functionReferenceTransformPass;
    public static var alias_guardGroupingPass: TransformPass = guardGroupingPass;
    public static var alias_heexContentInlinePass: TransformPass = heexContentInlinePass;
    public static var alias_identityPass: TransformPass = identityPass;
    public static var alias_idiomaticEnumPatternMatchingPass: TransformPass = idiomaticEnumPatternMatchingPass;
    public static var alias_immutabilityTransformPass: TransformPass = immutabilityTransformPass;
    public static var alias_instanceMethodTransformPass: TransformPass = instanceMethodTransformPass;
    public static var alias_listEffectLiftingPass: TransformPass = listEffectLiftingPass;
    public static var alias_liveViewCoreComponentsImportPass: TransformPass = liveViewCoreComponentsImportPass;
    public static var alias_loopTransformationPass: TransformPass = loopTransformationPass;
    public static var alias_nullCoalescingInlinePass: TransformPass = nullCoalescingInlinePass;
    public static var alias_numericNoOpCleanupPass: TransformPass = numericNoOpCleanupPass;
    public static var alias_otpChildSpecTransformPass: TransformPass = otpChildSpecTransformPass;
    public static var alias_phoenixComponentImportPass: TransformPass = phoenixComponentImportPass;
    public static var alias_phoenixFunctionMappingPass: TransformPass = phoenixFunctionMappingPass;
    public static var alias_pipelineOptimizationPass: TransformPass = pipelineOptimizationPass;
    public static var alias_prefixUnusedParametersPass: TransformPass = prefixUnusedParametersPass;
    public static var alias_removeRedundantEnumExtractionPass: TransformPass = removeRedundantEnumExtractionPass;
    public static var alias_removeRedundantNilInitPass: TransformPass = removeRedundantNilInitPass;
    public static var alias_selfReferenceTransformPass: TransformPass = selfReferenceTransformPass;
    public static var alias_statementContextTransformPass: TransformPass = statementContextTransformPass;
    public static var alias_stringInterpolationPass: TransformPass = stringInterpolationPass;
    public static var alias_stringMethodTransformPass: TransformPass = stringMethodTransformPass;
    public static var alias_structFieldAssignmentTransformPass: TransformPass = structFieldAssignmentTransformPass;
    public static var alias_supervisorOptionsTransformPass: TransformPass = supervisorOptionsTransformPass;
    public static var alias_throwStatementTransformPass: TransformPass = throwStatementTransformPass;
    public static var alias_tupleElemFieldToFunctionPass: TransformPass = tupleElemFieldToFunctionPass;
    public static var alias_underscoreVariableCleanupPass: TransformPass = underscoreVariableCleanupPass;

    // Public aliases for local transform passes (for registry access)

    // Public aliases for local transform passes (for registry access)

    
    /**
     * Main entry point: Apply all transformation passes
     *
     * WHY: Single interface for all AST transformations with optional context support
     * WHAT: Applies enabled passes in order, using contextual variant when available
     * HOW: Iterates through pass list, selecting appropriate variant for each pass
     *
     * CONTEXTUAL PASS SUPPORT:
     * - If pass has contextualPass AND context provided → Use contextual variant
     * - Otherwise → Use stateless pass (backward compatible)
     * - Enables passes to access compilation state (variable mappings, metadata)
     * - Ensures consistency between builder and transformer phases
     *
     * @param ast The AST to transform
     * @param context Optional compilation context for contextual passes
     * @return Transformed AST
     */
    public static function transform(ast: ElixirAST, ?context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_ast_transformer
        #if sys
        Sys.println('[XRay AST Transformer] Starting transformation pipeline');
        #else
        trace('[XRay AST Transformer] Starting transformation pipeline');
        #end
        trace('[XRay AST Transformer] AST type: ${Type.enumConstructor(ast.def)}');
        trace('[XRay AST Transformer] AST metadata: ${ast.metadata}');
        #end
        #if debug_unrolled_comprehension
        trace('[DEBUG Transform] ElixirASTTransformer.transform() called');
        #end
        
        #if debug_ast_structure
        // Print AST structure for debugging
        switch(ast.def) {
            case EModule(name, _, _):
                trace('[XRay AST Structure] Module: $name');
            default:
                trace('[XRay AST Structure] Root: ${ast.def}');
        }
        #end

        #if hxx_ast_progress
        transformInvocationCounter++;

        var rootName = switch (ast.def) {
            case EModule(name, _, _) | EDefmodule(name, _):
                name;
            default:
                "<root>";
        };

        #if sys
        Sys.println('[ASTProgress] #' + transformInvocationCounter + ' ' + rootName);
        #else
        trace('[ASTProgress] #' + transformInvocationCounter + ' ' + rootName);
        #end
        #end

        #if hxx_pass_trace
        var passTraceEnabled = false;
        var passTraceFilter = getDefineString("hxx_pass_trace_filter");
        if (passTraceFilter == null || (rootName != null && rootName.indexOf(passTraceFilter) != -1)) {
            passTraceEnabled = true;
        }
        #end
        
        var passes = getEnabledPasses();
        var result = ast;

        #if (hxx_pass_timing && !hxx_disable_timing)
        var __pipelineStart = haxe.Timer.stamp();
        // Optional substring filter to reduce timing noise:
        //   -D hxx_pass_timing_filter=Reduce
        var __passTimingFilter = getDefineString("hxx_pass_timing_filter");
        if (__passTimingFilter != null && __passTimingFilter == "") __passTimingFilter = null;
        #end
        
        for (passConfig in passes) {
            // Skip disabled passes - the enabled flag MUST be respected
            if (!passConfig.enabled) {
                #if debug_ast_transformer
                trace('[XRay AST Transformer] Skipping disabled pass: ${passConfig.name}');
                #end
                continue;
            }

            #if debug_ast_transformer
            #if sys
            Sys.println('[XRay AST Transformer] Applying pass: ${passConfig.name}');
            #else
            trace('[XRay AST Transformer] Applying pass: ${passConfig.name}');
            #end
            #end

            #if hxx_pass_trace
            if (passTraceEnabled) {
                #if sys
                Sys.println('[PassTrace] module=' + rootName + ' pass=' + passConfig.name + ' start');
                #else
                trace('[PassTrace] module=' + rootName + ' pass=' + passConfig.name + ' start');
                #end
            }
            #end

            /**
             * PassMetrics (debug_pass_metrics)
             *
             * WHAT
             * - Optional, flag‑gated per‑pass change detector that reports when a pass
             *   modifies the AST during the main transformation loop.
             *
             * WHY
             * - Speeds up diagnosis of "which pass changed this?" without heavy logging
             *   or snapshotting. Helps avoid circular debugging by pinpointing impact.
             *
             * HOW
             * - Before running a pass, render the current AST to a string using the printer.
             * - After the pass, render again and compare. If different, emit a concise
             *   line: `#[PassMetrics] Changed by: <passName>`.
             * - Guarded by `-D debug_pass_metrics`; zero cost and zero output otherwise.
             *
             * EXAMPLES
             * - Build with: `-D debug_pass_metrics` to get a per‑pass change trace.
             * - Typical output:
             *   `#[PassMetrics] Changed by: FilterQueryConsolidate`
             */
            #if debug_pass_metrics
            var __beforePrint: String = null;
            try __beforePrint = reflaxe.elixir.ast.ElixirASTPrinter.print(result, 0) catch (e: Dynamic) {}
            #end

            // CONTEXTUAL PASS SELECTION LOGIC
            // WHY: Enable passes to access compilation context when needed
            // WHAT: Check for contextualPass variant first, fall back to regular pass
            // HOW: Conditional logic based on contextualPass availability and context presence
            //
            // ARCHITECTURE:
            // 1. If contextualPass exists AND context provided → Use contextual variant
            // 2. Otherwise → Use stateless pass variant (backward compatible)
            //
            // This ensures:
            // - Contextual passes get access to tempVarRenameMap for consistency
            // - Non-contextual passes continue working unchanged
            // - No null pointer errors when context not provided
            #if (hxx_pass_timing && !hxx_disable_timing)
            var __t0 = haxe.Timer.stamp();
            #end
            #if debug_transformer_hang
            // Reset cycle detector per pass so visit counts reflect only the current pass.
            visitedNodes = new Map();
            nodeVisitCounter = 0;
            currentPassName = passConfig.name;
            #end
            if (passConfig.contextualPass != null && context != null) {
                #if debug_contextual_passes
                trace('[XRay Contextual Pass] Using contextual variant for: ${passConfig.name}');
                trace('[XRay Contextual Pass] Context available: ${context != null}');
                trace('[XRay Contextual Pass] Variable mappings: ${context.tempVarRenameMap.keys()}');
                #end

                result = passConfig.contextualPass(result, context);
            } else {
                #if debug_contextual_passes
                trace('[XRay Contextual Pass] Using stateless variant for: ${passConfig.name}');
                trace('[XRay Contextual Pass] Contextual variant available: ${passConfig.contextualPass != null}');
                trace('[XRay Contextual Pass] Context provided: ${context != null}');
                #end

                result = passConfig.pass(result);
            }
            #if (hxx_pass_timing && !hxx_disable_timing)
            var __elapsedPass = (haxe.Timer.stamp() - __t0) * 1000.0;

            // Apply optional substring filter when present.
            var __shouldLogPass = true;
            if (__passTimingFilter != null) {
                __shouldLogPass = (passConfig.name.indexOf(__passTimingFilter) != -1);
            }

            if (__shouldLogPass) {
                #if sys
                // Append timing to a deterministic file so partial logs survive.
                try {
                    var __log = sys.io.File.append("/tmp/passF-macro.log", false);
                    __log.writeString("[PassTiming] name=" + passConfig.name + " ms=" + Std.int(__elapsedPass) + "\n");
                    __log.close();
                } catch (e: Dynamic) {
                    // Fallback to stdout if append fails.
                    Sys.println('[PassTiming] name=' + passConfig.name + ' ms=' + Std.int(__elapsedPass));
                }
                #else
                trace('[PassTiming] name=' + passConfig.name + ' ms=' + Std.int(__elapsedPass));
                #end
            }
            #end

            #if debug_ast_snapshots
            // Per‑pass function snapshot: when debug_ast_snapshots_func is set,
            // dump the target function after each pass to tmp/ast_flow/passes.
            try {
                PerPassSnapshot.emitFunctionAfterPass(result, passConfig.name);
            } catch (e: Dynamic) {
                #if sys Sys.println('[AST Snapshot] PerPass failed for ' + passConfig.name + ': ' + Std.string(e)); #end
            }
            #end

            #if debug_pass_metrics
            var __afterPrint: String = null;
            var __changed: Bool = false;
            try {
                __afterPrint = reflaxe.elixir.ast.ElixirASTPrinter.print(result, 0);
                __changed = (__beforePrint != __afterPrint);
            } catch (e: Dynamic) {}
            if (__changed) {
                #if sys Sys.println('#[PassMetrics] Changed by: ' + passConfig.name); #else trace('#[PassMetrics] Changed by: ' + passConfig.name); #end
            }
            #end

            #if hxx_pass_trace
            if (passTraceEnabled) {
                #if sys
                Sys.println('[PassTrace] module=' + rootName + ' pass=' + passConfig.name + ' end');
                #else
                trace('[PassTrace] module=' + rootName + ' pass=' + passConfig.name + ' end');
                #end
            }
            #end
        }
        
        #if (hxx_pass_timing && !hxx_disable_timing)
        var __pipelineElapsed = (haxe.Timer.stamp() - __pipelineStart) * 1000.0;
        #if sys
        try {
            var __totalLog = sys.io.File.append("/tmp/passF-macro.log", false);
            __totalLog.writeString("[PassTiming] name=ElixirASTTransformer.total ms=" + Std.int(__pipelineElapsed) + "\n");
            __totalLog.close();
        } catch (e: Dynamic) {
            Sys.println('[PassTiming] name=ElixirASTTransformer.total ms=' + Std.int(__pipelineElapsed));
        }
        #else
        trace('[PassTiming] name=ElixirASTTransformer.total ms=' + Std.int(__pipelineElapsed));
        #end
        #end

        #if debug_ast_transformer
        trace('[XRay AST Transformer] Transformation complete');
        #end

        // ------------------------------------------------------------------
        // AbsoluteFinal Snapshot (debug_ast_snapshots)
        //
        // WHAT
        // - Optional, flag‑gated AST snapshot immediately before printing.
        // - Captures only the then‑branch of the main guard `if` inside
        //   filter_todos/3 for the todo‑app to minimize noise.
        //
        // WHY
        // - We need to confirm the final shape of the filter branch:
        //   either a named binder `query = String.downcase(search_query)`
        //   precedes Enum.filter, or the downcased query is inlined within
        //   the filter predicate (EFn/ERaw). Pass ordering and rescue/final
        //   rewrites make late shape shifts hard to reason about via logs.
        //
        // HOW
        // - When `-D debug_ast_snapshots` is set, traverse the transformed
        //   AST, find `filter_todos/3` (EDef/EDefp name "filter_todos" with
        //   arity 3), locate the first top‑level EIf within its body, and
        //   print its thenBranch to `tmp/ast_flow/AbsoluteFinal_filter_todos_then_branch.ex`.
        // - Optional defines (if provided) allow function‑level selection:
        //   `-D debug_ast_snapshots_func=filter_todos/3`
        //   `-D debug_ast_snapshots_module=TodoAppWeb.TodoLive`
        //   These are best‑effort; default targets filter_todos/3 globally.
        //
        // EXAMPLES
        // Haxe (goal):
        //   if (searchQuery != "") {
        //     final query = String.downcase(searchQuery);
        //     return Enum.filter(todos, (t) -> String.contains(String.downcase(t.title), query));
        //   } else {
        //     todos;
        //   }
        // Elixir snapshot (then‑branch):
        //   query = String.downcase(search_query)
        //   Enum.filter(todos, fn t -> String.contains?(String.downcase(t.title), query) end)
        //   # or inline: Enum.filter(..., fn t -> String.contains?(String.downcase(t.title), String.downcase(search_query)) end)
        // ------------------------------------------------------------------
        #if debug_ast_snapshots
        try {
            AbsoluteFinalSnapshot.emitFilterTodosThenBranch(result);
        } catch (e: Dynamic) {
            #if sys Sys.println('[AST Snapshot] Failed: ' + Std.string(e)); #else trace('[AST Snapshot] Failed: ' + Std.string(e)); #end
        }
        #end

        #if debug_ast_transformer
        trace('[XRay AST Transformer] Transformation complete');
        #end
        return result;
    }
    
    /**
     * Get list of enabled transformation passes
     */
    static function getEnabledPasses(): Array<PassConfig> {
        var passes = reflaxe.elixir.ast.transformers.registry.ElixirASTPassRegistry.getEnabledPasses();

        #if macro
        var disableSpec = getDefineString("hxx_disable_passes");
        if (disableSpec != null && disableSpec != "") {
            var tokens = disableSpec.split(",");
            var disabled = new Array<String>();
            for (tok in tokens) {
                var trimmed = tok.trim();
                if (trimmed != "") disabled.push(trimmed);
            }

            if (disabled.length > 0) {
                #if sys
                Sys.println('[AST PassFilter] hxx_disable_passes=' + disabled.join(","));
                #else
                trace('[AST PassFilter] hxx_disable_passes=' + disabled.join(","));
                #end

                passes = [
                    for (p in passes)
                    if (!isPassDisabled(p.name, disabled)) p
                ];
            }
        }
        #end

        return passes;
    }

    /**
     * Helper: read a string define in macro context; returns null when absent.
     */
    static inline function getDefineString(name: String): Null<String> {
        #if macro
        try {
            return Context.definedValue(name);
        } catch (_: Dynamic) {
            return null;
        }
        #else
        return null;
        #end
    }

    static function isPassDisabled(passName: String, disabled: Array<String>): Bool {
        for (token in disabled) {
            if (passName == token) return true;
        }
        return false;
    }

    // (debug_ast_snapshots helper moved to a top-level private class below)


    /**
     * Guard Condition Grouping Pass
     * 
     * WHY: When Haxe switch statements contain multiple cases with the same pattern but different 
     * guard conditions, the compiler was generating nested if-else statements with undefined variables.
     * This pass transforms these patterns into idiomatic Elixir `cond` statements.
     * 
     * WHAT: Transforms multiple case clauses with identical patterns but different guards into
     * a single clause with a `cond` expression in the body.
     * 
     * Example transformation:
     *   case color do
     *     {:rgb, r, g, b} when r > 200 -> "red dominant"
     *     {:rgb, r, g, b} when g > 200 -> "green dominant"  
     *     {:rgb, r, g, b} when b > 200 -> "blue dominant"
     *     {:rgb, r, g, b} -> "balanced"
     *   end
     * 
     * Becomes:
     *   case color do
     *     {:rgb, r, g, b} ->
     *       cond do
     *         r > 200 -> "red dominant"
     *         g > 200 -> "green dominant"
     *         b > 200 -> "blue dominant"
     *         true -> "balanced"
     *       end
     *   end
     * 
     * HOW: Uses metadata attached by ElixirASTBuilder (patternKey, boundVars, hasGuard)
     * to detect groupable clauses and transform them.
     */
    public static function guardGroupingPass(ast: ElixirAST): ElixirAST {
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Starting guard grouping pass with three-phase flattener');
        if (ast != null && ast.def != null) {
            trace('[XRay GuardGrouping] Processing node type: ' + ast.def);
        }
        #end
        
        // Handle null nodes
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EParen(inner):
                // Check if the parentheses wrap a case expression
                #if debug_guard_grouping
                trace("[XRay GuardGrouping] Found EParen, checking inner content");
                #end
                
                switch(inner?.def) {
                    case ECase(target, clauses):
                        #if debug_guard_grouping
                        trace("[XRay GuardGrouping] Found ECase inside EParen, transforming");
                        #end
                        
                        // Transform the case expression
                        var transformedClauses = [];
                        for (clause in clauses) {
                            var transformedClause = transformClauseWithGuards(clause);
                            transformedClauses.push(transformedClause);
                        }
                        
                        // Return the transformed case WITHOUT parentheses
                        // (parentheses around case are usually not needed)
                        makeASTWithMeta(
                            ECase(transformAST(target, guardGroupingPass), transformedClauses),
                            ast.metadata,
                            ast.pos
                        );
                        
                    default:
                        // Not a case inside parentheses, recurse normally
                        makeASTWithMeta(
                            EParen(transformAST(inner, guardGroupingPass)),
                            ast.metadata,
                            ast.pos
                        );
                }
                
            case ECase(target, clauses):
                #if debug_guard_grouping
                trace("[XRay GuardGrouping] Found direct ECase with " + clauses.length + " clauses");
                #end
                
                // Transform each clause individually
                var transformedClauses = [];
                
                for (clause in clauses) {
                    // Check if the clause body is a nested if-else chain (guards compiled by Haxe)
                    var transformedClause = transformClauseWithGuards(clause);
                    transformedClauses.push(transformedClause);
                }
                
                makeASTWithMeta(
                    ECase(transformAST(target, guardGroupingPass), transformedClauses),
                    ast.metadata,
                    ast.pos
                );
                
            default:
                // For nodes we don't handle, use transformAST to recursively transform children
                transformAST(ast, guardGroupingPass);
        };
    }
    
    /**
     * Transform a case clause that has guards compiled as nested if-else
     * Uses the three-phase GuardConditionFlattener for robust transformation
     */
    static function transformClauseWithGuards(clause: ECaseClause): ECaseClause {
        #if debug_guard_grouping
        trace("[XRay GuardGrouping] Examining clause with three-phase flattener");
        if (clause.pattern != null) {
            trace("[XRay GuardGrouping] Pattern type: " + Type.typeof(clause.pattern));
        }
        if (clause.body != null) {
            trace("[XRay GuardGrouping] Body def: " + clause.body.def);
        }
        #end
        
        // Phase 1: Collect all guard conditions from nested if-else chains
        var guardBranches = GuardConditionCollector.collectAllGuardConditions(clause.body);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 1 - Collected ${guardBranches.length} guard branches');
        #end
        
        // If no guard conditions found, just transform recursively
        if (guardBranches.length == 0) {
            return {
                pattern: clause.pattern,
                guard: clause.guard,
                body: transformAST(clause.body, guardGroupingPass)
            };
        }
        
        // Phase 2: Validate that conditions can be grouped
        // Extract bound variables from the pattern for validation
        var boundVars = extractBoundVariablesFromPattern(clause.pattern);
        var validationResult = GuardGroupValidator.validateGuardGroup(guardBranches, boundVars);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 2 - Validation result: canGroup=${validationResult.canGroup}, reason="${validationResult.reason}"');
        #end
        
        // If validation fails, fall back to recursive transformation
        if (!validationResult.canGroup) {
            #if debug_guard_grouping
            trace('[XRay GuardGrouping] Validation failed: ${validationResult.reason}');
            #end
            return {
                pattern: clause.pattern,
                guard: clause.guard,
                body: transformAST(clause.body, guardGroupingPass)
            };
        }
        
        // Phase 3: Reconstruct as a flat cond expression
        var flatCond = GuardConditionReconstructor.buildFlatCond(guardBranches, boundVars, clause.pattern);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 3 - Built flat cond expression');
        #end
        
        return {
            pattern: clause.pattern,
            guard: null,
            body: flatCond
        };
    }
    
    /**
     * Extract bound variable names from a pattern
     */
    static function extractBoundVariablesFromPattern(pattern: EPattern): Array<String> {
        var vars = [];
        
        function extract(p: EPattern): Void {
            switch(p) {
                case PVar(name): 
                    vars.push(name);
                case PTuple(patterns):
                    // Tuples can contain variables (like enum constructors)
                    for (subPattern in patterns) {
                        extract(subPattern);
                    }
                case PList(patterns):
                    for (subPattern in patterns) {
                        extract(subPattern);
                    }
                case PAlias(varName, pattern):
                    vars.push(varName);
                    extract(pattern);
                case PCons(head, tail):
                    extract(head);
                    extract(tail);
                default:
                    // Other patterns don't bind variables
            }
        }
        
        if (pattern != null) {
            extract(pattern);
        }
        
        return vars;
    }
    
    /**
     * Remove nil assignments for generated variables (r2 = nil, b3 = nil, etc.)
     * These are created by Haxe's guard compilation but are not needed
     */
    static function removeNilAssignments(ast: ElixirAST): ElixirAST {
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EBlock(exprs):
                #if debug_guard_grouping
                trace('[XRay RemoveNil] Processing EBlock with ${exprs.length} expressions');
                #end
                // Filter out nil assignments for generated variables
                var filtered = [];
                for (expr in exprs) {
                    var isGeneratedNilAssignment = switch(expr.def) {
                        case EMatch(PVar(varName), rhs) if (rhs != null):
                            #if debug_guard_grouping
                            trace('[XRay RemoveNil] Checking match for variable: $varName');
                            trace('[XRay RemoveNil] RHS type: ' + Type.enumConstructor(rhs.def));
                            #end
                            switch(rhs.def) {
                                case EAtom(a):
                                    var atomStr = (a:String);
                                    #if debug_guard_grouping
                                    trace('[XRay RemoveNil] Atom value: "$atomStr"');
                                    #end
                                    if (atomStr == "nil") {
                                        // Check if variable name ends with digit (r2, b3, etc.)
                                        var isGenerated = ~/^[a-z]+\d+$/.match(varName);
                                        #if debug_guard_grouping
                                        trace('[XRay RemoveNil] Is generated variable: $isGenerated for $varName');
                                        #end
                                        isGenerated;
                                    } else {
                                        false;
                                    }
                                default: false;
                            }
                        default: false;
                    };
                    
                    if (!isGeneratedNilAssignment) {
                        // Recursively clean the expression
                        filtered.push(removeNilAssignments(expr));
                    }
                }
                
                // Return simplified block or single expression
                if (filtered.length == 0) {
                    null;
                } else if (filtered.length == 1) {
                    filtered[0];
                } else {
                    makeASTWithMeta(EBlock(filtered), ast.metadata, ast.pos);
                }
                
            default:
                // Recursively transform children
                transformAST(ast, removeNilAssignments);
        };
    }
    
    /**
     * Fix undefined variable references in guard conditions
     * Maps suffixed variables (g2, r2, b2) back to their original names (g, r, b)
     */
    static function fixUndefinedVariables(ast: ElixirAST): ElixirAST {
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EVar(name):
                // More comprehensive pattern to fix various undefined variables
                // Patterns to fix:
                // - Single letter with number: g2 -> g, r3 -> r, b4 -> b
                // - Names with number suffix: l2 -> l, h2 -> h, s2 -> s
                // - Multi-letter names: r2 -> r, g2 -> g, b2 -> b
                
                // Check for common patterns from the test output
                var fixedName = name;
                
                // Pattern 1: Single letter followed by digit(s)
                if (~/^[a-z]\d+$/.match(name)) {
                    fixedName = name.charAt(0);
                }
                // Pattern 2: Common variable names with numeric suffixes
                else if (~/^(r|g|b|h|s|l)\d+$/.match(name)) {
                    fixedName = ~/^([a-z]+)\d+$/.replace(name, "$1");
                }
                // Pattern 3: More general - any word followed by digits
                else if (~/^(\w+?)\d+$/.match(name)) {
                    var base = ~/^(\w+?)\d+$/.replace(name, "$1");
                    // Only fix if it looks like a generated variable
                    if (base.length <= 2) {
                        fixedName = base;
                    }
                }
                
                if (fixedName != name) {
                    #if debug_guard_grouping
                    trace('[XRay GuardGrouping] Fixing variable: $name -> $fixedName');
                    #end
                    makeASTWithMeta(EVar(fixedName), ast.metadata, ast.pos);
                } else {
                    ast;
                }
                
            case EBinary(op, left, right):
                // Fix both sides of binary operations
                var fixedLeft = fixUndefinedVariables(left);
                var fixedRight = fixUndefinedVariables(right);
                makeASTWithMeta(EBinary(op, fixedLeft, fixedRight), ast.metadata, ast.pos);
                
            case ECall(expr, method, args):
                // Fix function calls and their arguments
                var fixedExpr = fixUndefinedVariables(expr);
                var fixedArgs = args.map(fixUndefinedVariables);
                makeASTWithMeta(ECall(fixedExpr, method, fixedArgs), ast.metadata, ast.pos);
                
            case EIf(cond, thenBranch, elseBranch):
                // Fix all parts of if expressions
                var fixedCond = fixUndefinedVariables(cond);
                var fixedThen = fixUndefinedVariables(thenBranch);
                var fixedElse = elseBranch != null ? fixUndefinedVariables(elseBranch) : null;
                makeASTWithMeta(EIf(fixedCond, fixedThen, fixedElse), ast.metadata, ast.pos);
                
            case EParen(inner):
                // Fix inside parentheses
                var fixedInner = fixUndefinedVariables(inner);
                makeASTWithMeta(EParen(fixedInner), ast.metadata, ast.pos);
                
            default:
                // For other node types, recursively fix children
                transformAST(ast, fixUndefinedVariables);
        };
    }
    
    /**
     * Extract cond branches from nested if-else chain
     */
    static function extractCondBranches(ast: ElixirAST): Array<{condition: ElixirAST, body: ElixirAST}> {
        var branches = [];
        
        function extract(node: ElixirAST, depth: Int = 0) {
            if (node == null) return;
            
            #if debug_guard_grouping
            trace("[XRay ExtractBranches] Depth " + depth + ", node type: " + (node.def != null ? Type.enumConstructor(node.def) : "null"));
            #end
            
            // Clean up nil assignments first
            var cleanedNode = removeNilAssignments(node);
            if (cleanedNode == null) return;
            
            // Recursively unwrap blocks and parentheses after cleaning
            var nodeToProcess = cleanedNode;
            var unwrapping = true;
            while (unwrapping && nodeToProcess != null) {
                switch(nodeToProcess.def) {
                    case EBlock(exprs) if (exprs.length == 1):
                        nodeToProcess = exprs[0];
                    case EParen(inner):
                        nodeToProcess = inner;
                    default:
                        unwrapping = false;
                }
            }
            
            switch(nodeToProcess.def) {
                case EIf(cond, thenBranch, elseBranch):
                    // Fix variables in both the condition and body
                    var fixedCond = fixUndefinedVariables(cond);
                    var fixedBody = fixUndefinedVariables(thenBranch);
                    
                    branches.push({
                        condition: fixedCond,
                        body: fixedBody  // Don't transform here, will be done later
                    });
                    
                    #if debug_guard_grouping
                    trace("[XRay ExtractBranches] Added branch at depth " + depth);
                    #end
                    
                    // Recursively process else branch
                    if (elseBranch != null) {
                        extract(elseBranch, depth + 1);
                    }
                    
                case _:
                    // This is the final else case (or a single expression)
                    var fixedNode = fixUndefinedVariables(nodeToProcess);
                    branches.push({
                        condition: makeAST(EBoolean(true)),
                        body: fixedNode
                    });
                    
                    #if debug_guard_grouping
                    trace("[XRay ExtractBranches] Added final branch at depth " + depth);
                    #end
            }
        }
        
        extract(ast);
        return branches;
    }
    

    /**
     * InlineTempBindingInExpr: Collapse simple temp-binding EBlock into a single expression
     * 
     * TERMINOLOGY:
     * - "Collapse" means to transform a two-statement block into a single expression by
     *   inlining a temporary variable. For example:
     *   BEFORE: (tmp = Date.now(); DateTime.to_unix(tmp, :millisecond))
     *   AFTER:  DateTime.to_unix(Date.now(), :millisecond)
     *   The temporary variable 'tmp' is eliminated by substituting its value directly.
     * 
     * WHY: Abstract method inlining sometimes produces blocks like:
     *   %{:online_at => (tmp = Date.now(); DateTime.to_unix(tmp, :millisecond))}
     * which is invalid in map field position. We collapse to a single expression:
     *   %{:online_at => DateTime.to_unix(Date.now(), :millisecond)}
     * 
     * WHAT: Detect EBlock([EMatch(PVar(tmp), exprA), exprB]) where exprB contains EVar(tmp)
     * and replace all occurrences of tmp in exprB with exprA, eliminating the temp variable.
     * 
     * HOW: Two-phase approach to avoid infinite recursion:
     * 1. Build a parent map to track expression vs statement contexts
     * 2. Single bottom-up transformation pass that collapses only in expression contexts
     * 
     * EDGE CASES:
     * - Only collapse in expression contexts (map values, function args, etc.)
     * - Skip collapsing in statement contexts (case clause bodies, function bodies)
     * - Only collapse if the temp variable is actually used
     * - Preserve precedence by wrapping substituted expressions in parentheses
     */
    
    /**
     * Throw statement transformation pass
     * 
     * WHY: Complex expressions in throw statements can generate invalid Elixir syntax
     *      when string concatenation includes conditionals or function calls
     * WHAT: Transforms throw expressions with complex string concatenation
     * HOW: Wraps complex expressions in parentheses to ensure valid syntax
     */
    static function throwStatementTransformPass(ast: ElixirAST): ElixirAST {
        if (ast == null || ast.def == null) return ast;
        return switch(ast.def) {
            case EThrow(value):
                // Transform the throw value to ensure it's a valid single expression
                var transformedValue = transformThrowValue(value);
                {
                    def: EThrow(transformedValue),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
            default:
                // Recursively transform children using the standard transformer
                transformAST(ast, throwStatementTransformPass);
        };
    }
    
    /**
     * Transform throw value to ensure it generates valid Elixir syntax
     */
    static function transformThrowValue(expr: ElixirAST): ElixirAST {
        return switch(expr.def) {
            case EBinary(StringConcat, left, right):
                // For string concatenation, ensure both sides are properly formatted
                var leftTransformed = transformThrowValue(left);
                var rightTransformed = transformThrowValue(right);
                
                // If right side is complex, wrap it in parentheses
                var rightWrapped = switch(rightTransformed.def) {
                    case EIf(_, _, _):
                        {
                            def: EParen(rightTransformed),
                            metadata: rightTransformed.metadata,
                            pos: rightTransformed.pos
                        };
                    case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
                        {
                            def: EParen(rightTransformed),
                            metadata: rightTransformed.metadata,
                            pos: rightTransformed.pos
                        };
                    default:
                        rightTransformed;
                };
                
                {
                    def: EBinary(StringConcat, leftTransformed, rightWrapped),
                    metadata: expr.metadata,
                    pos: expr.pos
                };
                
            case EIf(cond, then, els):
                // Wrap if expressions in parentheses when used in throw
                {
                    def: EParen(expr),
                    metadata: expr.metadata,
                    pos: expr.pos
                };
                
            default:
                expr;
        };
    }
    
    /**
     * Check if a call expression contains conditionals that might cause syntax issues
     */
    static function hasConditionalInCall(expr: ElixirAST): Bool {
        return switch(expr.def) {
            case ECall(_, _, args):
                Lambda.exists(args, function(arg) {
                    return switch(arg.def) {
                        case EIf(_, _, _): true;
                        default: false;
                    };
                });
            default: false;
        };
    }
    
    /**
     * Identity pass - returns AST unchanged
     * Base pass that ensures transformer works even with no transformations
     */
    static function identityPass(ast: ElixirAST): ElixirAST {
        return ast;
    }
    
    /**
     * Resolve Clause Locals Pass
     * 
     * WHY: Variables in case clause bodies need to match the names used in patterns.
     * When Haxe generates temporary variables (_g, g, etc.) for enum parameters,
     * but our patterns use the actual parameter names (value, reason, etc.),
     * we need to resolve these references.
     * 
     * WHAT: Looks for nodes with varIdToName metadata and rewrites EVar nodes
     * within them to use the mapped names based on their sourceVarId.
     * 
     * HOW: When we encounter a node with varIdToName metadata, we walk its
     * subtree and rewrite any EVar that has a sourceVarId matching an entry
     * in the varIdToName map.
     * 
     * EDGE CASES:
     * - Nested case expressions: Each case should have its own varIdToName scope
     * - String interpolation: Variables inside __elixir__() injections need resolution
     * - Anonymous functions: May reference outer scope variables
     */

    /**
     * Remove Redundant Enum Extraction Pass
     *
     * WHY: Elixir pattern matching already extracts values, but Haxe generates redundant elem() calls
     * WHAT: Removes assignments like `g = elem(result, 1)` after pattern `{:ok, g}`
     * HOW: Detects and removes redundant extraction statements in case bodies
     *
     * EXAMPLE:
     * Before:
     *   {:ok, g} ->
     *     g = elem(result, 1)  # Redundant!
     *     value = g
     *     value
     *
     * After:
     *   {:ok, g} ->
     *     value = g
     *     value
     */
    static function removeRedundantEnumExtractionPass(ast: ElixirAST): ElixirAST {
        #if debug_redundant_extraction
        trace('[RemoveRedundantEnumExtraction] Debug mode enabled');
        #end

        // Track the case target variable name for nested detection
        var caseTargetVar: String = null;
        // Track whether the current case has an enum binding plan
        var currentCaseHasBindingPlan: Bool = false;

        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ECase(target, clauses):
                    // Enhanced debug for ChangesetUtils issue
                    var targetDebug = switch(target.def) {
                        case EVar(v): 'variable: $v';
                        case EParen(inner): switch(inner.def) {
                            case EVar(v): 'variable in parens: $v';
                            default: 'complex expression';
                        };
                        default: 'complex expression';
                    };
                    #if debug_redundant_extraction
                    trace('[RemoveRedundantEnumExtraction] Processing ECase with ${clauses.length} clauses, target: $targetDebug');
                    #end
                    // Check if this case has an enum binding plan
                    currentCaseHasBindingPlan = node.metadata != null && node.metadata.hasEnumBindingPlan == true;
                    #if debug_enum_extraction
                    if (currentCaseHasBindingPlan) {
                        trace('[RemoveRedundantEnumExtraction] Found ECase with hasEnumBindingPlan flag');
                    }
                    #end

                    // Extract the case target variable name
                    switch(target.def) {
                        case EVar(v): caseTargetVar = v;
                        case EParen(inner):
                            switch(inner.def) {
                                case EVar(v): caseTargetVar = v;
                                default:
                            }
                        default:
                    }

                    // trace('[RemoveRedundantEnumExtraction] Processing case with target: $caseTargetVar');
                    // Process each case clause
                    var newClauses = [];
                    for (i in 0...clauses.length) {
                        var clause = clauses[i];
                        // ECaseClause is a typedef with pattern, guard, and body fields
                        var pattern = clause.pattern;
                        var guard = clause.guard;
                        var body = clause.body;

                        // Debug pattern to understand ChangesetUtils issue
                        #if debug_redundant_extraction
                        var patternDebug = switch(pattern) {
                            case PTuple(elements):
                                var elemStrs = [for (e in elements) switch(e) {
                                    case PLiteral(ast):
                                        switch(ast.def) {
                                            case EAtom(a): ':$a';
                                            default: '?';
                                        }
                                    case PVar(v): v;
                                    default: '?';
                                }];
                                '{${elemStrs.join(", ")}}';
                            default: 'other pattern';
                        };
                        trace('[RemoveRedundantEnumExtraction] Clause $i pattern: $patternDebug');
                        #end

                        // Propagate the binding plan flag to the clause body
                        if (currentCaseHasBindingPlan && body != null) {
                            if (body.metadata == null) body.metadata = {};
                            body.metadata.parentHasBindingPlan = true;
                        }

                        // Check if body contains redundant extraction (guard for null bodies)
                        var newBody = if (body == null) null else switch(body.def) {
                            case EBlock(exprs):
                                // M0 FIX: Track variable renames when removing redundant assignments
                                var varRenames: Map<String, String> = new Map();

                                // First pass: Filter out redundant elem() assignments and track renames
                                var filtered = [];
                                for (i in 0...exprs.length) {
                                    var expr = exprs[i];

                                    // Skip null expressions (these are filtered assignments from TEnumParameter)
                                    if (expr == null) {
                                        continue;
                                    }

                                    var isRedundant = false;

                                    // Check if marked as redundant via metadata
                                    if (expr.metadata != null && expr.metadata.redundantEnumExtraction == true) {
                                        isRedundant = true;
                                        #if debug_redundant_extraction
                                        trace('[RemoveRedundantEnumExtraction] Found node marked as redundant via metadata');
                                        #end
                                    }

                                    // Check if this is a redundant extraction
                                    switch(expr.def) {
                                        case EMatch(PVar(varName), rhs):
                                            // Enhanced debug for ChangesetUtils issues
                                            if (rhs != null) {
                                                var rhsDebug = switch(rhs.def) {
                                                    case EVar(v): 'EVar($v)';
                                                    case ECall(_, fn, _): 'ECall($fn)';
                                                    default: Type.enumConstructor(rhs.def);
                                                };
                                                #if debug_redundant_extraction
                                                trace('[RemoveRedundantEnumExtraction] Found assignment: $varName = ... (RHS: $rhsDebug, caseTarget: $caseTargetVar)');
                                                #end
                                            } else {
                                                #if debug_redundant_extraction
                                                trace('[RemoveRedundantEnumExtraction] Found assignment: $varName = null (skipped assignment)');
                                                #end
                                                // Mark this as redundant since it has no RHS
                                                isRedundant = true;
                                            }

                                            // Check for self-assignment first (e.g., content = content)
                                        if (varName == switch(rhs.def) {
                                            case EVar(v): v;
                                            default: null;
                                        }) {
                                            isRedundant = true;
                                            #if debug_redundant_extraction
                                            trace('[RemoveRedundantEnumExtraction] Removing self-assignment: $varName = $varName');
                                            #end
                                        }
                                        // Check if the target variable itself is a temp pattern var
                                        else if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
                                            isRedundant = true;
                                            #if debug_redundant_extraction
                                            trace('[RemoveRedundantEnumExtraction] Removing temp-var assignment: $varName = ...');
                                            #end
                                        }
                                        // Check if RHS is a reference to a temp variable (g, g1, g2, _g, etc.)
                                        else switch(rhs.def) {
                                            case EVar(v):
                                                // Check if this is an assignment from a temp variable
                                                    // Handle both "g" and "_g" patterns
                                                    // CRITICAL FIX: For idiomatic enums, the pattern uses the actual variable names
                                                    // (like {:ok, value}) instead of temp vars (like {:ok, g}).
                                                    // This means assignments like "value = g" are trying to assign from a
                                                    // non-existent variable 'g'. These MUST be removed unconditionally.
                                                    //
                                                    // Enhanced: For idiomatic enums with canonical pattern names,
                                                    // ANY assignment where RHS is "g" or a temp var should be removed
                                                    // because patterns already extract the values

                                                    // First, check if RHS is "g" (regardless of what LHS is)
                                                    // This catches "value = g" in idiomatic enums
                                                    if (v == "g" || v == "_g") {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent temp var)');
                                                        #end
                                                    }
                                                    // Check for numbered temp vars in RHS: g1, g2, etc.
                                                    else if (v.length > 1 && v.charAt(0) == "g" &&
                                                             v.length == 2 && v.charAt(1) >= '0' && v.charAt(1) <= '9') {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent numbered temp var)');
                                                        #end
                                                    }
                                                    // Check for underscore-prefixed numbered temp vars: _g1, _g2, etc.
                                                    else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" &&
                                                             v.charAt(2) >= '0' && v.charAt(2) <= '9') {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent underscore temp var)');
                                                        #end
                                                    }
                                                    // Also check for "g = result" pattern where result is case target
                                                    // This is ALWAYS wrong and should be removed - the pattern already extracted g
                                                    else if (v == caseTargetVar) {
                                                        // Remove assignments like "g = result" where g is a temp var
                                                        // The pattern {:error, g} already binds g to the error value
                                                        // So "g = result" would incorrectly assign the whole tuple
                                                        if (varName == "g" || varName == "_g" ||
                                                            (varName.length == 2 && varName.charAt(0) == "g" &&
                                                             varName.charAt(1) >= '0' && varName.charAt(1) <= '9') ||
                                                            (varName.length == 3 && varName.charAt(0) == "_" &&
                                                             varName.charAt(1) == "g" && varName.charAt(2) >= '0' &&
                                                             varName.charAt(2) <= '9')) {
                                                            isRedundant = true;
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction] Removing incorrect assignment: $varName = $v (pattern already extracted value)');
                                                            #end
                                                        }
                                                    }

                                                case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
                                                    #if debug_redundant_extraction
                                                    trace('[RemoveRedundantEnumExtraction]   - Found elem() call');
                                                    #end
                                                    // Check if elem is extracting from the case target
                                                    var isTargetMatch = switch(targetExpr.def) {
                                                        case EVar(v):
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction]   - elem() target: $v, case target: $caseTargetVar');
                                                            #end
                                                            // Check if this matches the case target variable
                                                            v == caseTargetVar;
                                                        default:
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction]   - elem() target is not a simple variable');
                                                            #end
                                                            false;
                                                    };

                                                    if (isTargetMatch) {
                                                        // Check if this variable was already extracted by the pattern
                                                        // Pattern variables like 'g', 'g1', 'g2' are extracted
                                                        if (varName == "g" ||
                                                            (varName.length > 1 && varName.charAt(0) == "g" &&
                                                             varName.charAt(1) >= '0' && varName.charAt(1) <= '9')) {
                                                            isRedundant = true;
                                                            #if debug_redundant_extraction
                                                            #end
                                                        } else {
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction] Not redundant - varName: $varName does not match g pattern');
                                                            #end
                                                        }
                                                    } else {
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] elem() not extracting from case target');
                                                        #end
                                                    }
                                                default:
                                            }
                                        default:
                                    }

                                    if (!isRedundant) {
                                        filtered.push(expr);
                                    }
                                }

                                // Return filtered block or single expression if only one left
                                // CRITICAL FIX: Must actually evaluate to a value, not just execute expressions
                                // ALSO: Ensure immutability by creating new AST nodes
                                if (filtered.length == 0) {
                                    makeAST(ENil);
                                } else if (filtered.length == 1) {
                                    // Recursively transform the single expression to ensure complete immutability
                                    transformNode(filtered[0], function(n) { return n; });
                                } else {
                                    // Recursively transform each filtered expression to ensure immutability
                                    var transformedFiltered = filtered.map(function(expr) {
                                        return transformNode(expr, function(n) { return n; });
                                    });
                                    // Preserve metadata when creating new block
                                    makeASTWithMeta(EBlock(transformedFiltered), body.metadata, body.pos);
                                };

                            default:
                                body; // Not a block, keep as-is
                        };

                        // Create new clause with updated body
                        // IMPORTANT: Recursively transform the new body to ensure all nested structures are processed
                        var fullyTransformedBody = transformNode(newBody, function(n) { return n; });
                        newClauses.push({
                            pattern: pattern,
                            guard: guard,
                            body: fullyTransformedBody
                        });
                    }

                    // Create new ECase node preserving original metadata and position
                    return makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);

                default:
                    return node;
            }
        });
    }

    /**
     * Function Reference Transform Pass
     *
     * WHY: When passing functions as references in Elixir, they need the capture operator
     * WHAT: Transforms Module.function__FUNC_REF__N to &Module.function/N
     * HOW: Looks for EField nodes with __FUNC_REF__ marker and converts to capture syntax
     */
    static function functionReferenceTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EField(target, field):
                    // Check if this has the function reference marker
                    if (field.indexOf("__FUNC_REF__") != -1) {
                        #if debug_function_reference
                        trace('[FunctionRef] Found marked field: $field');
                        #end
                        
                        // Extract the actual field name and arity
                        var parts = field.split("__FUNC_REF__");
                        var actualField = parts[0];
                        var arity = parts.length > 1 ? Std.parseInt(parts[1]) : 0;
                        if (arity == null) arity = 0;
                        
                        #if debug_function_reference
                        trace('[FunctionRef] Transforming to capture: &Module.$actualField/$arity');
                        #end
                        
                        // Create the clean field access without the marker
                        var cleanField = makeAST(EField(target, actualField));
                        
                        // Transform to capture syntax: &Module.function/arity
                        return makeAST(ECapture(cleanField, arity));
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Null Coalescing Inline Pass
     * 
     * Transforms null coalescing blocks into inline if expressions.
     * Detects pattern: var x = {tmp = expr; if (tmp != nil) tmp else default}
     * Transforms to: var x = if (tmp = expr) != nil, do: tmp, else: default
     */
    static function nullCoalescingInlinePass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_null_coalescing
            switch(node.def) {
                case EMatch(PVar(name), value):
                    trace('[NullCoalescing] Found EMatch with name: $name');
                    if (value != null) {
                        switch(value.def) {
                            case EBlock(exprs):
                                trace('[NullCoalescing] Found block with ${exprs.length} expressions');
                            default:
                                trace('[NullCoalescing] Value is not a block: ${value.def}');
                        }
                    }
                default:
            }
            #end
            
            return switch(node.def) {
                case EMatch(PVar(name), value) if (value != null):
                    // Check if value is a block with null coalescing pattern
                    switch(value.def) {
                        case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
                            // Check if this matches the null coalescing pattern
                            switch(assign.def) {
                                case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
                                    // Check if the if expression uses the same tmp variable
                                    switch(ifExpr.def) {
                                        case EIf(condition, thenBranch, elseBranch):
                                            // Check if condition is comparing tmp to nil
                                            switch(condition.def) {
                                                case EBinary(NotEqual, tmpVar, nilExpr):
                                                    switch(tmpVar.def) {
                                                        case EVar(checkName) if (checkName == tmpName):
                                                            // This is the null coalescing pattern!
                                                            // Transform to inline if with assignment in condition
                                                            // Create: name = if (tmp = expr) != nil, do: tmp, else: default
                                                            var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
                                                            var inlineCondition = makeAST(EBinary(
                                                                NotEqual,
                                                                makeAST(EParen(assignExpr)),
                                                                makeAST(ENil)
                                                            ));
                                                            makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));
                                                        default:
                                                            node; // Not using the same tmp variable
                                                    }
                                                default:
                                                    node; // Not a nil comparison
                                            }
                                        default:
                                            node; // Not an if expression
                                    }
                                default:
                                    node; // Not a temp variable assignment
                            }
                        default:
                            node; // Not a null coalescing block
                    }
                default:
                    node; // Not a variable declaration or no transformation needed
            };
        });
    }
    
    /**
     * Self reference transformation pass - converts self/this references to struct parameter
     * In Elixir, instance methods receive the struct as their first parameter
     * 
     * For inheritance: Haxe's super.method() becomes delegation to parent module
     * Example: super.toString() -> ParentModule.to_string(struct)
     */
    static function selfReferenceTransformPass(ast: ElixirAST): ElixirAST {
        // First pass: collect module metadata for context
        var moduleMetadata: ElixirMetadata = null;
        
        function collectModuleMetadata(node: ElixirAST): Void {
            if (node == null || node.def == null) return;
            
            switch(node.def) {
                case EModule(_, _, _):
                    if (node.metadata != null) {
                        moduleMetadata = node.metadata;
                        #if debug_super_handling
                        trace("[SuperTransform] Collected module metadata: parentModule=" + 
                              (moduleMetadata.parentModule != null ? moduleMetadata.parentModule : "null"));
                        #end
                    }
                default:
                    // Continue traversing
                    iterateAST(node, collectModuleMetadata);
            }
        }
        
        collectModuleMetadata(ast);
        
        // Second pass: transform with context
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Transform method calls on super
                // Note: In ElixirASTBuilder, super.toString() becomes:
                // ECall(target=null, methodName="call", args=[EField(EVar("super"), "to_string"), ...])
                // But we need to check for the direct case too:
                // ECall(target=EField(EVar("super"), "to_string"), methodName="call", args)
                case ECall(target, methodName, args):
                    #if debug_super_handling
                    trace("[SuperTransform] Processing ECall:");
                    trace("  target = " + target);
                    trace("  methodName = " + methodName);
                    trace("  args = " + args);
                    #end
                    // Handle synthetic super calls marker, if any
                    if (methodName == "__super__") {
                        return makeAST(ENil);
                    }
                    
                    // First check if this is a call where the first arg is super.field access
                    if (methodName == "call" && args.length > 0) {
                        switch(args[0].def) {
                            case EField(superVar, fieldName):
                                if (superVar.def.match(EVar("super"))) {
                                    #if debug_super_handling
                                    trace("[SuperTransform] Found super." + fieldName + " as first argument");
                                    #end
                                    if (fieldName == "to_string" || fieldName == "toString") {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Transforming super.toString() call to empty string");
                                        #end
                                        return makeAST(EString(""));
                                    }
                                }
                            default:
                        }
                    }
                    
                    // Also check if target itself is super.field or just super
                    if (target != null) {
                        switch(target.def) {
                            case EVar("super"):
                                // Direct super.method() call where super is the target
                                #if debug_super_handling
                                trace("[SuperTransform] Direct super as target detected!");
                                trace("  methodName = " + methodName);
                                trace("  node.metadata = " + node.metadata);
                                #end
                                
                                // Look for parent module in metadata
                                var parentModule = if (node.metadata != null && node.metadata.parentModule != null) {
                                    node.metadata.parentModule;
                                } else if (moduleMetadata != null && moduleMetadata.parentModule != null) {
                                    // Use collected module metadata
                                    moduleMetadata.parentModule;
                                } else {
                                    // No parent module available
                                    null;
                                };
                                
                                if (parentModule != null) {
                                    // Special handling for Exception parent (it's a behaviour, not a module with methods)
                                    if (parentModule == "Exception" && (methodName == "toString" || methodName == "to_string")) {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Special handling for Exception.toString()");
                                        #end
                                        // For Exception base class, use Kernel.to_string on the message
                                        return makeAST(ERemoteCall(
                                            makeAST(EVar("Kernel")),
                                            "to_string",
                                            [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                        ));
                                    }
                                    
                                    // Transform super.method() to ParentModule.method(struct, args...)
                                    #if debug_super_handling
                                    trace("[SuperTransform] Delegating to parent module: " + parentModule);
                                    trace("[SuperTransform] Parent module type: " + Type.typeof(parentModule));
                                    #end
                                    
                                    // Convert method name to snake_case for Elixir
                                    var elixirMethodName = if (methodName == "toString") {
                                        "to_string";
                                    } else {
                                        NameUtils.toSnakeCase(methodName);
                                    };
                                    
                                    // Build delegation call: ParentModule.method(struct, original_args...)
                                    var delegationArgs = [makeAST(EVar("struct"))].concat(args);
                                    return makeAST(ERemoteCall(
                                        makeAST(EVar(parentModule)),  // Use EVar for module alias, not EAtom
                                        elixirMethodName,
                                        delegationArgs
                                    ));
                                } else if (methodName == "to_string" || methodName == "toString") {
                                    // Fallback for toString when parent is unknown
                                    #if debug_super_handling
                                    trace("[SuperTransform] No parent module found, handling toString for exception");
                                    #end
                                    
                                    // Check if this is an exception class
                                    var isException = (moduleMetadata != null && moduleMetadata.isException == true);
                                    
                                    if (isException) {
                                        // For exception classes, use Kernel.to_string on the message field
                                        // This properly converts the message to a string using Elixir's built-in function
                                        return makeAST(ERemoteCall(
                                            makeAST(EVar("Kernel")),
                                            "to_string",
                                            [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                        ));
                                    } else {
                                        // For non-exception classes, just return the message field
                                        return makeAST(EField(makeAST(EVar("struct")), "message"));
                                    }
                                } else {
                                    // Keep as is if we can't resolve parent
                                    #if debug_super_handling
                                    trace("[SuperTransform] No parent module found, keeping super call as is");
                                    #end
                                    node;
                                }
                                
                            case EField(superVar, fieldName):
                                #if debug_super_handling
                                trace("[SuperTransform] EField target detected:");
                                trace("  superVar.def = " + superVar.def);
                                trace("  fieldName = " + fieldName);
                                #end
                                
                                if (superVar.def.match(EVar("super"))) {
                                    #if debug_super_handling
                                    trace("[SuperTransform] Super method call detected!");
                                    #end
                                    
                                    // This is super.method() call
                                    if (fieldName == "to_string" || fieldName == "toString") {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Transforming super.toString() for exception class");
                                        #end
                                        
                                        // Check if this is an exception class
                                        var isException = (moduleMetadata != null && moduleMetadata.isException == true);
                                        
                                        if (isException) {
                                            // For exception classes, use Kernel.to_string on the message field
                                            return makeAST(ERemoteCall(
                                                makeAST(EVar("Kernel")),
                                                "to_string",
                                                [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                            ));
                                        } else {
                                            // Default to empty string for non-exception classes
                                            return makeAST(EString(""));
                                        }
                                    } else {
                                        // For other methods, keep as is for now
                                        node;
                                    }
                                } else {
                                    node;
                                }
                            default:
                                #if debug_super_handling
                                trace("[SuperTransform] Target is not super or field access, keeping node");
                                #end
                                node;
                        }
                    } else {
                        node;
                    }
                    
                // Transform self.field and super.field  
                case EField(target, fieldName):
                    switch(target.def) {
                        case EVar("self"):
                            // Replace 'self' with 'struct' (the conventional first parameter)
                            makeAST(EField(makeAST(EVar("struct")), fieldName));
                        case EVar("super"):
                            // Don't transform super field access here anymore - handle in ECall
                            node;
                        default:
                            node;
                    }
                    
                // Transform standalone 'self' references
                case EVar("self"):
                    makeAST(EVar("struct"));
                    
                // Transform standalone 'super' references
                // NOTE: Don't transform super to nil - this causes issues with super.method() calls
                // Super method delegation should be handled at the TCall level when super is the target
                // case EVar("super"):
                //     makeAST(ENil);
                    
                // fallthrough
                default:
                    node;
            }
        });
    }
    
    /**
     * Phoenix Component Import Pass: Add Phoenix.Component import when ~H sigil is used
     * 
     * WHY: The ~H sigil for HEEx templates requires Phoenix.Component to be imported
     * WHAT: Detects any ESigil with type "H" and adds the necessary import
     * HOW: Traverses AST looking for ~H sigils, then adds import if found
     * 
     * IMPORTANT: Skip if module already has LiveView use statement (includes Phoenix.Component)
     */
    static function phoenixComponentImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if ~H sigil is used
        var needsPhoenixComponent = false;
        
        #if debug_phoenix_component_import
        trace('[XRay PhoenixComponentImport] Starting scan for ~H sigils');
        #end
        
        // Recursive function to deeply traverse the AST
        function checkForHSigil(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            switch(node.def) {
                case ESigil(type, _, _):
                    #if debug_phoenix_component_import
                    trace('[XRay PhoenixComponentImport] Found sigil type: $type');
                    #end
                    if (type == "H") {
                        needsPhoenixComponent = true;
                    }
                case ERaw(code):
                    // Also catch ~H usage present inside raw code blocks (e.g., untyped __elixir__ "~H\"\"\"...\"\"\"")
                    if (code != null && (code.indexOf("~H\"\"\"") != -1 || code.indexOf("~H\"") != -1)) {
                        needsPhoenixComponent = true;
                    } else {
                        // Continue traversal for any nested nodes in raw if needed
                        iterateAST(node, checkForHSigil);
                    }
                default:
                    // For all other node types, recursively visit children
                    iterateAST(node, checkForHSigil);
            }
        }
        
        checkForHSigil(ast);
        
        #if debug_phoenix_component_import
        trace('[XRay PhoenixComponentImport] Needs Phoenix.Component: $needsPhoenixComponent');
        #end
        
        // Phase 2: Add import if needed
        if (!needsPhoenixComponent) return ast;
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EModule(name, attributes, body):
                    // Handle module nodes constructed via EModule (ModuleBuilder default)
                    // Inject `use Phoenix.Component` at the top of the body when ~H is present
                    var hasImport = false;
                    // Scan existing body for EUse/EImport Phoenix.Component
                    for (stmt in body) switch (stmt.def) {
                        case EUse(mod, _): if (mod == "Phoenix.Component") { hasImport = true; }
                        case EImport(mod, _, _): if (mod == "Phoenix.Component") { hasImport = true; }
                        default:
                    }
                    if (!hasImport) {
                        var importStmt = makeAST(EUse("Phoenix.Component", []));
                        var newBody = [importStmt].concat(body);
                        return makeASTWithMeta(EModule(name, attributes, newBody), node.metadata, node.pos);
                    }
                    return node;
                case EDefmodule(name, doBlock):
                    #if debug_phoenix_component_import
                    trace('[XRay PhoenixComponentImport] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            #if debug_phoenix_component_import
                            trace('[XRay PhoenixComponentImport] Defmodule has ${statements.length} statements');
                            #end
                            
                            // Check if Phoenix.Component is already imported or if LiveView is used
                            var hasImport = false;
                            var hasLiveViewUse = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):
                                        // module is a string in EImport
                                        if (module == "Phoenix.Component") {
                                            hasImport = true;
                                            break;
                                        }
                                    case EUse(module, opts):
                                        // module is a string in EUse
                                        #if debug_phoenix_component_import
                                        trace('[XRay PhoenixComponentImport] Found EUse: module=$module, opts=$opts');
                                        #end
                                        if (module == "Phoenix.Component") {
                                            hasImport = true;
                                            break;
                                        }
                                        // Check if it's a LiveView use statement (e.g., use TodoAppWeb, :live_view)
                                        if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
                                            // Check if it has :live_view option
                                            for (opt in opts) {
                                                #if debug_phoenix_component_import
                                                trace('[XRay PhoenixComponentImport] Checking option: $opt');
                                                #end
                                                switch(opt.def) {
                                                    // Pattern matching with abstract types requires guard clause
                                                case EAtom(atom) if (atom == "live_view"):
                                                        #if debug_phoenix_component_import
                                                        trace('[XRay PhoenixComponentImport] Found :live_view option - will skip Phoenix.Component');
                                                        #end
                                                        hasLiveViewUse = true;
                                                        hasImport = true; // LiveView includes Phoenix.Component
                                                        break;
                                                    default:
                                                }
                                            }
                                        }
                                    default:
                                }
                            }
                            
                            /**
                             * LayoutContextHtmlUse Injection
                             *
                             * WHAT
                             * - For modules named `<App>Web.Layouts`, inject `use <App>Web, :html` instead of a raw
                             *   `use Phoenix.Component` so that the full Phoenix 1.7 HTML context is available.
                             *
                             * WHY
                             * - Layout modules commonly return ~H templates and rely on helpers (HTML, VerifiedRoutes,
                             *   controller conveniences). `:html` brings those into scope without app coupling.
                             *
                             * HOW
                             * - Detect EDefmodule with name ending in ".Layouts"; derive `<App>Web` from the prefix before
                             *   "Web" and prepend `use <App>Web, :html` when missing.
                             *
                             * EXAMPLES
                             *   Before:
                             *     defmodule TodoAppWeb.Layouts do
                             *       # (no imports)
                             *       def root(assigns), do: ~H"<head>...</head>"
                             *     end
                             *
                             *   After:
                             *     defmodule TodoAppWeb.Layouts do
                             *       use TodoAppWeb, :html
                             *       def root(assigns), do: ~H"<head>...</head>"
                             *     end
                             */
                            // If this is a Layouts module, ensure `use <App>Web, :html`
                            // so ~H helpers (Phoenix.Component, VerifiedRoutes, controller helpers) are in scope.
                            var isLayoutsModule = (name != null && StringTools.endsWith(name, ".Layouts"));

                            // Don't add Phoenix.Component or additional uses if LiveView is already used
                            if (hasLiveViewUse) {
                                #if debug_phoenix_component_import
                                trace('[XRay PhoenixComponentImport] Module already has LiveView use statement, skipping Phoenix.Component');
                                #end
                                return node;
                            }
                            
                            // For Layouts modules, prefer `use <App>Web, :html`
                            if (isLayoutsModule) {
                                // Derive <App> from "<App>Web.Layouts"
                                var appIdx = name.indexOf("Web");
                                var appPrefix = appIdx > 0 ? name.substr(0, appIdx) : null;
                                if (appPrefix != null) {
                                    var webModule = appPrefix + "Web";
                                    // Check if `use <App>Web, :html` already exists
                                    var hasHtmlUse = false;
                                    for (stmt in statements) switch (stmt.def) {
                                        case EUse(mod, opts):
                                            if (mod == webModule && opts != null) {
                                                for (o in opts) switch (o.def) { case EAtom(a) if (a == "html"): hasHtmlUse = true; default: }
                                            }
                                        default:
                                    }
                                    if (!hasHtmlUse) {
                                        #if debug_phoenix_component_import
                                        trace('[XRay PhoenixComponentImport] Adding use ' + webModule + ', :html for Layouts module');
                                        #end
                                        var htmlUse = makeAST(EUse(webModule, [ makeAST(EAtom("html")) ]));
                                        var newStatements = [htmlUse].concat(statements);
                                        var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                        return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                                    }
                                }
                            } else if (!hasImport) {
                                #if debug_phoenix_component_import
                                trace('[XRay PhoenixComponentImport] Adding Phoenix.Component import');
                                #end
                                // Create the import statement using EUse which takes a string
                                var importStmt = makeAST(EUse("Phoenix.Component", []));
                                // Add import at the beginning of the module body
                                var newStatements = [importStmt].concat(statements);
                                var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                            }
                            
                            return node; // Return unchanged if already has import
                            
                        default:
                            // Single expression body, wrap in block with import
                            var importStmt = makeAST(EUse("Phoenix.Component", []));
                            var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
                            return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                    }
                    
                default:
                    return node;
            }
        });
    }

    /**
     * Ecto Query Require Pass
     *
     * WHAT
     * - Scans modules for calls to Ecto.Query.* (macros like from/where/order_by/preload)
     * - Injects `require Ecto.Query` at module top if missing
     *
     * WHY
     * - In Elixir, macros must be required in the caller module
     * - Our builder emits ERemoteCall(EVar("Ecto.Query"), ...), which needs `require Ecto.Query`
     *
     * HOW
     * - Traverse defmodule body; if any ERemoteCall with module EVar("Ecto.Query") found, set needsRequire
     * - Check existing statements for Kernel.require("Ecto.Query"); if missing, prepend it
     */
    static function ectoQueryRequirePass(node: ElixirAST): ElixirAST {
        // Support both EDefmodule (do/end body) and EModule (attribute + body array) shapes
        function scanForEctoCalls(x: ElixirAST, found: {needs:Bool, has:Bool}): Void {
            if (x == null || x.def == null) return;
            switch (x.def) {
                case ERemoteCall(mod, func, args):
                    switch (mod.def) {
                        case EVar(m) if (m == "Kernel" && func == "require" && args != null && args.length == 1):
                            switch (args[0].def) { case EVar(v) if (v == "Ecto.Query"): found.has = true; default: }
                        case EVar(m) if (m == "Ecto.Query"): found.needs = true;
                        default:
                    }
                    if (args != null) for (a in args) scanForEctoCalls(a, found);
                case ERaw(code):
                    // Detect remote macro usage in raw injections only when explicitly remote
                    if (code != null && code.indexOf("Ecto.Query.") != -1) found.needs = true;
                // Remote-only gating: do NOT infer from pin operator alone
                case ECall(target, _, args):
                    if (target != null) scanForEctoCalls(target, found);
                    if (args != null) for (a in args) scanForEctoCalls(a, found);
                case EBlock(es): for (e in es) scanForEctoCalls(e, found);
                case EIf(c,t,e): scanForEctoCalls(c, found); scanForEctoCalls(t, found); if (e != null) scanForEctoCalls(e, found);
                case ECase(e, cs): scanForEctoCalls(e, found); for (c in cs) { if (c.guard != null) scanForEctoCalls(c.guard, found); scanForEctoCalls(c.body, found); }
                case EBinary(_, l, r): scanForEctoCalls(l, found); scanForEctoCalls(r, found);
                case EFn(cs): for (cl in cs) scanForEctoCalls(cl.body, found);
                case EDef(_, _, _, body): scanForEctoCalls(body, found);
                case EDefp(_, _, _, body): scanForEctoCalls(body, found);
                default:
            }
        }
        
        return transformNode(node, function(n: ElixirAST): ElixirAST {
            switch (n.def) {
                case EDefmodule(name, doBlock):
                    switch (doBlock.def) {
                        case EBlock(statements) | EDo(statements):
                            var found = {needs:false, has:false};
                            for (s in statements) scanForEctoCalls(s, found);
                            if (found.needs && !found.has) {
                                #if debug_ecto_query_require
                                trace('[EctoQueryRequire] Injecting require into defmodule ' + name);
                                #end
                                var requireStmt = makeAST(ERequire("Ecto.Query", null));
                                var newStatements = [requireStmt].concat(statements);
                                var newDo: ElixirAST = switch (doBlock.def) {
                                    case EBlock(_): makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                    case EDo(_): makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);
                                    default: doBlock;
                                };
                                return makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
                            }
                            #if debug_ecto_query_require
                            if (found.needs && found.has) trace('[EctoQueryRequire] Already has require in defmodule ' + name);
                            if (!found.needs) trace('[EctoQueryRequire] No Ecto.Query usage detected in defmodule ' + name);
                            #end
                            return n;
                        default:
                            return n;
                    }
                case EModule(name, attrs, body):
                    var found2 = {needs:false, has:false};
                    for (b in body) scanForEctoCalls(b, found2);
                    if (found2.needs && !found2.has) {
                        #if debug_ecto_query_require
                        trace('[EctoQueryRequire] Injecting require into module ' + name);
                        #end
                        var requireStmt2 = makeAST(ERequire("Ecto.Query", null));
                        var newBody = [requireStmt2].concat(body);
                        return makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);
                    }
                    #if debug_ecto_query_require
                    if (found2.needs && found2.has) trace('[EctoQueryRequire] Already has require in module ' + name);
                    if (!found2.needs) trace('[EctoQueryRequire] No Ecto.Query usage detected in module ' + name);
                    #end
                    return n;
                default:
                    return n;
            }
        });
    }

    /**
     * HeexContentInlinePass
     *
     * WHAT
     * - Replaces ~H"""<%= Phoenix.HTML.raw(content) %>""" in render(assigns) with ~H"""<html...>"""
     *   when `content` was assigned from a string literal earlier in the function.
     * - Removes the `content = "..."` intermediate assignment.
     *
     * WHY
     * - LiveView warns when templates access local variables; templates should use assigns
     *   or be self-contained. Inlining avoids variable access and keeps idiomatic ~H usage.
     *
     * HOW
     * - For EDef("render", [assigns], _, EBlock(stmts)) find:
     *   a) EMatch(PVar("content"), EString(html))
     *   b) ESigil("H", s) where s contains "Phoenix.HTML.raw(content)"
     *   Replace (b) with ESigil("H", html) and drop (a).
     */
    static function heexContentInlinePass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch (node.def) {
                case EDef(name, args, guards, body) if (name == "render"):
                    // Only handle block bodies
                    switch (body.def) {
                        case EBlock(stmts):
                            var contentHtml: Null<String> = null;
                            var contentAssignIdx: Int = -1;
                            // Find content = "..." (allow optional parentheses)
                            for (i in 0...stmts.length) {
                                switch (stmts[i].def) {
                                    case EMatch(PVar(varName), rhs) if (varName == "content"):
                                        switch (rhs.def) {
                                            case EString(s): contentHtml = s;
                                            case EParen(inner):
                                                switch (inner.def) {
                                                    case EString(s2): contentHtml = s2;
                                                    default:
                                                }
                                            default:
                                        }
                                        contentAssignIdx = i;
                                        break;
                                    default:
                                }
                            }
                            if (contentHtml == null) return node;
                            // Find ~H that references Phoenix.HTML.raw(content) (allow EParen wrapping)
                            var sigilIdx: Int = -1;
                            for (i in 0...stmts.length) {
                                switch (stmts[i].def) {
                                    case ESigil(type, content, modifiers) if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)") != -1):
                                        sigilIdx = i;
                                        break;
                                    case EParen(inner):
                                        switch (inner.def) {
                                            case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
                                                sigilIdx = i;
                                                break;
                                            default:
                                        }
                                    default:
                                }
                            }
                            if (sigilIdx == -1) return node;
                            // Build new statements: replace sigil with literal html, drop the assignment
                            var newStmts = [];
                            for (i in 0...stmts.length) {
                                if (i == contentAssignIdx) continue; // drop assignment
                                if (i == sigilIdx) {
                                    // Preserve parentheses if original was parenthesized
                                    switch (stmts[i].def) {
                                        case EParen(_):
                                            newStmts.push(makeASTWithMeta(EParen(makeAST(ESigil("H", contentHtml, ""))), stmts[i].metadata, stmts[i].pos));
                                        default:
                                            newStmts.push(makeASTWithMeta(ESigil("H", contentHtml, ""), stmts[i].metadata, stmts[i].pos));
                                    }
                                } else {
                                    newStmts.push(stmts[i]);
                                }
                            }
                            return makeASTWithMeta(EDef(name, args, guards, makeAST(EBlock(newStmts))), node.metadata, node.pos);
                        default:
                            return node;
                    }
                default:
                    return node;
            }
        });
    }

    /**
     * NumericNoOpCleanupPass
     *
     * WHAT
     * - Removes EBinary operations with numeric literals when used as statements.
     * - Converts bare increments like `if cond, do: count + 1` into `if cond, do: count = count + 1`.
     *
     * WHY
     * - Avoids Elixir warnings and preserves intended increment semantics when missed by earlier passes.
     */
    static function numericNoOpCleanupPass(ast: ElixirAST): ElixirAST {
        function isNumericLiteral(n: ElixirAST): Bool {
            return switch (n.def) {
                case EInteger(_) | EFloat(_): true;
                default: false;
            }
        }
        function rewriteIfIncrements(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case EBinary(Add, {def: EInteger(a)}, {def: EInteger(b)}):
                    // Fold constant addition to a single literal (eliminates operator warning)
                    makeAST(EInteger(a + b));
                case EIf(cond, thenB, elseB):
                    var newThen = switch (thenB.def) {
                        case EBinary(Add, {def: EVar(v)}, rhs):
                            makeAST(EMatch(PVar(v), makeAST(EBinary(Add, makeAST(EVar(v)), rewriteIfIncrements(rhs)))));
                        case EBinary(Add, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
                            makeAST(ENil);
                        default:
                            rewriteIfIncrements(thenB);
                    };
                    var newElse = if (elseB != null) switch (elseB.def) {
                        case EBinary(Add, {def: EVar(v2)}, rhs2):
                            makeAST(EMatch(PVar(v2), makeAST(EBinary(Add, makeAST(EVar(v2)), rewriteIfIncrements(rhs2)))));
                        case EBinary(Add, l2, r2) if (isNumericLiteral(l2) && isNumericLiteral(r2)):
                            makeAST(ENil);
                        default:
                            rewriteIfIncrements(elseB);
                    } else null;
                    makeASTWithMeta(EIf(rewriteIfIncrements(cond), newThen, newElse), n.metadata, n.pos);
                case EBlock(stmts):
                    var out: Array<ElixirAST> = [];
                    for (idx in 0...stmts.length) {
                        var s = stmts[idx];
                        // Drop standalone numeric operations like 0 + 1, but preserve a trailing
                        // bare numeric literal as it may represent an intentional return value
                        // (e.g., final 0 in compare/2).
                        var isLast = (idx == stmts.length - 1);
                        var drop = switch (s.def) {
                            case EBinary(_, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)): true;
                            case EInteger(_) if (!isLast): true; // Only drop bare integer when not last
                            default: false;
                        };
                        if (!drop) out.push(rewriteIfIncrements(s));
                    }
                    makeASTWithMeta(EBlock(out), n.metadata, n.pos);
                default:
                    n;
            }
        }
        return rewriteIfIncrements(ast);
    }
    
    /**
     * Phoenix function name mapping pass
     * 
     * WHY: Some Haxe helper functions need to be mapped to proper Phoenix functions
     * WHAT: Transforms assign_multiple to assign, and other custom names to Phoenix conventions
     * HOW: Detects function calls and remaps their names
     */
    static function phoenixFunctionMappingPass(node: ElixirAST): ElixirAST {
        return transformNode(node, function(n: ElixirAST): ElixirAST {
            switch(n.def) {
                // Transform assign_multiple(socket, map) to assign(socket, map)
                case ECall(null, "assign_multiple", args):
                    #if debug_ast_transformer
                    trace('[PhoenixFunctionMapping] Transforming assign_multiple to assign');
                    #end
                    return makeASTWithMeta(ECall(null, "assign", args), n.metadata, n.pos);
                    
                default:
                    return n;
            }
        });
    }
    
    /**
     * LiveView CoreComponents Import Pass: Add app's CoreComponents import for LiveView modules
     * 
     * WHY: LiveView modules that use component functions need to import their app's CoreComponents
     * WHAT: Detects component usage (<.button, <.input, etc.) and adds CoreComponents import
     * HOW: Looks for ~H sigils with component calls and adds appropriate import
     * 
     * NOTE: This can conflict with Phoenix.HTML.Form functions. In Phoenix apps, the CoreComponents
     * version takes precedence for dot-notation components (<.label> uses CoreComponents.label/1)
     */
    static function liveViewCoreComponentsImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if component functions are used
        var needsCoreComponents = false;
        var moduleName = "";
        
        #if debug_liveview_components
        trace('[XRay LiveViewComponents] Starting scan for component usage');
        #end
        
        // First, find the module name to determine the app name
        function findModuleName(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            switch(node.def) {
                case EDefmodule(name, _):
                    moduleName = name;
                    return;
                default:
                    iterateAST(node, findModuleName);
            }
        }
        
        findModuleName(ast);
        
        // Check if this is a LiveView module (has "Live" in name)
        if (moduleName == "" || moduleName.indexOf("Live") == -1) {
            return ast; // Not a LiveView module
        }
        
        // Recursive function to check for component usage in ~H sigils
        function checkForComponents(node: ElixirAST): Void {
            switch(node.def) {
                case ESigil(type, content, _):
                    if (type == "H") {
                        // Check if content contains component calls like <.button, <.input, etc.
                        if (content.indexOf("<.") != -1) {
                            #if debug_liveview_components
                            trace('[XRay LiveViewComponents] Found component usage in ~H sigil');
                            #end
                            needsCoreComponents = true;
                        }
                    }
                default:
                    iterateAST(node, checkForComponents);
            }
        }
        
        checkForComponents(ast);
        
        #if debug_liveview_components
        trace('[XRay LiveViewComponents] Needs CoreComponents: $needsCoreComponents');
        #end
        
        // Phase 2: Add import if needed
        if (!needsCoreComponents) return ast;
        
        // Extract app name from module name (e.g., TodoAppWeb.UserLive -> TodoAppWeb)
        var appWebName = "";
        if (moduleName.indexOf(".") != -1) {
            var parts = moduleName.split(".");
            if (parts.length > 0) {
                appWebName = parts[0]; // Get the first part (e.g., TodoAppWeb)
            }
        }
        
        if (appWebName == "") return ast; // Can't determine app name
        
        var coreComponentsModule = appWebName + ".CoreComponents";
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDefmodule(name, doBlock):
                    #if debug_liveview_components
                    trace('[XRay LiveViewComponents] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            // Check if CoreComponents is already imported
                            var hasImport = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):
                                        if (module == coreComponentsModule) {
                                            hasImport = true;
                                            break;
                                        }
                                    default:
                                }
                            }
                            
                            if (!hasImport) {
                                #if debug_liveview_components
                                trace('[XRay LiveViewComponents] Adding CoreComponents import: $coreComponentsModule');
                                #end
                                
                                // Create the import statement with specific functions to avoid conflicts
                                // Import CoreComponents but exclude label to avoid conflict with Phoenix.HTML.Form.label/1
                                // The dot-notation <.label> will still work via Phoenix.Component's component system
                                var exceptOptions: Array<EImportOption> = [{name: "label", arity: 1}];
                                var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
                                
                                // Add import after use statements but before function definitions
                                var newStatements = [];
                                var importAdded = false;
                                
                                for (stmt in statements) {
                                    newStatements.push(stmt);
                                    // Add import after use statements
                                    if (!importAdded) {
                                        switch(stmt.def) {
                                            case EUse(_, _):
                                                newStatements.push(importStmt);
                                                importAdded = true;
                                            default:
                                        }
                                    }
                                }
                                
                                // If no use statements, add at the beginning
                                if (!importAdded) {
                                    newStatements = [importStmt].concat(statements);
                                }
                                
                                var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                            }
                            
                            return node;
                            
                        default:
                            // Single expression body, unlikely for LiveView
                            return node;
                    }
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * String method transformation pass
     * 
     * WHY: Strings in Elixir don't have methods - they use the String module
     * WHAT: Transforms method calls on strings to String module calls
     * HOW: Detects ECall with string targets and converts to ERemoteCall
     * 
     * Examples:
     * - hex_chars.charAt(0) → String.at(hex_chars, 0)
     * - str.toLowerCase() → String.downcase(str)
     * - str.toUpperCase() → String.upcase(str)
     */
    /**
     * Instance method transformation pass
     * Transforms instance method calls to module function calls for standard library types
     * Example: buffer.add(str) → StringBuf.add(buffer, str)
     */
    static function instanceMethodTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_instance_methods
            switch(node.def) {
                case ECall(target, methodName, args):
                    trace('[InstanceMethodTransform] DEBUG - ECall detected:');
                    trace('  methodName: ${methodName}');
                    if (target != null) {
                        trace('  target.def: ${target.def}');
                    }
                    trace('  args.length: ${args.length}');
                default:
            }
            #end
            
            return switch(node.def) {
                // Handle instance method calls like instance.method(args)
                case ECall({def: EField(target, field), metadata: fieldMeta, pos: fieldPos}, methodName, args):
                    // This handles chained field access: struct.buffer.add()
                    // The field access (struct.buffer) becomes the target
                    // Transform to: StringBuf.add(struct.buffer, args)
                    
                    // Detect StringBuf methods
                    if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
                        #if debug_instance_methods
                        trace('[InstanceMethodTransform] Detected potential StringBuf method: ${methodName}');
                        #end
                        
                        // For now, assume it's a StringBuf if it has these methods
                        // A more sophisticated approach would track types through metadata
                        var moduleName = switch(methodName) {
                            case "add": "StringBuf";
                            case "toString" | "to_string": "StringBuf";
                            default: null;
                        };
                        
                        if (moduleName != null) {
                            // Transform instance.method(args) to Module.method(instance, args)
                            var moduleRef = makeAST(EVar(moduleName));
                            var targetField = makeASTWithMeta(EField(target, field), fieldMeta, fieldPos);
                            var newArgs = [targetField].concat(args);
                            var functionName = switch(methodName) {
                                case "toString" | "to_string": "to_string";
                                default: methodName;
                            };
                            
                            return makeASTWithMeta(
                                ERemoteCall(moduleRef, functionName, newArgs),
                                node.metadata,
                                node.pos
                            );
                        }
                    }
                    
                    // Check for other known instance types
                    // Could extend this to Map, List, etc.
                    node;
                    
                case ECall(target, methodName, args) if (target != null):
                    // Handle direct method calls (without field access chain)
                    // Check if this is a method that should be transformed
                    switch(target.def) {
                        case EVar(varName):
                            // Direct variable method call: buffer.add() or struct.write_value()
                            if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Direct method call on var: ${varName}.${methodName}');
                                #end
                                
                                // Transform to module function call
                                var moduleName = "StringBuf"; // Assume StringBuf for these methods
                                var moduleRef = makeAST(EVar(moduleName));
                                var functionName = switch(methodName) {
                                    case "toString" | "to_string": "to_string";
                                    default: methodName;
                                };
                                
                                return makeASTWithMeta(
                                    ERemoteCall(moduleRef, functionName, [target].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            } else if (methodName == "write_value" || methodName == "writeValue") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Struct method call on var: ${varName}.${methodName}');
                                #end
                                
                                // Transform struct.write_value(args) to write_value(struct, args)  
                                var functionName = switch(methodName) {
                                    case "writeValue": "write_value";
                                    default: methodName;
                                };
                                
                                // Transform to local function call with struct as first argument
                                return makeASTWithMeta(
                                    ECall(null, functionName, [target].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        case EField(obj, field):
                            // Method call on field access: struct.write_value()
                            // These should become local function calls: write_value(struct, ...)
                            if (methodName == "write_value" || methodName == "writeValue") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Struct method call: ${field}.${methodName}');
                                #end
                                
                                // Transform struct.method(args) to method(struct, args)
                                var functionName = switch(methodName) {
                                    case "writeValue": "write_value";
                                    default: methodName;
                                };
                                
                                // Create the target (struct.field)
                                var targetExpr = makeAST(EField(obj, field));
                                
                                // Transform to local function call with struct as first argument
                                return makeASTWithMeta(
                                    ECall(null, functionName, [targetExpr].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        default:
                    }
                    node;
                    
                default:
                    node;
            };
        });
    }
    
    static function stringMethodTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Handle method calls that look like string.method(args)
                case ECall(target, methodName, args) if (target != null):
                    // Check if this looks like a string method call
                    // Handle both camelCase and snake_case versions
                    var stringMethod = switch(methodName) {
                        case "charAt" | "char_at": "at";
                        case "charCodeAt" | "char_code_at": "to_charlist"; 
                        case "toLowerCase" | "to_lower_case": "downcase";
                        case "toUpperCase" | "to_upper_case": "upcase";
                        case "indexOf" | "index_of": "index";
                        case "substring" | "substr": "slice";
                        case "split": "split";
                        case "trim": "trim";
                        case "length": "length";  // Handle array/string length
                        case "toString" | "to_string": "to_string";  // Handle toString method calls
                        case "lastIndexOf" | "last_index_of": null;  // Special handling needed
                        case _: null;
                    };
                    
                    if (stringMethod != null) {
                        // Transform to String module call
                        #if debug_string_methods
                        trace('[StringMethodTransform] Converting ${methodName} to String.${stringMethod}');
                        if (target != null) {
                            trace('[StringMethodTransform] Target exists');
                        }
                        trace('[StringMethodTransform] Args count: ${args.length}');
                        #end
                        
                        // Special handling for different methods
                        if (methodName == "charCodeAt" || methodName == "char_code_at") {
                            // s.charCodeAt(pos) -> :binary.at(s, pos)
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EAtom(ElixirAtom.raw("binary"))),
                                    "at",
                                    [target].concat(args)
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else if (methodName == "toString" || methodName == "to_string") {
                            // Handle toString specially based on target type
                            // For integers and other primitives, use proper conversion
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("Integer")),
                                    "to_string",
                                    [target].concat(args)
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else if (methodName == "length") {
                            // s.length -> String.length(s)
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("String")),
                                    "length",
                                    [target]
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else {
                            // Prepend the target as the first argument
                            var newArgs = [target].concat(args);
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("String")),
                                    stringMethod,
                                    newArgs
                                ),
                                node.metadata,
                                node.pos
                            );
                        }
                    } else if (methodName == "lastIndexOf" || methodName == "last_index_of") {
                        // Special handling for lastIndexOf - no direct Elixir equivalent
                        // We can't easily transform this, so leave it as is for now
                        node;
                    } else {
                        node;
                    }
                    
                default:
                    node;
            };
        });
    }
    
    /**
     * Constant folding pass - evaluate constant expressions at compile time
     */
    static function constantFoldingPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Fold binary operations on constants
                case EBinary(op, left, right):
                    switch([left.def, right.def]) {
                        case [EInteger(l), EInteger(r)]:
                            var result = switch(op) {
                                case Add: l + r;
                                case Subtract: l - r;
                                case Multiply: l * r;
                                case Divide: Math.floor(l / r);
                                case Remainder: l % r;
                                case Less: l < r ? 1 : 0;
                                case Greater: l > r ? 1 : 0;
                                case LessEqual: l <= r ? 1 : 0;
                                case GreaterEqual: l >= r ? 1 : 0;
                                case Equal: l == r ? 1 : 0;
                                case NotEqual: l != r ? 1 : 0;
                                default: null;
                            };
                            
                            if (result != null) {
                                // For boolean results, convert to EBoolean
                                if (op == Less || op == Greater || op == LessEqual || 
                                    op == GreaterEqual || op == Equal || op == NotEqual) {
                                    makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
                                } else {
                                    makeASTWithMeta(EInteger(result), node.metadata, node.pos);
                                }
                            } else {
                                node; // Can't fold, return unchanged
                            }
                            
                        case [EString(l), EString(r)] if (op == StringConcat):
                            makeASTWithMeta(EString(l + r), node.metadata, node.pos);
                            
                        case [EList(l), EList(r)] if (op == Concat):
                            makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);
                            
                        default:
                            node; // Not constant, return unchanged
                    }
                    
                // Fold unary operations on constants
                case EUnary(op, expr):
                    switch(expr.def) {
                        case EInteger(i) if (op == Negate):
                            makeASTWithMeta(EInteger(-i), node.metadata, node.pos);
                        case EBoolean(b) if (op == Not):
                            makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);
                        default:
                            node;
                    }
                    
                default:
                    node; // Not a foldable expression
            }
        });
    }
    
    /**
     * String interpolation pass - convert string concatenation to idiomatic interpolation
     * 
     * WHY: Elixir's string interpolation #{} is more idiomatic and readable than concatenation
     * WHAT: Transforms EBinary(StringConcat, ...) chains into interpolated strings
     * HOW: Finds string concatenation chains and replaces them with interpolated strings
     * 
     * NOTE: We use a custom traversal instead of transformNode to avoid recursive transformation
     */
    static function stringInterpolationPass(ast: ElixirAST): ElixirAST {
        function transform(node: ElixirAST): ElixirAST {
            // Handle null nodes
            if (node == null) return null;
            
            // First check if this is a string concatenation chain at the top level
            switch(node.def) {
                case EBinary(StringConcat, l, r):
                    #if debug_string_interpolation
                    var fullNodeStr = ElixirASTPrinter.printAST(node);
                    trace('[StringInterpolation] Found concatenation pattern: ${fullNodeStr.substring(0, 200)}');
                    trace('[StringInterpolation] Left type: ${Type.enumConstructor(l.def)}');
                    trace('[StringInterpolation] Right type: ${Type.enumConstructor(r.def)}');
                    #end
                    // Collect all parts of the concatenation chain
                    var parts = [];
                    
                    function collectParts(expr: ElixirAST) {
                        switch(expr.def) {
                            case EBinary(StringConcat, l, r):
                                collectParts(l);
                                collectParts(r);
                            case EString(s):
                                parts.push({isString: true, value: s, expr: null});
                            default:
                                parts.push({isString: false, value: null, expr: expr});
                        }
                    }
                    
                    collectParts(node);
                    
                    // Check if we should convert to interpolation
                    var hasNonString = false;
                    var hasEmptyString = false;
                    for (part in parts) {
                        if (!part.isString) {
                            hasNonString = true;
                        } else if (part.value == "") {
                            hasEmptyString = true;
                        }
                    }
                    
                    // Only convert if we have non-string parts and multiple parts
                    if (hasNonString && parts.length > 1) {
                        // Build interpolated string
                        var result = '"';
                        
                        for (i in 0...parts.length) {
                            var part = parts[i];
                            if (part.isString) {
                                // Add literal string part (escape special characters)
                                var escaped = part.value;
                                escaped = escaped.split('\\').join('\\\\');
                                escaped = escaped.split('"').join('\\"');
                                escaped = escaped.split('#{').join('\\#{');  // Escape interpolation syntax
                                result += escaped;
                            } else {
                                // Add interpolated expression
                                // First recursively transform the expression
                                var transformedExpr = transform(part.expr);
                                
                                // Strip unnecessary .to_string() calls since Elixir auto-converts in interpolation
                                var exprToInterpolate = switch(transformedExpr.def) {
                                    case ECall(target, "to_string", []) if (target != null):
                                        // Remove the .to_string() wrapper, use the target directly
                                        target;
                                    default:
                                        transformedExpr;
                                };
                                
                                // Simplify common shapes for idiomatic interpolation: inspect(Map.get(obj, :field)) -> obj.field
                                function simplifyInterpolationExpr(e: ElixirAST): ElixirAST {
                                    return switch (e.def) {
                                        case ECall(null, "inspect", [inner]):
                                            switch (inner.def) {
                                                case ERemoteCall({def: EVar("Map")}, "get", args) if (args != null && args.length == 2):
                                                    switch (args[1].def) {
                                                        case EAtom(field): makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);
                                                        default: e;
                                                    }
                                                default: e;
                                            }
                                        default:
                                            e;
                                    }
                                }
                                exprToInterpolate = simplifyInterpolationExpr(exprToInterpolate);
                                
                                // Sanitize inline expression for interpolation: ensure no raw multi-statement
                                // blocks appear in function arguments (e.g., Enum.join(<block>, ",")).
                                function sanitizeForInterpolation(n: ElixirAST): ElixirAST {
                                    return transformNode(n, function(x: ElixirAST): ElixirAST {
                                        return switch (x.def) {
                                            case ECall(t, name, args):
                                                var newArgs = [];
                                                for (a in args) switch (a.def) {
                                                    case EBlock(sts) if (sts != null && sts.length > 1):
                                                        newArgs.push(makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: a }])), "", [])));
                                                    default:
                                                        newArgs.push(a);
                                                }
                                                if (newArgs != args) makeAST(ECall(t, name, newArgs)) else x;
                                            case ERemoteCall(mod, fname, rargs):
                                                var newRArgs = [];
                                                for (a2 in rargs) switch (a2.def) {
                                                    case EBlock(sts2) if (sts2 != null && sts2.length > 1):
                                                        newRArgs.push(makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: a2 }])), "", [])));
                                                    default:
                                                        newRArgs.push(a2);
                                                }
                                                if (newRArgs != rargs) makeAST(ERemoteCall(mod, fname, newRArgs)) else x;
                                            default:
                                                x;
                                        }
                                    });
                                }
                                // Avoid wrapping trivial expressions (vars, literals, simple field chains)
                                function isTrivialForInterpolation(x: ElixirAST, depth:Int = 0): Bool {
                                    if (x == null || depth > 4) return false;
                                    return switch (x.def) {
                                        case EVar(_): true;
                                        case EInteger(_)|EFloat(_)|EBoolean(_)|ENil|EString(_)|EAtom(_): true;
                                        case EField(obj, _): isTrivialForInterpolation(obj, depth + 1);
                                        default: false;
                                    }
                                }
                                var sanitizedExpr = sanitizeForInterpolation(exprToInterpolate);
                                var exprStr = ElixirASTPrinter.printAST(sanitizedExpr);
                                var trivial = isTrivialForInterpolation(sanitizedExpr);
                                // Only wrap when non-trivial and the printed expression clearly spans multiple
                                // statements or contains a standalone assignment (not a comparison).
                                var needsWrapIife = !trivial && ((exprStr.indexOf('\n') != -1) || (exprStr.indexOf(' = ') != -1 && exprStr.indexOf('==') == -1));
                                var printable = needsWrapIife ? '(fn -> ' + exprStr + ' end).()' : exprStr;
                                result += '#{' + printable + '}';
                            }
                        }
                        
                        result += '"';
                        
                        #if debug_string_interpolation
                        trace('[StringInterpolation] Transformed to: $result');
                        #end
                        
                        // Return raw interpolated string
                        return makeASTWithMeta(ERaw(result), node.metadata, node.pos);
                    }
                    
                default:
                    // Not a string concatenation at top level
            }
            
            // For all other nodes, recursively transform children
            return switch(node.def) {
                case EModule(name, attributes, body):
                    makeASTWithMeta(
                        EModule(name, attributes, body.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDefmodule(name, doBlock):
                    makeASTWithMeta(
                        EDefmodule(name, transform(doBlock)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDef(name, args, guards, body):
                    makeASTWithMeta(
                        EDef(name, args, guards, transform(body)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDefp(name, args, guards, body):
                    makeASTWithMeta(
                        EDefp(name, args, guards, transform(body)),
                        node.metadata,
                        node.pos
                    );
                    
                case EBlock(expressions):
                    makeASTWithMeta(
                        EBlock(expressions.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                // For other binary operations that aren't StringConcat, transform children
                case EBinary(op, left, right) if (op != StringConcat):
                    makeASTWithMeta(
                        EBinary(op, transform(left), transform(right)),
                        node.metadata,
                        node.pos
                    );
                
                // Transform function calls (e.g., Log.trace with string concatenation arguments)
                case ECall(target, method, args):
                    makeASTWithMeta(
                        ECall(
                            target != null ? transform(target) : null,
                            method,
                            args.map(transform)
                        ),
                        node.metadata,
                        node.pos
                    );
                
                // Transform remote calls (module function calls)
                case ERemoteCall(module, func, args):
                    makeASTWithMeta(
                        ERemoteCall(
                            transform(module),
                            func,
                            args.map(transform)
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform match expressions (assignments)
                case EMatch(pattern, expr):
                    makeASTWithMeta(
                        EMatch(pattern, transform(expr)),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform if expressions
                case EIf(condition, then_expr, else_expr):
                    makeASTWithMeta(
                        EIf(
                            transform(condition),
                            transform(then_expr),
                            else_expr != null ? transform(else_expr) : null
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform list literals (for array building patterns)
                case EList(items):
                    makeASTWithMeta(
                        EList(items.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform case expressions - recurse into clauses
                case ECase(expr, clauses):
                    #if debug_string_interpolation
                    trace('[StringInterpolation] Found ECase, transforming ${clauses.length} clauses');
                    #end
                    makeASTWithMeta(
                        ECase(
                            transform(expr),
                            clauses.map(clause -> {
                                #if debug_string_interpolation
                                var bodyStr = ElixirASTPrinter.printAST(clause.body);
                                if (bodyStr.indexOf("rgb(") > -1 || bodyStr.indexOf("<>") > -1) {
                                    trace('[StringInterpolation] Clause body BEFORE transformation: ${bodyStr.substring(0, 200)}');
                                    trace('[StringInterpolation] Clause body type: ${Type.enumConstructor(clause.body.def)}');
                                }
                                #end
                                var transformedBody = transform(clause.body);
                                #if debug_string_interpolation
                                var transformedStr = ElixirASTPrinter.printAST(transformedBody);
                                if (bodyStr.indexOf("<>") > -1) {
                                    trace('[StringInterpolation] Clause body AFTER transformation: ${transformedStr.substring(0, 200)}');
                                }
                                #end
                                {
                                    pattern: clause.pattern, // Don't transform pattern
                                    guard: clause.guard != null ? transform(clause.guard) : null,
                                    body: transformedBody
                                }
                            })
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                case EParen(expr):
                    // Handle parenthesized expressions - recurse into contents
                    makeASTWithMeta(
                        EParen(transform(expr)),
                        node.metadata,
                        node.pos
                    );
                    
                default:
                    // For all other nodes, return unchanged
                    // We're only transforming the specific nodes we care about
                    node;
            }
        }
        
        return transform(ast);
    }
    
    /**
     * Loop Transformation Pass
     * 
     * WHY: Haxe desugars loops into complex reduce_while(Stream.iterate(...)) patterns
     *      that are verbose and non-idiomatic in Elixir. These patterns should be
     *      transformed into clean Enum operations or comprehensions.
     * 
     * WHAT: Detects and transforms common loop patterns:
     *       - Simple iteration (0...n) → Enum.each(0..n-1, fn i -> ... end)
     *       - Array iteration → Enum.each(array, fn item -> ... end)
     *       - Collection building → for comprehensions
     *       - Filtering → Enum.filter or comprehension with guards
     * 
     * HOW: Pattern matches on Enum.reduce_while with Stream.iterate and transforms
     *      based on the loop body pattern (side effects only, collecting, filtering)
     * 
     * Example transformations:
     * From: Enum.reduce_while(Stream.iterate(0, fn n -> n + 1 end), {0}, fn _, {i} ->
     *         if (i < 5) do
     *           Log.trace(i)
     *           {:cont, {i + 1}}
     *         else
     *           {:halt, {i}}
     *         end
     *       end)
     * To: Enum.each(0..4, fn i -> Log.trace(i) end)
     */
    static function loopTransformationPass(ast: ElixirAST): ElixirAST {
        #if debug_loop_transformation
        trace("[LoopTransform] Starting loop transformation pass");
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ERemoteCall(module, funcName, args):
                    // Check for Enum.reduce_while pattern
                    switch(module.def) {
                        case EVar("Enum"):
                            if (funcName == "reduce_while" && args != null && args.length >= 3) {
                                #if debug_loop_transformation
                                trace("[LoopTransform] Found Enum.reduce_while call");
                                trace("[LoopTransform]   Args length: " + args.length);
                                if (args.length >= 3) {
                                    trace("[LoopTransform]   Third arg (reducer fn) type: " + Type.enumConstructor(args[2].def));
                                }
                                #end

                                // Check if first arg is Stream.iterate
                                var streamArg = args[0];
                                switch(streamArg.def) {
                                    case ERemoteCall(streamModule, streamFunc, streamArgs):
                                        switch(streamModule.def) {
                                            case EVar("Stream"):
                                                if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
                                                    #if debug_loop_transformation
                                                    trace("[LoopTransform] Found Stream.iterate pattern - WILL ATTEMPT TRANSFORMATION");
                                                    #end
                                                    
                                                    // Extract the initial value and increment function
                                                    var initValue = streamArgs[0];
                                                    var incrementFunc = streamArgs[1];
                                                    
                                                    // Check if this is a simple counter (0, fn n -> n + 1 end)
                                                    var isSimpleCounter = false;
                                                    switch(initValue.def) {
                                                        case EInteger(0):
                                                            switch(incrementFunc.def) {
                                                                case EFn(clauses) if (clauses.length > 0):
                                                                    var clause = clauses[0];
                                                                    if (clause.args.length == 1) {
                                                                        // Check if body is n + 1
                                                                        switch(clause.body.def) {
                                                                            case EBinary(Add, left, right):
                                                                                switch(left.def) {
                                                                                    case EVar(varName):
                                                                                        // Get the parameter name from the pattern
                                                                                        var paramName = switch(clause.args[0]) {
                                                                                            case PVar(name): name;
                                                                                            default: null;
                                                                                        };
                                                                                        if (paramName != null && varName == paramName) {
                                                                                            switch(right.def) {
                                                                                                case EInteger(1):
                                                                                                    isSimpleCounter = true;
                                                                                                default:
                                                                                            }
                                                                                        }
                                                                                    default:
                                                                                }
                                                                            default:
                                                                        }
                                                                    }
                                                                default:
                                                            }
                                                        default:
                                                    }
                                                    
                                                    if (isSimpleCounter) {
                                                        #if debug_loop_transformation
                                                        trace("[LoopTransform] Detected simple counter loop");
                                                        #end
                                                        
                                                        // Analyze the loop function to extract the body and condition
                                                        var loopFunc = args[2];
                                                        switch(loopFunc.def) {
                                                            case EFn(clauses) if (clauses.length > 0):
                                                                var clause = clauses[0];
                                                                // Try to extract the loop bound and body
                                                                var loopInfo = analyzeLoopBody(clause.body);
                                                                if (loopInfo != null) {
                                                                    #if debug_loop_transformation
                                                                    trace("[LoopTransform] Successfully analyzed loop body");
                                                                    trace("[LoopTransform] Upper bound: " + ElixirASTPrinter.print(loopInfo.upperBound, 0));
                                                                    trace("[LoopTransform] Has side effects only: " + loopInfo.hasSideEffectsOnly);
                                                                    #end
                                                                    
                                                                    // Transform to idiomatic Elixir
                                                                    if (loopInfo.hasSideEffectsOnly) {
                                                                        // Simple iteration with side effects → Enum.each
                                                                        var range = makeAST(ERange(
                                                                            makeAST(EInteger(0), node.pos),
                                                                            makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos),
                                                                            false // inclusive range (0..n-1)
                                                                        ), node.pos);
                                                                        
                                                                        var eachFunc = makeAST(EFn([{
                                                                            args: [PVar(loopInfo.iteratorVar)],
                                                                            guard: null,
                                                                            body: loopInfo.loopBody
                                                                        }]), node.pos);
                                                                        
                                                                        #if debug_loop_transformation
                                                                        trace("[LoopTransform] Transforming to Enum.each");
                                                                        #end
                                                                        
                                                                        return makeAST(ERemoteCall(
                                                                            makeAST(EVar("Enum"), node.pos),
                                                                            "each",
                                                                            [range, eachFunc]
                                                                        ), node.pos);
                                                                    }
                                                                }
                                                            default:
                                                        }
                                                    }
                                                }
                                            default:
                                        }
                                    default:
                                }
                            }
                        default:
                    }
                default:
            }
            
            return node;
        });
    }
    
    /**
     * Analyze a loop body to extract iteration information
     */
    static function analyzeLoopBody(body: ElixirAST): Null<{upperBound: ElixirAST, iteratorVar: String, loopBody: ElixirAST, hasSideEffectsOnly: Bool}> {
        // Look for the if condition pattern
        switch(body.def) {
            case EIf(condition, thenBranch, elseBranch):
                // Extract the upper bound from the condition
                var upperBound: ElixirAST = null;
                var iteratorVar: String = null;
                
                switch(condition.def) {
                    case EBinary(Less, left, right):
                        // Pattern: i < upperBound
                        switch(left.def) {
                            case EVar(varName):
                                iteratorVar = varName;
                                upperBound = right;
                            default:
                        }
                    default:
                }
                
                if (upperBound != null && iteratorVar != null) {
                    // Extract the loop body from the then branch
                    var loopBody: ElixirAST = null;
                    var hasSideEffectsOnly = true;
                    
                    switch(thenBranch.def) {
                        case EBlock(exprs):
                            // Filter out the increment and continuation
                            var bodyExprs = [];
                            for (expr in exprs) {
                                switch(expr.def) {
                                    case ETuple([contAtom, _]):
                                        // Skip {:cont, ...}
                                        switch(contAtom.def) {
                                            case EAtom(cont) if (cont == "cont"):
                                                // Skip
                                            default:
                                                bodyExprs.push(expr);
                                        }
                                    case EBinary(Add, _, _):
                                        // Skip increment expressions
                                    case EInteger(_):
                                        // Skip standalone integers
                                    default:
                                        bodyExprs.push(expr);
                                }
                            }
                            
                            if (bodyExprs.length == 1) {
                                loopBody = bodyExprs[0];
                            } else if (bodyExprs.length > 1) {
                                loopBody = makeAST(EBlock(bodyExprs), body.pos);
                            }
                        default:
                    }
                    
                    if (loopBody != null) {
                        return {
                            upperBound: upperBound,
                            iteratorVar: iteratorVar,
                            loopBody: loopBody,
                            hasSideEffectsOnly: hasSideEffectsOnly
                        };
                    }
                }
            default:
        }
        
        return null;
    }
    
    /**
     * Pipeline optimization pass - convert sequential operations to pipeline
     */
    static function pipelineOptimizationPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                case EBlock(expressions):
                    // Look for pipeline patterns in blocks
                    var optimized = detectAndOptimizePipeline(expressions);
                    if (optimized != null) {
                        optimized;
                    } else {
                        node;
                    }
                    
                default:
                    node;
            }
        });
    }
    
    /**
     * Map Iterator Transformation Pass (forwarder)
     * Thin forwarder to MapAndCollectionTransforms.mapIteratorTransformPass
     */
    static function mapIteratorTransformPass(ast: ElixirAST): ElixirAST {
        return reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.mapIteratorTransformPass(ast);
    }
    
    // Helper function to check if an AST contains Map iterator patterns
    // (legacy helper functions removed; implemented in MapAndCollectionTransforms)
    
    /**
     * Comprehension conversion pass - convert loops to comprehensions
     * This pass needs to handle module-level transformation to add generated functions
     */
    static function comprehensionConversionPass(ast: ElixirAST): ElixirAST {
        // Collection for generated loop functions
        var generatedFunctions: Array<ElixirAST> = [];
        var loopCounter = 0;
        
        // First pass: transform loops and collect generated functions
        function transformLoops(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Convert for loops that build lists
                case EFor(generators, filters, body, into, uniq):
                    // Already a comprehension, keep as-is
                    node;
                    
                // Convert while loops to recursive functions
                case ECall(null, "while_loop", [condition, body]):
                    // Generate unique function name
                    var funcName = "loop_" + (loopCounter++);
                    
                    // Transform condition and body recursively
                    var transformedCondition = transformNode(condition, transformLoops);
                    var transformedBody = transformNode(body, transformLoops);
                    
                    // Create recursive function definition
                    var recursiveFunc = makeAST(
                        EDefp(funcName, [], null, 
                            makeAST(EIf(
                                transformedCondition,
                                makeAST(EBlock([
                                    transformedBody,
                                    makeAST(ECall(null, funcName, []))
                                ])),
                                makeAST(EAtom(ElixirAtom.ok()))
                            ))
                        )
                    );
                    
                    // Add to generated functions collection
                    generatedFunctions.push(recursiveFunc);
                    
                    // Replace with function call
                    makeAST(ECall(null, funcName, []));
                    
                default:
                    // Return node unchanged - base case to prevent infinite recursion
                    node;
            }
        }
        
        // Apply transformation
        var transformed = transformLoops(ast);
        
        // If we're at module level and have generated functions, insert them
        if (generatedFunctions.length > 0) {
            switch(transformed.def) {
                case EModule(name, attributes, body):
                    // Insert generated functions at the end of the module body
                    var newBody = body.concat(generatedFunctions);
                    return makeAST(EModule(name, attributes, newBody));
                default:
                    // For non-module nodes, we need to wrap or handle differently
                    // This shouldn't happen in normal compilation
                    return transformed;
            }
        }
        
        return transformed;
    }
    
    /**
     * Abstract Method This Reference Fix Pass
     * 
     * WHY: In abstract methods like toDynamic(), Haxe generates parameters like "this_1"
     * but the AST builder incorrectly uses "struct" for TConst(TThis), causing reference mismatches.
     * 
     * WHAT: Fixes "struct" references in anonymous functions to match the actual parameter name.
     * - Detects anonymous functions with parameters like "this", "this_1", etc.
     * - Replaces "struct" references in the body with the actual parameter name
     * 
     * HOW: Tracks the first parameter of anonymous functions and ensures body references match
     */
    static function abstractMethodThisPass(ast: ElixirAST): ElixirAST {
        #if debug_abstract_this
        trace('[XRay AbstractThis] Starting pass');
        #end
        
        // Add debug to see what nodes we're actually getting
        #if debug_abstract_this
        function debugNode(node: ElixirAST, depth: Int = 0) {
            var indent = [for (i in 0...depth) "  "].join("");
            switch(node.def) {
                case EModule(name, _, body):
                    trace('$indent[XRay AbstractThis] Module: $name with ${body.length} definitions');
                    for (def in body) debugNode(def, depth + 1);
                case EDef(name, _, _, body):
                    trace('$indent[XRay AbstractThis] Def: $name');
                    debugNode(body, depth + 1);
                case EFn(clauses):
                    trace('$indent[XRay AbstractThis] !! Found EFn with ${clauses.length} clauses !!');
                default:
                    // Don't trace every node type, just the ones we care about
            }
        }
        debugNode(ast, 0);
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EFn(clauses):
                    #if debug_abstract_this
                    trace('[XRay AbstractThis] Processing EFn with ${clauses.length} clauses');
                    #end
                    // Check if this is an abstract method with "this" parameter
                    var fixedClauses = [];
                    var hasChanges = false;
                    
                    for (clause in clauses) {
                        if (clause.args.length > 0) {
                            switch(clause.args[0]) {
                                case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
                                    #if debug_abstract_this
                                    trace('[XRay AbstractThis] Found function with this/struct parameter: $paramName');
                                    trace('[XRay AbstractThis] Body before fix: ${ElixirASTPrinter.print(clause.body, 0)}');
                                    #end
                                    
                                    // Found a "this", "this_1", "struct", or "_struct" parameter
                                    // Replace "struct" or "this" with the actual parameter name in body
                                    var fixedBody = replaceStructWithParam(clause.body, paramName);
                                    
                                    #if debug_abstract_this
                                    trace('[XRay AbstractThis] Body after fix: ${ElixirASTPrinter.print(fixedBody, 0)}');
                                    #end
                                    
                                    hasChanges = true;
                                    fixedClauses.push({
                                        args: clause.args,
                                        guard: clause.guard,
                                        body: fixedBody
                                    });
                                default:
                                    fixedClauses.push(clause);
                            }
                        } else {
                            fixedClauses.push(clause);
                        }
                    }
                    
                    if (hasChanges) {
                        #if debug_abstract_this
                        trace('[XRay AbstractThis] Applied fix to function');
                        #end
                        return makeASTWithMeta(EFn(fixedClauses), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Helper: Replace "struct" or "this" variables with the actual parameter name
     * 
     * PROBLEM: In abstract methods, the AST builder sometimes generates incorrect variable
     * references. The parameter might be named "this_1" but the body references "this" or
     * "struct", causing compilation errors like "undefined variable this".
     * 
     * EXAMPLES:
     * - Input:  fn this_1 -> this end       // Wrong: "this" doesn't exist
     * - Output: fn this_1 -> this_1 end     // Fixed: matches parameter name
     * 
     * - Input:  fn this -> struct end       // Wrong: "struct" is internal compiler name
     * - Output: fn this -> this end         // Fixed: uses actual parameter
     * 
     * - Input:  fn this_2 -> struct.field end    // Wrong: struct not in scope
     * - Output: fn this_2 -> this_2.field end    // Fixed: correct reference
     * 
     * @param ast The AST to transform
     * @param paramName The actual parameter name to use (e.g., "this", "this_1", "this_2")
     * @return AST with all "struct" and "this" references replaced with paramName
     */
    static function replaceStructWithParam(ast: ElixirAST, paramName: String): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EVar("struct") | EVar("this"):
                    // Replace "struct" or "this" with the actual parameter name
                    return makeASTWithMeta(EVar(paramName), node.metadata, node.pos);
                default:
                    return node;
            }
        });
    }
    
    /**
     * Bitwise Import Pass
     * 
     * WHY: Elixir requires "import Bitwise" to use bitwise operators like &&&, |||, ^^^
     * but the generated code doesn't include this import automatically.
     * 
     * WHAT: Detects usage of bitwise operators and adds "import Bitwise" to the module.
     * - Scans the entire AST for bitwise operators
     * - Adds the import statement if any are found
     * 
     * HOW: Two-phase approach:
     * 1. Detection: Walk the AST to find bitwise operators
     * 2. Injection: Add import to module (handles both EModule and EDefmodule formats)
     * 
     * IMPORTANT AST STRUCTURE: Modules can be represented in two ways:
     * 
     * EDefmodule(name, doBlock): Standard Elixir "defmodule Name do ... end" format
     *   This is the most common format. The import must be added as the first 
     *   statement in the do block.
     *   
     *   Original Haxe code:
     *     class StringTools {
     *         public static function ltrim(s: String): String {
     *             // Uses bitwise operators &&&
     *         }
     *     }
     *   
     *   Example AST:
     *     EDefmodule("StringTools", 
     *       EBlock([
     *         EImport("Bitwise", null, null),  // <-- Insert here
     *         EFunction(...),
     *         EFunction(...)
     *       ])
     *     )
     * 
     * EModule(name, attributes, body): Alternative format with attributes array
     *   Less common format. The import is added to the attributes array.
     *   
     *   This format may be used internally by the compiler for certain constructs
     *   or intermediate representations. Most user-defined Haxe classes generate
     *   EDefmodule, not EModule. The exact conditions that produce EModule vs
     *   EDefmodule depend on the AST builder's internal logic.
     *   
     *   Example AST:
     *     EModule("StringTools",
     *       [
     *         EImport("Bitwise", null, null),  // <-- Insert here
     *         EAttribute(...)
     *       ],
     *       [EFunction(...), EFunction(...)]
     *     )
     * 
     * The original pass only handled EModule, which is why it wasn't working for
     * most generated code that uses EDefmodule format.
     */
    static function bitwiseImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if bitwise operators are used
        var needsBitwise = false;
        
        #if debug_bitwise_import
        trace('[XRay BitwiseImport] Starting scan for bitwise operators');
        #end
        
        // Recursive function to deeply traverse the AST
        function checkForBitwise(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            #if debug_bitwise_import
            var nodeType = Type.enumConstructor(node.def);
            if (nodeType == "EBinary") {
                trace('[XRay BitwiseImport] Checking EBinary node');
            }
            #end

            switch(node.def) {
                case EBinary(op, left, right):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Binary operator: $op');
                    #end
                    switch(op) {
                        case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
                            #if debug_bitwise_import
                            trace('[XRay BitwiseImport] Found bitwise operator: $op');
                            #end
                            needsBitwise = true;
                        default:
                    }
                    // Recursively check child nodes
                    checkForBitwise(left);
                    checkForBitwise(right);
                case EUnary(BitwiseNot, expr):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Found BitwiseNot operator');
                    #end
                    needsBitwise = true;
                    checkForBitwise(expr);
                default:
                    // For all other node types, recursively visit children
                    iterateAST(node, checkForBitwise);
            }
        }
        
        checkForBitwise(ast);
        
        #if debug_bitwise_import
        trace('[XRay BitwiseImport] Needs bitwise: $needsBitwise');
        #end
        
        // Phase 2: Add import if needed
        if (!needsBitwise) return ast;
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDefmodule(name, doBlock):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            #if debug_bitwise_import
                            trace('[XRay BitwiseImport] Defmodule has ${statements.length} statements');
                            #end
                            
                            // Check if Bitwise is already imported
                            var hasImport = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):  // Match all three parameters
                                        if (module == "Bitwise") {
                                            hasImport = true;
                                            break;
                                        }
                                    default:
                                }
                            }
                            
                            if (!hasImport) {
                                // Add import Bitwise at the beginning
                                var newStatements = statements.copy();
                                newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));  // Provide all three parameters
                                
                                #if debug_bitwise_import
                                trace('[XRay BitwiseImport] Added import Bitwise to defmodule');
                                #end
                                
                                return makeASTWithMeta(
                                    EDefmodule(name, makeAST(EBlock(newStatements))),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        default:
                    }
                    return node;
                    
                case EModule(name, attributes, body):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Processing module: $name');
                    trace('[XRay BitwiseImport] Current attributes count: ${attributes.length}');
                    #end
                    
                    // Check if Bitwise is already imported (by checking attribute names)
                    var hasImport = false;
                    for (attr in attributes) {
                        if (attr.name == "import" && attr.value != null) {
                            // Check if it's importing Bitwise
                            switch(attr.value.def) {
                                case EAtom(atomVal) if (atomVal == "Bitwise"):
                                    hasImport = true;
                                case EVar("Bitwise"):
                                    hasImport = true;
                                default:
                            }
                        }
                    }
                    
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Has existing import: $hasImport');
                    #end
                    
                    if (!hasImport) {
                        // Add import Bitwise at the beginning of attributes
                        var newAttributes = attributes.copy();
                        newAttributes.insert(0, {
                            name: "import",
                            value: makeAST(EAtom(ElixirAtom.raw("Bitwise")))
                        });
                        
                        #if debug_bitwise_import
                        trace('[XRay BitwiseImport] Added import Bitwise to module');
                        #end
                        
                        return makeASTWithMeta(
                            EModule(name, newAttributes, body),
                            node.metadata,
                            node.pos
                        );
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * List Effect Lifting Pass
     * 
     * WHY: Elixir doesn't allow assignments or side-effecting expressions inside list literals.
     * The malformed pattern `g = g ++ [g = [] ...]` creates illegal syntax.
     * 
     * WHAT: Detects and lifts side-effecting expressions out of list literals.
     * - Identifies assignments and other side effects within EList elements
     * - Extracts them to statements before the list construction
     * - Replaces them with pure variable references
     * 
     * HOW: Transforms EList nodes by:
     * 1. Scanning elements for side effects (assignments, blocks)
     * 2. Extracting effects to temporary variables
     * 3. Building the list with pure expressions only
     * 
     * Example:
     * Input:  [g = [], g = g ++ [1], g]
     * Output: g = []; g = g ++ [1]; [g]
     */
    static function listEffectLiftingPass(ast: ElixirAST): ElixirAST {
        #if debug_effect_lifting
        trace('[XRay ListEffectLifting] Starting pass');
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EList(elements):
                    #if debug_effect_lifting
                    trace('[XRay ListEffectLifting] Processing list with ${elements.length} elements');
                    #end
                    
                    // Check if any element has side effects
                    var hasEffects = false;
                    var liftedStatements: Array<ElixirAST> = [];
                    var pureElements: Array<ElixirAST> = [];
                    
                    for (i in 0...elements.length) {
                        var elem = elements[i];
                        #if debug_effect_lifting
                        trace('[XRay ListEffectLifting] Checking element $i: ${ElixirASTPrinter.print(elem, 0).substring(0, 50)}');
                        #end
                        
                        switch(elem.def) {
                            case EMatch(left, right):
                                // Assignment inside list - needs lifting
                                #if debug_effect_lifting
                                trace('[XRay ListEffectLifting] Found assignment in element $i');
                                #end
                                hasEffects = true;
                                liftedStatements.push(elem);
                                // Replace with just the variable reference
                                switch(left) {
                                    case PVar(name):
                                        pureElements.push(makeAST(EVar(name)));
                                    default:
                                        // For other patterns, convert to a simple variable
                                        pureElements.push(makeAST(EVar("_lifted_var")));
                                }
                                
                            case EBlock(exprs) if (exprs.length > 0):
                                // Block inside list - extract statements, keep last expression
                                #if debug_effect_lifting
                                trace('[XRay ListEffectLifting] Found block in element $i with ${exprs.length} expressions');
                                #end
                                hasEffects = true;
                                for (j in 0...exprs.length - 1) {
                                    liftedStatements.push(exprs[j]);
                                }
                                pureElements.push(exprs[exprs.length - 1]);
                                
                            case EBinary(Concat, left, right):
                                // Check if this is a nested problematic pattern
                                switch(right.def) {
                                    case EList(innerElements) if (innerElements.length > 0):
                                        // Check if inner list has assignments
                                        var innerHasEffects = false;
                                        for (innerElem in innerElements) {
                                            switch(innerElem.def) {
                                                case EMatch(_, _) | EBlock(_):
                                                    innerHasEffects = true;
                                                    break;
                                                default:
                                            }
                                        }
                                        if (innerHasEffects) {
                                            #if debug_effect_lifting
                                            trace('[XRay ListEffectLifting] Found nested list with effects');
                                            #end
                                            // Process the inner list recursively
                                            var processedInner = listEffectLiftingPass(makeAST(right.def));
                                            switch(processedInner.def) {
                                                case EBlock(stmts) if (stmts.length > 0):
                                                    hasEffects = true;
                                                    // Add all but last statement to lifted
                                                    for (k in 0...stmts.length - 1) {
                                                        liftedStatements.push(stmts[k]);
                                                    }
                                                    // Keep the concatenation with cleaned list
                                                    pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));
                                                default:
                                                    pureElements.push(elem);
                                            }
                                        } else {
                                            pureElements.push(elem);
                                        }
                                    default:
                                        pureElements.push(elem);
                                }
                                
                            default:
                                // Pure expression, keep as-is
                                pureElements.push(elem);
                        }
                    }
                    
                    if (hasEffects) {
                        #if debug_effect_lifting
                        trace('[XRay ListEffectLifting] Lifting ${liftedStatements.length} statements');
                        #end
                        
                        // Return a block with lifted statements followed by pure list
                        var allStatements = liftedStatements.copy();
                        allStatements.push(makeAST(EList(pureElements)));
                        return makeAST(EBlock(allStatements));
                    }
                    
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Struct field assignment transformation pass
     * 
     * WHY: Haxe's mutable field assignments (this.field = value) need to be transformed
     *      to Elixir's immutable struct update syntax (%{struct | field: value})
     * 
     * WHAT: Detects patterns like EMatch(EField(struct_var, field), value) where struct_var
     *       is a struct parameter (like "struct" or "self"), and transforms them to return
     *       a new struct with the updated field
     * 
     * HOW: - Identifies field assignments on struct parameters
     *      - Converts them to struct update syntax
     *      - Returns the updated struct for proper threading
     * 
     * Example: struct.count = 5 → %{struct | count: 5}
     */
    static function structFieldAssignmentTransformPass(ast: ElixirAST): ElixirAST {
        // Need to track the original struct variable for field assignments
        var structVarTracking: Map<String, String> = new Map();
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EBlock(expressions):
                    // Process block expressions looking for field assignment patterns
                    var transformed = [];
                    var i = 0;
                    
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        
                        // Look for pattern: spec = worker(...) followed by fieldName = value
                        switch(expr.def) {
                            case EMatch(PVar(varName), rhs):
                                // Track struct variable assignments from known constructors
                                switch(rhs.def) {
                                    case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
                                        structVarTracking.set(varName, varName);
                                    case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
                                        structVarTracking.set(varName, varName);
                                    default:
                                }
                                
                                // Check if this is a field assignment pattern
                                // Look ahead for the next expression to see if it's a field assignment
                                if (i + 1 < expressions.length) {
                                    var nextExpr = expressions[i + 1];
                                    switch(nextExpr.def) {
                                        case EMatch(PVar(fieldName), fieldValue):
                                            // Check if previous expression was a struct assignment we're tracking
                                            // and the field name matches common struct field patterns
                                            if (structVarTracking.exists(varName) && 
                                                (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || 
                                                 fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
                                                // This looks like a struct field assignment pattern
                                                // Transform: fieldName = value → spec = Map.put(spec, :fieldName, value)
                                                #if debug_ast_transformer
                                                trace('[XRay StructFieldAssignment] Found field assignment pattern: $fieldName = ...');
                                                trace('[XRay StructFieldAssignment] Transforming to Map.put($varName, :$fieldName, ...)');
                                                #end
                                                
                                                // Add the original struct assignment
                                                transformed.push(expr);
                                                
                                                // Transform the field assignment to Map.put
                                                var mapPut = makeAST(EMatch(
                                                    PVar(varName),
                                                    makeAST(ERemoteCall(
                                                        makeAST(EVar("Map")),
                                                        "put",
                                                        [
                                                            makeAST(EVar(varName)),
                                                            makeAST(EAtom(fieldName)),
                                                            fieldValue
                                                        ]
                                                    ))
                                                ));
                                                transformed.push(mapPut);
                                                
                                                // Skip the original field assignment
                                                i += 2;
                                                continue;
                                            }
                                        default:
                                    }
                                }
                                
                                // Not a field assignment pattern, keep as-is
                                transformed.push(expr);
                            default:
                                transformed.push(expr);
                        }
                        i++;
                    }
                    
                    // Return transformed block if we made changes
                    if (transformed.length > 0) {
                        return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    // Not a block, continue traversal
                    return node;
            }
        });
    }
    
    /**
     * Statement context transformation pass - add reassignments for immutable operations
     * 
     * WHY: Elixir is immutable, so operations like Map.put() return new values
     * WHAT: Detects when these operations are used as statements (value discarded)
     * HOW: Wraps them in reassignment to the original variable
     * 
     * Example transformation:
     * Map.put(params, "key", value) → params = Map.put(params, "key", value)
     */
    static function statementContextTransformPass(ast: ElixirAST): ElixirAST {
        // Transform with context tracking
        function transformWithContext(node: ElixirAST, isStatementContext: Bool): ElixirAST {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return node;
            }

            #if debug_ast_transformer
            trace('[XRay StatementContext] Processing node: ${node.def}, context: ${isStatementContext ? "statement" : "expression"}');
            #end

            // First, recursively transform children with appropriate context
            var transformed = switch(node.def) {
                case EDefmodule(name, doBlock):
                    // Process the module's do block in statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDefmodule: $name');
                    #end
                    makeASTWithMeta(
                        EDefmodule(name, transformWithContext(doBlock, true)),
                        node.metadata, node.pos
                    );
                    
                case EBlock(expressions):
                    // In a block, all but the last expression are in statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EBlock with ${expressions.length} expressions');
                    #end
                    var newExpressions = [];
                    for (i in 0...expressions.length) {
                        var isLast = (i == expressions.length - 1);
                        var childContext = isLast ? isStatementContext : true;
                        #if debug_ast_transformer
                        if (expressions[i] != null && expressions[i].def != null) {
                            var exprType = Type.enumConstructor(expressions[i].def);
                            trace('[XRay StatementContext] Block expr $i/${expressions.length}: $exprType, context: ${childContext ? "statement" : "expression"}');
                        }
                        #end
                        newExpressions.push(transformWithContext(expressions[i], childContext));
                    }
                    makeASTWithMeta(EBlock(newExpressions), node.metadata, node.pos);
                    
                case EDef(name, args, guards, body):
                    // Function body is a block - let it handle its own statement/expression context
                    // The block will mark all but the last expression as statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDef: $name, body type: ${body.def}');
                    #end
                    makeASTWithMeta(
                        EDef(name, args, guards, transformWithContext(body, false)),
                        node.metadata, node.pos
                    );
                    
                case EDefp(name, args, guards, body):
                    // Function body is a block - let it handle its own statement/expression context  
                    // The block will mark all but the last expression as statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDefp: $name, body type: ${body.def}');
                    #end
                    makeASTWithMeta(
                        EDefp(name, args, guards, transformWithContext(body, false)),
                        node.metadata, node.pos
                    );
                    
                case EIf(condition, thenBranch, elseBranch):
                    // Both branches inherit parent context
                    makeASTWithMeta(
                        EIf(transformWithContext(condition, false),
                            transformWithContext(thenBranch, isStatementContext),
                            elseBranch != null ? transformWithContext(elseBranch, isStatementContext) : null),
                        node.metadata, node.pos
                    );
                    
                case ECase(expr, clauses):
                    // All clauses inherit parent context
                    makeASTWithMeta(
                        ECase(transformWithContext(expr, false),
                              clauses.map(c -> {
                                  pattern: c.pattern,
                                  guard: c.guard != null ? transformWithContext(c.guard, false) : null,
                                  body: transformWithContext(c.body, isStatementContext)
                              })),
                        node.metadata, node.pos
                    );
                    
                // For other nodes, recursively transform children based on node type
                default:
                    // Manually handle child transformation for other node types
                    switch(node.def) {
                        case EModule(name, attributes, body):
                            makeASTWithMeta(
                                EModule(name, attributes, body.map(e -> transformWithContext(e, true))),
                                node.metadata, node.pos
                            );
                            
                        case ECall(target, funcName, args):
                            makeASTWithMeta(
                                ECall(target != null ? transformWithContext(target, false) : null,
                                      funcName,
                                      args.map(a -> transformWithContext(a, false))),
                                node.metadata, node.pos
                            );
                            
                        case ERemoteCall(module, funcName, args):
                            makeASTWithMeta(
                                ERemoteCall(transformWithContext(module, false),
                                           funcName,
                                           args.map(a -> transformWithContext(a, false))),
                                node.metadata, node.pos
                            );
                            
                        case EBinary(op, left, right):
                            makeASTWithMeta(
                                EBinary(op,
                                       transformWithContext(left, false),
                                       transformWithContext(right, false)),
                                node.metadata, node.pos
                            );
                            
                        case EMatch(pattern, expr):
                            makeASTWithMeta(
                                EMatch(pattern, transformWithContext(expr, false)),
                                node.metadata, node.pos
                            );
                            
                        // For literals and simple nodes, return unchanged
                        default:
                            node;
                    }
            };
            
            // Now check if this node needs reassignment wrapping
            if (isStatementContext) {
                switch(transformed.def) {
                    case ERemoteCall(module, funcName, args):
                        #if debug_ast_transformer
                        trace('[XRay StatementContext] Checking ERemoteCall: module=${module.def}, func=$funcName, args=${args.length}');
                        #end
                        // Check for immutable operations that need reassignment in statement context
                        var moduleName: Null<String> = switch(module.def) {
                            case EAtom(atom): atom; // ElixirAtom implicitly converts to String
                            case EVar(name): name;  // name is already String
                            default: null;
                        };
                        
                        if (moduleName != null) {
                            #if debug_ast_transformer
                            trace('[XRay StatementContext] Found module $moduleName, checking function: $funcName');
                            #end
                            
                            // Define immutable operations for each Elixir module
                            // TODO: Future improvement - Move this metadata to Haxe source files
                            // Instead of hardcoding here, each module (Map.hx, List.hx, etc.) could
                            // use metadata annotations like @:immutable or @:reassignsVar on methods
                            // that return new instances. This would make the system more maintainable
                            // and allow custom types to opt into this behavior.
                            // Example: @:immutable function put(key: K, value: V): Map<K,V> { ... }
                            var needsReassignment = switch(moduleName) {
                                case "Map":
                                    ["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;
                                case "List":
                                    ["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;
                                case "MapSet":
                                    ["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;
                                case "Keyword":
                                    ["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;
                                case "String":
                                    ["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;
                                default:
                                    false;
                            };
                            
                            if (needsReassignment && args.length >= 1) {
                                // First arg should be the variable being modified
                                switch(args[0].def) {
                                    case EVar(varName):
                                        #if debug_ast_transformer
                                        trace('[XRay StatementContext] Wrapping $moduleName.$funcName with reassignment to: $varName');
                                        #end
                                        // Transform to: varName = Module.operation(varName, ...)
                                        return makeASTWithMeta(
                                            EMatch(PVar(varName), transformed),
                                            node.metadata, node.pos
                                        );
                                    default:
                                        // Not a simple variable, can't reassign
                                }
                            }
                        }
                        
                    case EBinary(Concat, left, right):
                        // Check for list concatenation in statement context
                        switch(left.def) {
                            case EVar(varName):
                                #if debug_ast_transformer
                                trace('[XRay StatementContext] Wrapping ++ with reassignment to: $varName');
                                #end
                                // Transform to: varName = varName ++ right
                                return makeASTWithMeta(
                                    EMatch(PVar(varName), transformed),
                                    node.metadata, node.pos
                                );
                            default:
                        }
                        
                    default:
                }
            }
            
            return transformed;
        }
        
        // Start transformation with top-level as statement context
        return transformWithContext(ast, true);
    }
    
    /**
     * Immutability transformation pass - convert mutable patterns to immutable
     * 
     * ENHANCED: Now handles struct field mutations in BalancedTree and similar patterns
     */
    static function immutabilityTransformPass(ast: ElixirAST): ElixirAST {
        // First pass: Transform method bodies that mutate struct fields
        ast = transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                case EDef(name, args, guards, body) if ((name == "set" || name == "remove") && 
                                                        args.length > 0 && 
                                                        switch(args[0]) { case PVar("struct"): true; default: false; }):
                    // This is a struct method that might mutate fields
                    #if debug_ast_transformer
                    trace('[XRay ImmutabilityTransform] Found method $name with struct parameter');
                    #end
                    var updatedBody = transformStructFieldAssignments(body, args);
                    if (updatedBody != body) {
                        #if debug_ast_transformer
                        trace('[XRay ImmutabilityTransform] Transformed body for method $name');
                        #end
                        makeASTWithMeta(
                            EDef(name, args, guards, updatedBody),
                            node.metadata,
                            node.pos
                        );
                    } else {
                        #if debug_ast_transformer
                        trace('[XRay ImmutabilityTransform] No transformation needed for method $name');
                        #end
                        node;
                    }
                default:
                    node;
            }
        });
        
        // Second pass: Other immutability transformations
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Transform increment/decrement to reassignment
                case ECall(null, "pre_inc", [expr]):
                    // x++ becomes x = x + 1
                    switch(expr.def) {
                        case EVar(name):
                            makeAST(EMatch(
                                PVar(name),
                                makeAST(EBinary(Add, expr, makeAST(EInteger(1))))
                            ));
                        default:
                            node;
                    }
                    
                case ECall(null, "pre_dec", [expr]):
                    // x-- becomes x = x - 1
                    switch(expr.def) {
                        case EVar(name):
                            makeAST(EMatch(
                                PVar(name),
                                makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))
                            ));
                        default:
                            node;
                    }
                    
                // Transform modulo operator to rem function call
                case EBinary(Remainder, left, right):
                    // x % 2 becomes rem(x, 2) - rem is a function in Elixir, not an operator
                    makeAST(ECall(
                        null,
                        "rem",
                        [left, right]
                    ));
                    
                // Transform array mutation patterns
                case ECall(target, "push", [item]):
                    // Check if this is a push on a field (either direct or via struct)
                    switch(target.def) {
                        case EField(structVar, fieldName):
                            // This is struct.field.push(item) - qualified field access
                            // Check if structVar is "struct" (the conventional instance parameter)
                            switch(structVar.def) {
                                case EVar("struct"):
                                    // GUARD: Check if fieldName is an array infrastructure variable
                                    if (StructUpdateTransform.isArrayVariable(fieldName)) {
                                        #if debug_ast_transformer
                                        trace('[XRay ImmutabilityTransform] Skipping array variable field: struct.$fieldName');
                                        #end
                                        // Regular array concatenation
                                        makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                                    } else {
                                        // Transform to struct update: %{struct | field: struct.field ++ [item]}
                                        #if debug_ast_transformer
                                        trace('[XRay ImmutabilityTransform] Transforming struct.$fieldName.push(item) to struct update');
                                        #end
                                        makeAST(EStructUpdate(
                                            structVar,
                                            [{
                                                key: fieldName,
                                                value: makeAST(EBinary(
                                                    Concat,
                                                    target,  // struct.field
                                                    makeAST(EList([item]))
                                                ))
                                            }]
                                        ));
                                    }
                                default:
                                    node;
                            }
                        case EVar(fieldName):
                            // This is field.push(item) - direct field access
                            // This happens in instance methods where fields are accessed directly

                            // GUARD: Check if this is an array infrastructure variable
                            // Pattern: g, g2, _g, _g2, etc. - these are NOT struct fields
                            if (StructUpdateTransform.isArrayVariable(fieldName)) {
                                #if debug_ast_transformer
                                trace('[XRay ImmutabilityTransform] Skipping array variable: $fieldName');
                                #end
                                // Regular array concatenation, not struct update
                                makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                            } else {
                                // We need to transform this to a struct update
                                #if debug_ast_transformer
                                trace('[XRay ImmutabilityTransform] Transforming $fieldName.push(item) to struct update');
                                #end
                                // Create the struct variable (assuming "struct" is the instance parameter)
                                var structVar = makeAST(EVar("struct"));
                                makeAST(EStructUpdate(
                                    structVar,
                                    [{
                                        key: fieldName,
                                        value: makeAST(EBinary(
                                            Concat,
                                            makeAST(EField(structVar, fieldName)),  // struct.field
                                            makeAST(EList([item]))
                                        ))
                                    }]
                                ));
                            }
                        default:
                            // Regular array.push(item) becomes array ++ [item]
                            makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                    }

                case ECall(target, "pop", []):
                    // array.pop() becomes List.delete_at(array, -1)
                    makeAST(ERemoteCall(
                        makeAST(EAtom(ElixirAtom.raw("List"))),
                        "delete_at",
                        [target, makeAST(EInteger(-1))]
                    ));
                    
                    
                default:
                    node;
            }
        });
    }
    
    /**
     * Transform struct field assignments within a method body to return updated struct
     * 
     * WHY: Methods like BalancedTree.set() modify fields but need to return the updated struct
     * WHAT: Detects field assignments on "struct" parameter and adds struct return
     * HOW: Wraps body in block that returns updated struct
     */
    static function transformStructFieldAssignments(body: ElixirAST, args: Array<EPattern>): ElixirAST {
        // Check if first argument is "struct" (instance method pattern)
        var hasStructParam = args.length > 0 && switch(args[0]) {
            case PVar("struct"): true;
            default: false;
        };
        
        if (!hasStructParam) return body;
        
        #if debug_ast_transformer
        trace('[XRay transformStructFieldAssignments] Analyzing body for field assignments');
        #end
        
        // Look for field assignments in the body
        var hasFieldAssignment = false;
        var fieldUpdates: Map<String, ElixirAST> = new Map();
        
        // Analyze the body for field assignments
        function analyzeNode(node: ElixirAST): Void {
            switch(node.def) {
                case EMatch(PVar("root"), value):
                    // Found field assignment: root = ...
                    #if debug_ast_transformer
                    trace('[XRay transformStructFieldAssignments] Found root assignment');
                    #end
                    hasFieldAssignment = true;
                    fieldUpdates.set("root", value);
                case EBlock(statements):
                    for (stmt in statements) {
                        analyzeNode(stmt);
                    }
                default:
                    // Continue analyzing
            }
        }
        
        analyzeNode(body);
        
        #if debug_ast_transformer
        trace('[XRay transformStructFieldAssignments] hasFieldAssignment: $hasFieldAssignment, has root: ${fieldUpdates.exists("root")}');
        #end
        
        if (hasFieldAssignment && fieldUpdates.exists("root")) {
            // Transform the body to return updated struct
            var statements = [];
            
            // Add the original body logic
            switch(body.def) {
                case EBlock(stmts):
                    statements = stmts.copy();
                default:
                    statements = [body];
            }
            
            // Add struct update at the end
            // %{struct | root: root}
            var structUpdate = makeAST(EStructUpdate(
                makeAST(EVar("struct")),
                [{ key: "root", value: makeAST(EVar("root")) }]
            ));
            
            statements.push(structUpdate);
            
            return makeAST(EBlock(statements));
        }

        return body;
    }

    /**
     * Fluent API Optimization Pass
     *
     * WHY: Fluent API methods that return 'this' generate unnecessary intermediate assignments
     * in Elixir like `struct = %{struct | field: value}` followed by `struct`. This creates
     * "variable 'struct' is unused" warnings.
     *
     * WHAT: Detects and optimizes the pattern where a struct update is immediately returned.
     *
     * HOW: Transforms functions that have the pattern:
     * - Assignment: struct = %{struct | fields...}
     * - Return: struct
     * Into a single return of the struct update expression.
     */
    static function fluentApiOptimizationPass(ast: ElixirAST): ElixirAST {
        #if debug_fluent_api
        trace("[FluentApiOptimization] Starting optimization pass");
        #end

        return transformNode(ast, function(node) {
            switch(node.def) {
                case EDef(name, args, guards, body):
                    var optimizedBody = optimizeFluentBody(body);
                    if (optimizedBody != body) {
                        #if debug_fluent_api
                        trace('[FluentApiOptimization] Optimized function: $name');
                        #end
                        return makeAST(EDef(name, args, guards, optimizedBody));
                    }
                case EDefp(name, args, guards, body):
                    var optimizedBody = optimizeFluentBody(body);
                    if (optimizedBody != body) {
                        #if debug_fluent_api
                        trace('[FluentApiOptimization] Optimized private function: $name');
                        #end
                        return makeAST(EDefp(name, args, guards, optimizedBody));
                    }
                default:
            }
            return node;
        });
    }

    /**
     * Optimize the body of a fluent API method
     */
    static function optimizeFluentBody(body: ElixirAST): ElixirAST {
        if (body == null) return null;

        switch(body.def) {
            case EBlock(exprs) if (exprs.length == 2):
                // Check for pattern: [struct = %{struct | ...}, struct]
                var firstExpr = exprs[0];
                var secondExpr = exprs[1];

                // Check if first is assignment to 'struct'
                switch(firstExpr.def) {
                    case EMatch(PVar("struct"), updateExpr):
                        // Check if second is just returning 'struct'
                        switch(secondExpr.def) {
                            case EVar("struct"):
                                // Found the pattern! Return the update expression directly
                                #if debug_fluent_api
                                trace('[FluentApiOptimization] Found fluent pattern - optimizing');
                                #end
                                return updateExpr;
                            default:
                        }
                    default:
                }
            default:
        }

        // Pattern doesn't match, return as-is
        return body;
    }

    // ========================================================================
    // Helper Functions
    // ========================================================================
    
    /**
     * Extract parent module name from AST metadata
     * This should be set during the AST building phase when we know inheritance relationships
     * For now, we return null since metadata doesn't have a parentModule field yet
     * In the future, we should add this field to ElixirMetadata typedef
     */
    static function extractParentModule(node: ElixirAST): Null<String> {
        // TODO: Add parentModule field to ElixirMetadata typedef
        // For now, we can try to extract from sourceExpr if available
        if (node.metadata != null && node.metadata.sourceExpr != null) {
            // Could analyze the TypedExpr to find parent class info
            // For now, return null and use the fallback mechanism
        }
        return null;
    }
    
    /**
     * Array length field to function transformation pass
     * 
     * WHY: Elixir doesn't support .length property access on arrays/lists
     * WHAT: Transforms array.length field access to length(array) function calls
     * HOW: Detects EField(target, "length") and converts to ECall(null, "length", [target])
     * 
     * Example transformation:
     *   array.length -> length(array)
     *   list.length -> length(list) 
     */
    static function arrayLengthFieldToFunctionPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay ArrayLengthField] Starting array length field to function transformation');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case EField(target, "length"):
                // This is an array.length field access that needs to become length(array)
                #if debug_ast_transformer
                var targetStr = ElixirASTPrinter.printAST(target);
                trace('[XRay ArrayLengthField] Transforming ${targetStr}.length to length($targetStr)');
                #end
                {
                    def: ECall(null, "length", [
                        transformAST(target, arrayLengthFieldToFunctionPass)
                    ]),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            case ECall(expr, funcName, args):
                // Regular call, transform recursively
                {
                    def: ECall(
                        expr != null ? transformAST(expr, arrayLengthFieldToFunctionPass) : null,
                        funcName,
                        [for (arg in args) transformAST(arg, arrayLengthFieldToFunctionPass)]
                    ),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            default:
                // Recursively transform children
                transformAST(ast, arrayLengthFieldToFunctionPass);
        };
    }
    
    /**
     * Convert camelCase to snake_case for Elixir method names
     */
    static function toSnakeCase(name: String): String {
        var result = "";
        for (i in 0...name.length) {
            var char = name.charAt(i);
            if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
                result += "_";
            }
            result += char.toLowerCase();
        }
        return result;
    }
    
    /**
     * Recursively transform AST nodes with infinite recursion protection
     *
     * ## CRITICAL FIX: Infinite Recursion in Transformer (January 2025)
     *
     * ### The Problem
     * The transformer was entering infinite recursion, causing compilation hangs
     * lasting over 2 minutes. This occurred when certain nodes (especially atoms)
     * were being endlessly re-transformed.
     *
     * ### Root Cause
     * The original implementation always created new AST nodes, even when no
     * transformation occurred. This caused:
     * 1. Transformer applies to a node, returns a "new" node (same content, new object)
     * 2. Parent sees the node changed (different object reference)
     * 3. Parent re-transforms the "changed" node
     * 4. Infinite loop as nodes appear to always change
     *
     * ### The Solution: Structural Sharing Pattern
     * Only create new AST nodes when the content actually changes:
     * - If no children change, return the SAME object (not a copy)
     * - If any child changes, create a new parent with updated children
     * - Use physical equality (same object) to detect changes
     *
     * ### Special Handling for Terminal Nodes
     * Some nodes (like atoms) are terminal and should never recurse:
     * - EAtom: Always terminal, no children to transform
     * - EInteger, EFloat, EString: Terminal literal values
     * - These return immediately without recursion
     *
     * ### Implementation Details
     * - transformArray(): Helper that only copies arrays when elements change
     * - Physical equality check: `transformed != original` (object identity)
     * - Terminal node early returns prevent unnecessary recursion
     *
     * ### Impact
     * - Compilation time: 2+ minutes → ~10 seconds
     * - Memory usage: Significantly reduced due to structural sharing
     * - Correctness: Transformations still apply correctly
     *
     * @see https://github.com/reflaxe/reflaxe.haxe.elixir/commits/transformer-recursion-fix
     */
    // Track visited nodes to detect cycles (for debugging)
    private static var visitedNodes: Map<String, Int> = new Map();
    private static var nodeVisitCounter: Int = 0;
    // Large budget so normal multi-pass pipelines don't false-positive.
    private static var maxNodeVisits: Int = 500000;
    #if hxx_ast_progress
    private static var transformInvocationCounter: Int = 0;
    #end
    #if debug_transformer_hang
    private static var currentPassName: String = "";
    #end

    // Helper to transform an array only if elements change
    private static function transformArray(arr: Array<ElixirAST>, transformer: (ElixirAST) -> ElixirAST): {array: Array<ElixirAST>, changed: Bool} {
        var changed = false;
        var result = arr;

        for (i in 0...arr.length) {
            var original = arr[i];
            var transformed = transformNode(original, transformer);
            if (transformed != original) {
                if (!changed) {
                    // First change - copy the array
                    result = arr.copy();
                    changed = true;
                }
                result[i] = transformed;
            }
        }

        return {array: result, changed: changed};
    }

    /**
     * transformNode
     *
     * WHAT
     * - Recursively traverses and rebuilds the Elixir AST while applying a node-local transformer.
     * - Includes full recursion into EDo (do/end) bodies to ensure inner statements participate in passes.
     *
     * WHY
     * - Several shape-based passes (e.g., filter query consolidation) must operate on statements
     *   placed inside if/with/do blocks. Missing recursion into EDo caused late guards to miss
     *   legitimate targets, producing undefined variable issues.
     *
     * HOW
     * - Mirrors EBlock recursion for EDo: transforms each expression, then rebuilds the enclosing node.
     * - All other nodes retain prior recursion semantics; ERaw remains non-transformable by design.
     *
     * EXAMPLES
     * Before (no EDo recursion):
     *   if cond do
     *     Enum.filter(list, fn t -> uses_query end)
     *   end
     *   # Passes did not see the inner filter call.
     *
     * After (with EDo recursion):
     *   Same input; passes visit and may promote/bind/inline query deterministically.
     */
    public static function transformNode(ast: ElixirAST, transformer: (ElixirAST) -> ElixirAST): ElixirAST {
        // Handle null AST nodes or nodes with null def
        if (ast == null || ast.def == null) {
            return ast;  // Return as-is if null
        }

        #if debug_transformer_hang
        nodeVisitCounter++;

        // Create a unique identifier for this node
        var nodeId = Type.enumConstructor(ast.def) + "_" + Std.string(ast.pos);

        // Track visit frequency
        var visits = visitedNodes.get(nodeId);
        if (visits == null) visits = 0;
        visits++;
        visitedNodes.set(nodeId, visits);

        // Log breadcrumbs
        if (nodeVisitCounter % 1000 == 0) {
            trace('[TRANSFORMER BREADCRUMB] Node ${nodeVisitCounter}: ${Type.enumConstructor(ast.def)}');
        }

        // Detect excessive visits to same node (cycle)
        if (visits > 1000) {
            trace('[CYCLE DETECTED] Node ${nodeId} visited ${visits} times!');
            trace('[CYCLE DETECTED] AST def: ${ast.def}');
            #if debug_transformer_hang
            trace('[CYCLE DETECTED] Current pass: ' + currentPassName);
            #end
            throw 'Infinite recursion detected in transformer: ${nodeId}';
        }

        // Overall safety limit
        if (nodeVisitCounter > maxNodeVisits) {
            trace('[TRANSFORMER HANG] Exceeded ${maxNodeVisits} node visits');
            trace('[TRANSFORMER HANG] Last node: ${Type.enumConstructor(ast.def)}');
            throw 'Transformer exceeded maximum node visit limit';
        }
        #end

        // First transform children
        var transformed = switch(ast.def) {
            case EModule(name, attributes, body):
                var bodyResult = transformArray(body, transformer);
                if (bodyResult.changed) {
                    makeASTWithMeta(
                        EModule(name, attributes, bodyResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;  // Return original if nothing changed
                }
                
            case EDef(name, args, guards, body):
                makeASTWithMeta(
                    EDef(name, args, 
                         guards != null ? transformNode(guards, transformer) : null,
                         transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case EDefp(name, args, guards, body):
                makeASTWithMeta(
                    EDefp(name, args,
                          guards != null ? transformNode(guards, transformer) : null,
                          transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            // Blocks
            case EBlock(expressions):
                var expResult = transformArray(expressions, transformer);
                if (expResult.changed) {
                    makeASTWithMeta(
                        EBlock(expResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;  // Return original if nothing changed
                }

            // Transform do-end blocks by visiting each expression
            case EDo(body):
                var doResult = transformArray(body, transformer);
                if (doResult.changed) {
                    makeASTWithMeta(
                        EDo(doResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;
                }
                
            case EIf(condition, thenBranch, elseBranch):
                makeASTWithMeta(
                    EIf(transformNode(condition, transformer),
                        transformNode(thenBranch, transformer),
                        elseBranch != null ? transformNode(elseBranch, transformer) : null),
                    ast.metadata,
                    ast.pos
                );
                
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(transformNode(expr, transformer),
                          clauses.map(c -> {
                              pattern: c.pattern,
                              guard: c.guard != null ? transformNode(c.guard, transformer) : null,
                              body: transformNode(c.body, transformer)
                          })),
                    ast.metadata,
                    ast.pos
                );
            
            // Traverse anonymous functions and clause bodies
            case EFn(clauses):
                makeASTWithMeta(
                    EFn(clauses.map(cl -> {
                        args: cl.args,
                        guard: cl.guard != null ? transformNode(cl.guard, transformer) : null,
                        body: transformNode(cl.body, transformer)
                    })),
                    ast.metadata,
                    ast.pos
                );
                
            case EBinary(op, left, right):
                makeASTWithMeta(
                    EBinary(op,
                            transformNode(left, transformer),
                            transformNode(right, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case EUnary(op, expr):
                makeASTWithMeta(
                    EUnary(op, transformNode(expr, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case ECall(target, funcName, args):
                makeASTWithMeta(
                    ECall(target != null ? transformNode(target, transformer) : null,
                          funcName,
                          args.map(a -> transformNode(a, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case EList(elements):
                makeASTWithMeta(
                    EList(elements.map(e -> transformNode(e, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case ETuple(elements):
                makeASTWithMeta(
                    ETuple(elements.map(e -> transformNode(e, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case EMap(pairs):
                makeASTWithMeta(
                    EMap(pairs.map(p -> {
                        key: transformNode(p.key, transformer),
                        value: transformNode(p.value, transformer)
                    })),
                    ast.metadata,
                    ast.pos
                );

            case EMatch(pattern, expr):
                // CRITICAL FIX: Transform the RHS expression
                // WHY: EMatch bindings in HygieneTransforms mark LHS as declaration
                //      but RHS may reference variables that need renaming
                // WHAT: Recursively transform expr to rename any EVar nodes
                // HOW: Pattern stays unchanged (creates new binding), expr transforms
                makeASTWithMeta(
                    EMatch(pattern, transformNode(expr, transformer)),
                    ast.metadata,
                    ast.pos
                );

            case EFor(generators, filters, body, into, uniq):
                makeASTWithMeta(
                    EFor(generators.map(g -> {
                        pattern: g.pattern,
                        expr: transformNode(g.expr, transformer)
                    }),
                         filters.map(f -> transformNode(f, transformer)),
                         transformNode(body, transformer),
                         into != null ? transformNode(into, transformer) : null,
                         uniq),
                    ast.metadata,
                    ast.pos
                );
                
            // Raw Elixir code injection - NEVER transform
            case ERaw(code):
                // ERaw nodes are sacred - they contain direct Elixir code injection
                // from __elixir__() calls and must NEVER be transformed
                // Just return the node as-is, without calling the transformer
                return ast;
                
            case EDefmodule(name, body):
                // Transform the module body recursively
                makeASTWithMeta(
                    EDefmodule(name, transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            // Literals and simple nodes - no children to transform
            // These have no children, so just return them as-is for the transformer to process
            default:
                ast;
        };

        // Apply the transformation to this node
        var finalResult = transformer(transformed);

        // CRITICAL FIX: Prevent infinite recursion
        // Special handling for atoms which were causing infinite loops
        switch(finalResult.def) {
            case EAtom(_):
                // Atoms are terminal nodes and should never be recursively transformed
                // Just return them immediately to break any potential loops
                return finalResult;
            default:
                // For other nodes, check if the transformation actually changed anything
                // Use standard equality check
                if (finalResult == transformed) {
                    // If the same object was returned, no transformation occurred
                    return finalResult;
                }

                // Otherwise return the transformed result
                return finalResult;
        }
    }
    
    /**
     * Detect and optimize pipeline patterns in a block
     */
    static function detectAndOptimizePipeline(expressions: Array<ElixirAST>): Null<ElixirAST> {
        // Look for patterns like:
        // x = f(x, ...)
        // x = g(x, ...)
        // x = h(x, ...)
        // Also handles remote calls like:
        // x = Module.f(x, ...)
        // x = Module.g(x, ...)
        
        if (expressions.length < 2) return null;
        
        var pipelineOps = [];
        var baseVar: String = null;
        var lastExpr: ElixirAST = null;
        
        for (expr in expressions) {
            switch(expr.def) {
                case EMatch(PVar(name), call):
                    switch(call.def) {
                        case ECall(target, func, args):
                            if (args.length > 0) {
                                switch(args[0].def) {
                                    case EVar(argName) if (argName == name):
                                        // Found a pipeline candidate
                                        if (baseVar == null) {
                                            baseVar = name;
                                        }
                                        if (baseVar == name) {
                                            pipelineOps.push({
                                                func: func,
                                                args: args.slice(1),
                                                target: target
                                            });
                                            lastExpr = expr;
                                            continue;
                                        }
                                    default:
                                }
                            }
                        case ERemoteCall(module, func, args):
                            // Handle remote calls like EctoQuery_Impl_.where(query, ...)
                            if (args.length > 0) {
                                switch(args[0].def) {
                                    case EVar(argName) if (argName == name):
                                        // Found a pipeline candidate for remote call
                                        if (baseVar == null) {
                                            baseVar = name;
                                        }
                                        if (baseVar == name) {
                                            pipelineOps.push({
                                                func: func,
                                                args: args.slice(1),
                                                target: module  // Use module as target
                                            });
                                            lastExpr = expr;
                                            continue;
                                        }
                                    default:
                                }
                            }
                        default:
                    }
                default:
            }
            
            // Pattern broken, check if we have enough for a pipeline
            if (pipelineOps.length >= 2) {
                break;
            } else {
                // Reset and continue looking
                pipelineOps = [];
                baseVar = null;
            }
        }
        
        // Create pipeline if we found a pattern
        if (pipelineOps.length >= 2) {
            var pipeline = makeAST(EVar(baseVar));
            
            for (op in pipelineOps) {
                if (op.target != null) {
                    pipeline = makeAST(EPipe(
                        pipeline,
                        makeAST(ERemoteCall(op.target, op.func, op.args))
                    ));
                } else {
                    pipeline = makeAST(EPipe(
                        pipeline,
                        makeAST(ECall(null, op.func, op.args))
                    ));
                }
            }
            
            // Create final assignment
            return makeAST(EMatch(PVar(baseVar), pipeline));
        }
        
        return null;
    }
    
    /**
     * Conditional reassignment transformation pass
     * 
     * WHY: Elixir warns when variables are reassigned (shadowing)
     * WHAT: Transform conditional reassignments to functional style
     * HOW: Make if blocks return the new value instead of reassigning
     * 
     * Example transformation:
     * ```
     * if (condition) {
     *   query = query.where(...);
     * }
     * ```
     * Becomes:
     * ```
     * query = if (condition) do
     *   query.where(...)
     * else
     *   query
     * end
     * ```
     */
    
    static function conditionalReassignmentPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EBlock(expressions):
                    // Transform each if statement in the block
                    var transformed = [];
                    for (expr in expressions) {
                        if (expr == null || expr.def == null) {
                            continue;
                        }
                        switch(expr.def) {
                            case EIf(cond, thenBranch, null):  // If without else
                                // Check if the then branch is a single reassignment
                                switch(thenBranch.def) {
                                    case EMatch(PVar(varName), value):
                                        // Check if this is reassigning to an existing variable
                                        // by looking if the value references the same variable
                                        if (referencesVariable(value, varName)) {
                                            // Transform to functional style: var = if cond do new_value else var end
                                            var newIf = makeAST(EIf(
                                                cond,
                                                value,  // Return the new value
                                                makeAST(EVar(varName))  // Return original variable
                                            ));
                                            transformed.push(makeAST(EMatch(PVar(varName), newIf)));
                                        } else {
                                            transformed.push(expr);
                                        }
                                    default:
                                        transformed.push(expr);
                                }
                            default:
                                transformed.push(expr);
                        }
                    }
                    return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Check if an AST node references a specific variable
     */
    static function referencesVariable(ast: ElixirAST, varName: String): Bool {
        var found = false;
        
        function visitor(node: ElixirAST): Void {
            if (found) return;
            
            switch(node.def) {
                case EVar(name) if (name == varName):
                    found = true;
                case ERemoteCall(_, _, args):
                    // Check if first argument is the variable
                    if (args.length > 0) {
                        switch(args[0].def) {
                            case EVar(name) if (name == varName):
                                found = true;
                            default:
                                for (arg in args) {
                                    visitor(arg);
                                }
                        }
                    }
                default:
                    // Recursively visit child nodes
                    transformAST(node, function(n) { 
                        visitor(n); 
                        return n; 
                    });
            }
        }
        
        visitor(ast);
        return found;
    }
    
    /**
     * Remove redundant nil initialization pass
     * 
     * WHY: Abstract type constructors generate redundant `var = nil` followed by `var = value`
     * WHAT: Removes nil initialization when variable is immediately reassigned  
     * HOW: Detects pattern of consecutive assignments to same variable and removes first
     * 
     * Pattern detected:
     * ```elixir
     * this1 = nil
     * this1 = %{data: data, params: params}
     * ```
     * 
     * Transformed to:
     * ```elixir
     * this1 = %{data: data, params: params}
     * ```
     */
    static function removeRedundantNilInitPass(ast: ElixirAST): ElixirAST {
        // Helper function to check if an AST node represents nil
        // In Elixir, nil is represented as the atom :nil
        inline function isNilValue(ast: ElixirAST): Bool {
            if (ast == null) return false;
            return switch(ast.def) {
                case EAtom(a): a == "nil";
                case ENil: true; // Legacy support, though this shouldn't occur
                default: false;
            };
        }

        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDef(name, args, guards, body) if (name == "_new"):
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing _new function');
                    #end
                    // Special handling for abstract constructor _new functions
                    var transformedBody = switch(body.def) {
                        case EBlock(expressions) if (expressions.length >= 2):
                            // Look for pattern: this1 = nil; this1 = <value>; this1
                            var filteredExprs = [];
                            var i = 0;
                            while (i < expressions.length) {
                                var expr = expressions[i];
                                var shouldSkip = false;
                                
                                // Check for this1 = nil
                                switch(expr.def) {
                                    case EMatch(PVar("this1"), nilValue):
                                        if (isNilValue(nilValue)) {
                                            // Check next expression
                                            if (i + 1 < expressions.length) {
                                                switch(expressions[i + 1].def) {
                                                    case EMatch(PVar("this1"), value):
                                                        if (isNilValue(value)) {
                                                            // Don't skip if reassigning to nil
                                                        } else {
                                                            // Skip the nil assignment
                                                                    #if debug_ast_transformer
                                                                    trace('[XRay RemoveRedundantNilInit] Removing this1 = nil in _new function');
                                                                    #end
                                                                    shouldSkip = true;
                                                    }
                                                default:
                                            }
                                        }
                                    }
                                    default:
                                }
                                
                                if (!shouldSkip) {
                                    filteredExprs.push(expr);
                                }
                                i++;
                            }
                            
                            if (filteredExprs.length != expressions.length) {
                                makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
                            } else {
                                body;
                            }
                        default:
                            body;
                    };
                    
                    return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EBlock(expressions):
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EBlock with ${expressions.length} expressions');
                    #end
                    var filtered = [];
                    var nilAssignments = new Map<String, Int>(); // Track nil assignments by variable name
                    var i = 0;
                    
                    // First pass: identify all nil assignments
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        // Null safety check
                        if (expr == null || expr.def == null) {
                            i++;
                            continue;
                        }
                        switch(expr.def) {
                            case EMatch(PVar(varName), nilValue):
                                if (isNilValue(nilValue)) {
                                    #if debug_ast_transformer
                                    trace('[XRay RemoveRedundantNilInit] Found nil assignment for var: $varName at index $i');
                                    #end
                                    nilAssignments.set(varName, i);
                                }
                            default:
                        }
                        i++;
                    }
                    
                    // Second pass: filter out redundant nil assignments and useless variable references
                    i = 0;
                    var varsToClean = new Map<String, Bool>(); // Track variables that need their standalone refs removed
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        // Null safety check
                        if (expr == null || expr.def == null) {
                            i++;
                            continue;
                        }
                        
                        // Check if this is a useless standalone variable reference
                        switch(expr.def) {
                            case EVar(v) if (varsToClean.exists(v)):
                                // This is a standalone variable reference after an assignment, skip it
                                #if debug_ast_transformer
                                trace('[XRay RemoveRedundantNilInit] Removing standalone variable reference: $v');
                                #end
                                varsToClean.remove(v);
                                i++;
                                continue;
                            default:
                        }
                        
                        var shouldSkip = false;

                        // Check if this is a nil assignment that should be removed
                        switch(expr.def) {
                            case EMatch(PVar(varName), nilValue):
                                if (isNilValue(nilValue)) {
                                    // Special handling for 'this1' and similar abstract constructor variables
                                    // These are ALWAYS immediately reassigned in abstract constructors
                                    if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
                                        #if debug_ast_transformer
                                        trace('[XRay RemoveRedundantNilInit] Found "this1" nil assignment at index $i');
                                        #end
                                        // Check immediate next expression for reassignment
                                        if (i + 1 < expressions.length) {
                                            var nextExpr = expressions[i + 1];
                                            if (nextExpr != null && nextExpr.def != null) {
                                                #if debug_ast_transformer
                                                trace('[XRay RemoveRedundantNilInit] Next expr at ${i+1}: ${nextExpr.def}');
                                                #end
                                                switch(nextExpr.def) {
                                                case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
                                                    if (isNilValue(value)) {
                                                        // Don't skip if it's another nil
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] Next assignment is also nil, not skipping');
                                                        #end
                                                    } else {
                                                        // Non-nil reassignment - skip the initial nil AND check if there's a useless variable reference after
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] REMOVING redundant nil init for abstract constructor var: $varName');
                                                        #end
                                                        shouldSkip = true;
                                                        
                                                        // CRITICAL FIX: Also check if next+1 is just a variable reference
                                                        // Pattern: this1 = nil; this1 = value; this1
                                                        if (i + 2 < expressions.length) {
                                                            var afterNext = expressions[i + 2];
                                                            if (afterNext != null && afterNext.def != null) {
                                                                switch(afterNext.def) {
                                                                    case EVar(v) if (v == varName):
                                                                        // This is the standalone variable reference that causes the warning
                                                                        #if debug_ast_transformer
                                                                        trace('[XRay RemoveRedundantNilInit] Found standalone variable reference after assignment, marking for removal');
                                                                        #end
                                                                        // Mark this variable for cleanup
                                                                        varsToClean.set(varName, true);
                                                                    default:
                                                                }
                                                            }
                                                        }
                                                    }
                                                    default:
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] Next expr is not a match for $varName');
                                                        #end
                                                }
                                            }
                                        }

                                        // If not skipped yet, check if this variable is assigned again later
                                        if (!shouldSkip) {
                                            var j = i + 1;
                                            while (j < expressions.length) {
                                                var checkExpr = expressions[j];
                                                if (checkExpr == null || checkExpr.def == null) {
                                                    j++;
                                                    continue;
                                                }
                                                switch(checkExpr.def) {
                                                    case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
                                                        // Found reassignment - check if the value is not nil
                                                        if (isNilValue(value)) {
                                                            // Another nil assignment, keep looking
                                                        } else {
                                                            // Non-nil reassignment found - skip the initial nil
                                                                #if debug_ast_transformer
                                                                trace('[XRay RemoveRedundantNilInit] Removing redundant nil init for: $varName (reassigned at index $j)');
                                                                #end
                                                                shouldSkip = true;
                                                                break;
                                                        }
                                                    default:
                                                }
                                                j++;
                                            }
                                        }
                                    }
                                }
                            default:
                                // Not a match expression
                        }

                        if (!shouldSkip) {
                            // Recursively process the expression to handle nested structures
                            var processed = removeRedundantNilInitPass(expr);
                            filtered.push(processed);
                        } else {
                            #if debug_ast_transformer
                            trace('[XRay RemoveRedundantNilInit] Skipping redundant nil init at index $i');
                            #end
                        }
                        i++;
                    }

                    // Only create new block if we removed something
                    if (filtered.length != expressions.length) {
                        #if debug_ast_transformer
                        trace('[XRay RemoveRedundantNilInit] Removed ${expressions.length - filtered.length} redundant nil assignments from block');
                        #end
                        return makeASTWithMeta(EBlock(filtered), node.metadata, node.pos);
                    } else {
                        return node;
                    }
                    
                case EFn(clauses):
                    // Also handle anonymous function bodies
                    var transformedClauses = [for (clause in clauses) {
                        args: clause.args,
                        guard: clause.guard,
                        body: removeRedundantNilInitPass(clause.body)
                    }];
                    return makeASTWithMeta(EFn(transformedClauses), node.metadata, node.pos);
                    
                case EDef(name, args, guards, body):
                    // Handle public function definitions
                    var transformedBody = removeRedundantNilInitPass(body);
                    return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EDefp(name, args, guards, body):
                    // Handle private function definitions
                    var transformedBody = removeRedundantNilInitPass(body);
                    return makeASTWithMeta(EDefp(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EIf(cond, thenBranch, elseBranch):
                    // Recursively process if branches
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EIf - recursing into branches');
                    #end
                    var processedCond = removeRedundantNilInitPass(cond);
                    var processedThen = removeRedundantNilInitPass(thenBranch);
                    var processedElse = elseBranch != null ? removeRedundantNilInitPass(elseBranch) : null;
                    return makeASTWithMeta(EIf(processedCond, processedThen, processedElse), node.metadata, node.pos);

                case ECase(expr, clauses):
                    // Recursively process case expressions
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing ECase');
                    #end
                    var processedExpr = removeRedundantNilInitPass(expr);
                    var processedClauses = [for (clause in clauses) {
                        pattern: clause.pattern,
                        guard: clause.guard != null ? removeRedundantNilInitPass(clause.guard) : null,
                        body: removeRedundantNilInitPass(clause.body)
                    }];
                    return makeASTWithMeta(ECase(processedExpr, processedClauses), node.metadata, node.pos);

                case EFor(generators, filters, body, into, uniq):
                    // Recursively process for comprehensions
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EFor');
                    #end
                    var processedGenerators = [for (gen in generators) {
                        pattern: gen.pattern,
                        expr: removeRedundantNilInitPass(gen.expr)
                    }];
                    var processedFilters = [for (filter in filters) removeRedundantNilInitPass(filter)];
                    var processedBody = removeRedundantNilInitPass(body);
                    var processedInto = into != null ? removeRedundantNilInitPass(into) : null;
                    return makeASTWithMeta(EFor(processedGenerators, processedFilters, processedBody, processedInto, uniq), node.metadata, node.pos);

                case EParen(inner):
                    // Handle parenthesized expressions (often contains this1 = nil pattern)
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EParen');
                    #end

                    // Check if the inner expression is a sequence with redundant nil init
                    var transformedInner = switch(inner.def) {
                        case EBlock(expressions) if (expressions.length == 3):
                            // Pattern: (this1 = nil; this1 = value; this1)
                            var hasRedundantNil = false;

                            // Check for this1 = nil as first expression
                            switch(expressions[0].def) {
                                case EMatch(PVar("this1"), nilValue):
                                    if (isNilValue(nilValue)) {
                                        // Check second expression is also assignment to this1
                                        switch(expressions[1].def) {
                                            case EMatch(PVar("this1"), _):
                                                // Check third expression is just this1
                                                switch(expressions[2].def) {
                                                    case EVar("this1"):
                                                        hasRedundantNil = true;
                                                    default:
                                                }
                                            default:
                                        }
                                    }
                                default:
                            }

                            if (hasRedundantNil) {
                                #if debug_ast_transformer
                                trace('[XRay RemoveRedundantNilInit] Removing redundant nil from EParen block');
                                #end
                                // Remove the first expression (this1 = nil)
                                makeASTWithMeta(
                                    EBlock([expressions[1], expressions[2]]),
                                    inner.metadata,
                                    inner.pos
                                );
                            } else {
                                // Recursively process the block
                                removeRedundantNilInitPass(inner);
                            }
                        default:
                            // For other patterns, process recursively
                            removeRedundantNilInitPass(inner);
                    };

                    return makeASTWithMeta(EParen(transformedInner), node.metadata, node.pos);

                default:
                    return node;
            }
        });
    }
    
    /**
     * PREFIX UNUSED PARAMETERS PASS
     * 
     * WHY: Elixir convention requires unused function parameters to be prefixed with underscore
     *      to indicate they're intentionally unused. This prevents compiler warnings.
     * 
     * WHAT: Detects unused parameters in function definitions and prefixes them with underscore.
     *       Handles EDef, EDefp, EDefmacro, EDefmacrop, and EFn (anonymous functions).
     * 
     * HOW: 1. For each function definition, collect all parameter names
     *      2. Scan the function body to find which parameters are actually used
     *      3. Prefix unused parameters with underscore
     *      4. Update all references to maintain consistency
     * 
     * EDGE CASES:
     * - Parameters already prefixed with underscore are left as-is
     * - Parameters named "_" are not modified
     * - Nested functions are handled recursively
     */
    static function prefixUnusedParametersPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay PrefixUnusedParams] PASS START');
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                // Handle regular function definitions
                case EDef(name, args, guards, body):
                    #if debug_ast_transformer
                    trace('[XRay PrefixUnusedParams] Found EDef: $name with ${args.length} args');
                    #end
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDef: $name');
                        #end
                        return makeASTWithMeta(EDef(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefp(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefp: $name');
                        #end
                        return makeASTWithMeta(EDefp(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefmacro(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefmacro: $name');
                        #end
                        return makeASTWithMeta(EDefmacro(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefmacrop(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefmacrop: $name');
                        #end
                        return makeASTWithMeta(EDefmacrop(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                // Handle anonymous functions
                case EFn(clauses):
                    var hasAnyChange = false;
                    var newClauses = [];
                    
                    for (clause in clauses) {
                        var result = handleFunctionParameters(clause.args, clause.guard, clause.body);
                        if (result.hasChanges) {
                            hasAnyChange = true;
                            newClauses.push({
                                args: result.args,
                                guard: clause.guard,
                                body: result.body
                            });
                        } else {
                            newClauses.push(clause);
                        }
                    }
                    
                    if (hasAnyChange) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EFn with ${clauses.length} clauses');
                        #end
                        return makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Handle parameter detection and renaming for a function
     * Returns updated args and body if changes were made
     */
    static function handleFunctionParameters(args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST): {args: Array<EPattern>, body: ElixirAST, hasChanges: Bool} {
        // Extract parameter names from patterns
        var paramNames: Map<String, Bool> = new Map();
        var paramRenames: Map<String, String> = new Map();
        
        function extractParamNames(pattern: EPattern) {
            switch(pattern) {
                case PVar(name):
                    if (!name.startsWith("_")) { // Don't track already underscored params
                        paramNames.set(name, false); // false = not yet seen as used
                    }
                case PTuple(patterns):
                    for (p in patterns) extractParamNames(p);
                case PList(patterns):
                    for (p in patterns) extractParamNames(p);
                case PMap(pairs):
                    for (pair in pairs) extractParamNames(pair.value);
                case PCons(head, tail):
                    extractParamNames(head);
                    extractParamNames(tail);
                case PPin(pattern):
                    extractParamNames(pattern);
                default:
                    // Other patterns don't introduce variables
            }
        }
        
        for (arg in args) {
            extractParamNames(arg);
        }
        
        #if debug_ast_transformer
        trace('[XRay PrefixUnusedParams] Found parameters: ' + [for (name => _ in paramNames) name].join(", "));
        #end
        
        // If no parameters to check, return early
        if (Lambda.count(paramNames) == 0) {
            return {args: args, body: body, hasChanges: false};
        }
        
        // Check which parameters are used in the body (and guards if present)
        function markUsedVars(ast: ElixirAST) {
            switch(ast.def) {
                case EVar(name):
                    if (paramNames.exists(name)) {
                        paramNames.set(name, true); // Mark as used
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Found usage of param: $name');
                        #end
                    }
                case EField(target, _):
                    // Check if the target is a parameter being accessed
                    switch(target.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found field access on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(target); // Continue checking nested expressions
                    }
                case EAccess(target, key):
                    // Check if the target is a parameter being accessed
                    switch(target.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found bracket access on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(target); // Continue checking nested expressions
                    }
                    markUsedVars(key); // Also check the key expression
                case EStructUpdate(struct, fields):
                    // Check if struct being updated is a parameter
                    switch(struct.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found struct update on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(struct); // Continue checking nested expressions
                    }
                    // Also check the field values
                    for (field in fields) {
                        markUsedVars(field.value);
                    }
                case ERaw(code):
                    // Check if parameter names appear in raw Elixir code
                    // This handles __elixir__() injection where parameters are referenced
                    for (name => _ in paramNames) {
                        // Check if the parameter name appears as a word boundary in the raw code
                        // This handles cases like "Ecto.Changeset.change(data, params)"
                        var pattern = '\\b${name}\\b';
                        if (new EReg(pattern, "").match(code)) {
                            paramNames.set(name, true); // Mark as used
                            #if debug_ast_transformer
                            trace('[XRay PrefixUnusedParams] Found param usage in ERaw: $name in code: ${code.substring(0, 100)}...');
                            #end
                        }
                    }
                case EKeywordList(pairs):
                    // Check values in keyword list for parameter usage
                    for (pair in pairs) {
                        markUsedVars(pair.value);
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Checking keyword list value for parameter usage');
                        #end
                    }
                default:
                    iterateAST(ast, markUsedVars);
            }
        }
        
        // Check guards for parameter usage
        if (guards != null) {
            markUsedVars(guards);
        }
        
        // Check body for parameter usage
        markUsedVars(body);
        
        // M0 STABILIZATION: Disable underscore prefixing temporarily
        var hasChanges = false;
        /* Disabled to prevent variable mismatches
        for (name => used in paramNames) {
            if (!used && !name.startsWith("_")) {
                var newName = "_" + name;
                paramRenames.set(name, newName);
                hasChanges = true;
                #if debug_ast_transformer
                trace('[XRay PrefixUnusedParams] Will rename unused param: $name -> $newName');
                #end
            }
        }
        */
        
        // If no changes needed, return original
        if (!hasChanges) {
            return {args: args, body: body, hasChanges: false};
        }
        
        // Apply renames to argument patterns
        function renameInPattern(pattern: EPattern): EPattern {
            switch(pattern) {
                case PVar(name):
                    if (paramRenames.exists(name)) {
                        return PVar(paramRenames.get(name));
                    }
                    return pattern;
                case PTuple(patterns):
                    return PTuple(patterns.map(renameInPattern));
                case PList(patterns):
                    return PList(patterns.map(renameInPattern));
                case PMap(pairs):
                    return PMap([for (pair in pairs) {key: pair.key, value: renameInPattern(pair.value)}]);
                case PCons(head, tail):
                    return PCons(renameInPattern(head), renameInPattern(tail));
                case PPin(p):
                    return PPin(renameInPattern(p));
                default:
                    return pattern;
            }
        }
        
        var newArgs = args.map(renameInPattern);
        
        // Apply renames to the body as well to handle cases where usage detection
        // might be incomplete (e.g., field access patterns that weren't detected)
        function renameInAST(ast: ElixirAST): ElixirAST {
            switch(ast.def) {
                case EVar(name):
                    if (paramRenames.exists(name)) {
                        return {def: EVar(paramRenames.get(name)), metadata: ast.metadata};
                    }
                    return ast;
                default:
                    return transformAST(ast, renameInAST);
            }
        }
        
        var newBody = renameInAST(body);
        
        return {args: newArgs, body: newBody, hasChanges: true};
    }
    
    /**
     * Generate unique identifier for generated code
     */
    static var uniqueCounter = 0;
    static function generateUniqueId(): String {
        return Std.string(uniqueCounter++);
    }
    
    /**
     * Helper function to iterate over AST nodes without transformation
     */
    static function iterateAST(node: ElixirAST, visitor: ElixirAST -> Void): Void {
        // Check for null node or def before processing
        if (node == null || node.def == null) {
            return;
        }

        switch(node.def) {
            case EBlock(expressions):
                for (expr in expressions) if (expr != null) visitor(expr);
            case EModule(name, attributes, body):
                for (b in body) if (b != null) visitor(b);
            case EDefmodule(name, doBlock):
                if (doBlock != null) visitor(doBlock);
            case EDef(name, args, guards, body):
                if (body != null) visitor(body);
            case EDefp(name, args, guards, body):
                if (body != null) visitor(body);
            case EIf(condition, thenBranch, elseBranch):
                if (condition != null) visitor(condition);
                if (thenBranch != null) visitor(thenBranch);
                if (elseBranch != null) visitor(elseBranch);
            case ECase(expr, clauses):
                if (expr != null) visitor(expr);
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EMatch(pattern, expr):
                if (expr != null) visitor(expr);
            case EBinary(op, left, right):
                if (left != null) visitor(left);
                if (right != null) visitor(right);
            case EUnary(op, expr):
                if (expr != null) visitor(expr);
            case ECall(target, funcName, args):
                if (target != null) visitor(target);
                for (arg in args) if (arg != null) visitor(arg);
            case EMacroCall(macroName, args, doBlock):
                for (arg in args) if (arg != null) visitor(arg);
                if (doBlock != null) visitor(doBlock);
            case ETuple(elements):
                for (elem in elements) if (elem != null) visitor(elem);
            case EList(elements):
                for (elem in elements) if (elem != null) visitor(elem);
            case EMap(pairs):
                for (pair in pairs) {
                    if (pair != null) {
                        if (pair.key != null) visitor(pair.key);
                        if (pair.value != null) visitor(pair.value);
                    }
                }
            case EStruct(name, fields):
                for (field in fields) if (field != null && field.value != null) visitor(field.value);
            case EFor(generators, filters, body, into, uniq):
                for (gen in generators) {
                    if (gen != null && gen.expr != null) visitor(gen.expr);
                }
                for (filter in filters) if (filter != null) visitor(filter);
                if (body != null) visitor(body);
                if (into != null) visitor(into);
            case EFn(clauses):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EReceive(clauses, after):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
                if (after != null) {
                    if (after.timeout != null) visitor(after.timeout);
                    if (after.body != null) visitor(after.body);
                }
            case ERemoteCall(module, funcName, args):
                if (module != null) visitor(module);
                for (arg in args) if (arg != null) visitor(arg);
            case EParen(expr):
                if (expr != null) visitor(expr);
            case EDo(body):
                for (stmt in body) if (stmt != null) visitor(stmt);
            case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
                if (body != null) visitor(body);
                if (rescue != null) {
                    for (clause in rescue) {
                        // ERescueClause structure would need checking
                        if (clause != null && clause.body != null) visitor(clause.body);
                    }
                }
                if (catchClauses != null) {
                    for (clause in catchClauses) {
                        if (clause != null && clause.body != null) visitor(clause.body);
                    }
                }
                if (afterBlock != null) visitor(afterBlock);
                if (elseBlock != null) visitor(elseBlock);
            case EWith(clauses, doBlock, elseBlock):
                for (clause in clauses) {
                    // Pattern is not an ElixirAST, only visit the expression
                    if (clause != null && clause.expr != null) visitor(clause.expr);
                }
                if (doBlock != null) visitor(doBlock);
                if (elseBlock != null) visitor(elseBlock);
            case ECond(clauses):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.condition != null) visitor(clause.condition);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EField(object, field):
                if (object != null) visitor(object);
            case EModuleAttribute(name, value):
                if (value != null) visitor(value);
            case EKeywordList(pairs):
                // Visit values in keyword list
                for (pair in pairs) {
                    if (pair != null && pair.value != null) visitor(pair.value);
                }
            case _:
                // Leaf nodes - nothing to iterate
        }
    }
    
    /**
     * Helper function to transform AST nodes recursively
     */
    public static function transformAST(node: ElixirAST, transformer: ElixirAST -> ElixirAST): ElixirAST {
        if (node == null || node.def == null) {
            return null;
        }
        var transformed = switch(node.def) {
            case EBlock(expressions):
                makeASTWithMeta(EBlock(expressions.map(transformer)), node.metadata, node.pos);
            case EModule(name, attributes, body):
                makeASTWithMeta(EModule(name, attributes, body.map(transformer)), node.metadata, node.pos);
            case EDefmodule(name, doBlock):
                makeASTWithMeta(EDefmodule(name, transformer(doBlock)), node.metadata, node.pos);
            case EDef(name, args, guards, body):
                makeASTWithMeta(EDef(name, args, guards, transformer(body)), node.metadata, node.pos);
            case EDefp(name, args, guards, body):
                makeASTWithMeta(EDefp(name, args, guards, transformer(body)), node.metadata, node.pos);
            case EIf(condition, thenBranch, elseBranch):
                makeASTWithMeta(
                    EIf(transformer(condition), transformer(thenBranch),
                        elseBranch != null ? transformer(elseBranch) : null),
                    node.metadata, node.pos
                );
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(transformer(expr),
                          clauses.map(c -> {
                              pattern: c.pattern,
                              guard: c.guard != null ? transformer(c.guard) : null,
                              body: transformer(c.body)
                          })),
                    node.metadata, node.pos
                );
            case EMatch(pattern, expr):
                makeASTWithMeta(EMatch(pattern, transformer(expr)), node.metadata, node.pos);
            case EBinary(op, left, right):
                makeASTWithMeta(EBinary(op, transformer(left), transformer(right)), node.metadata, node.pos);
            case EUnary(op, expr):
                makeASTWithMeta(EUnary(op, transformer(expr)), node.metadata, node.pos);
            case ECall(target, funcName, args):
                makeASTWithMeta(ECall(target != null ? transformer(target) : null, funcName, args.map(transformer)), node.metadata, node.pos);
            case EMacroCall(macroName, args, doBlock):
                makeASTWithMeta(EMacroCall(macroName, args.map(transformer), transformer(doBlock)), node.metadata, node.pos);
            case ETuple(elements):
                makeASTWithMeta(ETuple(elements.map(transformer)), node.metadata, node.pos);
            case EList(elements):
                #if (debug_otp_child_spec && debug_otp_child_spec_verbose)
                if (elements.length > 0) {
                    trace('[XRay OTPChildSpec] Processing EList with ${elements.length} elements');
                    for (i in 0...elements.length) {
                        var elem = elements[i];
                        if (elem.metadata != null && elem.metadata.requiresIdiomaticTransform == true) {
                            trace('[XRay OTPChildSpec] Element $i has requiresIdiomaticTransform flag!');
                        }
                    }
                }
                #end
                makeASTWithMeta(EList(elements.map(transformer)), node.metadata, node.pos);
            case EMap(pairs):
                makeASTWithMeta(
                    EMap(pairs.map(p -> {key: transformer(p.key), value: transformer(p.value)})),
                    node.metadata, node.pos
                );
            case EKeywordList(pairs):
                makeASTWithMeta(
                    EKeywordList(pairs.map(p -> {key: p.key, value: transformer(p.value)})),
                    node.metadata, node.pos
                );
            case EStruct(name, fields):
                makeASTWithMeta(
                    EStruct(name, fields.map(f -> {key: f.key, value: transformer(f.value)})),
                    node.metadata, node.pos
                );
            case EFor(generators, filters, body, into, uniq):
                makeASTWithMeta(
                    EFor(generators.map(g -> {pattern: g.pattern, expr: transformer(g.expr)}),
                         filters.map(transformer),
                         transformer(body),
                         into != null ? transformer(into) : null,
                         uniq),
                    node.metadata, node.pos
                );
            case EFn(clauses):
                makeASTWithMeta(
                    EFn(clauses.map(c -> {
                        args: c.args,
                        guard: c.guard != null ? transformer(c.guard) : null,
                        body: transformer(c.body)
                    })),
                    node.metadata, node.pos
                );
            case EReceive(clauses, after):
                makeASTWithMeta(
                    EReceive(clauses.map(c -> {
                                 pattern: c.pattern,
                                 guard: c.guard != null ? transformer(c.guard) : null,
                                 body: transformer(c.body)
                             }),
                             after != null ? {timeout: transformer(after.timeout), body: transformer(after.body)} : null),
                    node.metadata, node.pos
                );
            case EModuleAttribute(name, value):
                makeASTWithMeta(EModuleAttribute(name, transformer(value)), node.metadata, node.pos);
            case ERemoteCall(module, funcName, args):
                makeASTWithMeta(
                    ERemoteCall(module != null ? transformer(module) : null, funcName, args.map(transformer)),
                    node.metadata, node.pos
                );
            case EParen(expr):
                // Transform the inner expression and preserve parentheses
                makeASTWithMeta(EParen(transformer(expr)), node.metadata, node.pos);
            case _:
                // Leaf nodes - return unchanged
                node;
        };
        return transformed;
    }
    
    /**
     * Underscore Variable Cleanup Pass
     * 
     * WHY: Haxe generates temporary variables with underscore prefixes (_g, _g_1, etc.) during
     * desugaring of switches, loops, and other complex expressions. These are actually USED
     * variables, but in Elixir, underscore-prefixed variables should not be referenced after
     * assignment, causing warnings and violating Elixir conventions.
     * 
     * WHAT: Detects and renames underscore-prefixed temporary variables that are actually used
     * - Identifies Haxe-generated temp variables (_g, _g_1, _g1, etc.)
     * - Tracks which ones are referenced after declaration
     * - Renames them consistently throughout the AST
     * - Preserves truly unused underscore variables (single underscore or unused prefixed)
     * 
     * HOW: Two-phase transformation
     * 1. Analysis phase: Collect all underscore variables and track usage
     * 2. Transformation phase: Rename used variables consistently
     */
    /**
     * Supervisor options transformation pass
     * 
     * WHY: Supervisor.start_link expects keyword lists but TObjectDecl generates maps
     * WHAT: Converts supervisor option maps to keyword lists
     * HOW: Delegates to SupervisorOptionsTransformPass
     */
    static function supervisorOptionsTransformPass(ast: ElixirAST): ElixirAST {
        return SupervisorOptionsTransformPass.transform(ast);
    }
    
    /**
     * OTP Child Spec Transformation Pass
     * 
     * WHY: Enum-based child specs generate tuples like {:PubSub, "TodoApp.PubSub"}
     * which are not valid OTP child specifications. Supervisor.start_link expects
     * either module names or proper child spec maps.
     * 
     * WHAT: Detects patterns that look like child specifications and transforms them:
     * - Simple tuples {:Atom, "String"} → proper module references or child spec maps
     * - Lists of such tuples → lists of proper child specs
     * - Works for any enum-based child spec pattern, not just TypeSafeChildSpec
     * 
     * HOW: Pattern matches on common OTP child spec contexts:
     * - Supervisor.start_link calls
     * - Children lists in application modules
     * - Any list containing tuple patterns that match child spec signatures
     * 
     * PATTERNS DETECTED:
     * - {:PubSub, "name"} → {Phoenix.PubSub, name: "name"}
     * - {:Endpoint} → MyAppWeb.Endpoint
     * - {:Telemetry} → MyAppWeb.Telemetry
     * - {:Repo, config} → {MyApp.Repo, config}
     */
    static function otpChildSpecTransformPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace("[XRay OTPChildSpec] Starting idiomatic enum transformation pass");
        #end
        
        var transformCount = 0;
        
        function transformIdiomaticNode(node: ElixirAST): ElixirAST {
            #if (debug_otp_child_spec && debug_otp_child_spec_verbose)
            // Very verbose - show every node being checked
            trace('[XRay OTPChildSpec] Checking node type: ${Type.enumConstructor(node.def)}');
            #end
            
            // First, recursively transform children
            var nodeWithTransformedChildren = transformAST(node, transformIdiomaticNode);
            
            // Handle null nodes
            if (nodeWithTransformedChildren == null) {
                return null;
            }
            
            // Then check if this node itself needs transformation
            if (nodeWithTransformedChildren.metadata != null && nodeWithTransformedChildren.metadata.requiresIdiomaticTransform == true) {
                #if debug_otp_child_spec
                trace('[XRay OTPChildSpec] Found node #${++transformCount} with requiresIdiomaticTransform flag');
                trace('[XRay OTPChildSpec] Node def: ${nodeWithTransformedChildren.def}');
                #end
                // Apply transformation using shared utility
                var transformed = reflaxe.elixir.ast.ElixirAST.applyIdiomaticEnumTransformation(nodeWithTransformedChildren);
                #if debug_otp_child_spec
                trace('[XRay OTPChildSpec] Transformed to: ${transformed.def}');
                #end
                return transformed;
            }
            
            return nodeWithTransformedChildren;
        }
        
        var result = transformIdiomaticNode(ast);
        
        #if debug_otp_child_spec
        trace('[XRay OTPChildSpec] Pass complete. Transformed ${transformCount} nodes');
        #end
        
        return result;
    }
    
    /**
     * Transform idiomatic enum constructors using convention-based patterns
     * 
     * WHY: Enums marked with @:elixirIdiomatic need special compilation
     * to match Elixir/OTP conventions. Instead of hardcoding specific patterns,
     * we detect structural conventions that indicate idiomatic Elixir usage.
     * 
     * WHAT: Convention-based transformations based on constructor structure:
     * 
     * 1. ZERO ARGUMENTS → Bare atom
     *    MyConstructor() → :my_constructor
     * 
     * 2. SINGLE ARGUMENT → Unwrap the value
     *    ModuleRef("Phoenix.PubSub") → Phoenix.PubSub
     *    This is common for module references in OTP
     * 
     * 3. TWO ARGUMENTS where second is keyword list → {first, keyword_list}
     *    ModuleWithConfig("Phoenix.PubSub", [name: "MyApp"]) → {Phoenix.PubSub, [name: "MyApp"]}
     *    This is the standard OTP child spec format
     * 
     * 4. TWO ARGUMENTS (general) → Keep as tuple but simplified
     *    SomeConstructor(a, b) → {a, b} (without constructor tag)
     * 
     * 5. THREE+ ARGUMENTS → Keep standard tuple format
     *    Complex(a, b, c) → {:complex, a, b, c}
     * 
     * HOW: Analyzes the AST structure to detect patterns:
     * - Counts arguments
     * - Detects keyword lists (EKeywordList nodes)
     * - Checks for string literals that should become atoms (module names)
     * 
     * CONVENTIONS DETECTED:
     * - Module name patterns (strings that look like Elixir modules)
     * - Keyword list patterns (for configuration)
     * - Arity patterns (zero, one, two, many)
     * 
     * @param elements The tuple elements [constructor_tag, arg1, arg2, ...]
     * @param node The original AST node with metadata
     * @return Transformed AST following Elixir idioms
     */
    /**
     * Tuple Element Field to Function Transformation Pass
     * 
     * WHY: When switch statements are compiled for Result enums, Haxe generates
     * TField expressions like tuple.elem(0) instead of function calls. These
     * become EField nodes which print as invalid Elixir syntax.
     * 
     * WHAT: Transforms EField nodes with "elem" field name into proper ECall nodes
     * for elem(tuple, index) function calls.
     * 
     * HOW: Recursively traverses AST, detects EField with "elem", and converts
     * them to ECall nodes. This enables the enum pattern matching pass to work.
     */
    static function tupleElemFieldToFunctionPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay TupleElemField] Starting tuple elem field to function transformation');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case EField(target, "elem"):
                // This is a tuple.elem field access that needs to become elem(tuple, N)
                // However, we don't have the index here - it's usually called as tuple.elem(0)
                // So we need to look for the pattern in context
                #if debug_ast_transformer
                var targetStr = ElixirASTPrinter.printAST(target);
                trace('[XRay TupleElemField] Found .elem field access on: $targetStr');
                #end
                
                // For now, we'll mark it for transformation but can't fully convert
                // without the index. The pattern matching pass will handle it.
                {
                    def: EField(transformAST(target, tupleElemFieldToFunctionPass), "elem"),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            case ECall(expr, funcName, args):
                if (funcName == "elem" && expr != null) {
                    // This is a method call pattern: target.elem(N)
                    // Transform to elem(target, N) for proper Elixir syntax
                    #if debug_ast_transformer
                    var targetStr = ElixirASTPrinter.printAST(expr);
                    trace('[XRay TupleElemField] Transforming ${targetStr}.elem(${args.length} args) to elem($targetStr, ...)');
                    #end
                    {
                        def: ECall(null, "elem", [
                            transformAST(expr, tupleElemFieldToFunctionPass)
                        ].concat([for (arg in args) transformAST(arg, tupleElemFieldToFunctionPass)])),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                } else {
                    // Regular call, transform recursively
                    {
                        def: ECall(
                            expr != null ? transformAST(expr, tupleElemFieldToFunctionPass) : null,
                            funcName,
                            [for (arg in args) transformAST(arg, tupleElemFieldToFunctionPass)]
                        ),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                }
                
            default:
                // Recursively transform children
                transformAST(ast, tupleElemFieldToFunctionPass);
        };
    }
    
    /**
     * Idiomatic Enum Pattern Matching Transformation Pass
     * 
     * WHY: The compiler generates low-level tuple access patterns for enum matching
     * which results in non-idiomatic Elixir code and variable naming inconsistencies.
     * Instead of case x.elem(0) with x.elem(1) extraction, we want case x with pattern matching.
     * 
     * WHAT: Transforms patterns like:
     *   case result.elem(0) do
     *     0 -> _g = result.elem(1); value = g; {:Some, value}
     *     1 -> _g = result.elem(1); :none
     *   end
     * Into:
     *   case result do
     *     {0, value} -> {:Some, value}
     *     {1, _} -> :none
     *   end
     * 
     * HOW: Detects ECase with ETupleAccess(expr, 0) and transforms the entire structure
     * to use tuple pattern matching instead of manual extraction.
     */
    static function idiomaticEnumPatternMatchingPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Starting idiomatic enum pattern matching pass');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case ECase(expr, clauses):
                // Check if this is an enum tag check pattern (case x.elem(0))
                var isEnumTagCheck = false;
                var baseExpr = expr;
                
                switch(expr.def) {
                    case ECall(tupleExpr, "elem", [arg]):
                        switch(arg.def) {
                            case EInteger(0):
                                #if debug_ast_transformer
                                trace('[XRay EnumPatternMatching] Found enum tag check pattern on elem(0) as ECall');
                                #end
                                isEnumTagCheck = true;
                                baseExpr = tupleExpr;
                            default:
                        }
                    case EField(tupleExpr, "elem"):
                        // This is the pattern generated by switch on Result enums
                        // We detect it here but can't check for index 0 directly
                        // The transformer will need to analyze the clauses to determine this
                        #if debug_ast_transformer
                        trace('[XRay EnumPatternMatching] Found potential enum tag check pattern with .elem field access');
                        #end
                        isEnumTagCheck = true;
                        baseExpr = tupleExpr;
                    default:
                }
                
                if (isEnumTagCheck) {
                    
                    #if debug_ast_transformer
                    trace('[XRay EnumPatternMatching] Transforming enum case to idiomatic pattern matching');
                    #end
                    
                    // Transform each clause
                    var transformedClauses = [];
                    for (clause in clauses) {
                        var transformedClause = transformEnumClause(clause, baseExpr);
                        transformedClauses.push(transformedClause);
                    }
                    
                    // Return the transformed case using the base expression directly
                    {
                        def: ECase(baseExpr, transformedClauses),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                } else {
                    // Not an enum pattern, recursively transform children
                    transformAST(ast, idiomaticEnumPatternMatchingPass);
                }
                
            default:
                // Recursively transform children
                transformAST(ast, idiomaticEnumPatternMatchingPass);
        };
    }
    
    /**
     * Transform an individual enum case clause to use pattern matching
     * 
     * WHY: Each clause needs to be transformed from tag checking to pattern matching
     * WHAT: Converts manual elem() extraction to tuple pattern destructuring  
     * HOW: Analyzes the body for elem(1) calls and creates appropriate patterns
     */
    static function transformEnumClause(clause: ECaseClause, baseExpr: ElixirAST): ECaseClause {
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Transforming clause with pattern: ${clause.pattern}');
        #end
        
        // Extract the tag value from the pattern
        var tagValue = switch(clause.pattern) {
            case PLiteral(ast):
                switch(ast.def) {
                    case EInteger(tag): tag;
                    default:
                        #if debug_ast_transformer
                        trace('[XRay EnumPatternMatching] Non-integer pattern, keeping as-is');
                        #end
                        return clause; // Can't transform non-integer patterns
                }
            default: 
                #if debug_ast_transformer
                trace('[XRay EnumPatternMatching] Non-literal pattern, keeping as-is');
                #end
                return clause; // Can't transform non-literal patterns
        };
        
        // Analyze the body to find parameter extraction patterns
        var extractedParams = analyzeEnumParameterExtraction(clause.body, baseExpr);
        
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Found ${extractedParams.length} extracted parameters');
        #end
        
        // Create tuple pattern based on extracted parameters
        var tuplePattern = if (extractedParams.length > 0) {
            // Create pattern with extracted variable names
            var patterns = [PLiteral(makeAST(EInteger(tagValue)))];
            for (param in extractedParams) {
                patterns.push(PVar(param.finalName));
            }
            PTuple(patterns);
        } else {
            // No parameters, use wildcard
            PTuple([PLiteral(makeAST(EInteger(tagValue))), PWildcard]);
        };
        
        // Clean up the body by removing extraction statements
        var cleanedBody = removeEnumParameterExtractions(clause.body, extractedParams);
        
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Created tuple pattern with ${extractedParams.length + 1} elements');
        #end
        
        return {
            pattern: tuplePattern,
            guard: clause.guard,
            body: cleanedBody
        };
    }
    
    /**
     * Analyze the body to find enum parameter extraction patterns
     */
    static function analyzeEnumParameterExtraction(body: ElixirAST, baseExpr: ElixirAST): Array<{tempName: String, finalName: String}> {
        var params = [];
        
        switch(body.def) {
            case EBlock(exprs):
                for (expr in exprs) {
                    switch(expr.def) {
                        case EMatch(PVar(varName), ast):
                            switch(ast.def) {
                                case ECall(tupleExpr, "elem", [arg]):
                                    switch(arg.def) {
                                        case EInteger(1):
                                            // Found pattern: _g = result.elem(1)
                                            if (astEquals(tupleExpr, baseExpr)) {
                                                // Look for subsequent assignment: value = g
                                                var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
                                                if (finalName != null) {
                                                    params.push({tempName: varName, finalName: finalName});
                                                } else {
                                                    // Use the temp name without underscore as final name
                                                    params.push({tempName: varName, finalName: varName.replace("_", "")});
                                                }
                                            }
                                        default:
                                    }
                                default:
                            }
                        default:
                    }
                }
            default:
                // Single expression body, no extraction
        }
        
        return params;
    }
    
    /**
     * Find subsequent assignment of a temp variable
     */
    static function findSubsequentAssignment(exprs: Array<ElixirAST>, tempVarWithoutUnderscore: String): Null<String> {
        for (expr in exprs) {
            switch(expr.def) {
                case EMatch(PVar(finalName), ast):
                    switch(ast.def) {
                        case EVar(srcVar):
                            if (srcVar == tempVarWithoutUnderscore) {
                                return finalName;
                            }
                        default:
                    }
                default:
            }
        }
        return null;
    }
    
    /**
     * Remove enum parameter extraction statements from the body
     */
    static function removeEnumParameterExtractions(body: ElixirAST, extractedParams: Array<{tempName: String, finalName: String}>): ElixirAST {
        switch(body.def) {
            case EBlock(exprs):
                var cleanedExprs = [];
                var skip = false;
                
                for (i in 0...exprs.length) {
                    var expr = exprs[i];
                    var shouldSkip = false;
                    
                    // Check if this is an extraction statement
                    switch(expr.def) {
                        case EMatch(PVar(varName), ast):
                            switch(ast.def) {
                                case ECall(_, "elem", [arg]):
                                    switch(arg.def) {
                                        case EInteger(1):
                                            // Check if this matches any extracted param
                                            for (param in extractedParams) {
                                                if (varName == param.tempName) {
                                                    shouldSkip = true;
                                                    break;
                                                }
                                            }
                                        default:
                                    }
                                case EVar(srcVar):
                                    // Check if this is a reassignment from temp var
                                    for (param in extractedParams) {
                                        if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
                                            shouldSkip = true;
                                            break;
                                        }
                                    }
                                default:
                            }
                        default:
                    }
                    
                    if (!shouldSkip) {
                        cleanedExprs.push(expr);
                    }
                }
                
                // If only one expression remains, unwrap the block
                if (cleanedExprs.length == 1) {
                    return cleanedExprs[0];
                } else if (cleanedExprs.length == 0) {
                    // Empty block, return nil
                    return makeAST(EAtom(ElixirAtom.nil()));
                } else {
                    return {
                        def: EBlock(cleanedExprs),
                        metadata: body.metadata,
                        pos: body.pos
                    };
                }
            default:
                // Not a block, return as-is
                return body;
        }
    }
    
    /**
     * Check if two AST nodes are structurally equal
     */
    static function astEquals(a: ElixirAST, b: ElixirAST): Bool {
        // Simple structural equality check for variable references
        return switch([a.def, b.def]) {
            case [EVar(name1), EVar(name2)]: name1 == name2;
            case [EField(obj1, field1), EField(obj2, field2)]: 
                field1 == field2 && astEquals(obj1, obj2);
            default: false;
        };
    }
    
    /**
     * Transform idiomatic enum constructors using shared utility
     * 
     * WHY: This wrapper delegates to the shared transformation utility in ElixirAST.hx
     * to ensure consistent transformation logic across the AST pipeline.
     * 
     * WHAT: Applies convention-based transformations for enums marked with @:elixirIdiomatic.
     * 
     * HOW: Simply delegates to the shared utility function.
     * 
     * @param elements The tuple elements to transform (unused - kept for compatibility)
     * @param node The original AST node for metadata preservation
     * @return Transformed AST following Elixir idioms
     */
    static function transformIdiomaticEnum(elements: Array<ElixirAST>, node: ElixirAST): ElixirAST {
        // Delegate to shared utility function
        return reflaxe.elixir.ast.ElixirAST.applyIdiomaticEnumTransformation(node);
    }
    
    /**
     * Check if a string looks like an Elixir module name
     * 
     * WHY: Module names in strings should be converted to atoms in idiomatic Elixir
     * WHAT: Detects patterns like "Phoenix.PubSub", "MyApp.Repo", "Elixir.MyModule"
     * HOW: Checks for capitalized segments separated by dots
     * 
     * @param s The string to check
     * @return True if it looks like a module name
     */
    static function isModuleName(s: String): Bool {
        if (s == null || s.length == 0) return false;
        
        // Module names start with uppercase or "Elixir."
        var firstChar = s.charAt(0);
        if (firstChar != firstChar.toUpperCase()) return false;
        
        // Check for module path pattern (e.g., "Phoenix.PubSub")
        var segments = s.split(".");
        for (segment in segments) {
            if (segment.length == 0) return false;
            var first = segment.charAt(0);
            // Each segment should start with uppercase
            if (first != first.toUpperCase() || first == first.toLowerCase()) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Convert a constructor name to idiomatic Elixir atom
     * 
     * WHY: Elixir atoms use snake_case, but some patterns need special handling
     * WHAT: Converts CamelCase to snake_case with special cases for common patterns
     * HOW: 
     * - "Ok" → "ok" (common Result pattern)
     * - "Error" → "error" (common Result pattern)  
     * - "Some" → "ok" (Option pattern mapped to Elixir convention)
     * - "None" → "error" (Option pattern mapped to Elixir convention)
     * - Others → snake_case
     * 
     * @param tag The constructor tag name
     * @return Idiomatic atom name
     */
    static function toIdiomaticAtom(tag: String): String {
        // Special cases for common patterns
        switch(tag.toLowerCase()) {
            case "ok": return "ok";
            case "error": return "error";
            case "some": return "ok";  // Option.Some maps to {:ok, _} in Elixir
            case "none": return "error";  // Option.None maps to :error in Elixir
            default:
                // Convert to snake_case
                return toSnakeCase(tag);
        }
    }
    
    
    static function underscoreVariableCleanupPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay UnderscoreCleanup] Starting underscore variable cleanup pass');
        #end
        
        // Phase 1: Collect underscore variables and track usage
        var underscoreVars = new Map<String, Bool>(); // var name -> is used
        var varDeclarations = new Map<String, Bool>(); // track all declarations
        var allUnderscoreVars = new Map<String, Bool>(); // track ALL underscore vars
        
        function collectPatternVars(pattern: EPattern, vars: Map<String, Bool>): Void {
            switch(pattern) {
                case PVar(name):
                    vars.set(name, true);
                    if (name.charAt(0) == "_" && name.length > 1) {
                        // Track all underscore variables (including _g_1, _g_2, etc.)
                        allUnderscoreVars.set(name, true);
                        // Initialize as unused
                        if (!underscoreVars.exists(name)) {
                            underscoreVars.set(name, false);
                        }
                    }
                case PTuple(patterns):
                    for (p in patterns) collectPatternVars(p, vars);
                case PList(patterns):
                    for (p in patterns) collectPatternVars(p, vars);
                case PCons(head, tail):
                    collectPatternVars(head, vars);
                    collectPatternVars(tail, vars);
                case PMap(pairs):
                    for (pair in pairs) collectPatternVars(pair.value, vars);
                case PStruct(name, fields):
                    for (field in fields) collectPatternVars(field.value, vars);
                case _:
                    // Other patterns don't declare variables
            }
        }
        
        function collectVariables(node: ElixirAST): Void {
            // Handle null nodes
            if (node == null) {
                return;
            }
            
            switch(node.def) {
                case EMatch(pattern, expr):
                    // Track variable declarations in patterns
                    collectPatternVars(pattern, varDeclarations);
                    // Continue collecting in expression
                    collectVariables(expr);
                    
                case EVar(name):
                    // Track variable usage (not in pattern context)
                    if (name.charAt(0) == "_" && name.length > 1) {
                        // Mark this underscore variable as used
                        underscoreVars.set(name, true);
                        allUnderscoreVars.set(name, true);
                        #if debug_ast_transformer
                        trace('[XRay UnderscoreCleanup] Found used underscore variable: $name at ${node.pos}');
                        #end
                    }
                    
                case ERemoteCall(module, funcName, args):
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Found ERemoteCall: $funcName with ${args.length} args');
                    #end
                    // Recursively collect from module and all arguments
                    if (module != null) collectVariables(module);
                    for (arg in args) {
                        collectVariables(arg);
                    }
                    
                case EFn(clauses):
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Found EFn with ${clauses.length} clauses');
                    #end
                    // Recursively collect from lambda/function bodies
                    for (clause in clauses) {
                        if (clause.guard != null) collectVariables(clause.guard);
                        collectVariables(clause.body);
                    }
                    
                case _:
                    // Recursively collect from all children
                    iterateAST(node, collectVariables);
            }
        }
        
        // Run collection phase
        collectVariables(ast);
        
        // Phase 2: Build renaming map for ALL underscore variables that are referenced
        var renameMap = new Map<String, String>();
        
        // Process all underscore variables we found
        for (varName in allUnderscoreVars.keys()) {
            // Check if this variable is actually used (referenced after declaration)
            var isUsed = underscoreVars.exists(varName) && underscoreVars.get(varName);

            if (isUsed) {
                // CRITICAL FIX: Skip infrastructure variables (_g, _g1, etc.)
                // These are Haxe-generated temporaries for switch desugaring that MUST keep their names
                // Reason: The variable declaration might be in a different scope/block than we can see
                // Example: `switch(msg.type)` desugars to `var _g = msg.type; switch(_g)`
                // If we rename `_g` to `g` in the switch but not in the declaration, we get undefined variable errors
                if (~/^_g(_?\d*)?$/.match(varName)) {
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] PRESERVING infrastructure variable: $varName (used in switch desugaring)');
                    #end
                    // DO NOT rename - keep the underscore prefix
                    continue;
                }

                // This underscore variable is used, so rename it
                if (~/^_\d+$/.match(varName)) {
                    // _1, _2 -> temp_1, temp_2 (avoid pure numeric)
                    var newName = "temp" + varName.substr(1);
                    renameMap.set(varName, newName);
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Renaming used numeric: $varName -> $newName');
                    #end
                }
                // Other underscore variables are left as-is (might be intentional)
            } else {
                #if debug_ast_transformer
                if (varName.charAt(0) == "_" && varName.length > 1) {
                    trace('[XRay UnderscoreCleanup] Keeping unused underscore variable: $varName');
                }
                #end
            }
        }
        
        // Phase 3: Apply renaming throughout the AST
        if (renameMap.keys().hasNext()) {
            #if debug_ast_transformer
            trace('[XRay UnderscoreCleanup] Applying ${Lambda.count(renameMap)} variable renamings');
            #end
            return applyVariableRenaming(ast, renameMap);
        }
        
        #if debug_ast_transformer
        trace('[XRay UnderscoreCleanup] No underscore variables need renaming');
        #end
        return ast;
    }
    
    /**
     * Apply variable renaming throughout the AST
     */
    static function applyVariableRenaming(ast: ElixirAST, renameMap: Map<String, String>): ElixirAST {
        function renameInPattern(pattern: EPattern): EPattern {
            return switch(pattern) {
                case PVar(name):
                    renameMap.exists(name) ? PVar(renameMap.get(name)) : pattern;
                case PTuple(patterns):
                    PTuple(patterns.map(renameInPattern));
                case PList(patterns):
                    PList(patterns.map(renameInPattern));
                case PCons(head, tail):
                    PCons(renameInPattern(head), renameInPattern(tail));
                case PMap(pairs):
                    PMap(pairs.map(p -> {key: p.key, value: renameInPattern(p.value)}));
                case PStruct(name, fields):
                    PStruct(name, fields.map(f -> {key: f.key, value: renameInPattern(f.value)}));
                case _:
                    pattern;
            }
        }
        
        function renameInAST(node: ElixirAST): ElixirAST {
            var transformed = switch(node.def) {
                case EVar(name):
                    if (renameMap.exists(name)) {
                        #if debug_ast_transformer
                        trace('[XRay UnderscoreCleanup] Renaming EVar: $name -> ${renameMap.get(name)}');
                        #end
                        makeASTWithMeta(EVar(renameMap.get(name)), node.metadata, node.pos);
                    } else {
                        node;
                    }
                    
                case EMatch(pattern, expr):
                    makeASTWithMeta(
                        EMatch(renameInPattern(pattern), renameInAST(expr)),
                        node.metadata, node.pos
                    );
                    
                case ECase(expr, clauses):
                    makeASTWithMeta(
                        ECase(renameInAST(expr),
                              clauses.map(c -> {
                                  pattern: renameInPattern(c.pattern),
                                  guard: c.guard != null ? renameInAST(c.guard) : null,
                                  body: renameInAST(c.body)
                              })),
                        node.metadata, node.pos
                    );
                    
                case EReceive(clauses, after):
                    makeASTWithMeta(
                        EReceive(clauses.map(c -> {
                                     pattern: renameInPattern(c.pattern),
                                     guard: c.guard != null ? renameInAST(c.guard) : null,
                                     body: renameInAST(c.body)
                                 }),
                                 after != null ? {timeout: renameInAST(after.timeout), body: renameInAST(after.body)} : null),
                        node.metadata, node.pos
                    );
                    
                case EFn(clauses):
                    makeASTWithMeta(
                        EFn(clauses.map(c -> {
                            args: c.args.map(renameInPattern),
                            guard: c.guard != null ? renameInAST(c.guard) : null,
                            body: renameInAST(c.body)
                        })),
                        node.metadata, node.pos
                    );
                    
                case _:
                    // For all other node types, recursively transform children
                    transformAST(node, renameInAST);
            };
            return transformed;
        }
        
        return renameInAST(ast);
    }
    
    /**
     * Fix Bare Concatenations Pass
     * 
     * WHY: When array.push() is transformed to concatenation, nested blocks can contain
     *      bare concatenations like `g ++ [0]` which are invalid as statements in Elixir.
     * 
     * WHAT: Converts bare concatenation statements to assignments.
     * 
     * HOW: Detects EBinary(Concat, EVar(name), ...) in statement position and wraps
     *      them with EBinary(Match, EVar(name), ...) to create valid assignments.
     */
    static function fixBareConcatenationsPass(ast: ElixirAST): ElixirAST {
        function fixConcatenations(node: ElixirAST): ElixirAST {
            if (node == null) return null;
            return switch(node.def) {
                case EBlock(statements):
                    var fixedStatements = [];
                    for (stmt in statements) {
                        // Add null check to prevent null pointer exceptions
                        if (stmt == null) {
                            continue;
                        }
                        var fixed = switch(stmt.def) {
                            // Check for bare concatenation: var ++ [value] or struct.field ++ [value]
                            case EBinary(Concat, left, right):
                                switch(left.def) {
                                    case EVar(name):
                                        // Convert to assignment: var = var ++ [value]
                                        makeAST(EBinary(Match, left, stmt));
                                    case EField(structVar, fieldName):
                                        // This is struct.field ++ [value] - a bare concatenation that should update the struct
                                        // Transform to: struct = %{struct | field: struct.field ++ [value]}
                                        switch(structVar.def) {
                                            case EVar("struct"):
                                                // Create struct update
                                                makeAST(EBinary(
                                                    Match,
                                                    structVar,
                                                    makeAST(EStructUpdate(
                                                        structVar,
                                                        [{
                                                            key: fieldName,
                                                            value: stmt  // The concatenation itself
                                                        }]
                                                    ))
                                                ));
                                            default:
                                                // Not a struct field, keep as-is
                                                stmt;
                                        }
                                    default:
                                        // Keep as-is if not a simple variable or field
                                        stmt;
                                }
                            default:
                                // Recursively fix nested blocks
                                fixConcatenations(stmt);
                        };
                        fixedStatements.push(fixed);
                    }
                    makeAST(EBlock(fixedStatements));
                    
                case EList(elements):
                    // Fix elements inside list literals
                    var fixedElements = [for (e in elements) fixConcatenations(e)];
                    makeAST(EList(fixedElements));
                    
                default:
                    // Recursively apply to all children
                    transformAST(node, fixConcatenations);
            };
        }
        
        return fixConcatenations(ast);
    }
    
    /**
     * Unrolled Comprehension Reconstruction Pass
     * 
     * WHY: Haxe completely unrolls array comprehensions with constant ranges at compile-time,
     *      converting `[for (i in 0...3) i]` into imperative code with temp variables and 
     *      concatenations. This creates invalid Elixir with bare concatenation expressions
     *      like `g ++ [0]` appearing as statements inside list literals.
     * 
     * WHAT: Detects blocks marked with isUnrolledComprehension metadata and reconstructs
     *       them back into idiomatic Elixir `for` comprehensions.
     * 
     * HOW: 1. Looks for Block nodes with isUnrolledComprehension metadata
     *      2. Analyzes the block to extract iteration pattern (range, values)
     *      3. Reconstructs as EFor(iterVar, range, body)
     *      4. Handles nested comprehensions by recursively processing inner blocks
     * 
     * EDGE CASES:
     * - Empty comprehensions (0...0 range)
     * - Single element comprehensions (0...1)
     * - Deeply nested comprehensions (3+ levels)
     * - Mixed constant and variable ranges
     * 
     * @see docs/03-compiler-development/ARRAY_COMPREHENSION_RECONSTRUCTION.md
     */
    static function unrolledComprehensionReconstructionPass(ast: ElixirAST): ElixirAST {
        #if debug_array_comprehension
        trace('[Array Comprehension Transform] Starting reconstruction pass');
        #end
        #if debug_unrolled_comprehension
        trace('[DEBUG Transform] unrolledComprehensionReconstructionPass called');
        #end
        
        function reconstructComprehension(ast: ElixirAST): ElixirAST {
            return switch(ast.def) {
                case EBlock(stmts) if (ast.metadata != null && ast.metadata.isUnrolledComprehension == true):
                    #if debug_array_comprehension
                    trace('[Array Comprehension Transform] ✓ Found marked block with ${stmts.length} statements');
                    trace('[Array Comprehension Transform]   Metadata: ${ast.metadata}');
                    #end
                    
                    // Analyze the block to reconstruct comprehension
                    var comprehension = analyzeAndReconstructComprehension(stmts);
                    if (comprehension != null) {
                        #if debug_array_comprehension
                        trace('[Array Comprehension Transform] ✓ Successfully reconstructed as for comprehension');
                        #end
                        comprehension;
                    } else {
                        #if debug_array_comprehension
                        trace('[Array Comprehension Transform] ✗ Could not reconstruct, keeping as block');
                        #end
                        ast;
                    }
                    
                case _:
                    // Recursively transform children
                    transformAST(ast, reconstructComprehension);
            };
        }
        
        return reconstructComprehension(ast);
    }
    
    /**
     * Analyze an unrolled comprehension block and reconstruct as EFor
     * 
     * Pattern to detect:
     * - g = []                    (initialization)
     * - g = g ++ [...]           (accumulation statements)
     * - g                        (return value)
     * 
     * Reconstructs as: for i <- 0..n, do: expression
     */
    static function analyzeAndReconstructComprehension(stmts: Array<ElixirAST>): Null<ElixirAST> {
        if (stmts.length < 3) return null;
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform] Analyzing block for reconstruction');
        #end
        
        // Check first statement: should be g = []
        var iterVar = switch(stmts[0].def) {
            case EBinary(Match, {def: EVar(varName)}, {def: EList([])}):
                varName;
            case _:
                return null;
        };
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Found initialization: $iterVar = []');
        #end
        
        // Extract elements from accumulation statements
        var elements = [];
        for (i in 1...stmts.length - 1) {
            switch(stmts[i].def) {
                case EBinary(Match, {def: EVar(v)}, {def: EBinary(Concat, {def: EVar(v2)}, {def: EList([elem])})}) if (v == iterVar && v2 == iterVar):
                    // g = g ++ [element]
                    elements.push(elem);
                case EBinary(Concat, {def: EVar(v)}, {def: EList([elem])}) if (v == iterVar):
                    // Bare concatenation: g ++ [element] (shouldn't happen after fix, but handle it)
                    elements.push(elem);
                case _:
                    // Unknown pattern
                    #if debug_array_comprehension
                    trace('[Array Comprehension Transform]   Unknown statement pattern: ${stmts[i].def}');
                    #end
            }
        }
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Extracted ${elements.length} elements');
        #end
        
        // Check last statement: should return the variable
        var returnsVar = switch(stmts[stmts.length - 1].def) {
            case EVar(v) if (v == iterVar): true;
            case _: false;
        };
        
        if (!returnsVar || elements.length == 0) return null;
        
        // Determine the range from element count
        var rangeEnd = elements.length - 1;
        
        // Check if elements are simple integers (0, 1, 2...) or nested comprehensions
        var isSimpleRange = true;
        var hasNestedComprehensions = false;
        
        for (i in 0...elements.length) {
            switch(elements[i].def) {
                case EInteger(val):
                    // Check if it's the expected integer
                    if (val != i) {
                        isSimpleRange = false;
                    }
                case EList(_):
                    // Nested list - likely a nested comprehension
                    hasNestedComprehensions = true;
                    isSimpleRange = false;
                case _:
                    isSimpleRange = false;
            }
        }
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Simple range: $isSimpleRange, Nested: $hasNestedComprehensions');
        #end
        
        // Generate appropriate comprehension
        if (isSimpleRange) {
            // Simple range comprehension: for i <- 0..n, do: i
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("i"),
                expr: range
            };
            var body = makeAST(EVar("i")); // Simple case: just return the iterator
            
            return makeAST(EFor([generator], [], body, null, null));
        } else if (hasNestedComprehensions) {
            // Nested comprehension: for i <- 0..n, do: for j <- 0..m, do: expr
            // For now, reconstruct the outer comprehension
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("i"),
                expr: range
            };
            
            // Use the first element as template for the body (should be consistent)
            var body = elements[0];
            
            // If the body is a list, check if it can be reconstructed as a nested comprehension
            switch(body.def) {
                case EList(innerElements):
                    // Check if inner elements follow a pattern
                    var innerComprehension = tryReconstructInnerComprehension(innerElements);
                    if (innerComprehension != null) {
                        body = innerComprehension;
                    }
                case _:
            }
            
            return makeAST(EFor([generator], [], body, null, null));
        } else {
            // Complex pattern - keep as-is for now
            #if debug_array_comprehension
            trace('[Array Comprehension Transform]   Complex pattern, not reconstructing');
            #end
            return null;
        }
    }
    
    /**
     * Try to reconstruct an inner comprehension from a list of elements
     */
    static function tryReconstructInnerComprehension(elements: Array<ElixirAST>): Null<ElixirAST> {
        if (elements.length == 0) return null;
        
        // Check if elements follow a simple numeric pattern
        var isSimpleRange = true;
        for (i in 0...elements.length) {
            switch(elements[i].def) {
                case EInteger(val):
                    if (val != i) {
                        isSimpleRange = false;
                        break;
                    }
                case _:
                    isSimpleRange = false;
                    break;
            }
        }
        
        if (isSimpleRange) {
            // Reconstruct as: for j <- 0..n, do: j
            var rangeEnd = elements.length - 1;
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("j"),
                expr: range
            };
            var body = makeAST(EVar("j"));
            
            return makeAST(EFor([generator], [], body, null, null));
        }
        
        return null;
    }
}

/**
 * SupervisorOptionsTransformPass: Convert supervisor options from map to keyword list
 * 
 * WHY: Supervisor.start_link expects options as a keyword list [strategy: :one_for_one, ...]
 *      but TObjectDecl generates EMap %{strategy: :one_for_one, ...}
 * 
 * WHAT: Detects supervisor option patterns and converts EMap to EKeywordList
 * 
 * HOW: Looks for maps with supervisor option keys (strategy, max_restarts, max_seconds)
 *      being passed to Supervisor.start_link and converts them to keyword lists
 */
class SupervisorOptionsTransformPass {
    
    /**
     * Transform supervisor options from maps to keyword lists
     */
    public static function transform(ast: ElixirAST, ?context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_ast_transformer
        trace("[XRay SupervisorOptions] Starting supervisor options transformation");
        switch(ast.def) {
            case EDefmodule(name, _):
                trace('[XRay SupervisorOptions] Processing module: $name');
            case _:
                trace('[XRay SupervisorOptions] Processing non-module AST');
        }
        #end
        
        return transformSupervisorCalls(ast);
    }
    
    /**
     * Find and transform Supervisor.start_link calls
     */
    static function transformSupervisorCalls(ast: ElixirAST): ElixirAST {
        return ElixirASTTransformer.transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_ast_transformer
            switch(node.def) {
                case EMatch(PVar(name), _):
                    trace('[XRay SupervisorOptions] Found variable assignment in transformSupervisorCalls: $name');
                case EMap(_):
                    trace('[XRay SupervisorOptions] Found map in transformSupervisorCalls');
                case _:
            }
            #end
            
            switch(node.def) {
                case ERemoteCall(module, "start_link", args) if (args.length == 2):
                    // Check if this is Supervisor.start_link(children, opts)
                    var isSupervisor = switch(module.def) {
                        case EVar("Supervisor"): true;
                        case _: false;
                    };
                    
                    if (isSupervisor) {
                        #if debug_ast_transformer
                        trace("[XRay SupervisorOptions] Found Supervisor.start_link call");
                        #end
                        
                        // Transform the second argument (options) if it's a map
                        var children = args[0];
                        var opts = transformSupervisorOptions(args[1]);
                        
                        return makeASTWithMeta(
                            ERemoteCall(module, "start_link", [children, opts]),
                            node.metadata,
                            node.pos
                        );
                    }
                    
                case EMatch(pattern, expr):
                    // Check if we're assigning to a variable named "opts" or similar
                    var varName = switch(pattern) {
                        case PVar(name): name;
                        case _: null;
                    };
                    
                    #if debug_ast_transformer
                    if (varName != null) {
                        trace('[XRay SupervisorOptions] Found variable assignment: $varName');
                    }
                    #end
                    
                    if (varName != null && (varName == "opts" || varName.indexOf("option") != -1 || varName.indexOf("config") != -1)) {
                        // This might be supervisor options
                        #if debug_ast_transformer
                        trace('[XRay SupervisorOptions] Variable $varName looks like options, checking if it\'s a map...');
                        #end
                        
                        var transformedExpr = transformSupervisorOptions(expr);
                        if (transformedExpr != expr) {
                            #if debug_ast_transformer
                            trace('[XRay SupervisorOptions] ✓ Transformed options assignment for variable: $varName');
                            #end
                            return makeASTWithMeta(
                                EMatch(pattern, transformedExpr),
                                node.metadata,
                                node.pos
                            );
                        }
                    }
                    
                case _:
                    // Not a supervisor call
            }
            
            return node;
        });
    }
    
    /**
     * Transform supervisor options from map to keyword list if needed
     */
    static function transformSupervisorOptions(expr: ElixirAST): ElixirAST {
        return switch(expr.def) {
            case EMap(pairs):
                #if debug_ast_transformer
                trace('[XRay SupervisorOptions] Analyzing map with ${pairs.length} pairs');
                #end
                
                // Check if this looks like supervisor options
                var hasStrategy = false;
                var hasMaxRestarts = false;
                var hasMaxSeconds = false;
                var hasName = false;
                
                for (pair in pairs) {
                    var keyName: Null<String> = switch(pair.key.def) {
                        case EAtom(atom): atom; // ElixirAtom implicitly converts to String
                        case _: null;
                    };
                    
                    if (keyName != null) {
                        // Check both snake_case and original field names (before transformation)
                        // since this pass might run at different stages
                        switch(keyName.toLowerCase()) {
                            case "strategy": hasStrategy = true;
                            case "max_restarts" | "maxrestarts": hasMaxRestarts = true;
                            case "max_seconds" | "maxseconds": hasMaxSeconds = true;
                            case "name": hasName = true;
                        }
                        
                        #if debug_ast_transformer
                        trace('[XRay SupervisorOptions] Checking key: $keyName (hasStrategy=$hasStrategy, hasMaxRestarts=$hasMaxRestarts)');
                        #end
                    }
                }
                
                // If it has at least strategy (required) and one other supervisor field, convert it
                if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
                    #if debug_ast_transformer
                    trace("[XRay SupervisorOptions] Converting map to keyword list for supervisor options");
                    #end
                    
                    // Convert EMapPair to EKeywordPair with normalization for strategy atom
                    var keywordPairs: Array<EKeywordPair> = [];
                    for (pair in pairs) {
                        var key = switch(pair.key.def) {
                            case EAtom(name): name;
                            case _: continue; // Skip non-atom keys
                        };
                        var value = pair.value;
                        // Normalize strategy value to a clean atom without a leading colon
                        if (key == "strategy") {
                            switch (value.def) {
                                case EAtom(a):
                                    var aStr:String = a;
                                    if (aStr != null && aStr.length > 0 && aStr.charAt(0) == ':') {
                                        var trimmed = aStr.substr(1);
                                        value = makeAST(EAtom(ElixirAtom.raw(trimmed)));
                                    }
                                case EString(s):
                                    if (s != null && s.length > 0 && s.charAt(0) == ':') {
                                        var trimmed2 = s.substr(1);
                                        value = makeAST(EAtom(ElixirAtom.raw(trimmed2)));
                                    }
                                default:
                            }
                        }
                        
                        // Note: Snake_case conversion for atoms is handled systematically
                        // in ElixirASTBuilder.toElixirAtomName(), not here
                        keywordPairs.push({key: key, value: value});
                    }
                    
                    return makeASTWithMeta(
                        EKeywordList(keywordPairs),
                        expr.metadata,
                        expr.pos
                    );
                }
                
                expr; // Not supervisor options
                
            case _:
                expr; // Not a map
        };
    }
    
    /**
     * Helper to create AST node with metadata
     */
    static function makeASTWithMeta(def: ElixirASTDef, ?metadata: ElixirMetadata, ?pos: haxe.macro.Expr.Position): ElixirAST {
        return {
            def: def,
            metadata: metadata != null ? metadata : {},
            pos: pos
        };
    }

    /**
     * Pattern Variable Origin Analysis Pass
     *
     * WHY: Distinguish between legitimate user variables named "g" (like in RGB patterns)
     *      and Haxe's temp extraction variables (g, g1, g2). Without this, legitimate
     *      variables get incorrectly prefixed with underscores.
     *
     * WHAT: Uses VarOrigin metadata to determine which variables should get underscore
     *       prefixes and ensures correct variable usage in pattern matching.
     *
     * HOW:
     * - Analyzes case patterns and their bodies for variable usage
     * - Checks varOrigin metadata to distinguish PatternBinder vs ExtractionTemp
     * - Updates pattern variables to use underscores only for truly unused variables
     * - Ensures consistency between pattern declaration and usage
     *
     * EXAMPLE:
     * Before: {:rgb, _g, _g1, _b} with reference to undefined 'g'
     * After: {:rgb, r, g, b} with correct references
     */
    static function patternVariableOriginAnalysisPass(ast: ElixirAST): ElixirAST {
        #if debug_pattern_variable_origin
        trace('[XRay PatternVariableOrigin] Starting analysis pass');
        #end

        // Forward declarations for recursive functions
        var analyzeAndTransform: ElixirAST -> ElixirAST = null;
        var analyzeClause: (ECaseClause, ElixirMetadata) -> ECaseClause = null;
        var collectPatternVars: (EPattern, Map<String, VarOrigin>, VarOrigin) -> Void = null;
        var analyzeUsage: (ElixirAST, Map<String, Bool>) -> Void = null;
        var updatePatternWithUsage: (EPattern, Map<String, VarOrigin>, Map<String, Bool>) -> EPattern = null;

        analyzeAndTransform = function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ECase(expr, clauses):
                    #if debug_pattern_variable_origin
                    trace('[XRay PatternVariableOrigin] Analyzing case expression');
                    #end

                    // Transform each clause
                    var newClauses = [];
                    for (clause in clauses) {
                        var transformedClause = analyzeClause(clause, node.metadata);
                        newClauses.push(transformedClause);
                    }

                    return makeASTWithMeta(
                        ECase(analyzeAndTransform(expr), newClauses),
                        node.metadata,
                        node.pos
                    );

                default:
                    // Recursively transform other nodes
                    return ElixirASTTransformer.transformAST(node, analyzeAndTransform);
            }
        };

        analyzeClause = function(clause: ECaseClause, caseMetadata: ElixirMetadata): ECaseClause {
            #if debug_pattern_variable_origin
            trace('[XRay PatternVariableOrigin] Analyzing clause pattern');
            #end

            // Get variable origin info from metadata if available
            var varOrigin = caseMetadata != null && caseMetadata.varOrigin != null ?
                caseMetadata.varOrigin : null;
            var tempToBinderMap = caseMetadata != null && caseMetadata.tempToBinderMap != null ?
                caseMetadata.tempToBinderMap : null;

            // Collect variables from the pattern and their origins
            var patternVars: Map<String, VarOrigin> = new Map();
            collectPatternVars(clause.pattern, patternVars, varOrigin);

            // Analyze usage in the clause body
            var usedVars: Map<String, Bool> = new Map();
            analyzeUsage(clause.body, usedVars);

            // Update pattern based on usage and origin
            var updatedPattern = updatePatternWithUsage(clause.pattern, patternVars, usedVars);

            return {
                pattern: updatedPattern,
                guard: clause.guard != null ? analyzeAndTransform(clause.guard) : null,
                body: analyzeAndTransform(clause.body)
            };
        };

        collectPatternVars = function(pattern: EPattern, vars: Map<String, VarOrigin>, defaultOrigin: VarOrigin): Void {
            switch(pattern) {
                case PVar(name):
                    // Use the origin from metadata if available, otherwise use default
                    var origin = defaultOrigin != null ? defaultOrigin : UserDefined;

                    // Special handling for known temp variable patterns
                    if (name == "g" || (name.startsWith("g") && name.length > 1 &&
                        name.charAt(1) >= '0' && name.charAt(1) <= '9')) {
                        // This looks like a temp extraction variable
                        origin = ExtractionTemp;
                    }

                    vars.set(name, origin);

                case PTuple(elements):
                    for (elem in elements) {
                        collectPatternVars(elem, vars, defaultOrigin);
                    }

                case PList(elements):
                    for (elem in elements) {
                        collectPatternVars(elem, vars, defaultOrigin);
                    }

                case PCons(head, tail):
                    collectPatternVars(head, vars, defaultOrigin);
                    collectPatternVars(tail, vars, defaultOrigin);

                default:
                    // Other patterns don't introduce variables
            }
        };

        analyzeUsage = function(ast: ElixirAST, usedVars: Map<String, Bool>): Void {
            switch(ast.def) {
                case EVar(name):
                    // Mark this variable as used (remove underscore prefix if present for comparison)
                    var cleanName = name.startsWith("_") ? name.substring(1) : name;
                    usedVars.set(cleanName, true);
                    usedVars.set(name, true); // Also mark the exact name

                case EMatch(pattern, expr):
                    // Analyze the expression for usage
                    analyzeUsage(expr, usedVars);
                    // Don't analyze the pattern - it's a declaration

                default:
                    // Recursively analyze children
                    // TODO: Need to properly iterate through AST children
                    // This pass is disabled anyway, so commenting out for now
                    // iterateAST(ast, function(child) {
                    //     analyzeUsage(child, usedVars);
                    // });
            }
        };

        updatePatternWithUsage = function(pattern: EPattern, patternVars: Map<String, VarOrigin>, usedVars: Map<String, Bool>): EPattern {
            switch(pattern) {
                case PVar(name):
                    var origin = patternVars.get(name);
                    var isUsed = usedVars.exists(name) && usedVars.get(name);

                    #if debug_pattern_variable_origin
                    trace('[XRay PatternVariableOrigin] Variable "$name" - Origin: $origin, Used: $isUsed');
                    #end

                    // Special case: legitimate user variables named "g" should NOT get underscores
                    // Only add underscore if:
                    // 1. Variable is not used AND
                    // 2. It's definitely an extraction temp (not a user's "g" in RGB)
                    if (!isUsed && !name.startsWith("_")) {
                        // Check if this is definitely a temp extraction variable
                        // For now, we're conservative - only prefix if we're sure it's unused
                        if (origin == ExtractionTemp) {
                            // But wait - if it's named just "g" in an RGB pattern, it might be legitimate
                            // This is where we'd need more context to decide
                            // For now, leave it as-is to avoid false positives
                            return pattern;
                        }
                    }
                    return pattern;

                case PTuple(elements):
                    return PTuple(elements.map(e -> updatePatternWithUsage(e, patternVars, usedVars)));

                case PList(elements):
                    return PList(elements.map(e -> updatePatternWithUsage(e, patternVars, usedVars)));

                case PCons(head, tail):
                    return PCons(
                        updatePatternWithUsage(head, patternVars, usedVars),
                        updatePatternWithUsage(tail, patternVars, usedVars)
                    );

                default:
                    return pattern;
            }
        };

        return analyzeAndTransform(ast);
    }
}

#if debug_ast_snapshots
private class AbsoluteFinalSnapshot {
    public static function emitFilterTodosThenBranch(ast: ElixirAST): Void {
        // Optional narrowing: module and func can be provided via defines.
        var wantFunc = getDefineString('debug_ast_snapshots_func');
        var wantModule = getDefineString('debug_ast_snapshots_module');

        // Default target if none provided
        if (wantFunc == null || wantFunc == '') wantFunc = 'filter_todos/3';

        var targetName = extractFuncName(wantFunc);
        var targetArity = extractArity(wantFunc);

        var thenBranch: ElixirAST = null;
        var seenFuncs: Array<String> = [];

        traverse(ast, function(node) {
            // Attempt capture from any function node we see
            tryCaptureFromDef(node, targetName, targetArity, function(b) thenBranch = b);
            if (thenBranch != null) return; // short‑circuit
            // Optional module narrowing: no‑op unless set
            switch (node.def) {
                case EModule(modName, _, _):
                    #if sys Sys.println('[AST Snapshot] In module: ' + modName); #end
                    if (wantModule != null && wantModule != '' && modName != wantModule) {
                        // Note: we don't prune traversal here to avoid skipping nested defs
                    }
                case EDef(name, args, _, _) | EDefp(name, args, _, _):
                    if (seenFuncs.indexOf(name + '/' + (args != null ? args.length : 0)) == -1)
                        seenFuncs.push(name + '/' + (args != null ? args.length : 0));
                default:
            }
        });

        if (thenBranch != null) {
            var code = safePrint(thenBranch);
            writeSnapshot('tmp/ast_flow', 'AbsoluteFinal_filter_todos_then_branch.ex', code);
            #if sys Sys.println('[AST Snapshot] Wrote then‑branch to tmp/ast_flow/AbsoluteFinal_filter_todos_then_branch.ex'); #else trace('[AST Snapshot] Wrote then‑branch'); #end
            // If module name filter is set, dump observed functions for debugging
            if (wantModule != null && wantModule != '') {
                var fnDump = seenFuncs.join("\n");
                writeSnapshot('tmp/ast_flow', 'AbsoluteFinal_' + targetName + '_observed_functions.txt', fnDump);
            }
        } else {
            #if sys Sys.println('[AST Snapshot] filter_todos/3 then‑branch not found'); #else trace('[AST Snapshot] then‑branch not found'); #end
        }
    }

    static function tryCaptureFromDef(node: ElixirAST, targetName: String, targetArity: Int, onFound: ElixirAST -> Void): Void {
        switch (node.def) {
            case EDef(name, args, _, body) | EDefp(name, args, _, body):
                #if sys Sys.println('[AST Snapshot] Saw def ' + name + '/' + (args != null ? args.length : 0)); #end
                if (name == targetName && args != null && args.length == targetArity) {
                    var firstIf = findFirstIf(body);
                    if (firstIf != null) onFound(firstIf.thenBranch);
                }
            default:
        }
    }

    static function findFirstIf(node: ElixirAST): { condition: ElixirAST, thenBranch: ElixirAST, elseBranch: Null<ElixirAST> } {
        var found: { condition: ElixirAST, thenBranch: ElixirAST, elseBranch: Null<ElixirAST> } = null;
        traverse(node, function(n) {
            if (found != null) return; // short‑circuit
            switch (n.def) {
                case EIf(cond, thenB, elseB):
                    found = { condition: cond, thenBranch: thenB, elseBranch: elseB };
                default:
            }
        });
        return found;
    }

    static function traverse(node: ElixirAST, f: ElixirAST -> Void): Void {
        if (node == null) return;
        function visitor(n: ElixirAST): Void {
            if (n == null) return;
            f(n);
            // Recursively visit child nodes via transformAST with identity
            ElixirASTTransformer.transformAST(n, function(child) {
                visitor(child);
                return child;
            });
        }
        visitor(node);
    }

    static function safePrint(node: ElixirAST): String {
        try {
            return reflaxe.elixir.ast.ElixirASTPrinter.print(node, 0);
        } catch (e: Dynamic) {
            return '// <printer error> ' + Std.string(e);
        }
    }

    static function extractFuncName(spec: String): String {
        var idx = spec.lastIndexOf('/');
        return idx >= 0 ? spec.substr(0, idx) : spec;
    }

    static function extractArity(spec: String): Int {
        var idx = spec.lastIndexOf('/');
        if (idx < 0) return 0;
        var s = spec.substr(idx + 1);
        return Std.parseInt(s);
    }

    static function getDefineString(name: String): Null<String> {
        #if macro
        try return haxe.macro.Context.definedValue(name) catch (_:Dynamic) return null;
        #else
        return null;
        #end
    }

    static function writeSnapshot(dir: String, file: String, content: String): Void {
        #if sys
        if (!sys.FileSystem.exists(dir)) sys.FileSystem.createDirectory(dir);
        var full = dir + '/' + file;
        sys.io.File.saveContent(full, content);
        #end
    }
}
#end // debug_ast_snapshots

#if debug_ast_snapshots
private class PerPassSnapshot {
    static var passIndex:Int = 0;

    public static function emitFunctionAfterPass(ast: ElixirAST, passName:String):Void {
        var spec = getDefineString('debug_ast_snapshots_func');
        if (spec == null || spec == '') return;
        var targetName = extractFuncName(spec);
        var targetArity = extractArity(spec);
        var fnNode: Null<ElixirAST> = null;
        traverse(ast, function(n) {
            switch (n.def) {
                case EDef(name, args, _, _) | EDefp(name, args, _, _):
                    if (name == targetName && args != null && args.length == targetArity) fnNode = n;
                default:
            }
        });
        if (fnNode == null) { passIndex++; return; }
        var code = safePrint(fnNode);
        var dir = 'tmp/ast_flow/passes';
        #if sys if (!sys.FileSystem.exists(dir)) sys.FileSystem.createDirectory(dir); #end
        var file = dir + '/' + Std.string(passIndex) + '_' + sanitize(passName) + '.ex';
        #if sys sys.io.File.saveContent(file, code); #end
        passIndex++;
    }

    static function sanitize(s:String):String {
        if (s == null) return 'pass';
        return s.split(' ').join('_').split('/').join('_');
    }
    static function getDefineString(name: String): Null<String> {
        #if macro
        try return haxe.macro.Context.definedValue(name) catch (_:Dynamic) return null;
        #else
        return null;
        #end
    }
    static function extractFuncName(spec: String): String {
        var idx = spec.lastIndexOf('/');
        return idx >= 0 ? spec.substr(0, idx) : spec;
    }
    static function extractArity(spec: String): Int {
        var idx = spec.lastIndexOf('/');
        if (idx < 0) return 0;
        var s = spec.substr(idx + 1);
        return Std.parseInt(s);
    }

    static function traverse(node: ElixirAST, f: ElixirAST -> Void): Void {
        if (node == null) return;
        function visitor(n: ElixirAST): Void {
            if (n == null) return;
            f(n);
            ElixirASTTransformer.transformAST(n, function(child) {
                visitor(child);
                return child;
            });
        }
        visitor(node);
    }

    static function safePrint(node: ElixirAST): String {
        try {
            return reflaxe.elixir.ast.ElixirASTPrinter.print(node, 0);
        } catch (e: Dynamic) {
            return '// <printer error> ' + Std.string(e);
        }
    }
}
#end // debug_ast_snapshots

#end // (macro || reflaxe_runtime)
</file>

</files>
