# PubSub Type-Safety & Macro Enhancement Roadmap

## Overview

This document outlines a comprehensive roadmap for making Phoenix PubSub operations completely type-safe using Haxe's type system and macro capabilities. The goal is to eliminate runtime errors from typos, provide excellent IntelliSense support, and create ergonomic APIs that showcase Haxe's advantages over raw Elixir string handling.

## Current State (Phase 0)

**Problems with Raw String Approach:**
```elixir
# Raw Elixir - Runtime errors possible
Phoenix.PubSub.broadcast("todo:updates", %{
  type: "todo_upaded",  # ‚Üê Typo! Runtime error
  todo: todo
})
```

```haxe
// Current Haxe (before this roadmap) - Same problems
PubSub.broadcast("todo:updates", {
    type: "todo_updated",  // ‚Üê Typo possible, runtime error
    todo: updated_todo
});
```

## Phase 1: Simple Type-Safe Enums ‚úÖ **CURRENT IMPLEMENTATION**

**Status**: ‚úÖ Implemented in `server/types/Types.hx`

**Approach**: Use Haxe enums to make topics and message types compile-time safe.

```haxe
// Type-safe topics - no more string typos
enum PubSubTopic {
    TodoUpdates;          // "todo:updates"
    UserActivity;         // "user:activity"  
    SystemNotifications;  // "system:notifications"
}

// Type-safe messages - compile-time validation
enum PubSubMessageType {
    TodoCreated(todo: server.schemas.Todo);
    TodoUpdated(todo: server.schemas.Todo);
    TodoDeleted(id: Int);
    BulkUpdate(action: BulkOperationType);
}

// Usage - IntelliSense shows all options
SafePubSub.broadcast(TodoUpdates, TodoUpdated(todo));
//                   ^^^^^^^^^    ^^^^^^^^^^^^
//                   IDE shows:   IDE shows all
//                   - TodoUpdates message types
//                   - UserActivity with required
//                   - SystemNotifications parameters
```

**Benefits:**
- ‚úÖ **Compile-time safety**: `TodoUpaded` becomes "Unknown enum constructor" error
- ‚úÖ **IntelliSense support**: IDE shows all available options with parameters
- ‚úÖ **Exhaustiveness checking**: Compiler ensures all message types handled in pattern matching
- ‚úÖ **Zero runtime overhead**: All validation happens at compile-time
- ‚úÖ **Foundation for macros**: Advanced features can build on these enums

---

## Phase 2: Declaration-Based Topic Generation Macro

**Status**: üîÆ **Future Enhancement**

**Goal**: Auto-generate enums, helper functions, and message parsing from simple declarations.

**Critical Enhancement - Auto-Generated Message Parsing:**
Instead of manually writing error-prone parsing code:
```haxe
// ‚ùå Manual parsing - typos, maintenance burden
static function parseMessage(msg: Dynamic): PubSubMessageType {
    return switch (msg.type) {
        case "todo_created": TodoCreated(msg.todo);  // ‚Üê Typo risk
        case "todo_updated": TodoUpdated(msg.todo);  // ‚Üê Must maintain manually
        case "todo_deleted": TodoDeleted(msg.id);    // ‚Üê Forget to add new types
    }
}
```

The macro auto-generates this from the enum definition:
```haxe
// ‚úÖ Auto-generated from PubSubMessageType enum - perfect sync!
@:build(PubSubMacro.generateParser())
enum PubSubMessageType {
    TodoCreated(todo: server.schemas.Todo);
    TodoUpdated(todo: server.schemas.Todo); 
    TodoDeleted(id: Int);
}
```

```haxe
@:pubsubTopics([
    "todo:updates" => TodoUpdates,
    "user:activity" => UserActivity,
    "system:notifications" => SystemNotifications
])
class AppPubSub {}
```

**Generated Output**:
```haxe
// Auto-generated by macro
enum PubSubTopic {
    TodoUpdates;
    UserActivity;
    SystemNotifications;
}

class AppPubSub {
    static function topicToString(topic: PubSubTopic): String {
        return switch (topic) {
            case TodoUpdates: "todo:updates";
            case UserActivity: "user:activity";
            case SystemNotifications: "system:notifications";
        }
    }
}
```

**Implementation Strategy**:
- Build macro using `@:build(PubSubMacro.generateTopics())`
- Parse metadata array and generate enum + conversion functions
- Validate string format and suggest corrections for typos

**Benefits**:
- üìù **Single source of truth**: Topic strings defined once
- üîß **Automatic maintenance**: Adding topic updates all related code
- üéØ **Reduced boilerplate**: No manual enum + conversion function writing

**Priority**: Medium - Nice but not essential

---

## Phase 3: Message Pattern Matching Macro

**Status**: üîÆ **Future Enhancement**

**Goal**: Ergonomic pattern matching for incoming PubSub messages with exhaustiveness checking.

```haxe
@:handlePubSub(TodoUpdates)
function handleTodoUpdates(message) {
    @:match {
        TodoCreated(todo) => addTodoToUI(todo);
        TodoUpdated(todo) => updateTodoInUI(todo);
        TodoDeleted(id) => removeTodoFromUI(id);
        BulkUpdate(CompleteAll) => refreshTodoList();
        BulkUpdate(DeleteCompleted) => removeCompletedFromUI();
        // Compiler ensures all cases covered!
    }
}
```

**Generated Output**:
```haxe
function handleTodoUpdates(message: PubSubMessage) {
    var parsedMessage = SafePubSub.parseMessage(message);
    switch (parsedMessage) {
        case TodoCreated(todo): addTodoToUI(todo);
        case TodoUpdated(todo): updateTodoInUI(todo);
        case TodoDeleted(id): removeTodoFromUI(id);
        case BulkUpdate(action): 
            switch (action) {
                case CompleteAll: refreshTodoList();
                case DeleteCompleted: removeCompletedFromUI();
                case _: trace("Unhandled bulk action: " + action);
            }
    }
}
```

**Implementation Strategy**:
- Expression macro that transforms `@:match` blocks
- Generate switch statements with exhaustiveness validation
- Automatic parsing from Dynamic to typed enums

**Benefits**:
- üîç **Exhaustiveness checking**: Compiler ensures all message types handled
- üéØ **Clean syntax**: No manual parsing from Dynamic objects
- üõ°Ô∏è **Type safety**: Wrong message types become compile errors

**Priority**: High - Pattern matching is very common

---

## Phase 4: Auto-Broadcasting Method Decorator

**Status**: üîÆ **Future Enhancement**

**Goal**: Automatic broadcasting on function success with proper error handling.

```haxe
@:broadcast(TodoUpdates, TodoCreated)
function createTodo(params: TodoParams): Todo {
    var todo = Repo.insert(Todo.changeset(params));
    return todo; // Automatically broadcasts TodoCreated(todo) on success
}

@:broadcast(TodoUpdates, TodoUpdated)
@:onError("Failed to update todo")
function updateTodo(id: Int, changes: TodoChanges): Todo {
    var todo = findTodo(id);
    return Repo.update(Todo.changeset(todo, changes));
}
```

**Generated Output**:
```haxe
function createTodo(params: TodoParams): Result<Todo, String> {
    switch (Repo.insert(Todo.changeset(params))) {
        case Ok(todo):
            switch (SafePubSub.broadcast(TodoUpdates, TodoCreated(todo))) {
                case Ok(_): return Ok(todo);
                case Error(reason): 
                    trace("Failed to broadcast todo creation: " + reason);
                    return Ok(todo); // Still succeed even if broadcast fails
            }
        case Error(reason): 
            return Error("Failed to create todo: " + reason);
    }
}
```

**Implementation Strategy**:
- Method-level build macro using `@:build`
- Wrap return values in Result<T,E> pattern
- Generate broadcast calls on success paths

**Benefits**:
- üîÑ **Consistent broadcasting**: Never forget to broadcast changes
- üõ°Ô∏è **Error handling**: Automatic Result<T,E> wrapping
- üìù **Less boilerplate**: Focus on business logic, not infrastructure

**Priority**: High - Very common pattern in LiveView apps

---

## Phase 5: LiveView Event Binding Macro

**Status**: üîÆ **Future Enhancement**

**Goal**: Combine LiveView event handling with type-safe PubSub broadcasting.

```haxe
@:liveview
class TodoLive {
    @:event("create_todo") 
    @:broadcast(TodoUpdates, TodoCreated)
    @:updateAssigns(["todos", "total_todos", "pending_todos"])
    function createTodo(params: EventParams, socket: Socket): Socket {
        var todo = Todo.create(params);
        var todos = [todo].concat(socket.assigns.todos);
        return socket.assign({todos: todos});
    }
}
```

**Generated Output**:
```haxe
static function handle_event(event: String, params: EventParams, socket: Socket): HandleEventResult {
    return switch (event) {
        case "create_todo": 
            switch (createTodo_impl(params, socket)) {
                case Ok(result): 
                    SafePubSub.broadcast(TodoUpdates, TodoCreated(result.todo));
                    var updated_socket = LiveView.assign_multiple(socket, {
                        todos: result.todos,
                        total_todos: result.total_todos,
                        pending_todos: result.pending_todos
                    });
                    NoReply(updated_socket);
                case Error(reason):
                    NoReply(LiveView.put_flash(socket, Error, reason));
            }
        // ... other events
    }
}
```

**Implementation Strategy**:
- Class-level build macro for `@:liveview`
- Generate `handle_event` function from annotated methods
- Automatic socket assign management

**Benefits**:
- üéØ **Clean event handlers**: Focus on logic, not plumbing
- üîÑ **Automatic broadcasting**: Never miss PubSub notifications
- üìä **Smart assign updates**: Track which socket assigns change

**Priority**: Medium - Nice ergonomic improvement

---

## Phase 6: Type-Safe Phoenix Channel Integration

**Status**: üîÆ **Future Enhancement**

**Goal**: Generate Phoenix channels with automatic PubSub integration.

```haxe
@:channel("todo:*")
class TodoChannel {
    @:onJoin(TodoUpdates)
    function joinTodoChannel(topic: String, payload: JoinPayload, socket: Socket): JoinResult {
        // Auto-subscribes to TodoUpdates PubSub topic
        // Validates topic format matches "todo:*" pattern
        return Ok(socket);
    }
    
    @:handle("new_todo", TodoCreated)
    function handleNewTodo(payload: NewTodoPayload, socket: Socket): HandleResult {
        var todo = Todo.create(payload);
        // Auto-broadcasts TodoCreated(todo) to PubSub
        return Reply({status: "ok", todo: todo}, socket);
    }
}
```

**Generated Output**:
```haxe
defmodule TodoAppWeb.TodoChannel do
  use Phoenix.Channel
  
  def join("todo:" <> _todo_id, payload, socket) do
    Phoenix.PubSub.subscribe(TodoApp.PubSub, "todo:updates")
    {:ok, socket}
  end
  
  def handle_in("new_todo", payload, socket) do
    case Todo.create(payload) do
      {:ok, todo} ->
        Phoenix.PubSub.broadcast("todo:updates", %{type: "todo_created", todo: todo})
        {:reply, %{status: "ok", todo: todo}, socket}
      {:error, reason} ->
        {:reply, %{status: "error", reason: reason}, socket}
    end
  end
end
```

**Implementation Strategy**:
- Generate Elixir channel modules from Haxe class definitions
- Integrate with existing PubSub type system
- Validate topic patterns and message types

**Benefits**:
- üåê **Real-time features**: Type-safe WebSocket communication
- üîó **PubSub integration**: Seamless connection between channels and LiveView
- üì± **Mobile support**: Enable mobile apps with same type safety

**Priority**: Low - Not needed for basic LiveView apps

---

## Phase 7: Compile-Time Topic Registry & Validation

**Status**: üîÆ **Future Enhancement**

**Goal**: Global validation of all PubSub usage at compile-time.

```haxe
// Compiler validates at build time:
@:validate macro function broadcast(topic: PubSubTopic, message: PubSubMessageType) {
    // Check 1: Topic exists in registry
    if (!TopicRegistry.hasTopicType(topic)) {
        Context.error("Unknown topic: " + topic, Context.currentPos());
    }
    
    // Check 2: Message compatible with topic
    if (!TopicRegistry.isMessageValidForTopic(topic, message)) {
        Context.error("Message " + message + " not valid for topic " + topic, Context.currentPos());
    }
    
    // Check 3: All required fields present
    validateMessageStructure(message);
    
    return buildBroadcastCall(topic, message);
}
```

**Compile-Time Errors**:
```haxe
SafePubSub.broadcast(UserActivity, TodoCreated(todo));
//                   ^^^^^^^^^^^^  ^^^^^^^^^^^^
// Error: TodoCreated message not valid for UserActivity topic
// Suggestion: Use TodoUpdates topic or UserOnline/UserOffline messages

SafePubSub.broadcast(TodoUpdates, TodoCreated(null));
//                                             ^^^^
// Error: TodoCreated requires non-null todo parameter
// Suggestion: Provide valid Todo object
```

**Implementation Strategy**:
- Build-time macro that analyzes all PubSub usage
- Maintain global registry of topic/message relationships
- Generate helpful error messages with suggestions

**Benefits**:
- üîç **Global validation**: Catch mismatched topics/messages anywhere in codebase
- üí° **Smart suggestions**: Helpful error messages guide correct usage
- üìä **Usage analysis**: Track which topics/messages are actually used

**Priority**: Low - Nice for large codebases

---

## Phase 8: PubSub Analytics & Monitoring

**Status**: üîÆ **Future Enhancement**

**Goal**: Automatic metrics collection and monitoring for PubSub usage.

```haxe
@:analytics
enum PubSubTopic {
    @:track(["creation_rate", "user_engagement"])
    TodoUpdates;
    
    @:track(["active_users", "session_duration"])  
    UserActivity;
    
    @:track(["error_rate", "alert_frequency"])
    SystemNotifications;
}
```

**Generated Output**:
```elixir
# Auto-generated Phoenix telemetry events
defmodule PubSubAnalytics do
  def track_broadcast(topic, message_type) do
    :telemetry.execute([:pubsub, :broadcast], %{count: 1}, %{
      topic: topic,
      message_type: message_type,
      timestamp: System.system_time(:microsecond)
    })
  end
end

# Usage metrics dashboard queries
def todo_creation_rate do
  from t in "telemetry_events"
  where t.event == [:pubsub, :broadcast] and 
        t.metadata["topic"] == "todo:updates" and
        t.metadata["message_type"] == "todo_created"
  group_by fragment("date_trunc('hour', ?)", t.inserted_at)
  select %{hour: fragment("date_trunc('hour', ?)", t.inserted_at), count: count()}
end
```

**Implementation Strategy**:
- Metadata-driven telemetry event generation
- Integration with Phoenix LiveDashboard
- Automatic dashboard queries for common metrics

**Benefits**:
- üìà **Performance monitoring**: Track PubSub message volume and patterns
- üéØ **User behavior insights**: Understand how features are used
- üö® **Error detection**: Automatic alerts for unusual patterns

**Priority**: Very Low - Production monitoring feature

---

## Implementation Priority & Timeline

### **Phase 1: Immediate (Current Sprint)**
- ‚úÖ **Simple Type-Safe Enums**: Already implemented
- üîÑ **Complete TodoLive Migration**: Replace all raw PubSub calls

### **Phase 2: Next Sprint (High Impact)**
- **Message Pattern Matching Macro**: Very common use case
- **Auto-Broadcasting Method Decorator**: Reduces boilerplate significantly

### **Phase 3: Future Sprints (Medium Impact)**  
- **Declaration-Based Topic Generation**: Nice ergonomic improvement
- **LiveView Event Binding**: Combines well with broadcasting decorator

### **Phase 4: Long-term (Low Priority)**
- **Channel Integration**: Only needed for real-time mobile features
- **Compile-Time Registry**: Useful for large codebases only
- **Analytics & Monitoring**: Production-grade feature

## Success Metrics

### **Developer Experience**
- ‚úÖ **Zero typo-related runtime errors**: All topic/message typos caught at compile-time
- ‚úÖ **Excellent IntelliSense**: IDE shows all available options with parameter hints
- ‚úÖ **Reduced boilerplate**: Less repetitive PubSub handling code

### **Code Quality**
- ‚úÖ **Type safety**: 100% compile-time validation of PubSub operations
- ‚úÖ **Maintainability**: Single source of truth for topics and message types
- ‚úÖ **Testability**: Easier to mock and test PubSub interactions

### **Performance**
- ‚úÖ **Zero runtime overhead**: All validation happens at compile-time
- ‚úÖ **Better error handling**: Proper Result<T,E> patterns throughout
- ‚úÖ **Faster development**: Immediate feedback instead of runtime debugging

## Conclusion

This roadmap transforms raw string-based PubSub operations into a fully type-safe system that showcases Haxe's advantages over traditional Elixir development. Each phase builds upon the previous, starting with simple but powerful type safety and evolving into sophisticated code generation and analysis tools.

The key insight is that **Phase 1 alone provides 80% of the benefits** - compile-time safety, IntelliSense support, and exhaustiveness checking - with minimal complexity. Advanced phases provide ergonomic improvements but aren't essential for the core value proposition.