# Reflaxe API Reference for Elixir Compiler Development

## Critical Preprocessors API

### Available Preprocessors (from ExpressionPreprocessor.hx)

```haxe
enum ExpressionPreprocessor {
    SanitizeEverythingIsExpression(options)     // Converts Haxe's "everything is expression" to imperative style
    RemoveTemporaryVariables(mode)               // Removes unnecessary temporaries like _g, _g1, _g2
    PreventRepeatVariables(options)              // Ensures unique variable names
    WrapLambdaCaptureVariablesInArray(options)   // Handles lambda captures
    RemoveSingleExpressionBlocks                 // Simplifies single-expression blocks
    RemoveConstantBoolIfs                        // Eliminates constant conditionals
    RemoveUnnecessaryBlocks                      // Removes redundant blocks
    RemoveReassignedVariableDeclarations         // Optimizes variable declarations
    RemoveLocalVariableAliases                   // Eliminates variable aliases
    MarkUnusedVariables                          // Marks unused variables with metadata
    Custom(preprocessor)                         // Custom preprocessor implementation
}
```

### Default Preprocessor List (ExpressionPreprocessorHelper.defaults())
```haxe
[
    SanitizeEverythingIsExpression({}),
    PreventRepeatVariables({}),
    RemoveSingleExpressionBlocks,
    RemoveConstantBoolIfs,
    RemoveUnnecessaryBlocks,
    RemoveReassignedVariableDeclarations,
    RemoveLocalVariableAliases,
    MarkUnusedVariables,
]
```

### Key Preprocessor: RemoveTemporaryVariables

**Purpose**: Removes compiler-generated temporaries that make code unreadable

**Mode Options**:
- `RemoveTemporaryVariablesMode` - Controls how aggressive the removal is

**What it removes**:
- Variables like `_g`, `_g1`, `_g2` (generated by Haxe desugaring)
- `temp_array` and similar temporary holders
- Unnecessary intermediate variables

### Key Preprocessor: MarkUnusedVariables

**Purpose**: Adds metadata to unused variables

**How it works**:
1. Traverses AST to find variable declarations
2. Tracks variable usage
3. Marks unused variables with `-reflaxe.unused` metadata
4. Multiple passes until no more unused variables found

**Key methods**:
```haxe
MarkUnusedVariablesImpl.mark(list: Array<TypedExpr>): Array<TypedExpr>
```

## BaseCompiler Configuration

### BaseCompilerOptions

```haxe
class BaseCompilerOptions {
    var expressionPreprocessors: Null<Array<ExpressionPreprocessor>>;
    // If null, uses ExpressionPreprocessorHelper.defaults()
}
```

### Enabling Preprocessors in ElixirCompiler

```haxe
class ElixirCompiler extends BaseCompiler {
    public function new() {
        super();
        
        // Option 1: Use defaults (includes most optimizations)
        options.expressionPreprocessors = null; // Uses defaults
        
        // Option 2: Custom list with specific preprocessors
        options.expressionPreprocessors = [
            SanitizeEverythingIsExpression({}),
            RemoveTemporaryVariables(Full),      // Remove all temporaries
            PreventRepeatVariables({}),
            RemoveUnnecessaryBlocks,
            RemoveLocalVariableAliases,
            MarkUnusedVariables
        ];
    }
}
```

## How Preprocessors Work

### Processing Flow
1. **Before compilation**: Preprocessors run on TypedExpr AST
2. **ClassFuncData**: Contains expression and metadata
3. **Transformation**: Each preprocessor modifies the AST
4. **Result**: Cleaner AST passed to compiler

### Example: RemoveTemporaryVariables in Action

**Before**:
```haxe
// Haxe desugared code
{
    temp_array = null;
    _g = [];
    _g1 = 0;
    _g2 = numbers;
    while (_g1 < _g2.length) {
        var item = _g2[_g1];
        _g.push(item * 2);
        _g1++;
    }
    temp_array = _g;
}
```

**After RemoveTemporaryVariables**:
```haxe
// Cleaner structure for compilation
{
    var result = [];
    var i = 0;
    while (i < numbers.length) {
        var item = numbers[i];
        result.push(item * 2);
        i++;
    }
}
```

## Critical API: ClassFuncData

```haxe
class ClassFuncData {
    var expr: Null<TypedExpr>;              // The expression to process
    var args: Array<FunctionArgument>;       // Function arguments
    
    function setExpr(e: TypedExpr): Void;    // Update expression
    function setExprList(list: Array<TypedExpr>): Void;
    function getOrFindVariableUsageCount(): Map<String, Int>;
    function getAllVariableNames(compiler: BaseCompiler): Array<String>;
}
```

## Using Preprocessors for Optimization

### Step 1: Check Current Configuration
```haxe
// In ElixirCompiler constructor
trace("Current preprocessors: " + options.expressionPreprocessors);
```

### Step 2: Enable Optimizations
```haxe
// Enable full optimization
options.expressionPreprocessors = [
    SanitizeEverythingIsExpression({}),
    RemoveTemporaryVariables(Full),  // Most aggressive mode
    PreventRepeatVariables({}),
    RemoveSingleExpressionBlocks,
    RemoveConstantBoolIfs,
    RemoveUnnecessaryBlocks,
    RemoveReassignedVariableDeclarations,
    RemoveLocalVariableAliases,
    MarkUnusedVariables
];
```

### Step 3: Handle Marked Variables
```haxe
// In compileExpression, check for unused metadata
case TVar(v, expr):
    if (v.meta.has("-reflaxe.unused")) {
        // Skip generating this variable
        return expr != null ? compileExpression(expr) : "";
    }
    // Normal variable compilation
```

## Why This Matters for Elixir

### Problem: Haxe Desugaring Creates Ugly Code
- Array methods become while loops with `_g` variables
- For-in loops create temporary counters
- Lambda expressions generate unnecessary wrappers

### Solution: Preprocessors + Re-sugaring
1. **Preprocessors clean the AST** before we compile
2. **Re-sugaring detects patterns** and generates idiomatic code
3. **Result**: Clean, readable Elixir without temporaries

### Example Transformation Pipeline

```
Haxe: numbers.map(n -> n * 2)
    ↓ (Haxe desugaring)
Complex while loop with _g, _g1, _g2, temp_array
    ↓ (RemoveTemporaryVariables preprocessor)
Cleaner while loop structure
    ↓ (ElixirCompiler re-sugaring)
Enum.map(numbers, fn item -> item * 2 end)
```

## Key Insight: Work at AST Level

**DON'T**: Try to clean up generated strings
**DO**: Use preprocessors to clean AST before generating strings

The preprocessors operate on TypedExpr, giving us:
- Type safety
- Reliable transformations
- No regex/string manipulation bugs
- Composable optimization passes

## Implementation Checklist

- [ ] Verify BaseCompiler inheritance includes preprocessor support
- [ ] Configure expressionPreprocessors in constructor
- [ ] Handle `-reflaxe.unused` metadata in variable compilation
- [ ] Test with RemoveTemporaryVariables enabled
- [ ] Verify output has no `_g` variables or `temp_array`
- [ ] Document which preprocessors are enabled and why