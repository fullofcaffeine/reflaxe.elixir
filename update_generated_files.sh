#!/bin/bash

# Update _GeneratedFiles.json files to reflect snake_case naming
# Generated by Claude Code on 2025-01-22

set -e  # Exit on any error

echo "üîß Updating _GeneratedFiles.json files for snake_case naming"

# Function to convert PascalCase to snake_case
pascal_to_snake() {
    echo "$1" | sed 's/\([A-Z]\)/_\1/g' | sed 's/^_//' | tr '[:upper:]' '[:lower:]'
}

# Initialize counters
updated_count=0
errors=()

# Find all _GeneratedFiles.json files
while IFS= read -r json_file; do
    if [[ -z "$json_file" ]]; then
        continue
    fi
    
    echo "üîç Processing: $json_file"
    
    # Create backup
    cp "$json_file" "$json_file.backup"
    
    # Read the JSON and update PascalCase .ex files to snake_case
    # This handles the common pattern where .ex files are listed in the JSON
    if python3 -c "
import json
import re
import sys

def pascal_to_snake(name):
    # Convert PascalCase to snake_case
    s1 = re.sub('([A-Z]+)([A-Z][a-z])', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

try:
    with open('$json_file', 'r') as f:
        data = json.load(f)
    
    changes_made = False
    
    # Update the JSON structure recursively
    def update_filenames(obj):
        global changes_made
        if isinstance(obj, dict):
            new_obj = {}
            for key, value in obj.items():
                new_key = key
                # If key is a .ex filename starting with uppercase, convert it
                if key.endswith('.ex') and key[0].isupper() and '/' not in key:
                    new_key = pascal_to_snake(key)
                    if new_key != key:
                        changes_made = True
                        print(f'   üìù Key: {key} ‚Üí {new_key}')
                
                new_obj[new_key] = update_filenames(value)
            return new_obj
        elif isinstance(obj, list):
            new_list = []
            for item in obj:
                if isinstance(item, str) and item.endswith('.ex') and item[0].isupper() and '/' not in item:
                    new_item = pascal_to_snake(item)
                    if new_item != item:
                        changes_made = True
                        print(f'   üìù Item: {item} ‚Üí {new_item}')
                    new_list.append(new_item)
                else:
                    new_list.append(update_filenames(item))
            return new_list
        else:
            return obj
    
    updated_data = update_filenames(data)
    
    if changes_made:
        with open('$json_file', 'w') as f:
            json.dump(updated_data, f, indent=2)
        print(f'   ‚úÖ Updated: $json_file')
        sys.exit(0)  # Success
    else:
        print(f'   ‚è≠Ô∏è  No changes needed: $json_file')
        sys.exit(1)  # No changes (not an error)
    
except Exception as e:
    print(f'   ‚ùå Error processing $json_file: {e}')
    sys.exit(2)  # Error
"; then
        ((updated_count++))
    elif [[ $? -eq 2 ]]; then
        errors+=("Error processing: $json_file")
        # Restore backup on error
        mv "$json_file.backup" "$json_file"
    else
        # No changes needed (exit code 1), remove backup
        rm "$json_file.backup"
    fi
    
done < <(find test/tests -name "_GeneratedFiles.json" -path "*/intended/*")

echo ""
echo "üìà Update Summary:"
echo "   ‚úÖ Successfully updated: $updated_count files"
echo "   ‚ùå Errors: ${#errors[@]} files"

if [[ ${#errors[@]} -gt 0 ]]; then
    echo ""
    echo "üö® Errors encountered:"
    for error in "${errors[@]}"; do
        echo "   - $error"
    done
fi

echo ""
echo "üß™ Next: Run tests to verify all fixes"
echo "Run: npm test"