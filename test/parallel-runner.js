// Generated by Haxe 4.3.7
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static rpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		buf_b += s == null ? "null" : "" + s;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
}
haxe_io_Bytes.__name__ = true;
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = true;
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
class haxe_io_Input {
}
haxe_io_Input.__name__ = true;
class haxe_io_Output {
}
haxe_io_Output.__name__ = true;
class haxe_io_Path {
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		let _g2 = paths;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		let paths1 = _g;
		if(paths1.length == 0) {
			return "";
		}
		let path = paths1[0];
		let _g3 = 1;
		let _g4 = paths1.length;
		while(_g3 < _g4) {
			let i = _g3++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g_offset = 0;
		let _g_s = tmp;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
class js_node_KeyValue {
	static get_key(this1) {
		return this1[0];
	}
	static get_value(this1) {
		return this1[1];
	}
}
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
class js_node_stream_WritableNewOptionsAdapter {
	static from(options) {
		if(!Object.prototype.hasOwnProperty.call(options,"final")) {
			Object.defineProperty(options,"final",{ get : function() {
				return options.final_;
			}});
		}
		return options;
	}
}
class js_node_url_URLSearchParamsEntry {
	static _new(name,value) {
		return [name,value];
	}
	static get_name(this1) {
		return this1[0];
	}
	static get_value(this1) {
		return this1[1];
	}
}
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _g ) {
			return false;
		}
	}
	static isDirectory(path) {
		try {
			return js_node_Fs.statSync(path).isDirectory();
		} catch( _g ) {
			return false;
		}
	}
}
sys_FileSystem.__name__ = true;
class sys_io_FileInput extends haxe_io_Input {
	constructor(fd) {
		super();
		this.hasReachedEof = false;
		this.fd = fd;
		this.pos = 0;
	}
	throwEof() {
		this.hasReachedEof = true;
		throw haxe_Exception.thrown(new haxe_io_Eof());
	}
	readByte() {
		let buf = js_node_buffer_Buffer.alloc(1);
		let bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				this.hasReachedEof = true;
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
			throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
		}
		if(bytesRead == 0) {
			this.hasReachedEof = true;
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	readBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		let bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				this.hasReachedEof = true;
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
			throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
		}
		if(bytesRead == 0) {
			this.hasReachedEof = true;
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
	seek(p,pos) {
		this.hasReachedEof = false;
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	tell() {
		return this.pos;
	}
	eof() {
		return this.hasReachedEof;
	}
}
sys_io_FileInput.__name__ = true;
class sys_io_FileOutput extends haxe_io_Output {
	constructor(fd) {
		super();
		this.fd = fd;
		this.pos = 0;
	}
	writeByte(b) {
		let buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	writeBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		let wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
	seek(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	tell() {
		return this.pos;
	}
}
sys_io_FileOutput.__name__ = true;
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__:true,__constructs__:null
	,SeekBegin: {_hx_name:"SeekBegin",_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_name:"SeekCur",_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_name:"SeekEnd",_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
sys_io_FileSeek.__constructs__ = [sys_io_FileSeek.SeekBegin,sys_io_FileSeek.SeekCur,sys_io_FileSeek.SeekEnd];
class test_ParallelTestRunnerNode {
	static main() {
		let args = process.argv.slice(2);
		let _g = 0;
		while(_g < args.length) {
			let arg = args[_g];
			++_g;
			if(arg == "update-intended") {
				test_ParallelTestRunnerNode.updateIntended = true;
			} else if(arg.startsWith("test=")) {
				test_ParallelTestRunnerNode.specificTests.push(HxOverrides.substr(arg,5,null));
			} else if(arg == "show-output") {
				test_ParallelTestRunnerNode.showOutput = true;
			} else if(arg == "no-details") {
				test_ParallelTestRunnerNode.noDetails = true;
			} else if(arg == "help") {
				test_ParallelTestRunnerNode.showHelp();
				return;
			}
		}
		let tests = test_ParallelTestRunnerNode.specificTests.length > 0 ? test_ParallelTestRunnerNode.specificTests : test_ParallelTestRunnerNode.getTestDirectories();
		test_ParallelTestRunnerNode.totalTests = tests.length;
		console.log("\nüöÄ Running " + test_ParallelTestRunnerNode.totalTests + " test(s) with up to " + test_ParallelTestRunnerNode.WORKER_COUNT + " parallel workers...");
		if(test_ParallelTestRunnerNode.totalTests > 20) {
			let estimatedTime = Math.ceil(test_ParallelTestRunnerNode.totalTests / test_ParallelTestRunnerNode.WORKER_COUNT * 5);
			console.log("‚è±Ô∏è  Estimated time: ~" + estimatedTime + " seconds (compilation takes time)\n");
		} else {
			console.log("");
		}
		test_ParallelTestRunnerNode.runTestsParallel(tests).then(function(results) {
			test_ParallelTestRunnerNode.printResults(results);
			let exitCode = test_ParallelTestRunnerNode.failedTests.length > 0 ? 1 : 0;
			return process.exit(exitCode);
		}).catch(function(err) {
			console.error("‚ùå ERROR:",err);
			return process.exit(1);
		});
	}
	static showHelp() {
		console.log("\nüìö Reflaxe.Elixir Parallel Test Runner (Node.js)\n\nUsage: node parallel-runner.js [options]\n\nOptions:\n  help                Show this help message\n  test=NAME           Run only the specified test\n  update-intended     Update the intended output files\n  show-output         Show compilation output\n  no-details          Don't show detailed differences\n\nExamples:\n  node parallel-runner.js                    # Run all tests\n  node parallel-runner.js test=arrays        # Run specific test\n  node parallel-runner.js update-intended    # Update intended outputs\n");
	}
	static runTestsParallel(tests) {
		let batches = [];
		let currentBatch = [];
		let _g = 0;
		while(_g < tests.length) {
			let test = tests[_g];
			++_g;
			currentBatch.push(test);
			if(currentBatch.length >= test_ParallelTestRunnerNode.WORKER_COUNT) {
				batches.push(currentBatch);
				currentBatch = [];
			}
		}
		if(currentBatch.length > 0) {
			batches.push(currentBatch);
		}
		let allResults = [];
		let promise = Promise.resolve(null);
		let _g1 = 0;
		while(_g1 < batches.length) {
			let batch = batches[_g1];
			++_g1;
			promise = promise.then(function(_) {
				let result = new Array(batch.length);
				let _g = 0;
				let _g1 = batch.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = test_ParallelTestRunnerNode.runSingleTest(batch[i]);
				}
				let batchPromises = result;
				return Promise.all(batchPromises).then(function(results) {
					let _g = 0;
					while(_g < results.length) {
						let result = results[_g];
						++_g;
						allResults.push(result);
						test_ParallelTestRunnerNode.completedTests++;
						test_ParallelTestRunnerNode.printProgress(result);
					}
					return null;
				});
			});
		}
		return promise.then(function(_) {
			return allResults;
		});
	}
	static runSingleTest(testName) {
		return new Promise(function(resolve,reject) {
			let testPath = js_node_Path.join(test_ParallelTestRunnerNode.TEST_DIR,testName);
			let outputDir = test_ParallelTestRunnerNode.updateIntended ? "intended" : "out";
			let startTime = new Date().getTime();
			let args = ["-D","elixir_output=" + outputDir,"-D","reflaxe.dont_output_metadata_id","compile.hxml"];
			let options = { cwd : testPath, timeout : test_ParallelTestRunnerNode.TIMEOUT_MS, shell : false};
			let stdout = "";
			let stderr = "";
			let timedOut = false;
			let proc = js_node_ChildProcess.spawn("haxe",args,options);
			let timeoutId = global.setTimeout(function() {
				timedOut = true;
				proc.kill();
			},test_ParallelTestRunnerNode.TIMEOUT_MS);
			proc.stdout.on("data",function(data) {
				stdout += data.toString();
				return stdout;
			});
			proc.stderr.on("data",function(data) {
				stderr += data.toString();
				return stderr;
			});
			proc.on("close",function(code,signal) {
				global.clearTimeout(timeoutId);
				let duration = new Date().getTime() - startTime;
				if(timedOut) {
					resolve({ name : testName, success : false, duration : duration, message : "Test timed out after " + test_ParallelTestRunnerNode.TIMEOUT_MS + "ms"});
				} else if(code == 0) {
					if(!test_ParallelTestRunnerNode.updateIntended) {
						let success = test_ParallelTestRunnerNode.compareOutput(testName);
						resolve({ name : testName, success : success, duration : duration, message : success ? null : "Output does not match intended"});
					} else {
						resolve({ name : testName, success : true, duration : duration, message : null});
					}
				} else {
					if(!test_ParallelTestRunnerNode.failedTests.includes(testName)) {
						test_ParallelTestRunnerNode.failedTests.push(testName);
					}
					resolve({ name : testName, success : false, duration : duration, message : "Compilation failed (exit code: " + code + ")\n" + stderr});
				}
			});
			proc.on("error",function(err) {
				global.clearTimeout(timeoutId);
				let duration = new Date().getTime() - startTime;
				if(!test_ParallelTestRunnerNode.failedTests.includes(testName)) {
					test_ParallelTestRunnerNode.failedTests.push(testName);
				}
				resolve({ name : testName, success : false, duration : duration, message : "Process error: " + Std.string(err)});
			});
		});
	}
	static compareOutput(testName) {
		let outDir = js_node_Path.join(test_ParallelTestRunnerNode.TEST_DIR,testName,"out");
		let intendedDir = js_node_Path.join(test_ParallelTestRunnerNode.TEST_DIR,testName,"intended");
		if(!js_node_Fs.existsSync(intendedDir)) {
			return false;
		}
		return test_ParallelTestRunnerNode.compareDirectories(outDir,intendedDir);
	}
	static compareDirectories(dir1,dir2) {
		if(!js_node_Fs.existsSync(dir1) || !js_node_Fs.existsSync(dir2)) {
			return false;
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = js_node_Fs.readdirSync(dir1);
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v.endsWith(".ex")) {
				_g.push(v);
			}
		}
		let files1 = _g;
		let _g3 = [];
		let _g4 = 0;
		let _g5 = js_node_Fs.readdirSync(dir2);
		while(_g4 < _g5.length) {
			let v = _g5[_g4];
			++_g4;
			if(v.endsWith(".ex")) {
				_g3.push(v);
			}
		}
		let files2 = _g3;
		if(files1.length != files2.length) {
			return false;
		}
		files1.sort(function(a,b) {
			if(a < b) {
				return -1;
			} else {
				return 1;
			}
		});
		files2.sort(function(a,b) {
			if(a < b) {
				return -1;
			} else {
				return 1;
			}
		});
		let _g6 = 0;
		let _g7 = files1.length;
		while(_g6 < _g7) {
			let i = _g6++;
			if(files1[i] != files2[i]) {
				return false;
			}
			let content1 = js_node_Fs.readFileSync(js_node_Path.join(dir1,files1[i]),"utf8");
			let content2 = js_node_Fs.readFileSync(js_node_Path.join(dir2,files2[i]),"utf8");
			if(content1 != content2) {
				return false;
			}
		}
		return true;
	}
	static getTestDirectories() {
		let items = js_node_Fs.readdirSync(test_ParallelTestRunnerNode.TEST_DIR);
		let _g = [];
		let _g1 = 0;
		let _g2 = items;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			let path = js_node_Path.join(test_ParallelTestRunnerNode.TEST_DIR,v);
			if(js_node_Fs.statSync(path).isDirectory() && js_node_Fs.existsSync(js_node_Path.join(path,"compile.hxml"))) {
				_g.push(v);
			}
		}
		let filtered = _g;
		filtered.sort(function(a,b) {
			if(a < b) {
				return -1;
			} else {
				return 1;
			}
		});
		return filtered;
	}
	static generateProgressBar(percent) {
		let width = 20;
		let filled = Math.floor(width * percent / 100);
		let empty = width - filled;
		return "[" + StringTools.rpad("","‚ñà",filled) + StringTools.rpad("","‚ñë",empty) + "]";
	}
	static printProgress(result) {
		let percent = Math.round(test_ParallelTestRunnerNode.completedTests / test_ParallelTestRunnerNode.totalTests * 100);
		let status = result.success ? "‚úÖ" : "‚ùå";
		let ms = Math.round(result.duration);
		let progressBar = test_ParallelTestRunnerNode.generateProgressBar(percent);
		console.log("" + progressBar + " [" + percent + "%] " + status + " " + result.name + " (" + ms + "ms)");
		if(!result.success && result.message != null && test_ParallelTestRunnerNode.showOutput && !test_ParallelTestRunnerNode.noDetails) {
			let lines = result.message.split("\n");
			let _g = 0;
			let _g1 = Math.floor(Math.min(3,lines.length));
			while(_g < _g1) {
				let i = _g++;
				console.log("    " + lines[i]);
			}
			if(lines.length > 3) {
				console.log("    ... (" + (lines.length - 3) + " more lines)");
			}
		}
	}
	static printResults(results) {
		let _g = [];
		let _g1 = 0;
		let _g2 = results;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(!v.success) {
				_g.push(v);
			}
		}
		let failed = _g;
		let passed = results.length - failed.length;
		console.log("\n" + StringTools.rpad("","‚ïê",50));
		console.log("üìä Test Results: " + passed + "/" + results.length + " passed");
		let totalTime = 0.0;
		let _g3 = 0;
		while(_g3 < results.length) {
			let r = results[_g3];
			++_g3;
			totalTime += r.duration;
		}
		console.log("‚è±Ô∏è  Total Time: " + Math.round(totalTime / 1000) + "s");
		if(failed.length > 0) {
			console.log("\n‚ùå FAILED: " + failed.length + " test(s)");
			let _g = 0;
			while(_g < failed.length) {
				let test = failed[_g];
				++_g;
				console.log("  ‚Ä¢ " + test.name);
				if(test.message != null && !test_ParallelTestRunnerNode.showOutput) {
					let firstLine = test.message.split("\n")[0];
					if(firstLine.length > 0) {
						console.log("    " + HxOverrides.substr(firstLine,0,80) + (firstLine.length > 80 ? "..." : ""));
					}
				}
			}
		} else {
			console.log("\n‚úÖ SUCCESS: All tests passed! üéâ");
		}
		let sequentialEstimate = results.length * 3.7;
		let speedup = Math.round((sequentialEstimate - totalTime / 1000) / sequentialEstimate * 100);
		if(speedup > 0) {
			console.log("‚ö° Performance: ~" + speedup + "% faster than sequential execution");
		}
	}
}
test_ParallelTestRunnerNode.__name__ = true;
class test_TestCommon {
	static shouldExcludeFromComparison(name) {
		if(!(name == "_build" || name == ".mix" || name == "deps" || name == "mix.exs" || name == "mix.lock" || name == "erl_crash.dump" || name == ".fetch")) {
			return name.endsWith(".beam");
		} else {
			return true;
		}
	}
	static getAllFiles(dir,prefix) {
		if(prefix == null) {
			prefix = "";
		}
		if(!sys_FileSystem.exists(dir)) {
			return [];
		}
		let files = [];
		let _g = 0;
		let _g1 = js_node_Fs.readdirSync(dir);
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			if(test_TestCommon.shouldExcludeFromComparison(item)) {
				continue;
			}
			let path = haxe_io_Path.join([dir,item]);
			let relPath = prefix.length > 0 ? haxe_io_Path.join([prefix,item]) : item;
			if(sys_FileSystem.isDirectory(path)) {
				let _g = 0;
				let _g1 = test_TestCommon.getAllFiles(path,relPath);
				while(_g < _g1.length) {
					let subFile = _g1[_g];
					++_g;
					files.push(subFile);
				}
			} else {
				files.push(relPath);
			}
		}
		return files;
	}
	static normalizeContent(content,fileName) {
		if(fileName == null) {
			fileName = "";
		}
		let normalized = StringTools.trim(StringTools.replace(content,"\r\n","\n"));
		normalized = StringTools.replace(normalized,"\r","\n");
		if(fileName == "_GeneratedFiles.json") {
			try {
				let lines = normalized.split("\n");
				let filteredLines = [];
				let idRegex = new EReg("^\\s*\"id\"\\s*:\\s*\\d+,?$","");
				let _g = 0;
				while(_g < lines.length) {
					let line = lines[_g];
					++_g;
					if(!idRegex.match(line)) {
						filteredLines.push(line);
					}
				}
				normalized = filteredLines.join("\n");
			} catch( _g ) {
			}
		}
		let lines = normalized.split("\n");
		let result = new Array(lines.length);
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = StringTools.rtrim(lines[i]);
		}
		lines = result;
		while(lines.length > 0 && lines[lines.length - 1] == "") lines.pop();
		return lines.join("\n");
	}
	static compareDirectoriesDetailed(actualDir,intendedDir) {
		let differences = [];
		let intendedFiles = test_TestCommon.getAllFiles(intendedDir);
		let actualFiles = test_TestCommon.getAllFiles(actualDir);
		let _g = 0;
		while(_g < intendedFiles.length) {
			let file = intendedFiles[_g];
			++_g;
			let intendedPath = haxe_io_Path.join([intendedDir,file]);
			let actualPath = haxe_io_Path.join([actualDir,file]);
			if(!sys_FileSystem.exists(actualPath)) {
				differences.push("Missing file: " + file);
				continue;
			}
			let intendedContent = test_TestCommon.normalizeContent(js_node_Fs.readFileSync(intendedPath,{ encoding : "utf8"}),file);
			let actualContent = test_TestCommon.normalizeContent(js_node_Fs.readFileSync(actualPath,{ encoding : "utf8"}),file);
			if(intendedContent != actualContent) {
				differences.push("Content differs: " + file);
			}
		}
		let _g1 = 0;
		while(_g1 < actualFiles.length) {
			let file = actualFiles[_g1];
			++_g1;
			if(!intendedFiles.includes(file)) {
				differences.push("Extra file: " + file);
			}
		}
		return differences;
	}
	static compareDirectoriesSimple(actualDir,intendedDir) {
		if(!sys_FileSystem.exists(intendedDir)) {
			return false;
		}
		let intendedFiles = test_TestCommon.getAllFiles(intendedDir);
		let actualFiles = test_TestCommon.getAllFiles(actualDir);
		if(intendedFiles.length != actualFiles.length) {
			return false;
		}
		let _g = 0;
		while(_g < intendedFiles.length) {
			let file = intendedFiles[_g];
			++_g;
			let intendedPath = haxe_io_Path.join([intendedDir,file]);
			let actualPath = haxe_io_Path.join([actualDir,file]);
			if(!sys_FileSystem.exists(actualPath)) {
				return false;
			}
			let intendedContent = test_TestCommon.normalizeContent(js_node_Fs.readFileSync(intendedPath,{ encoding : "utf8"}),file);
			let actualContent = test_TestCommon.normalizeContent(js_node_Fs.readFileSync(actualPath,{ encoding : "utf8"}),file);
			if(intendedContent != actualContent) {
				return false;
			}
		}
		return true;
	}
}
test_TestCommon.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.__name__ = true;
	Array.__name__ = true;
	Date.__name__ = "Date";
}
js_Boot.__toStr = ({ }).toString;
test_ParallelTestRunnerNode.TEST_DIR = "test/tests";
test_ParallelTestRunnerNode.WORKER_COUNT = 8;
test_ParallelTestRunnerNode.TIMEOUT_MS = 30000;
test_ParallelTestRunnerNode.updateIntended = false;
test_ParallelTestRunnerNode.specificTests = [];
test_ParallelTestRunnerNode.showOutput = false;
test_ParallelTestRunnerNode.noDetails = false;
test_ParallelTestRunnerNode.totalTests = 0;
test_ParallelTestRunnerNode.completedTests = 0;
test_ParallelTestRunnerNode.failedTests = [];
test_ParallelTestRunnerNode.main();
})({});
