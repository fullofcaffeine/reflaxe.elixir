class haxe.io.Output {

	public var bigEndian(default,set):Bool;

	function set_bigEndian[Function:(b : Bool) -> Bool]
		[Arg:Bool] [Local b(9694):Bool]
		[Block:Dynamic]
			[Binop:Bool]
				[Field:Bool]
					[Const:haxe.io.Output] this
					[FInstance:Bool]
						haxe.io.Output
						bigEndian:Bool
				=
				[Local b(9694):Bool:Bool]
			[Return:Dynamic] [Local b(9694):Bool:Bool]

	public function writeByte[Function:(c : Int) -> Void]
		[Arg:Int] [Local c(9695):Int]
		[Block:Void]

	public function writeBytes[Function:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
		[Arg:haxe.io.Bytes] [Local b(9696):haxe.io.Bytes]
		[Arg:Int] [Local pos(9697):Int]
		[Arg:Int] [Local len(9698):Int]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Local pos(9697):Int:Int]
							<
							[Const:Int] 0
						||
						[Binop:Bool]
							[Local len(9698):Int:Int]
							<
							[Const:Int] 0
					||
					[Binop:Bool]
						[Binop:Int]
							[Local pos(9697):Int:Int]
							+
							[Local len(9698):Int:Int]
						>
						[Field:Int]
							[Local b(9696):haxe.io.Bytes:haxe.io.Bytes]
							[FInstance:Int]
								haxe.io.Bytes
								length:Int
				[Then:Dynamic] [Block:Dynamic] [Throw:Dynamic] [Const:String] "Invalid parameters"
			[Var k(9699):Int] [Local len(9698):Int:Int]
			[While:Void]
				[Binop:Bool]
					[Local k(9699):Int:Int]
					>
					[Const:Int] 0
				[Block:Int]
					[Call:Void]
						[Field:(c : Int) -> Void]
							[Const:haxe.io.Output] this
							[FInstance:(c : Int) -> Void]
								haxe.io.Output
								writeByte:(c : Int) -> Void
						[Call:Int]
							[Field:(pos : Int) -> Int]
								[Local b(9696):haxe.io.Bytes:haxe.io.Bytes]
								[FInstance:(pos : Int) -> Int]
									haxe.io.Bytes
									get:(pos : Int) -> Int
							[Local pos(9697):Int:Int]
					[Unop:Int]
						++
						Postfix
						[Local pos(9697):Int:Int]
					[Unop:Int]
						--
						Postfix
						[Local k(9699):Int:Int]
			[Return:Dynamic] [Local len(9698):Int:Int]

	public function write[Function:(b : haxe.io.Bytes) -> Void]
		[Arg:haxe.io.Bytes] [Local b(9700):haxe.io.Bytes]
		[Block:Int]
			[Call:Int]
				[Field:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
					[Const:haxe.io.Output] this
					[FInstance:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
						haxe.io.Output
						writeBytes:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int
				[Local b(9700):haxe.io.Bytes:haxe.io.Bytes]
				[Const:Int] 0
				[Field:Int]
					[Local b(9700):haxe.io.Bytes:haxe.io.Bytes]
					[FInstance:Int]
						haxe.io.Bytes
						length:Int

	public function writeInput[Function:(i : haxe.io.Input, ?bufsize : Null<Int>) -> Void]
		[Arg:haxe.io.Input] [Local i(9701):haxe.io.Input]
		[Arg:Null<Int>]
			[Local bufsize(9702):Null<Int>]
			[Const:Null<Int>] null
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local bufsize(9702):Null<Int>:Null<Int>]
					==
					[Const:Null<Int>] null
				[Then:Null<Int>] [Block:Null<Int>]
					[Binop:Null<Int>]
						[Local bufsize(9702):Null<Int>:Null<Int>]
						=
						[Const:Int] 4096
			[Var buf(9703):haxe.io.Bytes]
				[Call:haxe.io.Bytes]
					[Field:(length : Int) -> haxe.io.Bytes]
						[TypeExpr haxe.io.Bytes:Class<haxe.io.Bytes>]
						[FStatic:(length : Int) -> haxe.io.Bytes]
							haxe.io.Bytes
							alloc:(length : Int) -> haxe.io.Bytes
					[Local bufsize(9702):Null<Int>:Null<Int>]
			[While:Void]
				[Const:Bool] true
				[Block:Int]
					[Var len(9704):Int]
						[Call:Int]
							[Field:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
								[Local i(9701):haxe.io.Input:haxe.io.Input]
								[FInstance:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
									haxe.io.Input
									readBytes:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int
							[Local buf(9703):haxe.io.Bytes:haxe.io.Bytes]
							[Const:Int] 0
							[Local bufsize(9702):Null<Int>:Null<Int>]
					[If:Void]
						[Binop:Bool]
							[Local len(9704):Int:Int]
							==
							[Const:Int] 0
						[Then:Dynamic] [Block:Dynamic] [Break:Dynamic]
					[Call:Int]
						[Field:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
							[Const:haxe.io.Output] this
							[FInstance:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int]
								haxe.io.Output
								writeBytes:(b : haxe.io.Bytes, pos : Int, len : Int) -> Int
						[Local buf(9703):haxe.io.Bytes:haxe.io.Bytes]
						[Const:Int] 0
						[Local len(9704):Int:Int]

	public function writeString[Function:(s : String) -> Void]
		[Arg:String] [Local s(9705):String]
		[Block:Void]
			[Var b(9706):haxe.io.Bytes]
				[Call:haxe.io.Bytes]
					[Field:(s : String, ?encoding : Null<haxe.io.Encoding>) -> haxe.io.Bytes]
						[TypeExpr haxe.io.Bytes:Class<haxe.io.Bytes>]
						[FStatic:(s : String, ?encoding : Null<haxe.io.Encoding>) -> haxe.io.Bytes]
							haxe.io.Bytes
							ofString:(s : String, ?encoding : Null<haxe.io.Encoding>) -> haxe.io.Bytes
					[Local s(9705):String:String]
					[Const:Null<haxe.io.Encoding>] null
			[Call:Void]
				[Field:(b : haxe.io.Bytes) -> Void]
					[Const:haxe.io.Output] this
					[FInstance:(b : haxe.io.Bytes) -> Void]
						haxe.io.Output
						write:(b : haxe.io.Bytes) -> Void
				[Local b(9706):haxe.io.Bytes:haxe.io.Bytes]

	public function flush[Function:() -> Void] [Block:Void]

	public function close[Function:() -> Void] [Block:Void]
}