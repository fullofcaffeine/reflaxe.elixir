class Std {

	@:has_untyped
	public static function string<T>[Function:(value : string.T) -> String]
		[Arg:string.T] [Local value(7):string.T]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Ident:(String, string.T) -> Unknown<36>] __elixir__
					[Const:String] "to_string({0})"
					[Local value(7):string.T:string.T]

	@:has_untyped
	public static function parseInt[Function:(str : String) -> Null<Int>]
		[Arg:String] [Local str(55):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<Int>]
					[Ident:(String, String) -> Unknown<37>] __elixir__
					[Const:String] "\n            case Integer.parse({0}) do\n                {num, _} -> num\n                :error -> nil\n            end\n        "
					[Local str(55):String:String]

	@:has_untyped
	public static function parseFloat[Function:(str : String) -> Null<Float>]
		[Arg:String] [Local str(56):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<Float>]
					[Ident:(String, String) -> Unknown<38>] __elixir__
					[Const:String] "\n            case Float.parse({0}) do\n                {num, _} -> num\n                :error -> nil\n            end\n        "
					[Local str(56):String:String]

	@:has_untyped
	public static function is[Function:(value : Dynamic, type : Dynamic) -> Bool]
		[Arg:Dynamic] [Local value(57):Dynamic]
		[Arg:Dynamic] [Local type(58):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Ident:(String, Dynamic, Dynamic) -> Unknown<39>] __elixir__
					[Const:String] "\n            # Convert type to string for comparison\n            type_str = to_string({1})\n            \n            case type_str do\n                \"String\" -> is_binary({0})\n                \"Float\" -> is_float({0})\n                \"Int\" -> is_integer({0})\n                \"Bool\" -> is_boolean({0})\n                \"Array\" -> is_list({0})\n                \"Map\" -> is_map({0})\n                _ ->\n                    # For user-defined types, check if it's a struct with matching __struct__ field\n                    case {0} do\n                        %{__struct__: struct_type} -> struct_type == {1}\n                        # For enums (tagged tuples), check if first element matches the type atom\n                        {tag, _} when is_atom(tag) -> tag == {1}\n                        {tag, _, _} when is_atom(tag) -> tag == {1}\n                        {tag, _, _, _} when is_atom(tag) -> tag == {1}\n                        _ -> false\n                    end\n            end\n        "
					[Local value(57):Dynamic:Dynamic]
					[Local type(58):Dynamic:Dynamic]

	public static inline function isOfType[Function:(value : Dynamic, type : Dynamic) -> Bool]
		[Arg:Dynamic] [Local value(59):Dynamic]
		[Arg:Dynamic] [Local type(60):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(value : Dynamic, type : Dynamic) -> Bool]
						[TypeExpr Std:Class<Std>]
						[FStatic:(value : Dynamic, type : Dynamic) -> Bool]
							Std
							is:(value : Dynamic, type : Dynamic) -> Bool
					[Local value(59):Dynamic:Dynamic]
					[Local type(60):Dynamic:Dynamic]

	@:has_untyped
	public static function random[Function:() -> Float]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Float]
					[Ident:String -> Unknown<40>] __elixir__
					[Const:String] ":rand.uniform()"

	@:has_untyped
	public static function int[Function:(value : Float) -> Int]
		[Arg:Float] [Local value(61):Float]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Int]
					[Ident:(String, Float) -> Unknown<41>] __elixir__
					[Const:String] "trunc({0})"
					[Local value(61):Float:Float]
}