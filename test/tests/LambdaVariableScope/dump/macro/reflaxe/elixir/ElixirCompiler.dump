class reflaxe.elixir.ElixirCompiler extends reflaxe.DirectToStringCompiler {

	public function new[Function:() -> Void]
		[Block:Void]
			[Binop:Map<String, String>]
				[Field:Map<String, String>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Map<String, String>]
						reflaxe.elixir.ElixirCompiler
						globalStructParameterMap:Map<String, String>
				=
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingStructMethod:Bool
				=
				[Const:Bool] false
			[Binop:Null<reflaxe.elixir.helpers.MutabilityInfo>]
				[Field:Null<reflaxe.elixir.helpers.MutabilityInfo>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<reflaxe.elixir.helpers.MutabilityInfo>]
						reflaxe.elixir.ElixirCompiler
						stateThreadingInfo:Null<reflaxe.elixir.helpers.MutabilityInfo>
				=
				[Const:Null<reflaxe.elixir.helpers.MutabilityInfo>] null
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						stateThreadingEnabled:Bool
				=
				[Const:Bool] false
			[Binop:Null<Map<String, Bool>>]
				[Field:Null<Map<String, Bool>>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<Map<String, Bool>>]
						reflaxe.elixir.ElixirCompiler
						liveViewInstanceVars:Null<Map<String, Bool>>
				=
				[Const:Null<Map<String, Bool>>] null
			[Binop:Null<haxe.macro.ClassType>]
				[Field:Null<haxe.macro.ClassType>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<haxe.macro.ClassType>]
						reflaxe.elixir.ElixirCompiler
						currentClassType:Null<haxe.macro.ClassType>
				=
				[Const:Null<haxe.macro.ClassType>] null
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingCaseArm:Bool
				=
				[Const:Bool] false
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingAbstractMethod:Bool
				=
				[Const:Bool] false
			[Binop:Map<String, String>]
				[Field:Map<String, String>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Map<String, String>]
						reflaxe.elixir.ElixirCompiler
						inlineContextMap:Map<String, String>
				=
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
			[Binop:Null<Map<String, String>>]
				[Field:Null<Map<String, String>>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<Map<String, String>>]
						reflaxe.elixir.ElixirCompiler
						variableRenameMap:Null<Map<String, String>>
				=
				[Const:Null<Map<String, String>>] null
			[Binop:Map<String, String>]
				[Field:Map<String, String>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Map<String, String>]
						reflaxe.elixir.ElixirCompiler
						currentFunctionParameterMap:Map<String, String>
				=
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
			[Binop:Array<reflaxe.elixir.SourceMapWriter>]
				[Field:Array<reflaxe.elixir.SourceMapWriter>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Array<reflaxe.elixir.SourceMapWriter>]
						reflaxe.elixir.ElixirCompiler
						pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>
				=
				[ArrayDecl:Array<reflaxe.elixir.SourceMapWriter>]
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						sourceMapOutputEnabled:Bool
				=
				[Const:Bool] false
			[Binop:Null<reflaxe.elixir.SourceMapWriter>]
				[Field:Null<reflaxe.elixir.SourceMapWriter>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
						reflaxe.elixir.ElixirCompiler
						currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
				=
				[Const:Null<reflaxe.elixir.SourceMapWriter>] null
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isInLoopContext:Bool
				=
				[Const:Bool] false
			[Binop:String]
				[Field:String]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:String]
						reflaxe.elixir.ElixirCompiler
						outputDirectory:String
				=
				[Const:String] "lib/"
			[Binop:String]
				[Field:String]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:String]
						reflaxe.elixir.ElixirCompiler
						fileExtension:String
				=
				[Const:String] ".ex"
			[Call:Void] [Const:reflaxe.DirectToStringCompiler] super
			[Binop:reflaxe.elixir.ElixirTyper]
				[Field:reflaxe.elixir.ElixirTyper]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.ElixirTyper]
						reflaxe.elixir.ElixirCompiler
						typer:reflaxe.elixir.ElixirTyper
				=
				[New:reflaxe.elixir.ElixirTyper] reflaxe.elixir.ElixirTyper
			[Binop:reflaxe.elixir.helpers.PatternMatcher]
				[Field:reflaxe.elixir.helpers.PatternMatcher]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PatternMatcher]
						reflaxe.elixir.ElixirCompiler
						patternMatcher:reflaxe.elixir.helpers.PatternMatcher
				=
				[New:reflaxe.elixir.helpers.PatternMatcher] reflaxe.elixir.helpers.PatternMatcher
			[Call:Void]
				[Field:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
					[Field:reflaxe.elixir.helpers.PatternMatcher]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.PatternMatcher]
							reflaxe.elixir.ElixirCompiler
							patternMatcher:reflaxe.elixir.helpers.PatternMatcher
					[FInstance:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
						reflaxe.elixir.helpers.PatternMatcher
						setCompiler:(compiler : reflaxe.elixir.ElixirCompiler) -> Void
				[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.GuardCompiler]
				[Field:reflaxe.elixir.helpers.GuardCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.GuardCompiler]
						reflaxe.elixir.ElixirCompiler
						guardCompiler:reflaxe.elixir.helpers.GuardCompiler
				=
				[New:reflaxe.elixir.helpers.GuardCompiler] reflaxe.elixir.helpers.GuardCompiler
			[Binop:reflaxe.elixir.helpers.PipelineOptimizer]
				[Field:reflaxe.elixir.helpers.PipelineOptimizer]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PipelineOptimizer]
						reflaxe.elixir.ElixirCompiler
						pipelineOptimizer:reflaxe.elixir.helpers.PipelineOptimizer
				=
				[New:reflaxe.elixir.helpers.PipelineOptimizer]
					reflaxe.elixir.helpers.PipelineOptimizer
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ImportOptimizer]
				[Field:reflaxe.elixir.helpers.ImportOptimizer]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ImportOptimizer]
						reflaxe.elixir.ElixirCompiler
						importOptimizer:reflaxe.elixir.helpers.ImportOptimizer
				=
				[New:reflaxe.elixir.helpers.ImportOptimizer]
					reflaxe.elixir.helpers.ImportOptimizer
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.LoopCompiler]
				[Field:reflaxe.elixir.helpers.LoopCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.LoopCompiler]
						reflaxe.elixir.ElixirCompiler
						loopCompiler:reflaxe.elixir.helpers.LoopCompiler
				=
				[New:reflaxe.elixir.helpers.LoopCompiler]
					reflaxe.elixir.helpers.LoopCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.PatternMatchingCompiler]
				[Field:reflaxe.elixir.helpers.PatternMatchingCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PatternMatchingCompiler]
						reflaxe.elixir.ElixirCompiler
						patternMatchingCompiler:reflaxe.elixir.helpers.PatternMatchingCompiler
				=
				[New:reflaxe.elixir.helpers.PatternMatchingCompiler]
					reflaxe.elixir.helpers.PatternMatchingCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.SchemaCompiler]
				[Field:reflaxe.elixir.helpers.SchemaCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.SchemaCompiler]
						reflaxe.elixir.ElixirCompiler
						schemaCompiler:reflaxe.elixir.helpers.SchemaCompiler
				=
				[New:reflaxe.elixir.helpers.SchemaCompiler]
					reflaxe.elixir.helpers.SchemaCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.MigrationCompiler]
				[Field:reflaxe.elixir.helpers.MigrationCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.MigrationCompiler]
						reflaxe.elixir.ElixirCompiler
						migrationCompiler:reflaxe.elixir.helpers.MigrationCompiler
				=
				[New:reflaxe.elixir.helpers.MigrationCompiler]
					reflaxe.elixir.helpers.MigrationCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.LiveViewCompiler]
				[Field:reflaxe.elixir.helpers.LiveViewCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.LiveViewCompiler]
						reflaxe.elixir.ElixirCompiler
						liveViewCompiler:reflaxe.elixir.helpers.LiveViewCompiler
				=
				[New:reflaxe.elixir.helpers.LiveViewCompiler]
					reflaxe.elixir.helpers.LiveViewCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.GenServerCompiler]
				[Field:reflaxe.elixir.helpers.GenServerCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.GenServerCompiler]
						reflaxe.elixir.ElixirCompiler
						genServerCompiler:reflaxe.elixir.helpers.GenServerCompiler
				=
				[New:reflaxe.elixir.helpers.GenServerCompiler]
					reflaxe.elixir.helpers.GenServerCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.MethodCallCompiler]
				[Field:reflaxe.elixir.helpers.MethodCallCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
						reflaxe.elixir.ElixirCompiler
						methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
				=
				[New:reflaxe.elixir.helpers.MethodCallCompiler]
					reflaxe.elixir.helpers.MethodCallCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ReflectionCompiler]
				[Field:reflaxe.elixir.helpers.ReflectionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ReflectionCompiler]
						reflaxe.elixir.ElixirCompiler
						reflectionCompiler:reflaxe.elixir.helpers.ReflectionCompiler
				=
				[New:reflaxe.elixir.helpers.ReflectionCompiler]
					reflaxe.elixir.helpers.ReflectionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
				[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
						reflaxe.elixir.ElixirCompiler
						arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
				=
				[New:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
					reflaxe.elixir.helpers.ArrayOptimizationCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.SubstitutionCompiler]
				[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
						reflaxe.elixir.ElixirCompiler
						substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
				=
				[New:reflaxe.elixir.helpers.SubstitutionCompiler]
					reflaxe.elixir.helpers.SubstitutionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.TempVariableOptimizer]
				[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
						reflaxe.elixir.ElixirCompiler
						tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
				=
				[New:reflaxe.elixir.helpers.TempVariableOptimizer]
					reflaxe.elixir.helpers.TempVariableOptimizer
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.NamingConventionCompiler]
				[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
						reflaxe.elixir.ElixirCompiler
						namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
				=
				[New:reflaxe.elixir.helpers.NamingConventionCompiler]
					reflaxe.elixir.helpers.NamingConventionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.StateManagementCompiler]
				[Field:reflaxe.elixir.helpers.StateManagementCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
						reflaxe.elixir.ElixirCompiler
						stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
				=
				[New:reflaxe.elixir.helpers.StateManagementCompiler]
					reflaxe.elixir.helpers.StateManagementCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.FunctionCompiler]
				[Field:reflaxe.elixir.helpers.FunctionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.FunctionCompiler]
						reflaxe.elixir.ElixirCompiler
						functionCompiler:reflaxe.elixir.helpers.FunctionCompiler
				=
				[New:reflaxe.elixir.helpers.FunctionCompiler]
					reflaxe.elixir.helpers.FunctionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ArrayMethodCompiler]
				[Field:reflaxe.elixir.helpers.ArrayMethodCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ArrayMethodCompiler]
						reflaxe.elixir.ElixirCompiler
						arrayMethodCompiler:reflaxe.elixir.helpers.ArrayMethodCompiler
				=
				[New:reflaxe.elixir.helpers.ArrayMethodCompiler]
					reflaxe.elixir.helpers.ArrayMethodCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.MapToolsCompiler]
				[Field:reflaxe.elixir.helpers.MapToolsCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.MapToolsCompiler]
						reflaxe.elixir.ElixirCompiler
						mapToolsCompiler:reflaxe.elixir.helpers.MapToolsCompiler
				=
				[New:reflaxe.elixir.helpers.MapToolsCompiler]
					reflaxe.elixir.helpers.MapToolsCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ADTMethodCompiler]
				[Field:reflaxe.elixir.helpers.ADTMethodCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ADTMethodCompiler]
						reflaxe.elixir.ElixirCompiler
						adtMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler
				=
				[New:reflaxe.elixir.helpers.ADTMethodCompiler]
					reflaxe.elixir.helpers.ADTMethodCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.YCombinatorCompiler]
				[Field:reflaxe.elixir.helpers.YCombinatorCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.YCombinatorCompiler]
						reflaxe.elixir.ElixirCompiler
						yCombinatorCompiler:reflaxe.elixir.helpers.YCombinatorCompiler
				=
				[New:reflaxe.elixir.helpers.YCombinatorCompiler]
					reflaxe.elixir.helpers.YCombinatorCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.PatternDetectionCompiler]
				[Field:reflaxe.elixir.helpers.PatternDetectionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PatternDetectionCompiler]
						reflaxe.elixir.ElixirCompiler
						patternDetectionCompiler:reflaxe.elixir.helpers.PatternDetectionCompiler
				=
				[New:reflaxe.elixir.helpers.PatternDetectionCompiler]
					reflaxe.elixir.helpers.PatternDetectionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.PatternAnalysisCompiler]
				[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
						reflaxe.elixir.ElixirCompiler
						patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
				=
				[New:reflaxe.elixir.helpers.PatternAnalysisCompiler]
					reflaxe.elixir.helpers.PatternAnalysisCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.TypeResolutionCompiler]
				[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
						reflaxe.elixir.ElixirCompiler
						typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
				=
				[New:reflaxe.elixir.helpers.TypeResolutionCompiler]
					reflaxe.elixir.helpers.TypeResolutionCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.CodeFixupCompiler]
				[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
						reflaxe.elixir.ElixirCompiler
						codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
				=
				[New:reflaxe.elixir.helpers.CodeFixupCompiler]
					reflaxe.elixir.helpers.CodeFixupCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.PipelineAnalyzer]
				[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
						reflaxe.elixir.ElixirCompiler
						pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
				=
				[New:reflaxe.elixir.helpers.PipelineAnalyzer]
					reflaxe.elixir.helpers.PipelineAnalyzer
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.WhileLoopCompiler]
				[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
						reflaxe.elixir.ElixirCompiler
						whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
				=
				[New:reflaxe.elixir.helpers.WhileLoopCompiler]
					reflaxe.elixir.helpers.WhileLoopCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ExpressionVariantCompiler]
				[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
						reflaxe.elixir.ElixirCompiler
						expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
				=
				[New:reflaxe.elixir.helpers.ExpressionVariantCompiler]
					reflaxe.elixir.helpers.ExpressionVariantCompiler
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:reflaxe.elixir.helpers.ExpressionDispatcher]
				[Field:reflaxe.elixir.helpers.ExpressionDispatcher]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ExpressionDispatcher]
						reflaxe.elixir.ElixirCompiler
						expressionDispatcher:reflaxe.elixir.helpers.ExpressionDispatcher
				=
				[New:reflaxe.elixir.helpers.ExpressionDispatcher]
					reflaxe.elixir.helpers.ExpressionDispatcher
					[Const:reflaxe.elixir.ElixirCompiler] this
			[Call:Void]
				[Field:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
					[Field:reflaxe.elixir.helpers.PatternMatcher]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.PatternMatcher]
							reflaxe.elixir.ElixirCompiler
							patternMatcher:reflaxe.elixir.helpers.PatternMatcher
					[FInstance:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
						reflaxe.elixir.helpers.PatternMatcher
						setCompiler:(compiler : reflaxe.elixir.ElixirCompiler) -> Void
				[Const:reflaxe.elixir.ElixirCompiler] this
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						sourceMapOutputEnabled:Bool
				=
				[Binop:Bool]
					[Call:Bool]
						[Field:(s : String) -> Bool]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(s : String) -> Bool]
								haxe.macro.Context
								defined:(s : String) -> Bool
						[Const:String] "source-map"
					||
					[Call:Bool]
						[Field:(s : String) -> Bool]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(s : String) -> Bool]
								haxe.macro.Context
								defined:(s : String) -> Bool
						[Const:String] "debug"
			[Var tmp(34167):reflaxe.preprocessors.ExpressionPreprocessor]
				[Call:reflaxe.preprocessors.ExpressionPreprocessor]
					[Field:(options : reflaxe.preprocessors.implementations.everything_is_expr.EverythingIsExprSanitizerOptions) -> reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:(options : reflaxe.preprocessors.implementations.everything_is_expr.EverythingIsExprSanitizerOptions) -> reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							SanitizeEverythingIsExpression
					[New:reflaxe.preprocessors.implementations.everything_is_expr.EverythingIsExprSanitizerOptions]
						reflaxe.preprocessors.implementations.everything_is_expr.EverythingIsExprSanitizerOptions
						[Const:Null<Bool>] null
						[Const:Null<Bool>] null
						[Const:Null<Bool>] null
						[Const:Null<reflaxe.preprocessors.implementations.everything_is_expr.LambdaWrapType>] null
						[Const:Null<Array<String>>] null
			[Var tmp1(34169):reflaxe.preprocessors.ExpressionPreprocessor]
				[Call:reflaxe.preprocessors.ExpressionPreprocessor]
					[Field:(options : reflaxe.preprocessors.PreventRepeatVariablesOptions) -> reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:(options : reflaxe.preprocessors.PreventRepeatVariablesOptions) -> reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							PreventRepeatVariables
					[New:reflaxe.preprocessors.PreventRepeatVariablesOptions]
						reflaxe.preprocessors.PreventRepeatVariablesOptions
						[Const:Null<Bool>] null
						[Const:Null<Null<Array<String>>>] null
			[Binop:Null<Array<reflaxe.preprocessors.ExpressionPreprocessor>>]
				[Field:Null<Array<reflaxe.preprocessors.ExpressionPreprocessor>>]
					[Field:reflaxe.BaseCompilerOptions]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.BaseCompilerOptions]
							reflaxe.BaseCompiler
							options:reflaxe.BaseCompilerOptions
					[FInstance:Null<Array<reflaxe.preprocessors.ExpressionPreprocessor>>]
						reflaxe.BaseCompilerOptions
						expressionPreprocessors:Null<Array<reflaxe.preprocessors.ExpressionPreprocessor>>
				=
				[ArrayDecl:Array<reflaxe.preprocessors.ExpressionPreprocessor>]
					[Local tmp(34167):reflaxe.preprocessors.ExpressionPreprocessor:reflaxe.preprocessors.ExpressionPreprocessor]
					[Call:reflaxe.preprocessors.ExpressionPreprocessor]
						[Field:(mode : reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode) -> reflaxe.preprocessors.ExpressionPreprocessor]
							[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
							[FEnum:(mode : reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode) -> reflaxe.preprocessors.ExpressionPreprocessor]
								reflaxe.preprocessors.ExpressionPreprocessor
								RemoveTemporaryVariables
						[Field:reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode]
							[TypeExpr reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode:Enum<reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode>]
							[FEnum:reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode]
								reflaxe.preprocessors.implementations.RemoveTemporaryVariablesMode
								AllVariables
					[Local tmp1(34169):reflaxe.preprocessors.ExpressionPreprocessor:reflaxe.preprocessors.ExpressionPreprocessor]
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							RemoveSingleExpressionBlocks
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							RemoveConstantBoolIfs
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							RemoveUnnecessaryBlocks
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							RemoveReassignedVariableDeclarations
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							RemoveLocalVariableAliases
					[Field:reflaxe.preprocessors.ExpressionPreprocessor]
						[TypeExpr reflaxe.preprocessors.ExpressionPreprocessor:Enum<reflaxe.preprocessors.ExpressionPreprocessor>]
						[FEnum:reflaxe.preprocessors.ExpressionPreprocessor]
							reflaxe.preprocessors.ExpressionPreprocessor
							MarkUnusedVariables
			[If:Void]
				[Parenthesis:Bool]
					[Call:Bool]
						[Field:(s : String) -> Bool]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(s : String) -> Bool]
								haxe.macro.Context
								defined:(s : String) -> Bool
						[Const:String] "generate-llm-docs"
				[Then:Void] [Call:Void]
					[Field:(?customConfig : Null<reflaxe.elixir.helpers.GeneratorConfig>) -> Void]
						[TypeExpr reflaxe.elixir.helpers.LLMDocsGenerator:Class<reflaxe.elixir.helpers.LLMDocsGenerator>]
						[FStatic:(?customConfig : Null<reflaxe.elixir.helpers.GeneratorConfig>) -> Void]
							reflaxe.elixir.helpers.LLMDocsGenerator
							initialize:(?customConfig : Null<reflaxe.elixir.helpers.GeneratorConfig>) -> Void
					[Const:Null<reflaxe.elixir.helpers.GeneratorConfig>] null

	@:value(".ex")
	public var fileExtension:String;

	@:value("lib/")
	public var outputDirectory:String;

	var typer:reflaxe.elixir.ElixirTyper;

	@:value(false)
	public var isInLoopContext:Bool;

	var patternMatcher:reflaxe.elixir.helpers.PatternMatcher;

	var guardCompiler:reflaxe.elixir.helpers.GuardCompiler;

	var pipelineOptimizer:reflaxe.elixir.helpers.PipelineOptimizer;

	public var loopCompiler:reflaxe.elixir.helpers.LoopCompiler;

	public var patternMatchingCompiler:reflaxe.elixir.helpers.PatternMatchingCompiler;

	var schemaCompiler:reflaxe.elixir.helpers.SchemaCompiler;

	var migrationCompiler:reflaxe.elixir.helpers.MigrationCompiler;

	var liveViewCompiler:reflaxe.elixir.helpers.LiveViewCompiler;

	var genServerCompiler:reflaxe.elixir.helpers.GenServerCompiler;

	var methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler;

	var reflectionCompiler:reflaxe.elixir.helpers.ReflectionCompiler;

	var arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler;

	public var substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler;

	var tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer;

	var namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler;

	var stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler;

	var functionCompiler:reflaxe.elixir.helpers.FunctionCompiler;

	var arrayMethodCompiler:reflaxe.elixir.helpers.ArrayMethodCompiler;

	var mapToolsCompiler:reflaxe.elixir.helpers.MapToolsCompiler;

	var adtMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler;

	var yCombinatorCompiler:reflaxe.elixir.helpers.YCombinatorCompiler;

	var patternDetectionCompiler:reflaxe.elixir.helpers.PatternDetectionCompiler;

	var patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler;

	var typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler;

	var codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler;

	var pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer;

	var whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler;

	var expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler;

	public var expressionDispatcher:reflaxe.elixir.helpers.ExpressionDispatcher;

	var importOptimizer:reflaxe.elixir.helpers.ImportOptimizer;

	@:value(null)
	var currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>;

	@:value(false)
	var sourceMapOutputEnabled:Bool;

	@:value([])
	var pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>;

	@:value(new Map())
	public var currentFunctionParameterMap:Map<String, String>;

	@:value(null)
	public var variableRenameMap:Null<Map<String, String>>;

	@:value(new Map<String,String>())
	public var inlineContextMap:Map<String, String>;

	@:value(false)
	var isCompilingAbstractMethod:Bool;

	@:value(false)
	public var isCompilingCaseArm:Bool;

	@:value(null)
	public var currentClassType:Null<haxe.macro.ClassType>;

	@:value(null)
	public var liveViewInstanceVars:Null<Map<String, Bool>>;

	@:value(false)
	public var stateThreadingEnabled:Bool;

	@:value(null)
	public var stateThreadingInfo:Null<reflaxe.elixir.helpers.MutabilityInfo>;

	@:value(false)
	public var isCompilingStructMethod:Bool;

	@:value(new Map())
	public var globalStructParameterMap:Map<String, String>;

	function fixMalformedConditionals[Function:(code : String) -> String]
		[Arg:String] [Local code(33306):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(code : String) -> String]
						[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
								reflaxe.elixir.ElixirCompiler
								codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
						[FInstance:(code : String) -> String]
							reflaxe.elixir.helpers.CodeFixupCompiler
							fixMalformedConditionals:(code : String) -> String
					[Local code(33306):String:String]

	public function getCurrentAppName[Function:() -> String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
								reflaxe.elixir.ElixirCompiler
								codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
						[FInstance:() -> String]
							reflaxe.elixir.helpers.CodeFixupCompiler
							getCurrentAppName:() -> String

	function replaceAppNameCalls[Function:(code : String, classType : haxe.macro.ClassType) -> String]
		[Arg:String] [Local code(33307):String]
		[Arg:haxe.macro.ClassType] [Local classType(33308):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(code : String, classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
								reflaxe.elixir.ElixirCompiler
								codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
						[FInstance:(code : String, classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.CodeFixupCompiler
							replaceAppNameCalls:(code : String, classType : haxe.macro.ClassType) -> String
					[Local code(33307):String:String]
					[Local classType(33308):haxe.macro.ClassType:haxe.macro.ClassType]

	function initSourceMapWriter[Function:(outputPath : String) -> Void]
		[Arg:String] [Local outputPath(33309):String]
		[Block:Void]
			[Call:Void]
				[Field:(outputPath : String) -> Void]
					[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
							reflaxe.elixir.ElixirCompiler
							codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
					[FInstance:(outputPath : String) -> Void]
						reflaxe.elixir.helpers.CodeFixupCompiler
						initSourceMapWriter:(outputPath : String) -> Void
				[Local outputPath(33309):String:String]

	function finalizeSourceMapWriter[Function:() -> Null<String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:() -> Null<String>]
						[Field:reflaxe.elixir.helpers.CodeFixupCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.CodeFixupCompiler]
								reflaxe.elixir.ElixirCompiler
								codeFixupCompiler:reflaxe.elixir.helpers.CodeFixupCompiler
						[FInstance:() -> Null<String>]
							reflaxe.elixir.helpers.CodeFixupCompiler
							finalizeSourceMapWriter:() -> Null<String>

	public function getOriginalVarName[Function:(v : haxe.macro.TVar) -> String]
		[Arg:haxe.macro.TVar] [Local v(22240):haxe.macro.TVar]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(v : reflaxe.helpers.NameAndMeta, metaName : String) -> String]
						[TypeExpr reflaxe.helpers.NameMetaHelper:{ Statics reflaxe.helpers.NameMetaHelper }]
						[FStatic:(v : reflaxe.helpers.NameAndMeta, metaName : String) -> String]
							reflaxe.helpers.NameMetaHelper
							getNameOrMeta:(v : reflaxe.helpers.NameAndMeta, metaName : String) -> String
					[Local v(22240):haxe.macro.TVar:haxe.macro.TVar]
					[Const:String] ":realPath"

	public function containsVariableReference[Function:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33310):haxe.macro.TypedExpr]
		[Arg:String] [Local variableName(33311):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
							reflaxe.elixir.helpers.PipelineAnalyzer
							containsVariableReference:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool
					[Local expr(33310):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local variableName(33311):String:String]

	function getProcessedStatementIndices[Function:(statements : Array<haxe.macro.TypedExpr>, pattern : reflaxe.elixir.helpers.PipelinePattern) -> Array<Int>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local statements(33312):Array<haxe.macro.TypedExpr>]
		[Arg:reflaxe.elixir.helpers.PipelinePattern] [Local pattern(33313):reflaxe.elixir.helpers.PipelinePattern]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Array<Int>]
					[Field:(statements : Array<haxe.macro.TypedExpr>, pattern : reflaxe.elixir.helpers.PipelinePattern) -> Array<Int>]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(statements : Array<haxe.macro.TypedExpr>, pattern : reflaxe.elixir.helpers.PipelinePattern) -> Array<Int>]
							reflaxe.elixir.helpers.PipelineAnalyzer
							getProcessedStatementIndices:(statements : Array<haxe.macro.TypedExpr>, pattern : reflaxe.elixir.helpers.PipelinePattern) -> Array<Int>
					[Local statements(33312):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
					[Local pattern(33313):reflaxe.elixir.helpers.PipelinePattern:reflaxe.elixir.helpers.PipelinePattern]

	function statementTargetsVariable[Function:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local stmt(33314):haxe.macro.TypedExpr]
		[Arg:String] [Local variableName(33315):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
							reflaxe.elixir.helpers.PipelineAnalyzer
							statementTargetsVariable:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool
					[Local stmt(33314):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local variableName(33315):String:String]

	function isTerminalOperation[Function:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local stmt(33316):haxe.macro.TypedExpr]
		[Arg:String] [Local variableName(33317):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool]
							reflaxe.elixir.helpers.PipelineAnalyzer
							isTerminalOperation:(stmt : haxe.macro.TypedExpr, variableName : String) -> Bool
					[Local stmt(33316):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local variableName(33317):String:String]

	function isTerminalOperationOnVariable[Function:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33318):haxe.macro.TypedExpr]
		[Arg:String] [Local variableName(33319):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool]
							reflaxe.elixir.helpers.PipelineAnalyzer
							isTerminalOperationOnVariable:(expr : haxe.macro.TypedExpr, variableName : String) -> Bool
					[Local expr(33318):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local variableName(33319):String:String]

	function extractTerminalCall[Function:(expr : haxe.macro.TypedExpr, variableName : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33320):haxe.macro.TypedExpr]
		[Arg:String] [Local variableName(33321):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, variableName : String) -> Null<String>]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(expr : haxe.macro.TypedExpr, variableName : String) -> Null<String>]
							reflaxe.elixir.helpers.PipelineAnalyzer
							extractTerminalCall:(expr : haxe.macro.TypedExpr, variableName : String) -> Null<String>
					[Local expr(33320):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local variableName(33321):String:String]

	function extractFunctionNameFromCall[Function:(funcExpr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local funcExpr(33322):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(funcExpr : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.PipelineAnalyzer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PipelineAnalyzer]
								reflaxe.elixir.ElixirCompiler
								pipelineAnalyzer:reflaxe.elixir.helpers.PipelineAnalyzer
						[FInstance:(funcExpr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.PipelineAnalyzer
							extractFunctionNameFromCall:(funcExpr : haxe.macro.TypedExpr) -> String
					[Local funcExpr(33322):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function detectCoreComponentsUsage[Function:(classType : haxe.macro.ClassType, funcFields : Array<reflaxe.data.ClassFuncData>) -> Bool]
		[Arg:haxe.macro.ClassType] [Local classType(33323):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33324):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(classType : haxe.macro.ClassType, funcFields : Array<reflaxe.data.ClassFuncData>) -> Bool]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(classType : haxe.macro.ClassType, funcFields : Array<reflaxe.data.ClassFuncData>) -> Bool]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							detectCoreComponentsUsage:(classType : haxe.macro.ClassType, funcFields : Array<reflaxe.data.ClassFuncData>) -> Bool
					[Local classType(33323):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local funcFields(33324):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	public function toElixirName[Function:(haxeName : String) -> String]
		[Arg:String] [Local haxeName(22114):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(haxeName : String) -> String]
						[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
								reflaxe.elixir.ElixirCompiler
								namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
						[FInstance:(haxeName : String) -> String]
							reflaxe.elixir.helpers.NamingConventionCompiler
							toElixirName:(haxeName : String) -> String
					[Local haxeName(22114):String:String]

	function convertPackageToDirectoryPath[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33325):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
								reflaxe.elixir.ElixirCompiler
								namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.NamingConventionCompiler
							convertPackageToDirectoryPath:(classType : haxe.macro.ClassType) -> String
					[Local classType(33325):haxe.macro.ClassType:haxe.macro.ClassType]

	function setFrameworkAwareOutputPath[Function:(classType : haxe.macro.ClassType) -> Void]
		[Arg:haxe.macro.ClassType] [Local classType(33326):haxe.macro.ClassType]
		[Block:Void]
			[Call:Void]
				[Field:(classType : haxe.macro.ClassType) -> Void]
					[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
							reflaxe.elixir.ElixirCompiler
							namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
					[FInstance:(classType : haxe.macro.ClassType) -> Void]
						reflaxe.elixir.helpers.NamingConventionCompiler
						setFrameworkAwareOutputPath:(classType : haxe.macro.ClassType) -> Void
				[Local classType(33326):haxe.macro.ClassType:haxe.macro.ClassType]

	@:value({ pack : null })
	function getUniversalNamingRule[Function:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
		[Arg:String] [Local moduleName(33327):String]
		[Arg:Null<Array<String>>]
			[Local pack(33328):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
						[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
								reflaxe.elixir.ElixirCompiler
								namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
						[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingConventionCompiler
							getUniversalNamingRule:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }
					[Local moduleName(33327):String:String]
					[Local pack(33328):Null<Array<String>>:Null<Array<String>>]

	@:value({ pack : null })
	function setUniversalOutputPath[Function:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
		[Arg:String] [Local moduleName(33329):String]
		[Arg:Null<Array<String>>]
			[Local pack(33330):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Void]
			[Call:Void]
				[Field:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
					[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
							reflaxe.elixir.ElixirCompiler
							namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
					[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
						reflaxe.elixir.helpers.NamingConventionCompiler
						setUniversalOutputPath:(moduleName : String, ?pack : Null<Array<String>>) -> Void
				[Local moduleName(33329):String:String]
				[Local pack(33330):Null<Array<String>>:Null<Array<String>>]

	function getComprehensiveNamingRule[Function:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
		[Arg:haxe.macro.ClassType] [Local classType(33331):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
						[Field:reflaxe.elixir.helpers.NamingConventionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.NamingConventionCompiler]
								reflaxe.elixir.ElixirCompiler
								namingConventionCompiler:reflaxe.elixir.helpers.NamingConventionCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingConventionCompiler
							getComprehensiveNamingRule:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }
					[Local classType(33331):haxe.macro.ClassType:haxe.macro.ClassType]

	public function enableStateThreadingMode[Function:(info : reflaxe.elixir.helpers.MutabilityInfo) -> Void]
		[Arg:reflaxe.elixir.helpers.MutabilityInfo] [Local info(23830):reflaxe.elixir.helpers.MutabilityInfo]
		[Block:Void]
			[Call:Void]
				[Field:(info : reflaxe.elixir.helpers.MutabilityInfo) -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:(info : reflaxe.elixir.helpers.MutabilityInfo) -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						enableStateThreadingMode:(info : reflaxe.elixir.helpers.MutabilityInfo) -> Void
				[Local info(23830):reflaxe.elixir.helpers.MutabilityInfo:reflaxe.elixir.helpers.MutabilityInfo]

	public function disableStateThreadingMode[Function:() -> Void]
		[Block:Void]
			[Call:Void]
				[Field:() -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:() -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						disableStateThreadingMode:() -> Void

	public function isStateThreadingEnabled[Function:() -> Bool]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:() -> Bool]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:() -> Bool]
							reflaxe.elixir.helpers.StateManagementCompiler
							isStateThreadingEnabled:() -> Bool

	public function getStateThreadingInfo[Function:() -> Null<reflaxe.elixir.helpers.MutabilityInfo>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<reflaxe.elixir.helpers.MutabilityInfo>]
					[Field:() -> Null<reflaxe.elixir.helpers.MutabilityInfo>]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:() -> Null<reflaxe.elixir.helpers.MutabilityInfo>]
							reflaxe.elixir.helpers.StateManagementCompiler
							getStateThreadingInfo:() -> Null<reflaxe.elixir.helpers.MutabilityInfo>

	public function setThisParameterMapping[Function:(structParamName : String) -> Void]
		[Arg:String] [Local structParamName(23808):String]
		[Block:Void]
			[Call:Void]
				[Field:(structParamName : String) -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:(structParamName : String) -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						setParameterMapping:(structParamName : String) -> Void
				[Local structParamName(23808):String:String]

	public function clearThisParameterMapping[Function:() -> Void]
		[Block:Void]
			[Call:Void]
				[Field:() -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:() -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						clearParameterMapping:() -> Void

	public function startCompilingStructMethod[Function:(structParamName : String) -> Void]
		[Arg:String] [Local structParamName(23791):String]
		[Block:Void]
			[Call:Void]
				[Field:(structParamName : String) -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:(structParamName : String) -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						startGlobalStructMethodCompilation:(structParamName : String) -> Void
				[Local structParamName(23791):String:String]

	public function stopCompilingStructMethod[Function:() -> Void]
		[Block:Void]
			[Call:Void]
				[Field:() -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:() -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						stopGlobalStructMethodCompilation:() -> Void

	public function setInlineContext[Function:(varName : String, replacement : String) -> Void]
		[Arg:String] [Local varName(21835):String]
		[Arg:String] [Local replacement(21836):String]
		[Block:Void]
			[Call:Void]
				[Field:(variableName : String, replacementValue : String) -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:(variableName : String, replacementValue : String) -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						setInlineContext:(variableName : String, replacementValue : String) -> Void
				[Local varName(21835):String:String]
				[Local replacement(21836):String:String]

	public function hasInlineContext[Function:(varName : String) -> Bool]
		[Arg:String] [Local varName(21659):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(varName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:(varName : String) -> Bool]
							reflaxe.elixir.helpers.StateManagementCompiler
							hasInlineContext:(varName : String) -> Bool
					[Local varName(21659):String:String]

	function getInlineContext[Function:(varName : String) -> Null<String>]
		[Arg:String] [Local varName(33332):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(varName : String) -> Null<String>]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:(varName : String) -> Null<String>]
							reflaxe.elixir.helpers.StateManagementCompiler
							getInlineContext:(varName : String) -> Null<String>
					[Local varName(33332):String:String]

	public function clearInlineContext[Function:() -> Void]
		[Block:Void]
			[Call:Void]
				[Field:() -> Void]
					[Field:reflaxe.elixir.helpers.StateManagementCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
							reflaxe.elixir.ElixirCompiler
							stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
					[FInstance:() -> Void]
						reflaxe.elixir.helpers.StateManagementCompiler
						clearInlineContext:() -> Void

	public function compileClassImpl[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> Null<String>]
		[Arg:haxe.macro.ClassType] [Local classType(33333):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33334):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33335):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
					==
					[Const:haxe.macro.ClassType] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(name : String) -> Bool]
							reflaxe.elixir.ElixirCompiler
							isStandardLibraryClass:(name : String) -> Bool
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Binop:Null<haxe.macro.ClassType>]
				[Field:Null<haxe.macro.ClassType>]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Null<haxe.macro.ClassType>]
						reflaxe.elixir.ElixirCompiler
						currentClassType:Null<haxe.macro.ClassType>
				=
				[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
			[Call:Void]
				[Field:() -> Void]
					[Field:reflaxe.elixir.helpers.ImportOptimizer]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.ImportOptimizer]
							reflaxe.elixir.ElixirCompiler
							importOptimizer:reflaxe.elixir.helpers.ImportOptimizer
					[FInstance:() -> Void]
						reflaxe.elixir.helpers.ImportOptimizer
						reset:() -> Void
			[Call:Void]
				[Field:(classType : haxe.macro.ClassType) -> Void]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:(classType : haxe.macro.ClassType) -> Void]
						reflaxe.elixir.ElixirCompiler
						setFrameworkAwareOutputPath:(classType : haxe.macro.ClassType) -> Void
				[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: setFrameworkAwareOutputPath completed for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 748
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[If:Void]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						sourceMapOutputEnabled:Bool
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Const:String] "DEBUG: Starting source mapping for "
							+
							[Field:String]
								[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:String] name:String
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
							lineNumber: [Const:Int] 752
							className: [Const:String] "reflaxe.elixir.ElixirCompiler"
							methodName: [Const:String] "compileClassImpl"
					[Var className(33337):String]
						[Field:String]
							[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:String] name:String
					[Var actualOutputDir(33338):Null<String>]
						[If:Null<String>]
							[Binop:Bool]
								[Field:Null<String>]
									[Field:Null<reflaxe.output.OutputManager>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:Null<reflaxe.output.OutputManager>]
											reflaxe.BaseCompiler
											output:Null<reflaxe.output.OutputManager>
									[FInstance:Null<String>]
										reflaxe.output.OutputManager
										outputDir:Null<String>
								!=
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>]
								[Field:Null<String>]
									[Field:Null<reflaxe.output.OutputManager>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:Null<reflaxe.output.OutputManager>]
											reflaxe.BaseCompiler
											output:Null<reflaxe.output.OutputManager>
									[FInstance:Null<String>]
										reflaxe.output.OutputManager
										outputDir:Null<String>
							[Else:String] [Block:String]
								[Field:String]
									[Const:reflaxe.elixir.ElixirCompiler] this
									[FInstance:String]
										reflaxe.elixir.ElixirCompiler
										outputDirectory:String
					[Var outputPath(33339):String]
						[Call:String]
							[Field:(classType : haxe.macro.ClassType, outputDir : String, fileExtension : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.PhoenixPathGenerator:Class<reflaxe.elixir.helpers.PhoenixPathGenerator>]
								[FStatic:(classType : haxe.macro.ClassType, outputDir : String, fileExtension : String) -> String]
									reflaxe.elixir.helpers.PhoenixPathGenerator
									generateAnnotationAwareOutputPath:(classType : haxe.macro.ClassType, outputDir : String, fileExtension : String) -> String
							[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
							[Local actualOutputDir(33338):Null<String>:Null<String>]
							[Field:String]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:String]
									reflaxe.elixir.ElixirCompiler
									fileExtension:String
					[Call:Void]
						[Field:(outputPath : String) -> Void]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:(outputPath : String) -> Void]
								reflaxe.elixir.ElixirCompiler
								initSourceMapWriter:(outputPath : String) -> Void
						[Local outputPath(33339):String:String]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Const:String] "DEBUG: Source mapping completed for "
							+
							[Field:String]
								[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:String] name:String
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
							lineNumber: [Const:Int] 759
							className: [Const:String] "reflaxe.elixir.ElixirCompiler"
							methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: About to check ExUnit for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 761
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Try:Void]
				[Block:Void]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Const:String] "DEBUG: About to call ExUnitCompiler.isExUnitTest for "
							+
							[Field:String]
								[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:String] name:String
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
							lineNumber: [Const:Int] 765
							className: [Const:String] "reflaxe.elixir.ElixirCompiler"
							methodName: [Const:String] "compileClassImpl"
					[If:Void]
						[Call:Bool]
							[Field:(classType : haxe.macro.ClassType) -> Bool]
								[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
								[FStatic:(classType : haxe.macro.ClassType) -> Bool]
									reflaxe.elixir.helpers.ExUnitCompiler
									isExUnitTest:(classType : haxe.macro.ClassType) -> Bool
							[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[Then:Dynamic] [Block:Dynamic]
							[Call:Void]
								[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
									[TypeExpr haxe.Log:Class<haxe.Log>]
									[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
										haxe.Log
										trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
								[Binop:String]
									[Binop:String]
										[Const:String] "DEBUG: "
										+
										[Field:String]
											[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
											[FAnon:String] name:String
									+
									[Const:String] " is an ExUnit test"
								[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
									fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
									lineNumber: [Const:Int] 767
									className: [Const:String] "reflaxe.elixir.ElixirCompiler"
									methodName: [Const:String] "compileClassImpl"
							[Var result(33340):String]
								[Call:String]
									[Field:(classType : haxe.macro.ClassType, compiler : reflaxe.elixir.ElixirCompiler) -> String]
										[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
										[FStatic:(classType : haxe.macro.ClassType, compiler : reflaxe.elixir.ElixirCompiler) -> String]
											reflaxe.elixir.helpers.ExUnitCompiler
											compile:(classType : haxe.macro.ClassType, compiler : reflaxe.elixir.ElixirCompiler) -> String
									[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
									[Const:reflaxe.elixir.ElixirCompiler] this
							[Return:Dynamic] [Local result(33340):String:String]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "DEBUG: "
								+
								[Field:String]
									[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:String] name:String
							+
							[Const:String] " is NOT an ExUnit test, continuing"
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
							lineNumber: [Const:Int] 771
							className: [Const:String] "reflaxe.elixir.ElixirCompiler"
							methodName: [Const:String] "compileClassImpl"
				Catch [Local `(34154):Dynamic]
					[Block:Void]
						[Block:Void]
						[Block:Void]
						[If:Void]
							[Const:Bool] true
							[Then:Dynamic] [Block:Dynamic]
								[Var e(33341):Dynamic] [Local `(34154):Dynamic:Dynamic]
								[Block:Dynamic]
									[Call:Void]
										[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
											[TypeExpr haxe.Log:Class<haxe.Log>]
											[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
												haxe.Log
												trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "DEBUG: ERROR in ExUnit check for "
													+
													[Field:String]
														[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
														[FAnon:String] name:String
												+
												[Const:String] ": "
											+
											[Call:String]
												[Field:(s : Dynamic) -> String]
													[TypeExpr Std:Class<Std>]
													[FStatic:(s : Dynamic) -> String]
														Std
														string:(s : Dynamic) -> String
												[Local e(33341):Dynamic:Dynamic]
										[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
											fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
											lineNumber: [Const:Int] 773
											className: [Const:String] "reflaxe.elixir.ElixirCompiler"
											methodName: [Const:String] "compileClassImpl"
									[Throw:Dynamic] [Local e(33341):Dynamic:Dynamic]
							[Else:Unknown<28>] [Throw:Unknown<28>] [Local `(34154):Dynamic:Dynamic]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: About to call AnnotationSystem.routeCompilation for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 778
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Var annotationResult(33342):Null<String>]
				[Call:Null<String>]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> Null<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> Null<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							routeCompilation:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> Null<String>
					[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33334):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33335):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: AnnotationSystem.routeCompilation completed for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 780
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[If:Void]
				[Binop:Bool]
					[Local annotationResult(33342):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local annotationResult(33342):Null<String>:Null<String>]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: About to call AnnotationSystem.detectAnnotations for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 786
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Var annotationInfo(33343):reflaxe.elixir.helpers.AnnotationInfo]
				[Call:reflaxe.elixir.helpers.AnnotationInfo]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
							reflaxe.elixir.helpers.AnnotationSystem
							detectAnnotations:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo
					[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: AnnotationSystem.detectAnnotations completed for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 788
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[If:Void]
				[Binop:Bool]
					[Field:Null<String>]
						[Local annotationInfo(33343):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
						[FAnon:Null<String>] primaryAnnotation:Null<String>
					==
					[Const:String] ":liveview"
				[Then:Dynamic] [Block:Dynamic]
					[Var result(33347):String]
						[Call:String]
							[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileLiveViewClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
							[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
							[Local varFields(33334):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
							[Local funcFields(33335):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
					[Return:Dynamic] [Local result(33347):String:String]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Not a LiveView, continuing to ClassCompiler for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 793
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: About to create ClassCompiler for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 796
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Var classCompiler(33348):reflaxe.elixir.helpers.ClassCompiler]
				[New:reflaxe.elixir.helpers.ClassCompiler]
					reflaxe.elixir.helpers.ClassCompiler
					[Field:reflaxe.elixir.ElixirTyper]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.ElixirTyper]
							reflaxe.elixir.ElixirCompiler
							typer:reflaxe.elixir.ElixirTyper
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: ClassCompiler created, setting compiler for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 798
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
					[Local classCompiler(33348):reflaxe.elixir.helpers.ClassCompiler:reflaxe.elixir.helpers.ClassCompiler]
					[FInstance:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
						reflaxe.elixir.helpers.ClassCompiler
						setCompiler:(compiler : reflaxe.elixir.ElixirCompiler) -> Void
				[Const:reflaxe.elixir.ElixirCompiler] this
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Compiler set, setting import optimizer for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 800
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(importOptimizer : reflaxe.elixir.helpers.ImportOptimizer) -> Void]
					[Local classCompiler(33348):reflaxe.elixir.helpers.ClassCompiler:reflaxe.elixir.helpers.ClassCompiler]
					[FInstance:(importOptimizer : reflaxe.elixir.helpers.ImportOptimizer) -> Void]
						reflaxe.elixir.helpers.ClassCompiler
						setImportOptimizer:(importOptimizer : reflaxe.elixir.helpers.ImportOptimizer) -> Void
				[Field:reflaxe.elixir.helpers.ImportOptimizer]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:reflaxe.elixir.helpers.ImportOptimizer]
						reflaxe.elixir.ElixirCompiler
						importOptimizer:reflaxe.elixir.helpers.ImportOptimizer
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: ClassCompiler setup complete for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 802
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Checking inheritance for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 805
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[If:Void]
				[Binop:Bool]
					[Field:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] superClass:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
					!=
					[Const:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] null
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "DEBUG: "
								+
								[Field:String]
									[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:String] name:String
							+
							[Const:String] " has superclass, adding for compilation"
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
							lineNumber: [Const:Int] 807
							className: [Const:String] "reflaxe.elixir.ElixirCompiler"
							methodName: [Const:String] "compileClassImpl"
					[Call:Void]
						[Field:(mt : haxe.macro.ModuleType) -> Void]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:(mt : haxe.macro.ModuleType) -> Void]
								reflaxe.BaseCompiler
								addModuleTypeForCompilation:(mt : haxe.macro.ModuleType) -> Void
						[Call:haxe.macro.ModuleType]
							[Field:(c : haxe.macro.Ref<haxe.macro.ClassType>) -> haxe.macro.ModuleType]
								[TypeExpr haxe.macro.ModuleType:Enum<haxe.macro.ModuleType>]
								[FEnum:(c : haxe.macro.Ref<haxe.macro.ClassType>) -> haxe.macro.ModuleType]
									haxe.macro.ModuleType
									TClassDecl
							[Field:haxe.macro.Ref<haxe.macro.ClassType>]
								[Field:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
									[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] superClass:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
								[FAnon:haxe.macro.Ref<haxe.macro.ClassType>] t:haxe.macro.Ref<haxe.macro.ClassType>
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Inheritance check complete for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 810
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Checking interfaces for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 813
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Block:Void]
				[Var `(33350):Int] [Const:Int] 0
				[Var `(33351):Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
					[Field:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] interfaces:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
				[While:Void]
					[Binop:Bool]
						[Local `(33350):Int:Int]
						<
						[Field:Int]
							[Local `(33351):Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
							[FInstance:Int]
								Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
								length:Int
					[Block:Void]
						[Var iface(33349):{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }]
							[Array:{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }]
								[Local `(33351):Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
								[Local `(33350):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(33350):Int:Int]
						[Call:Void]
							[Field:(mt : haxe.macro.ModuleType) -> Void]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:(mt : haxe.macro.ModuleType) -> Void]
									reflaxe.BaseCompiler
									addModuleTypeForCompilation:(mt : haxe.macro.ModuleType) -> Void
							[Call:haxe.macro.ModuleType]
								[Field:(c : haxe.macro.Ref<haxe.macro.ClassType>) -> haxe.macro.ModuleType]
									[TypeExpr haxe.macro.ModuleType:Enum<haxe.macro.ModuleType>]
									[FEnum:(c : haxe.macro.Ref<haxe.macro.ClassType>) -> haxe.macro.ModuleType]
										haxe.macro.ModuleType
										TClassDecl
								[Field:haxe.macro.Ref<haxe.macro.ClassType>]
									[Local iface(33349):{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }:{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }]
									[FAnon:haxe.macro.Ref<haxe.macro.ClassType>] t:haxe.macro.Ref<haxe.macro.ClassType>
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: Interface check complete for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 817
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: About to call classCompiler.compileClass for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 819
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[Var result(33352):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
						[Local classCompiler(33348):reflaxe.elixir.helpers.ClassCompiler:reflaxe.elixir.helpers.ClassCompiler]
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
							reflaxe.elixir.helpers.ClassCompiler
							compileClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
					[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33334):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33335):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: classCompiler.compileClass completed for "
					+
					[Field:String]
						[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/ElixirCompiler.hx"
					lineNumber: [Const:Int] 821
					className: [Const:String] "reflaxe.elixir.ElixirCompiler"
					methodName: [Const:String] "compileClassImpl"
			[If:Void]
				[Binop:Bool]
					[Local result(33352):String:String]
					!=
					[Const:String] null
				[Then:String] [Block:String]
					[Binop:String]
						[Local result(33352):String:String]
						=
						[Call:String]
							[Field:(code : String, classType : haxe.macro.ClassType) -> String]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:(code : String, classType : haxe.macro.ClassType) -> String]
									reflaxe.elixir.ElixirCompiler
									replaceAppNameCalls:(code : String, classType : haxe.macro.ClassType) -> String
							[Local result(33352):String:String]
							[Local classType(33333):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic] [Local result(33352):String:String]

	function compileMigrationClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33353):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33354):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33355):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
						[Field:reflaxe.elixir.helpers.MigrationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MigrationCompiler]
								reflaxe.elixir.ElixirCompiler
								migrationCompiler:reflaxe.elixir.helpers.MigrationCompiler
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.MigrationCompiler
							compileMigrationClass:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String
					[Local classType(33353):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33354):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33355):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	function compileTemplateClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33356):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33357):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33358):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(33359):String]
				[Field:String]
					[Local classType(33356):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(33360):reflaxe.elixir.helpers.TemplateConfig]
				[Call:reflaxe.elixir.helpers.TemplateConfig]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig]
						[TypeExpr reflaxe.elixir.helpers.TemplateCompiler:Class<reflaxe.elixir.helpers.TemplateCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig]
							reflaxe.elixir.helpers.TemplateCompiler
							getTemplateConfig:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig
					[Local classType(33356):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String]
						[TypeExpr reflaxe.elixir.helpers.TemplateCompiler:Class<reflaxe.elixir.helpers.TemplateCompiler>]
						[FStatic:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String]
							reflaxe.elixir.helpers.TemplateCompiler
							compileFullTemplate:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String
					[Local className(33359):String:String]
					[Local config(33360):reflaxe.elixir.helpers.TemplateConfig:reflaxe.elixir.helpers.TemplateConfig]

	function compileSchemaClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33361):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33362):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33363):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
						[Field:reflaxe.elixir.helpers.SchemaCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.SchemaCompiler]
								reflaxe.elixir.ElixirCompiler
								schemaCompiler:reflaxe.elixir.helpers.SchemaCompiler
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							compileSchemaClass:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String
					[Local classType(33361):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33362):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33363):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	function compileChangesetClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33364):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33365):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33366):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
						[Field:reflaxe.elixir.helpers.SchemaCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.SchemaCompiler]
								reflaxe.elixir.ElixirCompiler
								schemaCompiler:reflaxe.elixir.helpers.SchemaCompiler
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							compileChangesetClass:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String
					[Local classType(33364):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33365):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33366):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	function compileGenServerClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33367):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33368):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33369):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
						[Field:reflaxe.elixir.helpers.GenServerCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.GenServerCompiler]
								reflaxe.elixir.ElixirCompiler
								genServerCompiler:reflaxe.elixir.helpers.GenServerCompiler
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.GenServerCompiler
							compileGenServerClass:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String
					[Local classType(33367):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33368):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33369):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	function compileLiveViewClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33344):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33345):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(33346):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
						[Field:reflaxe.elixir.helpers.LiveViewCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.LiveViewCompiler]
								reflaxe.elixir.ElixirCompiler
								liveViewCompiler:reflaxe.elixir.helpers.LiveViewCompiler
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.LiveViewCompiler
							compileLiveViewClass:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String
					[Local classType(33344):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(33345):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(33346):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]

	public function compileEnumImpl[Function:(enumType : haxe.macro.EnumType, options : Array<reflaxe.data.EnumOptionData>) -> Null<String>]
		[Arg:haxe.macro.EnumType] [Local enumType(33370):haxe.macro.EnumType]
		[Arg:Array<reflaxe.data.EnumOptionData>] [Local options(33371):Array<reflaxe.data.EnumOptionData>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local enumType(33370):haxe.macro.EnumType:haxe.macro.EnumType]
					==
					[Const:haxe.macro.EnumType] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Call:Void]
				[Field:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
						reflaxe.elixir.ElixirCompiler
						setUniversalOutputPath:(moduleName : String, ?pack : Null<Array<String>>) -> Void
				[Field:String]
					[Local enumType(33370):haxe.macro.EnumType:haxe.macro.EnumType]
					[FAnon:String] name:String
				[Field:Array<String>]
					[Local enumType(33370):haxe.macro.EnumType:haxe.macro.EnumType]
					[FAnon:Array<String>] pack:Array<String>
			[Var enumCompiler(33372):reflaxe.elixir.helpers.EnumCompiler]
				[New:reflaxe.elixir.helpers.EnumCompiler]
					reflaxe.elixir.helpers.EnumCompiler
					[Field:reflaxe.elixir.ElixirTyper]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.ElixirTyper]
							reflaxe.elixir.ElixirCompiler
							typer:reflaxe.elixir.ElixirTyper
			[Return:Dynamic]
				[Call:String]
					[Field:(enumType : haxe.macro.EnumType, options : Array<reflaxe.data.EnumOptionData>) -> String]
						[Local enumCompiler(33372):reflaxe.elixir.helpers.EnumCompiler:reflaxe.elixir.helpers.EnumCompiler]
						[FInstance:(enumType : haxe.macro.EnumType, options : Array<reflaxe.data.EnumOptionData>) -> String]
							reflaxe.elixir.helpers.EnumCompiler
							compileEnum:(enumType : haxe.macro.EnumType, options : Array<reflaxe.data.EnumOptionData>) -> String
					[Local enumType(33370):haxe.macro.EnumType:haxe.macro.EnumType]
					[Local options(33371):Array<reflaxe.data.EnumOptionData>:Array<reflaxe.data.EnumOptionData>]

	@:value({ topLevel : false })
	public function compileExpression[Function:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(17954):haxe.macro.TypedExpr]
		[Arg:Bool]
			[Local topLevel(17955):Bool]
			[Const:Bool] false
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpressionImpl:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>
					[Local expr(17954):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local topLevel(17955):Bool:Bool]

	public function compileExpressionImpl[Function:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(17956):haxe.macro.TypedExpr]
		[Arg:Bool] [Local topLevel(17957):Bool]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionImpl:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>
					[Local expr(17956):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local topLevel(17957):Bool:Bool]

	public function compileAbstractImpl[Function:(abstractType : haxe.macro.AbstractType) -> Null<String>]
		[Arg:haxe.macro.AbstractType] [Local abstractType(33373):haxe.macro.AbstractType]
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(name : String) -> Bool]
							reflaxe.elixir.ElixirCompiler
							isBuiltinAbstractType:(name : String) -> Bool
					[Field:String]
						[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
						[FAnon:String] name:String
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Call:Void]
				[Field:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
						reflaxe.elixir.ElixirCompiler
						setUniversalOutputPath:(moduleName : String, ?pack : Null<Array<String>>) -> Void
				[Field:String]
					[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
					[FAnon:String] name:String
				[Field:Array<String>]
					[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
					[FAnon:Array<String>] pack:Array<String>
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Binop:Bool]
								[Field:String]
									[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
									[FAnon:String] name:String
								==
								[Const:String] "FlatEnum"
							||
							[Binop:Bool]
								[Field:String]
									[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
									[FAnon:String] name:String
								==
								[Const:String] "NotVoid"
						||
						[Binop:Bool]
							[Field:String]
								[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
								[FAnon:String] name:String
							==
							[Const:String] "Constructible"
					||
					[Binop:Bool]
						[Call:String]
							[Field:(sep : String) -> String]
								[Field:Array<String>]
									[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
									[FAnon:Array<String>] pack:Array<String>
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] "."
						==
						[Const:String] "haxe.Constraints"
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Var typeName(33375):String]
				[Field:String]
					[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
					[FAnon:String] name:String
			[Var underlyingType(33377):String]
				[Call:String]
					[Field:(type : haxe.macro.Type) -> String]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(type : haxe.macro.Type) -> String]
							reflaxe.elixir.ElixirCompiler
							getElixirTypeFromHaxeType:(type : haxe.macro.Type) -> String
					[Field:haxe.macro.Type]
						[Local abstractType(33373):haxe.macro.AbstractType:haxe.macro.AbstractType]
						[FAnon:haxe.macro.Type] type:haxe.macro.Type
			[Return:Dynamic] [Const:Null<String>] null

	function isBuiltinAbstractType[Function:(name : String) -> Bool]
		[Arg:String] [Local name(33374):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(name : String) -> Bool]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							isBuiltinAbstractType:(name : String) -> Bool
					[Local name(33374):String:String]

	function isStandardLibraryClass[Function:(name : String) -> Bool]
		[Arg:String] [Local name(33336):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(name : String) -> Bool]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							isStandardLibraryClass:(name : String) -> Bool
					[Local name(33336):String:String]

	function getElixirTypeFromHaxeType[Function:(type : haxe.macro.Type) -> String]
		[Arg:haxe.macro.Type] [Local type(33376):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(type : haxe.macro.Type) -> String]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(type : haxe.macro.Type) -> String]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							getElixirTypeFromHaxeType:(type : haxe.macro.Type) -> String
					[Local type(33376):haxe.macro.Type:haxe.macro.Type]

	function getCurrentModuleContent[Function:(abstractType : haxe.macro.AbstractType) -> Null<String>]
		[Arg:haxe.macro.AbstractType] [Local abstractType(33379):haxe.macro.AbstractType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(abstractType : haxe.macro.AbstractType) -> Null<String>]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(abstractType : haxe.macro.AbstractType) -> Null<String>]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							getCurrentModuleContent:(abstractType : haxe.macro.AbstractType) -> Null<String>
					[Local abstractType(33379):haxe.macro.AbstractType:haxe.macro.AbstractType]

	function addTypeDefinition[Function:(content : String, typeAlias : String) -> String]
		[Arg:String] [Local content(33380):String]
		[Arg:String] [Local typeAlias(33381):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(content : String, typeAlias : String) -> String]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(content : String, typeAlias : String) -> String]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							addTypeDefinition:(content : String, typeAlias : String) -> String
					[Local content(33380):String:String]
					[Local typeAlias(33381):String:String]

	function updateCurrentModuleContent[Function:(abstractType : haxe.macro.AbstractType, content : String) -> Void]
		[Arg:haxe.macro.AbstractType] [Local abstractType(33382):haxe.macro.AbstractType]
		[Arg:String] [Local content(33383):String]
		[Block:Void]
			[Call:Void]
				[Field:(abstractType : haxe.macro.AbstractType, content : String) -> Void]
					[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
							reflaxe.elixir.ElixirCompiler
							typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
					[FInstance:(abstractType : haxe.macro.AbstractType, content : String) -> Void]
						reflaxe.elixir.helpers.TypeResolutionCompiler
						updateCurrentModuleContent:(abstractType : haxe.macro.AbstractType, content : String) -> Void
				[Local abstractType(33382):haxe.macro.AbstractType:haxe.macro.AbstractType]
				[Local content(33383):String:String]

	public function compileTypedefImpl[Function:(defType : haxe.macro.DefType) -> Null<String>]
		[Arg:haxe.macro.DefType] [Local defType(33384):haxe.macro.DefType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(defType : haxe.macro.DefType) -> Null<String>]
						[Field:reflaxe.elixir.helpers.TypeResolutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TypeResolutionCompiler]
								reflaxe.elixir.ElixirCompiler
								typeResolutionCompiler:reflaxe.elixir.helpers.TypeResolutionCompiler
						[FInstance:(defType : haxe.macro.DefType) -> Null<String>]
							reflaxe.elixir.helpers.TypeResolutionCompiler
							compileTypedefImpl:(defType : haxe.macro.DefType) -> Null<String>
					[Local defType(33384):haxe.macro.DefType:haxe.macro.DefType]

	public function compileSwitchExpression[Function:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local switchExpr(19952):haxe.macro.TypedExpr]
		[Arg:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>] [Local cases(19953):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
		[Arg:Null<haxe.macro.TypedExpr>] [Local defaultExpr(19954):Null<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileSwitchExpression:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>) -> String
					[Local switchExpr(19952):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local cases(19953):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
					[Local defaultExpr(19954):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]

	public function isResultType[Function:(enumType : haxe.macro.EnumType) -> Bool]
		[Arg:haxe.macro.EnumType] [Local enumType(23386):haxe.macro.EnumType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Bool]
						[Field:(enumType : haxe.macro.EnumType) -> Bool]
							[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
							[FStatic:(enumType : haxe.macro.EnumType) -> Bool]
								reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
								isADTType:(enumType : haxe.macro.EnumType) -> Bool
						[Local enumType(23386):haxe.macro.EnumType:haxe.macro.EnumType]
					&&
					[Binop:Bool]
						[Field:String]
							[Local enumType(23386):haxe.macro.EnumType:haxe.macro.EnumType]
							[FAnon:String] name:String
						==
						[Const:String] "Result"

	public function isOptionType[Function:(enumType : haxe.macro.EnumType) -> Bool]
		[Arg:haxe.macro.EnumType] [Local enumType(23387):haxe.macro.EnumType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Bool]
						[Field:(enumType : haxe.macro.EnumType) -> Bool]
							[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
							[FStatic:(enumType : haxe.macro.EnumType) -> Bool]
								reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
								isADTType:(enumType : haxe.macro.EnumType) -> Bool
						[Local enumType(23387):haxe.macro.EnumType:haxe.macro.EnumType]
					&&
					[Binop:Bool]
						[Field:String]
							[Local enumType(23387):haxe.macro.EnumType:haxe.macro.EnumType]
							[FAnon:String] name:String
						==
						[Const:String] "Option"

	function compileStruct[Function:(varFields : Array<reflaxe.data.ClassVarData>) -> String]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33386):Array<reflaxe.data.ClassVarData>]
		[Block:Dynamic]
			[Var result(33387):String] [Const:String] "  defstruct ["
			[Var fieldNames(33388):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(33391):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(33391):Int:Int]
						<
						[Field:Int]
							[Local varFields(33386):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
							[FInstance:Int]
								Array<reflaxe.data.ClassVarData>
								length:Int
					[Block:Void]
						[Var field(33389):reflaxe.data.ClassVarData]
							[Array:reflaxe.data.ClassVarData]
								[Local varFields(33386):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
								[Local `(33391):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(33391):Int:Int]
						[Var fieldName(33390):String]
							[Call:String]
								[Field:(haxeName : String) -> String]
									[Const:reflaxe.elixir.ElixirCompiler] this
									[FInstance:(haxeName : String) -> String]
										reflaxe.elixir.ElixirCompiler
										toElixirName:(haxeName : String) -> String
								[Field:String]
									[Field:haxe.macro.ClassField]
										[Local field(33389):reflaxe.data.ClassVarData:reflaxe.data.ClassVarData]
										[FInstance:haxe.macro.ClassField]
											reflaxe.data.ClassVarData
											field:haxe.macro.ClassField
									[FAnon:String] name:String
						[Call:Int]
							[Field:(x : String) -> Int]
								[Local fieldNames(33388):Array<String>:Array<String>]
								[FInstance:(x : String) -> Int]
									Array<String>
									push:(x : Array.T) -> Int
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local fieldName(33390):String:String]
								+
								[Const:String] ": nil"
			[Binop:String]
				[Local result(33387):String:String]
				+=
				[Call:String]
					[Field:(sep : String) -> String]
						[Local fieldNames(33388):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ", "
			[Binop:String]
				[Local result(33387):String:String]
				+=
				[Const:String] "]\n\n"
			[Return:Dynamic] [Local result(33387):String:String]

	@:value({ isStatic : false })
	public function compileFunction[Function:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
		[Arg:reflaxe.data.ClassFuncData] [Local funcField(25123):reflaxe.data.ClassFuncData]
		[Arg:Bool]
			[Local isStatic(25124):Bool]
			[Const:Bool] false
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
						[Field:reflaxe.elixir.helpers.FunctionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.FunctionCompiler]
								reflaxe.elixir.ElixirCompiler
								functionCompiler:reflaxe.elixir.helpers.FunctionCompiler
						[FInstance:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
							reflaxe.elixir.helpers.FunctionCompiler
							compileFunction:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String
					[Local funcField(25123):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
					[Local isStatic(25124):Bool:Bool]

	function hasInstanceVars[Function:(varFields : Array<reflaxe.data.ClassVarData>) -> Bool]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(33392):Array<reflaxe.data.ClassVarData>]
		[Block:Dynamic]
			[Block:Void]
				[Var `(33394):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(33394):Int:Int]
						<
						[Field:Int]
							[Local varFields(33392):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
							[FInstance:Int]
								Array<reflaxe.data.ClassVarData>
								length:Int
					[Block:Void]
						[Var field(33393):reflaxe.data.ClassVarData]
							[Array:reflaxe.data.ClassVarData]
								[Local varFields(33392):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
								[Local `(33394):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(33394):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Field:Bool]
									[Local field(33393):reflaxe.data.ClassVarData:reflaxe.data.ClassVarData]
									[FInstance:Bool]
										reflaxe.data.ClassVarData
										isStatic:Bool
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	function isEnumFieldAccess[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33395):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TField(_, FEnum(_, _)):
		true;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(33401):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33395):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33401):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 4
							[Then:Bool] [Block:Bool]
								[Var `(33402):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33401):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(33403):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(33401):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33403):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										==
										[Const:Int] 5
									[Then:Bool] [Block:Bool]
										[Var `(33404):haxe.macro.Ref<haxe.macro.EnumType>]
											[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
												[Local `(33403):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												FEnum
												0
										[Var `(33405):haxe.macro.EnumField]
											[EnumParameter:haxe.macro.EnumField]
												[Local `(33403):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												FEnum
												1
										[Block:Bool] [Const:Bool] true
									[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Const:Bool] false

	function extractEnumFieldName[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33406):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TField(_, FEnum(_, enumField)):
		NamingHelper.toSnakeCase(enumField.name);	
	case _:
		"unknown";	
})
					[Block:String]
						[Var `(33413):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33406):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 4
							[Then:String] [Block:String]
								[Var `(33414):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(33415):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(33413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[If:String]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33415):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										==
										[Const:Int] 5
									[Then:String] [Block:String]
										[Var `(33416):haxe.macro.Ref<haxe.macro.EnumType>]
											[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
												[Local `(33415):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												FEnum
												0
										[Var `(33417):haxe.macro.EnumField]
											[EnumParameter:haxe.macro.EnumField]
												[Local `(33415):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												FEnum
												1
										[Block:String]
											[Var enumField(33418):haxe.macro.EnumField] [Local `(33417):haxe.macro.EnumField:haxe.macro.EnumField]
											[Block:String]
												[Call:String]
													[Field:(camelCase : String) -> String]
														[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
														[FStatic:(camelCase : String) -> String]
															reflaxe.elixir.helpers.NamingHelper
															toSnakeCase:(camelCase : String) -> String
													[Field:String]
														[Local enumField(33418):haxe.macro.EnumField:haxe.macro.EnumField]
														[FAnon:String] name:String
									[Else:String] [Block:String] [Const:String] "unknown"
							[Else:String] [Block:String] [Const:String] "unknown"

	public function compileConstant[Function:(constant : haxe.macro.Constant) -> String]
		[Arg:haxe.macro.Constant] [Local constant(33419):haxe.macro.Constant]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (constant) {
	case CInt(i, _):
		i;	
	case CFloat(s, _):
		s;	
	case CString(s, _):
		"\"${s}\"";	
	case CIdent(s):
		s;	
	case CRegexp(r, opt):
		"~r/${r}/${opt}";	
	case _:
		"nil";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(33435):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										0
								[Var `(33436):Null<String>]
									[EnumParameter:Null<String>]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										1
								[Block:String]
									[Var i(33437):String] [Local `(33435):String:String]
									[Block:String] [Local i(33437):String:String]
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(33438):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										0
								[Var `(33439):Null<String>]
									[EnumParameter:Null<String>]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										1
								[Block:String]
									[Var s(33440):String] [Local `(33438):String:String]
									[Block:String] [Local s(33440):String:String]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(33441):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CString
										0
								[Var `(33442):Null<haxe.macro.StringLiteralKind>]
									[EnumParameter:Null<haxe.macro.StringLiteralKind>]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CString
										1
								[Block:String]
									[Var s(33443):String] [Local `(33441):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "\""
												+
												[Local s(33443):String:String]
											+
											[Const:String] "\""
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(33444):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CIdent
										0
								[Block:String]
									[Var s(33445):String] [Local `(33444):String:String]
									[Block:String] [Local s(33445):String:String]
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(33446):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										0
								[Var `(33447):String]
									[EnumParameter:String]
										[Local constant(33419):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										1
								[Block:String]
									[Var r(33448):String] [Local `(33446):String:String]
									[Var opt(33449):String] [Local `(33447):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "~r/"
													+
													[Local r(33448):String:String]
												+
												[Const:String] "/"
											+
											[Local opt(33449):String:String]

	function compileExpressionWithTypeAwareness[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33450):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
					[Local expr(33450):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	public function isStringType[Function:(type : haxe.macro.Type) -> Bool]
		[Arg:haxe.macro.Type] [Local type(20914):haxe.macro.Type]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local type(20914):haxe.macro.Type:haxe.macro.Type]
					==
					[Const:haxe.macro.Type] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (type) {
	case TInst(t, _):
		t.get().name == "String";	
	case TAbstract(t, _):
		t.get().name == "String";	
	case _:
		false;	
})
					[Switch:Bool]
						[EnumIndex:Int] [Local type(20914):haxe.macro.Type:haxe.macro.Type]
						[Case:Bool]
							[Const:Int] 2
							[Block:Bool]
								[Var `(20921):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(20914):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(20922):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(20914):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:Bool]
									[Var t(20923):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(20921):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Block:Bool]
										[Binop:Bool]
											[Field:String]
												[Call:haxe.macro.ClassType]
													[Field:() -> haxe.macro.ClassType]
														[Local t(20923):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
														[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
												[FAnon:String] name:String
											==
											[Const:String] "String"
						[Case:Bool]
							[Const:Int] 8
							[Block:Bool]
								[Var `(20924):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(20914):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(20925):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(20914):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:Bool]
									[Var t(20926):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(20924):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Block:Bool]
										[Binop:Bool]
											[Field:String]
												[Call:haxe.macro.AbstractType]
													[Field:() -> haxe.macro.AbstractType]
														[Local t(20926):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
														[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
												[FAnon:String] name:String
											==
											[Const:String] "String"
						[Default:Bool] [Block:Bool] [Const:Bool] false

	public function convertToString[Function:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(22256):haxe.macro.TypedExpr]
		[Arg:String] [Local compiledExpr(22257):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.t) {
	case TAbstract(t, _):
		var typeName = t.get().name;
		switch (typeName) {
			case "Int":
				"Integer.to_string(${compiledExpr})";			
			case "Float":
				"Float.to_string(${compiledExpr})";			
			case "Bool":
				"Atom.to_string(${compiledExpr})";			
			case _:
				"Kernel.inspect(${compiledExpr})";			
		};	
	case TInst(t, _):
		"Kernel.inspect(${compiledExpr})";	
	case _:
		"Kernel.inspect(${compiledExpr})";	
})
					[Block:String]
						[Var `(22266):haxe.macro.Type]
							[Field:haxe.macro.Type]
								[Local expr(22256):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.Type] t:haxe.macro.Type
						[Switch:String]
							[EnumIndex:Int] [Local `(22266):haxe.macro.Type:haxe.macro.Type]
							[Case:String]
								[Const:Int] 2
								[Block:String]
									[Var `(22267):haxe.macro.Ref<haxe.macro.ClassType>]
										[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
											[Local `(22266):haxe.macro.Type:haxe.macro.Type]
											TInst
											0
									[Var `(22268):Array<haxe.macro.Type>]
										[EnumParameter:Array<haxe.macro.Type>]
											[Local `(22266):haxe.macro.Type:haxe.macro.Type]
											TInst
											1
									[Block:String]
										[Var t(22269):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(22267):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
										[Block:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "Kernel.inspect("
													+
													[Local compiledExpr(22257):String:String]
												+
												[Const:String] ")"
							[Case:String]
								[Const:Int] 8
								[Block:String]
									[Var `(22270):haxe.macro.Ref<haxe.macro.AbstractType>]
										[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
											[Local `(22266):haxe.macro.Type:haxe.macro.Type]
											TAbstract
											0
									[Var `(22271):Array<haxe.macro.Type>]
										[EnumParameter:Array<haxe.macro.Type>]
											[Local `(22266):haxe.macro.Type:haxe.macro.Type]
											TAbstract
											1
									[Block:String]
										[Var t(22272):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(22270):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Block:String]
											[Var typeName(22273):String]
												[Field:String]
													[Call:haxe.macro.AbstractType]
														[Field:() -> haxe.macro.AbstractType]
															[Local t(22272):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
															[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
													[FAnon:String] name:String
											[Meta:String]
												:ast(switch (typeName) {
	case "Int":
		"Integer.to_string(${compiledExpr})";	
	case "Float":
		"Float.to_string(${compiledExpr})";	
	case "Bool":
		"Atom.to_string(${compiledExpr})";	
	case _:
		"Kernel.inspect(${compiledExpr})";	
})
												[Switch:String]
													[Local typeName(22273):String:String]
													[Case:String]
														[Const:String] "Bool"
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "Atom.to_string("
																		+
																		[Local compiledExpr(22257):String:String]
																	+
																	[Const:String] ")"
													[Case:String]
														[Const:String] "Float"
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "Float.to_string("
																		+
																		[Local compiledExpr(22257):String:String]
																	+
																	[Const:String] ")"
													[Case:String]
														[Const:String] "Int"
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "Integer.to_string("
																		+
																		[Local compiledExpr(22257):String:String]
																	+
																	[Const:String] ")"
													[Default:String]
														[Block:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] "Kernel.inspect("
																	+
																	[Local compiledExpr(22257):String:String]
																+
																[Const:String] ")"
							[Default:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "Kernel.inspect("
											+
											[Local compiledExpr(22257):String:String]
										+
										[Const:String] ")"

	public function compileBinop[Function:(op : haxe.macro.Binop) -> String]
		[Arg:haxe.macro.Binop] [Local op(22276):haxe.macro.Binop]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (op) {
	case OpAdd:
		"+";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpSub:
		"-";	
	case OpAssign:
		"=";	
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpAnd:
		"&&&";	
	case OpOr:
		"|||";	
	case OpXor:
		"^^^";	
	case OpBoolAnd:
		"&&";	
	case OpBoolOr:
		"||";	
	case OpShl:
		"<<<";	
	case OpShr:
		">>>";	
	case OpUShr:
		">>>";	
	case OpMod:
		"rem";	
	case OpAssignOp(op):
		compileBinop(op) + "=";	
	case OpInterval:
		"..";	
	case OpArrow:
		"->";	
	case OpIn:
		"in";	
	case OpNullCoal:
		"||";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local op(22276):haxe.macro.Binop:haxe.macro.Binop]
						[Case:String]
							[Const:Int] 0
							[Block:String] [Block:String] [Const:String] "+"
						[Case:String]
							[Const:Int] 1
							[Block:String] [Block:String] [Const:String] "*"
						[Case:String]
							[Const:Int] 2
							[Block:String] [Block:String] [Const:String] "/"
						[Case:String]
							[Const:Int] 3
							[Block:String] [Block:String] [Const:String] "-"
						[Case:String]
							[Const:Int] 4
							[Block:String] [Block:String] [Const:String] "="
						[Case:String]
							[Const:Int] 5
							[Block:String] [Block:String] [Const:String] "=="
						[Case:String]
							[Const:Int] 6
							[Block:String] [Block:String] [Const:String] "!="
						[Case:String]
							[Const:Int] 7
							[Block:String] [Block:String] [Const:String] ">"
						[Case:String]
							[Const:Int] 8
							[Block:String] [Block:String] [Const:String] ">="
						[Case:String]
							[Const:Int] 9
							[Block:String] [Block:String] [Const:String] "<"
						[Case:String]
							[Const:Int] 10
							[Block:String] [Block:String] [Const:String] "<="
						[Case:String]
							[Const:Int] 11
							[Block:String] [Block:String] [Const:String] "&&&"
						[Case:String]
							[Const:Int] 12
							[Block:String] [Block:String] [Const:String] "|||"
						[Case:String]
							[Const:Int] 13
							[Block:String] [Block:String] [Const:String] "^^^"
						[Case:String]
							[Const:Int] 14
							[Block:String] [Block:String] [Const:String] "&&"
						[Case:String]
							[Const:Int] 15
							[Block:String] [Block:String] [Const:String] "||"
						[Case:String]
							[Const:Int] 16
							[Block:String] [Block:String] [Const:String] "<<<"
						[Case:String]
							[Const:Int] 17
							[Block:String] [Block:String] [Const:String] ">>>"
						[Case:String]
							[Const:Int] 18
							[Block:String] [Block:String] [Const:String] ">>>"
						[Case:String]
							[Const:Int] 19
							[Block:String] [Block:String] [Const:String] "rem"
						[Case:String]
							[Const:Int] 20
							[Block:String]
								[Var `(22279):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local op(22276):haxe.macro.Binop:haxe.macro.Binop]
										OpAssignOp
										0
								[Block:String]
									[Var op(22280):haxe.macro.Binop] [Local `(22279):haxe.macro.Binop:haxe.macro.Binop]
									[Block:String]
										[Binop:String]
											[Call:String]
												[Field:(op : haxe.macro.Binop) -> String]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(op : haxe.macro.Binop) -> String]
														reflaxe.elixir.ElixirCompiler
														compileBinop:(op : haxe.macro.Binop) -> String
												[Local op(22280):haxe.macro.Binop:haxe.macro.Binop]
											+
											[Const:String] "="
						[Case:String]
							[Const:Int] 21
							[Block:String] [Block:String] [Const:String] ".."
						[Case:String]
							[Const:Int] 22
							[Block:String] [Block:String] [Const:String] "->"
						[Case:String]
							[Const:Int] 23
							[Block:String] [Block:String] [Const:String] "in"
						[Case:String]
							[Const:Int] 24
							[Block:String] [Block:String] [Const:String] "||"

	function compileFieldAccess[Function:(e : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(33451):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(33452):haxe.macro.FieldAccess]
		[Block:Dynamic]
			[Var expr(33480):Null<String>]
				[Meta:Null<String>]
					:ast(switch (e.expr) {
	case TConst(TThis):
		var mappedName = currentFunctionParameterMap.get("this");
		mappedName != null ? mappedName : compileExpression(e);	
	case TLocal(v) if (v.name == "this" || v.name == "_this"):
		var mappedName = currentFunctionParameterMap.get("this");
		if (mappedName == null && v.name == "_this") {
			mappedName = currentFunctionParameterMap.get("_this");
		};
		mappedName != null ? mappedName : compileExpression(e);	
	case _:
		compileExpression(e);	
})
					[Block:Null<String>]
						[Var `(33471):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Null<String>]
							[EnumIndex:Int] [Local `(33471):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Null<String>]
								[Const:Int] 0
								[Block:Null<String>]
									[Var `(33472):haxe.macro.TConstant]
										[EnumParameter:haxe.macro.TConstant]
											[Local `(33471):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TConst
											0
									[If:Null<String>]
										[Binop:Bool]
											[EnumIndex:Int] [Local `(33472):haxe.macro.TConstant:haxe.macro.TConstant]
											==
											[Const:Int] 5
										[Then:Null<String>] [Block:Null<String>]
											[Block:Null<String>]
												[Var mappedName(33473):Null<String>]
													[Block:Null<String>]
														[Var this(33474):haxe.IMap<String, String>]
															[Field:Map<String, String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:Map<String, String>]
																	reflaxe.elixir.ElixirCompiler
																	currentFunctionParameterMap:Map<String, String>
														[Call:Null<String>]
															[Field:(key : String) -> Null<String>]
																[Cast:haxe.ds.StringMap<String>] [Local this(33474):haxe.IMap<String, String>:haxe.IMap<String, String>]
																[FInstance:(key : String) -> Null<String>]
																	haxe.ds.StringMap<String>
																	get:(key : String) -> Null<haxe.ds.StringMap.T>
															[Const:String] "this"
												[If:Null<String>]
													[Binop:Bool]
														[Local mappedName(33473):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
													[Then:Null<String>] [Block:Null<String>] [Local mappedName(33473):Null<String>:Null<String>]
													[Else:Null<String>] [Block:Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Const:Null<Bool>] null
										[Else:Null<String>] [Block:Null<String>]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
							[Case:Null<String>]
								[Const:Int] 1
								[Block:Null<String>]
									[Var `(33475):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(33471):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:Null<String>]
										[Var v(33476):haxe.macro.TVar] [Local `(33475):haxe.macro.TVar:haxe.macro.TVar]
										[If:Null<String>]
											[Binop:Bool]
												[Binop:Bool]
													[Field:String]
														[Local v(33476):haxe.macro.TVar:haxe.macro.TVar]
														[FAnon:String] name:String
													==
													[Const:String] "this"
												||
												[Binop:Bool]
													[Field:String]
														[Local v(33476):haxe.macro.TVar:haxe.macro.TVar]
														[FAnon:String] name:String
													==
													[Const:String] "_this"
											[Then:Null<String>] [Block:Null<String>]
												[Var mappedName(33477):Null<String>]
													[Block:Null<String>]
														[Var this(33478):haxe.IMap<String, String>]
															[Field:Map<String, String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:Map<String, String>]
																	reflaxe.elixir.ElixirCompiler
																	currentFunctionParameterMap:Map<String, String>
														[Call:Null<String>]
															[Field:(key : String) -> Null<String>]
																[Cast:haxe.ds.StringMap<String>] [Local this(33478):haxe.IMap<String, String>:haxe.IMap<String, String>]
																[FInstance:(key : String) -> Null<String>]
																	haxe.ds.StringMap<String>
																	get:(key : String) -> Null<haxe.ds.StringMap.T>
															[Const:String] "this"
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Local mappedName(33477):Null<String>:Null<String>]
															==
															[Const:Null<String>] null
														&&
														[Binop:Bool]
															[Field:String]
																[Local v(33476):haxe.macro.TVar:haxe.macro.TVar]
																[FAnon:String] name:String
															==
															[Const:String] "_this"
													[Then:Null<String>] [Block:Null<String>]
														[Binop:Null<String>]
															[Local mappedName(33477):Null<String>:Null<String>]
															=
															[Block:Null<String>]
																[Var this(33479):haxe.IMap<String, String>]
																	[Field:Map<String, String>]
																		[Const:reflaxe.elixir.ElixirCompiler] this
																		[FInstance:Map<String, String>]
																			reflaxe.elixir.ElixirCompiler
																			currentFunctionParameterMap:Map<String, String>
																[Call:Null<String>]
																	[Field:(key : String) -> Null<String>]
																		[Cast:haxe.ds.StringMap<String>] [Local this(33479):haxe.IMap<String, String>:haxe.IMap<String, String>]
																		[FInstance:(key : String) -> Null<String>]
																			haxe.ds.StringMap<String>
																			get:(key : String) -> Null<haxe.ds.StringMap.T>
																	[Const:String] "_this"
												[If:Null<String>]
													[Binop:Bool]
														[Local mappedName(33477):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
													[Then:Null<String>] [Block:Null<String>] [Local mappedName(33477):Null<String>:Null<String>]
													[Else:Null<String>] [Block:Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Const:Null<Bool>] null
											[Else:Null<String>] [Block:Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Const:Null<Bool>] null
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Const:reflaxe.elixir.ElixirCompiler] this
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local e(33451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (fa) {
	case FInstance(classType, _, classFieldRef):
		var fieldName = classFieldRef.get().name;
		var classTypeName = classType.get().name;
		if (classTypeName == "String" && fieldName == "length") {
			return "String.length(${expr})";
		};
		if (classTypeName == "Array" && fieldName == "length") {
			return "length(${expr})";
		};
		if (fieldName == "length") {
			return "length(${expr})";
		};
		fieldName = NamingHelper.toSnakeCase(fieldName);
		var classRef = classType.get();
		if (!classRef.isExtern && !classRef.isInterface && !classRef.isAbstract) {
			return "${expr}.${fieldName}";
		};
		"${expr}.${fieldName}";	
	case FStatic(classType, classFieldRef):
		var cls = classType.get();
		var className = NamingHelper.getElixirModuleName(cls.getNameOrNative());
		var fieldName = NamingHelper.toSnakeCase(classFieldRef.get().name);
		if (cls.name == "PubSub" && cls.isExtern) {
			className = "Phoenix.PubSub";
		} else if (cls.name == "StringTools" && cls.isExtern) {
			className = "StringTools";
			fieldName = switch (fieldName) {
				case "isSpace":
					"is_space";				
				case "urlEncode":
					"url_encode";				
				case "urlDecode":
					"url_decode";				
				case "htmlEscape":
					"html_escape";				
				case "htmlUnescape":
					"html_unescape";				
				case "startsWith":
					"starts_with?";				
				case "endsWith":
					"ends_with?";				
				case "fastCodeAt":
					"fast_code_at";				
				case "unsafeCodeAt":
					"unsafe_code_at";				
				case "isEof":
					"is_eof";				
				case "utf16CodePointAt":
					"utf16_code_point_at";				
				case "keyValueIterator":
					"key_value_iterator";				
				case "quoteUnixArg":
					"quote_unix_arg";				
				case "quoteWinArg":
					"quote_win_arg";				
				case "winMetaCharacters":
					"win_meta_characters";				
				case other:
					NamingHelper.toSnakeCase(other);				
			};
		};
		if (className == "Option" && (fieldName == "Some" || fieldName == "None")) {
			if (fieldName == "Some") {
				return "fn value -> {:ok, value} end";
			} else if (fieldName == "None") {
				return ":error";
			};
		} else {
			fieldName = NamingHelper.getElixirFunctionName(fieldName);
		};
		"${className}.${fieldName}";	
	case FAnon(classFieldRef):
		var fieldName = classFieldRef.get().name;
		if (fieldName == "length") {
			return "length(${expr})";
		};
		fieldName = NamingHelper.toSnakeCase(fieldName);
		"${expr}.${fieldName}";	
	case FDynamic(s):
		if (s == "length") {
			return "length(${expr})";
		};
		var fieldName = NamingHelper.toSnakeCase(s);
		"${expr}.${fieldName}";	
	case FClosure(_, classFieldRef):
		var fieldName = NamingHelper.toSnakeCase(classFieldRef.get().name);
		"${expr}.${fieldName}";	
	case FEnum(enumType, enumField):
		var enumTypeRef = enumType.get();
		if (AlgebraicDataTypeCompiler.isADTType(enumTypeRef)) {
			var compiled = AlgebraicDataTypeCompiler.compileADTFieldAccess(enumTypeRef, enumField);
			if (compiled != null) return compiled;
		};
		var fieldName = NamingHelper.toSnakeCase(enumField.name);
		":${fieldName}";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(33515):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										0
								[Var `(33516):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										1
								[Var `(33517):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										2
								[Block:String]
									[Var classType(33518):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(33515):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Var classFieldRef(33519):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33517):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var fieldName(33520):String]
											[Field:String]
												[Call:haxe.macro.ClassField]
													[Field:() -> haxe.macro.ClassField]
														[Local classFieldRef(33519):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
														[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
												[FAnon:String] name:String
										[Var classTypeName(33521):String]
											[Field:String]
												[Call:haxe.macro.ClassType]
													[Field:() -> haxe.macro.ClassType]
														[Local classType(33518):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
														[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
												[FAnon:String] name:String
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local classTypeName(33521):String:String]
													==
													[Const:String] "String"
												&&
												[Binop:Bool]
													[Local fieldName(33520):String:String]
													==
													[Const:String] "length"
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] "String.length("
															+
															[Local expr(33480):Null<String>:Null<String>]
														+
														[Const:String] ")"
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local classTypeName(33521):String:String]
													==
													[Const:String] "Array"
												&&
												[Binop:Bool]
													[Local fieldName(33520):String:String]
													==
													[Const:String] "length"
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] "length("
															+
															[Local expr(33480):Null<String>:Null<String>]
														+
														[Const:String] ")"
										[If:Void]
											[Binop:Bool]
												[Local fieldName(33520):String:String]
												==
												[Const:String] "length"
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] "length("
															+
															[Local expr(33480):Null<String>:Null<String>]
														+
														[Const:String] ")"
										[Binop:String]
											[Local fieldName(33520):String:String]
											=
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Local fieldName(33520):String:String]
										[Var classRef(33522):haxe.macro.ClassType]
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local classType(33518):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Unop:Bool]
														!
														Prefix
														[Field:Bool]
															[Local classRef(33522):haxe.macro.ClassType:haxe.macro.ClassType]
															[FAnon:Bool] isExtern:Bool
													&&
													[Unop:Bool]
														!
														Prefix
														[Field:Bool]
															[Local classRef(33522):haxe.macro.ClassType:haxe.macro.ClassType]
															[FAnon:Bool] isInterface:Bool
												&&
												[Unop:Bool]
													!
													Prefix
													[Field:Bool]
														[Local classRef(33522):haxe.macro.ClassType:haxe.macro.ClassType]
														[FAnon:Bool] isAbstract:Bool
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] ""
																+
																[Local expr(33480):Null<String>:Null<String>]
															+
															[Const:String] "."
														+
														[Local fieldName(33520):String:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local expr(33480):Null<String>:Null<String>]
												+
												[Const:String] "."
											+
											[Local fieldName(33520):String:String]
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(33523):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FStatic
										0
								[Var `(33524):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FStatic
										1
								[Block:String]
									[Var classType(33525):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(33523):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Var classFieldRef(33526):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33524):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var cls(33527):haxe.macro.ClassType]
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local classType(33525):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
										[Var className(33528):String]
											[Call:String]
												[Field:(haxeName : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(haxeName : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														getElixirModuleName:(haxeName : String) -> String
												[Call:String]
													[Field:(v : reflaxe.helpers.NameAndMeta) -> String]
														[TypeExpr reflaxe.helpers.NameMetaHelper:{ Statics reflaxe.helpers.NameMetaHelper }]
														[FStatic:(v : reflaxe.helpers.NameAndMeta) -> String]
															reflaxe.helpers.NameMetaHelper
															getNameOrNative:(v : reflaxe.helpers.NameAndMeta) -> String
													[Local cls(33527):haxe.macro.ClassType:haxe.macro.ClassType]
										[Var fieldName(33529):String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Call:haxe.macro.ClassField]
														[Field:() -> haxe.macro.ClassField]
															[Local classFieldRef(33526):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
															[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
													[FAnon:String] name:String
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Field:String]
														[Local cls(33527):haxe.macro.ClassType:haxe.macro.ClassType]
														[FAnon:String] name:String
													==
													[Const:String] "PubSub"
												&&
												[Field:Bool]
													[Local cls(33527):haxe.macro.ClassType:haxe.macro.ClassType]
													[FAnon:Bool] isExtern:Bool
											[Then:String] [Block:String]
												[Binop:String]
													[Local className(33528):String:String]
													=
													[Const:String] "Phoenix.PubSub"
											[Else:Void] [Block:Void]
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Field:String]
																[Local cls(33527):haxe.macro.ClassType:haxe.macro.ClassType]
																[FAnon:String] name:String
															==
															[Const:String] "StringTools"
														&&
														[Field:Bool]
															[Local cls(33527):haxe.macro.ClassType:haxe.macro.ClassType]
															[FAnon:Bool] isExtern:Bool
													[Then:String] [Block:String]
														[Binop:String]
															[Local className(33528):String:String]
															=
															[Const:String] "StringTools"
														[Binop:String]
															[Local fieldName(33529):String:String]
															=
															[Meta:String]
																:ast(switch (fieldName) {
	case "isSpace":
		"is_space";	
	case "urlEncode":
		"url_encode";	
	case "urlDecode":
		"url_decode";	
	case "htmlEscape":
		"html_escape";	
	case "htmlUnescape":
		"html_unescape";	
	case "startsWith":
		"starts_with?";	
	case "endsWith":
		"ends_with?";	
	case "fastCodeAt":
		"fast_code_at";	
	case "unsafeCodeAt":
		"unsafe_code_at";	
	case "isEof":
		"is_eof";	
	case "utf16CodePointAt":
		"utf16_code_point_at";	
	case "keyValueIterator":
		"key_value_iterator";	
	case "quoteUnixArg":
		"quote_unix_arg";	
	case "quoteWinArg":
		"quote_win_arg";	
	case "winMetaCharacters":
		"win_meta_characters";	
	case other:
		NamingHelper.toSnakeCase(other);	
})
																[Switch:String]
																	[Local fieldName(33529):String:String]
																	[Case:String]
																		[Const:String] "endsWith"
																		[Block:String] [Block:String] [Const:String] "ends_with?"
																	[Case:String]
																		[Const:String] "fastCodeAt"
																		[Block:String] [Block:String] [Const:String] "fast_code_at"
																	[Case:String]
																		[Const:String] "htmlEscape"
																		[Block:String] [Block:String] [Const:String] "html_escape"
																	[Case:String]
																		[Const:String] "htmlUnescape"
																		[Block:String] [Block:String] [Const:String] "html_unescape"
																	[Case:String]
																		[Const:String] "isEof"
																		[Block:String] [Block:String] [Const:String] "is_eof"
																	[Case:String]
																		[Const:String] "isSpace"
																		[Block:String] [Block:String] [Const:String] "is_space"
																	[Case:String]
																		[Const:String] "keyValueIterator"
																		[Block:String] [Block:String] [Const:String] "key_value_iterator"
																	[Case:String]
																		[Const:String] "quoteUnixArg"
																		[Block:String] [Block:String] [Const:String] "quote_unix_arg"
																	[Case:String]
																		[Const:String] "quoteWinArg"
																		[Block:String] [Block:String] [Const:String] "quote_win_arg"
																	[Case:String]
																		[Const:String] "startsWith"
																		[Block:String] [Block:String] [Const:String] "starts_with?"
																	[Case:String]
																		[Const:String] "unsafeCodeAt"
																		[Block:String] [Block:String] [Const:String] "unsafe_code_at"
																	[Case:String]
																		[Const:String] "urlDecode"
																		[Block:String] [Block:String] [Const:String] "url_decode"
																	[Case:String]
																		[Const:String] "urlEncode"
																		[Block:String] [Block:String] [Const:String] "url_encode"
																	[Case:String]
																		[Const:String] "utf16CodePointAt"
																		[Block:String] [Block:String] [Const:String] "utf16_code_point_at"
																	[Case:String]
																		[Const:String] "winMetaCharacters"
																		[Block:String] [Block:String] [Const:String] "win_meta_characters"
																	[Default:String]
																		[Block:String]
																			[Var other(33530):String] [Local fieldName(33529):String:String]
																			[Block:String]
																				[Call:String]
																					[Field:(camelCase : String) -> String]
																						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																						[FStatic:(camelCase : String) -> String]
																							reflaxe.elixir.helpers.NamingHelper
																							toSnakeCase:(camelCase : String) -> String
																					[Local other(33530):String:String]
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local className(33528):String:String]
													==
													[Const:String] "Option"
												&&
												[Parenthesis:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local fieldName(33529):String:String]
															==
															[Const:String] "Some"
														||
														[Binop:Bool]
															[Local fieldName(33529):String:String]
															==
															[Const:String] "None"
											[Then:Void] [Block:Void]
												[If:Void]
													[Binop:Bool]
														[Local fieldName(33529):String:String]
														==
														[Const:String] "Some"
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "fn value -> {:ok, value} end"
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Local fieldName(33529):String:String]
																==
																[Const:String] "None"
															[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ":error"
											[Else:String] [Block:String]
												[Binop:String]
													[Local fieldName(33529):String:String]
													=
													[Call:String]
														[Field:(haxeName : String) -> String]
															[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
															[FStatic:(haxeName : String) -> String]
																reflaxe.elixir.helpers.NamingHelper
																getElixirFunctionName:(haxeName : String) -> String
														[Local fieldName(33529):String:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local className(33528):String:String]
												+
												[Const:String] "."
											+
											[Local fieldName(33529):String:String]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(33531):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FAnon
										0
								[Block:String]
									[Var classFieldRef(33532):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33531):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var fieldName(33533):String]
											[Field:String]
												[Call:haxe.macro.ClassField]
													[Field:() -> haxe.macro.ClassField]
														[Local classFieldRef(33532):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
														[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
												[FAnon:String] name:String
										[If:Void]
											[Binop:Bool]
												[Local fieldName(33533):String:String]
												==
												[Const:String] "length"
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] "length("
															+
															[Local expr(33480):Null<String>:Null<String>]
														+
														[Const:String] ")"
										[Binop:String]
											[Local fieldName(33533):String:String]
											=
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Local fieldName(33533):String:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local expr(33480):Null<String>:Null<String>]
												+
												[Const:String] "."
											+
											[Local fieldName(33533):String:String]
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(33534):String]
									[EnumParameter:String]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FDynamic
										0
								[Block:String]
									[Var s(33535):String] [Local `(33534):String:String]
									[Block:String]
										[If:Void]
											[Binop:Bool]
												[Local s(33535):String:String]
												==
												[Const:String] "length"
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] "length("
															+
															[Local expr(33480):Null<String>:Null<String>]
														+
														[Const:String] ")"
										[Var fieldName(33536):String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Local s(33535):String:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local expr(33480):Null<String>:Null<String>]
												+
												[Const:String] "."
											+
											[Local fieldName(33536):String:String]
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(33537):Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
									[EnumParameter:Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FClosure
										0
								[Var `(33538):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FClosure
										1
								[Block:String]
									[Var classFieldRef(33539):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33538):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var fieldName(33540):String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Call:haxe.macro.ClassField]
														[Field:() -> haxe.macro.ClassField]
															[Local classFieldRef(33539):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
															[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
													[FAnon:String] name:String
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local expr(33480):Null<String>:Null<String>]
												+
												[Const:String] "."
											+
											[Local fieldName(33540):String:String]
						[Case:String]
							[Const:Int] 5
							[Block:String]
								[Var `(33541):haxe.macro.Ref<haxe.macro.EnumType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FEnum
										0
								[Var `(33542):haxe.macro.EnumField]
									[EnumParameter:haxe.macro.EnumField]
										[Local fa(33452):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FEnum
										1
								[Block:String]
									[Var enumType(33543):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(33541):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
									[Var enumField(33544):haxe.macro.EnumField] [Local `(33542):haxe.macro.EnumField:haxe.macro.EnumField]
									[Block:String]
										[Var enumTypeRef(33545):haxe.macro.EnumType]
											[Call:haxe.macro.EnumType]
												[Field:() -> haxe.macro.EnumType]
													[Local enumType(33543):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
													[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
										[If:Void]
											[Call:Bool]
												[Field:(enumType : haxe.macro.EnumType) -> Bool]
													[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
													[FStatic:(enumType : haxe.macro.EnumType) -> Bool]
														reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
														isADTType:(enumType : haxe.macro.EnumType) -> Bool
												[Local enumTypeRef(33545):haxe.macro.EnumType:haxe.macro.EnumType]
											[Then:Void] [Block:Void]
												[Var compiled(33546):Null<String>]
													[Call:Null<String>]
														[Field:(enumType : haxe.macro.EnumType, enumField : haxe.macro.EnumField) -> Null<String>]
															[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
															[FStatic:(enumType : haxe.macro.EnumType, enumField : haxe.macro.EnumField) -> Null<String>]
																reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
																compileADTFieldAccess:(enumType : haxe.macro.EnumType, enumField : haxe.macro.EnumField) -> Null<String>
														[Local enumTypeRef(33545):haxe.macro.EnumType:haxe.macro.EnumType]
														[Local enumField(33544):haxe.macro.EnumField:haxe.macro.EnumField]
												[If:Void]
													[Binop:Bool]
														[Local compiled(33546):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiled(33546):Null<String>:Null<String>]
										[Var fieldName(33547):String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Local enumField(33544):haxe.macro.EnumField:haxe.macro.EnumField]
													[FAnon:String] name:String
										[Binop:String]
											[Const:String] ":"
											+
											[Local fieldName(33547):String:String]

	public function setFunctionParameterMapping[Function:(args : Array<reflaxe.data.ClassFuncArg>) -> Void]
		[Arg:Array<reflaxe.data.ClassFuncArg>] [Local args(23676):Array<reflaxe.data.ClassFuncArg>]
		[Block:Void]
			[Var savedThisMapping(23681):Null<String>]
				[Block:Null<String>]
					[Var this(23679):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Null<String>]
						[Field:(key : String) -> Null<String>]
							[Cast:haxe.ds.StringMap<String>] [Local this(23679):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Null<String>]
								haxe.ds.StringMap<String>
								get:(key : String) -> Null<haxe.ds.StringMap.T>
						[Const:String] "this"
			[Var savedUnderscoreThisMapping(23686):Null<String>]
				[Block:Null<String>]
					[Var this(23684):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Null<String>]
						[Field:(key : String) -> Null<String>]
							[Cast:haxe.ds.StringMap<String>] [Local this(23684):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Null<String>]
								haxe.ds.StringMap<String>
								get:(key : String) -> Null<haxe.ds.StringMap.T>
						[Const:String] "_this"
			[Var savedStructMapping(23691):Null<String>]
				[Block:Null<String>]
					[Var this(23689):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Null<String>]
						[Field:(key : String) -> Null<String>]
							[Cast:haxe.ds.StringMap<String>] [Local this(23689):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Null<String>]
								haxe.ds.StringMap<String>
								get:(key : String) -> Null<haxe.ds.StringMap.T>
						[Const:String] "struct"
			[Block:Void]
				[Var this(23694):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:() -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(23694):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:() -> Void]
							haxe.ds.StringMap<String>
							clear:() -> Void
			[Block:Void]
				[Var this(23697):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							inlineContextMap:Map<String, String>
				[Call:Void]
					[Field:() -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(23697):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:() -> Void]
							haxe.ds.StringMap<String>
							clear:() -> Void
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingAbstractMethod:Bool
				=
				[Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Local savedThisMapping(23681):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var this(23700):haxe.IMap<String, String>]
							[Field:Map<String, String>]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:Map<String, String>]
									reflaxe.elixir.ElixirCompiler
									currentFunctionParameterMap:Map<String, String>
						[Call:Void]
							[Field:(key : String, value : String) -> Void]
								[Cast:haxe.ds.StringMap<String>] [Local this(23700):haxe.IMap<String, String>:haxe.IMap<String, String>]
								[FInstance:(key : String, value : String) -> Void]
									haxe.ds.StringMap<String>
									set:(key : String, value : haxe.ds.StringMap.T) -> Void
							[Const:String] "this"
							[Local savedThisMapping(23681):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Local savedUnderscoreThisMapping(23686):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var this(23705):haxe.IMap<String, String>]
							[Field:Map<String, String>]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:Map<String, String>]
									reflaxe.elixir.ElixirCompiler
									currentFunctionParameterMap:Map<String, String>
						[Call:Void]
							[Field:(key : String, value : String) -> Void]
								[Cast:haxe.ds.StringMap<String>] [Local this(23705):haxe.IMap<String, String>:haxe.IMap<String, String>]
								[FInstance:(key : String, value : String) -> Void]
									haxe.ds.StringMap<String>
									set:(key : String, value : haxe.ds.StringMap.T) -> Void
							[Const:String] "_this"
							[Local savedUnderscoreThisMapping(23686):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Local savedStructMapping(23691):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var this(23710):haxe.IMap<String, String>]
							[Field:Map<String, String>]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:Map<String, String>]
									reflaxe.elixir.ElixirCompiler
									currentFunctionParameterMap:Map<String, String>
						[Call:Void]
							[Field:(key : String, value : String) -> Void]
								[Cast:haxe.ds.StringMap<String>] [Local this(23710):haxe.IMap<String, String>:haxe.IMap<String, String>]
								[FInstance:(key : String, value : String) -> Void]
									haxe.ds.StringMap<String>
									set:(key : String, value : haxe.ds.StringMap.T) -> Void
							[Const:String] "struct"
							[Local savedStructMapping(23691):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Local args(23676):Array<reflaxe.data.ClassFuncArg>:Array<reflaxe.data.ClassFuncArg>]
					!=
					[Const:Array<reflaxe.data.ClassFuncArg>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(23727):Int] [Const:Int] 0
						[Var `(23728):Int]
							[Field:Int]
								[Local args(23676):Array<reflaxe.data.ClassFuncArg>:Array<reflaxe.data.ClassFuncArg>]
								[FInstance:Int]
									Array<reflaxe.data.ClassFuncArg>
									length:Int
						[While:Void]
							[Binop:Bool]
								[Local `(23727):Int:Int]
								<
								[Local `(23728):Int:Int]
							[Block:Void]
								[Var i(23713):Int]
									[Unop:Int]
										++
										Postfix
										[Local `(23727):Int:Int]
								[Var arg(23714):reflaxe.data.ClassFuncArg]
									[Array:reflaxe.data.ClassFuncArg]
										[Local args(23676):Array<reflaxe.data.ClassFuncArg>:Array<reflaxe.data.ClassFuncArg>]
										[Local i(23713):Int:Int]
								[Var originalName(23715):String]
									[If:String]
										[Binop:Bool]
											[Field:Null<haxe.macro.TVar>]
												[Local arg(23714):reflaxe.data.ClassFuncArg:reflaxe.data.ClassFuncArg]
												[FInstance:Null<haxe.macro.TVar>]
													reflaxe.data.ClassFuncArg
													tvar:Null<haxe.macro.TVar>
											!=
											[Const:Null<haxe.macro.TVar>] null
										[Then:String] [Block:String]
											[Field:String]
												[Field:Null<haxe.macro.TVar>]
													[Local arg(23714):reflaxe.data.ClassFuncArg:reflaxe.data.ClassFuncArg]
													[FInstance:Null<haxe.macro.TVar>]
														reflaxe.data.ClassFuncArg
														tvar:Null<haxe.macro.TVar>
												[FAnon:String] name:String
										[Else:String] [Block:String]
											[Binop:String]
												[Const:String] "param"
												+
												[Local i(23713):Int:Int]
								[Var snakeCaseName(23716):String]
									[Call:String]
										[Field:(camelCase : String) -> String]
											[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
											[FStatic:(camelCase : String) -> String]
												reflaxe.elixir.helpers.NamingHelper
												toSnakeCase:(camelCase : String) -> String
										[Local originalName(23715):String:String]
								[Block:Void]
									[Var this(23719):haxe.IMap<String, String>]
										[Field:Map<String, String>]
											[Const:reflaxe.elixir.ElixirCompiler] this
											[FInstance:Map<String, String>]
												reflaxe.elixir.ElixirCompiler
												currentFunctionParameterMap:Map<String, String>
									[Call:Void]
										[Field:(key : String, value : String) -> Void]
											[Cast:haxe.ds.StringMap<String>] [Local this(23719):haxe.IMap<String, String>:haxe.IMap<String, String>]
											[FInstance:(key : String, value : String) -> Void]
												haxe.ds.StringMap<String>
												set:(key : String, value : haxe.ds.StringMap.T) -> Void
										[Local originalName(23715):String:String]
										[Local snakeCaseName(23716):String:String]
								[If:Void]
									[Binop:Bool]
										[Local originalName(23715):String:String]
										==
										[Const:String] "this"
									[Then:Void] [Block:Void]
										[Block:Void]
											[Var this(23724):haxe.IMap<String, String>]
												[Field:Map<String, String>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:Map<String, String>]
														reflaxe.elixir.ElixirCompiler
														currentFunctionParameterMap:Map<String, String>
											[Call:Void]
												[Field:(key : String, value : String) -> Void]
													[Cast:haxe.ds.StringMap<String>] [Local this(23724):haxe.IMap<String, String>:haxe.IMap<String, String>]
													[FInstance:(key : String, value : String) -> Void]
														haxe.ds.StringMap<String>
														set:(key : String, value : haxe.ds.StringMap.T) -> Void
												[Const:String] "this1"
												[Local snakeCaseName(23716):String:String]

	function resolveThisReference[Function:() -> String]
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(varName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:(varName : String) -> Bool]
							reflaxe.elixir.helpers.StateManagementCompiler
							hasInlineContext:(varName : String) -> Bool
					[Const:String] "struct"
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "struct"
			[If:Void]
				[Binop:Bool]
					[Field:Null<Map<String, Bool>>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Null<Map<String, Bool>>]
							reflaxe.elixir.ElixirCompiler
							liveViewInstanceVars:Null<Map<String, Bool>>
					!=
					[Const:Null<Map<String, Bool>>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "__LIVEVIEW_THIS__"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Field:reflaxe.elixir.helpers.StateManagementCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.StateManagementCompiler]
								reflaxe.elixir.ElixirCompiler
								stateManagementCompiler:reflaxe.elixir.helpers.StateManagementCompiler
						[FInstance:() -> String]
							reflaxe.elixir.helpers.StateManagementCompiler
							resolveThisReference:() -> String

	public function isFunctionReference[Function:(v : haxe.macro.TVar, originalName : String) -> Bool]
		[Arg:haxe.macro.TVar] [Local v(21677):haxe.macro.TVar]
		[Arg:String] [Local originalName(21678):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (v.t) {
	case TFun(_, _):
		return true;	
	case _:
		if (currentClassType != null) {
			var classFields = currentClassType.statics.get();
			for (field  in  classFields) {
				if (field.name == originalName && field.type.match(TFun(_, _))) {
					return true;
				};
			};
			var instanceFields = currentClassType.fields.get();
			for (field  in  instanceFields) {
				if (field.name == originalName && field.type.match(TFun(_, _))) {
					return true;
				};
			};
		};
		return false;	
})
				[Block:Void]
					[Var `(21700):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local v(21677):haxe.macro.TVar:haxe.macro.TVar]
							[FAnon:haxe.macro.Type] t:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(21700):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 4
						[Then:Dynamic] [Block:Dynamic]
							[Var `(21701):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
								[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[Local `(21700):haxe.macro.Type:haxe.macro.Type]
									TFun
									0
							[Var `(21702):haxe.macro.Type]
								[EnumParameter:haxe.macro.Type]
									[Local `(21700):haxe.macro.Type:haxe.macro.Type]
									TFun
									1
							[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Else:Dynamic] [Block:Dynamic]
							[If:Void]
								[Binop:Bool]
									[Field:Null<haxe.macro.ClassType>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:Null<haxe.macro.ClassType>]
											reflaxe.elixir.ElixirCompiler
											currentClassType:Null<haxe.macro.ClassType>
									!=
									[Const:Null<haxe.macro.ClassType>] null
								[Then:Void] [Block:Void]
									[Var classFields(21703):Array<haxe.macro.ClassField>]
										[Call:Array<haxe.macro.ClassField>]
											[Field:() -> Array<haxe.macro.ClassField>]
												[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
													[Field:Null<haxe.macro.ClassType>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:Null<haxe.macro.ClassType>]
															reflaxe.elixir.ElixirCompiler
															currentClassType:Null<haxe.macro.ClassType>
													[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] statics:haxe.macro.Ref<Array<haxe.macro.ClassField>>
												[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
									[Block:Void]
										[Var `(21704):Int] [Const:Int] 0
										[While:Void]
											[Binop:Bool]
												[Local `(21704):Int:Int]
												<
												[Field:Int]
													[Local classFields(21703):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
													[FInstance:Int]
														Array<haxe.macro.ClassField>
														length:Int
											[Block:Void]
												[Var field(21705):haxe.macro.ClassField]
													[Array:haxe.macro.ClassField]
														[Local classFields(21703):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
														[Local `(21704):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(21704):Int:Int]
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Field:String]
																[Local field(21705):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:String] name:String
															==
															[Local originalName(21678):String:String]
														&&
														[Block:Bool]
															[Var `(21706):haxe.macro.Type]
																[Field:haxe.macro.Type]
																	[Local field(21705):haxe.macro.ClassField:haxe.macro.ClassField]
																	[FAnon:haxe.macro.Type] type:haxe.macro.Type
															[If:Bool]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(21706):haxe.macro.Type:haxe.macro.Type]
																	==
																	[Const:Int] 4
																[Then:Bool] [Block:Bool]
																	[Var `(21707):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																			[Local `(21706):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			0
																	[Var `(21708):haxe.macro.Type]
																		[EnumParameter:haxe.macro.Type]
																			[Local `(21706):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			1
																	[Const:Bool] true
																[Else:Bool] [Const:Bool] false
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
									[Var instanceFields(21709):Array<haxe.macro.ClassField>]
										[Call:Array<haxe.macro.ClassField>]
											[Field:() -> Array<haxe.macro.ClassField>]
												[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
													[Field:Null<haxe.macro.ClassType>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:Null<haxe.macro.ClassType>]
															reflaxe.elixir.ElixirCompiler
															currentClassType:Null<haxe.macro.ClassType>
													[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
												[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
									[Block:Void]
										[Var `(21710):Int] [Const:Int] 0
										[While:Void]
											[Binop:Bool]
												[Local `(21710):Int:Int]
												<
												[Field:Int]
													[Local instanceFields(21709):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
													[FInstance:Int]
														Array<haxe.macro.ClassField>
														length:Int
											[Block:Void]
												[Var field(21711):haxe.macro.ClassField]
													[Array:haxe.macro.ClassField]
														[Local instanceFields(21709):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
														[Local `(21710):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(21710):Int:Int]
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Field:String]
																[Local field(21711):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:String] name:String
															==
															[Local originalName(21678):String:String]
														&&
														[Block:Bool]
															[Var `(21712):haxe.macro.Type]
																[Field:haxe.macro.Type]
																	[Local field(21711):haxe.macro.ClassField:haxe.macro.ClassField]
																	[FAnon:haxe.macro.Type] type:haxe.macro.Type
															[If:Bool]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(21712):haxe.macro.Type:haxe.macro.Type]
																	==
																	[Const:Int] 4
																[Then:Bool] [Block:Bool]
																	[Var `(21713):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																			[Local `(21712):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			0
																	[Var `(21714):haxe.macro.Type]
																		[EnumParameter:haxe.macro.Type]
																			[Local `(21712):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			1
																	[Const:Bool] true
																[Else:Bool] [Const:Bool] false
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
							[Return:Dynamic] [Const:Bool] false

	public function generateFunctionReference[Function:(functionName : String) -> String]
		[Arg:String] [Local functionName(21715):String]
		[Block:Dynamic]
			[Var elixirFunctionName(21716):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local functionName(21715):String:String]
			[Var currentModuleName(21717):String]
				[Call:String]
					[Field:() -> String]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:() -> String]
							reflaxe.elixir.ElixirCompiler
							getCurrentModuleName:() -> String
			[Var arity(21741):Int]
				[Call:Int]
					[Field:(functionName : String) -> Int]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(functionName : String) -> Int]
							reflaxe.elixir.ElixirCompiler
							getFunctionArity:(functionName : String) -> Int
					[Local functionName(21715):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "&"
									+
									[Local currentModuleName(21717):String:String]
								+
								[Const:String] "."
							+
							[Local elixirFunctionName(21716):String:String]
						+
						[Const:String] "/"
					+
					[Local arity(21741):Int:Int]

	public function getCurrentModuleName[Function:() -> String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Null<haxe.macro.ClassType>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
					!=
					[Const:Null<haxe.macro.ClassType>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Field:String]
							[Field:Null<haxe.macro.ClassType>]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:Null<haxe.macro.ClassType>]
									reflaxe.elixir.ElixirCompiler
									currentClassType:Null<haxe.macro.ClassType>
							[FAnon:String] name:String
			[Return:Dynamic] [Const:String] "UnknownModule"

	public function getModuleName[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25052):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Field:String]
					[Local classType(25052):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String

	function isBeingCalled[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33548):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function getFunctionArity[Function:(functionName : String) -> Int]
		[Arg:String] [Local functionName(21718):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Null<haxe.macro.ClassType>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
					!=
					[Const:Null<haxe.macro.ClassType>] null
				[Then:Void] [Block:Void]
					[Var classFields(21719):Array<haxe.macro.ClassField>]
						[Call:Array<haxe.macro.ClassField>]
							[Field:() -> Array<haxe.macro.ClassField>]
								[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
									[Field:Null<haxe.macro.ClassType>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:Null<haxe.macro.ClassType>]
											reflaxe.elixir.ElixirCompiler
											currentClassType:Null<haxe.macro.ClassType>
									[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] statics:haxe.macro.Ref<Array<haxe.macro.ClassField>>
								[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
					[Block:Void]
						[Var `(21729):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(21729):Int:Int]
								<
								[Field:Int]
									[Local classFields(21719):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
									[FInstance:Int]
										Array<haxe.macro.ClassField>
										length:Int
							[Block:Void]
								[Var field(21720):haxe.macro.ClassField]
									[Array:haxe.macro.ClassField]
										[Local classFields(21719):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
										[Local `(21729):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(21729):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Field:String]
											[Local field(21720):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:String] name:String
										==
										[Local functionName(21718):String:String]
									[Then:Void] [Block:Void]
										[Meta:Void]
											:ast(switch (field.type) {
	case TFun(args, _):
		return args.length;	
	case _:
})
											[Block:Void]
												[Var `(21725):haxe.macro.Type]
													[Field:haxe.macro.Type]
														[Local field(21720):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.Type] type:haxe.macro.Type
												[If:Void]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(21725):haxe.macro.Type:haxe.macro.Type]
														==
														[Const:Int] 4
													[Then:Dynamic] [Block:Dynamic]
														[Var `(21726):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
															[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																[Local `(21725):haxe.macro.Type:haxe.macro.Type]
																TFun
																0
														[Var `(21727):haxe.macro.Type]
															[EnumParameter:haxe.macro.Type]
																[Local `(21725):haxe.macro.Type:haxe.macro.Type]
																TFun
																1
														[Block:Dynamic]
															[Var args(21728):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(21726):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Field:Int]
																		[Local args(21728):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[FInstance:Int]
																			Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
																			length:Int
													[Else:Void] [Block:Void]
					[Var instanceFields(21730):Array<haxe.macro.ClassField>]
						[Call:Array<haxe.macro.ClassField>]
							[Field:() -> Array<haxe.macro.ClassField>]
								[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
									[Field:Null<haxe.macro.ClassType>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:Null<haxe.macro.ClassType>]
											reflaxe.elixir.ElixirCompiler
											currentClassType:Null<haxe.macro.ClassType>
									[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
								[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
					[Block:Void]
						[Var `(21740):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(21740):Int:Int]
								<
								[Field:Int]
									[Local instanceFields(21730):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
									[FInstance:Int]
										Array<haxe.macro.ClassField>
										length:Int
							[Block:Void]
								[Var field(21731):haxe.macro.ClassField]
									[Array:haxe.macro.ClassField]
										[Local instanceFields(21730):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
										[Local `(21740):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(21740):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Field:String]
											[Local field(21731):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:String] name:String
										==
										[Local functionName(21718):String:String]
									[Then:Void] [Block:Void]
										[Meta:Void]
											:ast(switch (field.type) {
	case TFun(args, _):
		return args.length;	
	case _:
})
											[Block:Void]
												[Var `(21736):haxe.macro.Type]
													[Field:haxe.macro.Type]
														[Local field(21731):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.Type] type:haxe.macro.Type
												[If:Void]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(21736):haxe.macro.Type:haxe.macro.Type]
														==
														[Const:Int] 4
													[Then:Dynamic] [Block:Dynamic]
														[Var `(21737):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
															[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																[Local `(21736):haxe.macro.Type:haxe.macro.Type]
																TFun
																0
														[Var `(21738):haxe.macro.Type]
															[EnumParameter:haxe.macro.Type]
																[Local `(21736):haxe.macro.Type:haxe.macro.Type]
																TFun
																1
														[Block:Dynamic]
															[Var args(21739):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(21737):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Field:Int]
																		[Local args(21739):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[FInstance:Int]
																			Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
																			length:Int
													[Else:Void] [Block:Void]
			[Return:Dynamic] [Const:Int] 1

	function compileBlockExpressionsWithContext[Function:(expressions : Array<haxe.macro.TypedExpr>) -> Array<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(33549):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Array<String>]
					[Field:(expressions : Array<haxe.macro.TypedExpr>) -> Array<String>]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expressions : Array<haxe.macro.TypedExpr>) -> Array<String>]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileBlockExpressionsWithContext:(expressions : Array<haxe.macro.TypedExpr>) -> Array<String>
					[Local expressions(33549):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function setCaseArmContext[Function:(inCaseArm : Bool) -> Void]
		[Arg:Bool] [Local inCaseArm(24147):Bool]
		[Block:Bool]
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingCaseArm:Bool
				=
				[Local inCaseArm(24147):Bool:Bool]

	public function clearFunctionParameterMapping[Function:() -> Void]
		[Block:Bool]
			[Block:Void]
				[Var this(33552):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:() -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(33552):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:() -> Void]
							haxe.ds.StringMap<String>
							clear:() -> Void
			[Binop:Bool]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						isCompilingAbstractMethod:Bool
				=
				[Const:Bool] false

	function compileMethodCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(33553):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(33554):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.MethodCallCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
								reflaxe.elixir.ElixirCompiler
								methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
						[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.MethodCallCompiler
							compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
					[Local e(33553):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local args(33554):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function detectReflectFieldsPattern[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local econd(33555):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33556):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
						[Field:reflaxe.elixir.helpers.PatternDetectionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternDetectionCompiler]
								reflaxe.elixir.ElixirCompiler
								patternDetectionCompiler:reflaxe.elixir.helpers.PatternDetectionCompiler
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.PatternDetectionCompiler
							detectReflectFieldsPattern:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>
					[Local econd(33555):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(33556):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function checkForTForInExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33557):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr) -> Bool]
						[Field:reflaxe.elixir.helpers.LoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.LoopCompiler]
								reflaxe.elixir.ElixirCompiler
								loopCompiler:reflaxe.elixir.helpers.LoopCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.LoopCompiler
							checkForTForInExpression:(expr : haxe.macro.TypedExpr) -> Bool
					[Local expr(33557):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function checkForReflectFieldsInExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33558):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr) -> Bool]
						[Field:reflaxe.elixir.helpers.ReflectionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ReflectionCompiler]
								reflaxe.elixir.ElixirCompiler
								reflectionCompiler:reflaxe.elixir.helpers.ReflectionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.ReflectionCompiler
							checkForReflectFieldsInExpression:(expr : haxe.macro.TypedExpr) -> Bool
					[Local expr(33558):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function containsTWhileExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33559):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr) -> Bool]
						[Field:reflaxe.elixir.helpers.LoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.LoopCompiler]
								reflaxe.elixir.ElixirCompiler
								loopCompiler:reflaxe.elixir.helpers.LoopCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.LoopCompiler
							containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
					[Local expr(33559):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function generateEnumFindPattern[Function:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(33560):String]
		[Arg:String] [Local loopVar(33561):String]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33562):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							generateEnumFindPattern:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String
					[Local arrayExpr(33560):String:String]
					[Local loopVar(33561):String:String]
					[Local ebody(33562):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function extractConditionFromReturn[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33563):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							extractConditionFromReturn:(expr : haxe.macro.TypedExpr) -> Null<String>
					[Local expr(33563):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function transformFindLoopBody[Function:(expr : haxe.macro.TypedExpr, loopVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33564):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(33565):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, loopVar : String) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, loopVar : String) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							transformFindLoopBody:(expr : haxe.macro.TypedExpr, loopVar : String) -> String
					[Local expr(33564):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(33565):String:String]

	function generateEnumCountPattern[Function:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(33566):String]
		[Arg:String] [Local loopVar(33567):String]
		[Arg:haxe.macro.TypedExpr] [Local conditionExpr(33568):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							generateEnumCountPattern:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String
					[Local arrayExpr(33566):String:String]
					[Local loopVar(33567):String:String]
					[Local conditionExpr(33568):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function findFirstLocalVariable[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33569):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							findFirstLocalVariable:(expr : haxe.macro.TypedExpr) -> Null<String>
					[Local expr(33569):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function findFirstLocalTVar[Function:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33570):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<haxe.macro.TVar>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							findFirstLocalTVar:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
					[Local expr(33570):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function generateEnumFilterPattern[Function:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(33571):String]
		[Arg:String] [Local loopVar(33572):String]
		[Arg:haxe.macro.TypedExpr] [Local conditionExpr(33573):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							generateEnumFilterPattern:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String
					[Local arrayExpr(33571):String:String]
					[Local loopVar(33572):String:String]
					[Local conditionExpr(33573):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function generateEnumMapPattern[Function:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(33574):String]
		[Arg:String] [Local loopVar(33575):String]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33576):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							generateEnumMapPattern:(arrayExpr : String, loopVar : String, ebody : haxe.macro.TypedExpr) -> String
					[Local arrayExpr(33574):String:String]
					[Local loopVar(33575):String:String]
					[Local ebody(33576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function findFirstTLocalInExpression[Function:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33577):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<haxe.macro.TVar>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							findFirstTLocalInExpression:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
					[Local expr(33577):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function findTLocalFromFieldAccess[Function:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33578):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<haxe.macro.TVar>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							findTLocalFromFieldAccess:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
					[Local expr(33578):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function findFirstTLocalInExpressionRecursive[Function:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33579):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<haxe.macro.TVar>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							findFirstTLocalInExpressionRecursive:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
					[Local expr(33579):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function extractTransformationFromBodyWithTVar[Function:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33580):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TVar] [Local sourceTVar(33581):haxe.macro.TVar]
		[Arg:String] [Local targetVarName(33582):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							extractTransformationFromBodyWithTVar:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
					[Local expr(33580):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceTVar(33581):haxe.macro.TVar:haxe.macro.TVar]
					[Local targetVarName(33582):String:String]

	function extractTransformationFromBody[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33583):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(33584):String]
		[Arg:String] [Local targetVar(33585):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							extractTransformationFromBody:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(33583):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(33584):String:String]
					[Local targetVar(33585):String:String]

	function getLambdaParameterFromBody[Function:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33586):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TFunction(func):
		if (func.args.length > 0) {
			return func.args[0].v;
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = getLambdaParameterFromBody(e);
			if (result != null) return result;
		};	
	case TBinop(_, e1, e2):
		var result = getLambdaParameterFromBody(e1);
		if (result != null) return result;
		return getLambdaParameterFromBody(e2);	
	case TCall(e, args):
		var result = getLambdaParameterFromBody(e);
		if (result != null) return result;
		for (arg  in  args) {
			result = getLambdaParameterFromBody(arg);
			if (result != null) return result;
		};	
	case TIf(econd, eif, eelse):
		var result = getLambdaParameterFromBody(econd);
		if (result != null) return result;
		result = getLambdaParameterFromBody(eif);
		if (result != null) return result;
		if (eelse != null) {
			result = getLambdaParameterFromBody(eelse);
			if (result != null) return result;
		};	
	case _:
})
				[Block:Void]
					[Var `(33615):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(33586):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 3
							[Block:Dynamic]
								[Var `(33616):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33617):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33618):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[Block:Dynamic]
									[Var e1(33619):haxe.macro.TypedExpr] [Local `(33617):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(33620):haxe.macro.TypedExpr] [Local `(33618):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Var result(33621):Null<haxe.macro.TVar>]
											[Call:Null<haxe.macro.TVar>]
												[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
														reflaxe.elixir.ElixirCompiler
														getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
												[Local e1(33619):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Local result(33621):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
												!=
												[Const:Null<haxe.macro.TVar>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33621):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
										[Return:Dynamic]
											[Call:Null<haxe.macro.TVar>]
												[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
														reflaxe.elixir.ElixirCompiler
														getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
												[Local e2(33620):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Void]
							[Const:Int] 9
							[Block:Void]
								[Var `(33622):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(33623):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Void]
									[Var e(33624):haxe.macro.TypedExpr] [Local `(33622):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var args(33625):Array<haxe.macro.TypedExpr>] [Local `(33623):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Var result(33626):Null<haxe.macro.TVar>]
											[Call:Null<haxe.macro.TVar>]
												[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
														reflaxe.elixir.ElixirCompiler
														getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
												[Local e(33624):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Local result(33626):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
												!=
												[Const:Null<haxe.macro.TVar>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33626):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
										[Block:Void]
											[Var `(33627):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(33627):Int:Int]
													<
													[Field:Int]
														[Local args(33625):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var arg(33628):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local args(33625):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(33627):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(33627):Int:Int]
													[Binop:Null<haxe.macro.TVar>]
														[Local result(33626):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
														=
														[Call:Null<haxe.macro.TVar>]
															[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
																	reflaxe.elixir.ElixirCompiler
																	getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
															[Local arg(33628):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[If:Void]
														[Binop:Bool]
															[Local result(33626):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
															!=
															[Const:Null<haxe.macro.TVar>] null
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33626):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
						[Case:Void]
							[Const:Int] 12
							[Block:Void]
								[Var `(33629):haxe.macro.TFunc]
									[EnumParameter:haxe.macro.TFunc]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFunction
										0
								[Block:Void]
									[Var func(33630):haxe.macro.TFunc] [Local `(33629):haxe.macro.TFunc:haxe.macro.TFunc]
									[Block:Void]
										[If:Void]
											[Binop:Bool]
												[Field:Int]
													[Field:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>]
														[Local func(33630):haxe.macro.TFunc:haxe.macro.TFunc]
														[FAnon:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>] args:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>
													[FInstance:Int]
														Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>
														length:Int
												>
												[Const:Int] 0
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Field:haxe.macro.TVar]
														[Array:{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }]
															[Field:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>]
																[Local func(33630):haxe.macro.TFunc:haxe.macro.TFunc]
																[FAnon:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>] args:Array<{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }>
															[Const:Int] 0
														[FAnon:haxe.macro.TVar] v:haxe.macro.TVar
						[Case:Void]
							[Const:Int] 14
							[Block:Void]
								[Var `(33631):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Void]
									[Var exprs(33632):Array<haxe.macro.TypedExpr>] [Local `(33631):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Block:Void]
											[Var `(33633):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(33633):Int:Int]
													<
													[Field:Int]
														[Local exprs(33632):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(33634):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(33632):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(33633):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(33633):Int:Int]
													[Var result(33635):Null<haxe.macro.TVar>]
														[Call:Null<haxe.macro.TVar>]
															[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
																	reflaxe.elixir.ElixirCompiler
																	getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
															[Local e(33634):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[If:Void]
														[Binop:Bool]
															[Local result(33635):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
															!=
															[Const:Null<haxe.macro.TVar>] null
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33635):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
						[Case:Void]
							[Const:Int] 16
							[Block:Void]
								[Var `(33636):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(33637):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(33638):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(33615):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Void]
									[Var econd(33639):haxe.macro.TypedExpr] [Local `(33636):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eif(33640):haxe.macro.TypedExpr] [Local `(33637):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eelse(33641):Null<haxe.macro.TypedExpr>] [Local `(33638):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Void]
										[Var result(33642):Null<haxe.macro.TVar>]
											[Call:Null<haxe.macro.TVar>]
												[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
														reflaxe.elixir.ElixirCompiler
														getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
												[Local econd(33639):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
												!=
												[Const:Null<haxe.macro.TVar>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
										[Binop:Null<haxe.macro.TVar>]
											[Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
											=
											[Call:Null<haxe.macro.TVar>]
												[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
													[Const:reflaxe.elixir.ElixirCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
														reflaxe.elixir.ElixirCompiler
														getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
												[Local eif(33640):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
												!=
												[Const:Null<haxe.macro.TVar>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
										[If:Void]
											[Binop:Bool]
												[Local eelse(33641):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Void] [Block:Void]
												[Binop:Null<haxe.macro.TVar>]
													[Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
													=
													[Call:Null<haxe.macro.TVar>]
														[Field:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>]
																reflaxe.elixir.ElixirCompiler
																getLambdaParameterFromBody:(expr : haxe.macro.TypedExpr) -> Null<haxe.macro.TVar>
														[Local eelse(33641):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[If:Void]
													[Binop:Bool]
														[Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
														!=
														[Const:Null<haxe.macro.TVar>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33642):Null<haxe.macro.TVar>:Null<haxe.macro.TVar>]
						[Default:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<haxe.macro.TVar>] null

	function compileExpressionWithVarMapping[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33643):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(33644):String]
		[Arg:String] [Local targetVar(33645):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionWithVarMapping:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(33643):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(33644):String:String]
					[Local targetVar(33645):String:String]

	function isSystemVariable[Function:(varName : String) -> Bool]
		[Arg:String] [Local varName(22246):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(varName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(varName : String) -> Bool]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							isSystemVariable:(varName : String) -> Bool
					[Local varName(22246):String:String]

	@:value({ isAggressiveMode : false, sourceVar : null })
	public function shouldSubstituteVariable[Function:(varName : String, ?sourceVar : Null<String>, ?isAggressiveMode : Bool) -> Bool]
		[Arg:String] [Local varName(22243):String]
		[Arg:Null<String>]
			[Local sourceVar(22244):Null<String>]
			[Const:Null<String>] null
		[Arg:Bool]
			[Local isAggressiveMode(22245):Bool]
			[Const:Bool] false
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(varName : String) -> Bool]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(varName : String) -> Bool]
							reflaxe.elixir.ElixirCompiler
							isSystemVariable:(varName : String) -> Bool
					[Local varName(22243):String:String]
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Local sourceVar(22244):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:Bool]
							[Local varName(22243):String:String]
							==
							[Local sourceVar(22244):Null<String>:Null<String>]
			[If:Void]
				[Local isAggressiveMode(22245):Bool:Bool]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Field:Bool]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:Bool]
								reflaxe.elixir.ElixirCompiler
								isInLoopContext:Bool
			[Return:Dynamic] [Const:Bool] false

	function compileExpressionWithAggressiveSubstitution[Function:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33646):haxe.macro.TypedExpr]
		[Arg:String] [Local targetVar(33647):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionWithAggressiveSubstitution:(expr : haxe.macro.TypedExpr, targetVar : String) -> String
					[Local expr(33646):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local targetVar(33647):String:String]

	function extractTransformationFromBodyWithAggressiveSubstitution[Function:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33648):haxe.macro.TypedExpr]
		[Arg:String] [Local targetVar(33649):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							extractTransformationFromBodyWithAggressiveSubstitution:(expr : haxe.macro.TypedExpr, targetVar : String) -> String
					[Local expr(33648):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local targetVar(33649):String:String]

	public function compileExpressionWithTVarSubstitution[Function:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(22233):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TVar] [Local sourceTVar(22234):haxe.macro.TVar]
		[Arg:String] [Local targetVarName(22235):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
					[Local expr(22233):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceTVar(22234):haxe.macro.TVar:haxe.macro.TVar]
					[Local targetVarName(22235):String:String]

	function compileWhileLoopWithRenamings[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool, renamings : Map<String, String>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(33650):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33651):haxe.macro.TypedExpr]
		[Arg:Bool] [Local normalWhile(33652):Bool]
		[Arg:Map<String, String>] [Local renamings(33653):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool, renamings : Map<String, String>) -> String]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool, renamings : Map<String, String>) -> String]
							reflaxe.elixir.helpers.WhileLoopCompiler
							compileWhileLoopWithRenamings:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool, renamings : Map<String, String>) -> String
					[Local econd(33650):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(33651):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local normalWhile(33652):Bool:Bool]
					[Local renamings(33653):Map<String, String>:Map<String, String>]

	public function compileExpressionWithRenaming[Function:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(30527):haxe.macro.TypedExpr]
		[Arg:Map<String, String>] [Local renamings(30528):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithRenaming:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String
					[Local expr(30527):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local renamings(30528):Map<String, String>:Map<String, String>]

	function compileExpressionWithSubstitution[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33654):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(33655):String]
		[Arg:String] [Local targetVar(33656):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithSubstitution:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(33654):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(33655):String:String]
					[Local targetVar(33656):String:String]

	function extractVariableFromCondition[Function:(condition : String) -> Null<String>]
		[Arg:String] [Local condition(33657):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(condition : String) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(condition : String) -> Null<String>]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							extractVariableFromCondition:(condition : String) -> Null<String>
					[Local condition(33657):String:String]

	function analyzeRangeLoopBody[Function:(ebody : haxe.macro.TypedExpr) -> { loopVar : String, isAddition : Bool, hasSimpleAccumulator : Bool, accumulator : String }]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33658):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ loopVar : String, isAddition : Bool, hasSimpleAccumulator : Bool, accumulator : String }]
					[Field:(ebody : haxe.macro.TypedExpr) -> { loopVar : String, isAddition : Bool, hasSimpleAccumulator : Bool, accumulator : String }]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(ebody : haxe.macro.TypedExpr) -> { loopVar : String, isAddition : Bool, hasSimpleAccumulator : Bool, accumulator : String }]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							analyzeRangeLoopBody:(ebody : haxe.macro.TypedExpr) -> { loopVar : String, isAddition : Bool, hasSimpleAccumulator : Bool, accumulator : String }
					[Local ebody(33658):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function transformComplexLoopBody[Function:(ebody : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33659):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(ebody : haxe.macro.TypedExpr) -> String]
						[Field:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayOptimizationCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayOptimizationCompiler:reflaxe.elixir.helpers.ArrayOptimizationCompiler
						[FInstance:(ebody : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ArrayOptimizationCompiler
							transformComplexLoopBody:(ebody : haxe.macro.TypedExpr) -> String
					[Local ebody(33659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function compileWhileLoop[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(33660):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33661):haxe.macro.TypedExpr]
		[Arg:Bool] [Local normalWhile(33662):Bool]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
							reflaxe.elixir.helpers.WhileLoopCompiler
							compileWhileLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
					[Local econd(33660):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(33661):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local normalWhile(33662):Bool:Bool]

	function detectArrayBuildingPattern[Function:(ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33663):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
					[Field:(ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
							reflaxe.elixir.helpers.WhileLoopCompiler
							detectArrayBuildingPattern:(ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>
					[Local ebody(33663):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function compileArrayBuildingLoop[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(33664):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33665):haxe.macro.TypedExpr]
		[Arg:{ indexVar : String, arrayExpr : String, accumVar : String }] [Local pattern(33666):{ indexVar : String, arrayExpr : String, accumVar : String }]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
							reflaxe.elixir.helpers.WhileLoopCompiler
							compileArrayBuildingLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String
					[Local econd(33664):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(33665):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local pattern(33666):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]

	function extractArrayTransformation[Function:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33667):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(33668):String]
		[Arg:String] [Local accumVar(33669):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
							reflaxe.elixir.helpers.WhileLoopCompiler
							extractArrayTransformation:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>
					[Local ebody(33667):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local indexVar(33668):String:String]
					[Local accumVar(33669):String:String]

	function compileWhileLoopGeneric[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(33670):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(33671):haxe.macro.TypedExpr]
		[Arg:Bool] [Local normalWhile(33672):Bool]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
							reflaxe.elixir.helpers.WhileLoopCompiler
							compileWhileLoopGeneric:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
					[Local econd(33670):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(33671):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local normalWhile(33672):Bool:Bool]

	function extractModifiedVariables[Function:(expr : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33673):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Array<{ type : String, name : String }>]
					[Field:(expr : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
							reflaxe.elixir.helpers.WhileLoopCompiler
							extractModifiedVariables:(expr : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>
					[Local expr(33673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function transformLoopBodyMutations[Function:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33674):haxe.macro.TypedExpr]
		[Arg:Array<{ type : String, name : String }>] [Local modifiedVars(33675):Array<{ type : String, name : String }>]
		[Arg:Bool] [Local normalWhile(33676):Bool]
		[Arg:String] [Local condition(33677):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
						[Field:reflaxe.elixir.helpers.WhileLoopCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.WhileLoopCompiler]
								reflaxe.elixir.ElixirCompiler
								whileLoopCompiler:reflaxe.elixir.helpers.WhileLoopCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
							reflaxe.elixir.helpers.WhileLoopCompiler
							transformLoopBodyMutations:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String
					[Local expr(33674):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local modifiedVars(33675):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
					[Local normalWhile(33676):Bool:Bool]
					[Local condition(33677):String:String]

	function compileExpressionWithMutationTracking[Function:(expr : haxe.macro.TypedExpr, updates : Map<String, String>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33678):haxe.macro.TypedExpr]
		[Arg:Map<String, String>] [Local updates(33679):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, updates : Map<String, String>) -> String]
						[Field:reflaxe.elixir.helpers.ExpressionVariantCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ExpressionVariantCompiler]
								reflaxe.elixir.ElixirCompiler
								expressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, updates : Map<String, String>) -> String]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compileExpressionWithMutationTracking:(expr : haxe.macro.TypedExpr, updates : Map<String, String>) -> String
					[Local expr(33678):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local updates(33679):Map<String, String>:Map<String, String>]

	public function isArrayMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22160):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(methodName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.ArrayMethodCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayMethodCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayMethodCompiler:reflaxe.elixir.helpers.ArrayMethodCompiler
						[FInstance:(methodName : String) -> Bool]
							reflaxe.elixir.helpers.ArrayMethodCompiler
							isArrayMethod:(methodName : String) -> Bool
					[Local methodName(22160):String:String]

	public function isMapMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22533):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(methodName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.MapToolsCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MapToolsCompiler]
								reflaxe.elixir.ElixirCompiler
								mapToolsCompiler:reflaxe.elixir.helpers.MapToolsCompiler
						[FInstance:(methodName : String) -> Bool]
							reflaxe.elixir.helpers.MapToolsCompiler
							isMapMethod:(methodName : String) -> Bool
					[Local methodName(22533):String:String]

	public function isOptionMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22136):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(methodName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.ADTMethodCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ADTMethodCompiler]
								reflaxe.elixir.ElixirCompiler
								adtMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler
						[FInstance:(methodName : String) -> Bool]
							reflaxe.elixir.helpers.ADTMethodCompiler
							isOptionMethod:(methodName : String) -> Bool
					[Local methodName(22136):String:String]

	public function isResultMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22148):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(methodName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.ADTMethodCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ADTMethodCompiler]
								reflaxe.elixir.ElixirCompiler
								adtMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler
						[FInstance:(methodName : String) -> Bool]
							reflaxe.elixir.helpers.ADTMethodCompiler
							isResultMethod:(methodName : String) -> Bool
					[Local methodName(22148):String:String]

	public function compileADTStaticExtension[Function:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
		[Arg:haxe.macro.EnumType] [Local enumType(22826):haxe.macro.EnumType]
		[Arg:String] [Local methodName(22827):String]
		[Arg:String] [Local objStr(22828):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22829):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ADTMethodCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ADTMethodCompiler]
								reflaxe.elixir.ElixirCompiler
								adtMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler
						[FInstance:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
							reflaxe.elixir.helpers.ADTMethodCompiler
							compileADTStaticExtension:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>
					[Local enumType(22826):haxe.macro.EnumType:haxe.macro.EnumType]
					[Local methodName(22827):String:String]
					[Local objStr(22828):String:String]
					[Local args(22829):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function compileArrayMethod[Function:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local objStr(22166):String]
		[Arg:String] [Local methodName(22167):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22168):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.ArrayMethodCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ArrayMethodCompiler]
								reflaxe.elixir.ElixirCompiler
								arrayMethodCompiler:reflaxe.elixir.helpers.ArrayMethodCompiler
						[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.ArrayMethodCompiler
							compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
					[Local objStr(22166):String:String]
					[Local methodName(22167):String:String]
					[Local args(22168):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function compileMapMethod[Function:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local objStr(22539):String]
		[Arg:String] [Local methodName(22540):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22541):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.MapToolsCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MapToolsCompiler]
								reflaxe.elixir.ElixirCompiler
								mapToolsCompiler:reflaxe.elixir.helpers.MapToolsCompiler
						[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.MapToolsCompiler
							compileMapMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
					[Local objStr(22539):String:String]
					[Local methodName(22540):String:String]
					[Local args(22541):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function compileHxxCall[Function:(args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22135):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(22135):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					!=
					[Const:Int] 1
				[Then:Dynamic] [Block:Dynamic]
					[Call:Dynamic]
						[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
								haxe.macro.Context
								error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
						[Const:String] "hxx() expects exactly one string argument"
						[Call:haxe.macro.Position]
							[Field:() -> haxe.macro.Position]
								[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
								[FStatic:() -> haxe.macro.Position]
									haxe.macro.Context
									currentPos:() -> haxe.macro.Position
						[Const:Null<Int>] null
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr) -> String]
						[TypeExpr reflaxe.elixir.helpers.HxxCompiler:Class<reflaxe.elixir.helpers.HxxCompiler>]
						[FStatic:(expr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.HxxCompiler
							compileHxxTemplate:(expr : haxe.macro.TypedExpr) -> String
					[Array:haxe.macro.TypedExpr]
						[Local args(22135):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[Const:Int] 0

	function compileStringMethod[Function:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local objStr(33680):String]
		[Arg:String] [Local methodName(33681):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(33682):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(33684):reflaxe.elixir.ElixirCompiler] [Const:reflaxe.elixir.ElixirCompiler] this
			[Var compiledArgs(33693):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(33688):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(33689):Int] [Const:Int] 0
						[Var `(33690):Array<haxe.macro.TypedExpr>] [Local args(33682):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(33689):Int:Int]
								<
								[Field:Int]
									[Local `(33690):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(33691):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(33690):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(33689):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33689):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(33688):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(33692):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Local `this(33684):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(33692):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(33691):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(33688):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodName) {
	case "charCodeAt":
		if (compiledArgs.length > 0) {
			"case String.at(${objStr}, ${compiledArgs[0]}) do nil -> nil; c -> :binary.first(c) end";
		} else {
			"nil";
		};	
	case "charAt":
		if (compiledArgs.length > 0) {
			"String.at(${objStr}, ${compiledArgs[0]})";
		} else {
			"\"\"";
		};	
	case "toLowerCase":
		"String.downcase(${objStr})";	
	case "toUpperCase":
		"String.upcase(${objStr})";	
	case "substr" | "substring":
		if (compiledArgs.length >= 2) {
			"String.slice(${objStr}, ${compiledArgs[0]}, ${compiledArgs[1]})";
		} else if (compiledArgs.length == 1) {
			"String.slice(${objStr}, ${compiledArgs[0]}..-1)";
		} else {
			objStr;
		};	
	case "indexOf":
		if (compiledArgs.length > 0) {
			"case :binary.match(${objStr}, ${compiledArgs[0]}) do {pos, _} -> pos; :nomatch -> -1 end";
		} else {
			"-1";
		};	
	case "split":
		if (compiledArgs.length > 0) {
			"String.split(${objStr}, ${compiledArgs[0]})";
		} else {
			"[${objStr}]";
		};	
	case "trim":
		"String.trim(${objStr})";	
	case "length":
		"String.length(${objStr})";	
	case _:
		"${objStr}.${methodName}(${compiledArgs.join(\", \")})";	
})
					[Switch:String]
						[Local methodName(33681):String:String]
						[Case:String]
							[Const:String] "charAt"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:Int]
													Array<Null<String>>
													length:Int
											>
											[Const:Int] 0
										[Then:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "String.at("
															+
															[Local objStr(33680):String:String]
														+
														[Const:String] ", "
													+
													[Array:Null<String>]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[Const:Int] 0
												+
												[Const:String] ")"
										[Else:String] [Block:String] [Const:String] "\"\""
						[Case:String]
							[Const:String] "charCodeAt"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:Int]
													Array<Null<String>>
													length:Int
											>
											[Const:Int] 0
										[Then:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "case String.at("
															+
															[Local objStr(33680):String:String]
														+
														[Const:String] ", "
													+
													[Array:Null<String>]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[Const:Int] 0
												+
												[Const:String] ") do nil -> nil; c -> :binary.first(c) end"
										[Else:String] [Block:String] [Const:String] "nil"
						[Case:String]
							[Const:String] "indexOf"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:Int]
													Array<Null<String>>
													length:Int
											>
											[Const:Int] 0
										[Then:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "case :binary.match("
															+
															[Local objStr(33680):String:String]
														+
														[Const:String] ", "
													+
													[Array:Null<String>]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[Const:Int] 0
												+
												[Const:String] ") do {pos, _} -> pos; :nomatch -> -1 end"
										[Else:String] [Block:String] [Const:String] "-1"
						[Case:String]
							[Const:String] "length"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "String.length("
											+
											[Local objStr(33680):String:String]
										+
										[Const:String] ")"
						[Case:String]
							[Const:String] "split"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:Int]
													Array<Null<String>>
													length:Int
											>
											[Const:Int] 0
										[Then:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "String.split("
															+
															[Local objStr(33680):String:String]
														+
														[Const:String] ", "
													+
													[Array:Null<String>]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[Const:Int] 0
												+
												[Const:String] ")"
										[Else:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "["
													+
													[Local objStr(33680):String:String]
												+
												[Const:String] "]"
						[Case:String]
							[Const:String] "substr"
							[Const:String] "substring"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:Int]
													Array<Null<String>>
													length:Int
											>=
											[Const:Int] 2
										[Then:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] "String.slice("
																	+
																	[Local objStr(33680):String:String]
																+
																[Const:String] ", "
															+
															[Array:Null<String>]
																[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
																[Const:Int] 0
														+
														[Const:String] ", "
													+
													[Array:Null<String>]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[Const:Int] 1
												+
												[Const:String] ")"
										[Else:String] [Block:String]
											[If:String]
												[Binop:Bool]
													[Field:Int]
														[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
														[FInstance:Int]
															Array<Null<String>>
															length:Int
													==
													[Const:Int] 1
												[Then:String] [Block:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] "String.slice("
																	+
																	[Local objStr(33680):String:String]
																+
																[Const:String] ", "
															+
															[Array:Null<String>]
																[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
																[Const:Int] 0
														+
														[Const:String] "..-1)"
												[Else:String] [Block:String] [Local objStr(33680):String:String]
						[Case:String]
							[Const:String] "toLowerCase"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "String.downcase("
											+
											[Local objStr(33680):String:String]
										+
										[Const:String] ")"
						[Case:String]
							[Const:String] "toUpperCase"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "String.upcase("
											+
											[Local objStr(33680):String:String]
										+
										[Const:String] ")"
						[Case:String]
							[Const:String] "trim"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "String.trim("
											+
											[Local objStr(33680):String:String]
										+
										[Const:String] ")"
						[Default:String]
							[Block:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local objStr(33680):String:String]
													+
													[Const:String] "."
												+
												[Local methodName(33681):String:String]
											+
											[Const:String] "("
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(33693):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"

	function detectSchemaFromArgs[Function:(args : Array<haxe.macro.TypedExpr>) -> Null<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(33694):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(args : Array<haxe.macro.TypedExpr>) -> Null<String>]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(args : Array<haxe.macro.TypedExpr>) -> Null<String>]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							detectSchemaFromArgs:(args : Array<haxe.macro.TypedExpr>) -> Null<String>
					[Local args(33694):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function getFieldName[Function:(fa : haxe.macro.FieldAccess) -> String]
		[Arg:haxe.macro.FieldAccess] [Local fa(21995):haxe.macro.FieldAccess]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf):
		var field = cf.get();
		if (field.meta != null && field.meta.has(":native")) {
			var nativeMeta = field.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				var nativeName = switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						s;					
					default:
						field.name;					
				};
				return nativeName;
			};
		};
		return NamingHelper.toSnakeCase(field.name);	
	case FAnon(cf):
		var field = cf.get();
		if (field.meta != null && field.meta.has(":native")) {
			var nativeMeta = field.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				var nativeName = switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						s;					
					default:
						field.name;					
				};
				return nativeName;
			};
		};
		return NamingHelper.toSnakeCase(field.name);	
	case FDynamic(s):
		NamingHelper.toSnakeCase(s);	
	case FEnum(_, ef):
		NamingHelper.toSnakeCase(ef.name);	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(22037):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										0
								[Var `(22038):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										1
								[Var `(22039):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FInstance
										2
								[Block:String]
									[Var cf(22040):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(22039):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var field(22041):haxe.macro.ClassField]
											[Call:haxe.macro.ClassField]
												[Field:() -> haxe.macro.ClassField]
													[Local cf(22040):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
													[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Field:haxe.macro.MetaAccess]
														[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
													!=
													[Const:haxe.macro.MetaAccess] null
												&&
												[Call:Bool]
													[Field:(name : String) -> Bool]
														[Field:haxe.macro.MetaAccess]
															[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
															[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
														[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
													[Const:String] ":native"
											[Then:Void] [Block:Void]
												[Var nativeMeta(22042):Array<haxe.macro.MetadataEntry>]
													[Call:Array<haxe.macro.MetadataEntry>]
														[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
															[Field:haxe.macro.MetaAccess]
																[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
															[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
														[Const:String] ":native"
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Field:Int]
																	[Local nativeMeta(22042):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																	[FInstance:Int]
																		Array<haxe.macro.MetadataEntry>
																		length:Int
																>
																[Const:Int] 0
															&&
															[Binop:Bool]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22042):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																!=
																[Const:Null<Array<haxe.macro.Expr>>] null
														&&
														[Binop:Bool]
															[Field:Int]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22042):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																[FInstance:Int]
																	Array<haxe.macro.Expr>
																	length:Int
															>
															[Const:Int] 0
													[Then:Dynamic] [Block:Dynamic]
														[Var nativeName(22043):String]
															[Meta:String]
																:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		field.name;	
})
																[Block:String]
																	[Var `(22044):haxe.macro.ExprDef]
																		[Field:haxe.macro.ExprDef]
																			[Array:haxe.macro.Expr]
																				[Field:Null<Array<haxe.macro.Expr>>]
																					[Array:haxe.macro.MetadataEntry]
																						[Local nativeMeta(22042):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																						[Const:Int] 0
																					[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																				[Const:Int] 0
																			[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
																	[If:String]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(22044):haxe.macro.ExprDef:haxe.macro.ExprDef]
																			==
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Var `(22045):haxe.macro.Constant]
																				[EnumParameter:haxe.macro.Constant]
																					[Local `(22044):haxe.macro.ExprDef:haxe.macro.ExprDef]
																					EConst
																					0
																			[If:String]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(22045):haxe.macro.Constant:haxe.macro.Constant]
																					==
																					[Const:Int] 2
																				[Then:String] [Block:String]
																					[Var `(22046):String]
																						[EnumParameter:String]
																							[Local `(22045):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							0
																					[Var `(22047):Null<haxe.macro.StringLiteralKind>]
																						[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																							[Local `(22045):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							1
																					[Block:String]
																						[Var s(22048):String] [Local `(22046):String:String]
																						[Block:String] [Local s(22048):String:String]
																				[Else:String] [Block:String]
																					[Field:String]
																						[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
																						[FAnon:String] name:String
																		[Else:String] [Block:String]
																			[Field:String]
																				[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
																				[FAnon:String] name:String
														[Return:Dynamic] [Local nativeName(22043):String:String]
										[Return:String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Local field(22041):haxe.macro.ClassField:haxe.macro.ClassField]
													[FAnon:String] name:String
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(22049):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FStatic
										0
								[Var `(22050):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FStatic
										1
								[Block:String]
									[Var cf(22051):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(22050):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var field(22052):haxe.macro.ClassField]
											[Call:haxe.macro.ClassField]
												[Field:() -> haxe.macro.ClassField]
													[Local cf(22051):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
													[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Field:haxe.macro.MetaAccess]
														[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
													!=
													[Const:haxe.macro.MetaAccess] null
												&&
												[Call:Bool]
													[Field:(name : String) -> Bool]
														[Field:haxe.macro.MetaAccess]
															[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
															[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
														[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
													[Const:String] ":native"
											[Then:Void] [Block:Void]
												[Var nativeMeta(22053):Array<haxe.macro.MetadataEntry>]
													[Call:Array<haxe.macro.MetadataEntry>]
														[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
															[Field:haxe.macro.MetaAccess]
																[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
															[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
														[Const:String] ":native"
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Field:Int]
																	[Local nativeMeta(22053):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																	[FInstance:Int]
																		Array<haxe.macro.MetadataEntry>
																		length:Int
																>
																[Const:Int] 0
															&&
															[Binop:Bool]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22053):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																!=
																[Const:Null<Array<haxe.macro.Expr>>] null
														&&
														[Binop:Bool]
															[Field:Int]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22053):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																[FInstance:Int]
																	Array<haxe.macro.Expr>
																	length:Int
															>
															[Const:Int] 0
													[Then:Dynamic] [Block:Dynamic]
														[Var nativeName(22054):String]
															[Meta:String]
																:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		field.name;	
})
																[Block:String]
																	[Var `(22055):haxe.macro.ExprDef]
																		[Field:haxe.macro.ExprDef]
																			[Array:haxe.macro.Expr]
																				[Field:Null<Array<haxe.macro.Expr>>]
																					[Array:haxe.macro.MetadataEntry]
																						[Local nativeMeta(22053):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																						[Const:Int] 0
																					[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																				[Const:Int] 0
																			[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
																	[If:String]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(22055):haxe.macro.ExprDef:haxe.macro.ExprDef]
																			==
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Var `(22056):haxe.macro.Constant]
																				[EnumParameter:haxe.macro.Constant]
																					[Local `(22055):haxe.macro.ExprDef:haxe.macro.ExprDef]
																					EConst
																					0
																			[If:String]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(22056):haxe.macro.Constant:haxe.macro.Constant]
																					==
																					[Const:Int] 2
																				[Then:String] [Block:String]
																					[Var `(22057):String]
																						[EnumParameter:String]
																							[Local `(22056):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							0
																					[Var `(22058):Null<haxe.macro.StringLiteralKind>]
																						[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																							[Local `(22056):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							1
																					[Block:String]
																						[Var s(22059):String] [Local `(22057):String:String]
																						[Block:String] [Local s(22059):String:String]
																				[Else:String] [Block:String]
																					[Field:String]
																						[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
																						[FAnon:String] name:String
																		[Else:String] [Block:String]
																			[Field:String]
																				[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
																				[FAnon:String] name:String
														[Return:Dynamic] [Local nativeName(22054):String:String]
										[Return:String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Local field(22052):haxe.macro.ClassField:haxe.macro.ClassField]
													[FAnon:String] name:String
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(22060):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FAnon
										0
								[Block:String]
									[Var cf(22061):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(22060):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var field(22062):haxe.macro.ClassField]
											[Call:haxe.macro.ClassField]
												[Field:() -> haxe.macro.ClassField]
													[Local cf(22061):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
													[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Field:haxe.macro.MetaAccess]
														[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
													!=
													[Const:haxe.macro.MetaAccess] null
												&&
												[Call:Bool]
													[Field:(name : String) -> Bool]
														[Field:haxe.macro.MetaAccess]
															[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
															[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
														[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
													[Const:String] ":native"
											[Then:Void] [Block:Void]
												[Var nativeMeta(22063):Array<haxe.macro.MetadataEntry>]
													[Call:Array<haxe.macro.MetadataEntry>]
														[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
															[Field:haxe.macro.MetaAccess]
																[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
															[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
														[Const:String] ":native"
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Field:Int]
																	[Local nativeMeta(22063):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																	[FInstance:Int]
																		Array<haxe.macro.MetadataEntry>
																		length:Int
																>
																[Const:Int] 0
															&&
															[Binop:Bool]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22063):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																!=
																[Const:Null<Array<haxe.macro.Expr>>] null
														&&
														[Binop:Bool]
															[Field:Int]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22063):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																[FInstance:Int]
																	Array<haxe.macro.Expr>
																	length:Int
															>
															[Const:Int] 0
													[Then:Dynamic] [Block:Dynamic]
														[Var nativeName(22064):String]
															[Meta:String]
																:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		field.name;	
})
																[Block:String]
																	[Var `(22065):haxe.macro.ExprDef]
																		[Field:haxe.macro.ExprDef]
																			[Array:haxe.macro.Expr]
																				[Field:Null<Array<haxe.macro.Expr>>]
																					[Array:haxe.macro.MetadataEntry]
																						[Local nativeMeta(22063):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																						[Const:Int] 0
																					[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																				[Const:Int] 0
																			[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
																	[If:String]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(22065):haxe.macro.ExprDef:haxe.macro.ExprDef]
																			==
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Var `(22066):haxe.macro.Constant]
																				[EnumParameter:haxe.macro.Constant]
																					[Local `(22065):haxe.macro.ExprDef:haxe.macro.ExprDef]
																					EConst
																					0
																			[If:String]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(22066):haxe.macro.Constant:haxe.macro.Constant]
																					==
																					[Const:Int] 2
																				[Then:String] [Block:String]
																					[Var `(22067):String]
																						[EnumParameter:String]
																							[Local `(22066):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							0
																					[Var `(22068):Null<haxe.macro.StringLiteralKind>]
																						[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																							[Local `(22066):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							1
																					[Block:String]
																						[Var s(22069):String] [Local `(22067):String:String]
																						[Block:String] [Local s(22069):String:String]
																				[Else:String] [Block:String]
																					[Field:String]
																						[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
																						[FAnon:String] name:String
																		[Else:String] [Block:String]
																			[Field:String]
																				[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
																				[FAnon:String] name:String
														[Return:Dynamic] [Local nativeName(22064):String:String]
										[Return:String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Local field(22062):haxe.macro.ClassField:haxe.macro.ClassField]
													[FAnon:String] name:String
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(22070):String]
									[EnumParameter:String]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FDynamic
										0
								[Block:String]
									[Var s(22071):String] [Local `(22070):String:String]
									[Block:String]
										[Call:String]
											[Field:(camelCase : String) -> String]
												[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
												[FStatic:(camelCase : String) -> String]
													reflaxe.elixir.helpers.NamingHelper
													toSnakeCase:(camelCase : String) -> String
											[Local s(22071):String:String]
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(22072):Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
									[EnumParameter:Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FClosure
										0
								[Var `(22073):haxe.macro.Ref<haxe.macro.ClassField>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FClosure
										1
								[Block:String]
									[Var cf(22074):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(22073):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
									[Block:String]
										[Var field(22075):haxe.macro.ClassField]
											[Call:haxe.macro.ClassField]
												[Field:() -> haxe.macro.ClassField]
													[Local cf(22074):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
													[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Field:haxe.macro.MetaAccess]
														[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
														[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
													!=
													[Const:haxe.macro.MetaAccess] null
												&&
												[Call:Bool]
													[Field:(name : String) -> Bool]
														[Field:haxe.macro.MetaAccess]
															[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
															[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
														[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
													[Const:String] ":native"
											[Then:Void] [Block:Void]
												[Var nativeMeta(22076):Array<haxe.macro.MetadataEntry>]
													[Call:Array<haxe.macro.MetadataEntry>]
														[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
															[Field:haxe.macro.MetaAccess]
																[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
																[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
															[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
														[Const:String] ":native"
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Field:Int]
																	[Local nativeMeta(22076):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																	[FInstance:Int]
																		Array<haxe.macro.MetadataEntry>
																		length:Int
																>
																[Const:Int] 0
															&&
															[Binop:Bool]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22076):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																!=
																[Const:Null<Array<haxe.macro.Expr>>] null
														&&
														[Binop:Bool]
															[Field:Int]
																[Field:Null<Array<haxe.macro.Expr>>]
																	[Array:haxe.macro.MetadataEntry]
																		[Local nativeMeta(22076):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																		[Const:Int] 0
																	[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																[FInstance:Int]
																	Array<haxe.macro.Expr>
																	length:Int
															>
															[Const:Int] 0
													[Then:Dynamic] [Block:Dynamic]
														[Var nativeName(22077):String]
															[Meta:String]
																:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		field.name;	
})
																[Block:String]
																	[Var `(22078):haxe.macro.ExprDef]
																		[Field:haxe.macro.ExprDef]
																			[Array:haxe.macro.Expr]
																				[Field:Null<Array<haxe.macro.Expr>>]
																					[Array:haxe.macro.MetadataEntry]
																						[Local nativeMeta(22076):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
																						[Const:Int] 0
																					[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
																				[Const:Int] 0
																			[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
																	[If:String]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(22078):haxe.macro.ExprDef:haxe.macro.ExprDef]
																			==
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Var `(22079):haxe.macro.Constant]
																				[EnumParameter:haxe.macro.Constant]
																					[Local `(22078):haxe.macro.ExprDef:haxe.macro.ExprDef]
																					EConst
																					0
																			[If:String]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(22079):haxe.macro.Constant:haxe.macro.Constant]
																					==
																					[Const:Int] 2
																				[Then:String] [Block:String]
																					[Var `(22080):String]
																						[EnumParameter:String]
																							[Local `(22079):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							0
																					[Var `(22081):Null<haxe.macro.StringLiteralKind>]
																						[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																							[Local `(22079):haxe.macro.Constant:haxe.macro.Constant]
																							CString
																							1
																					[Block:String]
																						[Var s(22082):String] [Local `(22080):String:String]
																						[Block:String] [Local s(22082):String:String]
																				[Else:String] [Block:String]
																					[Field:String]
																						[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
																						[FAnon:String] name:String
																		[Else:String] [Block:String]
																			[Field:String]
																				[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
																				[FAnon:String] name:String
														[Return:Dynamic] [Local nativeName(22077):String:String]
										[Return:String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Local field(22075):haxe.macro.ClassField:haxe.macro.ClassField]
													[FAnon:String] name:String
						[Case:String]
							[Const:Int] 5
							[Block:String]
								[Var `(22083):haxe.macro.Ref<haxe.macro.EnumType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FEnum
										0
								[Var `(22084):haxe.macro.EnumField]
									[EnumParameter:haxe.macro.EnumField]
										[Local fa(21995):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										FEnum
										1
								[Block:String]
									[Var ef(22085):haxe.macro.EnumField] [Local `(22084):haxe.macro.EnumField:haxe.macro.EnumField]
									[Block:String]
										[Call:String]
											[Field:(camelCase : String) -> String]
												[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
												[FStatic:(camelCase : String) -> String]
													reflaxe.elixir.helpers.NamingHelper
													toSnakeCase:(camelCase : String) -> String
											[Field:String]
												[Local ef(22085):haxe.macro.EnumField:haxe.macro.EnumField]
												[FAnon:String] name:String

	function isValidAtomName[Function:(name : String) -> Bool]
		[Arg:String] [Local name(33695):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local name(33695):String:String]
						==
						[Const:String] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local name(33695):String:String]
							[FInstance:Int]
								String
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var firstChar(33696):String]
				[Call:String]
					[Field:(index : Int) -> String]
						[Local name(33695):String:String]
						[FInstance:(index : Int) -> String]
							String
							charAt:(index : Int) -> String
					[Const:Int] 0
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Parenthesis:Bool]
						[Binop:Bool]
							[Parenthesis:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Local firstChar(33696):String:String]
										>=
										[Const:String] "a"
									&&
									[Binop:Bool]
										[Local firstChar(33696):String:String]
										<=
										[Const:String] "z"
							||
							[Binop:Bool]
								[Local firstChar(33696):String:String]
								==
								[Const:String] "_"
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Block:Void]
				[Var `(33699):Int] [Const:Int] 1
				[Var `(33700):Int]
					[Field:Int]
						[Local name(33695):String:String]
						[FInstance:Int]
							String
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(33699):Int:Int]
						<
						[Local `(33700):Int:Int]
					[Block:Void]
						[Var i(33697):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(33699):Int:Int]
						[Var char(33698):String]
							[Call:String]
								[Field:(index : Int) -> String]
									[Local name(33695):String:String]
									[FInstance:(index : Int) -> String]
										String
										charAt:(index : Int) -> String
								[Local i(33697):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Parenthesis:Bool]
									[Binop:Bool]
										[Binop:Bool]
											[Binop:Bool]
												[Parenthesis:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local char(33698):String:String]
															>=
															[Const:String] "a"
														&&
														[Binop:Bool]
															[Local char(33698):String:String]
															<=
															[Const:String] "z"
												||
												[Parenthesis:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local char(33698):String:String]
															>=
															[Const:String] "A"
														&&
														[Binop:Bool]
															[Local char(33698):String:String]
															<=
															[Const:String] "Z"
											||
											[Parenthesis:Bool]
												[Binop:Bool]
													[Binop:Bool]
														[Local char(33698):String:String]
														>=
														[Const:String] "0"
													&&
													[Binop:Bool]
														[Local char(33698):String:String]
														<=
														[Const:String] "9"
										||
										[Binop:Bool]
											[Local char(33698):String:String]
											==
											[Const:String] "_"
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic] [Const:Bool] true

	function shouldUseAtomKeys[Function:(fields : Array<{ name : String, expr : haxe.macro.TypedExpr }>) -> Bool]
		[Arg:Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						==
						[Const:Array<{ name : String, expr : haxe.macro.TypedExpr }>] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ name : String, expr : haxe.macro.TypedExpr }>
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var fieldNames(33711):Array<String>]
				[Block:Array<String>]
					[Var `(33706):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(33707):Int] [Const:Int] 0
						[Var `(33708):Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						[While:Void]
							[Binop:Bool]
								[Local `(33707):Int:Int]
								<
								[Field:Int]
									[Local `(33708):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
									[FInstance:Int]
										Array<{ name : String, expr : haxe.macro.TypedExpr }>
										length:Int
							[Block:Void]
								[Var v(33709):{ name : String, expr : haxe.macro.TypedExpr }]
									[Array:{ name : String, expr : haxe.macro.TypedExpr }]
										[Local `(33708):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
										[Local `(33707):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33707):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(33706):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(f : { name : String, expr : haxe.macro.TypedExpr }) -> String]
											[Arg:{ name : String, expr : haxe.macro.TypedExpr }] [Local f(33710):{ name : String, expr : haxe.macro.TypedExpr }]
											[Block:Dynamic]
												[Return:Dynamic]
													[Field:String]
														[Local f(33710):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
														[FAnon:String] name:String
										[Local v(33709):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
					[Local `(33706):Array<String>:Array<String>]
			[Var supervisorFields(33712):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "strategy"
					[Const:String] "max_restarts"
					[Const:String] "max_seconds"
			[Var hasAllSupervisorFields(33713):Bool] [Const:Bool] true
			[Block:Void]
				[Var `(33715):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(33715):Int:Int]
						<
						[Field:Int]
							[Local supervisorFields(33712):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var field(33714):String]
							[Array:String]
								[Local supervisorFields(33712):Array<String>:Array<String>]
								[Local `(33715):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(33715):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Call:Int]
									[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
										[Local fieldNames(33711):Array<String>:Array<String>]
										[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
											Array<String>
											indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
									[Local field(33714):String:String]
									[Const:Null<Int>] null
								==
								[Const:Int] -1
							[Then:Dynamic] [Block:Dynamic]
								[Binop:Bool]
									[Local hasAllSupervisorFields(33713):Bool:Bool]
									=
									[Const:Bool] false
								[Break:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local hasAllSupervisorFields(33713):Bool:Bool]
					&&
					[Binop:Bool]
						[Field:Int]
							[Local fieldNames(33711):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
						==
						[Const:Int] 3
				[Then:Dynamic] [Block:Dynamic]
					[Block:Void]
						[Var `(33717):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(33717):Int:Int]
								<
								[Field:Int]
									[Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
									[FInstance:Int]
										Array<{ name : String, expr : haxe.macro.TypedExpr }>
										length:Int
							[Block:Void]
								[Var field(33716):{ name : String, expr : haxe.macro.TypedExpr }]
									[Array:{ name : String, expr : haxe.macro.TypedExpr }]
										[Local fields(33701):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
										[Local `(33717):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33717):Int:Int]
								[If:Void]
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(name : String) -> Bool]
												[Const:reflaxe.elixir.ElixirCompiler] this
												[FInstance:(name : String) -> Bool]
													reflaxe.elixir.ElixirCompiler
													isValidAtomName:(name : String) -> Bool
											[Field:String]
												[Local field(33716):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
												[FAnon:String] name:String
									[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
					[Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Int]
							[Local fieldNames(33711):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
						==
						[Const:Int] 1
					&&
					[Binop:Bool]
						[Array:String]
							[Local fieldNames(33711):Array<String>:Array<String>]
							[Const:Int] 0
						==
						[Const:String] "name"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:Bool]
							[Field:(name : String) -> Bool]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:(name : String) -> Bool]
									reflaxe.elixir.ElixirCompiler
									isValidAtomName:(name : String) -> Bool
							[Const:String] "name"
			[Return:Dynamic] [Const:Bool] false

	function isChildSpecObject[Function:(fields : Array<{ name : String, expr : haxe.macro.TypedExpr }>) -> Bool]
		[Arg:Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33718):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local fields(33718):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						==
						[Const:Array<{ name : String, expr : haxe.macro.TypedExpr }>] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local fields(33718):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ name : String, expr : haxe.macro.TypedExpr }>
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var fieldNames(33728):Array<String>]
				[Block:Array<String>]
					[Var `(33723):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(33724):Int] [Const:Int] 0
						[Var `(33725):Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33718):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						[While:Void]
							[Binop:Bool]
								[Local `(33724):Int:Int]
								<
								[Field:Int]
									[Local `(33725):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
									[FInstance:Int]
										Array<{ name : String, expr : haxe.macro.TypedExpr }>
										length:Int
							[Block:Void]
								[Var v(33726):{ name : String, expr : haxe.macro.TypedExpr }]
									[Array:{ name : String, expr : haxe.macro.TypedExpr }]
										[Local `(33725):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
										[Local `(33724):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33724):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(33723):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(f : { name : String, expr : haxe.macro.TypedExpr }) -> String]
											[Arg:{ name : String, expr : haxe.macro.TypedExpr }] [Local f(33727):{ name : String, expr : haxe.macro.TypedExpr }]
											[Block:Dynamic]
												[Return:Dynamic]
													[Field:String]
														[Local f(33727):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
														[FAnon:String] name:String
										[Local v(33726):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
					[Local `(33723):Array<String>:Array<String>]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
								[Local fieldNames(33728):Array<String>:Array<String>]
								[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
									Array<String>
									indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
							[Const:String] "id"
							[Const:Null<Int>] null
						!=
						[Const:Int] -1
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
								[Local fieldNames(33728):Array<String>:Array<String>]
								[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
									Array<String>
									indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
							[Const:String] "start"
							[Const:Null<Int>] null
						!=
						[Const:Int] -1

	function analyzeChildSpecStructure[Function:(compiledFields : Map<String, String>) -> String]
		[Arg:Map<String, String>] [Local compiledFields(21499):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(compiledFields : Map<String, String>) -> String]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(compiledFields : Map<String, String>) -> String]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							analyzeChildSpecStructure:(compiledFields : Map<String, String>) -> String
					[Local compiledFields(21499):Map<String, String>:Map<String, String>]

	function hasSimpleStartPattern[Function:(startField : String) -> Bool]
		[Arg:String] [Local startField(33729):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(startField : String) -> Bool]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(startField : String) -> Bool]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							hasSimpleStartPattern:(startField : String) -> Bool
					[Local startField(33729):String:String]

	function generateModernTupleFormat[Function:(idField : String, startField : String, appName : String) -> String]
		[Arg:String] [Local idField(21533):String]
		[Arg:String] [Local startField(21534):String]
		[Arg:String] [Local appName(21535):String]
		[Block:Dynamic]
			[Var cleanId(21536):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local idField(21533):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] "\""
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Local cleanId(21536):String:String]
					==
					[Const:String] "Phoenix.PubSub"
				[Then:Dynamic] [Block:Dynamic]
					[Var pubsubName(21537):String]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local appName(21535):String:String]
							+
							[Const:String] ".PubSub"
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local startField(21534):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "[%{name: "
								[Const:Null<Int>] null
							>
							[Const:Int] -1
						[Then:Void] [Block:Void]
							[Var namePattern(21538):EReg]
								[New:EReg]
									EReg
									[Const:String] "\\[%\\{name: ([^}]+)\\}\\]"
									[Const:String] ""
							[If:Void]
								[Call:Bool]
									[Field:(s : String) -> Bool]
										[Local namePattern(21538):EReg:EReg]
										[FInstance:(s : String) -> Bool]
											EReg
											match:(s : String) -> Bool
									[Local startField(21534):String:String]
								[Then:String] [Block:String]
									[Binop:String]
										[Local pubsubName(21537):String:String]
										=
										[Call:String]
											[Field:(n : Int) -> String]
												[Local namePattern(21538):EReg:EReg]
												[FInstance:(n : Int) -> String]
													EReg
													matched:(n : Int) -> String
											[Const:Int] 1
					[Var atomName(21539):String]
						[Call:String]
							[Field:(sep : String) -> String]
								[Call:Array<String>]
									[Field:(delimiter : String) -> Array<String>]
										[Local pubsubName(21537):String:String]
										[FInstance:(delimiter : String) -> Array<String>]
											String
											split:(delimiter : String) -> Array<String>
									[Const:String] "\""
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ""
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "{Phoenix.PubSub, name: "
								+
								[Local atomName(21539):String:String]
							+
							[Const:String] "}"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local startField(21534):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] ", []"
						[Const:Null<Int>] null
					>
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local cleanId(21536):String:String]
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local startField(21534):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "[%{"
								[Const:Null<Int>] null
							>
							[Const:Int] -1
						[Then:Void] [Block:Void]
							[Var argsPattern(21540):EReg]
								[New:EReg]
									EReg
									[Const:String] "\\[(%\\{[^}]+\\})\\]"
									[Const:String] ""
							[If:Void]
								[Call:Bool]
									[Field:(s : String) -> Bool]
										[Local argsPattern(21540):EReg:EReg]
										[FInstance:(s : String) -> Bool]
											EReg
											match:(s : String) -> Bool
									[Local startField(21534):String:String]
								[Then:Dynamic] [Block:Dynamic]
									[Var args(21541):String]
										[Call:String]
											[Field:(n : Int) -> String]
												[Local argsPattern(21540):EReg:EReg]
												[FInstance:(n : Int) -> String]
													EReg
													matched:(n : Int) -> String
											[Const:Int] 1
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "{"
														+
														[Local cleanId(21536):String:String]
													+
													[Const:String] ", "
												+
												[Local args(21541):String:String]
											+
											[Const:String] "}"
			[Return:Dynamic] [Local cleanId(21536):String:String]

	function generateSimpleModuleFormat[Function:(idField : String, appName : String) -> String]
		[Arg:String] [Local idField(21542):String]
		[Arg:String] [Local appName(21543):String]
		[Block:Dynamic]
			[Var cleanId(21544):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local idField(21542):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] "\""
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "Telemetry"
							[Const:Null<Int>] null
						>
						[Const:Int] -1
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Local appName(21543):String:String]
							[Const:Null<Int>] null
						==
						[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local appName(21543):String:String]
							+
							[Const:String] "Web.Telemetry"
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "Endpoint"
							[Const:Null<Int>] null
						>
						[Const:Int] -1
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Local appName(21543):String:String]
							[Const:Null<Int>] null
						==
						[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local appName(21543):String:String]
							+
							[Const:String] "Web.Endpoint"
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "Repo"
							[Const:Null<Int>] null
						>
						[Const:Int] -1
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local cleanId(21544):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Local appName(21543):String:String]
							[Const:Null<Int>] null
						==
						[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local appName(21543):String:String]
							+
							[Const:String] ".Repo"
			[Return:Dynamic] [Local cleanId(21544):String:String]

	public function compileChildSpec[Function:(fields : Array<{ name : String, expr : haxe.macro.TypedExpr }>, classType : Null<haxe.macro.ClassType>) -> String]
		[Arg:Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(21296):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
		[Arg:Null<haxe.macro.ClassType>] [Local classType(21297):Null<haxe.macro.ClassType>]
		[Block:Dynamic]
			[Var compiledFields(21298):haxe.ds.Map<String, String>]
				[Block:haxe.ds.StringMap<String>]
					[Block:Void]
					[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
			[Var appName(21299):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.AnnotationSystem
							getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
					[Local classType(21297):Null<haxe.macro.ClassType>:Null<haxe.macro.ClassType>]
			[Block:Void]
				[Var `(21480):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(21480):Int:Int]
						<
						[Field:Int]
							[Local fields(21296):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ name : String, expr : haxe.macro.TypedExpr }>
								length:Int
					[Block:Void]
						[Var field(21300):{ name : String, expr : haxe.macro.TypedExpr }]
							[Array:{ name : String, expr : haxe.macro.TypedExpr }]
								[Local fields(21296):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
								[Local `(21480):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(21480):Int:Int]
						[Meta:Void]
							:ast(switch (field.name) {
	case "id":
		var idValue = compileExpression(field.expr);
		if (idValue.indexOf("temp_") != -1 || idValue.indexOf("temp") == 0) {
			compiledFields.set("id", "if(id != nil, do: id, else: module)");
		} else {
			idValue = resolveAppNameInString(idValue, appName);
			compiledFields.set("id", idValue);
		};	
	case "start":
		switch (field.expr.expr) {
			case TObjectDecl(startFields):
				var startValues = new Map<String,String>();
				for (startField  in  startFields) {
					var value = compileExpression(startField.expr);
					switch (startField.name) {
						case "module":
							value = resolveAppNameInString(value, appName);
							startValues.set("module", value);						
						case "func":
							value = value.split("\"").join("");
							startValues.set("func", ":${value}");						
						case "args":
							value = resolveAppNameInString(value, appName);
							startValues.set("args", value);						
					};
				};
				var moduleVal = startValues.get("module") != null ? startValues.get("module") : "module";
				var funcVal = startValues.get("func") != null ? startValues.get("func") : ":start_link";
				var argsVal = startValues.get("args") != null ? startValues.get("args") : "[]";
				compiledFields.set("start", "{${moduleVal}, ${funcVal}, ${argsVal}}");			
			case _:
				var startExpr = compileExpression(field.expr);
				startExpr = resolveAppNameInString(startExpr, appName);
				compiledFields.set("start", startExpr);			
		};	
	case "restart":
		var restartValue = compileExpression(field.expr);
		if (restartValue.indexOf("Permanent") != -1) {
			compiledFields.set("restart", ":permanent");
		} else if (restartValue.indexOf("Temporary") != -1) {
			compiledFields.set("restart", ":temporary");
		} else if (restartValue.indexOf("Transient") != -1) {
			compiledFields.set("restart", ":transient");
		} else {
			compiledFields.set("restart", restartValue);
		};	
	case "shutdown":
		var shutdownValue = compileExpression(field.expr);
		if (shutdownValue.indexOf("Brutal") != -1) {
			compiledFields.set("shutdown", ":brutal_kill");
		} else if (shutdownValue.indexOf("Infinity") != -1) {
			compiledFields.set("shutdown", ":infinity");
		} else if (shutdownValue.indexOf("Timeout") != -1) {
			var timeoutPattern = ~/Timeout\((\d+)\)/;
			if (timeoutPattern.match(shutdownValue)) {
				var timeoutMs = timeoutPattern.matched(1);
				compiledFields.set("shutdown", timeoutMs);
			} else {
				compiledFields.set("shutdown", "5000");
			};
		} else {
			compiledFields.set("shutdown", shutdownValue);
		};	
	case "type":
		var typeValue = compileExpression(field.expr);
		if (typeValue.indexOf("Worker") != -1) {
			compiledFields.set("type", ":worker");
		} else if (typeValue.indexOf("Supervisor") != -1) {
			compiledFields.set("type", ":supervisor");
		} else {
			compiledFields.set("type", typeValue);
		};	
	case "modules":
		var modulesValue = compileExpression(field.expr);
		modulesValue = resolveAppNameInString(modulesValue, appName);
		compiledFields.set("modules", modulesValue);	
})
							[Block:Void]
								[Var `(21460):String]
									[Field:String]
										[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
										[FAnon:String] name:String
								[Switch:Void]
									[Local `(21460):String:String]
									[Case:Void]
										[Const:String] "id"
										[Block:Void]
											[Block:Void]
												[Var idValue(21461):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Call:Int]
																[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																	[Local idValue(21461):Null<String>:Null<String>]
																	[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																		String
																		indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																[Const:String] "temp_"
																[Const:Null<Int>] null
															!=
															[Const:Int] -1
														||
														[Binop:Bool]
															[Call:Int]
																[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																	[Local idValue(21461):Null<String>:Null<String>]
																	[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																		String
																		indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																[Const:String] "temp"
																[Const:Null<Int>] null
															==
															[Const:Int] 0
													[Then:Void] [Block:Void]
														[Block:Void]
															[Call:Void]
																[Field:(key : String, value : String) -> Void]
																	[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																	[FInstance:(key : String, value : String) -> Void]
																		haxe.ds.StringMap<String>
																		set:(key : String, value : haxe.ds.StringMap.T) -> Void
																[Const:String] "id"
																[Const:String] "if(id != nil, do: id, else: module)"
													[Else:Void] [Block:Void]
														[Binop:Null<String>]
															[Local idValue(21461):Null<String>:Null<String>]
															=
															[Call:String]
																[Field:(str : String, appName : String) -> String]
																	[Const:reflaxe.elixir.ElixirCompiler] this
																	[FInstance:(str : String, appName : String) -> String]
																		reflaxe.elixir.ElixirCompiler
																		resolveAppNameInString:(str : String, appName : String) -> String
																[Local idValue(21461):Null<String>:Null<String>]
																[Local appName(21299):String:String]
														[Block:Void]
															[Call:Void]
																[Field:(key : String, value : String) -> Void]
																	[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																	[FInstance:(key : String, value : String) -> Void]
																		haxe.ds.StringMap<String>
																		set:(key : String, value : haxe.ds.StringMap.T) -> Void
																[Const:String] "id"
																[Local idValue(21461):Null<String>:Null<String>]
									[Case:Void]
										[Const:String] "modules"
										[Block:Void]
											[Block:Void]
												[Var modulesValue(21462):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[Binop:Null<String>]
													[Local modulesValue(21462):Null<String>:Null<String>]
													=
													[Call:String]
														[Field:(str : String, appName : String) -> String]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(str : String, appName : String) -> String]
																reflaxe.elixir.ElixirCompiler
																resolveAppNameInString:(str : String, appName : String) -> String
														[Local modulesValue(21462):Null<String>:Null<String>]
														[Local appName(21299):String:String]
												[Block:Void]
													[Call:Void]
														[Field:(key : String, value : String) -> Void]
															[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
															[FInstance:(key : String, value : String) -> Void]
																haxe.ds.StringMap<String>
																set:(key : String, value : haxe.ds.StringMap.T) -> Void
														[Const:String] "modules"
														[Local modulesValue(21462):Null<String>:Null<String>]
									[Case:Void]
										[Const:String] "restart"
										[Block:Void]
											[Block:Void]
												[Var restartValue(21463):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[If:Void]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local restartValue(21463):Null<String>:Null<String>]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "Permanent"
															[Const:Null<Int>] null
														!=
														[Const:Int] -1
													[Then:Void] [Block:Void]
														[Block:Void]
															[Call:Void]
																[Field:(key : String, value : String) -> Void]
																	[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																	[FInstance:(key : String, value : String) -> Void]
																		haxe.ds.StringMap<String>
																		set:(key : String, value : haxe.ds.StringMap.T) -> Void
																[Const:String] "restart"
																[Const:String] ":permanent"
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local restartValue(21463):Null<String>:Null<String>]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] "Temporary"
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
															[Then:Void] [Block:Void]
																[Block:Void]
																	[Call:Void]
																		[Field:(key : String, value : String) -> Void]
																			[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																			[FInstance:(key : String, value : String) -> Void]
																				haxe.ds.StringMap<String>
																				set:(key : String, value : haxe.ds.StringMap.T) -> Void
																		[Const:String] "restart"
																		[Const:String] ":temporary"
															[Else:Void] [Block:Void]
																[If:Void]
																	[Binop:Bool]
																		[Call:Int]
																			[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																				[Local restartValue(21463):Null<String>:Null<String>]
																				[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																					String
																					indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																			[Const:String] "Transient"
																			[Const:Null<Int>] null
																		!=
																		[Const:Int] -1
																	[Then:Void] [Block:Void]
																		[Block:Void]
																			[Call:Void]
																				[Field:(key : String, value : String) -> Void]
																					[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																					[FInstance:(key : String, value : String) -> Void]
																						haxe.ds.StringMap<String>
																						set:(key : String, value : haxe.ds.StringMap.T) -> Void
																				[Const:String] "restart"
																				[Const:String] ":transient"
																	[Else:Void] [Block:Void]
																		[Block:Void]
																			[Call:Void]
																				[Field:(key : String, value : String) -> Void]
																					[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																					[FInstance:(key : String, value : String) -> Void]
																						haxe.ds.StringMap<String>
																						set:(key : String, value : haxe.ds.StringMap.T) -> Void
																				[Const:String] "restart"
																				[Local restartValue(21463):Null<String>:Null<String>]
									[Case:Void]
										[Const:String] "shutdown"
										[Block:Void]
											[Block:Void]
												[Var shutdownValue(21464):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[If:Void]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local shutdownValue(21464):Null<String>:Null<String>]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "Brutal"
															[Const:Null<Int>] null
														!=
														[Const:Int] -1
													[Then:Void] [Block:Void]
														[Block:Void]
															[Call:Void]
																[Field:(key : String, value : String) -> Void]
																	[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																	[FInstance:(key : String, value : String) -> Void]
																		haxe.ds.StringMap<String>
																		set:(key : String, value : haxe.ds.StringMap.T) -> Void
																[Const:String] "shutdown"
																[Const:String] ":brutal_kill"
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local shutdownValue(21464):Null<String>:Null<String>]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] "Infinity"
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
															[Then:Void] [Block:Void]
																[Block:Void]
																	[Call:Void]
																		[Field:(key : String, value : String) -> Void]
																			[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																			[FInstance:(key : String, value : String) -> Void]
																				haxe.ds.StringMap<String>
																				set:(key : String, value : haxe.ds.StringMap.T) -> Void
																		[Const:String] "shutdown"
																		[Const:String] ":infinity"
															[Else:Void] [Block:Void]
																[If:Void]
																	[Binop:Bool]
																		[Call:Int]
																			[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																				[Local shutdownValue(21464):Null<String>:Null<String>]
																				[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																					String
																					indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																			[Const:String] "Timeout"
																			[Const:Null<Int>] null
																		!=
																		[Const:Int] -1
																	[Then:Void] [Block:Void]
																		[Var timeoutPattern(21465):EReg]
																			[New:EReg]
																				EReg
																				[Const:String] "Timeout\\((\\d+)\\)"
																				[Const:String] ""
																		[If:Void]
																			[Call:Bool]
																				[Field:(s : String) -> Bool]
																					[Local timeoutPattern(21465):EReg:EReg]
																					[FInstance:(s : String) -> Bool]
																						EReg
																						match:(s : String) -> Bool
																				[Local shutdownValue(21464):Null<String>:Null<String>]
																			[Then:Void] [Block:Void]
																				[Var timeoutMs(21466):String]
																					[Call:String]
																						[Field:(n : Int) -> String]
																							[Local timeoutPattern(21465):EReg:EReg]
																							[FInstance:(n : Int) -> String]
																								EReg
																								matched:(n : Int) -> String
																						[Const:Int] 1
																				[Block:Void]
																					[Call:Void]
																						[Field:(key : String, value : String) -> Void]
																							[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																							[FInstance:(key : String, value : String) -> Void]
																								haxe.ds.StringMap<String>
																								set:(key : String, value : haxe.ds.StringMap.T) -> Void
																						[Const:String] "shutdown"
																						[Local timeoutMs(21466):String:String]
																			[Else:Void] [Block:Void]
																				[Block:Void]
																					[Call:Void]
																						[Field:(key : String, value : String) -> Void]
																							[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																							[FInstance:(key : String, value : String) -> Void]
																								haxe.ds.StringMap<String>
																								set:(key : String, value : haxe.ds.StringMap.T) -> Void
																						[Const:String] "shutdown"
																						[Const:String] "5000"
																	[Else:Void] [Block:Void]
																		[Block:Void]
																			[Call:Void]
																				[Field:(key : String, value : String) -> Void]
																					[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																					[FInstance:(key : String, value : String) -> Void]
																						haxe.ds.StringMap<String>
																						set:(key : String, value : haxe.ds.StringMap.T) -> Void
																				[Const:String] "shutdown"
																				[Local shutdownValue(21464):Null<String>:Null<String>]
									[Case:Void]
										[Const:String] "start"
										[Block:Void]
											[Block:Void]
												[Meta:Void]
													:ast(switch (field.expr.expr) {
	case TObjectDecl(startFields):
		var startValues = new Map<String,String>();
		for (startField  in  startFields) {
			var value = compileExpression(startField.expr);
			switch (startField.name) {
				case "module":
					value = resolveAppNameInString(value, appName);
					startValues.set("module", value);				
				case "func":
					value = value.split("\"").join("");
					startValues.set("func", ":${value}");				
				case "args":
					value = resolveAppNameInString(value, appName);
					startValues.set("args", value);				
			};
		};
		var moduleVal = startValues.get("module") != null ? startValues.get("module") : "module";
		var funcVal = startValues.get("func") != null ? startValues.get("func") : ":start_link";
		var argsVal = startValues.get("args") != null ? startValues.get("args") : "[]";
		compiledFields.set("start", "{${moduleVal}, ${funcVal}, ${argsVal}}");	
	case _:
		var startExpr = compileExpression(field.expr);
		startExpr = resolveAppNameInString(startExpr, appName);
		compiledFields.set("start", startExpr);	
})
													[Block:Void]
														[Var `(21467):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExpr]
																	[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
																	[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Void]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(21467):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 7
															[Then:Void] [Block:Void]
																[Var `(21468):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
																	[EnumParameter:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
																		[Local `(21467):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TObjectDecl
																		0
																[Block:Void]
																	[Var startFields(21469):Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local `(21468):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
																	[Block:Void]
																		[Var startValues(21470):haxe.ds.Map<String, String>]
																			[Block:haxe.ds.StringMap<String>]
																				[Block:Void]
																				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
																		[Block:Void]
																			[Var `(21471):Int] [Const:Int] 0
																			[While:Void]
																				[Binop:Bool]
																					[Local `(21471):Int:Int]
																					<
																					[Field:Int]
																						[Local startFields(21469):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
																						[FInstance:Int]
																							Array<{ name : String, expr : haxe.macro.TypedExpr }>
																							length:Int
																				[Block:Void]
																					[Var startField(21472):{ name : String, expr : haxe.macro.TypedExpr }]
																						[Array:{ name : String, expr : haxe.macro.TypedExpr }]
																							[Local startFields(21469):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
																							[Local `(21471):Int:Int]
																					[Unop:Int]
																						++
																						Prefix
																						[Local `(21471):Int:Int]
																					[Var value(21473):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Const:reflaxe.elixir.ElixirCompiler] this
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Field:haxe.macro.TypedExpr]
																								[Local startField(21472):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
																								[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
																							[Const:Null<Bool>] null
																					[Meta:Void]
																						:ast(switch (startField.name) {
	case "module":
		value = resolveAppNameInString(value, appName);
		startValues.set("module", value);	
	case "func":
		value = value.split("\"").join("");
		startValues.set("func", ":${value}");	
	case "args":
		value = resolveAppNameInString(value, appName);
		startValues.set("args", value);	
})
																						[Block:Void]
																							[Var `(21474):String]
																								[Field:String]
																									[Local startField(21472):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
																									[FAnon:String] name:String
																							[Switch:Void]
																								[Local `(21474):String:String]
																								[Case:Void]
																									[Const:String] "args"
																									[Block:Void]
																										[Block:Void]
																											[Binop:Null<String>]
																												[Local value(21473):Null<String>:Null<String>]
																												=
																												[Call:String]
																													[Field:(str : String, appName : String) -> String]
																														[Const:reflaxe.elixir.ElixirCompiler] this
																														[FInstance:(str : String, appName : String) -> String]
																															reflaxe.elixir.ElixirCompiler
																															resolveAppNameInString:(str : String, appName : String) -> String
																													[Local value(21473):Null<String>:Null<String>]
																													[Local appName(21299):String:String]
																											[Block:Void]
																												[Call:Void]
																													[Field:(key : String, value : String) -> Void]
																														[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																														[FInstance:(key : String, value : String) -> Void]
																															haxe.ds.StringMap<String>
																															set:(key : String, value : haxe.ds.StringMap.T) -> Void
																													[Const:String] "args"
																													[Local value(21473):Null<String>:Null<String>]
																								[Case:Void]
																									[Const:String] "func"
																									[Block:Void]
																										[Block:Void]
																											[Binop:Null<String>]
																												[Local value(21473):Null<String>:Null<String>]
																												=
																												[Call:String]
																													[Field:(sep : String) -> String]
																														[Call:Array<String>]
																															[Field:(delimiter : String) -> Array<String>]
																																[Local value(21473):Null<String>:Null<String>]
																																[FInstance:(delimiter : String) -> Array<String>]
																																	String
																																	split:(delimiter : String) -> Array<String>
																															[Const:String] "\""
																														[FInstance:(sep : String) -> String]
																															Array<String>
																															join:(sep : String) -> String
																													[Const:String] ""
																											[Block:Void]
																												[Call:Void]
																													[Field:(key : String, value : String) -> Void]
																														[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																														[FInstance:(key : String, value : String) -> Void]
																															haxe.ds.StringMap<String>
																															set:(key : String, value : haxe.ds.StringMap.T) -> Void
																													[Const:String] "func"
																													[Binop:String]
																														[Const:String] ":"
																														+
																														[Local value(21473):Null<String>:Null<String>]
																								[Case:Void]
																									[Const:String] "module"
																									[Block:Void]
																										[Block:Void]
																											[Binop:Null<String>]
																												[Local value(21473):Null<String>:Null<String>]
																												=
																												[Call:String]
																													[Field:(str : String, appName : String) -> String]
																														[Const:reflaxe.elixir.ElixirCompiler] this
																														[FInstance:(str : String, appName : String) -> String]
																															reflaxe.elixir.ElixirCompiler
																															resolveAppNameInString:(str : String, appName : String) -> String
																													[Local value(21473):Null<String>:Null<String>]
																													[Local appName(21299):String:String]
																											[Block:Void]
																												[Call:Void]
																													[Field:(key : String, value : String) -> Void]
																														[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																														[FInstance:(key : String, value : String) -> Void]
																															haxe.ds.StringMap<String>
																															set:(key : String, value : haxe.ds.StringMap.T) -> Void
																													[Const:String] "module"
																													[Local value(21473):Null<String>:Null<String>]
																		[Var moduleVal(21475):Null<String>]
																			[If:Null<String>]
																				[Binop:Bool]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "module"
																					!=
																					[Const:Null<String>] null
																				[Then:Null<String>] [Block:Null<String>]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "module"
																				[Else:String] [Block:String] [Const:String] "module"
																		[Var funcVal(21476):Null<String>]
																			[If:Null<String>]
																				[Binop:Bool]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "func"
																					!=
																					[Const:Null<String>] null
																				[Then:Null<String>] [Block:Null<String>]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "func"
																				[Else:String] [Block:String] [Const:String] ":start_link"
																		[Var argsVal(21477):Null<String>]
																			[If:Null<String>]
																				[Binop:Bool]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "args"
																					!=
																					[Const:Null<String>] null
																				[Then:Null<String>] [Block:Null<String>]
																					[Cast:Null<String>]
																						[Call:Null<String>]
																							[Field:(key : String) -> Null<String>]
																								[Local startValues(21470):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																								[FInstance:(key : String) -> Null<String>]
																									haxe.ds.StringMap<String>
																									get:(key : String) -> Null<haxe.ds.StringMap.T>
																							[Const:String] "args"
																				[Else:String] [Block:String] [Const:String] "[]"
																		[Block:Void]
																			[Call:Void]
																				[Field:(key : String, value : String) -> Void]
																					[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																					[FInstance:(key : String, value : String) -> Void]
																						haxe.ds.StringMap<String>
																						set:(key : String, value : haxe.ds.StringMap.T) -> Void
																				[Const:String] "start"
																				[Binop:String]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Binop:String]
																										[Const:String] "{"
																										+
																										[Local moduleVal(21475):Null<String>:Null<String>]
																									+
																									[Const:String] ", "
																								+
																								[Local funcVal(21476):Null<String>:Null<String>]
																							+
																							[Const:String] ", "
																						+
																						[Local argsVal(21477):Null<String>:Null<String>]
																					+
																					[Const:String] "}"
															[Else:Void] [Block:Void]
																[Var startExpr(21478):Null<String>]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Const:reflaxe.elixir.ElixirCompiler] this
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Field:haxe.macro.TypedExpr]
																			[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
																			[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
																		[Const:Null<Bool>] null
																[Binop:Null<String>]
																	[Local startExpr(21478):Null<String>:Null<String>]
																	=
																	[Call:String]
																		[Field:(str : String, appName : String) -> String]
																			[Const:reflaxe.elixir.ElixirCompiler] this
																			[FInstance:(str : String, appName : String) -> String]
																				reflaxe.elixir.ElixirCompiler
																				resolveAppNameInString:(str : String, appName : String) -> String
																		[Local startExpr(21478):Null<String>:Null<String>]
																		[Local appName(21299):String:String]
																[Block:Void]
																	[Call:Void]
																		[Field:(key : String, value : String) -> Void]
																			[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																			[FInstance:(key : String, value : String) -> Void]
																				haxe.ds.StringMap<String>
																				set:(key : String, value : haxe.ds.StringMap.T) -> Void
																		[Const:String] "start"
																		[Local startExpr(21478):Null<String>:Null<String>]
									[Case:Void]
										[Const:String] "type"
										[Block:Void]
											[Block:Void]
												[Var typeValue(21479):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21300):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[If:Void]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local typeValue(21479):Null<String>:Null<String>]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "Worker"
															[Const:Null<Int>] null
														!=
														[Const:Int] -1
													[Then:Void] [Block:Void]
														[Block:Void]
															[Call:Void]
																[Field:(key : String, value : String) -> Void]
																	[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																	[FInstance:(key : String, value : String) -> Void]
																		haxe.ds.StringMap<String>
																		set:(key : String, value : haxe.ds.StringMap.T) -> Void
																[Const:String] "type"
																[Const:String] ":worker"
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local typeValue(21479):Null<String>:Null<String>]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] "Supervisor"
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
															[Then:Void] [Block:Void]
																[Block:Void]
																	[Call:Void]
																		[Field:(key : String, value : String) -> Void]
																			[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																			[FInstance:(key : String, value : String) -> Void]
																				haxe.ds.StringMap<String>
																				set:(key : String, value : haxe.ds.StringMap.T) -> Void
																		[Const:String] "type"
																		[Const:String] ":supervisor"
															[Else:Void] [Block:Void]
																[Block:Void]
																	[Call:Void]
																		[Field:(key : String, value : String) -> Void]
																			[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
																			[FInstance:(key : String, value : String) -> Void]
																				haxe.ds.StringMap<String>
																				set:(key : String, value : haxe.ds.StringMap.T) -> Void
																		[Const:String] "type"
																		[Local typeValue(21479):Null<String>:Null<String>]
			[Var idField(21489):Null<String>]
				[If:Null<String>]
					[Binop:Bool]
						[Cast:Null<String>]
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "id"
						!=
						[Const:Null<String>] null
					[Then:Null<String>] [Block:Null<String>]
						[Cast:Null<String>]
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "id"
					[Else:String] [Block:String] [Const:String] "module"
			[Var startField(21498):Null<String>]
				[If:Null<String>]
					[Binop:Bool]
						[Cast:Null<String>]
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "start"
						!=
						[Const:Null<String>] null
					[Then:Null<String>] [Block:Null<String>]
						[Cast:Null<String>]
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "start"
					[Else:String] [Block:String] [Const:String] "{module, :start_link, []}"
			[Var specFormat(21532):String]
				[Call:String]
					[Field:(compiledFields : Map<String, String>) -> String]
						[Const:reflaxe.elixir.ElixirCompiler] this
						[FInstance:(compiledFields : Map<String, String>) -> String]
							reflaxe.elixir.ElixirCompiler
							analyzeChildSpecStructure:(compiledFields : Map<String, String>) -> String
					[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.Map<String, String>]
			[Meta:Void]
				:ast(switch (specFormat) {
	case MODERN_TUPLE:
		return generateModernTupleFormat(idField, startField, appName);	
	case SIMPLE_MODULE:
		return generateSimpleModuleFormat(idField, appName);	
	case TRADITIONAL_MAP:
})
				[Switch:Void]
					[Local specFormat(21532):String:String]
					[Case:Dynamic]
						[Const:String] "ModernTuple"
						[Block:Dynamic]
							[Block:Dynamic]
								[Return:Dynamic]
									[Call:String]
										[Field:(idField : String, startField : String, appName : String) -> String]
											[Const:reflaxe.elixir.ElixirCompiler] this
											[FInstance:(idField : String, startField : String, appName : String) -> String]
												reflaxe.elixir.ElixirCompiler
												generateModernTupleFormat:(idField : String, startField : String, appName : String) -> String
										[Local idField(21489):Null<String>:Null<String>]
										[Local startField(21498):Null<String>:Null<String>]
										[Local appName(21299):String:String]
					[Case:Dynamic]
						[Const:String] "SimpleModule"
						[Block:Dynamic]
							[Block:Dynamic]
								[Return:Dynamic]
									[Call:String]
										[Field:(idField : String, appName : String) -> String]
											[Const:reflaxe.elixir.ElixirCompiler] this
											[FInstance:(idField : String, appName : String) -> String]
												reflaxe.elixir.ElixirCompiler
												generateSimpleModuleFormat:(idField : String, appName : String) -> String
										[Local idField(21489):Null<String>:Null<String>]
										[Local appName(21299):String:String]
					[Case:Void]
						[Const:String] "TraditionalMap"
						[Block:Void] [Block:Void]
			[Var mapFields(21545):Array<String>] [ArrayDecl:Array<String>]
			[Call:Int]
				[Field:(x : String) -> Int]
					[Local mapFields(21545):Array<String>:Array<String>]
					[FInstance:(x : String) -> Int]
						Array<String>
						push:(x : Array.T) -> Int
				[Binop:String]
					[Const:String] "id: "
					+
					[Local idField(21489):Null<String>:Null<String>]
			[Call:Int]
				[Field:(x : String) -> Int]
					[Local mapFields(21545):Array<String>:Array<String>]
					[FInstance:(x : String) -> Int]
						Array<String>
						push:(x : Array.T) -> Int
				[Binop:String]
					[Const:String] "start: "
					+
					[Local startField(21498):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Cast:Null<String>]
						[Call:Null<String>]
							[Field:(key : String) -> Null<String>]
								[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
								[FInstance:(key : String) -> Null<String>]
									haxe.ds.StringMap<String>
									get:(key : String) -> Null<haxe.ds.StringMap.T>
							[Const:String] "restart"
					!=
					[Const:Null<String>] null
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local mapFields(21545):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Const:String] "restart: "
							+
							[Cast:Null<String>]
								[Call:Null<String>]
									[Field:(key : String) -> Null<String>]
										[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
										[FInstance:(key : String) -> Null<String>]
											haxe.ds.StringMap<String>
											get:(key : String) -> Null<haxe.ds.StringMap.T>
									[Const:String] "restart"
			[If:Void]
				[Binop:Bool]
					[Cast:Null<String>]
						[Call:Null<String>]
							[Field:(key : String) -> Null<String>]
								[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
								[FInstance:(key : String) -> Null<String>]
									haxe.ds.StringMap<String>
									get:(key : String) -> Null<haxe.ds.StringMap.T>
							[Const:String] "shutdown"
					!=
					[Const:Null<String>] null
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local mapFields(21545):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Const:String] "shutdown: "
							+
							[Cast:Null<String>]
								[Call:Null<String>]
									[Field:(key : String) -> Null<String>]
										[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
										[FInstance:(key : String) -> Null<String>]
											haxe.ds.StringMap<String>
											get:(key : String) -> Null<haxe.ds.StringMap.T>
									[Const:String] "shutdown"
			[If:Void]
				[Binop:Bool]
					[Cast:Null<String>]
						[Call:Null<String>]
							[Field:(key : String) -> Null<String>]
								[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
								[FInstance:(key : String) -> Null<String>]
									haxe.ds.StringMap<String>
									get:(key : String) -> Null<haxe.ds.StringMap.T>
							[Const:String] "type"
					!=
					[Const:Null<String>] null
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local mapFields(21545):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Const:String] "type: "
							+
							[Cast:Null<String>]
								[Call:Null<String>]
									[Field:(key : String) -> Null<String>]
										[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
										[FInstance:(key : String) -> Null<String>]
											haxe.ds.StringMap<String>
											get:(key : String) -> Null<haxe.ds.StringMap.T>
									[Const:String] "type"
			[If:Void]
				[Binop:Bool]
					[Cast:Null<String>]
						[Call:Null<String>]
							[Field:(key : String) -> Null<String>]
								[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
								[FInstance:(key : String) -> Null<String>]
									haxe.ds.StringMap<String>
									get:(key : String) -> Null<haxe.ds.StringMap.T>
							[Const:String] "modules"
					!=
					[Const:Null<String>] null
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local mapFields(21545):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Const:String] "modules: "
							+
							[Cast:Null<String>]
								[Call:Null<String>]
									[Field:(key : String) -> Null<String>]
										[Local compiledFields(21298):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
										[FInstance:(key : String) -> Null<String>]
											haxe.ds.StringMap<String>
											get:(key : String) -> Null<haxe.ds.StringMap.T>
									[Const:String] "modules"
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Const:String] "%{"
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local mapFields(21545):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] "}"

	function resolveAppNameInString[Function:(str : String, appName : String) -> String]
		[Arg:String] [Local str(21307):String]
		[Arg:String] [Local appName(21308):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local str(21307):String:String]
					==
					[Const:String] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(sep : String) -> String]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local str(21307):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] "\""
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local str(21307):String:String]
					[Const:String] "\" <> app_name <> \""
					[Local appName(21308):String:String]
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local str(21307):String:String]
					[Binop:String]
						[Const:String] ""
						+
						[Local appName(21308):String:String]
					[Local appName(21308):String:String]
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local str(21307):String:String]
					[Const:String] "app_name"
					[Local appName(21308):String:String]
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local str(21307):String:String]
					[Const:String] "\" <> \""
					[Const:String] ""
			[Binop:String]
				[Local str(21307):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local str(21307):String:String]
					[Const:String] " <> "
					[Const:String] ""
			[Return:Dynamic] [Local str(21307):String:String]

	function isSupervisorOptionsObject[Function:(fields : Array<{ name : String, expr : haxe.macro.TypedExpr }>) -> Bool]
		[Arg:Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33730):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local fields(33730):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						==
						[Const:Array<{ name : String, expr : haxe.macro.TypedExpr }>] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local fields(33730):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ name : String, expr : haxe.macro.TypedExpr }>
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var fieldNames(33740):Array<String>]
				[Block:Array<String>]
					[Var `(33735):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(33736):Int] [Const:Int] 0
						[Var `(33737):Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(33730):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
						[While:Void]
							[Binop:Bool]
								[Local `(33736):Int:Int]
								<
								[Field:Int]
									[Local `(33737):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
									[FInstance:Int]
										Array<{ name : String, expr : haxe.macro.TypedExpr }>
										length:Int
							[Block:Void]
								[Var v(33738):{ name : String, expr : haxe.macro.TypedExpr }]
									[Array:{ name : String, expr : haxe.macro.TypedExpr }]
										[Local `(33737):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
										[Local `(33736):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33736):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(33735):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(f : { name : String, expr : haxe.macro.TypedExpr }) -> String]
											[Arg:{ name : String, expr : haxe.macro.TypedExpr }] [Local f(33739):{ name : String, expr : haxe.macro.TypedExpr }]
											[Block:Dynamic]
												[Return:Dynamic]
													[Field:String]
														[Local f(33739):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
														[FAnon:String] name:String
										[Local v(33738):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
					[Local `(33735):Array<String>:Array<String>]
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Int]
						[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
							[Local fieldNames(33740):Array<String>:Array<String>]
							[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
								Array<String>
								indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
						[Const:String] "strategy"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1

	public function compileSupervisorOptions[Function:(fields : Array<{ name : String, expr : haxe.macro.TypedExpr }>, classType : Null<haxe.macro.ClassType>) -> String]
		[Arg:Array<{ name : String, expr : haxe.macro.TypedExpr }>] [Local fields(21591):Array<{ name : String, expr : haxe.macro.TypedExpr }>]
		[Arg:Null<haxe.macro.ClassType>] [Local classType(21592):Null<haxe.macro.ClassType>]
		[Block:Dynamic]
			[Var strategy(21593):String] [Const:String] "one_for_one"
			[Var name(21594):String] [Const:String] ""
			[Var appName(21595):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.AnnotationSystem
							getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
					[Local classType(21592):Null<haxe.macro.ClassType>:Null<haxe.macro.ClassType>]
			[Block:Void]
				[Var `(21599):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(21599):Int:Int]
						<
						[Field:Int]
							[Local fields(21591):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ name : String, expr : haxe.macro.TypedExpr }>
								length:Int
					[Block:Void]
						[Var field(21596):{ name : String, expr : haxe.macro.TypedExpr }]
							[Array:{ name : String, expr : haxe.macro.TypedExpr }]
								[Local fields(21591):Array<{ name : String, expr : haxe.macro.TypedExpr }>:Array<{ name : String, expr : haxe.macro.TypedExpr }>]
								[Local `(21599):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(21599):Int:Int]
						[Meta:Void]
							:ast(switch (field.name) {
	case "strategy":
		strategy = compileExpression(field.expr);
		strategy = strategy.split("\"").join("");
		if (strategy.startsWith(":")) {
			strategy = strategy.substring(1);
		};	
	case "name":
		name = compileExpression(field.expr);
		name = resolveAppNameInString(name, appName);	
})
							[Block:Void]
								[Var `(21598):String]
									[Field:String]
										[Local field(21596):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
										[FAnon:String] name:String
								[Switch:Void]
									[Local `(21598):String:String]
									[Case:String]
										[Const:String] "name"
										[Block:String]
											[Block:String]
												[Binop:String]
													[Local name(21594):String:String]
													=
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21596):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[Binop:String]
													[Local name(21594):String:String]
													=
													[Call:String]
														[Field:(str : String, appName : String) -> String]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(str : String, appName : String) -> String]
																reflaxe.elixir.ElixirCompiler
																resolveAppNameInString:(str : String, appName : String) -> String
														[Local name(21594):String:String]
														[Local appName(21595):String:String]
									[Case:Void]
										[Const:String] "strategy"
										[Block:Void]
											[Block:Void]
												[Binop:String]
													[Local strategy(21593):String:String]
													=
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Const:reflaxe.elixir.ElixirCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Field:haxe.macro.TypedExpr]
															[Local field(21596):{ name : String, expr : haxe.macro.TypedExpr }:{ name : String, expr : haxe.macro.TypedExpr }]
															[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Const:Null<Bool>] null
												[Binop:String]
													[Local strategy(21593):String:String]
													=
													[Call:String]
														[Field:(sep : String) -> String]
															[Call:Array<String>]
																[Field:(delimiter : String) -> Array<String>]
																	[Local strategy(21593):String:String]
																	[FInstance:(delimiter : String) -> Array<String>]
																		String
																		split:(delimiter : String) -> Array<String>
																[Const:String] "\""
															[FInstance:(sep : String) -> String]
																Array<String>
																join:(sep : String) -> String
														[Const:String] ""
												[If:Void]
													[Call:Bool]
														[Field:(s : String, start : String) -> Bool]
															[TypeExpr StringTools:{ Statics StringTools }]
															[FStatic:(s : String, start : String) -> Bool]
																StringTools
																startsWith:(s : String, start : String) -> Bool
														[Local strategy(21593):String:String]
														[Const:String] ":"
													[Then:String] [Block:String]
														[Binop:String]
															[Local strategy(21593):String:String]
															=
															[Call:String]
																[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																	[Local strategy(21593):String:String]
																	[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																		String
																		substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
																[Const:Int] 1
																[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Local name(21594):String:String]
					==
					[Const:String] ""
				[Then:String] [Block:String]
					[Binop:String]
						[Local name(21594):String:String]
						=
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local appName(21595):String:String]
							+
							[Const:String] ".Supervisor"
			[Var options(21600):Array<String>] [ArrayDecl:Array<String>]
			[Call:Int]
				[Field:(x : String) -> Int]
					[Local options(21600):Array<String>:Array<String>]
					[FInstance:(x : String) -> Int]
						Array<String>
						push:(x : Array.T) -> Int
				[Binop:String]
					[Const:String] "strategy: :"
					+
					[Local strategy(21593):String:String]
			[Call:Int]
				[Field:(x : String) -> Int]
					[Local options(21600):Array<String>:Array<String>]
					[FInstance:(x : String) -> Int]
						Array<String>
						push:(x : Array.T) -> Int
				[Binop:String]
					[Const:String] "name: "
					+
					[Local name(21594):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Const:String] "["
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local options(21600):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] "]"

	public function isElixirSyntaxCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(33741):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(33742):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.MethodCallCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
								reflaxe.elixir.ElixirCompiler
								methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
						[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
							reflaxe.elixir.helpers.MethodCallCompiler
							isElixirSyntaxCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
					[Local obj(33741):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldName(33742):String:String]

	public function compileElixirSyntaxCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(33743):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(33744):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.MethodCallCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
								reflaxe.elixir.ElixirCompiler
								methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
						[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.MethodCallCompiler
							compileElixirSyntaxCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
					[Local methodName(33743):String:String]
					[Local args(33744):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function isFieldAssignment[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33745):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, e1, e2):
		switch (e1.expr) {
			case TField(e, fa):
				switch (e.expr) {
					case TConst(TThis):
						true;					
					case TLocal(v):
						v.name == "this" || v.name == "_this";					
					case _:
						false;					
				};			
			case _:
				false;			
		};	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(33774):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33745):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33774):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 3
							[Then:Bool] [Block:Bool]
								[Var `(33775):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33774):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33776):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33774):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33777):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33774):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33775):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Bool] [Block:Bool]
										[Block:Bool]
											[Var e1(33778):haxe.macro.TypedExpr] [Local `(33776):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e2(33779):haxe.macro.TypedExpr] [Local `(33777):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Bool]
												[Meta:Bool]
													:ast(switch (e1.expr) {
	case TField(e, fa):
		switch (e.expr) {
			case TConst(TThis):
				true;			
			case TLocal(v):
				v.name == "this" || v.name == "_this";			
			case _:
				false;			
		};	
	case _:
		false;	
})
													[Block:Bool]
														[Var `(33780):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local e1(33778):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Bool]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(33780):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 4
															[Then:Bool] [Block:Bool]
																[Var `(33781):haxe.macro.TypedExpr]
																	[EnumParameter:haxe.macro.TypedExpr]
																		[Local `(33780):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TField
																		0
																[Var `(33782):haxe.macro.FieldAccess]
																	[EnumParameter:haxe.macro.FieldAccess]
																		[Local `(33780):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TField
																		1
																[Block:Bool]
																	[Var e(33783):haxe.macro.TypedExpr] [Local `(33781):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Var fa(33784):haxe.macro.FieldAccess] [Local `(33782):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																	[Block:Bool]
																		[Meta:Bool]
																			:ast(switch (e.expr) {
	case TConst(TThis):
		true;	
	case TLocal(v):
		v.name == "this" || v.name == "_this";	
	case _:
		false;	
})
																			[Block:Bool]
																				[Var `(33785):haxe.macro.TypedExprDef]
																					[Field:haxe.macro.TypedExprDef]
																						[Local e(33783):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																				[Switch:Bool]
																					[EnumIndex:Int] [Local `(33785):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					[Case:Bool]
																						[Const:Int] 0
																						[Block:Bool]
																							[Var `(33786):haxe.macro.TConstant]
																								[EnumParameter:haxe.macro.TConstant]
																									[Local `(33785):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TConst
																									0
																							[If:Bool]
																								[Binop:Bool]
																									[EnumIndex:Int] [Local `(33786):haxe.macro.TConstant:haxe.macro.TConstant]
																									==
																									[Const:Int] 5
																								[Then:Bool] [Block:Bool] [Block:Bool] [Const:Bool] true
																								[Else:Bool] [Block:Bool] [Const:Bool] false
																					[Case:Bool]
																						[Const:Int] 1
																						[Block:Bool]
																							[Var `(33787):haxe.macro.TVar]
																								[EnumParameter:haxe.macro.TVar]
																									[Local `(33785):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TLocal
																									0
																							[Block:Bool]
																								[Var v(33788):haxe.macro.TVar] [Local `(33787):haxe.macro.TVar:haxe.macro.TVar]
																								[Block:Bool]
																									[Binop:Bool]
																										[Binop:Bool]
																											[Field:String]
																												[Local v(33788):haxe.macro.TVar:haxe.macro.TVar]
																												[FAnon:String] name:String
																											==
																											[Const:String] "this"
																										||
																										[Binop:Bool]
																											[Field:String]
																												[Local v(33788):haxe.macro.TVar:haxe.macro.TVar]
																												[FAnon:String] name:String
																											==
																											[Const:String] "_this"
																					[Default:Bool] [Block:Bool] [Const:Bool] false
															[Else:Bool] [Block:Bool] [Const:Bool] false
									[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Const:Bool] false

	function extractFieldUpdate[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33789):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, e1, e2):
		switch (e1.expr) {
			case TField(e, fa):
				var fieldName = switch (fa) {
					case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf):
						cf.get().name;					
					case _:
						null;					
				};
				if (fieldName != null) {
					var value = compileExpression(e2);
					var elixirFieldName = reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName);
					"${elixirFieldName}: ${value}";
				} else {
					null;
				};			
			case _:
				null;			
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(33837):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33789):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33837):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 3
							[Then:Null<String>] [Block:Null<String>]
								[Var `(33838):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33837):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33839):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33837):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33840):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33837):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Null<String>]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33838):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Null<String>] [Block:Null<String>]
										[Block:Null<String>]
											[Var e1(33841):haxe.macro.TypedExpr] [Local `(33839):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e2(33842):haxe.macro.TypedExpr] [Local `(33840):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Null<String>]
												[Meta:Null<String>]
													:ast(switch (e1.expr) {
	case TField(e, fa):
		var fieldName = switch (fa) {
			case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf):
				cf.get().name;			
			case _:
				null;			
		};
		if (fieldName != null) {
			var value = compileExpression(e2);
			var elixirFieldName = reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName);
			"${elixirFieldName}: ${value}";
		} else {
			null;
		};	
	case _:
		null;	
})
													[Block:Null<String>]
														[Var `(33843):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local e1(33841):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Null<String>]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(33843):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 4
															[Then:Null<String>] [Block:Null<String>]
																[Var `(33844):haxe.macro.TypedExpr]
																	[EnumParameter:haxe.macro.TypedExpr]
																		[Local `(33843):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TField
																		0
																[Var `(33845):haxe.macro.FieldAccess]
																	[EnumParameter:haxe.macro.FieldAccess]
																		[Local `(33843):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TField
																		1
																[Block:Null<String>]
																	[Var e(33846):haxe.macro.TypedExpr] [Local `(33844):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Var fa(33847):haxe.macro.FieldAccess] [Local `(33845):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																	[Block:Null<String>]
																		[Var fieldName(33848):Null<String>]
																			[Meta:Null<String>]
																				:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf):
		cf.get().name;	
	case _:
		null;	
})
																				[Switch:Null<String>]
																					[EnumIndex:Int] [Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																					[Case:String]
																						[Const:Int] 0
																						[Block:String]
																							[Var `(33849):haxe.macro.Ref<haxe.macro.ClassType>]
																								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FInstance
																									0
																							[Var `(33850):Array<haxe.macro.Type>]
																								[EnumParameter:Array<haxe.macro.Type>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FInstance
																									1
																							[Var `(33851):haxe.macro.Ref<haxe.macro.ClassField>]
																								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FInstance
																									2
																							[Block:String]
																								[Var cf(33852):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33851):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																								[Block:String]
																									[Field:String]
																										[Call:haxe.macro.ClassField]
																											[Field:() -> haxe.macro.ClassField]
																												[Local cf(33852):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																												[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																										[FAnon:String] name:String
																					[Case:String]
																						[Const:Int] 1
																						[Block:String]
																							[Var `(33853):haxe.macro.Ref<haxe.macro.ClassType>]
																								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FStatic
																									0
																							[Var `(33854):haxe.macro.Ref<haxe.macro.ClassField>]
																								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FStatic
																									1
																							[Block:String]
																								[Var cf(33855):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33854):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																								[Block:String]
																									[Field:String]
																										[Call:haxe.macro.ClassField]
																											[Field:() -> haxe.macro.ClassField]
																												[Local cf(33855):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																												[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																										[FAnon:String] name:String
																					[Case:String]
																						[Const:Int] 2
																						[Block:String]
																							[Var `(33856):haxe.macro.Ref<haxe.macro.ClassField>]
																								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																									[Local fa(33847):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																									FAnon
																									0
																							[Block:String]
																								[Var cf(33857):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(33856):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																								[Block:String]
																									[Field:String]
																										[Call:haxe.macro.ClassField]
																											[Field:() -> haxe.macro.ClassField]
																												[Local cf(33857):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																												[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																										[FAnon:String] name:String
																					[Default:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
																		[If:Null<String>]
																			[Binop:Bool]
																				[Local fieldName(33848):Null<String>:Null<String>]
																				!=
																				[Const:Null<String>] null
																			[Then:String] [Block:String]
																				[Var value(33858):Null<String>]
																					[Call:Null<String>]
																						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							[Const:reflaxe.elixir.ElixirCompiler] this
																							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								reflaxe.elixir.ElixirCompiler
																								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																						[Local e2(33842):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Const:Null<Bool>] null
																				[Var elixirFieldName(33859):String]
																					[Call:String]
																						[Field:(camelCase : String) -> String]
																							[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																							[FStatic:(camelCase : String) -> String]
																								reflaxe.elixir.helpers.NamingHelper
																								toSnakeCase:(camelCase : String) -> String
																						[Local fieldName(33848):Null<String>:Null<String>]
																				[Binop:String]
																					[Binop:String]
																						[Binop:String]
																							[Const:String] ""
																							+
																							[Local elixirFieldName(33859):String:String]
																						+
																						[Const:String] ": "
																					+
																					[Local value(33858):Null<String>:Null<String>]
																			[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
															[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
									[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function detectTempVariablePattern[Function:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(33860):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>]
							reflaxe.elixir.helpers.TempVariableOptimizer
							detectTempVariablePattern:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>
					[Local expressions(33860):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function optimizeTempVariablePattern[Function:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local tempVarName(33861):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(33862):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.TempVariableOptimizer
							optimizeTempVariablePattern:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String
					[Local tempVarName(33861):String:String]
					[Local expressions(33862):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function fixTempVariableScoping[Function:(code : String, tempVarName : String) -> String]
		[Arg:String] [Local code(33863):String]
		[Arg:String] [Local tempVarName(33864):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(code : String, tempVarName : String) -> String]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(code : String, tempVarName : String) -> String]
							reflaxe.elixir.helpers.TempVariableOptimizer
							fixTempVariableScoping:(code : String, tempVarName : String) -> String
					[Local code(33863):String:String]
					[Local tempVarName(33864):String:String]

	function extractValueFromTempAssignment[Function:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33865):haxe.macro.TypedExpr]
		[Arg:String] [Local tempVarName(33866):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(33865):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					==
					[Const:haxe.macro.TypedExpr] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, lhs, rhs):
		switch (lhs.expr) {
			case TLocal(v):
				var varName = getOriginalVarName(v);
				if (varName == tempVarName) {
					return compileExpression(rhs);
				};			
			case _:
		};
		var rhsResult = extractValueFromTempAssignment(rhs, tempVarName);
		if (rhsResult != null) return rhsResult;
		var lhsResult = extractValueFromTempAssignment(lhs, tempVarName);
		if (lhsResult != null) return lhsResult;
		null;	
	case TBlock(expressions):
		for (e  in  expressions) {
			var result = extractValueFromTempAssignment(e, tempVarName);
			if (result != null) return result;
		};
		null;	
	case TIf(condition, thenExpr, elseExpr):
		var thenResult = extractValueFromTempAssignment(thenExpr, tempVarName);
		if (thenResult != null) return thenResult;
		var elseResult = extractValueFromTempAssignment(elseExpr, tempVarName);
		if (elseResult != null) return elseResult;
		null;	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(33896):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33865):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Null<String>]
							[EnumIndex:Int] [Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Null<String>]
								[Const:Int] 3
								[Block:Null<String>]
									[Var `(33897):haxe.macro.Binop]
										[EnumParameter:haxe.macro.Binop]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											0
									[Var `(33898):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											1
									[Var `(33899):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											2
									[If:Null<String>]
										[Binop:Bool]
											[EnumIndex:Int] [Local `(33897):haxe.macro.Binop:haxe.macro.Binop]
											==
											[Const:Int] 4
										[Then:Null<String>] [Block:Null<String>]
											[Block:Null<String>]
												[Var lhs(33900):haxe.macro.TypedExpr] [Local `(33898):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var rhs(33901):haxe.macro.TypedExpr] [Local `(33899):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Block:Null<String>]
													[Meta:Void]
														:ast(switch (lhs.expr) {
	case TLocal(v):
		var varName = getOriginalVarName(v);
		if (varName == tempVarName) {
			return compileExpression(rhs);
		};	
	case _:
})
														[Block:Void]
															[Var `(33902):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local lhs(33900):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Void]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(33902):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 1
																[Then:Void] [Block:Void]
																	[Var `(33903):haxe.macro.TVar]
																		[EnumParameter:haxe.macro.TVar]
																			[Local `(33902):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TLocal
																			0
																	[Block:Void]
																		[Var v(33904):haxe.macro.TVar] [Local `(33903):haxe.macro.TVar:haxe.macro.TVar]
																		[Block:Void]
																			[Var varName(33905):String]
																				[Call:String]
																					[Field:(v : haxe.macro.TVar) -> String]
																						[Const:reflaxe.elixir.ElixirCompiler] this
																						[FInstance:(v : haxe.macro.TVar) -> String]
																							reflaxe.elixir.ElixirCompiler
																							getOriginalVarName:(v : haxe.macro.TVar) -> String
																					[Local v(33904):haxe.macro.TVar:haxe.macro.TVar]
																			[If:Void]
																				[Binop:Bool]
																					[Local varName(33905):String:String]
																					==
																					[Local tempVarName(33866):String:String]
																				[Then:Dynamic] [Block:Dynamic]
																					[Return:Dynamic]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Const:reflaxe.elixir.ElixirCompiler] this
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Local rhs(33901):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Const:Null<Bool>] null
																[Else:Void] [Block:Void]
													[Var rhsResult(33906):Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	extractValueFromTempAssignment:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>
															[Local rhs(33901):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local tempVarName(33866):String:String]
													[If:Void]
														[Binop:Bool]
															[Local rhsResult(33906):Null<String>:Null<String>]
															!=
															[Const:Null<String>] null
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local rhsResult(33906):Null<String>:Null<String>]
													[Var lhsResult(33907):Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																[Const:reflaxe.elixir.ElixirCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	extractValueFromTempAssignment:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>
															[Local lhs(33900):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local tempVarName(33866):String:String]
													[If:Void]
														[Binop:Bool]
															[Local lhsResult(33907):Null<String>:Null<String>]
															!=
															[Const:Null<String>] null
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local lhsResult(33907):Null<String>:Null<String>]
													[Const:Null<String>] null
										[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Case:Null<String>]
								[Const:Int] 14
								[Block:Null<String>]
									[Var `(33908):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:Null<String>]
										[Var expressions(33909):Array<haxe.macro.TypedExpr>] [Local `(33908):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:Null<String>]
											[Block:Void]
												[Var `(33910):Int] [Const:Int] 0
												[While:Void]
													[Binop:Bool]
														[Local `(33910):Int:Int]
														<
														[Field:Int]
															[Local expressions(33909):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var e(33911):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local expressions(33909):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(33910):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(33910):Int:Int]
														[Var result(33912):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																	[Const:reflaxe.elixir.ElixirCompiler] this
																	[FInstance:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		extractValueFromTempAssignment:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>
																[Local e(33911):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Local tempVarName(33866):String:String]
														[If:Void]
															[Binop:Bool]
																[Local result(33912):Null<String>:Null<String>]
																!=
																[Const:Null<String>] null
															[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local result(33912):Null<String>:Null<String>]
											[Const:Null<String>] null
							[Case:Null<String>]
								[Const:Int] 16
								[Block:Null<String>]
									[Var `(33913):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											0
									[Var `(33914):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											1
									[Var `(33915):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(33896):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											2
									[Block:Null<String>]
										[Var condition(33916):haxe.macro.TypedExpr] [Local `(33913):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var thenExpr(33917):haxe.macro.TypedExpr] [Local `(33914):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var elseExpr(33918):Null<haxe.macro.TypedExpr>] [Local `(33915):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										[Block:Null<String>]
											[Var thenResult(33919):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															extractValueFromTempAssignment:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>
													[Local thenExpr(33917):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local tempVarName(33866):String:String]
											[If:Void]
												[Binop:Bool]
													[Local thenResult(33919):Null<String>:Null<String>]
													!=
													[Const:Null<String>] null
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local thenResult(33919):Null<String>:Null<String>]
											[Var elseResult(33920):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															extractValueFromTempAssignment:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Null<String>
													[Local elseExpr(33918):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													[Local tempVarName(33866):String:String]
											[If:Void]
												[Binop:Bool]
													[Local elseResult(33920):Null<String>:Null<String>]
													!=
													[Const:Null<String>] null
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local elseResult(33920):Null<String>:Null<String>]
											[Const:Null<String>] null
							[Default:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function isTempVariableUsage[Function:(expr : haxe.macro.TypedExpr, tempVarName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(33921):haxe.macro.TypedExpr]
		[Arg:String] [Local tempVarName(33922):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, lhs, rhs):
		switch (rhs.expr) {
			case TLocal(v):
				var varName = getOriginalVarName(v);
				return varName == tempVarName;			
			case _:
				return false;			
		};	
	case _:
		return false;	
})
					[Block:Bool]
						[Var `(33937):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33921):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33937):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 3
							[Then:Bool] [Block:Bool]
								[Var `(33938):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33937):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33939):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33937):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33940):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33937):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33938):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Bool] [Block:Bool]
										[Block:Bool]
											[Var lhs(33941):haxe.macro.TypedExpr] [Local `(33939):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var rhs(33942):haxe.macro.TypedExpr] [Local `(33940):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Bool]
												[Meta:Bool]
													:ast(switch (rhs.expr) {
	case TLocal(v):
		var varName = getOriginalVarName(v);
		return varName == tempVarName;	
	case _:
		return false;	
})
													[Block:Bool]
														[Var `(33943):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local rhs(33942):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Bool]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(33943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 1
															[Then:Bool] [Block:Bool]
																[Var `(33944):haxe.macro.TVar]
																	[EnumParameter:haxe.macro.TVar]
																		[Local `(33943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TLocal
																		0
																[Block:Bool]
																	[Var v(33945):haxe.macro.TVar] [Local `(33944):haxe.macro.TVar:haxe.macro.TVar]
																	[Block:Bool]
																		[Var varName(33946):String]
																			[Call:String]
																				[Field:(v : haxe.macro.TVar) -> String]
																					[Const:reflaxe.elixir.ElixirCompiler] this
																					[FInstance:(v : haxe.macro.TVar) -> String]
																						reflaxe.elixir.ElixirCompiler
																						getOriginalVarName:(v : haxe.macro.TVar) -> String
																				[Local v(33945):haxe.macro.TVar:haxe.macro.TVar]
																		[Return:Bool]
																			[Binop:Bool]
																				[Local varName(33946):String:String]
																				==
																				[Local tempVarName(33922):String:String]
															[Else:Bool] [Block:Bool] [Return:Bool] [Const:Bool] false
									[Else:Bool] [Block:Bool] [Return:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Return:Bool] [Const:Bool] false

	function detectTempVariableAssignmentPattern[Function:(ifBranch : haxe.macro.TypedExpr, elseBranch : Null<haxe.macro.TypedExpr>) -> Null<{ varName : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ifBranch(33947):haxe.macro.TypedExpr]
		[Arg:Null<haxe.macro.TypedExpr>] [Local elseBranch(33948):Null<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<{ varName : String }>]
					[Field:(ifBranch : haxe.macro.TypedExpr, elseBranch : Null<haxe.macro.TypedExpr>) -> Null<{ varName : String }>]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(ifBranch : haxe.macro.TypedExpr, elseBranch : Null<haxe.macro.TypedExpr>) -> Null<{ varName : String }>]
							reflaxe.elixir.helpers.TempVariableOptimizer
							detectTempVariableAssignmentPattern:(ifBranch : haxe.macro.TypedExpr, elseBranch : Null<haxe.macro.TypedExpr>) -> Null<{ varName : String }>
					[Local ifBranch(33947):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local elseBranch(33948):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]

	function getAssignmentVariable[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33949):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
						[Field:reflaxe.elixir.helpers.PatternAnalysisCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.PatternAnalysisCompiler]
								reflaxe.elixir.ElixirCompiler
								patternAnalysisCompiler:reflaxe.elixir.helpers.PatternAnalysisCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.PatternAnalysisCompiler
							getAssignmentVariable:(expr : haxe.macro.TypedExpr) -> Null<String>
					[Local expr(33949):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function extractAssignmentValue[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(33950):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, lhs, rhs):
		compileExpression(rhs);	
	case _:
		compileExpression(expr);	
})
					[Block:String]
						[Var `(33957):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33957):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 3
							[Then:String] [Block:String]
								[Var `(33958):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33957):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33959):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33957):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33960):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33957):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:String]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33958):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Null<String>] [Block:Null<String>]
										[Block:Null<String>]
											[Var lhs(33961):haxe.macro.TypedExpr] [Local `(33959):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var rhs(33962):haxe.macro.TypedExpr] [Local `(33960):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Const:reflaxe.elixir.ElixirCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Local rhs(33962):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Const:Null<Bool>] null
									[Else:Null<String>] [Block:Null<String>]
										[Call:Null<String>]
											[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												[Const:reflaxe.elixir.ElixirCompiler] this
												[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
											[Local expr(33950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Const:Null<Bool>] null
							[Else:Null<String>] [Block:Null<String>]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										[Const:reflaxe.elixir.ElixirCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											reflaxe.elixir.ElixirCompiler
											compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
									[Local expr(33950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Const:Null<Bool>] null

	function detectTempVariableAssignmentSequence[Function:(expressions : Array<haxe.macro.TypedExpr>) -> Null<{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(33963):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Null<{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }>]
					[Field:(expressions : Array<haxe.macro.TypedExpr>) -> Null<{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }>]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(expressions : Array<haxe.macro.TypedExpr>) -> Null<{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }>]
							reflaxe.elixir.helpers.TempVariableOptimizer
							detectTempVariableAssignmentSequence:(expressions : Array<haxe.macro.TypedExpr>) -> Null<{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }>
					[Local expressions(33963):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function optimizeTempVariableAssignmentSequence[Function:(sequence : { tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }, expressions : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }] [Local sequence(33964):{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(33965):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(sequence : { tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }, expressions : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
								reflaxe.elixir.ElixirCompiler
								tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
						[FInstance:(sequence : { tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }, expressions : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.TempVariableOptimizer
							optimizeTempVariableAssignmentSequence:(sequence : { tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }, expressions : Array<haxe.macro.TypedExpr>) -> String
					[Local sequence(33964):{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }:{ tempVar : String, targetVar : String, ifIndex : Int, assignIndex : Int }]
					[Local expressions(33965):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function getTargetVariableFromAssignment[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(33966):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TBinop(OpAssign, lhs, rhs):
		switch (lhs.expr) {
			case TLocal(v):
				return getOriginalVarName(v);			
			case TField(e, field):
				var objCompiled = compileExpression(e);
				return objCompiled;			
			case _:
				return null;			
		};	
	case _:
		return null;	
})
					[Block:Null<String>]
						[Var `(33989):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(33966):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(33989):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 3
							[Then:Null<String>] [Block:Null<String>]
								[Var `(33990):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(33989):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(33991):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33989):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(33992):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(33989):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Null<String>]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(33990):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Null<String>] [Block:Null<String>]
										[Block:Null<String>]
											[Var lhs(33993):haxe.macro.TypedExpr] [Local `(33991):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var rhs(33994):haxe.macro.TypedExpr] [Local `(33992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Null<String>]
												[Meta:Null<String>]
													:ast(switch (lhs.expr) {
	case TLocal(v):
		return getOriginalVarName(v);	
	case TField(e, field):
		var objCompiled = compileExpression(e);
		return objCompiled;	
	case _:
		return null;	
})
													[Block:Null<String>]
														[Var `(33995):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local lhs(33993):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[Switch:Null<String>]
															[EnumIndex:Int] [Local `(33995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															[Case:Null<String>]
																[Const:Int] 1
																[Block:Null<String>]
																	[Var `(33996):haxe.macro.TVar]
																		[EnumParameter:haxe.macro.TVar]
																			[Local `(33995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TLocal
																			0
																	[Block:Null<String>]
																		[Var v(33997):haxe.macro.TVar] [Local `(33996):haxe.macro.TVar:haxe.macro.TVar]
																		[Block:Null<String>]
																			[Return:Null<String>]
																				[Call:String]
																					[Field:(v : haxe.macro.TVar) -> String]
																						[Const:reflaxe.elixir.ElixirCompiler] this
																						[FInstance:(v : haxe.macro.TVar) -> String]
																							reflaxe.elixir.ElixirCompiler
																							getOriginalVarName:(v : haxe.macro.TVar) -> String
																					[Local v(33997):haxe.macro.TVar:haxe.macro.TVar]
															[Case:Null<String>]
																[Const:Int] 4
																[Block:Null<String>]
																	[Var `(33998):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(33995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			0
																	[Var `(33999):haxe.macro.FieldAccess]
																		[EnumParameter:haxe.macro.FieldAccess]
																			[Local `(33995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			1
																	[Block:Null<String>]
																		[Var e(34000):haxe.macro.TypedExpr] [Local `(33998):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var field(34001):haxe.macro.FieldAccess] [Local `(33999):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		[Block:Null<String>]
																			[Var objCompiled(34002):Null<String>]
																				[Call:Null<String>]
																					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						[Const:reflaxe.elixir.ElixirCompiler] this
																						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							reflaxe.elixir.ElixirCompiler
																							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																					[Local e(34000):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Const:Null<Bool>] null
																			[Return:Null<String>] [Local objCompiled(34002):Null<String>:Null<String>]
															[Default:Null<String>] [Block:Null<String>] [Return:Null<String>] [Const:Null<String>] null
									[Else:Null<String>] [Block:Null<String>] [Return:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Return:Null<String>] [Const:Null<String>] null

	function isNilExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(34003):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TConst(TNull):
		true;	
	case TIdent("nil"):
		true;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(34007):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(34003):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Bool]
							[EnumIndex:Int] [Local `(34007):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Bool]
								[Const:Int] 0
								[Block:Bool]
									[Var `(34008):haxe.macro.TConstant]
										[EnumParameter:haxe.macro.TConstant]
											[Local `(34007):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TConst
											0
									[If:Bool]
										[Binop:Bool]
											[EnumIndex:Int] [Local `(34008):haxe.macro.TConstant:haxe.macro.TConstant]
											==
											[Const:Int] 4
										[Then:Bool] [Block:Bool] [Block:Bool] [Const:Bool] true
										[Else:Bool] [Block:Bool] [Const:Bool] false
							[Case:Bool]
								[Const:Int] 28
								[Block:Bool]
									[Var `(34009):String]
										[EnumParameter:String]
											[Local `(34007):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIdent
											0
									[If:Bool]
										[Binop:Bool]
											[Local `(34009):String:String]
											==
											[Const:String] "nil"
										[Then:Bool] [Block:Bool] [Block:Bool] [Const:Bool] true
										[Else:Bool] [Block:Bool] [Const:Bool] false
							[Default:Bool] [Block:Bool] [Const:Bool] false

	public function isTypeSafeChildSpecCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(34010):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(34011):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
						[Field:reflaxe.elixir.helpers.MethodCallCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
								reflaxe.elixir.ElixirCompiler
								methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
						[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
							reflaxe.elixir.helpers.MethodCallCompiler
							isTypeSafeChildSpecCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
					[Local obj(34010):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldName(34011):String:String]

	public function compileTypeSafeChildSpecCall[Function:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local fieldName(34012):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(34013):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
						[Field:reflaxe.elixir.helpers.MethodCallCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.MethodCallCompiler]
								reflaxe.elixir.ElixirCompiler
								methodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler
						[FInstance:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
							reflaxe.elixir.helpers.MethodCallCompiler
							compileTypeSafeChildSpecCall:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String
					[Local fieldName(34012):String:String]
					[Local args(34013):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	function detectYCombinatorInAST[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(34014):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expr : haxe.macro.TypedExpr) -> Bool]
						[Field:reflaxe.elixir.helpers.YCombinatorCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.YCombinatorCompiler]
								reflaxe.elixir.ElixirCompiler
								yCombinatorCompiler:reflaxe.elixir.helpers.YCombinatorCompiler
						[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.YCombinatorCompiler
							detectYCombinatorInAST:(expr : haxe.macro.TypedExpr) -> Bool
					[Local expr(34014):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function hasReflectFieldsIteration[Function:(expressions : Array<haxe.macro.TypedExpr>) -> Bool]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(34015):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(expressions : Array<haxe.macro.TypedExpr>) -> Bool]
						[Field:reflaxe.elixir.helpers.ReflectionCompiler]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:reflaxe.elixir.helpers.ReflectionCompiler]
								reflaxe.elixir.ElixirCompiler
								reflectionCompiler:reflaxe.elixir.helpers.ReflectionCompiler
						[FInstance:(expressions : Array<haxe.macro.TypedExpr>) -> Bool]
							reflaxe.elixir.helpers.ReflectionCompiler
							hasReflectFieldsIteration:(expressions : Array<haxe.macro.TypedExpr>) -> Bool
					[Local expressions(34015):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]

	public function onCompileEnd[Function:() -> Void]
		[Block:Void]
			[If:Void]
				[Field:Bool]
					[Const:reflaxe.elixir.ElixirCompiler] this
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						sourceMapOutputEnabled:Bool
				[Then:Array<reflaxe.elixir.SourceMapWriter>] [Block:Array<reflaxe.elixir.SourceMapWriter>]
					[Block:Void]
						[Var `(34017):Int] [Const:Int] 0
						[Var `(34018):Array<reflaxe.elixir.SourceMapWriter>]
							[Field:Array<reflaxe.elixir.SourceMapWriter>]
								[Const:reflaxe.elixir.ElixirCompiler] this
								[FInstance:Array<reflaxe.elixir.SourceMapWriter>]
									reflaxe.elixir.ElixirCompiler
									pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>
						[While:Void]
							[Binop:Bool]
								[Local `(34017):Int:Int]
								<
								[Field:Int]
									[Local `(34018):Array<reflaxe.elixir.SourceMapWriter>:Array<reflaxe.elixir.SourceMapWriter>]
									[FInstance:Int]
										Array<reflaxe.elixir.SourceMapWriter>
										length:Int
							[Block:Void]
								[Var writer(34016):reflaxe.elixir.SourceMapWriter]
									[Array:reflaxe.elixir.SourceMapWriter]
										[Local `(34018):Array<reflaxe.elixir.SourceMapWriter>:Array<reflaxe.elixir.SourceMapWriter>]
										[Local `(34017):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(34017):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Local writer(34016):reflaxe.elixir.SourceMapWriter:reflaxe.elixir.SourceMapWriter]
										!=
										[Const:reflaxe.elixir.SourceMapWriter] null
									[Then:String] [Block:String]
										[Call:String]
											[Field:() -> String]
												[Local writer(34016):reflaxe.elixir.SourceMapWriter:reflaxe.elixir.SourceMapWriter]
												[FInstance:() -> String]
													reflaxe.elixir.SourceMapWriter
													generateSourceMap:() -> String
					[Binop:Array<reflaxe.elixir.SourceMapWriter>]
						[Field:Array<reflaxe.elixir.SourceMapWriter>]
							[Const:reflaxe.elixir.ElixirCompiler] this
							[FInstance:Array<reflaxe.elixir.SourceMapWriter>]
								reflaxe.elixir.ElixirCompiler
								pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>
						=
						[ArrayDecl:Array<reflaxe.elixir.SourceMapWriter>]

	public function typeToString[Function:(type : haxe.macro.Type) -> String]
		[Arg:haxe.macro.Type] [Local type(31045):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (type) {
	case TInst(t, _):
		t.get().name;	
	case TAbstract(t, _):
		t.get().name;	
	case TEnum(t, _):
		t.get().name;	
	case TFun(_, ret):
		"Function";	
	case TMono(_):
		"Mono";	
	case TDynamic(_):
		"Dynamic";	
	case TAnonymous(_):
		"Anonymous";	
	case TType(t, _):
		t.get().name;	
	case TLazy(_):
		"Lazy";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local type(31045):haxe.macro.Type:haxe.macro.Type]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(31065):haxe.macro.Ref<Null<haxe.macro.Type>>]
									[EnumParameter:haxe.macro.Ref<Null<haxe.macro.Type>>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TMono
										0
								[Block:String] [Const:String] "Mono"
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(31066):haxe.macro.Ref<haxe.macro.EnumType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TEnum
										0
								[Var `(31067):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TEnum
										1
								[Block:String]
									[Var t(31068):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(31066):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
									[Block:String]
										[Field:String]
											[Call:haxe.macro.EnumType]
												[Field:() -> haxe.macro.EnumType]
													[Local t(31068):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
													[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
											[FAnon:String] name:String
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(31069):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(31070):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:String]
									[Var t(31071):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(31069):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Block:String]
										[Field:String]
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local t(31071):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
											[FAnon:String] name:String
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(31072):haxe.macro.Ref<haxe.macro.DefType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.DefType>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TType
										0
								[Var `(31073):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TType
										1
								[Block:String]
									[Var t(31074):haxe.macro.Ref<haxe.macro.DefType>] [Local `(31072):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
									[Block:String]
										[Field:String]
											[Call:haxe.macro.DefType]
												[Field:() -> haxe.macro.DefType]
													[Local t(31074):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
													[FAnon:() -> haxe.macro.DefType] get:() -> haxe.macro.DefType
											[FAnon:String] name:String
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(31075):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TFun
										0
								[Var `(31076):haxe.macro.Type]
									[EnumParameter:haxe.macro.Type]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TFun
										1
								[Block:String]
									[Var ret(31077):haxe.macro.Type] [Local `(31076):haxe.macro.Type:haxe.macro.Type]
									[Block:String] [Const:String] "Function"
						[Case:String]
							[Const:Int] 5
							[Block:String]
								[Var `(31078):haxe.macro.Ref<haxe.macro.AnonType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AnonType>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TAnonymous
										0
								[Block:String] [Const:String] "Anonymous"
						[Case:String]
							[Const:Int] 6
							[Block:String]
								[Var `(31079):Null<haxe.macro.Type>]
									[EnumParameter:Null<haxe.macro.Type>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TDynamic
										0
								[Block:String] [Const:String] "Dynamic"
						[Case:String]
							[Const:Int] 7
							[Block:String]
								[Var `(31080):() -> haxe.macro.Type]
									[EnumParameter:() -> haxe.macro.Type]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TLazy
										0
								[Block:String] [Const:String] "Lazy"
						[Case:String]
							[Const:Int] 8
							[Block:String]
								[Var `(31081):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(31082):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(31045):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:String]
									[Var t(31083):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(31081):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Block:String]
										[Field:String]
											[Call:haxe.macro.AbstractType]
												[Field:() -> haxe.macro.AbstractType]
													[Local t(31083):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
													[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
											[FAnon:String] name:String

	@:value("ModernTuple")
	static inline var MODERN_TUPLE:String = [Const:String] "ModernTuple";

	@:value("SimpleModule")
	static inline var SIMPLE_MODULE:String = [Const:String] "SimpleModule";

	@:value("TraditionalMap")
	static inline var TRADITIONAL_MAP:String = [Const:String] "TraditionalMap";
}