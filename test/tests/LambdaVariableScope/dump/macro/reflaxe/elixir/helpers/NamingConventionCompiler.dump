@:nullSafety(Off)
class reflaxe.elixir.helpers.NamingConventionCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(33170):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.NamingConventionCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(33170):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function toElixirName[Function:(haxeName : String) -> String]
		[Arg:String] [Local haxeName(22115):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local haxeName(22115):String:String]

	public function convertPackageToDirectoryPath[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(33171):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var packageParts(33172):Array<String>]
				[Field:Array<String>]
					[Local classType(33171):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:Array<String>] pack:Array<String>
			[Var className(33173):String]
				[Field:String]
					[Local classType(33171):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var snakeClassName(33174):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local className(33173):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local packageParts(33172):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local snakeClassName(33174):String:String]
			[Var snakePackageParts(33184):Array<String>]
				[Block:Array<String>]
					[Var `(33179):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(33180):Int] [Const:Int] 0
						[Var `(33181):Array<String>] [Local packageParts(33172):Array<String>:Array<String>]
						[While:Void]
							[Binop:Bool]
								[Local `(33180):Int:Int]
								<
								[Field:Int]
									[Local `(33181):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var v(33182):String]
									[Array:String]
										[Local `(33181):Array<String>:Array<String>]
										[Local `(33180):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(33180):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(33179):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(part : String) -> String]
											[Arg:String] [Local part(33183):String]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:String]
														[Field:(camelCase : String) -> String]
															[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
															[FStatic:(camelCase : String) -> String]
																reflaxe.elixir.helpers.NamingHelper
																toSnakeCase:(camelCase : String) -> String
														[Local part(33183):String:String]
										[Local v(33182):String:String]
					[Local `(33179):Array<String>:Array<String>]
			[Return:Dynamic]
				[Call:String]
					[Field:(paths : Array<String>) -> String]
						[TypeExpr haxe.io.Path:Class<haxe.io.Path>]
						[FStatic:(paths : Array<String>) -> String]
							haxe.io.Path
							join:(paths : Array<String>) -> String
					[Call:Array<String>]
						[Field:(a : Array<String>) -> Array<String>]
							[Local snakePackageParts(33184):Array<String>:Array<String>]
							[FInstance:(a : Array<String>) -> Array<String>]
								Array<String>
								concat:(a : Array<Array.T>) -> Array<Array.T>
						[ArrayDecl:Array<String>] [Local snakeClassName(33174):String:String]

	public function setFrameworkAwareOutputPath[Function:(classType : haxe.macro.ClassType) -> Void]
		[Arg:haxe.macro.ClassType] [Local classType(33185):haxe.macro.ClassType]
		[Block:Void]
			[Var annotationInfo(33186):reflaxe.elixir.helpers.AnnotationInfo]
				[Call:reflaxe.elixir.helpers.AnnotationInfo]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
							reflaxe.elixir.helpers.AnnotationSystem
							detectAnnotations:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo
					[Local classType(33185):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Binop:Bool]
					[Field:Null<String>]
						[Local annotationInfo(33186):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
						[FAnon:Null<String>] primaryAnnotation:Null<String>
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Var namingRule(33188):{ fileName : String, dirPath : String }]
						[Call:{ fileName : String, dirPath : String }]
							[Field:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
									reflaxe.elixir.helpers.NamingConventionCompiler
									getComprehensiveNamingRule:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }
							[Local classType(33185):haxe.macro.ClassType:haxe.macro.ClassType]
					[Call:Void]
						[Field:(name : Null<String>) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.NamingConventionCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(name : Null<String>) -> Void]
								reflaxe.BaseCompiler
								setOutputFileName:(name : Null<String>) -> Void
						[Field:String]
							[Local namingRule(33188):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
							[FAnon:String] fileName:String
					[Var safeDir(33189):String]
						[If:String]
							[Binop:Bool]
								[Binop:Bool]
									[Field:String]
										[Local namingRule(33188):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
										[FAnon:String] dirPath:String
									!=
									[Const:String] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Field:String]
											[Local namingRule(33188):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
											[FAnon:String] dirPath:String
										[FInstance:Int]
											String
											length:Int
									>
									[Const:Int] 0
							[Then:String] [Block:String]
								[Field:String]
									[Local namingRule(33188):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
									[FAnon:String] dirPath:String
							[Else:String] [Block:String] [Const:String] "."
					[Call:Void]
						[Field:(dir : Null<String>) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.NamingConventionCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(dir : Null<String>) -> Void]
								reflaxe.BaseCompiler
								setOutputFileDir:(dir : Null<String>) -> Void
						[Local safeDir(33189):String:String]
				[Else:Void] [Block:Void]
					[Call:Void]
						[Field:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
							[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
							[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
								reflaxe.elixir.helpers.NamingConventionCompiler
								setUniversalOutputPath:(moduleName : String, ?pack : Null<Array<String>>) -> Void
						[Field:String]
							[Local classType(33185):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:String] name:String
						[Field:Array<String>]
							[Local classType(33185):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:Array<String>] pack:Array<String>

	@:value({ pack : null })
	public function getUniversalNamingRule[Function:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
		[Arg:String] [Local moduleName(33192):String]
		[Arg:Null<Array<String>>]
			[Local pack(33193):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingHelper
							getUniversalNamingRule:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }
					[Local moduleName(33192):String:String]
					[Local pack(33193):Null<Array<String>>:Null<Array<String>>]

	@:value({ pack : null })
	public function setUniversalOutputPath[Function:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
		[Arg:String] [Local moduleName(33190):String]
		[Arg:Null<Array<String>>]
			[Local pack(33191):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Void]
			[Var namingRule(33194):{ fileName : String, dirPath : String }]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingConventionCompiler
							getUniversalNamingRule:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }
					[Local moduleName(33190):String:String]
					[Local pack(33191):Null<Array<String>>:Null<Array<String>>]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "Universal naming: "
									+
									[Local moduleName(33190):String:String]
								+
								[Const:String] " â†’ file: "
							+
							[Field:String]
								[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
								[FAnon:String] fileName:String
						+
						[Const:String] ", dir: "
					+
					[Field:String]
						[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
						[FAnon:String] dirPath:String
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/NamingConventionCompiler.hx"
					lineNumber: [Const:Int] 71
					className: [Const:String] "reflaxe.elixir.helpers.NamingConventionCompiler"
					methodName: [Const:String] "setUniversalOutputPath"
			[Call:Void]
				[Field:(name : Null<String>) -> Void]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.NamingConventionCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:(name : Null<String>) -> Void]
						reflaxe.BaseCompiler
						setOutputFileName:(name : Null<String>) -> Void
				[Field:String]
					[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
					[FAnon:String] fileName:String
			[Var safeDir(33195):String]
				[If:String]
					[Binop:Bool]
						[Binop:Bool]
							[Field:String]
								[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
								[FAnon:String] dirPath:String
							!=
							[Const:String] null
						&&
						[Binop:Bool]
							[Field:Int]
								[Field:String]
									[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
									[FAnon:String] dirPath:String
								[FInstance:Int]
									String
									length:Int
							>
							[Const:Int] 0
					[Then:String] [Block:String]
						[Field:String]
							[Local namingRule(33194):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
							[FAnon:String] dirPath:String
					[Else:String] [Block:String] [Const:String] "."
			[Call:Void]
				[Field:(dir : Null<String>) -> Void]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.NamingConventionCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:(dir : Null<String>) -> Void]
						reflaxe.BaseCompiler
						setOutputFileDir:(dir : Null<String>) -> Void
				[Local safeDir(33195):String:String]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Binop:String]
					[Const:String] "DEBUG: setUniversalOutputPath completed successfully for "
					+
					[Local moduleName(33190):String:String]
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/NamingConventionCompiler.hx"
					lineNumber: [Const:Int] 79
					className: [Const:String] "reflaxe.elixir.helpers.NamingConventionCompiler"
					methodName: [Const:String] "setUniversalOutputPath"

	public function getComprehensiveNamingRule[Function:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
		[Arg:haxe.macro.ClassType] [Local classType(33187):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
						[TypeExpr reflaxe.elixir.helpers.PhoenixPathGenerator:Class<reflaxe.elixir.helpers.PhoenixPathGenerator>]
						[FStatic:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.PhoenixPathGenerator
							getComprehensiveNamingRule:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }
					[Local classType(33187):haxe.macro.ClassType:haxe.macro.ClassType]
}