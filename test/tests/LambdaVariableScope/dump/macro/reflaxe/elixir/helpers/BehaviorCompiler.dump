class reflaxe.elixir.helpers.BehaviorCompiler {

	public static function isBehaviorClassType[Function:(classType : haxe.macro.ClassType) -> Bool]
		[Arg:haxe.macro.ClassType] [Local classType(15400):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classType(15400):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":behaviour"

	public static function usesBehavior[Function:(classType : haxe.macro.ClassType) -> Bool]
		[Arg:haxe.macro.ClassType] [Local classType(25236):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classType(25236):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":use"

	public static function compileBehavior[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15404):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var className(15405):String]
				[Field:String]
					[Local classType(15404):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var fields(15406):Array<haxe.macro.ClassField>]
				[Call:Array<haxe.macro.ClassField>]
					[Field:() -> Array<haxe.macro.ClassField>]
						[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
							[Local classType(15404):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
						[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
			[Var output(15407):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local className(15405):String:String]
					+
					[Const:String] " do\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  @moduledoc \"\"\"\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  Behavior module defining callback specifications.\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  Generated from Haxe @:behaviour class.\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  \"\"\"\n\n"
			[Var optionalCallbacks(15408):Array<String>] [ArrayDecl:Array<String>]
			[Var requiredCallbacks(15409):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(15480):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(15480):Int:Int]
						<
						[Field:Int]
							[Local fields(15406):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
							[FInstance:Int]
								Array<haxe.macro.ClassField>
								length:Int
					[Block:Void]
						[Var field(15410):haxe.macro.ClassField]
							[Array:haxe.macro.ClassField]
								[Local fields(15406):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
								[Local `(15480):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15480):Int:Int]
						[If:Void]
							[Block:Bool]
								[Var `(15413):haxe.macro.FieldKind]
									[Field:haxe.macro.FieldKind]
										[Local field(15410):haxe.macro.ClassField:haxe.macro.ClassField]
										[FAnon:haxe.macro.FieldKind] kind:haxe.macro.FieldKind
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(15413):haxe.macro.FieldKind:haxe.macro.FieldKind]
										==
										[Const:Int] 1
									[Then:Bool] [Block:Bool]
										[Var `(15414):haxe.macro.MethodKind]
											[EnumParameter:haxe.macro.MethodKind]
												[Local `(15413):haxe.macro.FieldKind:haxe.macro.FieldKind]
												FMethod
												0
										[Const:Bool] true
									[Else:Bool] [Const:Bool] false
							[Then:Void] [Block:Void]
								[Var functionName(15415):String]
									[Call:String]
										[Field:(camelCase : String) -> String]
											[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
											[FStatic:(camelCase : String) -> String]
												reflaxe.elixir.helpers.NamingHelper
												toSnakeCase:(camelCase : String) -> String
										[Field:String]
											[Local field(15410):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:String] name:String
								[Var signature(15466):String]
									[Call:String]
										[Field:(field : haxe.macro.ClassField) -> String]
											[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
											[FStatic:(field : haxe.macro.ClassField) -> String]
												reflaxe.elixir.helpers.BehaviorCompiler
												generateCallbackSignature:(field : haxe.macro.ClassField) -> String
										[Local field(15410):haxe.macro.ClassField:haxe.macro.ClassField]
								[Var arity(15478):Int]
									[Call:Int]
										[Field:(field : haxe.macro.ClassField) -> Int]
											[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
											[FStatic:(field : haxe.macro.ClassField) -> Int]
												reflaxe.elixir.helpers.BehaviorCompiler
												getCallbackArity:(field : haxe.macro.ClassField) -> Int
										[Local field(15410):haxe.macro.ClassField:haxe.macro.ClassField]
								[Var isOptional(15479):Bool]
									[Call:Bool]
										[Field:(name : String) -> Bool]
											[Field:haxe.macro.MetaAccess]
												[Local field(15410):haxe.macro.ClassField:haxe.macro.ClassField]
												[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
											[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
										[Const:String] ":optional_callback"
								[If:Void]
									[Local isOptional(15479):Bool:Bool]
									[Then:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local optionalCallbacks(15408):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local functionName(15415):String:String]
													+
													[Const:String] ": "
												+
												[Local arity(15478):Int:Int]
									[Else:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local requiredCallbacks(15409):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local functionName(15415):String:String]
													+
													[Const:String] ": "
												+
												[Local arity(15478):Int:Int]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local output(15407):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "  @callback "
												+
												[Local functionName(15415):String:String]
											+
											[Local signature(15466):String:String]
										+
										[Const:String] "\n"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local optionalCallbacks(15408):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(15407):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "\n  @optional_callbacks ["
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local optionalCallbacks(15408):Array<String>:Array<String>]
										[FInstance:(sep : String) -> String]
											Array<String>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] "]\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(15407):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "\nend\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(15407):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	public static function validateBehaviorUsage[Function:(classType : haxe.macro.ClassType) -> Array<String>]
		[Arg:haxe.macro.ClassType] [Local classType(25237):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var errors(25238):Array<String>] [ArrayDecl:Array<String>]
			[Var behaviorNames(25252):Array<String>]
				[Call:Array<String>]
					[Field:(classType : haxe.macro.ClassType) -> Array<String>]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> Array<String>]
							reflaxe.elixir.helpers.BehaviorCompiler
							extractBehaviorNames:(classType : haxe.macro.ClassType) -> Array<String>
					[Local classType(25237):haxe.macro.ClassType:haxe.macro.ClassType]
			[Block:Void]
				[Var `(25279):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25279):Int:Int]
						<
						[Field:Int]
							[Local behaviorNames(25252):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var behaviorName(25253):String]
							[Array:String]
								[Local behaviorNames(25252):Array<String>:Array<String>]
								[Local `(25279):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25279):Int:Int]
						[Var missingCallbacks(25278):Array<String>]
							[Call:Array<String>]
								[Field:(implClass : haxe.macro.ClassType, behaviorName : String) -> Array<String>]
									[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
									[FStatic:(implClass : haxe.macro.ClassType, behaviorName : String) -> Array<String>]
										reflaxe.elixir.helpers.BehaviorCompiler
										validateImplementation:(implClass : haxe.macro.ClassType, behaviorName : String) -> Array<String>
								[Local classType(25237):haxe.macro.ClassType:haxe.macro.ClassType]
								[Local behaviorName(25253):String:String]
						[Binop:Array<String>]
							[Local errors(25238):Array<String>:Array<String>]
							=
							[Call:Array<String>]
								[Field:(a : Array<String>) -> Array<String>]
									[Local errors(25238):Array<String>:Array<String>]
									[FInstance:(a : Array<String>) -> Array<String>]
										Array<String>
										concat:(a : Array<Array.T>) -> Array<Array.T>
								[Local missingCallbacks(25278):Array<String>:Array<String>]
			[Return:Dynamic] [Local errors(25238):Array<String>:Array<String>]

	public static function generateBehaviorDirective[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25280):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var behaviorNames(25281):Array<String>]
				[Call:Array<String>]
					[Field:(classType : haxe.macro.ClassType) -> Array<String>]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> Array<String>]
							reflaxe.elixir.helpers.BehaviorCompiler
							extractBehaviorNames:(classType : haxe.macro.ClassType) -> Array<String>
					[Local classType(25280):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local behaviorNames(25281):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Var output(25282):StringBuf] [New:StringBuf] StringBuf
			[Block:Void]
				[Var `(25284):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25284):Int:Int]
						<
						[Field:Int]
							[Local behaviorNames(25281):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var behaviorName(25283):String]
							[Array:String]
								[Local behaviorNames(25281):Array<String>:Array<String>]
								[Local `(25284):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25284):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local output(25282):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "  @behaviour "
									+
									[Local behaviorName(25283):String:String]
								+
								[Const:String] "\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(25282):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	public static function validateImplementation[Function:(implClass : haxe.macro.ClassType, behaviorName : String) -> Array<String>]
		[Arg:haxe.macro.ClassType] [Local implClass(25254):haxe.macro.ClassType]
		[Arg:String] [Local behaviorName(25255):String]
		[Block:Dynamic]
			[Var errors(25256):Array<String>] [ArrayDecl:Array<String>]
			[Var implMethods(25273):Array<haxe.macro.ClassField>]
				[Call:Array<haxe.macro.ClassField>]
					[Field:(classType : haxe.macro.ClassType) -> Array<haxe.macro.ClassField>]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> Array<haxe.macro.ClassField>]
							reflaxe.elixir.helpers.BehaviorCompiler
							getImplementationMethods:(classType : haxe.macro.ClassType) -> Array<haxe.macro.ClassField>
					[Local implClass(25254):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var methodNames(25277):Array<String>]
				[Block:Array<String>]
					[Var `(25274):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(25276):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(25276):Int:Int]
								<
								[Field:Int]
									[Local implMethods(25273):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
									[FInstance:Int]
										Array<haxe.macro.ClassField>
										length:Int
							[Block:Void]
								[Var method(25275):haxe.macro.ClassField]
									[Array:haxe.macro.ClassField]
										[Local implMethods(25273):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
										[Local `(25276):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25276):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(25274):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Field:String]
										[Local method(25275):haxe.macro.ClassField:haxe.macro.ClassField]
										[FAnon:String] name:String
					[Local `(25274):Array<String>:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Local behaviorName(25255):String:String]
					==
					[Const:String] "StateMachineBehavior"
				[Then:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
									[Local methodNames(25277):Array<String>:Array<String>]
									[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
										Array<String>
										indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
								[Const:String] "transition"
								[Const:Null<Int>] null
							==
							[Const:Int] -1
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local errors(25256):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Missing required callback: transition/3"
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
									[Local methodNames(25277):Array<String>:Array<String>]
									[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
										Array<String>
										indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
								[Const:String] "get_valid_states"
								[Const:Null<Int>] null
							==
							[Const:Int] -1
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local errors(25256):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Missing required callback: get_valid_states/0"
			[If:Void]
				[Binop:Bool]
					[Local behaviorName(25255):String:String]
					==
					[Const:String] "WorkerBehavior"
				[Then:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
									[Local methodNames(25277):Array<String>:Array<String>]
									[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
										Array<String>
										indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
								[Const:String] "start_work"
								[Const:Null<Int>] null
							==
							[Const:Int] -1
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local errors(25256):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Missing required callback: start_work/1"
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
									[Local methodNames(25277):Array<String>:Array<String>]
									[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
										Array<String>
										indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
								[Const:String] "stop_work"
								[Const:Null<Int>] null
							==
							[Const:Int] -1
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local errors(25256):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Missing required callback: stop_work/0"
			[Return:Dynamic] [Local errors(25256):Array<String>:Array<String>]

	public static function integrateBehaviorWithOTP[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25285):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var behaviorDirectives(25286):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.BehaviorCompiler
							generateBehaviorDirective:(classType : haxe.macro.ClassType) -> String
					[Local classType(25285):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var validationErrors(25287):Array<String>]
				[Call:Array<String>]
					[Field:(classType : haxe.macro.ClassType) -> Array<String>]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> Array<String>]
							reflaxe.elixir.helpers.BehaviorCompiler
							validateBehaviorUsage:(classType : haxe.macro.ClassType) -> Array<String>
					[Local classType(25285):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local validationErrors(25287):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(25289):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(25289):Int:Int]
								<
								[Field:Int]
									[Local validationErrors(25287):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var error(25288):String]
									[Array:String]
										[Local validationErrors(25287):Array<String>:Array<String>]
										[Local `(25289):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25289):Int:Int]
								[Call:Void]
									[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
										[TypeExpr haxe.Log:Class<haxe.Log>]
										[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
											haxe.Log
											trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
									[Binop:String]
										[Const:String] "ERROR: "
										+
										[Local error(25288):String:String]
									[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
										fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/BehaviorCompiler.hx"
										lineNumber: [Const:Int] 180
										className: [Const:String] "reflaxe.elixir.helpers.BehaviorCompiler"
										methodName: [Const:String] "integrateBehaviorWithOTP"
			[Return:Dynamic] [Local behaviorDirectives(25286):String:String]

	public static function compileBehaviorExtension[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25290):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var output(25291):StringBuf] [New:StringBuf] StringBuf
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classType(25290):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":extends"
				[Then:Void] [Block:Void]
					[Var extendsData(25292):Array<haxe.macro.MetadataEntry>]
						[Call:Array<haxe.macro.MetadataEntry>]
							[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
								[Field:haxe.macro.MetaAccess]
									[Local classType(25290):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
								[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
							[Const:String] ":extends"
					[If:Void]
						[Binop:Bool]
							[Field:Int]
								[Local extendsData(25292):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
								[FInstance:Int]
									Array<haxe.macro.MetadataEntry>
									length:Int
							>
							[Const:Int] 0
						[Then:Void] [Block:Void]
							[Var parentBehavior(25293):String] [Const:String] "BaseBehavior"
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local output(25291):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Binop:String]
									[Binop:String]
										[Const:String] "  # Extends "
										+
										[Local parentBehavior(25293):String:String]
									+
									[Const:String] " behavior\n"
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local output(25291):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Binop:String]
									[Binop:String]
										[Const:String] "  @behaviour "
										+
										[Local parentBehavior(25293):String:String]
									+
									[Const:String] "\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(25291):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function generateCallbackSignature[Function:(field : haxe.macro.ClassField) -> String]
		[Arg:haxe.macro.ClassField] [Local field(15416):haxe.macro.ClassField]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (field.type) {
	case TFun(args, ret):
		var argSpecs = args.map(function(arg) ->  @:implicitReturn return mapHaxeTypeToElixirSpec(arg.t)).join(", ");
		var retSpec = mapHaxeTypeToElixirSpec(ret);
		"(${argSpecs}) :: ${retSpec}";	
	default:
		"() :: any()";	
})
					[Block:String]
						[Var `(15454):haxe.macro.Type]
							[Field:haxe.macro.Type]
								[Local field(15416):haxe.macro.ClassField:haxe.macro.ClassField]
								[FAnon:haxe.macro.Type] type:haxe.macro.Type
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(15454):haxe.macro.Type:haxe.macro.Type]
								==
								[Const:Int] 4
							[Then:String] [Block:String]
								[Var `(15455):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
										[Local `(15454):haxe.macro.Type:haxe.macro.Type]
										TFun
										0
								[Var `(15456):haxe.macro.Type]
									[EnumParameter:haxe.macro.Type]
										[Local `(15454):haxe.macro.Type:haxe.macro.Type]
										TFun
										1
								[Block:String]
									[Var args(15457):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(15455):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[Var ret(15458):haxe.macro.Type] [Local `(15456):haxe.macro.Type:haxe.macro.Type]
									[Block:String]
										[Var argSpecs(15459):String]
											[Call:String]
												[Field:(sep : String) -> String]
													[Block:Array<String>]
														[Var `(15460):Array<String>] [ArrayDecl:Array<String>]
														[Block:Void]
															[Var `(15461):Int] [Const:Int] 0
															[Var `(15462):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local args(15457):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
															[While:Void]
																[Binop:Bool]
																	[Local `(15461):Int:Int]
																	<
																	[Field:Int]
																		[Local `(15462):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[FInstance:Int]
																			Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
																			length:Int
																[Block:Void]
																	[Var v(15463):{ t : haxe.macro.Type, opt : Bool, name : String }]
																		[Array:{ t : haxe.macro.Type, opt : Bool, name : String }]
																			[Local `(15462):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																			[Local `(15461):Int:Int]
																	[Unop:Int]
																		++
																		Prefix
																		[Local `(15461):Int:Int]
																	[Call:Int]
																		[Field:(x : String) -> Int]
																			[Local `(15460):Array<String>:Array<String>]
																			[FInstance:(x : String) -> Int]
																				Array<String>
																				push:(x : Array.T) -> Int
																		[Call:String]
																			[Function:(arg : { t : haxe.macro.Type, opt : Bool, name : String }) -> String]
																				[Arg:{ t : haxe.macro.Type, opt : Bool, name : String }] [Local arg(15464):{ t : haxe.macro.Type, opt : Bool, name : String }]
																				[Block:Dynamic]
																					[Return:Dynamic]
																						[Call:String]
																							[Field:(type : haxe.macro.Type) -> String]
																								[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
																								[FStatic:(type : haxe.macro.Type) -> String]
																									reflaxe.elixir.helpers.BehaviorCompiler
																									mapHaxeTypeToElixirSpec:(type : haxe.macro.Type) -> String
																							[Field:haxe.macro.Type]
																								[Local arg(15464):{ t : haxe.macro.Type, opt : Bool, name : String }:{ t : haxe.macro.Type, opt : Bool, name : String }]
																								[FAnon:haxe.macro.Type] t:haxe.macro.Type
																			[Local v(15463):{ t : haxe.macro.Type, opt : Bool, name : String }:{ t : haxe.macro.Type, opt : Bool, name : String }]
														[Local `(15460):Array<String>:Array<String>]
													[FInstance:(sep : String) -> String]
														Array<String>
														join:(sep : String) -> String
												[Const:String] ", "
										[Var retSpec(15465):String]
											[Call:String]
												[Field:(type : haxe.macro.Type) -> String]
													[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
													[FStatic:(type : haxe.macro.Type) -> String]
														reflaxe.elixir.helpers.BehaviorCompiler
														mapHaxeTypeToElixirSpec:(type : haxe.macro.Type) -> String
												[Local ret(15458):haxe.macro.Type:haxe.macro.Type]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "("
													+
													[Local argSpecs(15459):String:String]
												+
												[Const:String] ") :: "
											+
											[Local retSpec(15465):String:String]
							[Else:String] [Block:String] [Const:String] "() :: any()"

	static function getCallbackArity[Function:(field : haxe.macro.ClassField) -> Int]
		[Arg:haxe.macro.ClassField] [Local field(15467):haxe.macro.ClassField]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Int]
					:ast(switch (field.type) {
	case TFun(args, ret):
		args.length;	
	default:
		0;	
})
					[Block:Int]
						[Var `(15473):haxe.macro.Type]
							[Field:haxe.macro.Type]
								[Local field(15467):haxe.macro.ClassField:haxe.macro.ClassField]
								[FAnon:haxe.macro.Type] type:haxe.macro.Type
						[If:Int]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(15473):haxe.macro.Type:haxe.macro.Type]
								==
								[Const:Int] 4
							[Then:Int] [Block:Int]
								[Var `(15474):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
										[Local `(15473):haxe.macro.Type:haxe.macro.Type]
										TFun
										0
								[Var `(15475):haxe.macro.Type]
									[EnumParameter:haxe.macro.Type]
										[Local `(15473):haxe.macro.Type:haxe.macro.Type]
										TFun
										1
								[Block:Int]
									[Var args(15476):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(15474):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[Var ret(15477):haxe.macro.Type] [Local `(15475):haxe.macro.Type:haxe.macro.Type]
									[Block:Int]
										[Field:Int]
											[Local args(15476):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
											[FInstance:Int]
												Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
												length:Int
							[Else:Int] [Block:Int] [Const:Int] 0

	static function mapHaxeTypeToElixirSpec[Function:(type : haxe.macro.Type) -> String]
		[Arg:haxe.macro.Type] [Local type(15420):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (type) {
	case TInst(_.get().name => "String", _):
		"String.t()";	
	case TAbstract(_.get().name => "Int", _):
		"integer()";	
	case TAbstract(_.get().name => "Float", _):
		"float()";	
	case TAbstract(_.get().name => "Bool", _):
		"boolean()";	
	case TDynamic(_):
		"any()";	
	case TInst(_.get().name => "Map", _):
		"map()";	
	case TInst(_.get().name => "Array", _):
		"list()";	
	default:
		"any()";	
})
					[Switch:String]
						[EnumIndex:Int] [Local type(15420):haxe.macro.Type:haxe.macro.Type]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(15434):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(15420):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(15435):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(15420):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:String]
									[Var _hx_tmp(15436):String]
									[Switch:String]
										[Parenthesis:String]
											[Binop:String]
												[Local _hx_tmp(15436):String:String]
												=
												[Field:String]
													[Call:haxe.macro.ClassType]
														[Field:() -> haxe.macro.ClassType]
															[Local `(15434):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
															[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
													[FAnon:String] name:String
										[Case:String]
											[Const:String] "Array"
											[Block:String] [Block:String] [Const:String] "list()"
										[Case:String]
											[Const:String] "Map"
											[Block:String] [Block:String] [Const:String] "map()"
										[Case:String]
											[Const:String] "String"
											[Block:String] [Block:String] [Const:String] "String.t()"
										[Default:String] [Block:String] [Const:String] "any()"
						[Case:String]
							[Const:Int] 6
							[Block:String]
								[Var `(15437):Null<haxe.macro.Type>]
									[EnumParameter:Null<haxe.macro.Type>]
										[Local type(15420):haxe.macro.Type:haxe.macro.Type]
										TDynamic
										0
								[Block:String] [Const:String] "any()"
						[Case:String]
							[Const:Int] 8
							[Block:String]
								[Var `(15438):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(15420):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(15439):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(15420):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:String]
									[Var _hx_tmp(15440):String]
									[Switch:String]
										[Parenthesis:String]
											[Binop:String]
												[Local _hx_tmp(15440):String:String]
												=
												[Field:String]
													[Call:haxe.macro.AbstractType]
														[Field:() -> haxe.macro.AbstractType]
															[Local `(15438):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
															[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
													[FAnon:String] name:String
										[Case:String]
											[Const:String] "Bool"
											[Block:String] [Block:String] [Const:String] "boolean()"
										[Case:String]
											[Const:String] "Float"
											[Block:String] [Block:String] [Const:String] "float()"
										[Case:String]
											[Const:String] "Int"
											[Block:String] [Block:String] [Const:String] "integer()"
										[Default:String] [Block:String] [Const:String] "any()"
						[Default:String] [Block:String] [Const:String] "any()"

	static function extractBehaviorNames[Function:(classType : haxe.macro.ClassType) -> Array<String>]
		[Arg:haxe.macro.ClassType] [Local classType(25239):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var behaviorNames(25240):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classType(25239):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":use"
				[Then:Void] [Block:Void]
					[Var useData(25241):Array<haxe.macro.MetadataEntry>]
						[Call:Array<haxe.macro.MetadataEntry>]
							[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
								[Field:haxe.macro.MetaAccess]
									[Local classType(25239):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
								[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
							[Const:String] ":use"
					[Block:Void]
						[Var `(25251):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(25251):Int:Int]
								<
								[Field:Int]
									[Local useData(25241):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
									[FInstance:Int]
										Array<haxe.macro.MetadataEntry>
										length:Int
							[Block:Void]
								[Var use(25242):haxe.macro.MetadataEntry]
									[Array:haxe.macro.MetadataEntry]
										[Local useData(25241):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
										[Local `(25251):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25251):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Binop:Bool]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Local use(25242):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											!=
											[Const:Null<Array<haxe.macro.Expr>>] null
										&&
										[Binop:Bool]
											[Field:Int]
												[Field:Null<Array<haxe.macro.Expr>>]
													[Local use(25242):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
													[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
												[FInstance:Int]
													Array<haxe.macro.Expr>
													length:Int
											>
											[Const:Int] 0
									[Then:Void] [Block:Void]
										[Meta:Void]
											:ast(switch (use.params[0].expr) {
	case EConst(CIdent(behaviorName)):
		behaviorNames.push(behaviorName);	
	default:
})
											[Block:Void]
												[Var `(25247):haxe.macro.ExprDef]
													[Field:haxe.macro.ExprDef]
														[Array:haxe.macro.Expr]
															[Field:Null<Array<haxe.macro.Expr>>]
																[Local use(25242):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
																[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
															[Const:Int] 0
														[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
												[If:Void]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(25247):haxe.macro.ExprDef:haxe.macro.ExprDef]
														==
														[Const:Int] 0
													[Then:Void] [Block:Void]
														[Var `(25248):haxe.macro.Constant]
															[EnumParameter:haxe.macro.Constant]
																[Local `(25247):haxe.macro.ExprDef:haxe.macro.ExprDef]
																EConst
																0
														[If:Void]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(25248):haxe.macro.Constant:haxe.macro.Constant]
																==
																[Const:Int] 3
															[Then:Int] [Block:Int]
																[Var `(25249):String]
																	[EnumParameter:String]
																		[Local `(25248):haxe.macro.Constant:haxe.macro.Constant]
																		CIdent
																		0
																[Block:Int]
																	[Var behaviorName(25250):String] [Local `(25249):String:String]
																	[Block:Int]
																		[Call:Int]
																			[Field:(x : String) -> Int]
																				[Local behaviorNames(25240):Array<String>:Array<String>]
																				[FInstance:(x : String) -> Int]
																					Array<String>
																					push:(x : Array.T) -> Int
																			[Local behaviorName(25250):String:String]
															[Else:Void] [Block:Void]
													[Else:Void] [Block:Void]
			[Return:Dynamic] [Local behaviorNames(25240):Array<String>:Array<String>]

	static function getImplementationMethods[Function:(classType : haxe.macro.ClassType) -> Array<haxe.macro.ClassField>]
		[Arg:haxe.macro.ClassType] [Local classType(25257):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Block:Array<haxe.macro.ClassField>]
					[Var _this(25264):Array<haxe.macro.ClassField>]
						[Call:Array<haxe.macro.ClassField>]
							[Field:() -> Array<haxe.macro.ClassField>]
								[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
									[Local classType(25257):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
								[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
					[Block:Array<haxe.macro.ClassField>]
						[Var `(25266):Array<haxe.macro.ClassField>] [ArrayDecl:Array<haxe.macro.ClassField>]
						[Block:Void]
							[Var `(25267):Int] [Const:Int] 0
							[Var `(25268):Array<haxe.macro.ClassField>] [Local _this(25264):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
							[While:Void]
								[Binop:Bool]
									[Local `(25267):Int:Int]
									<
									[Field:Int]
										[Local `(25268):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
										[FInstance:Int]
											Array<haxe.macro.ClassField>
											length:Int
								[Block:Void]
									[Var v(25269):haxe.macro.ClassField]
										[Array:haxe.macro.ClassField]
											[Local `(25268):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
											[Local `(25267):Int:Int]
									[Unop:Int]
										++
										Prefix
										[Local `(25267):Int:Int]
									[If:Void]
										[Call:Bool]
											[Function:(field : haxe.macro.ClassField) -> Bool]
												[Arg:haxe.macro.ClassField] [Local field(25270):haxe.macro.ClassField]
												[Block:Dynamic]
													[Return:Dynamic]
														[Block:Bool]
															[Var `(25271):haxe.macro.FieldKind]
																[Field:haxe.macro.FieldKind]
																	[Local field(25270):haxe.macro.ClassField:haxe.macro.ClassField]
																	[FAnon:haxe.macro.FieldKind] kind:haxe.macro.FieldKind
															[If:Bool]
																[Parenthesis:Bool]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(25271):haxe.macro.FieldKind:haxe.macro.FieldKind]
																		==
																		[Const:Int] 1
																[Then:Bool] [Block:Bool]
																	[Var `(25272):haxe.macro.MethodKind]
																		[EnumParameter:haxe.macro.MethodKind]
																			[Local `(25271):haxe.macro.FieldKind:haxe.macro.FieldKind]
																			FMethod
																			0
																	[Const:Bool] true
																[Else:Bool] [Const:Bool] false
											[Local v(25269):haxe.macro.ClassField:haxe.macro.ClassField]
										[Then:Int] [Block:Int]
											[Call:Int]
												[Field:(x : haxe.macro.ClassField) -> Int]
													[Local `(25266):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
													[FInstance:(x : haxe.macro.ClassField) -> Int]
														Array<haxe.macro.ClassField>
														push:(x : Array.T) -> Int
												[Local v(25269):haxe.macro.ClassField:haxe.macro.ClassField]
						[Local `(25266):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]

	public static function batchValidateBehaviors[Function:(classTypes : Array<haxe.macro.ClassType>) -> Map<String, Array<String>>]
		[Arg:Array<haxe.macro.ClassType>] [Local classTypes(25294):Array<haxe.macro.ClassType>]
		[Block:Dynamic]
			[Var startTime(25295):Float]
				[Call:Float]
					[Field:() -> Float]
						[TypeExpr Sys:Class<Sys>]
						[FStatic:() -> Float]
							Sys
							time:() -> Float
			[Var results(25296):haxe.ds.Map<String, Array<String>>]
				[Block:haxe.ds.StringMap<Array<String>>]
					[Block:Void]
					[New:haxe.ds.StringMap<Array<String>>] haxe.ds.StringMap<Array<String>>
			[Block:Void]
				[Var `(25304):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25304):Int:Int]
						<
						[Field:Int]
							[Local classTypes(25294):Array<haxe.macro.ClassType>:Array<haxe.macro.ClassType>]
							[FInstance:Int]
								Array<haxe.macro.ClassType>
								length:Int
					[Block:Void]
						[Var classType(25297):haxe.macro.ClassType]
							[Array:haxe.macro.ClassType]
								[Local classTypes(25294):Array<haxe.macro.ClassType>:Array<haxe.macro.ClassType>]
								[Local `(25304):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25304):Int:Int]
						[If:Void]
							[Call:Bool]
								[Field:(classType : haxe.macro.ClassType) -> Bool]
									[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
									[FStatic:(classType : haxe.macro.ClassType) -> Bool]
										reflaxe.elixir.helpers.BehaviorCompiler
										usesBehavior:(classType : haxe.macro.ClassType) -> Bool
								[Local classType(25297):haxe.macro.ClassType:haxe.macro.ClassType]
							[Then:Void] [Block:Void]
								[Var errors(25298):Array<String>]
									[Call:Array<String>]
										[Field:(classType : haxe.macro.ClassType) -> Array<String>]
											[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
											[FStatic:(classType : haxe.macro.ClassType) -> Array<String>]
												reflaxe.elixir.helpers.BehaviorCompiler
												validateBehaviorUsage:(classType : haxe.macro.ClassType) -> Array<String>
										[Local classType(25297):haxe.macro.ClassType:haxe.macro.ClassType]
								[Block:Void]
									[Var key(25302):String]
										[Field:String]
											[Local classType(25297):haxe.macro.ClassType:haxe.macro.ClassType]
											[FAnon:String] name:String
									[Call:Void]
										[Field:(key : String, value : Array<String>) -> Void]
											[Local results(25296):haxe.ds.Map<String, Array<String>>:haxe.ds.StringMap<Array<String>>]
											[FInstance:(key : String, value : Array<String>) -> Void]
												haxe.ds.StringMap<Array<String>>
												set:(key : String, value : haxe.ds.StringMap.T) -> Void
										[Local key(25302):String:String]
										[Local errors(25298):Array<String>:Array<String>]
			[Var totalTime(25305):Float]
				[Binop:Float]
					[Call:Float]
						[Field:() -> Float]
							[TypeExpr Sys:Class<Sys>]
							[FStatic:() -> Float]
								Sys
								time:() -> Float
					-
					[Local startTime(25295):Float:Float]
			[If:Void]
				[Binop:Bool]
					[Local totalTime(25305):Float:Float]
					>
					[Const:Float] 0.015
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "WARNING: Behavior validation took "
								+
								[Binop:Float]
									[Local totalTime(25305):Float:Float]
									*
									[Const:Int] 1000
							+
							[Const:String] "ms, exceeding 15ms target"
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/BehaviorCompiler.hx"
							lineNumber: [Const:Int] 281
							className: [Const:String] "reflaxe.elixir.helpers.BehaviorCompiler"
							methodName: [Const:String] "batchValidateBehaviors"
			[Return:Dynamic] [Local results(25296):haxe.ds.Map<String, Array<String>>:haxe.ds.Map<String, Array<String>>]
}