class reflaxe.elixir.helpers.AnnotationSystem {

	@:value(null)
	static var globalAppNameRegistry:Null<String> = [Const:Null<String>] null;

	@:value([":genserver", ":controller", ":router", ":endpoint", ":channel", ":behaviour", ":protocol", ":impl", ":repo", ":migration", ":template", ":component", ":schema", ":changeset", ":liveview", ":query", ":appName"])
	public static var SUPPORTED_ANNOTATIONS:Array<String> = [ArrayDecl:Array<String>]
		[Const:String] ":genserver"
		[Const:String] ":controller"
		[Const:String] ":router"
		[Const:String] ":endpoint"
		[Const:String] ":channel"
		[Const:String] ":behaviour"
		[Const:String] ":protocol"
		[Const:String] ":impl"
		[Const:String] ":repo"
		[Const:String] ":migration"
		[Const:String] ":template"
		[Const:String] ":component"
		[Const:String] ":schema"
		[Const:String] ":changeset"
		[Const:String] ":liveview"
		[Const:String] ":query"
		[Const:String] ":appName";

	@:value([[":genserver", ":liveview", ":channel"], [":schema", ":changeset"], [":migration", ":schema", ":changeset"]])
	public static var EXCLUSIVE_GROUPS:Array<Array<String>> = [ArrayDecl:Array<Array<String>>]
		[ArrayDecl:Array<String>]
			[Const:String] ":genserver"
			[Const:String] ":liveview"
			[Const:String] ":channel"
		[ArrayDecl:Array<String>]
			[Const:String] ":schema"
			[Const:String] ":changeset"
		[ArrayDecl:Array<String>]
			[Const:String] ":migration"
			[Const:String] ":schema"
			[Const:String] ":changeset";

	@:value([[":liveview", ":template"], [":schema", ":query"], [":changeset", ":query"], [":appName"]])
	public static var COMPATIBLE_COMBINATIONS:Array<Array<String>> = [ArrayDecl:Array<Array<String>>]
		[ArrayDecl:Array<String>]
			[Const:String] ":liveview"
			[Const:String] ":template"
		[ArrayDecl:Array<String>]
			[Const:String] ":schema"
			[Const:String] ":query"
		[ArrayDecl:Array<String>]
			[Const:String] ":changeset"
			[Const:String] ":query"
		[ArrayDecl:Array<String>] [Const:String] ":appName";

	public static function detectAnnotations[Function:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
		[Arg:haxe.macro.ClassType] [Local classType(15044):haxe.macro.ClassType]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local classType(15044):haxe.macro.ClassType:haxe.macro.ClassType]
					==
					[Const:haxe.macro.ClassType] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[ObjectDecl:{ primaryAnnotation : Null<String>, isSupported : Bool, hasConflicts : Bool, conflicts : Array<reflaxe.elixir.helpers.AnnotationConflict>, annotations : Array<String> }]
							annotations: [ArrayDecl:Array<String>]
							primaryAnnotation: [Const:Null<String>] null
							hasConflicts: [Const:Bool] false
							conflicts: [ArrayDecl:Array<reflaxe.elixir.helpers.AnnotationConflict>]
							isSupported: [Const:Bool] false
			[Var detectedAnnotations(15045):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(15047):Int] [Const:Int] 0
				[Var `(15048):Array<String>]
					[Field:Array<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							SUPPORTED_ANNOTATIONS:Array<String>
				[While:Void]
					[Binop:Bool]
						[Local `(15047):Int:Int]
						<
						[Field:Int]
							[Local `(15048):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var annotation(15046):String]
							[Array:String]
								[Local `(15048):Array<String>:Array<String>]
								[Local `(15047):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15047):Int:Int]
						[If:Void]
							[Call:Bool]
								[Field:(name : String) -> Bool]
									[Field:haxe.macro.MetaAccess]
										[Local classType(15044):haxe.macro.ClassType:haxe.macro.ClassType]
										[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
									[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
								[Local annotation(15046):String:String]
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local detectedAnnotations(15045):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Local annotation(15046):String:String]
			[Var conflicts(15067):Array<reflaxe.elixir.helpers.AnnotationConflict>]
				[Call:Array<reflaxe.elixir.helpers.AnnotationConflict>]
					[Field:(annotations : Array<String>) -> Array<reflaxe.elixir.helpers.AnnotationConflict>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(annotations : Array<String>) -> Array<reflaxe.elixir.helpers.AnnotationConflict>]
							reflaxe.elixir.helpers.AnnotationSystem
							validateAnnotations:(annotations : Array<String>) -> Array<reflaxe.elixir.helpers.AnnotationConflict>
					[Local detectedAnnotations(15045):Array<String>:Array<String>]
			[Var primaryAnnotation(15072):Null<String>]
				[Call:Null<String>]
					[Field:(annotations : Array<String>) -> Null<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(annotations : Array<String>) -> Null<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							determinePrimaryAnnotation:(annotations : Array<String>) -> Null<String>
					[Local detectedAnnotations(15045):Array<String>:Array<String>]
			[Return:Dynamic]
				[ObjectDecl:{ primaryAnnotation : Null<String>, isSupported : Bool, hasConflicts : Bool, conflicts : Array<reflaxe.elixir.helpers.AnnotationConflict>, annotations : Array<String> }]
					annotations: [Local detectedAnnotations(15045):Array<String>:Array<String>]
					primaryAnnotation: [Local primaryAnnotation(15072):Null<String>:Null<String>]
					hasConflicts: [Binop:Bool]
						[Field:Int]
							[Local conflicts(15067):Array<reflaxe.elixir.helpers.AnnotationConflict>:Array<reflaxe.elixir.helpers.AnnotationConflict>]
							[FInstance:Int]
								Array<reflaxe.elixir.helpers.AnnotationConflict>
								length:Int
						>
						[Const:Int] 0
					conflicts: [Local conflicts(15067):Array<reflaxe.elixir.helpers.AnnotationConflict>:Array<reflaxe.elixir.helpers.AnnotationConflict>]
					isSupported: [Binop:Bool]
						[Field:Int]
							[Local detectedAnnotations(15045):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
						>
						[Const:Int] 0

	static function validateAnnotations[Function:(annotations : Array<String>) -> Array<reflaxe.elixir.helpers.AnnotationConflict>]
		[Arg:Array<String>] [Local annotations(15049):Array<String>]
		[Block:Dynamic]
			[Var conflicts(15050):Array<{ type : String, message : String, conflicting : Array<String> }>] [ArrayDecl:Array<{ type : String, message : String, conflicting : Array<String> }>]
			[Block:Void]
				[Var `(15055):Int] [Const:Int] 0
				[Var `(15056):Array<Array<String>>]
					[Field:Array<Array<String>>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<Array<String>>]
							reflaxe.elixir.helpers.AnnotationSystem
							EXCLUSIVE_GROUPS:Array<Array<String>>
				[While:Void]
					[Binop:Bool]
						[Local `(15055):Int:Int]
						<
						[Field:Int]
							[Local `(15056):Array<Array<String>>:Array<Array<String>>]
							[FInstance:Int]
								Array<Array<String>>
								length:Int
					[Block:Void]
						[Var group(15051):Array<String>]
							[Array:Array<String>]
								[Local `(15056):Array<Array<String>>:Array<Array<String>>]
								[Local `(15055):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15055):Int:Int]
						[Var foundInGroup(15052):Array<String>] [ArrayDecl:Array<String>]
						[Block:Void]
							[Var `(15054):Int] [Const:Int] 0
							[While:Void]
								[Binop:Bool]
									[Local `(15054):Int:Int]
									<
									[Field:Int]
										[Local annotations(15049):Array<String>:Array<String>]
										[FInstance:Int]
											Array<String>
											length:Int
								[Block:Void]
									[Var annotation(15053):String]
										[Array:String]
											[Local annotations(15049):Array<String>:Array<String>]
											[Local `(15054):Int:Int]
									[Unop:Int]
										++
										Prefix
										[Local `(15054):Int:Int]
									[If:Void]
										[Call:Bool]
											[Field:(x : String) -> Bool]
												[Local group(15051):Array<String>:Array<String>]
												[FInstance:(x : String) -> Bool]
													Array<String>
													contains:(x : Array.T) -> Bool
											[Local annotation(15053):String:String]
										[Then:Int] [Block:Int]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local foundInGroup(15052):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Local annotation(15053):String:String]
						[If:Void]
							[Binop:Bool]
								[Field:Int]
									[Local foundInGroup(15052):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 1
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : { type : String, message : String, conflicting : Array<String> }) -> Int]
										[Local conflicts(15050):Array<{ type : String, message : String, conflicting : Array<String> }>:Array<{ type : String, message : String, conflicting : Array<String> }>]
										[FInstance:(x : { type : String, message : String, conflicting : Array<String> }) -> Int]
											Array<{ type : String, message : String, conflicting : Array<String> }>
											push:(x : Array.T) -> Int
									[ObjectDecl:{ type : String, message : String, conflicting : Array<String> }]
										type: [Const:String] "exclusive_group"
										conflicting: [Local foundInGroup(15052):Array<String>:Array<String>]
										message: [Binop:String]
											[Binop:String]
												[Const:String] "Annotations "
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local foundInGroup(15052):Array<String>:Array<String>]
														[FInstance:(sep : String) -> String]
															Array<String>
															join:(sep : String) -> String
													[Const:String] ", "
											+
											[Const:String] " cannot be used together - they are mutually exclusive"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local annotations(15049):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 1
				[Then:Void] [Block:Void]
					[Var hasValidCombination(15057):Bool] [Const:Bool] false
					[If:Void]
						[Call:Bool]
							[Field:(x : String) -> Bool]
								[Local annotations(15049):Array<String>:Array<String>]
								[FInstance:(x : String) -> Bool]
									Array<String>
									contains:(x : Array.T) -> Bool
							[Const:String] ":appName"
						[Then:Bool] [Block:Bool]
							[Binop:Bool]
								[Local hasValidCombination(15057):Bool:Bool]
								=
								[Const:Bool] true
						[Else:Void] [Block:Void]
							[Block:Void]
								[Var `(15062):Int] [Const:Int] 0
								[Var `(15063):Array<Array<String>>]
									[Field:Array<Array<String>>]
										[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
										[FStatic:Array<Array<String>>]
											reflaxe.elixir.helpers.AnnotationSystem
											COMPATIBLE_COMBINATIONS:Array<Array<String>>
								[While:Void]
									[Binop:Bool]
										[Local `(15062):Int:Int]
										<
										[Field:Int]
											[Local `(15063):Array<Array<String>>:Array<Array<String>>]
											[FInstance:Int]
												Array<Array<String>>
												length:Int
									[Block:Void]
										[Var combination(15058):Array<String>]
											[Array:Array<String>]
												[Local `(15063):Array<Array<String>>:Array<Array<String>>]
												[Local `(15062):Int:Int]
										[Unop:Int]
											++
											Prefix
											[Local `(15062):Int:Int]
										[Var matchesAll(15059):Bool] [Const:Bool] true
										[Block:Void]
											[Var `(15061):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(15061):Int:Int]
													<
													[Field:Int]
														[Local annotations(15049):Array<String>:Array<String>]
														[FInstance:Int]
															Array<String>
															length:Int
												[Block:Void]
													[Var annotation(15060):String]
														[Array:String]
															[Local annotations(15049):Array<String>:Array<String>]
															[Local `(15061):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(15061):Int:Int]
													[If:Void]
														[Unop:Bool]
															!
															Prefix
															[Call:Bool]
																[Field:(x : String) -> Bool]
																	[Local combination(15058):Array<String>:Array<String>]
																	[FInstance:(x : String) -> Bool]
																		Array<String>
																		contains:(x : Array.T) -> Bool
																[Local annotation(15060):String:String]
														[Then:Dynamic] [Block:Dynamic]
															[Binop:Bool]
																[Local matchesAll(15059):Bool:Bool]
																=
																[Const:Bool] false
															[Break:Dynamic]
										[If:Void]
											[Local matchesAll(15059):Bool:Bool]
											[Then:Dynamic] [Block:Dynamic]
												[Binop:Bool]
													[Local hasValidCombination(15057):Bool:Bool]
													=
													[Const:Bool] true
												[Break:Dynamic]
							[If:Void]
								[Binop:Bool]
									[Unop:Bool]
										!
										Prefix
										[Local hasValidCombination(15057):Bool:Bool]
									&&
									[Binop:Bool]
										[Field:Int]
											[Local annotations(15049):Array<String>:Array<String>]
											[FInstance:Int]
												Array<String>
												length:Int
										==
										[Const:Int] 2
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var `(15065):Int] [Const:Int] 0
										[Var `(15066):Array<Array<String>>]
											[Field:Array<Array<String>>]
												[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
												[FStatic:Array<Array<String>>]
													reflaxe.elixir.helpers.AnnotationSystem
													COMPATIBLE_COMBINATIONS:Array<Array<String>>
										[While:Void]
											[Binop:Bool]
												[Local `(15065):Int:Int]
												<
												[Field:Int]
													[Local `(15066):Array<Array<String>>:Array<Array<String>>]
													[FInstance:Int]
														Array<Array<String>>
														length:Int
											[Block:Void]
												[Var combination(15064):Array<String>]
													[Array:Array<String>]
														[Local `(15066):Array<Array<String>>:Array<Array<String>>]
														[Local `(15065):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(15065):Int:Int]
												[If:Void]
													[Binop:Bool]
														[Call:Bool]
															[Field:(x : String) -> Bool]
																[Local combination(15064):Array<String>:Array<String>]
																[FInstance:(x : String) -> Bool]
																	Array<String>
																	contains:(x : Array.T) -> Bool
															[Array:String]
																[Local annotations(15049):Array<String>:Array<String>]
																[Const:Int] 0
														&&
														[Call:Bool]
															[Field:(x : String) -> Bool]
																[Local combination(15064):Array<String>:Array<String>]
																[FInstance:(x : String) -> Bool]
																	Array<String>
																	contains:(x : Array.T) -> Bool
															[Array:String]
																[Local annotations(15049):Array<String>:Array<String>]
																[Const:Int] 1
													[Then:Dynamic] [Block:Dynamic]
														[Binop:Bool]
															[Local hasValidCombination(15057):Bool:Bool]
															=
															[Const:Bool] true
														[Break:Dynamic]
					[If:Void]
						[Unop:Bool]
							!
							Prefix
							[Local hasValidCombination(15057):Bool:Bool]
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : { type : String, message : String, conflicting : Array<String> }) -> Int]
									[Local conflicts(15050):Array<{ type : String, message : String, conflicting : Array<String> }>:Array<{ type : String, message : String, conflicting : Array<String> }>]
									[FInstance:(x : { type : String, message : String, conflicting : Array<String> }) -> Int]
										Array<{ type : String, message : String, conflicting : Array<String> }>
										push:(x : Array.T) -> Int
								[ObjectDecl:{ type : String, message : String, conflicting : Array<String> }]
									type: [Const:String] "unsupported_combination"
									conflicting: [Local annotations(15049):Array<String>:Array<String>]
									message: [Binop:String]
										[Binop:String]
											[Const:String] "Annotation combination "
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local annotations(15049):Array<String>:Array<String>]
													[FInstance:(sep : String) -> String]
														Array<String>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] " is not supported"
			[Return:Dynamic] [Local conflicts(15050):Array<{ type : String, message : String, conflicting : Array<String> }>:Array<{ type : String, message : String, conflicting : Array<String> }>]

	static function determinePrimaryAnnotation[Function:(annotations : Array<String>) -> Null<String>]
		[Arg:Array<String>] [Local annotations(15068):Array<String>]
		[Block:Dynamic]
			[Block:Void]
				[Var `(15070):Int] [Const:Int] 0
				[Var `(15071):Array<String>]
					[Field:Array<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							SUPPORTED_ANNOTATIONS:Array<String>
				[While:Void]
					[Binop:Bool]
						[Local `(15070):Int:Int]
						<
						[Field:Int]
							[Local `(15071):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var annotation(15069):String]
							[Array:String]
								[Local `(15071):Array<String>:Array<String>]
								[Local `(15070):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15070):Int:Int]
						[If:Void]
							[Call:Bool]
								[Field:(x : String) -> Bool]
									[Local annotations(15068):Array<String>:Array<String>]
									[FInstance:(x : String) -> Bool]
										Array<String>
										contains:(x : Array.T) -> Bool
								[Local annotation(15069):String:String]
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local annotation(15069):String:String]
			[Return:Dynamic] [Const:Null<String>] null

	public static function routeCompilation[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> Null<String>]
		[Arg:haxe.macro.ClassType] [Local classType(15073):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15074):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15075):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo]
				[Call:reflaxe.elixir.helpers.AnnotationInfo]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
							reflaxe.elixir.helpers.AnnotationSystem
							detectAnnotations:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo
					[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Field:Bool]
					[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
					[FAnon:Bool] hasConflicts:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Block:Void]
						[Var `(15078):Int] [Const:Int] 0
						[Var `(15079):Array<reflaxe.elixir.helpers.AnnotationConflict>]
							[Field:Array<reflaxe.elixir.helpers.AnnotationConflict>]
								[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
								[FAnon:Array<reflaxe.elixir.helpers.AnnotationConflict>] conflicts:Array<reflaxe.elixir.helpers.AnnotationConflict>
						[While:Void]
							[Binop:Bool]
								[Local `(15078):Int:Int]
								<
								[Field:Int]
									[Local `(15079):Array<reflaxe.elixir.helpers.AnnotationConflict>:Array<reflaxe.elixir.helpers.AnnotationConflict>]
									[FInstance:Int]
										Array<reflaxe.elixir.helpers.AnnotationConflict>
										length:Int
							[Block:Void]
								[Var conflict(15077):reflaxe.elixir.helpers.AnnotationConflict]
									[Array:reflaxe.elixir.helpers.AnnotationConflict]
										[Local `(15079):Array<reflaxe.elixir.helpers.AnnotationConflict>:Array<reflaxe.elixir.helpers.AnnotationConflict>]
										[Local `(15078):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(15078):Int:Int]
								[Call:Void]
									[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
										[TypeExpr haxe.Log:Class<haxe.Log>]
										[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
											haxe.Log
											trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
									[Binop:String]
										[Const:String] "ERROR: "
										+
										[Field:String]
											[Local conflict(15077):reflaxe.elixir.helpers.AnnotationConflict:reflaxe.elixir.helpers.AnnotationConflict]
											[FAnon:String] message:String
									[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
										fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
										lineNumber: [Const:Int] 203
										className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
										methodName: [Const:String] "routeCompilation"
					[Return:Dynamic] [Const:Null<String>] null
			[If:Void]
				[Binop:Bool]
					[Field:Null<String>]
						[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
						[FAnon:Null<String>] primaryAnnotation:Null<String>
					==
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (annotationInfo.primaryAnnotation) {
	case ":genserver":
		if (reflaxe.elixir.helpers.OTPCompiler.isGenServerClassType(classType)) {
			compileGenServerClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: @:genserver annotation detected but OTPCompiler validation failed");
			null;
		};	
	case ":controller":
		if (reflaxe.elixir.helpers.RouterCompiler.isControllerClassType(classType)) {
			compileControllerClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:controller annotation detected but RouterCompiler validation failed");
			null;
		};	
	case ":router":
		if (reflaxe.elixir.helpers.RouterCompiler.isRouterClassType(classType)) {
			compileRouterClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:router annotation detected but RouterCompiler validation failed");
			null;
		};	
	case ":endpoint":
		null;	
	case ":channel":
		compileChannelClass(classType, varFields, funcFields);	
	case ":behaviour":
		if (reflaxe.elixir.helpers.BehaviorCompiler.isBehaviorClassType(classType)) {
			compileBehaviorClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:behaviour annotation detected but BehaviorCompiler validation failed");
			null;
		};	
	case ":protocol":
		if (reflaxe.elixir.helpers.ProtocolCompiler.isProtocolClassType(classType)) {
			compileProtocolClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:protocol annotation detected but ProtocolCompiler validation failed");
			null;
		};	
	case ":impl":
		if (reflaxe.elixir.helpers.ProtocolCompiler.isImplClassType(classType)) {
			compileImplClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:impl annotation detected but ProtocolCompiler validation failed");
			null;
		};	
	case ":repo":
		if (reflaxe.elixir.helpers.RepoCompiler.isRepoClass(classType)) {
			compileRepoClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: @:repo annotation detected but RepoCompiler validation failed");
			null;
		};	
	case ":migration":
		if (reflaxe.elixir.helpers.MigrationDSL.isMigrationClassType(classType)) {
			compileMigrationClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:migration annotation detected but MigrationDSL validation failed");
			null;
		};	
	case ":template":
		if (reflaxe.elixir.helpers.TemplateCompiler.isTemplateClassType(classType)) {
			compileTemplateClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:template annotation detected but TemplateCompiler validation failed");
			null;
		};	
	case ":component":
		compileComponentClass(classType, varFields, funcFields);	
	case ":schema":
		null;	
	case ":changeset":
		if (reflaxe.elixir.helpers.ChangesetCompiler.isChangesetClassType(classType)) {
			compileChangesetClass(classType, varFields, funcFields);
		} else {
			trace("ERROR: " + "@:changeset annotation detected but ChangesetCompiler validation failed");
			null;
		};	
	case ":liveview":
		if (reflaxe.elixir.LiveViewCompiler.isLiveViewClassType(classType)) {
			null;
		} else {
			trace("ERROR: " + "@:liveview annotation detected but LiveViewCompiler validation failed");
			null;
		};	
	case ":query":
		trace("WARNING: @:query annotation is not yet implemented. Query methods will be compiled as regular functions.");
		null;	
	case ":appName":
		null;	
	default:
		trace("ERROR: Unknown annotation: ${annotationInfo.primaryAnnotation}");
		null;	
})
					[Block:Null<String>]
						[Var `(16729):Null<String>]
							[Field:Null<String>]
								[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
								[FAnon:Null<String>] primaryAnnotation:Null<String>
						[If:Null<String>]
							[Binop:Bool]
								[Local `(16729):Null<String>:Null<String>]
								==
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>]
								[Call:Void]
									[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
										[TypeExpr haxe.Log:Class<haxe.Log>]
										[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
											haxe.Log
											trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
									[Binop:String]
										[Const:String] "ERROR: Unknown annotation: "
										+
										[Field:Null<String>]
											[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
											[FAnon:Null<String>] primaryAnnotation:Null<String>
									[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
										fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
										lineNumber: [Const:Int] 330
										className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
										methodName: [Const:String] "routeCompilation"
								[Const:Null<String>] null
							[Else:Null<String>] [Switch:Null<String>]
								[Local `(16729):Null<String>:Null<String>]
								[Case:Null<String>]
									[Const:String] ":appName"
									[Block:Null<String>] [Block:Null<String>] [Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":behaviour"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.BehaviorCompiler
															isBehaviorClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileBehaviorClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:behaviour annotation detected but BehaviorCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 251
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":changeset"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : Dynamic) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.ChangesetCompiler:Class<reflaxe.elixir.helpers.ChangesetCompiler>]
														[FStatic:(classType : Dynamic) -> Bool]
															reflaxe.elixir.helpers.ChangesetCompiler
															isChangesetClassType:(classType : Dynamic) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileChangesetClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:changeset annotation detected but ChangesetCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 306
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:String]
									[Const:String] ":channel"
									[Block:String]
										[Block:String]
											[Call:String]
												[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
													[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
													[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
														reflaxe.elixir.helpers.AnnotationSystem
														compileChannelClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
												[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
												[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
								[Case:String]
									[Const:String] ":component"
									[Block:String]
										[Block:String]
											[Call:String]
												[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
													[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
													[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
														reflaxe.elixir.helpers.AnnotationSystem
														compileComponentClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
												[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
												[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
								[Case:Null<String>]
									[Const:String] ":controller"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.RouterCompiler:Class<reflaxe.elixir.helpers.RouterCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.RouterCompiler
															isControllerClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileControllerClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:controller annotation detected but RouterCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 227
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":endpoint"
									[Block:Null<String>] [Block:Null<String>] [Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":genserver"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : Dynamic) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.OTPCompiler:Class<reflaxe.elixir.helpers.OTPCompiler>]
														[FStatic:(classType : Dynamic) -> Bool]
															reflaxe.elixir.helpers.OTPCompiler
															isGenServerClassType:(classType : Dynamic) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileGenServerClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Const:String] "ERROR: @:genserver annotation detected but OTPCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 219
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":impl"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.ProtocolCompiler:Class<reflaxe.elixir.helpers.ProtocolCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.ProtocolCompiler
															isImplClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileImplClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:impl annotation detected but ProtocolCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 267
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":liveview"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : Dynamic) -> Bool]
														[TypeExpr reflaxe.elixir.LiveViewCompiler:Class<reflaxe.elixir.LiveViewCompiler>]
														[FStatic:(classType : Dynamic) -> Bool]
															reflaxe.elixir.LiveViewCompiler
															isLiveViewClassType:(classType : Dynamic) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:Null<String>] [Block:Null<String>] [Const:Null<String>] null
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:liveview annotation detected but LiveViewCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 315
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":migration"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : Dynamic) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.MigrationDSL:Class<reflaxe.elixir.helpers.MigrationDSL>]
														[FStatic:(classType : Dynamic) -> Bool]
															reflaxe.elixir.helpers.MigrationDSL
															isMigrationClassType:(classType : Dynamic) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileMigrationClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:migration annotation detected but MigrationDSL validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 283
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":protocol"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.ProtocolCompiler:Class<reflaxe.elixir.helpers.ProtocolCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.ProtocolCompiler
															isProtocolClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileProtocolClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:protocol annotation detected but ProtocolCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 259
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":query"
									[Block:Null<String>]
										[Block:Null<String>]
											[Call:Void]
												[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
													[TypeExpr haxe.Log:Class<haxe.Log>]
													[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
														haxe.Log
														trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
												[Const:String] "WARNING: @:query annotation is not yet implemented. Query methods will be compiled as regular functions."
												[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
													fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
													lineNumber: [Const:Int] 321
													className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
													methodName: [Const:String] "routeCompilation"
											[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":repo"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.RepoCompiler:Class<reflaxe.elixir.helpers.RepoCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.RepoCompiler
															isRepoClass:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileRepoClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Const:String] "ERROR: @:repo annotation detected but RepoCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 275
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":router"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.RouterCompiler:Class<reflaxe.elixir.helpers.RouterCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.RouterCompiler
															isRouterClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileRouterClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:router annotation detected but RouterCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 235
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":schema"
									[Block:Null<String>] [Block:Null<String>] [Const:Null<String>] null
								[Case:Null<String>]
									[Const:String] ":template"
									[Block:Null<String>]
										[Block:Null<String>]
											[If:Null<String>]
												[Call:Bool]
													[Field:(classType : haxe.macro.ClassType) -> Bool]
														[TypeExpr reflaxe.elixir.helpers.TemplateCompiler:Class<reflaxe.elixir.helpers.TemplateCompiler>]
														[FStatic:(classType : haxe.macro.ClassType) -> Bool]
															reflaxe.elixir.helpers.TemplateCompiler
															isTemplateClassType:(classType : haxe.macro.ClassType) -> Bool
													[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
												[Then:String] [Block:String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																compileTemplateClass:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String
														[Local classType(15073):haxe.macro.ClassType:haxe.macro.ClassType]
														[Local varFields(15074):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
														[Local funcFields(15075):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
												[Else:Null<String>] [Block:Null<String>]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Binop:String]
															[Const:String] "ERROR: "
															+
															[Const:String] "@:template annotation detected but TemplateCompiler validation failed"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 291
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "routeCompilation"
													[Const:Null<String>] null
								[Default:Null<String>]
									[Block:Null<String>]
										[Call:Void]
											[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
												[TypeExpr haxe.Log:Class<haxe.Log>]
												[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
													haxe.Log
													trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
											[Binop:String]
												[Const:String] "ERROR: Unknown annotation: "
												+
												[Field:Null<String>]
													[Local annotationInfo(15076):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
													[FAnon:Null<String>] primaryAnnotation:Null<String>
											[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
												fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
												lineNumber: [Const:Int] 330
												className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
												methodName: [Const:String] "routeCompilation"
										[Const:Null<String>] null

	public static function getAppName[Function:(classType : haxe.macro.ClassType) -> Null<String>]
		[Arg:haxe.macro.ClassType] [Local classType(15155):haxe.macro.ClassType]
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classType(15155):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":appName"
				[Then:Void] [Block:Void]
					[Var appNameMeta(15156):Array<haxe.macro.MetadataEntry>]
						[Call:Array<haxe.macro.MetadataEntry>]
							[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
								[Field:haxe.macro.MetaAccess]
									[Local classType(15155):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
								[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
							[Const:String] ":appName"
					[If:Void]
						[Binop:Bool]
							[Field:Int]
								[Local appNameMeta(15156):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
								[FInstance:Int]
									Array<haxe.macro.MetadataEntry>
									length:Int
							>
							[Const:Int] 0
						[Then:Void] [Block:Void]
							[Var params(15157):Null<Array<haxe.macro.Expr>>]
								[Field:Null<Array<haxe.macro.Expr>>]
									[Array:haxe.macro.MetadataEntry]
										[Local appNameMeta(15156):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
										[Const:Int] 0
									[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Local params(15157):Null<Array<haxe.macro.Expr>>:Null<Array<haxe.macro.Expr>>]
										!=
										[Const:Null<Array<haxe.macro.Expr>>] null
									&&
									[Binop:Bool]
										[Field:Int]
											[Local params(15157):Null<Array<haxe.macro.Expr>>:Null<Array<haxe.macro.Expr>>]
											[FInstance:Int]
												Array<haxe.macro.Expr>
												length:Int
										>
										[Const:Int] 0
								[Then:Void] [Block:Void]
									[Meta:Void]
										:ast(switch (params[0].expr) {
	case EConst(CString(s, _)):
		globalAppNameRegistry = s;
		return s;	
	default:
		trace("WARNING: @:appName annotation must contain a string value. Example: @:appName('MyApp')");	
})
										[Block:Void]
											[Var `(15163):haxe.macro.ExprDef]
												[Field:haxe.macro.ExprDef]
													[Array:haxe.macro.Expr]
														[Local params(15157):Null<Array<haxe.macro.Expr>>:Null<Array<haxe.macro.Expr>>]
														[Const:Int] 0
													[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
											[If:Void]
												[Binop:Bool]
													[EnumIndex:Int] [Local `(15163):haxe.macro.ExprDef:haxe.macro.ExprDef]
													==
													[Const:Int] 0
												[Then:Void] [Block:Void]
													[Var `(15164):haxe.macro.Constant]
														[EnumParameter:haxe.macro.Constant]
															[Local `(15163):haxe.macro.ExprDef:haxe.macro.ExprDef]
															EConst
															0
													[If:Void]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(15164):haxe.macro.Constant:haxe.macro.Constant]
															==
															[Const:Int] 2
														[Then:Dynamic] [Block:Dynamic]
															[Var `(15165):String]
																[EnumParameter:String]
																	[Local `(15164):haxe.macro.Constant:haxe.macro.Constant]
																	CString
																	0
															[Var `(15166):Null<haxe.macro.StringLiteralKind>]
																[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																	[Local `(15164):haxe.macro.Constant:haxe.macro.Constant]
																	CString
																	1
															[Block:Dynamic]
																[Var s(15167):String] [Local `(15165):String:String]
																[Block:Dynamic]
																	[Binop:Null<String>]
																		[Field:Null<String>]
																			[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																			[FStatic:Null<String>]
																				reflaxe.elixir.helpers.AnnotationSystem
																				globalAppNameRegistry:Null<String>
																		=
																		[Local s(15167):String:String]
																	[Return:Dynamic] [Local s(15167):String:String]
														[Else:Void] [Block:Void]
															[Call:Void]
																[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																	[TypeExpr haxe.Log:Class<haxe.Log>]
																	[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																		haxe.Log
																		trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
																[Const:String] "WARNING: @:appName annotation must contain a string value. Example: @:appName('MyApp')"
																[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
																	fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
																	lineNumber: [Const:Int] 352
																	className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
																	methodName: [Const:String] "getAppName"
												[Else:Void] [Block:Void]
													[Call:Void]
														[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															[TypeExpr haxe.Log:Class<haxe.Log>]
															[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
																haxe.Log
																trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
														[Const:String] "WARNING: @:appName annotation must contain a string value. Example: @:appName('MyApp')"
														[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
															fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
															lineNumber: [Const:Int] 352
															className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
															methodName: [Const:String] "getAppName"
								[Else:Void] [Block:Void]
									[Call:Void]
										[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
											[TypeExpr haxe.Log:Class<haxe.Log>]
											[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
												haxe.Log
												trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
										[Const:String] "WARNING: @:appName annotation requires a value. Example: @:appName('MyApp')"
										[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
											fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/AnnotationSystem.hx"
											lineNumber: [Const:Int] 355
											className: [Const:String] "reflaxe.elixir.helpers.AnnotationSystem"
											methodName: [Const:String] "getAppName"
			[Return:Dynamic] [Const:Null<String>] null

	public static function getEffectiveAppName[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15154):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var annotatedName(15168):Null<String>]
				[Call:Null<String>]
					[Field:(classType : haxe.macro.ClassType) -> Null<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> Null<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							getAppName:(classType : haxe.macro.ClassType) -> Null<String>
					[Local classType(15154):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Binop:Bool]
					[Local annotatedName(15168):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local annotatedName(15168):Null<String>:Null<String>]
			[Var globalAppName(15169):Null<String>]
				[Call:Null<String>]
					[Field:() -> Null<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:() -> Null<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							getGlobalAppName:() -> Null<String>
			[If:Void]
				[Binop:Bool]
					[Local globalAppName(15169):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local globalAppName(15169):Null<String>:Null<String>]
			[Var className(15170):String]
				[Field:String]
					[Local classType(15154):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local className(15170):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "App"
						[Const:Null<Int>] null
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Array:String]
								[Call:Array<String>]
									[Field:(delimiter : String) -> Array<String>]
										[Local className(15170):String:String]
										[FInstance:(delimiter : String) -> Array<String>]
											String
											split:(delimiter : String) -> Array<String>
									[Const:String] "App"
								[Const:Int] 0
							+
							[Const:String] "App"
			[Return:Dynamic] [Const:String] "App"

	public static function getGlobalAppName[Function:() -> Null<String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Field:Null<String>]
					[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
					[FStatic:Null<String>]
						reflaxe.elixir.helpers.AnnotationSystem
						globalAppNameRegistry:Null<String>

	public static function generateAnnotationDocs[Function:() -> String]
		[Block:Dynamic]
			[Var result(17080):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(17080):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "# Reflaxe.Elixir Annotation Reference\n\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(17080):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "## Supported Annotations\n\n"
			[Block:Void]
				[Var `(17083):Int] [Const:Int] 0
				[Var `(17084):Array<String>]
					[Field:Array<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							SUPPORTED_ANNOTATIONS:Array<String>
				[While:Void]
					[Binop:Bool]
						[Local `(17083):Int:Int]
						<
						[Field:Int]
							[Local `(17084):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var annotation(17081):String]
							[Array:String]
								[Local `(17084):Array<String>:Array<String>]
								[Local `(17083):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(17083):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(17080):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "- **"
											+
											[Local annotation(17081):String:String]
										+
										[Const:String] "** - "
									+
									[Call:String]
										[Field:(annotation : String) -> String]
											[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
											[FStatic:(annotation : String) -> String]
												reflaxe.elixir.helpers.AnnotationSystem
												getAnnotationDescription:(annotation : String) -> String
										[Local annotation(17081):String:String]
								+
								[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(17080):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "\n## Annotation Combinations\n\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(17080):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "### Compatible Combinations:\n"
			[Block:Void]
				[Var `(17086):Int] [Const:Int] 0
				[Var `(17087):Array<Array<String>>]
					[Field:Array<Array<String>>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<Array<String>>]
							reflaxe.elixir.helpers.AnnotationSystem
							COMPATIBLE_COMBINATIONS:Array<Array<String>>
				[While:Void]
					[Binop:Bool]
						[Local `(17086):Int:Int]
						<
						[Field:Int]
							[Local `(17087):Array<Array<String>>:Array<Array<String>>]
							[FInstance:Int]
								Array<Array<String>>
								length:Int
					[Block:Void]
						[Var combination(17085):Array<String>]
							[Array:Array<String>]
								[Local `(17087):Array<Array<String>>:Array<Array<String>>]
								[Local `(17086):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(17086):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(17080):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "- "
									+
									[Call:String]
										[Field:(sep : String) -> String]
											[Local combination(17085):Array<String>:Array<String>]
											[FInstance:(sep : String) -> String]
												Array<String>
												join:(sep : String) -> String
										[Const:String] " + "
								+
								[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(17080):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "\n### Exclusive Groups (mutually exclusive):\n"
			[Block:Void]
				[Var `(17089):Int] [Const:Int] 0
				[Var `(17090):Array<Array<String>>]
					[Field:Array<Array<String>>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:Array<Array<String>>]
							reflaxe.elixir.helpers.AnnotationSystem
							EXCLUSIVE_GROUPS:Array<Array<String>>
				[While:Void]
					[Binop:Bool]
						[Local `(17089):Int:Int]
						<
						[Field:Int]
							[Local `(17090):Array<Array<String>>:Array<Array<String>>]
							[FInstance:Int]
								Array<Array<String>>
								length:Int
					[Block:Void]
						[Var group(17088):Array<String>]
							[Array:Array<String>]
								[Local `(17090):Array<Array<String>>:Array<Array<String>>]
								[Local `(17089):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(17089):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(17080):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "- "
									+
									[Call:String]
										[Field:(sep : String) -> String]
											[Local group(17088):Array<String>:Array<String>]
											[FInstance:(sep : String) -> String]
												Array<String>
												join:(sep : String) -> String
										[Const:String] " | "
								+
								[Const:String] " (choose one)\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(17080):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function getAnnotationDescription[Function:(annotation : String) -> String]
		[Arg:String] [Local annotation(17082):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (annotation) {
	case ":genserver":
		"OTP GenServer with lifecycle callbacks";	
	case ":router":
		"Phoenix Router with route definitions";	
	case ":endpoint":
		"Phoenix Endpoint with HTTP configuration";	
	case ":protocol":
		"Elixir protocol for polymorphic dispatch";	
	case ":impl":
		"Protocol implementation for specific types";	
	case ":migration":
		"Ecto database migration with table operations";	
	case ":template":
		"Phoenix HEEx template with component integration";	
	case ":schema":
		"Ecto schema with field definitions and associations";	
	case ":changeset":
		"Ecto changeset with validation pipeline";	
	case ":liveview":
		"Phoenix LiveView with real-time updates";	
	case ":component":
		"Phoenix UI components with type-safe renders";	
	case ":query":
		"Ecto query DSL with type-safe operations";	
	case ":appName":
		"Application name configuration for module naming";	
	default:
		"Unknown annotation";	
})
					[Switch:String]
						[Local annotation(17082):String:String]
						[Case:String]
							[Const:String] ":appName"
							[Block:String] [Block:String] [Const:String] "Application name configuration for module naming"
						[Case:String]
							[Const:String] ":changeset"
							[Block:String] [Block:String] [Const:String] "Ecto changeset with validation pipeline"
						[Case:String]
							[Const:String] ":component"
							[Block:String] [Block:String] [Const:String] "Phoenix UI components with type-safe renders"
						[Case:String]
							[Const:String] ":endpoint"
							[Block:String] [Block:String] [Const:String] "Phoenix Endpoint with HTTP configuration"
						[Case:String]
							[Const:String] ":genserver"
							[Block:String] [Block:String] [Const:String] "OTP GenServer with lifecycle callbacks"
						[Case:String]
							[Const:String] ":impl"
							[Block:String] [Block:String] [Const:String] "Protocol implementation for specific types"
						[Case:String]
							[Const:String] ":liveview"
							[Block:String] [Block:String] [Const:String] "Phoenix LiveView with real-time updates"
						[Case:String]
							[Const:String] ":migration"
							[Block:String] [Block:String] [Const:String] "Ecto database migration with table operations"
						[Case:String]
							[Const:String] ":protocol"
							[Block:String] [Block:String] [Const:String] "Elixir protocol for polymorphic dispatch"
						[Case:String]
							[Const:String] ":query"
							[Block:String] [Block:String] [Const:String] "Ecto query DSL with type-safe operations"
						[Case:String]
							[Const:String] ":router"
							[Block:String] [Block:String] [Const:String] "Phoenix Router with route definitions"
						[Case:String]
							[Const:String] ":schema"
							[Block:String] [Block:String] [Const:String] "Ecto schema with field definitions and associations"
						[Case:String]
							[Const:String] ":template"
							[Block:String] [Block:String] [Const:String] "Phoenix HEEx template with component integration"
						[Default:String] [Block:String] [Const:String] "Unknown annotation"

	static function compileGenServerClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15081):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15082):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15083):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(15084):String]
				[Field:String]
					[Local classType(15081):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(15086):Unknown<30>]
				[Call:Dynamic]
					[Field:(classType : Dynamic) -> Dynamic]
						[TypeExpr reflaxe.elixir.helpers.OTPCompiler:Class<reflaxe.elixir.helpers.OTPCompiler>]
						[FStatic:(classType : Dynamic) -> Dynamic]
							reflaxe.elixir.helpers.OTPCompiler
							getGenServerConfig:(classType : Dynamic) -> Dynamic
					[Local classType(15081):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(genServerData : Dynamic) -> String]
						[TypeExpr reflaxe.elixir.helpers.OTPCompiler:Class<reflaxe.elixir.helpers.OTPCompiler>]
						[FStatic:(genServerData : Dynamic) -> String]
							reflaxe.elixir.helpers.OTPCompiler
							compileFullGenServer:(genServerData : Dynamic) -> String
					[ObjectDecl:{ initialState : String, className : String, castMethods : Array<Unknown<32>>, callMethods : Array<Unknown<31>> }]
						className: [Local className(15084):String:String]
						initialState: [Const:String] "%{}"
						callMethods: [ArrayDecl:Array<Unknown<31>>]
						castMethods: [ArrayDecl:Array<Unknown<32>>]

	static function compileControllerClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15112):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15113):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15114):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.RouterCompiler:Class<reflaxe.elixir.helpers.RouterCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.RouterCompiler
							compileController:(classType : haxe.macro.ClassType) -> String
					[Local classType(15112):haxe.macro.ClassType:haxe.macro.ClassType]

	static function compileRouterClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15148):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15149):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15150):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.RouterCompiler:Class<reflaxe.elixir.helpers.RouterCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.RouterCompiler
							compileRouter:(classType : haxe.macro.ClassType) -> String
					[Local classType(15148):haxe.macro.ClassType:haxe.macro.ClassType]

	static function compileChannelClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15354):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15355):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15356):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, content : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.ChannelCompiler:Class<reflaxe.elixir.helpers.ChannelCompiler>]
						[FStatic:(classType : haxe.macro.ClassType, content : String) -> String]
							reflaxe.elixir.helpers.ChannelCompiler
							compileChannel:(classType : haxe.macro.ClassType, content : String) -> String
					[Local classType(15354):haxe.macro.ClassType:haxe.macro.ClassType]
					[Const:String] ""

	static function compileBehaviorClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15401):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15402):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15403):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.BehaviorCompiler:Class<reflaxe.elixir.helpers.BehaviorCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.BehaviorCompiler
							compileBehavior:(classType : haxe.macro.ClassType) -> String
					[Local classType(15401):haxe.macro.ClassType:haxe.macro.ClassType]

	static function compileProtocolClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15482):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15483):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15484):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.ProtocolCompiler:Class<reflaxe.elixir.helpers.ProtocolCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.ProtocolCompiler
							compileProtocol:(classType : haxe.macro.ClassType) -> String
					[Local classType(15482):haxe.macro.ClassType:haxe.macro.ClassType]

	static function compileImplClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15565):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15566):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15567):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.ProtocolCompiler:Class<reflaxe.elixir.helpers.ProtocolCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.ProtocolCompiler
							compileImplementation:(classType : haxe.macro.ClassType) -> String
					[Local classType(15565):haxe.macro.ClassType:haxe.macro.ClassType]

	static function compileRepoClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15626):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15627):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15628):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(15629):String]
				[Call:String]
					[Field:(v : reflaxe.helpers.NameAndMeta) -> String]
						[TypeExpr reflaxe.helpers.NameMetaHelper:{ Statics reflaxe.helpers.NameMetaHelper }]
						[FStatic:(v : reflaxe.helpers.NameAndMeta) -> String]
							reflaxe.helpers.NameMetaHelper
							getNameOrNative:(v : reflaxe.helpers.NameAndMeta) -> String
					[Local classType(15626):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, className : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.RepoCompiler:Class<reflaxe.elixir.helpers.RepoCompiler>]
						[FStatic:(classType : haxe.macro.ClassType, className : String) -> String]
							reflaxe.elixir.helpers.RepoCompiler
							compileRepoModule:(classType : haxe.macro.ClassType, className : String) -> String
					[Local classType(15626):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local className(15629):String:String]

	static function compileMigrationClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15637):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15638):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15639):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(15640):String]
				[Field:String]
					[Local classType(15637):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(15692):{ timestamp : Unknown<33>, table : Null<Null<String>> }]
				[Call:Dynamic]
					[Field:(classType : haxe.macro.ClassType) -> Dynamic]
						[TypeExpr reflaxe.elixir.helpers.MigrationDSL:Class<reflaxe.elixir.helpers.MigrationDSL>]
						[FStatic:(classType : haxe.macro.ClassType) -> Dynamic]
							reflaxe.elixir.helpers.MigrationDSL
							getMigrationConfig:(classType : haxe.macro.ClassType) -> Dynamic
					[Local classType(15637):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var tableName(15693):Null<String>]
				[If:Null<String>]
					[Binop:Bool]
						[Field:Null<Null<String>>]
							[Local config(15692):{ timestamp : Unknown<33>, table : Null<Null<String>> }:{ timestamp : Unknown<33>, table : Null<Null<String>> }]
							[FAnon:Null<Null<String>>] table:Null<Null<String>>
						!=
						[Const:Null<Null<String>>] null
					[Then:Null<Null<String>>] [Block:Null<Null<String>>]
						[Field:Null<Null<String>>]
							[Local config(15692):{ timestamp : Unknown<33>, table : Null<Null<String>> }:{ timestamp : Unknown<33>, table : Null<Null<String>> }]
							[FAnon:Null<Null<String>>] table:Null<Null<String>>
					[Else:String] [Block:String] [Const:String] "default_table"
			[Var columns(15703):Array<String>]
				[Block:Array<String>]
					[Var `(15698):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(15699):Int] [Const:Int] 0
						[Var `(15700):Array<reflaxe.data.ClassVarData>] [Local varFields(15638):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
						[While:Void]
							[Binop:Bool]
								[Local `(15699):Int:Int]
								<
								[Field:Int]
									[Local `(15700):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
									[FInstance:Int]
										Array<reflaxe.data.ClassVarData>
										length:Int
							[Block:Void]
								[Var v(15701):reflaxe.data.ClassVarData]
									[Array:reflaxe.data.ClassVarData]
										[Local `(15700):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
										[Local `(15699):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(15699):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(15698):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(field : reflaxe.data.ClassVarData) -> String]
											[Arg:reflaxe.data.ClassVarData] [Local field(15702):reflaxe.data.ClassVarData]
											[Block:Dynamic]
												[Return:Dynamic]
													[Binop:String]
														[Binop:String]
															[Const:String] ""
															+
															[Field:String]
																[Field:haxe.macro.ClassField]
																	[Local field(15702):reflaxe.data.ClassVarData:reflaxe.data.ClassVarData]
																	[FInstance:haxe.macro.ClassField]
																		reflaxe.data.ClassVarData
																		field:haxe.macro.ClassField
																[FAnon:String] name:String
														+
														[Const:String] ":string"
										[Local v(15701):reflaxe.data.ClassVarData:reflaxe.data.ClassVarData]
					[Local `(15698):Array<String>:Array<String>]
			[Return:Dynamic]
				[Call:String]
					[Field:(migrationData : Dynamic) -> String]
						[TypeExpr reflaxe.elixir.helpers.MigrationDSL:Class<reflaxe.elixir.helpers.MigrationDSL>]
						[FStatic:(migrationData : Dynamic) -> String]
							reflaxe.elixir.helpers.MigrationDSL
							compileFullMigration:(migrationData : Dynamic) -> String
					[ObjectDecl:{ timestamp : Unknown<33>, tableName : Null<String>, columns : Array<String>, className : String }]
						className: [Local className(15640):String:String]
						timestamp: [Field:Unknown<33>]
							[Local config(15692):{ timestamp : Unknown<33>, table : Null<Null<String>> }:{ timestamp : Unknown<33>, table : Null<Null<String>> }]
							[FAnon:Unknown<33>] timestamp:Unknown<33>
						tableName: [Local tableName(15693):Null<String>:Null<String>]
						columns: [Local columns(15703):Array<String>:Array<String>]

	static function compileTemplateClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15726):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15727):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15728):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(15729):String]
				[Field:String]
					[Local classType(15726):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(15743):reflaxe.elixir.helpers.TemplateConfig]
				[Call:reflaxe.elixir.helpers.TemplateConfig]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig]
						[TypeExpr reflaxe.elixir.helpers.TemplateCompiler:Class<reflaxe.elixir.helpers.TemplateCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig]
							reflaxe.elixir.helpers.TemplateCompiler
							getTemplateConfig:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.TemplateConfig
					[Local classType(15726):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String]
						[TypeExpr reflaxe.elixir.helpers.TemplateCompiler:Class<reflaxe.elixir.helpers.TemplateCompiler>]
						[FStatic:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String]
							reflaxe.elixir.helpers.TemplateCompiler
							compileFullTemplate:(className : String, config : reflaxe.elixir.helpers.TemplateConfig) -> String
					[Local className(15729):String:String]
					[Local config(15743):reflaxe.elixir.helpers.TemplateConfig:reflaxe.elixir.helpers.TemplateConfig]

	static function compileComponentClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(15749):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(15750):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(15751):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(15752):String]
				[Field:String]
					[Local classType(15749):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var moduleName(15753):String]
				[Call:String]
					[Field:(v : reflaxe.helpers.NameAndMeta) -> String]
						[TypeExpr reflaxe.helpers.NameMetaHelper:{ Statics reflaxe.helpers.NameMetaHelper }]
						[FStatic:(v : reflaxe.helpers.NameAndMeta) -> String]
							reflaxe.helpers.NameMetaHelper
							getNameOrNative:(v : reflaxe.helpers.NameAndMeta) -> String
					[Local classType(15749):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var result(15754):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local moduleName(15753):String:String]
					+
					[Const:String] " do\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  @moduledoc \"\"\"\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  Core UI components for Phoenix applications.\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  \n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  Generated from Haxe CoreComponents with type safety and consistent styling.\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  \"\"\"\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  use Phoenix.Component\n\n"
			[Block:Void]
				[Var `(16711):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(16711):Int:Int]
						<
						[Field:Int]
							[Local funcFields(15751):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
							[FInstance:Int]
								Array<reflaxe.data.ClassFuncData>
								length:Int
					[Block:Void]
						[Var funcField(15755):reflaxe.data.ClassFuncData]
							[Array:reflaxe.data.ClassFuncData]
								[Local funcFields(15751):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
								[Local `(16711):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(16711):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Field:haxe.macro.MetaAccess]
										[Field:haxe.macro.ClassField]
											[Local funcField(15755):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
											[FInstance:haxe.macro.ClassField]
												reflaxe.data.ClassFuncData
												field:haxe.macro.ClassField
										[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
									!=
									[Const:haxe.macro.MetaAccess] null
								&&
								[Call:Bool]
									[Field:(name : String) -> Bool]
										[Field:haxe.macro.MetaAccess]
											[Field:haxe.macro.ClassField]
												[Local funcField(15755):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
												[FInstance:haxe.macro.ClassField]
													reflaxe.data.ClassFuncData
													field:haxe.macro.ClassField
											[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
										[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
									[Const:String] ":component"
							[Then:Void] [Block:Void]
								[Var componentCode(16710):String]
									[Call:String]
										[Field:(funcField : reflaxe.data.ClassFuncData, classType : haxe.macro.ClassType) -> String]
											[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
											[FStatic:(funcField : reflaxe.data.ClassFuncData, classType : haxe.macro.ClassType) -> String]
												reflaxe.elixir.helpers.AnnotationSystem
												compileComponentFunction:(funcField : reflaxe.data.ClassFuncData, classType : haxe.macro.ClassType) -> String
										[Local funcField(15755):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
										[Local classType(15749):haxe.macro.ClassType:haxe.macro.ClassType]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local result(15754):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Local componentCode(16710):String:String]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local result(15754):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15754):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "end\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(15754):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function compileComponentFunction[Function:(funcField : reflaxe.data.ClassFuncData, classType : haxe.macro.ClassType) -> String]
		[Arg:reflaxe.data.ClassFuncData] [Local funcField(15756):reflaxe.data.ClassFuncData]
		[Arg:haxe.macro.ClassType] [Local classType(15757):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var funcName(15758):String]
				[Field:String]
					[Field:haxe.macro.ClassField]
						[Local funcField(15756):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
						[FInstance:haxe.macro.ClassField]
							reflaxe.data.ClassFuncData
							field:haxe.macro.ClassField
					[FAnon:String] name:String
			[Var result(15759):StringBuf] [New:StringBuf] StringBuf
			[Var attributes(15825):Array<reflaxe.elixir.helpers.ComponentAttribute>]
				[Call:Array<reflaxe.elixir.helpers.ComponentAttribute>]
					[Field:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentAttribute>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentAttribute>]
							reflaxe.elixir.helpers.AnnotationSystem
							extractComponentAttributes:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentAttribute>
					[Field:haxe.macro.MetaAccess]
						[Field:haxe.macro.ClassField]
							[Local funcField(15756):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
							[FInstance:haxe.macro.ClassField]
								reflaxe.data.ClassFuncData
								field:haxe.macro.ClassField
						[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
			[Var slots(15844):Array<reflaxe.elixir.helpers.ComponentSlot>]
				[Call:Array<reflaxe.elixir.helpers.ComponentSlot>]
					[Field:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentSlot>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentSlot>]
							reflaxe.elixir.helpers.AnnotationSystem
							extractComponentSlots:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentSlot>
					[Field:haxe.macro.MetaAccess]
						[Field:haxe.macro.ClassField]
							[Local funcField(15756):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
							[FInstance:haxe.macro.ClassField]
								reflaxe.data.ClassFuncData
								field:haxe.macro.ClassField
						[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
			[Block:Void]
				[Var `(15846):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(15846):Int:Int]
						<
						[Field:Int]
							[Local attributes(15825):Array<reflaxe.elixir.helpers.ComponentAttribute>:Array<reflaxe.elixir.helpers.ComponentAttribute>]
							[FInstance:Int]
								Array<reflaxe.elixir.helpers.ComponentAttribute>
								length:Int
					[Block:Void]
						[Var attr(15845):reflaxe.elixir.helpers.ComponentAttribute]
							[Array:reflaxe.elixir.helpers.ComponentAttribute]
								[Local attributes(15825):Array<reflaxe.elixir.helpers.ComponentAttribute>:Array<reflaxe.elixir.helpers.ComponentAttribute>]
								[Local `(15846):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15846):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(15759):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "  attr :"
										+
										[Field:String]
											[Local attr(15845):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
											[FAnon:String] name:String
									+
									[Const:String] ", :"
								+
								[Field:String]
									[Local attr(15845):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
									[FAnon:String] type:String
						[If:Void]
							[Field:Bool]
								[Local attr(15845):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
								[FAnon:Bool] required:Bool
							[Then:Void] [Block:Void]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local result(15759):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Const:String] ", required: true"
							[Else:Void] [Block:Void]
								[If:Void]
									[Binop:Bool]
										[Field:Null<String>]
											[Local attr(15845):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
											[FAnon:Null<String>] defaultValue:Null<String>
										!=
										[Const:Null<String>] null
									[Then:Void] [Block:Void]
										[Call:Void]
											[Field:(x : String) -> Void]
												[Local result(15759):StringBuf:StringBuf]
												[FInstance:(x : String) -> Void]
													StringBuf
													add:(x : add.T) -> Void
											[Binop:String]
												[Const:String] ", default: "
												+
												[Field:Null<String>]
													[Local attr(15845):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
													[FAnon:Null<String>] defaultValue:Null<String>
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(15759):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Const:String] "\n"
			[Block:Void]
				[Var `(15848):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(15848):Int:Int]
						<
						[Field:Int]
							[Local slots(15844):Array<reflaxe.elixir.helpers.ComponentSlot>:Array<reflaxe.elixir.helpers.ComponentSlot>]
							[FInstance:Int]
								Array<reflaxe.elixir.helpers.ComponentSlot>
								length:Int
					[Block:Void]
						[Var slot(15847):reflaxe.elixir.helpers.ComponentSlot]
							[Array:reflaxe.elixir.helpers.ComponentSlot]
								[Local slots(15844):Array<reflaxe.elixir.helpers.ComponentSlot>:Array<reflaxe.elixir.helpers.ComponentSlot>]
								[Local `(15848):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15848):Int:Int]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(15759):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Const:String] "  slot :"
								+
								[Field:String]
									[Local slot(15847):reflaxe.elixir.helpers.ComponentSlot:reflaxe.elixir.helpers.ComponentSlot]
									[FAnon:String] name:String
						[If:Void]
							[Field:Bool]
								[Local slot(15847):reflaxe.elixir.helpers.ComponentSlot:reflaxe.elixir.helpers.ComponentSlot]
								[FAnon:Bool] required:Bool
							[Then:Void] [Block:Void]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local result(15759):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Const:String] ", required: true"
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local result(15759):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15759):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "  def "
						+
						[Local funcName(15758):String:String]
					+
					[Const:String] "(assigns) do\n"
			[If:Void]
				[Binop:Bool]
					[Field:Null<haxe.macro.TypedExpr>]
						[Local funcField(15756):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
						[FInstance:Null<haxe.macro.TypedExpr>]
							reflaxe.data.ClassFuncData
							expr:Null<haxe.macro.TypedExpr>
					!=
					[Const:Null<haxe.macro.TypedExpr>] null
				[Then:Void] [Block:Void]
					[Var hxxTemplate(16709):String]
						[Call:String]
							[Field:(expr : haxe.macro.TypedExpr) -> String]
								[TypeExpr reflaxe.elixir.helpers.HxxCompiler:Class<reflaxe.elixir.helpers.HxxCompiler>]
								[FStatic:(expr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.HxxCompiler
									compileHxxTemplate:(expr : haxe.macro.TypedExpr) -> String
							[Field:Null<haxe.macro.TypedExpr>]
								[Local funcField(15756):reflaxe.data.ClassFuncData:reflaxe.data.ClassFuncData]
								[FInstance:Null<haxe.macro.TypedExpr>]
									reflaxe.data.ClassFuncData
									expr:Null<haxe.macro.TypedExpr>
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(15759):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "    "
								+
								[Local hxxTemplate(16709):String:String]
							+
							[Const:String] "\n"
				[Else:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(15759):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "    ~H\"\"\"\n    <div></div>\n    \"\"\"\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(15759):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  end\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(15759):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function extractComponentAttributes[Function:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentAttribute>]
		[Arg:Null<haxe.macro.MetaAccess>] [Local meta(15760):Null<haxe.macro.MetaAccess>]
		[Block:Dynamic]
			[Var attributes(15761):Array<reflaxe.elixir.helpers.ComponentAttribute>] [ArrayDecl:Array<reflaxe.elixir.helpers.ComponentAttribute>]
			[If:Void]
				[Binop:Bool]
					[Local meta(15760):Null<haxe.macro.MetaAccess>:Null<haxe.macro.MetaAccess>]
					==
					[Const:Null<haxe.macro.MetaAccess>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local attributes(15761):Array<reflaxe.elixir.helpers.ComponentAttribute>:Array<reflaxe.elixir.helpers.ComponentAttribute>]
			[Var attrMeta(15762):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Local meta(15760):Null<haxe.macro.MetaAccess>:Null<haxe.macro.MetaAccess>]
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":attr"
			[Block:Void]
				[Var `(15824):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(15824):Int:Int]
						<
						[Field:Int]
							[Local attrMeta(15762):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
							[FInstance:Int]
								Array<haxe.macro.MetadataEntry>
								length:Int
					[Block:Void]
						[Var attr(15763):haxe.macro.MetadataEntry]
							[Array:haxe.macro.MetadataEntry]
								[Local attrMeta(15762):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
								[Local `(15824):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15824):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Field:Null<Array<haxe.macro.Expr>>]
										[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
										[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
									!=
									[Const:Null<Array<haxe.macro.Expr>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Field:Null<Array<haxe.macro.Expr>>]
											[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
											[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
										[FInstance:Int]
											Array<haxe.macro.Expr>
											length:Int
									>=
									[Const:Int] 2
							[Then:Int] [Block:Int]
								[Var name(15775):String]
									[Call:String]
										[Field:(expr : haxe.macro.Expr) -> String]
											[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
											[FStatic:(expr : haxe.macro.Expr) -> String]
												reflaxe.elixir.helpers.AnnotationSystem
												extractStringParam:(expr : haxe.macro.Expr) -> String
										[Array:haxe.macro.Expr]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											[Const:Int] 0
								[Var type(15776):String]
									[Call:String]
										[Field:(expr : haxe.macro.Expr) -> String]
											[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
											[FStatic:(expr : haxe.macro.Expr) -> String]
												reflaxe.elixir.helpers.AnnotationSystem
												extractStringParam:(expr : haxe.macro.Expr) -> String
										[Array:haxe.macro.Expr]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											[Const:Int] 1
								[Var options(15777):Null<Null<haxe.macro.Expr>>]
									[If:Null<haxe.macro.Expr>]
										[Binop:Bool]
											[Field:Int]
												[Field:Null<Array<haxe.macro.Expr>>]
													[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
													[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
												[FInstance:Int]
													Array<haxe.macro.Expr>
													length:Int
											>
											[Const:Int] 2
										[Then:haxe.macro.Expr] [Block:haxe.macro.Expr]
											[Array:haxe.macro.Expr]
												[Field:Null<Array<haxe.macro.Expr>>]
													[Local attr(15763):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
													[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
												[Const:Int] 2
										[Else:Null<Null<haxe.macro.Expr>>] [Block:Null<Null<haxe.macro.Expr>>] [Const:Null<Null<haxe.macro.Expr>>] null
								[Var attribute(15778):reflaxe.elixir.helpers.ComponentAttribute]
									[ObjectDecl:{ type : String, required : Bool, name : String, defaultValue : Null<String> }]
										name: [Local name(15775):String:String]
										type: [Local type(15776):String:String]
										required: [Const:Bool] false
										defaultValue: [Const:Null<String>] null
								[If:Void]
									[Binop:Bool]
										[Local options(15777):Null<Null<haxe.macro.Expr>>:Null<Null<haxe.macro.Expr>>]
										!=
										[Const:Null<Null<haxe.macro.Expr>>] null
									[Then:Void] [Block:Void]
										[Meta:Void]
											:ast(switch (options.expr) {
	case EObjectDecl(fields):
		for (field  in  fields) {
			switch (field.field) {
				case "required":
					attribute.required = extractBoolParam(field.expr);				
				case "default":
					attribute.defaultValue = extractValueParam(field.expr);				
			};
		};	
	case _:
})
											[Block:Void]
												[Var `(15818):haxe.macro.ExprDef]
													[Field:haxe.macro.ExprDef]
														[Local options(15777):Null<Null<haxe.macro.Expr>>:Null<Null<haxe.macro.Expr>>]
														[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
												[If:Void]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(15818):haxe.macro.ExprDef:haxe.macro.ExprDef]
														==
														[Const:Int] 5
													[Then:Void] [Block:Void]
														[Var `(15819):Array<haxe.macro.ObjectField>]
															[EnumParameter:Array<haxe.macro.ObjectField>]
																[Local `(15818):haxe.macro.ExprDef:haxe.macro.ExprDef]
																EObjectDecl
																0
														[Block:Void]
															[Var fields(15820):Array<haxe.macro.ObjectField>] [Local `(15819):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
															[Block:Void]
																[Block:Void]
																	[Var `(15821):Int] [Const:Int] 0
																	[While:Void]
																		[Binop:Bool]
																			[Local `(15821):Int:Int]
																			<
																			[Field:Int]
																				[Local fields(15820):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
																				[FInstance:Int]
																					Array<haxe.macro.ObjectField>
																					length:Int
																		[Block:Void]
																			[Var field(15822):haxe.macro.ObjectField]
																				[Array:haxe.macro.ObjectField]
																					[Local fields(15820):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
																					[Local `(15821):Int:Int]
																			[Unop:Int]
																				++
																				Prefix
																				[Local `(15821):Int:Int]
																			[Meta:Void]
																				:ast(switch (field.field) {
	case "required":
		attribute.required = extractBoolParam(field.expr);	
	case "default":
		attribute.defaultValue = extractValueParam(field.expr);	
})
																				[Block:Void]
																					[Var `(15823):String]
																						[Field:String]
																							[Local field(15822):haxe.macro.ObjectField:haxe.macro.ObjectField]
																							[FAnon:String] field:String
																					[Switch:Void]
																						[Local `(15823):String:String]
																						[Case:Null<String>]
																							[Const:String] "default"
																							[Block:Null<String>]
																								[Block:Null<String>]
																									[Binop:Null<String>]
																										[Field:Null<String>]
																											[Local attribute(15778):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
																											[FAnon:Null<String>] defaultValue:Null<String>
																										=
																										[Call:String]
																											[Field:(expr : haxe.macro.Expr) -> String]
																												[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																												[FStatic:(expr : haxe.macro.Expr) -> String]
																													reflaxe.elixir.helpers.AnnotationSystem
																													extractValueParam:(expr : haxe.macro.Expr) -> String
																											[Field:haxe.macro.Expr]
																												[Local field(15822):haxe.macro.ObjectField:haxe.macro.ObjectField]
																												[FAnon:haxe.macro.Expr] expr:haxe.macro.Expr
																						[Case:Bool]
																							[Const:String] "required"
																							[Block:Bool]
																								[Block:Bool]
																									[Binop:Bool]
																										[Field:Bool]
																											[Local attribute(15778):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
																											[FAnon:Bool] required:Bool
																										=
																										[Call:Bool]
																											[Field:(expr : haxe.macro.Expr) -> Bool]
																												[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																												[FStatic:(expr : haxe.macro.Expr) -> Bool]
																													reflaxe.elixir.helpers.AnnotationSystem
																													extractBoolParam:(expr : haxe.macro.Expr) -> Bool
																											[Field:haxe.macro.Expr]
																												[Local field(15822):haxe.macro.ObjectField:haxe.macro.ObjectField]
																												[FAnon:haxe.macro.Expr] expr:haxe.macro.Expr
													[Else:Void] [Block:Void]
								[Call:Int]
									[Field:(x : reflaxe.elixir.helpers.ComponentAttribute) -> Int]
										[Local attributes(15761):Array<reflaxe.elixir.helpers.ComponentAttribute>:Array<reflaxe.elixir.helpers.ComponentAttribute>]
										[FInstance:(x : reflaxe.elixir.helpers.ComponentAttribute) -> Int]
											Array<reflaxe.elixir.helpers.ComponentAttribute>
											push:(x : Array.T) -> Int
									[Local attribute(15778):reflaxe.elixir.helpers.ComponentAttribute:reflaxe.elixir.helpers.ComponentAttribute]
			[Return:Dynamic] [Local attributes(15761):Array<reflaxe.elixir.helpers.ComponentAttribute>:Array<reflaxe.elixir.helpers.ComponentAttribute>]

	static function extractComponentSlots[Function:(meta : Null<haxe.macro.MetaAccess>) -> Array<reflaxe.elixir.helpers.ComponentSlot>]
		[Arg:Null<haxe.macro.MetaAccess>] [Local meta(15826):Null<haxe.macro.MetaAccess>]
		[Block:Dynamic]
			[Var slots(15827):Array<reflaxe.elixir.helpers.ComponentSlot>] [ArrayDecl:Array<reflaxe.elixir.helpers.ComponentSlot>]
			[If:Void]
				[Binop:Bool]
					[Local meta(15826):Null<haxe.macro.MetaAccess>:Null<haxe.macro.MetaAccess>]
					==
					[Const:Null<haxe.macro.MetaAccess>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local slots(15827):Array<reflaxe.elixir.helpers.ComponentSlot>:Array<reflaxe.elixir.helpers.ComponentSlot>]
			[Var slotMeta(15828):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Local meta(15826):Null<haxe.macro.MetaAccess>:Null<haxe.macro.MetaAccess>]
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":slot"
			[Block:Void]
				[Var `(15843):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(15843):Int:Int]
						<
						[Field:Int]
							[Local slotMeta(15828):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
							[FInstance:Int]
								Array<haxe.macro.MetadataEntry>
								length:Int
					[Block:Void]
						[Var slot(15829):haxe.macro.MetadataEntry]
							[Array:haxe.macro.MetadataEntry]
								[Local slotMeta(15828):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
								[Local `(15843):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(15843):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Field:Null<Array<haxe.macro.Expr>>]
										[Local slot(15829):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
										[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
									!=
									[Const:Null<Array<haxe.macro.Expr>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Field:Null<Array<haxe.macro.Expr>>]
											[Local slot(15829):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
											[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
										[FInstance:Int]
											Array<haxe.macro.Expr>
											length:Int
									>=
									[Const:Int] 1
							[Then:Int] [Block:Int]
								[Var name(15830):String]
									[Call:String]
										[Field:(expr : haxe.macro.Expr) -> String]
											[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
											[FStatic:(expr : haxe.macro.Expr) -> String]
												reflaxe.elixir.helpers.AnnotationSystem
												extractStringParam:(expr : haxe.macro.Expr) -> String
										[Array:haxe.macro.Expr]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Local slot(15829):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											[Const:Int] 0
								[Var options(15831):Null<Null<haxe.macro.Expr>>]
									[If:Null<haxe.macro.Expr>]
										[Binop:Bool]
											[Field:Int]
												[Field:Null<Array<haxe.macro.Expr>>]
													[Local slot(15829):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
													[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
												[FInstance:Int]
													Array<haxe.macro.Expr>
													length:Int
											>
											[Const:Int] 1
										[Then:haxe.macro.Expr] [Block:haxe.macro.Expr]
											[Array:haxe.macro.Expr]
												[Field:Null<Array<haxe.macro.Expr>>]
													[Local slot(15829):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
													[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
												[Const:Int] 1
										[Else:Null<Null<haxe.macro.Expr>>] [Block:Null<Null<haxe.macro.Expr>>] [Const:Null<Null<haxe.macro.Expr>>] null
								[Var slotDef(15832):reflaxe.elixir.helpers.ComponentSlot]
									[ObjectDecl:{ required : Bool, name : String }]
										name: [Local name(15830):String:String]
										required: [Const:Bool] false
								[If:Void]
									[Binop:Bool]
										[Local options(15831):Null<Null<haxe.macro.Expr>>:Null<Null<haxe.macro.Expr>>]
										!=
										[Const:Null<Null<haxe.macro.Expr>>] null
									[Then:Void] [Block:Void]
										[Meta:Void]
											:ast(switch (options.expr) {
	case EObjectDecl(fields):
		for (field  in  fields) {
			if (field.field == "required") {
				slotDef.required = extractBoolParam(field.expr);
			};
		};	
	case _:
})
											[Block:Void]
												[Var `(15838):haxe.macro.ExprDef]
													[Field:haxe.macro.ExprDef]
														[Local options(15831):Null<Null<haxe.macro.Expr>>:Null<Null<haxe.macro.Expr>>]
														[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
												[If:Void]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(15838):haxe.macro.ExprDef:haxe.macro.ExprDef]
														==
														[Const:Int] 5
													[Then:Void] [Block:Void]
														[Var `(15839):Array<haxe.macro.ObjectField>]
															[EnumParameter:Array<haxe.macro.ObjectField>]
																[Local `(15838):haxe.macro.ExprDef:haxe.macro.ExprDef]
																EObjectDecl
																0
														[Block:Void]
															[Var fields(15840):Array<haxe.macro.ObjectField>] [Local `(15839):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
															[Block:Void]
																[Block:Void]
																	[Var `(15841):Int] [Const:Int] 0
																	[While:Void]
																		[Binop:Bool]
																			[Local `(15841):Int:Int]
																			<
																			[Field:Int]
																				[Local fields(15840):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
																				[FInstance:Int]
																					Array<haxe.macro.ObjectField>
																					length:Int
																		[Block:Void]
																			[Var field(15842):haxe.macro.ObjectField]
																				[Array:haxe.macro.ObjectField]
																					[Local fields(15840):Array<haxe.macro.ObjectField>:Array<haxe.macro.ObjectField>]
																					[Local `(15841):Int:Int]
																			[Unop:Int]
																				++
																				Prefix
																				[Local `(15841):Int:Int]
																			[If:Void]
																				[Binop:Bool]
																					[Field:String]
																						[Local field(15842):haxe.macro.ObjectField:haxe.macro.ObjectField]
																						[FAnon:String] field:String
																					==
																					[Const:String] "required"
																				[Then:Bool] [Block:Bool]
																					[Binop:Bool]
																						[Field:Bool]
																							[Local slotDef(15832):reflaxe.elixir.helpers.ComponentSlot:reflaxe.elixir.helpers.ComponentSlot]
																							[FAnon:Bool] required:Bool
																						=
																						[Call:Bool]
																							[Field:(expr : haxe.macro.Expr) -> Bool]
																								[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																								[FStatic:(expr : haxe.macro.Expr) -> Bool]
																									reflaxe.elixir.helpers.AnnotationSystem
																									extractBoolParam:(expr : haxe.macro.Expr) -> Bool
																							[Field:haxe.macro.Expr]
																								[Local field(15842):haxe.macro.ObjectField:haxe.macro.ObjectField]
																								[FAnon:haxe.macro.Expr] expr:haxe.macro.Expr
													[Else:Void] [Block:Void]
								[Call:Int]
									[Field:(x : reflaxe.elixir.helpers.ComponentSlot) -> Int]
										[Local slots(15827):Array<reflaxe.elixir.helpers.ComponentSlot>:Array<reflaxe.elixir.helpers.ComponentSlot>]
										[FInstance:(x : reflaxe.elixir.helpers.ComponentSlot) -> Int]
											Array<reflaxe.elixir.helpers.ComponentSlot>
											push:(x : Array.T) -> Int
									[Local slotDef(15832):reflaxe.elixir.helpers.ComponentSlot:reflaxe.elixir.helpers.ComponentSlot]
			[Return:Dynamic] [Local slots(15827):Array<reflaxe.elixir.helpers.ComponentSlot>:Array<reflaxe.elixir.helpers.ComponentSlot>]

	static function extractStringParam[Function:(expr : haxe.macro.Expr) -> String]
		[Arg:haxe.macro.Expr] [Local expr(15764):haxe.macro.Expr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case EConst(CString(s, _)):
		s;	
	case _:
		"";	
})
					[Block:String]
						[Var `(15770):haxe.macro.ExprDef]
							[Field:haxe.macro.ExprDef]
								[Local expr(15764):haxe.macro.Expr:haxe.macro.Expr]
								[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(15770):haxe.macro.ExprDef:haxe.macro.ExprDef]
								==
								[Const:Int] 0
							[Then:String] [Block:String]
								[Var `(15771):haxe.macro.Constant]
									[EnumParameter:haxe.macro.Constant]
										[Local `(15770):haxe.macro.ExprDef:haxe.macro.ExprDef]
										EConst
										0
								[If:String]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(15771):haxe.macro.Constant:haxe.macro.Constant]
										==
										[Const:Int] 2
									[Then:String] [Block:String]
										[Var `(15772):String]
											[EnumParameter:String]
												[Local `(15771):haxe.macro.Constant:haxe.macro.Constant]
												CString
												0
										[Var `(15773):Null<haxe.macro.StringLiteralKind>]
											[EnumParameter:Null<haxe.macro.StringLiteralKind>]
												[Local `(15771):haxe.macro.Constant:haxe.macro.Constant]
												CString
												1
										[Block:String]
											[Var s(15774):String] [Local `(15772):String:String]
											[Block:String] [Local s(15774):String:String]
									[Else:String] [Block:String] [Const:String] ""
							[Else:String] [Block:String] [Const:String] ""

	static function extractBoolParam[Function:(expr : haxe.macro.Expr) -> Bool]
		[Arg:haxe.macro.Expr] [Local expr(15781):haxe.macro.Expr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case EConst(CIdent("true")):
		true;	
	case EConst(CIdent("false")):
		false;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(15785):haxe.macro.ExprDef]
							[Field:haxe.macro.ExprDef]
								[Local expr(15781):haxe.macro.Expr:haxe.macro.Expr]
								[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(15785):haxe.macro.ExprDef:haxe.macro.ExprDef]
								==
								[Const:Int] 0
							[Then:Bool] [Block:Bool]
								[Var `(15786):haxe.macro.Constant]
									[EnumParameter:haxe.macro.Constant]
										[Local `(15785):haxe.macro.ExprDef:haxe.macro.ExprDef]
										EConst
										0
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(15786):haxe.macro.Constant:haxe.macro.Constant]
										==
										[Const:Int] 3
									[Then:Bool] [Block:Bool]
										[Var `(15787):String]
											[EnumParameter:String]
												[Local `(15786):haxe.macro.Constant:haxe.macro.Constant]
												CIdent
												0
										[Switch:Bool]
											[Local `(15787):String:String]
											[Case:Bool]
												[Const:String] "false"
												[Block:Bool] [Block:Bool] [Const:Bool] false
											[Case:Bool]
												[Const:String] "true"
												[Block:Bool] [Block:Bool] [Const:Bool] true
											[Default:Bool] [Block:Bool] [Const:Bool] false
									[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Const:Bool] false

	static function extractValueParam[Function:(expr : haxe.macro.Expr) -> String]
		[Arg:haxe.macro.Expr] [Local expr(15788):haxe.macro.Expr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case EConst(CString(s, _)):
		"\"${s}\"";	
	case EConst(CInt(i)):
		Std.string(i);	
	case EConst(CFloat(f)):
		f;	
	case EConst(CIdent("true")):
		"true";	
	case EConst(CIdent("false")):
		"false";	
	case EConst(CIdent("nil")):
		"nil";	
	case _:
		"nil";	
})
					[Block:String]
						[Var `(15801):haxe.macro.ExprDef]
							[Field:haxe.macro.ExprDef]
								[Local expr(15788):haxe.macro.Expr:haxe.macro.Expr]
								[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(15801):haxe.macro.ExprDef:haxe.macro.ExprDef]
								==
								[Const:Int] 0
							[Then:String] [Block:String]
								[Var `(15802):haxe.macro.Constant]
									[EnumParameter:haxe.macro.Constant]
										[Local `(15801):haxe.macro.ExprDef:haxe.macro.ExprDef]
										EConst
										0
								[Switch:String]
									[EnumIndex:Int] [Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
									[Case:String]
										[Const:Int] 0
										[Block:String]
											[Var `(15803):String]
												[EnumParameter:String]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CInt
													0
											[Var `(15804):Null<String>]
												[EnumParameter:Null<String>]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CInt
													1
											[Block:String]
												[Var i(15805):String] [Local `(15803):String:String]
												[Block:String]
													[Call:String]
														[Field:(s : Dynamic) -> String]
															[TypeExpr Std:Class<Std>]
															[FStatic:(s : Dynamic) -> String]
																Std
																string:(s : Dynamic) -> String
														[Local i(15805):String:String]
									[Case:String]
										[Const:Int] 1
										[Block:String]
											[Var `(15806):String]
												[EnumParameter:String]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CFloat
													0
											[Var `(15807):Null<String>]
												[EnumParameter:Null<String>]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CFloat
													1
											[Block:String]
												[Var f(15808):String] [Local `(15806):String:String]
												[Block:String] [Local f(15808):String:String]
									[Case:String]
										[Const:Int] 2
										[Block:String]
											[Var `(15809):String]
												[EnumParameter:String]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CString
													0
											[Var `(15810):Null<haxe.macro.StringLiteralKind>]
												[EnumParameter:Null<haxe.macro.StringLiteralKind>]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CString
													1
											[Block:String]
												[Var s(15811):String] [Local `(15809):String:String]
												[Block:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "\""
															+
															[Local s(15811):String:String]
														+
														[Const:String] "\""
									[Case:String]
										[Const:Int] 3
										[Block:String]
											[Var `(15812):String]
												[EnumParameter:String]
													[Local `(15802):haxe.macro.Constant:haxe.macro.Constant]
													CIdent
													0
											[Switch:String]
												[Local `(15812):String:String]
												[Case:String]
													[Const:String] "false"
													[Block:String] [Block:String] [Const:String] "false"
												[Case:String]
													[Const:String] "nil"
													[Block:String] [Block:String] [Const:String] "nil"
												[Case:String]
													[Const:String] "true"
													[Block:String] [Block:String] [Const:String] "true"
												[Default:String] [Block:String] [Const:String] "nil"
									[Default:String] [Block:String] [Const:String] "nil"
							[Else:String] [Block:String] [Const:String] "nil"

	static function compileChangesetClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(16713):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(16714):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(16715):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(16716):String]
				[Field:String]
					[Local classType(16713):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(16723):{ schema : String }]
				[Call:Dynamic]
					[Field:(classType : Dynamic) -> Dynamic]
						[TypeExpr reflaxe.elixir.helpers.ChangesetCompiler:Class<reflaxe.elixir.helpers.ChangesetCompiler>]
						[FStatic:(classType : Dynamic) -> Dynamic]
							reflaxe.elixir.helpers.ChangesetCompiler
							getChangesetConfig:(classType : Dynamic) -> Dynamic
					[Local classType(16713):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(className : String, schemaName : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.ChangesetCompiler:Class<reflaxe.elixir.helpers.ChangesetCompiler>]
						[FStatic:(className : String, schemaName : String) -> String]
							reflaxe.elixir.helpers.ChangesetCompiler
							compileFullChangeset:(className : String, schemaName : String) -> String
					[Local className(16716):String:String]
					[Field:String]
						[Local config(16723):{ schema : String }:{ schema : String }]
						[FAnon:String] schema:String

	static function compileLiveViewClass[Function:(classType : haxe.macro.ClassType, varFields : Array<reflaxe.data.ClassVarData>, funcFields : Array<reflaxe.data.ClassFuncData>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(17091):haxe.macro.ClassType]
		[Arg:Array<reflaxe.data.ClassVarData>] [Local varFields(17092):Array<reflaxe.data.ClassVarData>]
		[Arg:Array<reflaxe.data.ClassFuncData>] [Local funcFields(17093):Array<reflaxe.data.ClassFuncData>]
		[Block:Dynamic]
			[Var className(17094):String]
				[Field:String]
					[Local classType(17091):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var config(17095):Unknown<34>]
				[Call:Dynamic]
					[Field:(classType : Dynamic) -> Dynamic]
						[TypeExpr reflaxe.elixir.LiveViewCompiler:Class<reflaxe.elixir.LiveViewCompiler>]
						[FStatic:(classType : Dynamic) -> Dynamic]
							reflaxe.elixir.LiveViewCompiler
							getLiveViewConfig:(classType : Dynamic) -> Dynamic
					[Local classType(17091):haxe.macro.ClassType:haxe.macro.ClassType]
			[Return:Dynamic]
				[Call:String]
					[Field:(className : String, config : Dynamic, ?varFields : Null<Array<reflaxe.data.ClassVarData>>, ?funcFields : Null<Array<reflaxe.data.ClassFuncData>>) -> String]
						[TypeExpr reflaxe.elixir.LiveViewCompiler:Class<reflaxe.elixir.LiveViewCompiler>]
						[FStatic:(className : String, config : Dynamic, ?varFields : Null<Array<reflaxe.data.ClassVarData>>, ?funcFields : Null<Array<reflaxe.data.ClassFuncData>>) -> String]
							reflaxe.elixir.LiveViewCompiler
							compileFullLiveView:(className : String, config : Dynamic, ?varFields : Null<Array<reflaxe.data.ClassVarData>>, ?funcFields : Null<Array<reflaxe.data.ClassFuncData>>) -> String
					[Local className(17094):String:String]
					[Local config(17095):Unknown<34>:Unknown<34>]
					[Local varFields(17092):Array<reflaxe.data.ClassVarData>:Array<reflaxe.data.ClassVarData>]
					[Local funcFields(17093):Array<reflaxe.data.ClassFuncData>:Array<reflaxe.data.ClassFuncData>]
}