class reflaxe.elixir.helpers.LoopCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(28387):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.LoopCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.LoopCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(28387):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileForLoop[Function:(tvar : haxe.macro.TVar, iterExpr : haxe.macro.TypedExpr, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TVar] [Local tvar(20238):haxe.macro.TVar]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20239):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20240):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var loopVar(20241):String]
				[Call:String]
					[Field:(v : haxe.macro.TVar) -> String]
						[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
						[FStatic:(v : haxe.macro.TVar) -> String]
							reflaxe.elixir.helpers.CompilerUtilities
							toElixirVarName:(v : haxe.macro.TVar) -> String
					[Local tvar(20238):haxe.macro.TVar:haxe.macro.TVar]
			[Var reflectFieldsResult(20487):Null<String>]
				[Call:Null<String>]
					[Field:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							detectReflectFieldsPattern:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>
					[Local iterExpr(20239):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20241):String:String]
					[Local blockExpr(20240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local reflectFieldsResult(20487):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local reflectFieldsResult(20487):Null<String>:Null<String>]
			[Var arrayOptimization(20828):Null<String>]
				[Call:Null<String>]
					[Field:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							tryOptimizeArrayIteration:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>
					[Local iterExpr(20239):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20241):String:String]
					[Local blockExpr(20240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local arrayOptimization(20828):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local arrayOptimization(20828):Null<String>:Null<String>]
			[Var rangeOptimization(20841):Null<String>]
				[Call:Null<String>]
					[Field:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							tryOptimizeRangeIteration:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>
					[Local iterExpr(20239):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20241):String:String]
					[Local blockExpr(20240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local rangeOptimization(20841):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local rangeOptimization(20841):Null<String>:Null<String>]
			[Var result(20847):String]
				[Call:String]
					[Field:(loopVar : String, iterExpr : haxe.macro.TypedExpr, blockExpr : haxe.macro.TypedExpr) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(loopVar : String, iterExpr : haxe.macro.TypedExpr, blockExpr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							compileGenericForLoop:(loopVar : String, iterExpr : haxe.macro.TypedExpr, blockExpr : haxe.macro.TypedExpr) -> String
					[Local loopVar(20241):String:String]
					[Local iterExpr(20239):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local blockExpr(20240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[Return:Dynamic] [Local result(20847):String:String]

	function detectReflectFieldsPattern[Function:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20242):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(20243):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20244):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var sourceObject(20258):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							extractReflectFieldsSource:(expr : haxe.macro.TypedExpr) -> Null<String>
					[Local iterExpr(20242):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local sourceObject(20258):Null<String>:Null<String>]
					==
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Var targetObject(20281):Null<String>]
				[Call:Null<String>]
					[Field:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							detectFieldCopyingTarget:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>
					[Local blockExpr(20244):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20243):String:String]
			[If:Void]
				[Binop:Bool]
					[Local targetObject(20281):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var result(20486):String]
						[Call:String]
							[Field:(fieldVar : String, sourceObject : String, blockExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(fieldVar : String, sourceObject : String, blockExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									compileReflectFieldsIteration:(fieldVar : String, sourceObject : String, blockExpr : haxe.macro.TypedExpr) -> String
							[Local loopVar(20243):String:String]
							[Local sourceObject(20258):Null<String>:Null<String>]
							[Local blockExpr(20244):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Return:Dynamic] [Local result(20486):String:String]
			[Return:Dynamic] [Const:Null<String>] null

	function extractReflectFieldsSource[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(20245):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TCall(e, el) if (el.length == 1):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.fields") {
			compiler.compileExpression(el[0]);
		} else {
			null;
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(20252):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20245):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20252):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 9
							[Then:Null<String>] [Block:Null<String>]
								[Var `(20253):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20252):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20254):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20252):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Null<String>]
									[Var e(20255):haxe.macro.TypedExpr] [Local `(20253):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20256):Array<haxe.macro.TypedExpr>] [Local `(20254):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[If:Null<String>]
										[Binop:Bool]
											[Field:Int]
												[Local el(20256):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 1
										[Then:Null<String>] [Block:Null<String>]
											[Var callTarget(20257):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.LoopCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Local e(20255):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Const:Null<Bool>] null
											[If:Null<String>]
												[Binop:Bool]
													[Local callTarget(20257):Null<String>:Null<String>]
													==
													[Const:String] "Reflect.fields"
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20256):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 0
														[Const:Null<Bool>] null
												[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
										[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function detectFieldCopyingTarget[Function:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20259):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20260):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (blockExpr.expr) {
	case TBlock(exprs):
		if (exprs.length > 0) {
			detectSetFieldTarget(exprs[0], fieldVar);
		} else {
			null;
		};	
	case _:
		detectSetFieldTarget(blockExpr, fieldVar);	
})
					[Block:Null<String>]
						[Var `(20278):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local blockExpr(20259):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20278):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 14
							[Then:Null<String>] [Block:Null<String>]
								[Var `(20279):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20278):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Null<String>]
									[Var exprs(20280):Array<haxe.macro.TypedExpr>] [Local `(20279):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Null<String>]
										[If:Null<String>]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(20280):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 0
											[Then:Null<String>] [Block:Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
															reflaxe.elixir.helpers.LoopCompiler
															detectSetFieldTarget:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local exprs(20280):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Local fieldVar(20260):String:String]
											[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
										[Const:reflaxe.elixir.helpers.LoopCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
											reflaxe.elixir.helpers.LoopCompiler
											detectSetFieldTarget:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>
									[Local blockExpr(20259):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local fieldVar(20260):String:String]

	function detectSetFieldTarget[Function:(expr : haxe.macro.TypedExpr, fieldVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(20262):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20263):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TCall(e, el) if (el.length == 3):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.setField") {
			compiler.compileExpression(el[0]);
		} else {
			null;
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(20270):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20262):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20270):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 9
							[Then:Null<String>] [Block:Null<String>]
								[Var `(20271):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20270):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20272):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20270):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Null<String>]
									[Var e(20273):haxe.macro.TypedExpr] [Local `(20271):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20274):Array<haxe.macro.TypedExpr>] [Local `(20272):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[If:Null<String>]
										[Binop:Bool]
											[Field:Int]
												[Local el(20274):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 3
										[Then:Null<String>] [Block:Null<String>]
											[Var callTarget(20275):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.LoopCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Local e(20273):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Const:Null<Bool>] null
											[If:Null<String>]
												[Binop:Bool]
													[Local callTarget(20275):Null<String>:Null<String>]
													==
													[Const:String] "Reflect.setField"
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20274):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 0
														[Const:Null<Bool>] null
												[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
										[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	public function compileReflectFieldsIteration[Function:(fieldVar : String, sourceObject : String, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local fieldVar(20282):String]
		[Arg:String] [Local sourceObject(20283):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20284):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var transformationType(20360):{ type : String, target : String }]
				[Call:{ type : String, target : String }]
					[Field:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeReflectFieldsTransformation:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }
					[Local blockExpr(20284):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldVar(20282):String:String]
					[Local sourceObject(20283):String:String]
			[Var result(20485):String]
				[Meta:String]
					:ast(switch (transformationType.type) {
	case "simple_copy":
		"Map.merge(${transformationType.target}, ${sourceObject})";	
	case "conditional_copy":
		generateConditionalFieldCopy(sourceObject, transformationType.target, blockExpr, fieldVar);	
	case "transform_copy":
		generateTransformFieldCopy(sourceObject, transformationType.target, blockExpr, fieldVar);	
	case "complex":
		generateExplicitFieldIteration(sourceObject, blockExpr, fieldVar);	
	case _:
		generateExplicitFieldIteration(sourceObject, blockExpr, fieldVar);	
})
					[Block:String]
						[Var `(20484):String]
							[Field:String]
								[Local transformationType(20360):{ type : String, target : String }:{ type : String, target : String }]
								[FAnon:String] type:String
						[Switch:String]
							[Local `(20484):String:String]
							[Case:String]
								[Const:String] "complex"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
													reflaxe.elixir.helpers.LoopCompiler
													generateExplicitFieldIteration:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String
											[Local sourceObject(20283):String:String]
											[Local blockExpr(20284):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local fieldVar(20282):String:String]
							[Case:String]
								[Const:String] "conditional_copy"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
													reflaxe.elixir.helpers.LoopCompiler
													generateConditionalFieldCopy:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String
											[Local sourceObject(20283):String:String]
											[Field:String]
												[Local transformationType(20360):{ type : String, target : String }:{ type : String, target : String }]
												[FAnon:String] target:String
											[Local blockExpr(20284):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local fieldVar(20282):String:String]
							[Case:String]
								[Const:String] "simple_copy"
								[Block:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Map.merge("
														+
														[Field:String]
															[Local transformationType(20360):{ type : String, target : String }:{ type : String, target : String }]
															[FAnon:String] target:String
													+
													[Const:String] ", "
												+
												[Local sourceObject(20283):String:String]
											+
											[Const:String] ")"
							[Case:String]
								[Const:String] "transform_copy"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
													reflaxe.elixir.helpers.LoopCompiler
													generateTransformFieldCopy:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String
											[Local sourceObject(20283):String:String]
											[Field:String]
												[Local transformationType(20360):{ type : String, target : String }:{ type : String, target : String }]
												[FAnon:String] target:String
											[Local blockExpr(20284):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local fieldVar(20282):String:String]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
											[Const:reflaxe.elixir.helpers.LoopCompiler] this
											[FInstance:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
												reflaxe.elixir.helpers.LoopCompiler
												generateExplicitFieldIteration:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String
										[Local sourceObject(20283):String:String]
										[Local blockExpr(20284):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local fieldVar(20282):String:String]
			[Return:Dynamic] [Local result(20485):String:String]

	function analyzeReflectFieldsTransformation[Function:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20285):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20286):String]
		[Arg:String] [Local sourceObject(20287):String]
		[Block:Dynamic]
			[Var result(20288):{ type : String, target : String }]
				[ObjectDecl:{ type : String, target : String }]
					type: [Const:String] "complex"
					target: [Const:String] ""
			[Meta:Void]
				:ast(switch (blockExpr.expr) {
	case TBlock(exprs) if (exprs.length == 1):
		result = analyzeReflectFieldStatement(exprs[0], fieldVar, sourceObject);	
	case TBlock(exprs) if (exprs.length > 1):
		result.type = "complex";	
	case _:
		result = analyzeReflectFieldStatement(blockExpr, fieldVar, sourceObject);	
})
				[Block:Void]
					[Var `(20356):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local blockExpr(20285):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(20356):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 14
						[Then:Void] [Block:Void]
							[Var `(20357):Array<haxe.macro.TypedExpr>]
								[EnumParameter:Array<haxe.macro.TypedExpr>]
									[Local `(20356):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBlock
									0
							[Block:Void]
								[Var exprs(20358):Array<haxe.macro.TypedExpr>] [Local `(20357):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[If:Void]
									[Binop:Bool]
										[Field:Int]
											[Local exprs(20358):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
										==
										[Const:Int] 1
									[Then:{ type : String, target : String }] [Block:{ type : String, target : String }]
										[Binop:{ type : String, target : String }]
											[Local result(20288):{ type : String, target : String }:{ type : String, target : String }]
											=
											[Call:{ type : String, target : String }]
												[Field:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
														reflaxe.elixir.helpers.LoopCompiler
														analyzeReflectFieldStatement:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }
												[Array:haxe.macro.TypedExpr]
													[Local exprs(20358):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[Const:Int] 0
												[Local fieldVar(20286):String:String]
												[Local sourceObject(20287):String:String]
									[Else:Void] [Block:Void]
										[Var exprs(20359):Array<haxe.macro.TypedExpr>] [Local `(20357):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Void]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(20359):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 1
											[Then:String] [Block:String]
												[Binop:String]
													[Field:String]
														[Local result(20288):{ type : String, target : String }:{ type : String, target : String }]
														[FAnon:String] type:String
													=
													[Const:String] "complex"
											[Else:{ type : String, target : String }] [Block:{ type : String, target : String }]
												[Binop:{ type : String, target : String }]
													[Local result(20288):{ type : String, target : String }:{ type : String, target : String }]
													=
													[Call:{ type : String, target : String }]
														[Field:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
																reflaxe.elixir.helpers.LoopCompiler
																analyzeReflectFieldStatement:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }
														[Local blockExpr(20285):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local fieldVar(20286):String:String]
														[Local sourceObject(20287):String:String]
						[Else:{ type : String, target : String }] [Block:{ type : String, target : String }]
							[Binop:{ type : String, target : String }]
								[Local result(20288):{ type : String, target : String }:{ type : String, target : String }]
								=
								[Call:{ type : String, target : String }]
									[Field:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
										[Const:reflaxe.elixir.helpers.LoopCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
											reflaxe.elixir.helpers.LoopCompiler
											analyzeReflectFieldStatement:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }
									[Local blockExpr(20285):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local fieldVar(20286):String:String]
									[Local sourceObject(20287):String:String]
			[Return:Dynamic] [Local result(20288):{ type : String, target : String }:{ type : String, target : String }]

	function analyzeReflectFieldStatement[Function:(expr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> { type : String, target : String }]
		[Arg:haxe.macro.TypedExpr] [Local expr(20290):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20291):String]
		[Arg:String] [Local sourceObject(20292):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:{ type : String, target : String }]
					:ast(switch (expr.expr) {
	case TCall(e, el) if (el.length == 3):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.setField") {
			var target = compiler.compileExpression(el[0]);
			var field = compiler.compileExpression(el[1]);
			var value = compiler.compileExpression(el[2]);
			if (isSimpleFieldCopy(field, value, fieldVar, sourceObject)) {
				{ type : "simple_copy", target : target };
			} else {
				{ type : "transform_copy", target : target };
			};
		} else {
			{ type : "complex", target : "" };
		};	
	case TIf(_, _, _):
		{ type : "conditional_copy", target : extractTargetFromConditional(expr) };	
	case _:
		{ type : "complex", target : "" };	
})
					[Block:{ type : String, target : String }]
						[Var `(20341):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20290):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:{ type : String, target : String }]
							[EnumIndex:Int] [Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:{ type : String, target : String }]
								[Const:Int] 9
								[Block:{ type : String, target : String }]
									[Var `(20342):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(20343):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:{ type : String, target : String }]
										[Var e(20344):haxe.macro.TypedExpr] [Local `(20342):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var el(20345):Array<haxe.macro.TypedExpr>] [Local `(20343):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:{ type : String, target : String }]
											[Binop:Bool]
												[Field:Int]
													[Local el(20345):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												==
												[Const:Int] 3
											[Then:{ type : String, target : String }] [Block:{ type : String, target : String }]
												[Var callTarget(20346):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local e(20344):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
												[If:{ type : String, target : String }]
													[Binop:Bool]
														[Local callTarget(20346):Null<String>:Null<String>]
														==
														[Const:String] "Reflect.setField"
													[Then:{ type : String, target : String }] [Block:{ type : String, target : String }]
														[Var target(20347):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local el(20345):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 0
																[Const:Null<Bool>] null
														[Var field(20348):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local el(20345):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 1
																[Const:Null<Bool>] null
														[Var value(20349):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local el(20345):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 2
																[Const:Null<Bool>] null
														[If:{ type : String, target : String }]
															[Call:Bool]
																[Field:(field : String, value : String, fieldVar : String, sourceObject : String) -> Bool]
																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																	[FInstance:(field : String, value : String, fieldVar : String, sourceObject : String) -> Bool]
																		reflaxe.elixir.helpers.LoopCompiler
																		isSimpleFieldCopy:(field : String, value : String, fieldVar : String, sourceObject : String) -> Bool
																[Local field(20348):Null<String>:Null<String>]
																[Local value(20349):Null<String>:Null<String>]
																[Local fieldVar(20291):String:String]
																[Local sourceObject(20292):String:String]
															[Then:{ type : String, target : Null<String> }] [Block:{ type : String, target : Null<String> }]
																[ObjectDecl:{ type : String, target : Null<String> }]
																	type: [Const:String] "simple_copy"
																	target: [Local target(20347):Null<String>:Null<String>]
															[Else:{ type : String, target : Null<String> }] [Block:{ type : String, target : Null<String> }]
																[ObjectDecl:{ type : String, target : Null<String> }]
																	type: [Const:String] "transform_copy"
																	target: [Local target(20347):Null<String>:Null<String>]
													[Else:{ type : String, target : String }] [Block:{ type : String, target : String }]
														[ObjectDecl:{ type : String, target : String }]
															type: [Const:String] "complex"
															target: [Const:String] ""
											[Else:{ type : String, target : String }] [Block:{ type : String, target : String }]
												[ObjectDecl:{ type : String, target : String }]
													type: [Const:String] "complex"
													target: [Const:String] ""
							[Case:{ type : String, target : String }]
								[Const:Int] 16
								[Block:{ type : String, target : String }]
									[Var `(20350):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											0
									[Var `(20351):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											1
									[Var `(20352):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20341):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											2
									[Block:{ type : String, target : String }]
										[ObjectDecl:{ type : String, target : String }]
											type: [Const:String] "conditional_copy"
											target: [Call:String]
												[Field:(expr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.LoopCompiler
														extractTargetFromConditional:(expr : haxe.macro.TypedExpr) -> String
												[Local expr(20290):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Default:{ type : String, target : String }]
								[Block:{ type : String, target : String }]
									[ObjectDecl:{ type : String, target : String }]
										type: [Const:String] "complex"
										target: [Const:String] ""

	function isSimpleFieldCopy[Function:(field : String, value : String, fieldVar : String, sourceObject : String) -> Bool]
		[Arg:String] [Local field(20299):String]
		[Arg:String] [Local value(20300):String]
		[Arg:String] [Local fieldVar(20301):String]
		[Arg:String] [Local sourceObject(20302):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local field(20299):String:String]
						==
						[Local fieldVar(20301):String:String]
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local value(20300):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "Reflect.field("
											+
											[Local sourceObject(20302):String:String]
										+
										[Const:String] ", "
									+
									[Local fieldVar(20301):String:String]
								+
								[Const:String] ")"
							[Const:Null<Int>] null
						>=
						[Const:Int] 0

	function extractTargetFromConditional[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(20303):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TIf(_, thenExpr, elseExpr):
		var target = findSetFieldTarget(thenExpr);
		if (target != null) return target;
		if (elseExpr != null) {
			target = findSetFieldTarget(elseExpr);
			if (target != null) return target;
		};	
	case _:
})
				[Block:Void]
					[Var `(20328):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(20303):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(20328):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 16
						[Then:Void] [Block:Void]
							[Var `(20329):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(20328):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TIf
									0
							[Var `(20330):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(20328):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TIf
									1
							[Var `(20331):Null<haxe.macro.TypedExpr>]
								[EnumParameter:Null<haxe.macro.TypedExpr>]
									[Local `(20328):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TIf
									2
							[Block:Void]
								[Var thenExpr(20332):haxe.macro.TypedExpr] [Local `(20330):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[Var elseExpr(20333):Null<haxe.macro.TypedExpr>] [Local `(20331):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
								[Block:Void]
									[Var target(20334):Null<String>]
										[Call:Null<String>]
											[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
													reflaxe.elixir.helpers.LoopCompiler
													findSetFieldTarget:(expr : haxe.macro.TypedExpr) -> Null<String>
											[Local thenExpr(20332):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[If:Void]
										[Binop:Bool]
											[Local target(20334):Null<String>:Null<String>]
											!=
											[Const:Null<String>] null
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local target(20334):Null<String>:Null<String>]
									[If:Void]
										[Binop:Bool]
											[Local elseExpr(20333):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											!=
											[Const:Null<haxe.macro.TypedExpr>] null
										[Then:Void] [Block:Void]
											[Binop:Null<String>]
												[Local target(20334):Null<String>:Null<String>]
												=
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
															reflaxe.elixir.helpers.LoopCompiler
															findSetFieldTarget:(expr : haxe.macro.TypedExpr) -> Null<String>
													[Local elseExpr(20333):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[If:Void]
												[Binop:Bool]
													[Local target(20334):Null<String>:Null<String>]
													!=
													[Const:Null<String>] null
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local target(20334):Null<String>:Null<String>]
						[Else:Void] [Block:Void]
			[Return:Dynamic] [Const:String] ""

	function findSetFieldTarget[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(20306):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TCall(e, el) if (el.length == 3):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.setField") {
			compiler.compileExpression(el[0]);
		} else {
			null;
		};	
	case TBlock(exprs):
		if (exprs.length > 0) {
			findSetFieldTarget(exprs[0]);
		} else {
			null;
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(20315):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20306):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Null<String>]
							[EnumIndex:Int] [Local `(20315):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Null<String>]
								[Const:Int] 9
								[Block:Null<String>]
									[Var `(20316):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20315):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(20317):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20315):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:Null<String>]
										[Var e(20318):haxe.macro.TypedExpr] [Local `(20316):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var el(20319):Array<haxe.macro.TypedExpr>] [Local `(20317):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Null<String>]
											[Binop:Bool]
												[Field:Int]
													[Local el(20319):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												==
												[Const:Int] 3
											[Then:Null<String>] [Block:Null<String>]
												[Var callTarget(20320):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local e(20318):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
												[If:Null<String>]
													[Binop:Bool]
														[Local callTarget(20320):Null<String>:Null<String>]
														==
														[Const:String] "Reflect.setField"
													[Then:Null<String>] [Block:Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.LoopCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Array:haxe.macro.TypedExpr]
																[Local el(20319):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[Const:Null<Bool>] null
													[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
											[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Case:Null<String>]
								[Const:Int] 14
								[Block:Null<String>]
									[Var `(20321):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20315):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:Null<String>]
										[Var exprs(20322):Array<haxe.macro.TypedExpr>] [Local `(20321):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:Null<String>]
											[If:Null<String>]
												[Binop:Bool]
													[Field:Int]
														[Local exprs(20322):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
													>
													[Const:Int] 0
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
																reflaxe.elixir.helpers.LoopCompiler
																findSetFieldTarget:(expr : haxe.macro.TypedExpr) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local exprs(20322):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 0
												[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Default:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function generateConditionalFieldCopy[Function:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
		[Arg:String] [Local sourceObject(20361):String]
		[Arg:String] [Local targetObject(20362):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20363):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20364):String]
		[Block:Dynamic]
			[Var condition(20400):String]
				[Call:String]
					[Field:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractFieldCondition:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String
					[Local blockExpr(20363):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldVar(20364):String:String]
			[Var transformation(20431):String]
				[Call:String]
					[Field:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractFieldTransformation:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String
					[Local blockExpr(20363):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldVar(20364):String:String]
					[Local sourceObject(20361):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "Enum.reduce(Map.keys("
																+
																[Local sourceObject(20361):String:String]
															+
															[Const:String] "), "
														+
														[Local targetObject(20362):String:String]
													+
													[Const:String] ", fn "
												+
												[Local fieldVar(20364):String:String]
											+
											[Const:String] ", acc ->\n  if "
										+
										[Local condition(20400):String:String]
									+
									[Const:String] " do\n    Map.put(acc, "
								+
								[Local fieldVar(20364):String:String]
							+
							[Const:String] ", "
						+
						[Local transformation(20431):String:String]
					+
					[Const:String] ")\n  else\n    acc\n  end\nend)"

	function generateTransformFieldCopy[Function:(sourceObject : String, targetObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
		[Arg:String] [Local sourceObject(20432):String]
		[Arg:String] [Local targetObject(20433):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20434):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20435):String]
		[Block:Dynamic]
			[Var transformation(20436):String]
				[Call:String]
					[Field:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractFieldTransformation:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String
					[Local blockExpr(20434):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local fieldVar(20435):String:String]
					[Local sourceObject(20432):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Enum.reduce(Map.keys("
														+
														[Local sourceObject(20432):String:String]
													+
													[Const:String] "), "
												+
												[Local targetObject(20433):String:String]
											+
											[Const:String] ", fn "
										+
										[Local fieldVar(20435):String:String]
									+
									[Const:String] ", acc ->\n  Map.put(acc, "
								+
								[Local fieldVar(20435):String:String]
							+
							[Const:String] ", "
						+
						[Local transformation(20436):String:String]
					+
					[Const:String] ")\nend)"

	function generateExplicitFieldIteration[Function:(sourceObject : String, blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
		[Arg:String] [Local sourceObject(20437):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20438):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20439):String]
		[Block:Dynamic]
			[Var transformedBody(20482):String]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, targetObject : String, fieldVar : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr, targetObject : String, fieldVar : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							compileReflectFieldsBody:(expr : haxe.macro.TypedExpr, targetObject : String, fieldVar : String) -> String
					[Local blockExpr(20438):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceObject(20437):String:String]
					[Local fieldVar(20439):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "Enum.each(Map.keys("
										+
										[Local sourceObject(20437):String:String]
									+
									[Const:String] "), fn "
								+
								[Local fieldVar(20439):String:String]
							+
							[Const:String] " ->\n"
						+
						[Call:String]
							[Field:(code : String, ?spaces : Int) -> String]
								[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
								[FStatic:(code : String, ?spaces : Int) -> String]
									reflaxe.elixir.helpers.CompilerUtilities
									indentCode:(code : String, ?spaces : Int) -> String
							[Local transformedBody(20482):String:String]
							[Const:Null<Int>] null
					+
					[Const:String] "\nend)"

	function extractFieldCondition[Function:(blockExpr : haxe.macro.TypedExpr, fieldVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20365):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20366):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (blockExpr.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TIf(cond, _, _):
					return compiler.compileExpression(cond);				
				case _:
			};
		};	
	case TIf(cond, _, _):
		return compiler.compileExpression(cond);	
	case _:
})
				[Block:Void]
					[Var `(20386):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local blockExpr(20365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(20386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 14
							[Block:Void]
								[Var `(20387):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Void]
									[Var exprs(20388):Array<haxe.macro.TypedExpr>] [Local `(20387):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Block:Void]
											[Var `(20389):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(20389):Int:Int]
													<
													[Field:Int]
														[Local exprs(20388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var expr(20390):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(20388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(20389):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(20389):Int:Int]
													[Meta:Void]
														:ast(switch (expr.expr) {
	case TIf(cond, _, _):
		return compiler.compileExpression(cond);	
	case _:
})
														[Block:Void]
															[Var `(20391):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local expr(20390):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Void]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(20391):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 16
																[Then:Dynamic] [Block:Dynamic]
																	[Var `(20392):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(20391):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			0
																	[Var `(20393):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(20391):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			1
																	[Var `(20394):Null<haxe.macro.TypedExpr>]
																		[EnumParameter:Null<haxe.macro.TypedExpr>]
																			[Local `(20391):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			2
																	[Block:Dynamic]
																		[Var cond(20395):haxe.macro.TypedExpr] [Local `(20392):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Return:Dynamic]
																				[Call:Null<String>]
																					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						[Field:reflaxe.elixir.ElixirCompiler]
																							[Const:reflaxe.elixir.helpers.LoopCompiler] this
																							[FInstance:reflaxe.elixir.ElixirCompiler]
																								reflaxe.elixir.helpers.LoopCompiler
																								compiler:reflaxe.elixir.ElixirCompiler
																						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							reflaxe.elixir.ElixirCompiler
																							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																					[Local cond(20395):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Const:Null<Bool>] null
																[Else:Void] [Block:Void]
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(20396):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(20397):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(20398):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(20386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var cond(20399):haxe.macro.TypedExpr] [Local `(20396):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.LoopCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local cond(20399):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
						[Default:Void] [Block:Void]
			[Return:Dynamic] [Const:String] "true"

	function extractFieldTransformation[Function:(blockExpr : haxe.macro.TypedExpr, fieldVar : String, sourceObject : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20401):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldVar(20402):String]
		[Arg:String] [Local sourceObject(20403):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (blockExpr.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			var value = extractSetFieldValue(expr);
			if (value != null) return value;
		};	
	case _:
		var value = extractSetFieldValue(blockExpr);
		if (value != null) return value;	
})
				[Block:Void]
					[Var `(20424):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local blockExpr(20401):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(20424):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 14
						[Then:Void] [Block:Void]
							[Var `(20425):Array<haxe.macro.TypedExpr>]
								[EnumParameter:Array<haxe.macro.TypedExpr>]
									[Local `(20424):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBlock
									0
							[Block:Void]
								[Var exprs(20426):Array<haxe.macro.TypedExpr>] [Local `(20425):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Block:Void]
									[Block:Void]
										[Var `(20427):Int] [Const:Int] 0
										[While:Void]
											[Binop:Bool]
												[Local `(20427):Int:Int]
												<
												[Field:Int]
													[Local exprs(20426):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var expr(20428):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local exprs(20426):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(20427):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(20427):Int:Int]
												[Var value(20429):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
																reflaxe.elixir.helpers.LoopCompiler
																extractSetFieldValue:(expr : haxe.macro.TypedExpr) -> Null<String>
														[Local expr(20428):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[If:Void]
													[Binop:Bool]
														[Local value(20429):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local value(20429):Null<String>:Null<String>]
						[Else:Void] [Block:Void]
							[Var value(20430):Null<String>]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
										[Const:reflaxe.elixir.helpers.LoopCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
											reflaxe.elixir.helpers.LoopCompiler
											extractSetFieldValue:(expr : haxe.macro.TypedExpr) -> Null<String>
									[Local blockExpr(20401):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[If:Void]
								[Binop:Bool]
									[Local value(20430):Null<String>:Null<String>]
									!=
									[Const:Null<String>] null
								[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local value(20430):Null<String>:Null<String>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] "Map.get("
								+
								[Local sourceObject(20403):String:String]
							+
							[Const:String] ", "
						+
						[Local fieldVar(20402):String:String]
					+
					[Const:String] ")"

	function extractSetFieldValue[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(20406):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TCall(e, el) if (el.length == 3):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.setField") {
			compiler.compileExpression(el[2]);
		} else {
			null;
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(20413):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20406):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 9
							[Then:Null<String>] [Block:Null<String>]
								[Var `(20414):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20415):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20413):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Null<String>]
									[Var e(20416):haxe.macro.TypedExpr] [Local `(20414):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20417):Array<haxe.macro.TypedExpr>] [Local `(20415):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[If:Null<String>]
										[Binop:Bool]
											[Field:Int]
												[Local el(20417):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 3
										[Then:Null<String>] [Block:Null<String>]
											[Var callTarget(20418):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.LoopCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Local e(20416):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Const:Null<Bool>] null
											[If:Null<String>]
												[Binop:Bool]
													[Local callTarget(20418):Null<String>:Null<String>]
													==
													[Const:String] "Reflect.setField"
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20417):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 2
														[Const:Null<Bool>] null
												[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
										[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function compileReflectFieldsBody[Function:(expr : haxe.macro.TypedExpr, targetObject : String, fieldVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(20440):haxe.macro.TypedExpr]
		[Arg:String] [Local targetObject(20441):String]
		[Arg:String] [Local fieldVar(20442):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBlock(exprs):
		var statements = [for (e  in  exprs) compileReflectFieldsStatement(e, targetObject, fieldVar)];
		statements.join("\n");	
	case _:
		compileReflectFieldsStatement(expr, targetObject, fieldVar);	
})
					[Block:String]
						[Var `(20475):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20440):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20475):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 14
							[Then:String] [Block:String]
								[Var `(20476):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20475):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:String]
									[Var exprs(20477):Array<haxe.macro.TypedExpr>] [Local `(20476):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:String]
										[Var statements(20478):Array<String>]
											[Block:Array<String>]
												[Var `(20479):Array<String>] [ArrayDecl:Array<String>]
												[Block:Void]
													[Var `(20480):Int] [Const:Int] 0
													[While:Void]
														[Binop:Bool]
															[Local `(20480):Int:Int]
															<
															[Field:Int]
																[Local exprs(20477):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
														[Block:Void]
															[Var e(20481):haxe.macro.TypedExpr]
																[Array:haxe.macro.TypedExpr]
																	[Local exprs(20477):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local `(20480):Int:Int]
															[Unop:Int]
																++
																Prefix
																[Local `(20480):Int:Int]
															[Call:Int]
																[Field:(x : String) -> Int]
																	[Local `(20479):Array<String>:Array<String>]
																	[FInstance:(x : String) -> Int]
																		Array<String>
																		push:(x : Array.T) -> Int
																[Call:String]
																	[Field:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String]
																			reflaxe.elixir.helpers.LoopCompiler
																			compileReflectFieldsStatement:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String
																	[Local e(20481):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local targetObject(20441):String:String]
																	[Local fieldVar(20442):String:String]
												[Local `(20479):Array<String>:Array<String>]
										[Call:String]
											[Field:(sep : String) -> String]
												[Local statements(20478):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] "\n"
							[Else:String] [Block:String]
								[Call:String]
									[Field:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String]
										[Const:reflaxe.elixir.helpers.LoopCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String]
											reflaxe.elixir.helpers.LoopCompiler
											compileReflectFieldsStatement:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String
									[Local expr(20440):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local targetObject(20441):String:String]
									[Local fieldVar(20442):String:String]

	function compileReflectFieldsStatement[Function:(expr : haxe.macro.TypedExpr, sourceObject : String, fieldVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(20446):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceObject(20447):String]
		[Arg:String] [Local fieldVar(20448):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TCall(e, el):
		var callTarget = compiler.compileExpression(e);
		if (callTarget == "Reflect.setField" && el.length == 3) {
			var target = compiler.compileExpression(el[0]);
			var field = compiler.compileExpression(el[1]);
			var value = compiler.compileExpression(el[2]);
			"${target} = Map.put(${target}, ${field}, ${value})";
		} else if (callTarget == "Reflect.field" && el.length == 2) {
			var obj = compiler.compileExpression(el[0]);
			var field = compiler.compileExpression(el[1]);
			"Map.get(${obj}, ${field})";
		} else {
			compiler.compileExpression(expr);
		};	
	case _:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(20460):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20446):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20460):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 9
							[Then:String] [Block:String]
								[Var `(20461):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20460):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20462):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20460):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:String]
									[Var e(20463):haxe.macro.TypedExpr] [Local `(20461):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20464):Array<haxe.macro.TypedExpr>] [Local `(20462):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:String]
										[Var callTarget(20465):Null<String>]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.LoopCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local e(20463):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Local callTarget(20465):Null<String>:Null<String>]
													==
													[Const:String] "Reflect.setField"
												&&
												[Binop:Bool]
													[Field:Int]
														[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
													==
													[Const:Int] 3
											[Then:String] [Block:String]
												[Var target(20466):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 0
														[Const:Null<Bool>] null
												[Var field(20467):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 1
														[Const:Null<Bool>] null
												[Var value(20468):Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 2
														[Const:Null<Bool>] null
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Binop:String]
																				[Const:String] ""
																				+
																				[Local target(20466):Null<String>:Null<String>]
																			+
																			[Const:String] " = Map.put("
																		+
																		[Local target(20466):Null<String>:Null<String>]
																	+
																	[Const:String] ", "
																+
																[Local field(20467):Null<String>:Null<String>]
															+
															[Const:String] ", "
														+
														[Local value(20468):Null<String>:Null<String>]
													+
													[Const:String] ")"
											[Else:String] [Block:String]
												[If:String]
													[Binop:Bool]
														[Binop:Bool]
															[Local callTarget(20465):Null<String>:Null<String>]
															==
															[Const:String] "Reflect.field"
														&&
														[Binop:Bool]
															[Field:Int]
																[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
															==
															[Const:Int] 2
													[Then:String] [Block:String]
														[Var obj(20469):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 0
																[Const:Null<Bool>] null
														[Var field(20470):Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local el(20464):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 1
																[Const:Null<Bool>] null
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "Map.get("
																		+
																		[Local obj(20469):Null<String>:Null<String>]
																	+
																	[Const:String] ", "
																+
																[Local field(20470):Null<String>:Null<String>]
															+
															[Const:String] ")"
													[Else:Null<String>] [Block:Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.LoopCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local expr(20446):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Const:Null<Bool>] null
							[Else:Null<String>] [Block:Null<String>]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.LoopCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.LoopCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											reflaxe.elixir.ElixirCompiler
											compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
									[Local expr(20446):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Const:Null<Bool>] null

	function tryOptimizeArrayIteration[Function:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20488):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(20489):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20490):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var arrayExpr(20491):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local iterExpr(20488):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
				[Call:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
					[Field:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeLoopBody:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }
					[Local blockExpr(20490):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Field:Bool]
					[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
					[FAnon:Bool] hasFinding:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Var result(20712):String]
						[Call:String]
							[Field:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									generateEnumFindPattern:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String
							[Local arrayExpr(20491):Null<String>:Null<String>]
							[Local loopVar(20489):String:String]
							[Local blockExpr(20490):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Return:Dynamic] [Local result(20712):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Bool]
						[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
						[FAnon:Bool] hasFiltering:Bool
					&&
					[Unop:Bool]
						!
						Prefix
						[Field:Bool]
							[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
							[FAnon:Bool] hasMapping:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Var result(20718):String]
						[Call:String]
							[Field:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									generateEnumFilterPattern:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String
							[Local arrayExpr(20491):Null<String>:Null<String>]
							[Local loopVar(20489):String:String]
							[Field:haxe.macro.TypedExpr]
								[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
								[FAnon:haxe.macro.TypedExpr] conditionExpr:haxe.macro.TypedExpr
					[Return:Dynamic] [Local result(20718):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Bool]
						[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
						[FAnon:Bool] hasMapping:Bool
					&&
					[Unop:Bool]
						!
						Prefix
						[Field:Bool]
							[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
							[FAnon:Bool] hasFiltering:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Var result(20821):String]
						[Call:String]
							[Field:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									generateEnumMapPattern:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String
							[Local arrayExpr(20491):Null<String>:Null<String>]
							[Local loopVar(20489):String:String]
							[Local blockExpr(20490):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Return:Dynamic] [Local result(20821):String:String]
			[If:Void]
				[Field:Bool]
					[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
					[FAnon:Bool] hasCounting:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Var result(20827):String]
						[Call:String]
							[Field:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									generateEnumCountPattern:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String
							[Local arrayExpr(20491):Null<String>:Null<String>]
							[Local loopVar(20489):String:String]
							[Field:haxe.macro.TypedExpr]
								[Local bodyAnalysis(20662):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
								[FAnon:haxe.macro.TypedExpr] conditionExpr:haxe.macro.TypedExpr
					[Return:Dynamic] [Local result(20827):String:String]
			[Return:Dynamic] [Const:Null<String>] null

	function analyzeLoopBody[Function:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20492):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var result(20493):{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }]
				[ObjectDecl:{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }]
					hasMapping: [Const:Bool] false
					hasFiltering: [Const:Bool] false
					hasFinding: [Const:Bool] false
					hasCounting: [Const:Bool] false
					hasAccumulation: [Const:Bool] false
					conditionExpr: [Const:Null<haxe.macro.TypedExpr>] null
					mappingExpr: [Const:Null<haxe.macro.TypedExpr>] null
					targetVar: [Const:String] ""
			[Call:Void]
				[Field:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
					[Const:reflaxe.elixir.helpers.LoopCompiler] this
					[FInstance:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
						reflaxe.elixir.helpers.LoopCompiler
						analyzeLoopBodyAST:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void
				[Local blockExpr(20492):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
				[Local result(20493):{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }:{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }]
			[Return:Dynamic] [Local result(20493):{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }:{ targetVar : String, mappingExpr : Null<haxe.macro.TypedExpr>, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : Null<haxe.macro.TypedExpr> }]

	function analyzeLoopBodyAST[Function:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local expr(20494):haxe.macro.TypedExpr]
		[Arg:Dynamic] [Local result(20495):Dynamic]
		[Block:Void]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) {
			analyzeLoopBodyAST(e, result);
		};	
	case TVar(tvar, valueExpr):
		if (valueExpr != null) {
			result.hasMapping = true;
			result.mappingExpr = valueExpr;
			result.targetVar = CompilerUtilities.toElixirVarName(tvar);
		};	
	case TBinop(OpAssign, e1, e2):
		analyzeAssignmentPattern(e1, e2, result);	
	case TIf(cond, thenExpr, elseExpr):
		result.hasFiltering = true;
		result.conditionExpr = cond;
		if (containsReturn(thenExpr) || (elseExpr != null && containsReturn(elseExpr))) {
			result.hasFinding = true;
		};
		analyzeLoopBodyAST(thenExpr, result);
		if (elseExpr != null) {
			analyzeLoopBodyAST(elseExpr, result);
		};	
	case TReturn(_):
		result.hasFinding = true;	
	case TCall(e, el):
		analyzeMethodCall(e, el, result);	
	case _:
})
				[Block:Void]
					[Var `(20637):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(20494):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 3
							[Block:Void]
								[Var `(20638):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(20639):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(20640):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(20638):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Void] [Block:Void]
										[Block:Void]
											[Var e1(20641):haxe.macro.TypedExpr] [Local `(20639):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e2(20642):haxe.macro.TypedExpr] [Local `(20640):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Void]
												[Call:Void]
													[Field:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, result : Dynamic) -> Void]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, result : Dynamic) -> Void]
															reflaxe.elixir.helpers.LoopCompiler
															analyzeAssignmentPattern:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, result : Dynamic) -> Void
													[Local e1(20641):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local e2(20642):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local result(20495):Dynamic:Dynamic]
									[Else:Void] [Block:Void]
						[Case:Void]
							[Const:Int] 9
							[Block:Void]
								[Var `(20643):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20644):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Void]
									[Var e(20645):haxe.macro.TypedExpr] [Local `(20643):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20646):Array<haxe.macro.TypedExpr>] [Local `(20644):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Call:Void]
											[Field:(methodExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, result : Dynamic) -> Void]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(methodExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, result : Dynamic) -> Void]
													reflaxe.elixir.helpers.LoopCompiler
													analyzeMethodCall:(methodExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, result : Dynamic) -> Void
											[Local e(20645):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local el(20646):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[Local result(20495):Dynamic:Dynamic]
						[Case:Void]
							[Const:Int] 13
							[Block:Void]
								[Var `(20647):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										0
								[Var `(20648):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										1
								[Block:Void]
									[Var tvar(20649):haxe.macro.TVar] [Local `(20647):haxe.macro.TVar:haxe.macro.TVar]
									[Var valueExpr(20650):Null<haxe.macro.TypedExpr>] [Local `(20648):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Void]
										[If:Void]
											[Binop:Bool]
												[Local valueExpr(20650):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Dynamic] [Block:Dynamic]
												[Binop:Dynamic]
													[Field:Dynamic]
														[Local result(20495):Dynamic:Dynamic]
														[FDynamic:Dynamic] hasMapping
													=
													[Const:Bool] true
												[Binop:Dynamic]
													[Field:Dynamic]
														[Local result(20495):Dynamic:Dynamic]
														[FDynamic:Dynamic] mappingExpr
													=
													[Local valueExpr(20650):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Binop:Dynamic]
													[Field:Dynamic]
														[Local result(20495):Dynamic:Dynamic]
														[FDynamic:Dynamic] targetVar
													=
													[Call:String]
														[Field:(v : haxe.macro.TVar) -> String]
															[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
															[FStatic:(v : haxe.macro.TVar) -> String]
																reflaxe.elixir.helpers.CompilerUtilities
																toElixirVarName:(v : haxe.macro.TVar) -> String
														[Local tvar(20649):haxe.macro.TVar:haxe.macro.TVar]
						[Case:Void]
							[Const:Int] 14
							[Block:Void]
								[Var `(20651):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Void]
									[Var exprs(20652):Array<haxe.macro.TypedExpr>] [Local `(20651):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Block:Void]
											[Var `(20653):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(20653):Int:Int]
													<
													[Field:Int]
														[Local exprs(20652):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(20654):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(20652):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(20653):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(20653):Int:Int]
													[Call:Void]
														[Field:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
																reflaxe.elixir.helpers.LoopCompiler
																analyzeLoopBodyAST:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void
														[Local e(20654):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local result(20495):Dynamic:Dynamic]
						[Case:Void]
							[Const:Int] 16
							[Block:Void]
								[Var `(20655):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(20656):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(20657):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Void]
									[Var cond(20658):haxe.macro.TypedExpr] [Local `(20655):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var thenExpr(20659):haxe.macro.TypedExpr] [Local `(20656):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var elseExpr(20660):Null<haxe.macro.TypedExpr>] [Local `(20657):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Void]
										[Binop:Dynamic]
											[Field:Dynamic]
												[Local result(20495):Dynamic:Dynamic]
												[FDynamic:Dynamic] hasFiltering
											=
											[Const:Bool] true
										[Binop:Dynamic]
											[Field:Dynamic]
												[Local result(20495):Dynamic:Dynamic]
												[FDynamic:Dynamic] conditionExpr
											=
											[Local cond(20658):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
													[Local thenExpr(20659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												||
												[Parenthesis:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local elseExpr(20660):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															!=
															[Const:Null<haxe.macro.TypedExpr>] null
														&&
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
															[Local elseExpr(20660):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[Then:Dynamic] [Block:Dynamic]
												[Binop:Dynamic]
													[Field:Dynamic]
														[Local result(20495):Dynamic:Dynamic]
														[FDynamic:Dynamic] hasFinding
													=
													[Const:Bool] true
										[Call:Void]
											[Field:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
													reflaxe.elixir.helpers.LoopCompiler
													analyzeLoopBodyAST:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void
											[Local thenExpr(20659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local result(20495):Dynamic:Dynamic]
										[If:Void]
											[Binop:Bool]
												[Local elseExpr(20660):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Void] [Block:Void]
												[Call:Void]
													[Field:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void]
															reflaxe.elixir.helpers.LoopCompiler
															analyzeLoopBodyAST:(expr : haxe.macro.TypedExpr, result : Dynamic) -> Void
													[Local elseExpr(20660):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													[Local result(20495):Dynamic:Dynamic]
						[Case:Dynamic]
							[Const:Int] 20
							[Block:Dynamic]
								[Var `(20661):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(20637):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TReturn
										0
								[Block:Dynamic]
									[Binop:Dynamic]
										[Field:Dynamic]
											[Local result(20495):Dynamic:Dynamic]
											[FDynamic:Dynamic] hasFinding
										=
										[Const:Bool] true
						[Default:Void] [Block:Void]

	function analyzeAssignmentPattern[Function:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, result : Dynamic) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local target(20503):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local value(20504):haxe.macro.TypedExpr]
		[Arg:Dynamic] [Local result(20505):Dynamic]
		[Block:Void]
			[Meta:Void]
				:ast(switch (value.expr) {
	case TBinop(OpAdd, e1, e2):
		if (isLiteralOne(e2) && isVariableReference(e1, target)) {
			result.hasCounting = true;
		};	
	case TCall(e, el):
		var methodName = extractMethodName(e);
		if (methodName == "push" || methodName == "concat") {
			result.hasAccumulation = true;
		};	
	case _:
})
				[Block:Void]
					[Var `(20585):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local value(20504):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 3
							[Block:Void]
								[Var `(20586):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(20587):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(20588):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(20586):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 0
									[Then:Void] [Block:Void]
										[Block:Void]
											[Var e1(20589):haxe.macro.TypedExpr] [Local `(20587):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e2(20590):haxe.macro.TypedExpr] [Local `(20588):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Void]
												[If:Void]
													[Binop:Bool]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	isLiteralOne:(expr : haxe.macro.TypedExpr) -> Bool
															[Local e2(20590):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														&&
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr, target : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, target : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	isVariableReference:(expr : haxe.macro.TypedExpr, target : haxe.macro.TypedExpr) -> Bool
															[Local e1(20589):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local target(20503):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Then:Dynamic] [Block:Dynamic]
														[Binop:Dynamic]
															[Field:Dynamic]
																[Local result(20505):Dynamic:Dynamic]
																[FDynamic:Dynamic] hasCounting
															=
															[Const:Bool] true
									[Else:Void] [Block:Void]
						[Case:Void]
							[Const:Int] 9
							[Block:Void]
								[Var `(20591):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(20592):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(20585):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Void]
									[Var e(20593):haxe.macro.TypedExpr] [Local `(20591):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var el(20594):Array<haxe.macro.TypedExpr>] [Local `(20592):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Var methodName(20595):String]
											[Call:String]
												[Field:(methodExpr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(methodExpr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.LoopCompiler
														extractMethodName:(methodExpr : haxe.macro.TypedExpr) -> String
												[Local e(20593):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local methodName(20595):String:String]
													==
													[Const:String] "push"
												||
												[Binop:Bool]
													[Local methodName(20595):String:String]
													==
													[Const:String] "concat"
											[Then:Dynamic] [Block:Dynamic]
												[Binop:Dynamic]
													[Field:Dynamic]
														[Local result(20505):Dynamic:Dynamic]
														[FDynamic:Dynamic] hasAccumulation
													=
													[Const:Bool] true
						[Default:Void] [Block:Void]

	function analyzeMethodCall[Function:(methodExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, result : Dynamic) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local methodExpr(20620):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(20621):Array<haxe.macro.TypedExpr>]
		[Arg:Dynamic] [Local result(20622):Dynamic]
		[Block:Void]
			[Var methodName(20623):String]
				[Call:String]
					[Field:(methodExpr : haxe.macro.TypedExpr) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(methodExpr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractMethodName:(methodExpr : haxe.macro.TypedExpr) -> String
					[Local methodExpr(20620):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[Meta:Void]
				:ast(switch (methodName) {
	case "push" | "concat" | "append":
		result.hasAccumulation = true;	
	case "length" | "size":
		result.hasCounting = true;	
	case _:
})
				[Switch:Void]
					[Local methodName(20623):String:String]
					[Case:Dynamic]
						[Const:String] "append"
						[Const:String] "concat"
						[Const:String] "push"
						[Block:Dynamic]
							[Block:Dynamic]
								[Binop:Dynamic]
									[Field:Dynamic]
										[Local result(20622):Dynamic:Dynamic]
										[FDynamic:Dynamic] hasAccumulation
									=
									[Const:Bool] true
					[Case:Dynamic]
						[Const:String] "length"
						[Const:String] "size"
						[Block:Dynamic]
							[Block:Dynamic]
								[Binop:Dynamic]
									[Field:Dynamic]
										[Local result(20622):Dynamic:Dynamic]
										[FDynamic:Dynamic] hasCounting
									=
									[Const:Bool] true
					[Default:Void] [Block:Void]

	function containsReturn[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(20599):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TReturn(_):
		true;	
	case TBlock(exprs):
		exprs.exists(containsReturn);	
	case TIf(_, thenExpr, elseExpr):
		containsReturn(thenExpr) || (elseExpr != null && containsReturn(elseExpr));	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(20609):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20599):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Bool]
							[EnumIndex:Int] [Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Bool]
								[Const:Int] 14
								[Block:Bool]
									[Var `(20610):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:Bool]
										[Var exprs(20611):Array<haxe.macro.TypedExpr>] [Local `(20610):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:Bool]
											[Call:Bool]
												[Field:(it : Iterable<haxe.macro.TypedExpr>, f : ((item : haxe.macro.TypedExpr) -> Bool)) -> Bool]
													[TypeExpr Lambda:{ Statics Lambda }]
													[FStatic:(it : Iterable<haxe.macro.TypedExpr>, f : ((item : haxe.macro.TypedExpr) -> Bool)) -> Bool]
														Lambda
														exists:(it : Iterable<exists.A>, f : ((item : exists.A) -> Bool)) -> Bool
												[Local exprs(20611):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FClosure:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
							[Case:Bool]
								[Const:Int] 16
								[Block:Bool]
									[Var `(20612):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											0
									[Var `(20613):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											1
									[Var `(20614):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											2
									[Block:Bool]
										[Var thenExpr(20615):haxe.macro.TypedExpr] [Local `(20613):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var elseExpr(20616):Null<haxe.macro.TypedExpr>] [Local `(20614):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										[Block:Bool]
											[Binop:Bool]
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
													[Local thenExpr(20615):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												||
												[Parenthesis:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local elseExpr(20616):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															!=
															[Const:Null<haxe.macro.TypedExpr>] null
														&&
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
															[Local elseExpr(20616):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							[Case:Bool]
								[Const:Int] 20
								[Block:Bool]
									[Var `(20617):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20609):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TReturn
											0
									[Block:Bool] [Const:Bool] true
							[Default:Bool] [Block:Bool] [Const:Bool] false

	function isLiteralOne[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(20508):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TConst(TInt(1)):
		true;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(20512):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20508):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20512):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 0
							[Then:Bool] [Block:Bool]
								[Var `(20513):haxe.macro.TConstant]
									[EnumParameter:haxe.macro.TConstant]
										[Local `(20512):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TConst
										0
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(20513):haxe.macro.TConstant:haxe.macro.TConstant]
										==
										[Const:Int] 0
									[Then:Bool] [Block:Bool]
										[Var `(20514):Int]
											[EnumParameter:Int]
												[Local `(20513):haxe.macro.TConstant:haxe.macro.TConstant]
												TInt
												0
										[If:Bool]
											[Binop:Bool]
												[Local `(20514):Int:Int]
												==
												[Const:Int] 1
											[Then:Bool] [Block:Bool] [Block:Bool] [Const:Bool] true
											[Else:Bool] [Block:Bool] [Const:Bool] false
									[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Const:Bool] false

	function isVariableReference[Function:(expr : haxe.macro.TypedExpr, target : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(20515):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local target(20516):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch ([expr.expr, target.expr]) {
	case [TLocal(v1), TLocal(v2)]:
		v1.id == v2.id;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(20523):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(20515):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Var `(20524):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local target(20516):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(20523):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 1
							[Then:Bool] [Block:Bool]
								[Var `(20525):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(20523):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[If:Bool]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(20524):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										==
										[Const:Int] 1
									[Then:Bool] [Block:Bool]
										[Var `(20526):haxe.macro.TVar]
											[EnumParameter:haxe.macro.TVar]
												[Local `(20524):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TLocal
												0
										[Block:Bool]
											[Var v2(20527):haxe.macro.TVar] [Local `(20526):haxe.macro.TVar:haxe.macro.TVar]
											[Var v1(20528):haxe.macro.TVar] [Local `(20525):haxe.macro.TVar:haxe.macro.TVar]
											[Block:Bool]
												[Binop:Bool]
													[Field:Int]
														[Local v1(20528):haxe.macro.TVar:haxe.macro.TVar]
														[FAnon:Int] id:Int
													==
													[Field:Int]
														[Local v2(20527):haxe.macro.TVar:haxe.macro.TVar]
														[FAnon:Int] id:Int
									[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool] [Const:Bool] false

	function extractMethodName[Function:(methodExpr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local methodExpr(20531):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodExpr.expr) {
	case TField(_, fa):
		CompilerUtilities.extractFieldName(fa);	
	case TLocal(v):
		CompilerUtilities.toElixirVarName(v);	
	case _:
		"";	
})
					[Block:String]
						[Var `(20572):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local methodExpr(20531):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(20572):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 1
								[Block:String]
									[Var `(20573):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(20572):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:String]
										[Var v(20574):haxe.macro.TVar] [Local `(20573):haxe.macro.TVar:haxe.macro.TVar]
										[Block:String]
											[Call:String]
												[Field:(v : haxe.macro.TVar) -> String]
													[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
													[FStatic:(v : haxe.macro.TVar) -> String]
														reflaxe.elixir.helpers.CompilerUtilities
														toElixirVarName:(v : haxe.macro.TVar) -> String
												[Local v(20574):haxe.macro.TVar:haxe.macro.TVar]
							[Case:String]
								[Const:Int] 4
								[Block:String]
									[Var `(20575):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20572):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(20576):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(20572):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:String]
										[Var fa(20577):haxe.macro.FieldAccess] [Local `(20576):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:String]
											[Call:String]
												[Field:(field : haxe.macro.FieldAccess) -> String]
													[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
													[FStatic:(field : haxe.macro.FieldAccess) -> String]
														reflaxe.elixir.helpers.CompilerUtilities
														extractFieldName:(field : haxe.macro.FieldAccess) -> String
												[Local fa(20577):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
							[Default:String] [Block:String] [Const:String] ""

	function generateEnumFindPattern[Function:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(20663):String]
		[Arg:String] [Local loopVar(20664):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20665):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var condition(20710):String]
				[Call:String]
					[Field:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractFindCondition:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String
					[Local blockExpr(20665):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20664):String:String]
			[Var result(20711):String]
				[If:String]
					[Binop:Bool]
						[Binop:Bool]
							[Field:Int]
								[Local condition(20710):String:String]
								[FInstance:Int]
									String
									length:Int
							>
							[Const:Int] 50
						||
						[Binop:Bool]
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local condition(20710):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "\n"
								[Const:Null<Int>] null
							>=
							[Const:Int] 0
					[Then:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.find("
												+
												[Local arrayExpr(20663):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20664):String:String]
									+
									[Const:String] " ->\n"
								+
								[Call:String]
									[Field:(code : String, ?spaces : Int) -> String]
										[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
										[FStatic:(code : String, ?spaces : Int) -> String]
											reflaxe.elixir.helpers.CompilerUtilities
											indentCode:(code : String, ?spaces : Int) -> String
									[Local condition(20710):String:String]
									[Const:Null<Int>] null
							+
							[Const:String] "\nend)"
					[Else:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.find("
												+
												[Local arrayExpr(20663):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20664):String:String]
									+
									[Const:String] " -> "
								+
								[Local condition(20710):String:String]
							+
							[Const:String] " end)"
			[Return:Dynamic] [Local result(20711):String:String]

	function extractFindCondition[Function:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20666):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(20667):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (blockExpr.expr) {
	case TBlock(exprs):
		extractFindConditionFromStatements(exprs, loopVar);	
	case TIf(cond, thenExpr, _):
		if (containsReturn(thenExpr)) {
			compiler.compileExpression(cond);
		} else {
			"true";
		};	
	case TReturn(valueExpr):
		if (valueExpr != null) {
			var value = compiler.compileExpression(valueExpr);
			value;
		} else {
			"true";
		};	
	case _:
		"true";	
})
					[Block:String]
						[Var `(20699):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local blockExpr(20666):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 14
								[Block:String]
									[Var `(20700):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:String]
										[Var exprs(20701):Array<haxe.macro.TypedExpr>] [Local `(20700):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:String]
											[Call:String]
												[Field:(statements : Array<haxe.macro.TypedExpr>, loopVar : String) -> String]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(statements : Array<haxe.macro.TypedExpr>, loopVar : String) -> String]
														reflaxe.elixir.helpers.LoopCompiler
														extractFindConditionFromStatements:(statements : Array<haxe.macro.TypedExpr>, loopVar : String) -> String
												[Local exprs(20701):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local loopVar(20667):String:String]
							[Case:String]
								[Const:Int] 16
								[Block:String]
									[Var `(20702):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											0
									[Var `(20703):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											1
									[Var `(20704):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TIf
											2
									[Block:String]
										[Var cond(20705):haxe.macro.TypedExpr] [Local `(20702):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var thenExpr(20706):haxe.macro.TypedExpr] [Local `(20703):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:String]
											[If:String]
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
													[Local thenExpr(20706):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local cond(20705):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
												[Else:String] [Block:String] [Const:String] "true"
							[Case:String]
								[Const:Int] 20
								[Block:String]
									[Var `(20707):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TReturn
											0
									[Block:String]
										[Var valueExpr(20708):Null<haxe.macro.TypedExpr>] [Local `(20707):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										[Block:String]
											[If:String]
												[Binop:Bool]
													[Local valueExpr(20708):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:Null<String>] [Block:Null<String>]
													[Var value(20709):Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.LoopCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local valueExpr(20708):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															[Const:Null<Bool>] null
													[Local value(20709):Null<String>:Null<String>]
												[Else:String] [Block:String] [Const:String] "true"
							[Default:String] [Block:String] [Const:String] "true"

	function extractFindConditionFromStatements[Function:(statements : Array<haxe.macro.TypedExpr>, loopVar : String) -> String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local statements(20669):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local loopVar(20670):String]
		[Block:Dynamic]
			[Block:Void]
				[Var `(20688):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(20688):Int:Int]
						<
						[Field:Int]
							[Local statements(20669):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var stmt(20671):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local statements(20669):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(20688):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(20688):Int:Int]
						[Meta:Void]
							:ast(switch (stmt.expr) {
	case TIf(cond, thenExpr, _):
		if (containsReturn(thenExpr)) {
			return compiler.compileExpression(cond);
		};	
	case TReturn(valueExpr):
		if (valueExpr != null) {
			return compiler.compileExpression(valueExpr);
		};	
	case _:
})
							[Block:Void]
								[Var `(20680):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local stmt(20671):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(20680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 16
										[Block:Void]
											[Var `(20681):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(20680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													0
											[Var `(20682):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(20680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													1
											[Var `(20683):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(20680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													2
											[Block:Void]
												[Var cond(20684):haxe.macro.TypedExpr] [Local `(20681):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var thenExpr(20685):haxe.macro.TypedExpr] [Local `(20682):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Block:Void]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsReturn:(expr : haxe.macro.TypedExpr) -> Bool
															[Local thenExpr(20685):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Then:Dynamic] [Block:Dynamic]
															[Return:Dynamic]
																[Call:Null<String>]
																	[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		[Field:reflaxe.elixir.ElixirCompiler]
																			[Const:reflaxe.elixir.helpers.LoopCompiler] this
																			[FInstance:reflaxe.elixir.ElixirCompiler]
																				reflaxe.elixir.helpers.LoopCompiler
																				compiler:reflaxe.elixir.ElixirCompiler
																		[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			reflaxe.elixir.ElixirCompiler
																			compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																	[Local cond(20684):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Const:Null<Bool>] null
									[Case:Void]
										[Const:Int] 20
										[Block:Void]
											[Var `(20686):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(20680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TReturn
													0
											[Block:Void]
												[Var valueExpr(20687):Null<haxe.macro.TypedExpr>] [Local `(20686):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:Void]
													[If:Void]
														[Binop:Bool]
															[Local valueExpr(20687):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															!=
															[Const:Null<haxe.macro.TypedExpr>] null
														[Then:Dynamic] [Block:Dynamic]
															[Return:Dynamic]
																[Call:Null<String>]
																	[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		[Field:reflaxe.elixir.ElixirCompiler]
																			[Const:reflaxe.elixir.helpers.LoopCompiler] this
																			[FInstance:reflaxe.elixir.ElixirCompiler]
																				reflaxe.elixir.helpers.LoopCompiler
																				compiler:reflaxe.elixir.ElixirCompiler
																		[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			reflaxe.elixir.ElixirCompiler
																			compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																	[Local valueExpr(20687):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																	[Const:Null<Bool>] null
									[Default:Void] [Block:Void]
			[Return:Dynamic] [Const:String] "true"

	function generateEnumCountPattern[Function:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(20822):String]
		[Arg:String] [Local loopVar(20823):String]
		[Arg:haxe.macro.TypedExpr] [Local conditionExpr(20824):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var condition(20825):Null<String>]
				[If:Null<String>]
					[Binop:Bool]
						[Local conditionExpr(20824):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						!=
						[Const:haxe.macro.TypedExpr] null
					[Then:Null<String>] [Block:Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.LoopCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.LoopCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local conditionExpr(20824):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Const:Null<Bool>] null
					[Else:String] [Block:String] [Const:String] "true"
			[Var result(20826):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "Enum.count("
										+
										[Local arrayExpr(20822):String:String]
									+
									[Const:String] ", fn "
								+
								[Local loopVar(20823):String:String]
							+
							[Const:String] " -> "
						+
						[Local condition(20825):Null<String>:Null<String>]
					+
					[Const:String] " end)"
			[Return:Dynamic] [Local result(20826):String:String]

	function generateEnumFilterPattern[Function:(arrayExpr : String, loopVar : String, conditionExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(20713):String]
		[Arg:String] [Local loopVar(20714):String]
		[Arg:haxe.macro.TypedExpr] [Local conditionExpr(20715):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var condition(20716):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local conditionExpr(20715):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var result(20717):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "Enum.filter("
										+
										[Local arrayExpr(20713):String:String]
									+
									[Const:String] ", fn "
								+
								[Local loopVar(20714):String:String]
							+
							[Const:String] " -> "
						+
						[Local condition(20716):Null<String>:Null<String>]
					+
					[Const:String] " end)"
			[Return:Dynamic] [Local result(20717):String:String]

	function generateEnumMapPattern[Function:(arrayExpr : String, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local arrayExpr(20719):String]
		[Arg:String] [Local loopVar(20720):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20721):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var transformation(20819):String]
				[Call:String]
					[Field:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							extractTransformationFromBody:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String
					[Local blockExpr(20721):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local loopVar(20720):String:String]
			[Var result(20820):String]
				[If:String]
					[Binop:Bool]
						[Binop:Bool]
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local transformation(20819):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "\n"
								[Const:Null<Int>] null
							>=
							[Const:Int] 0
						||
						[Binop:Bool]
							[Field:Int]
								[Local transformation(20819):String:String]
								[FInstance:Int]
									String
									length:Int
							>
							[Const:Int] 50
					[Then:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.map("
												+
												[Local arrayExpr(20719):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20720):String:String]
									+
									[Const:String] " ->\n"
								+
								[Call:String]
									[Field:(code : String, ?spaces : Int) -> String]
										[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
										[FStatic:(code : String, ?spaces : Int) -> String]
											reflaxe.elixir.helpers.CompilerUtilities
											indentCode:(code : String, ?spaces : Int) -> String
									[Local transformation(20819):String:String]
									[Const:Null<Int>] null
							+
							[Const:String] "\nend)"
					[Else:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.map("
												+
												[Local arrayExpr(20719):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20720):String:String]
									+
									[Const:String] " -> "
								+
								[Local transformation(20819):String:String]
							+
							[Const:String] " end)"
			[Return:Dynamic] [Local result(20820):String:String]

	function extractTransformationFromBody[Function:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20722):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(20723):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (blockExpr.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TBlock(innerExprs):
					var hasArrayInit = false;
					var hasWhileLoop = false;
					for (innerExpr  in  innerExprs) {
						switch (innerExpr.expr) {
							case TVar(tvar, init) if (init != null):
								var varName = CompilerUtilities.toElixirVarName(tvar);
								if (varName == "g_array") {
									hasArrayInit = true;
								};							
							case TWhile(_, _, _):
								hasWhileLoop = true;							
							case _:
						};
					};
					if (hasArrayInit && hasWhileLoop) {
						var result = compiler.compileExpression(expr);
						var lines = result.split("\n");
						for (line  in  lines) {
							if (line.indexOf("Enum.") >= 0) {
								return StringTools.trim(line);
							};
						};
					};				
				case _:
			};
		};
		var statements = [for (expr  in  exprs) compiler.compileExpression(expr)];
		statements.join("\n");	
	case TVar(tvar, valueExpr):
		if (valueExpr != null) {
			compiler.compileExpression(valueExpr);
		} else {
			loopVar;
		};	
	case _:
		compiler.compileExpression(blockExpr);	
})
					[Block:String]
						[Var `(20786):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local blockExpr(20722):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(20786):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 13
								[Block:String]
									[Var `(20787):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(20786):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TVar
											0
									[Var `(20788):Null<haxe.macro.TypedExpr>]
										[EnumParameter:Null<haxe.macro.TypedExpr>]
											[Local `(20786):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TVar
											1
									[Block:String]
										[Var tvar(20789):haxe.macro.TVar] [Local `(20787):haxe.macro.TVar:haxe.macro.TVar]
										[Var valueExpr(20790):Null<haxe.macro.TypedExpr>] [Local `(20788):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										[Block:String]
											[If:String]
												[Binop:Bool]
													[Local valueExpr(20790):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.LoopCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local valueExpr(20790):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
														[Const:Null<Bool>] null
												[Else:String] [Block:String] [Local loopVar(20723):String:String]
							[Case:String]
								[Const:Int] 14
								[Block:String]
									[Var `(20791):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(20786):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:String]
										[Var exprs(20792):Array<haxe.macro.TypedExpr>] [Local `(20791):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:String]
											[Block:Void]
												[Var `(20793):Int] [Const:Int] 0
												[While:Void]
													[Binop:Bool]
														[Local `(20793):Int:Int]
														<
														[Field:Int]
															[Local exprs(20792):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var expr(20794):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local exprs(20792):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(20793):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(20793):Int:Int]
														[Meta:Void]
															:ast(switch (expr.expr) {
	case TBlock(innerExprs):
		var hasArrayInit = false;
		var hasWhileLoop = false;
		for (innerExpr  in  innerExprs) {
			switch (innerExpr.expr) {
				case TVar(tvar, init) if (init != null):
					var varName = CompilerUtilities.toElixirVarName(tvar);
					if (varName == "g_array") {
						hasArrayInit = true;
					};				
				case TWhile(_, _, _):
					hasWhileLoop = true;				
				case _:
			};
		};
		if (hasArrayInit && hasWhileLoop) {
			var result = compiler.compileExpression(expr);
			var lines = result.split("\n");
			for (line  in  lines) {
				if (line.indexOf("Enum.") >= 0) {
					return StringTools.trim(line);
				};
			};
		};	
	case _:
})
															[Block:Void]
																[Var `(20795):haxe.macro.TypedExprDef]
																	[Field:haxe.macro.TypedExprDef]
																		[Local expr(20794):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																[If:Void]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(20795):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		==
																		[Const:Int] 14
																	[Then:Void] [Block:Void]
																		[Var `(20796):Array<haxe.macro.TypedExpr>]
																			[EnumParameter:Array<haxe.macro.TypedExpr>]
																				[Local `(20795):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TBlock
																				0
																		[Block:Void]
																			[Var innerExprs(20797):Array<haxe.macro.TypedExpr>] [Local `(20796):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Block:Void]
																				[Var hasArrayInit(20798):Bool] [Const:Bool] false
																				[Var hasWhileLoop(20799):Bool] [Const:Bool] false
																				[Block:Void]
																					[Var `(20800):Int] [Const:Int] 0
																					[While:Void]
																						[Binop:Bool]
																							[Local `(20800):Int:Int]
																							<
																							[Field:Int]
																								[Local innerExprs(20797):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[FInstance:Int]
																									Array<haxe.macro.TypedExpr>
																									length:Int
																						[Block:Void]
																							[Var innerExpr(20801):haxe.macro.TypedExpr]
																								[Array:haxe.macro.TypedExpr]
																									[Local innerExprs(20797):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																									[Local `(20800):Int:Int]
																							[Unop:Int]
																								++
																								Prefix
																								[Local `(20800):Int:Int]
																							[Meta:Void]
																								:ast(switch (innerExpr.expr) {
	case TVar(tvar, init) if (init != null):
		var varName = CompilerUtilities.toElixirVarName(tvar);
		if (varName == "g_array") {
			hasArrayInit = true;
		};	
	case TWhile(_, _, _):
		hasWhileLoop = true;	
	case _:
})
																								[Block:Void]
																									[Var `(20802):haxe.macro.TypedExprDef]
																										[Field:haxe.macro.TypedExprDef]
																											[Local innerExpr(20801):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																											[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																									[Switch:Void]
																										[EnumIndex:Int] [Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																										[Case:Void]
																											[Const:Int] 13
																											[Block:Void]
																												[Var `(20803):haxe.macro.TVar]
																													[EnumParameter:haxe.macro.TVar]
																														[Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																														TVar
																														0
																												[Var `(20804):Null<haxe.macro.TypedExpr>]
																													[EnumParameter:Null<haxe.macro.TypedExpr>]
																														[Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																														TVar
																														1
																												[Block:Void]
																													[Var tvar(20805):haxe.macro.TVar] [Local `(20803):haxe.macro.TVar:haxe.macro.TVar]
																													[Var init(20806):Null<haxe.macro.TypedExpr>] [Local `(20804):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																													[If:Void]
																														[Binop:Bool]
																															[Local init(20806):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																															!=
																															[Const:Null<haxe.macro.TypedExpr>] null
																														[Then:Void] [Block:Void]
																															[Var varName(20807):String]
																																[Call:String]
																																	[Field:(v : haxe.macro.TVar) -> String]
																																		[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																																		[FStatic:(v : haxe.macro.TVar) -> String]
																																			reflaxe.elixir.helpers.CompilerUtilities
																																			toElixirVarName:(v : haxe.macro.TVar) -> String
																																	[Local tvar(20805):haxe.macro.TVar:haxe.macro.TVar]
																															[If:Void]
																																[Binop:Bool]
																																	[Local varName(20807):String:String]
																																	==
																																	[Const:String] "g_array"
																																[Then:Bool] [Block:Bool]
																																	[Binop:Bool]
																																		[Local hasArrayInit(20798):Bool:Bool]
																																		=
																																		[Const:Bool] true
																														[Else:Void] [Block:Void]
																										[Case:Bool]
																											[Const:Int] 17
																											[Block:Bool]
																												[Var `(20808):haxe.macro.TypedExpr]
																													[EnumParameter:haxe.macro.TypedExpr]
																														[Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																														TWhile
																														0
																												[Var `(20809):haxe.macro.TypedExpr]
																													[EnumParameter:haxe.macro.TypedExpr]
																														[Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																														TWhile
																														1
																												[Var `(20810):Bool]
																													[EnumParameter:Bool]
																														[Local `(20802):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																														TWhile
																														2
																												[Block:Bool]
																													[Binop:Bool]
																														[Local hasWhileLoop(20799):Bool:Bool]
																														=
																														[Const:Bool] true
																										[Default:Void] [Block:Void]
																				[If:Void]
																					[Binop:Bool]
																						[Local hasArrayInit(20798):Bool:Bool]
																						&&
																						[Local hasWhileLoop(20799):Bool:Bool]
																					[Then:Void] [Block:Void]
																						[Var result(20811):Null<String>]
																							[Call:Null<String>]
																								[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									[Field:reflaxe.elixir.ElixirCompiler]
																										[Const:reflaxe.elixir.helpers.LoopCompiler] this
																										[FInstance:reflaxe.elixir.ElixirCompiler]
																											reflaxe.elixir.helpers.LoopCompiler
																											compiler:reflaxe.elixir.ElixirCompiler
																									[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																										reflaxe.elixir.ElixirCompiler
																										compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																								[Local expr(20794):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																								[Const:Null<Bool>] null
																						[Var lines(20812):Array<String>]
																							[Call:Array<String>]
																								[Field:(delimiter : String) -> Array<String>]
																									[Local result(20811):Null<String>:Null<String>]
																									[FInstance:(delimiter : String) -> Array<String>]
																										String
																										split:(delimiter : String) -> Array<String>
																								[Const:String] "\n"
																						[Block:Void]
																							[Var `(20813):Int] [Const:Int] 0
																							[While:Void]
																								[Binop:Bool]
																									[Local `(20813):Int:Int]
																									<
																									[Field:Int]
																										[Local lines(20812):Array<String>:Array<String>]
																										[FInstance:Int]
																											Array<String>
																											length:Int
																								[Block:Void]
																									[Var line(20814):String]
																										[Array:String]
																											[Local lines(20812):Array<String>:Array<String>]
																											[Local `(20813):Int:Int]
																									[Unop:Int]
																										++
																										Prefix
																										[Local `(20813):Int:Int]
																									[If:Void]
																										[Binop:Bool]
																											[Call:Int]
																												[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																													[Local line(20814):String:String]
																													[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																														String
																														indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																												[Const:String] "Enum."
																												[Const:Null<Int>] null
																											>=
																											[Const:Int] 0
																										[Then:Dynamic] [Block:Dynamic]
																											[Return:Dynamic]
																												[Call:String]
																													[Field:(s : String) -> String]
																														[TypeExpr StringTools:Class<StringTools>]
																														[FStatic:(s : String) -> String]
																															StringTools
																															trim:(s : String) -> String
																													[Local line(20814):String:String]
																	[Else:Void] [Block:Void]
											[Var statements(20815):Array<Null<String>>]
												[Block:Array<Null<String>>]
													[Var `(20816):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
													[Block:Void]
														[Var `(20817):Int] [Const:Int] 0
														[While:Void]
															[Binop:Bool]
																[Local `(20817):Int:Int]
																<
																[Field:Int]
																	[Local exprs(20792):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[FInstance:Int]
																		Array<haxe.macro.TypedExpr>
																		length:Int
															[Block:Void]
																[Var expr(20818):haxe.macro.TypedExpr]
																	[Array:haxe.macro.TypedExpr]
																		[Local exprs(20792):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Local `(20817):Int:Int]
																[Unop:Int]
																	++
																	Prefix
																	[Local `(20817):Int:Int]
																[Call:Int]
																	[Field:(x : Null<String>) -> Int]
																		[Local `(20816):Array<Null<String>>:Array<Null<String>>]
																		[FInstance:(x : Null<String>) -> Int]
																			Array<Null<String>>
																			push:(x : Array.T) -> Int
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Const:reflaxe.elixir.helpers.LoopCompiler] this
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.LoopCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local expr(20818):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
													[Local `(20816):Array<Null<String>>:Array<Null<String>>]
											[Call:String]
												[Field:(sep : String) -> String]
													[Local statements(20815):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] "\n"
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.LoopCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local blockExpr(20722):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null

	function tryOptimizeRangeIteration[Function:(iterExpr : haxe.macro.TypedExpr, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20829):haxe.macro.TypedExpr]
		[Arg:String] [Local loopVar(20830):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20831):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var rangePattern(20833):Null<{ start : String, inclusive : Bool, end : String }>]
				[Call:Null<{ start : String, inclusive : Bool, end : String }>]
					[Field:(iterExpr : haxe.macro.TypedExpr) -> Null<{ start : String, inclusive : Bool, end : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(iterExpr : haxe.macro.TypedExpr) -> Null<{ start : String, inclusive : Bool, end : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							detectRangePattern:(iterExpr : haxe.macro.TypedExpr) -> Null<{ start : String, inclusive : Bool, end : String }>
					[Local iterExpr(20829):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local rangePattern(20833):Null<{ start : String, inclusive : Bool, end : String }>:Null<{ start : String, inclusive : Bool, end : String }>]
					!=
					[Const:Null<{ start : String, inclusive : Bool, end : String }>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(range : { start : String, inclusive : Bool, end : String }, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(range : { start : String, inclusive : Bool, end : String }, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									optimizeRangeLoop:(range : { start : String, inclusive : Bool, end : String }, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String
							[Local rangePattern(20833):Null<{ start : String, inclusive : Bool, end : String }>:Null<{ start : String, inclusive : Bool, end : String }>]
							[Local loopVar(20830):String:String]
							[Local blockExpr(20831):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[Return:Dynamic] [Const:Null<String>] null

	function detectRangePattern[Function:(iterExpr : haxe.macro.TypedExpr) -> Null<{ start : String, inclusive : Bool, end : String }>]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20832):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:Null<{ start : String, inclusive : Bool, end : String }>] null

	function optimizeRangeLoop[Function:(range : { start : String, inclusive : Bool, end : String }, loopVar : String, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:{ start : String, inclusive : Bool, end : String }] [Local range(20834):{ start : String, inclusive : Bool, end : String }]
		[Arg:String] [Local loopVar(20835):String]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20836):haxe.macro.TypedExpr]
		[Block:Void]
			[Var rangeExpr(20837):String]
				[If:String]
					[Field:Bool]
						[Local range(20834):{ start : String, inclusive : Bool, end : String }:{ start : String, inclusive : Bool, end : String }]
						[FAnon:Bool] inclusive:Bool
					[Then:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Field:String]
										[Local range(20834):{ start : String, inclusive : Bool, end : String }:{ start : String, inclusive : Bool, end : String }]
										[FAnon:String] start:String
								+
								[Const:String] ".."
							+
							[Field:String]
								[Local range(20834):{ start : String, inclusive : Bool, end : String }:{ start : String, inclusive : Bool, end : String }]
								[FAnon:String] end:String
					[Else:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] ""
										+
										[Field:String]
											[Local range(20834):{ start : String, inclusive : Bool, end : String }:{ start : String, inclusive : Bool, end : String }]
											[FAnon:String] start:String
									+
									[Const:String] "..("
								+
								[Field:String]
									[Local range(20834):{ start : String, inclusive : Bool, end : String }:{ start : String, inclusive : Bool, end : String }]
									[FAnon:String] end:String
							+
							[Const:String] " - 1)"
			[Var bodyAnalysis(20838):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
				[Call:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
					[Field:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeLoopBody:(blockExpr : haxe.macro.TypedExpr) -> { targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }
					[Local blockExpr(20836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Field:Bool]
					[Local bodyAnalysis(20838):{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }:{ targetVar : String, mappingExpr : haxe.macro.TypedExpr, hasMapping : Bool, hasFinding : Bool, hasFiltering : Bool, hasCounting : Bool, hasAccumulation : Bool, conditionExpr : haxe.macro.TypedExpr }]
					[FAnon:Bool] hasMapping:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Var transformation(20839):String]
						[Call:String]
							[Field:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									extractTransformationFromBody:(blockExpr : haxe.macro.TypedExpr, loopVar : String) -> String
							[Local blockExpr(20836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local loopVar(20835):String:String]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.map("
												+
												[Local rangeExpr(20837):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20835):String:String]
									+
									[Const:String] " -> "
								+
								[Local transformation(20839):String:String]
							+
							[Const:String] " end)"
				[Else:Dynamic] [Block:Dynamic]
					[Var body(20840):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.LoopCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.LoopCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local blockExpr(20836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Const:Null<Bool>] null
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Enum.each("
												+
												[Local rangeExpr(20837):String:String]
											+
											[Const:String] ", fn "
										+
										[Local loopVar(20835):String:String]
									+
									[Const:String] " -> "
								+
								[Local body(20840):Null<String>:Null<String>]
							+
							[Const:String] " end)"

	function compileGenericForLoop[Function:(loopVar : String, iterExpr : haxe.macro.TypedExpr, blockExpr : haxe.macro.TypedExpr) -> String]
		[Arg:String] [Local loopVar(20842):String]
		[Arg:haxe.macro.TypedExpr] [Local iterExpr(20843):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local blockExpr(20844):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var iterable(20845):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local iterExpr(20843):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var body(20846):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local blockExpr(20844):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "Enum.each("
										+
										[Local iterable(20845):Null<String>:Null<String>]
									+
									[Const:String] ", fn "
								+
								[Local loopVar(20842):String:String]
							+
							[Const:String] " ->\n"
						+
						[Call:String]
							[Field:(code : String, ?spaces : Int) -> String]
								[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
								[FStatic:(code : String, ?spaces : Int) -> String]
									reflaxe.elixir.helpers.CompilerUtilities
									indentCode:(code : String, ?spaces : Int) -> String
							[Local body(20846):Null<String>:Null<String>]
							[Const:Null<Int>] null
					+
					[Const:String] "\nend)"

	public function compileWhileLoop[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(18365):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18366):haxe.macro.TypedExpr]
		[Arg:Bool] [Local normalWhile(18367):Bool]
		[Block:Dynamic]
			[Call:Void]
				[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
					[TypeExpr haxe.Log:Class<haxe.Log>]
					[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
						haxe.Log
						trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
				[Const:String] "[FORCED DEBUG] compileWhileLoop called"
				[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
					fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/LoopCompiler.hx"
					lineNumber: [Const:Int] 1463
					className: [Const:String] "reflaxe.elixir.helpers.LoopCompiler"
					methodName: [Const:String] "compileWhileLoop"
			[Var condStr(18368):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local condStr(18368):Null<String>:Null<String>]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "length"
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
							[TypeExpr haxe.Log:Class<haxe.Log>]
							[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
								haxe.Log
								trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
						[Binop:String]
							[Const:String] "[DEBUG ARRAY] Found length in condition: "
							+
							[Local condStr(18368):Null<String>:Null<String>]
						[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
							fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/LoopCompiler.hx"
							lineNumber: [Const:Int] 1467
							className: [Const:String] "reflaxe.elixir.helpers.LoopCompiler"
							methodName: [Const:String] "compileWhileLoop"
			[Var forInOptimization(18497):Null<String>]
				[Call:Null<String>]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							tryOptimizeForInPattern:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>
					[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(18366):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local forInOptimization(18497):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local forInOptimization(18497):Null<String>:Null<String>]
			[Var reflectOptimization(18500):Null<String>]
				[Call:Null<String>]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
							reflaxe.elixir.helpers.LoopCompiler
							optimizeReflectFieldsLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>
					[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(18366):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local reflectOptimization(18500):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local reflectOptimization(18500):Null<String>:Null<String>]
			[Var arrayBuildingPattern(18501):Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
				[Call:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							detectArrayBuildingPattern:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>
					[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(18366):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local arrayBuildingPattern(18501):Null<{ indexVar : String, arrayExpr : String, accumVar : String }>:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
					!=
					[Const:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var result(18502):String]
						[Call:String]
							[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
									reflaxe.elixir.helpers.LoopCompiler
									compileArrayBuildingLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String
							[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local ebody(18366):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local arrayBuildingPattern(18501):Null<{ indexVar : String, arrayExpr : String, accumVar : String }>:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
					[Return:Dynamic] [Local result(18502):String:String]
			[Var result(18709):String]
				[Call:String]
					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							compileWhileLoopGeneric:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
					[Local econd(18365):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local ebody(18366):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local normalWhile(18367):Bool:Bool]
			[Return:Dynamic] [Local result(18709):String:String]

	function tryOptimizeForInPattern[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local econd(18369):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18370):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var conditionInfo(18371):Null<{ indexVar : String, arrayVar : String }>]
				[Call:Null<{ indexVar : String, arrayVar : String }>]
					[Field:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeArrayLoopCondition:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>
					[Local econd(18369):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local conditionInfo(18371):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
					==
					[Const:Null<{ indexVar : String, arrayVar : String }>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Var bodyPattern(18479):Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
				[Call:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
					[Field:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeArrayLoopBody:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>
					[Local ebody(18370):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local conditionInfo(18371):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
			[If:Void]
				[Binop:Bool]
					[Local bodyPattern(18479):Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
					==
					[Const:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Var result(18496):String]
				[Call:String]
					[Field:(pattern : { type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }, conditionInfo : { indexVar : String, arrayVar : String }) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(pattern : { type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }, conditionInfo : { indexVar : String, arrayVar : String }) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							generateEnumFunction:(pattern : { type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }, conditionInfo : { indexVar : String, arrayVar : String }) -> String
					[Local bodyPattern(18479):Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
					[Local conditionInfo(18371):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
			[Return:Dynamic] [Local result(18496):String:String]

	function optimizeReflectFieldsLoop[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local econd(18498):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18499):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null

	public function detectArrayBuildingPattern[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayExpr : String, accumVar : String }>]
		[Arg:haxe.macro.TypedExpr] [Local econd(18042):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18043):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>]
				[Call:Null<{ indexVar : String, arrayVar : String }>]
					[Field:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeArrayLoopCondition:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>
					[Local econd(18042):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
					==
					[Const:Null<{ indexVar : String, arrayVar : String }>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>] null
			[Var bodyAnalysis(18280):Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
				[Call:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
					[Field:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							analyzeSimpleArrayLoopBody:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>
					[Local ebody(18043):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
			[If:Void]
				[Binop:Bool]
					[Local bodyAnalysis(18280):Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
					==
					[Const:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayExpr : String, accumVar : String }>] null
			[Return:Dynamic]
				[ObjectDecl:{ indexVar : String, arrayExpr : String, accumVar : String }]
					indexVar: [Field:String]
						[Local conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
						[FAnon:String] indexVar:String
					accumVar: [If:String]
						[Binop:Bool]
							[Field:String]
								[Local bodyAnalysis(18280):Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
								[FAnon:String] accumulator:String
							!=
							[Const:String] null
						[Then:String] [Block:String]
							[Field:String]
								[Local bodyAnalysis(18280):Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
								[FAnon:String] accumulator:String
						[Else:String] [Block:String]
							[Field:String]
								[Local conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
								[FAnon:String] arrayVar:String
					arrayExpr: [Field:String]
						[Local conditionInfo(18113):Null<{ indexVar : String, arrayVar : String }>:Null<{ indexVar : String, arrayVar : String }>]
						[FAnon:String] arrayVar:String

	public function compileArrayBuildingLoop[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, pattern : { indexVar : String, arrayExpr : String, accumVar : String }) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(18282):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18283):haxe.macro.TypedExpr]
		[Arg:{ indexVar : String, arrayExpr : String, accumVar : String }] [Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }]
		[Block:Void]
			[Var patternType(19080):{ type : String, expression : String }]
				[Call:{ type : String, expression : String }]
					[Field:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
							reflaxe.elixir.helpers.LoopCompiler
							classifyArrayPattern:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }
					[Local ebody(18283):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Field:String]
						[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
						[FAnon:String] indexVar:String
					[Field:String]
						[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
						[FAnon:String] accumVar:String
			[Meta:Void]
				:ast(switch (patternType.type) {
	case "filter":
		var condition = patternType.expression;
		var result = "Enum.filter(${pattern.arrayExpr}, fn item -> ${condition} end)";
		return result;	
	case "map":
		var transformation = patternType.expression;
		var result = "Enum.map(${pattern.arrayExpr}, fn item -> ${transformation} end)";
		return result;	
	case "each":
		var sideEffect = patternType.expression;
		var result = "Enum.each(${pattern.arrayExpr}, fn item -> ${sideEffect} end)";
		return result;	
	case "reduce":
		var transformation = patternType.expression != null ? patternType.expression : "item";
		var result = "Enum.reduce(${pattern.arrayExpr}, [], fn item, acc -> [${transformation} | acc] end) |> Enum.reverse()";
		return result;	
	case _:
		return null;	
})
				[Block:Void]
					[Var `(19090):String]
						[Field:String]
							[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
							[FAnon:String] type:String
					[Switch:Void]
						[Local `(19090):String:String]
						[Case:Dynamic]
							[Const:String] "each"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var sideEffect(19091):String]
										[Field:String]
											[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
											[FAnon:String] expression:String
									[Var result(19092):String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Enum.each("
														+
														[Field:String]
															[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
															[FAnon:String] arrayExpr:String
													+
													[Const:String] ", fn item -> "
												+
												[Local sideEffect(19091):String:String]
											+
											[Const:String] " end)"
									[Return:Dynamic] [Local result(19092):String:String]
						[Case:Dynamic]
							[Const:String] "filter"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var condition(19093):String]
										[Field:String]
											[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
											[FAnon:String] expression:String
									[Var result(19094):String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Enum.filter("
														+
														[Field:String]
															[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
															[FAnon:String] arrayExpr:String
													+
													[Const:String] ", fn item -> "
												+
												[Local condition(19093):String:String]
											+
											[Const:String] " end)"
									[Return:Dynamic] [Local result(19094):String:String]
						[Case:Dynamic]
							[Const:String] "map"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var transformation(19095):String]
										[Field:String]
											[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
											[FAnon:String] expression:String
									[Var result(19096):String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Enum.map("
														+
														[Field:String]
															[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
															[FAnon:String] arrayExpr:String
													+
													[Const:String] ", fn item -> "
												+
												[Local transformation(19095):String:String]
											+
											[Const:String] " end)"
									[Return:Dynamic] [Local result(19096):String:String]
						[Case:Dynamic]
							[Const:String] "reduce"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var transformation(19097):String]
										[If:String]
											[Binop:Bool]
												[Field:String]
													[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
													[FAnon:String] expression:String
												!=
												[Const:String] null
											[Then:String] [Block:String]
												[Field:String]
													[Local patternType(19080):{ type : String, expression : String }:{ type : String, expression : String }]
													[FAnon:String] expression:String
											[Else:String] [Block:String] [Const:String] "item"
									[Var result(19098):String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Enum.reduce("
														+
														[Field:String]
															[Local pattern(18284):{ indexVar : String, arrayExpr : String, accumVar : String }:{ indexVar : String, arrayExpr : String, accumVar : String }]
															[FAnon:String] arrayExpr:String
													+
													[Const:String] ", [], fn item, acc -> ["
												+
												[Local transformation(19097):String:String]
											+
											[Const:String] " | acc] end) |> Enum.reverse()"
									[Return:Dynamic] [Local result(19098):String:String]
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] null

	function classifyArrayPattern[Function:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18285):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(18286):String]
		[Arg:String] [Local accumVar(18287):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (ebody.expr) {
	case TBlock(exprs):
		return classifyBlockPattern(exprs, indexVar, accumVar);	
	case TIf(condition, thenExpr, elseExpr):
		return classifyConditionalPattern(condition, thenExpr, elseExpr, indexVar, accumVar);	
	case TBinop(OpAssign, target, value):
		return classifyAssignmentPattern(target, value, indexVar, accumVar);	
	case _:
		return { type : "reduce", expression : "item" };	
})
				[Block:Void]
					[Var `(19066):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local ebody(18285):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 3
							[Block:Void]
								[Var `(19067):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(19068):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(19069):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(19067):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Dynamic] [Block:Dynamic]
										[Block:Dynamic]
											[Var target(19070):haxe.macro.TypedExpr] [Local `(19068):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var value(19071):haxe.macro.TypedExpr] [Local `(19069):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:{ type : String, expression : String }]
														[Field:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
																reflaxe.elixir.helpers.LoopCompiler
																classifyAssignmentPattern:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }
														[Local target(19070):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local value(19071):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local indexVar(18286):String:String]
														[Local accumVar(18287):String:String]
									[Else:Dynamic] [Block:Dynamic]
										[Return:Dynamic]
											[ObjectDecl:{ type : String, expression : String }]
												type: [Const:String] "reduce"
												expression: [Const:String] "item"
						[Case:Dynamic]
							[Const:Int] 14
							[Block:Dynamic]
								[Var `(19072):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Dynamic]
									[Var exprs(19073):Array<haxe.macro.TypedExpr>] [Local `(19072):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:{ type : String, expression : String }]
												[Field:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> { type : String, expression : String }]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> { type : String, expression : String }]
														reflaxe.elixir.helpers.LoopCompiler
														classifyBlockPattern:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> { type : String, expression : String }
												[Local exprs(19073):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local indexVar(18286):String:String]
												[Local accumVar(18287):String:String]
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(19074):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(19075):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(19076):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(19066):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var condition(19077):haxe.macro.TypedExpr] [Local `(19074):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var thenExpr(19078):haxe.macro.TypedExpr] [Local `(19075):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var elseExpr(19079):Null<haxe.macro.TypedExpr>] [Local `(19076):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:{ type : String, expression : String }]
												[Field:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
														reflaxe.elixir.helpers.LoopCompiler
														classifyConditionalPattern:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }
												[Local condition(19077):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local thenExpr(19078):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local elseExpr(19079):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Local indexVar(18286):String:String]
												[Local accumVar(18287):String:String]
						[Default:Dynamic]
							[Block:Dynamic]
								[Return:Dynamic]
									[ObjectDecl:{ type : String, expression : String }]
										type: [Const:String] "reduce"
										expression: [Const:String] "item"

	function findNestedArrayOperation[Function:(exprs : Array<haxe.macro.TypedExpr>, tempVarName : String) -> Null<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local exprs(28388):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local tempVarName(28389):String]
		[Block:Dynamic]
			[Block:Void]
				[Var `(28477):Int] [Const:Int] 0
				[Var `(28478):Int]
					[Field:Int]
						[Local exprs(28388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(28477):Int:Int]
						<
						[Local `(28478):Int:Int]
					[Block:Void]
						[Var i(28390):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(28477):Int:Int]
						[Var expr(28391):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(28388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local i(28390):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TBlock(blockExprs):
		for (blockExpr  in  blockExprs) {
			switch (blockExpr.expr) {
				case TBinop(OpAssign, e1, e2):
					var leftSide = compiler.compileExpression(e1);
					if (leftSide == tempVarName) {
						for (innerExpr  in  blockExprs) {
							switch (innerExpr.expr) {
								case TWhile(econd, ebody, normalWhile):
									var nestedResult = compileWhileLoop(econd, ebody, normalWhile);
									if (nestedResult != null && nestedResult.indexOf("Enum.") >= 0) {
										return nestedResult;
									};								
								case _:
							};
						};
					};				
				case _:
			};
		};	
	case TWhile(econd, ebody, normalWhile):
		var bodyStr = compiler.compileExpression(ebody);
		if (bodyStr.indexOf(tempVarName + " =") >= 0) {
			var nestedResult = compileWhileLoop(econd, ebody, normalWhile);
			if (nestedResult != null && nestedResult.indexOf("Enum.") >= 0) {
				return nestedResult;
			};
		};	
	case _:
})
							[Block:Void]
								[Var `(28447):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(28391):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(28447):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 14
										[Block:Void]
											[Var `(28448):Array<haxe.macro.TypedExpr>]
												[EnumParameter:Array<haxe.macro.TypedExpr>]
													[Local `(28447):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBlock
													0
											[Block:Void]
												[Var blockExprs(28449):Array<haxe.macro.TypedExpr>] [Local `(28448):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Block:Void]
													[Block:Void]
														[Var `(28450):Int] [Const:Int] 0
														[While:Void]
															[Binop:Bool]
																[Local `(28450):Int:Int]
																<
																[Field:Int]
																	[Local blockExprs(28449):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[FInstance:Int]
																		Array<haxe.macro.TypedExpr>
																		length:Int
															[Block:Void]
																[Var blockExpr(28451):haxe.macro.TypedExpr]
																	[Array:haxe.macro.TypedExpr]
																		[Local blockExprs(28449):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Local `(28450):Int:Int]
																[Unop:Int]
																	++
																	Prefix
																	[Local `(28450):Int:Int]
																[Meta:Void]
																	:ast(switch (blockExpr.expr) {
	case TBinop(OpAssign, e1, e2):
		var leftSide = compiler.compileExpression(e1);
		if (leftSide == tempVarName) {
			for (innerExpr  in  blockExprs) {
				switch (innerExpr.expr) {
					case TWhile(econd, ebody, normalWhile):
						var nestedResult = compileWhileLoop(econd, ebody, normalWhile);
						if (nestedResult != null && nestedResult.indexOf("Enum.") >= 0) {
							return nestedResult;
						};					
					case _:
				};
			};
		};	
	case _:
})
																	[Block:Void]
																		[Var `(28452):haxe.macro.TypedExprDef]
																			[Field:haxe.macro.TypedExprDef]
																				[Local blockExpr(28451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																		[If:Void]
																			[Binop:Bool]
																				[EnumIndex:Int] [Local `(28452):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				==
																				[Const:Int] 3
																			[Then:Void] [Block:Void]
																				[Var `(28453):haxe.macro.Binop]
																					[EnumParameter:haxe.macro.Binop]
																						[Local `(28452):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																						TBinop
																						0
																				[Var `(28454):haxe.macro.TypedExpr]
																					[EnumParameter:haxe.macro.TypedExpr]
																						[Local `(28452):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																						TBinop
																						1
																				[Var `(28455):haxe.macro.TypedExpr]
																					[EnumParameter:haxe.macro.TypedExpr]
																						[Local `(28452):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																						TBinop
																						2
																				[If:Void]
																					[Binop:Bool]
																						[EnumIndex:Int] [Local `(28453):haxe.macro.Binop:haxe.macro.Binop]
																						==
																						[Const:Int] 4
																					[Then:Void] [Block:Void]
																						[Block:Void]
																							[Var e1(28456):haxe.macro.TypedExpr] [Local `(28454):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Var e2(28457):haxe.macro.TypedExpr] [Local `(28455):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Block:Void]
																								[Var leftSide(28458):Null<String>]
																									[Call:Null<String>]
																										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																											[Field:reflaxe.elixir.ElixirCompiler]
																												[Const:reflaxe.elixir.helpers.LoopCompiler] this
																												[FInstance:reflaxe.elixir.ElixirCompiler]
																													reflaxe.elixir.helpers.LoopCompiler
																													compiler:reflaxe.elixir.ElixirCompiler
																											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																												reflaxe.elixir.ElixirCompiler
																												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																										[Local e1(28456):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																										[Const:Null<Bool>] null
																								[If:Void]
																									[Binop:Bool]
																										[Local leftSide(28458):Null<String>:Null<String>]
																										==
																										[Local tempVarName(28389):String:String]
																									[Then:Void] [Block:Void]
																										[Block:Void]
																											[Var `(28459):Int] [Const:Int] 0
																											[While:Void]
																												[Binop:Bool]
																													[Local `(28459):Int:Int]
																													<
																													[Field:Int]
																														[Local blockExprs(28449):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																														[FInstance:Int]
																															Array<haxe.macro.TypedExpr>
																															length:Int
																												[Block:Void]
																													[Var innerExpr(28460):haxe.macro.TypedExpr]
																														[Array:haxe.macro.TypedExpr]
																															[Local blockExprs(28449):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																															[Local `(28459):Int:Int]
																													[Unop:Int]
																														++
																														Prefix
																														[Local `(28459):Int:Int]
																													[Meta:Void]
																														:ast(switch (innerExpr.expr) {
	case TWhile(econd, ebody, normalWhile):
		var nestedResult = compileWhileLoop(econd, ebody, normalWhile);
		if (nestedResult != null && nestedResult.indexOf("Enum.") >= 0) {
			return nestedResult;
		};	
	case _:
})
																														[Block:Void]
																															[Var `(28461):haxe.macro.TypedExprDef]
																																[Field:haxe.macro.TypedExprDef]
																																	[Local innerExpr(28460):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																															[If:Void]
																																[Binop:Bool]
																																	[EnumIndex:Int] [Local `(28461):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																	==
																																	[Const:Int] 17
																																[Then:Void] [Block:Void]
																																	[Var `(28462):haxe.macro.TypedExpr]
																																		[EnumParameter:haxe.macro.TypedExpr]
																																			[Local `(28461):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																			TWhile
																																			0
																																	[Var `(28463):haxe.macro.TypedExpr]
																																		[EnumParameter:haxe.macro.TypedExpr]
																																			[Local `(28461):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																			TWhile
																																			1
																																	[Var `(28464):Bool]
																																		[EnumParameter:Bool]
																																			[Local `(28461):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																			TWhile
																																			2
																																	[Block:Void]
																																		[Var econd(28465):haxe.macro.TypedExpr] [Local `(28462):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																		[Var ebody(28466):haxe.macro.TypedExpr] [Local `(28463):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																		[Var normalWhile(28467):Bool] [Local `(28464):Bool:Bool]
																																		[Block:Void]
																																			[Var nestedResult(28468):String]
																																				[Call:String]
																																					[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																						[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																																							reflaxe.elixir.helpers.LoopCompiler
																																							compileWhileLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
																																					[Local econd(28465):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																					[Local ebody(28466):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																					[Local normalWhile(28467):Bool:Bool]
																																			[If:Void]
																																				[Binop:Bool]
																																					[Binop:Bool]
																																						[Local nestedResult(28468):String:String]
																																						!=
																																						[Const:String] null
																																					&&
																																					[Binop:Bool]
																																						[Call:Int]
																																							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																																								[Local nestedResult(28468):String:String]
																																								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																																									String
																																									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																																							[Const:String] "Enum."
																																							[Const:Null<Int>] null
																																						>=
																																						[Const:Int] 0
																																				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local nestedResult(28468):String:String]
																																[Else:Void] [Block:Void]
																					[Else:Void] [Block:Void]
																			[Else:Void] [Block:Void]
									[Case:Void]
										[Const:Int] 17
										[Block:Void]
											[Var `(28469):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28447):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TWhile
													0
											[Var `(28470):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28447):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TWhile
													1
											[Var `(28471):Bool]
												[EnumParameter:Bool]
													[Local `(28447):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TWhile
													2
											[Block:Void]
												[Var econd(28472):haxe.macro.TypedExpr] [Local `(28469):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var ebody(28473):haxe.macro.TypedExpr] [Local `(28470):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var normalWhile(28474):Bool] [Local `(28471):Bool:Bool]
												[Block:Void]
													[Var bodyStr(28475):Null<String>]
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.LoopCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local ebody(28473):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Const:Null<Bool>] null
													[If:Void]
														[Binop:Bool]
															[Call:Int]
																[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																	[Local bodyStr(28475):Null<String>:Null<String>]
																	[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																		String
																		indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																[Binop:String]
																	[Local tempVarName(28389):String:String]
																	+
																	[Const:String] " ="
																[Const:Null<Int>] null
															>=
															[Const:Int] 0
														[Then:Void] [Block:Void]
															[Var nestedResult(28476):String]
																[Call:String]
																	[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																			reflaxe.elixir.helpers.LoopCompiler
																			compileWhileLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
																	[Local econd(28472):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local ebody(28473):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local normalWhile(28474):Bool:Bool]
															[If:Void]
																[Binop:Bool]
																	[Binop:Bool]
																		[Local nestedResult(28476):String:String]
																		!=
																		[Const:String] null
																	&&
																	[Binop:Bool]
																		[Call:Int]
																			[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																				[Local nestedResult(28476):String:String]
																				[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																					String
																					indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																			[Const:String] "Enum."
																			[Const:Null<Int>] null
																		>=
																		[Const:Int] 0
																[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local nestedResult(28476):String:String]
									[Default:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<String>] null

	function classifyBlockPattern[Function:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> { type : String, expression : String }]
		[Arg:Array<haxe.macro.TypedExpr>] [Local exprs(18289):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local indexVar(18290):String]
		[Arg:String] [Local accumVar(18291):String]
		[Block:Void]
			[Var hasConditional(18292):Bool] [Const:Bool] false
			[Var hasAssignment(18293):Bool] [Const:Bool] false
			[Var transformationExpr(18294):String] [Const:String] "item"
			[Var conditionExpr(18295):String] [Const:String] "true"
			[Var itemVarName(18296):String] [Const:String] "item"
			[Block:Void]
				[Var `(18308):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(18308):Int:Int]
						<
						[Field:Int]
							[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(18297):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(18308):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(18308):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TVar(tvar, init) if (init != null):
		itemVarName = CompilerUtilities.toElixirVarName(tvar);
		break;	
	case _:
})
							[Block:Void]
								[Var `(18303):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(18297):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(18303):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										==
										[Const:Int] 13
									[Then:Void] [Block:Void]
										[Var `(18304):haxe.macro.TVar]
											[EnumParameter:haxe.macro.TVar]
												[Local `(18303):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TVar
												0
										[Var `(18305):Null<haxe.macro.TypedExpr>]
											[EnumParameter:Null<haxe.macro.TypedExpr>]
												[Local `(18303):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TVar
												1
										[Block:Void]
											[Var tvar(18306):haxe.macro.TVar] [Local `(18304):haxe.macro.TVar:haxe.macro.TVar]
											[Var init(18307):Null<haxe.macro.TypedExpr>] [Local `(18305):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[If:Void]
												[Binop:Bool]
													[Local init(18307):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:Dynamic] [Block:Dynamic]
													[Binop:String]
														[Local itemVarName(18296):String:String]
														=
														[Call:String]
															[Field:(v : haxe.macro.TVar) -> String]
																[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																[FStatic:(v : haxe.macro.TVar) -> String]
																	reflaxe.elixir.helpers.CompilerUtilities
																	toElixirVarName:(v : haxe.macro.TVar) -> String
															[Local tvar(18306):haxe.macro.TVar:haxe.macro.TVar]
													[Break:Dynamic]
												[Else:Void] [Block:Void]
									[Else:Void] [Block:Void]
			[Block:Void]
				[Var `(19015):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(19015):Int:Int]
						<
						[Field:Int]
							[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(18309):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(19015):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(19015):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TIf(condition, thenExpr, elseExpr):
		hasConditional = true;
		conditionExpr = substituteVariableNamesWithItem(compiler.compileExpression(condition), indexVar, accumVar, itemVarName);	
	case TBinop(OpAssign, target, value):
		hasAssignment = true;
		switch (value.expr) {
			case TBinop(OpAdd, left, right):
				switch (right.expr) {
					case TArrayDecl([transformExpr]):
						transformationExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, itemVarName);					
					case _:
				};			
			case _:
		};	
	case TCall(fn, args):
		switch (fn.expr) {
			case TField(obj, field):
				switch (field) {
					case FInstance(_, _, cf) if (cf.get().name == "push"):
						hasAssignment = true;
						if (args.length > 0) {
							var isNestedArrayResult = false;
							switch (args[0].expr) {
								case TLocal(v):
									var varName = CompilerUtilities.toElixirVarName(v);
									if (varName.indexOf("temp_array") >= 0) {
										for (i  in  0 ... exprs.length) {
											switch (exprs[i].expr) {
												case TVar(tvar, init) if (init == null):
													var thisVarName = CompilerUtilities.toElixirVarName(tvar);
													if (thisVarName == varName) {
														for (j  in  (i + 1) ... exprs.length) {
															switch (exprs[j].expr) {
																case TBinop(OpAssign, e1, e2):
																	var leftSide = compiler.compileExpression(e1);
																	if (leftSide == varName) {
																		switch (e2.expr) {
																			case TBlock(blockExprs):
																				for (blockExpr  in  blockExprs) {
																					switch (blockExpr.expr) {
																						case TWhile(econd, ebody, normalWhile):
																							var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
																							if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
																								transformationExpr = nestedOp;
																								isNestedArrayResult = true;
																								break;
																							};																						
																						case _:
																					};
																				};																			
																			case _:
																		};
																	};																
																case _:
															};
														};
													};												
												case _:
											};
										};
										if (!isNestedArrayResult) { };
									};								
								case _:
							};
							if (!isNestedArrayResult) {
								var compiledArg = compiler.compileExpression(args[0]);
								transformationExpr = substituteVariableNamesWithItem(compiledArg, indexVar, accumVar, itemVarName);
							};
						};					
					case _:
						continue;					
				};			
			case _:
				continue;			
		};	
	case _:
		continue;	
})
							[Block:Void]
								[Var `(18942):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(18309):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 3
										[Block:Void]
											[Var `(18943):haxe.macro.Binop]
												[EnumParameter:haxe.macro.Binop]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													0
											[Var `(18944):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													1
											[Var `(18945):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													2
											[If:Void]
												[Binop:Bool]
													[EnumIndex:Int] [Local `(18943):haxe.macro.Binop:haxe.macro.Binop]
													==
													[Const:Int] 4
												[Then:Void] [Block:Void]
													[Block:Void]
														[Var target(18946):haxe.macro.TypedExpr] [Local `(18944):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Var value(18947):haxe.macro.TypedExpr] [Local `(18945):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Block:Void]
															[Binop:Bool]
																[Local hasAssignment(18293):Bool:Bool]
																=
																[Const:Bool] true
															[Meta:Void]
																:ast(switch (value.expr) {
	case TBinop(OpAdd, left, right):
		switch (right.expr) {
			case TArrayDecl([transformExpr]):
				transformationExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, itemVarName);			
			case _:
		};	
	case _:
})
																[Block:Void]
																	[Var `(18948):haxe.macro.TypedExprDef]
																		[Field:haxe.macro.TypedExprDef]
																			[Local value(18947):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																	[If:Void]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(18948):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			==
																			[Const:Int] 3
																		[Then:Void] [Block:Void]
																			[Var `(18949):haxe.macro.Binop]
																				[EnumParameter:haxe.macro.Binop]
																					[Local `(18948):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					0
																			[Var `(18950):haxe.macro.TypedExpr]
																				[EnumParameter:haxe.macro.TypedExpr]
																					[Local `(18948):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					1
																			[Var `(18951):haxe.macro.TypedExpr]
																				[EnumParameter:haxe.macro.TypedExpr]
																					[Local `(18948):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					2
																			[If:Void]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(18949):haxe.macro.Binop:haxe.macro.Binop]
																					==
																					[Const:Int] 0
																				[Then:Void] [Block:Void]
																					[Block:Void]
																						[Var left(18952):haxe.macro.TypedExpr] [Local `(18950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Var right(18953):haxe.macro.TypedExpr] [Local `(18951):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Block:Void]
																							[Meta:Void]
																								:ast(switch (right.expr) {
	case TArrayDecl([transformExpr]):
		transformationExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, itemVarName);	
	case _:
})
																								[Block:Void]
																									[Var `(18954):haxe.macro.TypedExprDef]
																										[Field:haxe.macro.TypedExprDef]
																											[Local right(18953):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																											[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																									[If:Void]
																										[Binop:Bool]
																											[EnumIndex:Int] [Local `(18954):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																											==
																											[Const:Int] 8
																										[Then:Void] [Block:Void]
																											[Var `(18955):Array<haxe.macro.TypedExpr>]
																												[EnumParameter:Array<haxe.macro.TypedExpr>]
																													[Local `(18954):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																													TArrayDecl
																													0
																											[If:Void]
																												[Binop:Bool]
																													[Field:Int]
																														[Local `(18955):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																														[FInstance:Int]
																															Array<haxe.macro.TypedExpr>
																															length:Int
																													==
																													[Const:Int] 1
																												[Then:String] [Block:String]
																													[Var `(18956):haxe.macro.TypedExpr]
																														[Array:haxe.macro.TypedExpr]
																															[Local `(18955):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																															[Const:Int] 0
																													[Block:String]
																														[Var transformExpr(18957):haxe.macro.TypedExpr] [Local `(18956):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																														[Block:String]
																															[Binop:String]
																																[Local transformationExpr(18294):String:String]
																																=
																																[Call:String]
																																	[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																		[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																			reflaxe.elixir.helpers.LoopCompiler
																																			substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
																																	[Call:Null<String>]
																																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																			[Field:reflaxe.elixir.ElixirCompiler]
																																				[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																				[FInstance:reflaxe.elixir.ElixirCompiler]
																																					reflaxe.elixir.helpers.LoopCompiler
																																					compiler:reflaxe.elixir.ElixirCompiler
																																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																				reflaxe.elixir.ElixirCompiler
																																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																																		[Local transformExpr(18957):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																		[Const:Null<Bool>] null
																																	[Local indexVar(18290):String:String]
																																	[Local accumVar(18291):String:String]
																																	[Local itemVarName(18296):String:String]
																												[Else:Void] [Block:Void]
																										[Else:Void] [Block:Void]
																				[Else:Void] [Block:Void]
																		[Else:Void] [Block:Void]
												[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
									[Case:Void]
										[Const:Int] 9
										[Block:Void]
											[Var `(18958):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TCall
													0
											[Var `(18959):Array<haxe.macro.TypedExpr>]
												[EnumParameter:Array<haxe.macro.TypedExpr>]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TCall
													1
											[Block:Void]
												[Var fn(18960):haxe.macro.TypedExpr] [Local `(18958):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var args(18961):Array<haxe.macro.TypedExpr>] [Local `(18959):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Block:Void]
													[Meta:Void]
														:ast(switch (fn.expr) {
	case TField(obj, field):
		switch (field) {
			case FInstance(_, _, cf) if (cf.get().name == "push"):
				hasAssignment = true;
				if (args.length > 0) {
					var isNestedArrayResult = false;
					switch (args[0].expr) {
						case TLocal(v):
							var varName = CompilerUtilities.toElixirVarName(v);
							if (varName.indexOf("temp_array") >= 0) {
								for (i  in  0 ... exprs.length) {
									switch (exprs[i].expr) {
										case TVar(tvar, init) if (init == null):
											var thisVarName = CompilerUtilities.toElixirVarName(tvar);
											if (thisVarName == varName) {
												for (j  in  (i + 1) ... exprs.length) {
													switch (exprs[j].expr) {
														case TBinop(OpAssign, e1, e2):
															var leftSide = compiler.compileExpression(e1);
															if (leftSide == varName) {
																switch (e2.expr) {
																	case TBlock(blockExprs):
																		for (blockExpr  in  blockExprs) {
																			switch (blockExpr.expr) {
																				case TWhile(econd, ebody, normalWhile):
																					var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
																					if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
																						transformationExpr = nestedOp;
																						isNestedArrayResult = true;
																						break;
																					};																				
																				case _:
																			};
																		};																	
																	case _:
																};
															};														
														case _:
													};
												};
											};										
										case _:
									};
								};
								if (!isNestedArrayResult) { };
							};						
						case _:
					};
					if (!isNestedArrayResult) {
						var compiledArg = compiler.compileExpression(args[0]);
						transformationExpr = substituteVariableNamesWithItem(compiledArg, indexVar, accumVar, itemVarName);
					};
				};			
			case _:
				continue;			
		};	
	case _:
		continue;	
})
														[Block:Void]
															[Var `(18962):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local fn(18960):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Void]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(18962):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 4
																[Then:Void] [Block:Void]
																	[Var `(18963):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18962):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			0
																	[Var `(18964):haxe.macro.FieldAccess]
																		[EnumParameter:haxe.macro.FieldAccess]
																			[Local `(18962):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			1
																	[Block:Void]
																		[Var obj(18965):haxe.macro.TypedExpr] [Local `(18963):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var field(18966):haxe.macro.FieldAccess] [Local `(18964):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		[Block:Void]
																			[Meta:Void]
																				:ast(switch (field) {
	case FInstance(_, _, cf) if (cf.get().name == "push"):
		hasAssignment = true;
		if (args.length > 0) {
			var isNestedArrayResult = false;
			switch (args[0].expr) {
				case TLocal(v):
					var varName = CompilerUtilities.toElixirVarName(v);
					if (varName.indexOf("temp_array") >= 0) {
						for (i  in  0 ... exprs.length) {
							switch (exprs[i].expr) {
								case TVar(tvar, init) if (init == null):
									var thisVarName = CompilerUtilities.toElixirVarName(tvar);
									if (thisVarName == varName) {
										for (j  in  (i + 1) ... exprs.length) {
											switch (exprs[j].expr) {
												case TBinop(OpAssign, e1, e2):
													var leftSide = compiler.compileExpression(e1);
													if (leftSide == varName) {
														switch (e2.expr) {
															case TBlock(blockExprs):
																for (blockExpr  in  blockExprs) {
																	switch (blockExpr.expr) {
																		case TWhile(econd, ebody, normalWhile):
																			var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
																			if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
																				transformationExpr = nestedOp;
																				isNestedArrayResult = true;
																				break;
																			};																		
																		case _:
																	};
																};															
															case _:
														};
													};												
												case _:
											};
										};
									};								
								case _:
							};
						};
						if (!isNestedArrayResult) { };
					};				
				case _:
			};
			if (!isNestedArrayResult) {
				var compiledArg = compiler.compileExpression(args[0]);
				transformationExpr = substituteVariableNamesWithItem(compiledArg, indexVar, accumVar, itemVarName);
			};
		};	
	case _:
		continue;	
})
																				[If:Void]
																					[Binop:Bool]
																						[EnumIndex:Int] [Local field(18966):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						==
																						[Const:Int] 0
																					[Then:Void] [Block:Void]
																						[Var `(18967):haxe.macro.Ref<haxe.macro.ClassType>]
																							[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																								[Local field(18966):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																								FInstance
																								0
																						[Var `(18968):Array<haxe.macro.Type>]
																							[EnumParameter:Array<haxe.macro.Type>]
																								[Local field(18966):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																								FInstance
																								1
																						[Var `(18969):haxe.macro.Ref<haxe.macro.ClassField>]
																							[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																								[Local field(18966):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																								FInstance
																								2
																						[Block:Void]
																							[Var cf(18970):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(18969):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																							[If:Void]
																								[Binop:Bool]
																									[Field:String]
																										[Call:haxe.macro.ClassField]
																											[Field:() -> haxe.macro.ClassField]
																												[Local cf(18970):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																												[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																										[FAnon:String] name:String
																									==
																									[Const:String] "push"
																								[Then:Void] [Block:Void]
																									[Binop:Bool]
																										[Local hasAssignment(18293):Bool:Bool]
																										=
																										[Const:Bool] true
																									[If:Void]
																										[Binop:Bool]
																											[Field:Int]
																												[Local args(18961):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																												[FInstance:Int]
																													Array<haxe.macro.TypedExpr>
																													length:Int
																											>
																											[Const:Int] 0
																										[Then:Void] [Block:Void]
																											[Var isNestedArrayResult(18971):Bool] [Const:Bool] false
																											[Meta:Void]
																												:ast(switch (args[0].expr) {
	case TLocal(v):
		var varName = CompilerUtilities.toElixirVarName(v);
		if (varName.indexOf("temp_array") >= 0) {
			for (i  in  0 ... exprs.length) {
				switch (exprs[i].expr) {
					case TVar(tvar, init) if (init == null):
						var thisVarName = CompilerUtilities.toElixirVarName(tvar);
						if (thisVarName == varName) {
							for (j  in  (i + 1) ... exprs.length) {
								switch (exprs[j].expr) {
									case TBinop(OpAssign, e1, e2):
										var leftSide = compiler.compileExpression(e1);
										if (leftSide == varName) {
											switch (e2.expr) {
												case TBlock(blockExprs):
													for (blockExpr  in  blockExprs) {
														switch (blockExpr.expr) {
															case TWhile(econd, ebody, normalWhile):
																var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
																if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
																	transformationExpr = nestedOp;
																	isNestedArrayResult = true;
																	break;
																};															
															case _:
														};
													};												
												case _:
											};
										};									
									case _:
								};
							};
						};					
					case _:
				};
			};
			if (!isNestedArrayResult) { };
		};	
	case _:
})
																												[Block:Void]
																													[Var `(18972):haxe.macro.TypedExprDef]
																														[Field:haxe.macro.TypedExprDef]
																															[Array:haxe.macro.TypedExpr]
																																[Local args(18961):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																[Const:Int] 0
																															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																													[If:Void]
																														[Binop:Bool]
																															[EnumIndex:Int] [Local `(18972):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																															==
																															[Const:Int] 1
																														[Then:Void] [Block:Void]
																															[Var `(18973):haxe.macro.TVar]
																																[EnumParameter:haxe.macro.TVar]
																																	[Local `(18972):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																	TLocal
																																	0
																															[Block:Void]
																																[Var v(18974):haxe.macro.TVar] [Local `(18973):haxe.macro.TVar:haxe.macro.TVar]
																																[Block:Void]
																																	[Var varName(18975):String]
																																		[Call:String]
																																			[Field:(v : haxe.macro.TVar) -> String]
																																				[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																																				[FStatic:(v : haxe.macro.TVar) -> String]
																																					reflaxe.elixir.helpers.CompilerUtilities
																																					toElixirVarName:(v : haxe.macro.TVar) -> String
																																			[Local v(18974):haxe.macro.TVar:haxe.macro.TVar]
																																	[If:Void]
																																		[Binop:Bool]
																																			[Call:Int]
																																				[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																																					[Local varName(18975):String:String]
																																					[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																																						String
																																						indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																																				[Const:String] "temp_array"
																																				[Const:Null<Int>] null
																																			>=
																																			[Const:Int] 0
																																		[Then:Void] [Block:Void]
																																			[Block:Void]
																																				[Var `(18976):Int] [Const:Int] 0
																																				[Var `(18977):Int]
																																					[Field:Int]
																																						[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																						[FInstance:Int]
																																							Array<haxe.macro.TypedExpr>
																																							length:Int
																																				[While:Void]
																																					[Binop:Bool]
																																						[Local `(18976):Int:Int]
																																						<
																																						[Local `(18977):Int:Int]
																																					[Block:Void]
																																						[Var i(18978):Int]
																																							[Unop:Int]
																																								++
																																								Postfix
																																								[Local `(18976):Int:Int]
																																						[Meta:Void]
																																							:ast(switch (exprs[i].expr) {
	case TVar(tvar, init) if (init == null):
		var thisVarName = CompilerUtilities.toElixirVarName(tvar);
		if (thisVarName == varName) {
			for (j  in  (i + 1) ... exprs.length) {
				switch (exprs[j].expr) {
					case TBinop(OpAssign, e1, e2):
						var leftSide = compiler.compileExpression(e1);
						if (leftSide == varName) {
							switch (e2.expr) {
								case TBlock(blockExprs):
									for (blockExpr  in  blockExprs) {
										switch (blockExpr.expr) {
											case TWhile(econd, ebody, normalWhile):
												var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
												if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
													transformationExpr = nestedOp;
													isNestedArrayResult = true;
													break;
												};											
											case _:
										};
									};								
								case _:
							};
						};					
					case _:
				};
			};
		};	
	case _:
})
																																							[Block:Void]
																																								[Var `(18979):haxe.macro.TypedExprDef]
																																									[Field:haxe.macro.TypedExprDef]
																																										[Array:haxe.macro.TypedExpr]
																																											[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																											[Local i(18978):Int:Int]
																																										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																																								[If:Void]
																																									[Binop:Bool]
																																										[EnumIndex:Int] [Local `(18979):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																										==
																																										[Const:Int] 13
																																									[Then:Void] [Block:Void]
																																										[Var `(18980):haxe.macro.TVar]
																																											[EnumParameter:haxe.macro.TVar]
																																												[Local `(18979):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																												TVar
																																												0
																																										[Var `(18981):Null<haxe.macro.TypedExpr>]
																																											[EnumParameter:Null<haxe.macro.TypedExpr>]
																																												[Local `(18979):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																												TVar
																																												1
																																										[Block:Void]
																																											[Var tvar(18982):haxe.macro.TVar] [Local `(18980):haxe.macro.TVar:haxe.macro.TVar]
																																											[Var init(18983):Null<haxe.macro.TypedExpr>] [Local `(18981):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																																											[If:Void]
																																												[Binop:Bool]
																																													[Local init(18983):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																																													==
																																													[Const:Null<haxe.macro.TypedExpr>] null
																																												[Then:Void] [Block:Void]
																																													[Var thisVarName(18984):String]
																																														[Call:String]
																																															[Field:(v : haxe.macro.TVar) -> String]
																																																[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																																																[FStatic:(v : haxe.macro.TVar) -> String]
																																																	reflaxe.elixir.helpers.CompilerUtilities
																																																	toElixirVarName:(v : haxe.macro.TVar) -> String
																																															[Local tvar(18982):haxe.macro.TVar:haxe.macro.TVar]
																																													[If:Void]
																																														[Binop:Bool]
																																															[Local thisVarName(18984):String:String]
																																															==
																																															[Local varName(18975):String:String]
																																														[Then:Void] [Block:Void]
																																															[Block:Void]
																																																[Var `(18985):Int]
																																																	[Parenthesis:Int]
																																																		[Binop:Int]
																																																			[Local i(18978):Int:Int]
																																																			+
																																																			[Const:Int] 1
																																																[Var `(18986):Int]
																																																	[Field:Int]
																																																		[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																																		[FInstance:Int]
																																																			Array<haxe.macro.TypedExpr>
																																																			length:Int
																																																[While:Void]
																																																	[Binop:Bool]
																																																		[Local `(18985):Int:Int]
																																																		<
																																																		[Local `(18986):Int:Int]
																																																	[Block:Void]
																																																		[Var j(18987):Int]
																																																			[Unop:Int]
																																																				++
																																																				Postfix
																																																				[Local `(18985):Int:Int]
																																																		[Meta:Void]
																																																			:ast(switch (exprs[j].expr) {
	case TBinop(OpAssign, e1, e2):
		var leftSide = compiler.compileExpression(e1);
		if (leftSide == varName) {
			switch (e2.expr) {
				case TBlock(blockExprs):
					for (blockExpr  in  blockExprs) {
						switch (blockExpr.expr) {
							case TWhile(econd, ebody, normalWhile):
								var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
								if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
									transformationExpr = nestedOp;
									isNestedArrayResult = true;
									break;
								};							
							case _:
						};
					};				
				case _:
			};
		};	
	case _:
})
																																																			[Block:Void]
																																																				[Var `(18988):haxe.macro.TypedExprDef]
																																																					[Field:haxe.macro.TypedExprDef]
																																																						[Array:haxe.macro.TypedExpr]
																																																							[Local exprs(18289):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																																							[Local j(18987):Int:Int]
																																																						[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																																																				[If:Void]
																																																					[Binop:Bool]
																																																						[EnumIndex:Int] [Local `(18988):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																						==
																																																						[Const:Int] 3
																																																					[Then:Void] [Block:Void]
																																																						[Var `(18989):haxe.macro.Binop]
																																																							[EnumParameter:haxe.macro.Binop]
																																																								[Local `(18988):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																								TBinop
																																																								0
																																																						[Var `(18990):haxe.macro.TypedExpr]
																																																							[EnumParameter:haxe.macro.TypedExpr]
																																																								[Local `(18988):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																								TBinop
																																																								1
																																																						[Var `(18991):haxe.macro.TypedExpr]
																																																							[EnumParameter:haxe.macro.TypedExpr]
																																																								[Local `(18988):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																								TBinop
																																																								2
																																																						[If:Void]
																																																							[Binop:Bool]
																																																								[EnumIndex:Int] [Local `(18989):haxe.macro.Binop:haxe.macro.Binop]
																																																								==
																																																								[Const:Int] 4
																																																							[Then:Void] [Block:Void]
																																																								[Block:Void]
																																																									[Var e1(18992):haxe.macro.TypedExpr] [Local `(18990):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																									[Var e2(18993):haxe.macro.TypedExpr] [Local `(18991):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																									[Block:Void]
																																																										[Var leftSide(18994):Null<String>]
																																																											[Call:Null<String>]
																																																												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																																													[Field:reflaxe.elixir.ElixirCompiler]
																																																														[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																																														[FInstance:reflaxe.elixir.ElixirCompiler]
																																																															reflaxe.elixir.helpers.LoopCompiler
																																																															compiler:reflaxe.elixir.ElixirCompiler
																																																													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																																														reflaxe.elixir.ElixirCompiler
																																																														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																																																												[Local e1(18992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																												[Const:Null<Bool>] null
																																																										[If:Void]
																																																											[Binop:Bool]
																																																												[Local leftSide(18994):Null<String>:Null<String>]
																																																												==
																																																												[Local varName(18975):String:String]
																																																											[Then:Void] [Block:Void]
																																																												[Meta:Void]
																																																													:ast(switch (e2.expr) {
	case TBlock(blockExprs):
		for (blockExpr  in  blockExprs) {
			switch (blockExpr.expr) {
				case TWhile(econd, ebody, normalWhile):
					var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
					if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
						transformationExpr = nestedOp;
						isNestedArrayResult = true;
						break;
					};				
				case _:
			};
		};	
	case _:
})
																																																													[Block:Void]
																																																														[Var `(18995):haxe.macro.TypedExprDef]
																																																															[Field:haxe.macro.TypedExprDef]
																																																																[Local e2(18993):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																																																														[If:Void]
																																																															[Binop:Bool]
																																																																[EnumIndex:Int] [Local `(18995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																==
																																																																[Const:Int] 14
																																																															[Then:Void] [Block:Void]
																																																																[Var `(18996):Array<haxe.macro.TypedExpr>]
																																																																	[EnumParameter:Array<haxe.macro.TypedExpr>]
																																																																		[Local `(18995):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																		TBlock
																																																																		0
																																																																[Block:Void]
																																																																	[Var blockExprs(18997):Array<haxe.macro.TypedExpr>] [Local `(18996):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																																																	[Block:Void]
																																																																		[Block:Void]
																																																																			[Var `(18998):Int] [Const:Int] 0
																																																																			[While:Void]
																																																																				[Binop:Bool]
																																																																					[Local `(18998):Int:Int]
																																																																					<
																																																																					[Field:Int]
																																																																						[Local blockExprs(18997):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																																																						[FInstance:Int]
																																																																							Array<haxe.macro.TypedExpr>
																																																																							length:Int
																																																																				[Block:Void]
																																																																					[Var blockExpr(18999):haxe.macro.TypedExpr]
																																																																						[Array:haxe.macro.TypedExpr]
																																																																							[Local blockExprs(18997):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																																																							[Local `(18998):Int:Int]
																																																																					[Unop:Int]
																																																																						++
																																																																						Prefix
																																																																						[Local `(18998):Int:Int]
																																																																					[Meta:Void]
																																																																						:ast(switch (blockExpr.expr) {
	case TWhile(econd, ebody, normalWhile):
		var nestedOp = compileWhileLoop(econd, ebody, normalWhile);
		if (nestedOp != null && nestedOp.indexOf("Enum.") >= 0) {
			transformationExpr = nestedOp;
			isNestedArrayResult = true;
			break;
		};	
	case _:
})
																																																																						[Block:Void]
																																																																							[Var `(19000):haxe.macro.TypedExprDef]
																																																																								[Field:haxe.macro.TypedExprDef]
																																																																									[Local blockExpr(18999):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																									[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																																																																							[If:Void]
																																																																								[Binop:Bool]
																																																																									[EnumIndex:Int] [Local `(19000):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																									==
																																																																									[Const:Int] 17
																																																																								[Then:Void] [Block:Void]
																																																																									[Var `(19001):haxe.macro.TypedExpr]
																																																																										[EnumParameter:haxe.macro.TypedExpr]
																																																																											[Local `(19000):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																											TWhile
																																																																											0
																																																																									[Var `(19002):haxe.macro.TypedExpr]
																																																																										[EnumParameter:haxe.macro.TypedExpr]
																																																																											[Local `(19000):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																											TWhile
																																																																											1
																																																																									[Var `(19003):Bool]
																																																																										[EnumParameter:Bool]
																																																																											[Local `(19000):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																																																											TWhile
																																																																											2
																																																																									[Block:Void]
																																																																										[Var econd(19004):haxe.macro.TypedExpr] [Local `(19001):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																										[Var ebody(19005):haxe.macro.TypedExpr] [Local `(19002):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																										[Var normalWhile(19006):Bool] [Local `(19003):Bool:Bool]
																																																																										[Block:Void]
																																																																											[Var nestedOp(19007):String]
																																																																												[Call:String]
																																																																													[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																																																																														[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																																																														[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
																																																																															reflaxe.elixir.helpers.LoopCompiler
																																																																															compileWhileLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
																																																																													[Local econd(19004):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																													[Local ebody(19005):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																																																													[Local normalWhile(19006):Bool:Bool]
																																																																											[If:Void]
																																																																												[Binop:Bool]
																																																																													[Binop:Bool]
																																																																														[Local nestedOp(19007):String:String]
																																																																														!=
																																																																														[Const:String] null
																																																																													&&
																																																																													[Binop:Bool]
																																																																														[Call:Int]
																																																																															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																																																																																[Local nestedOp(19007):String:String]
																																																																																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																																																																																	String
																																																																																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																																																																															[Const:String] "Enum."
																																																																															[Const:Null<Int>] null
																																																																														>=
																																																																														[Const:Int] 0
																																																																												[Then:Dynamic] [Block:Dynamic]
																																																																													[Binop:String]
																																																																														[Local transformationExpr(18294):String:String]
																																																																														=
																																																																														[Local nestedOp(19007):String:String]
																																																																													[Binop:Bool]
																																																																														[Local isNestedArrayResult(18971):Bool:Bool]
																																																																														=
																																																																														[Const:Bool] true
																																																																													[Break:Dynamic]
																																																																								[Else:Void] [Block:Void]
																																																															[Else:Void] [Block:Void]
																																																							[Else:Void] [Block:Void]
																																																					[Else:Void] [Block:Void]
																																												[Else:Void] [Block:Void]
																																									[Else:Void] [Block:Void]
																																			[If:Void]
																																				[Unop:Bool]
																																					!
																																					Prefix
																																					[Local isNestedArrayResult(18971):Bool:Bool]
																																				[Then:Void] [Block:Void]
																														[Else:Void] [Block:Void]
																											[If:Void]
																												[Unop:Bool]
																													!
																													Prefix
																													[Local isNestedArrayResult(18971):Bool:Bool]
																												[Then:String] [Block:String]
																													[Var compiledArg(19008):Null<String>]
																														[Call:Null<String>]
																															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																[Field:reflaxe.elixir.ElixirCompiler]
																																	[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																	[FInstance:reflaxe.elixir.ElixirCompiler]
																																		reflaxe.elixir.helpers.LoopCompiler
																																		compiler:reflaxe.elixir.ElixirCompiler
																																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																	reflaxe.elixir.ElixirCompiler
																																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																															[Array:haxe.macro.TypedExpr]
																																[Local args(18961):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																																[Const:Int] 0
																															[Const:Null<Bool>] null
																													[Binop:String]
																														[Local transformationExpr(18294):String:String]
																														=
																														[Call:String]
																															[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																	reflaxe.elixir.helpers.LoopCompiler
																																	substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
																															[Local compiledArg(19008):Null<String>:Null<String>]
																															[Local indexVar(18290):String:String]
																															[Local accumVar(18291):String:String]
																															[Local itemVarName(18296):String:String]
																								[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
																					[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
																[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
									[Case:String]
										[Const:Int] 16
										[Block:String]
											[Var `(19009):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													0
											[Var `(19010):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													1
											[Var `(19011):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(18942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													2
											[Block:String]
												[Var condition(19012):haxe.macro.TypedExpr] [Local `(19009):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var thenExpr(19013):haxe.macro.TypedExpr] [Local `(19010):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var elseExpr(19014):Null<haxe.macro.TypedExpr>] [Local `(19011):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:String]
													[Binop:Bool]
														[Local hasConditional(18292):Bool:Bool]
														=
														[Const:Bool] true
													[Binop:String]
														[Local conditionExpr(18295):String:String]
														=
														[Call:String]
															[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																	reflaxe.elixir.helpers.LoopCompiler
																	substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local condition(19012):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
															[Local indexVar(18290):String:String]
															[Local accumVar(18291):String:String]
															[Local itemVarName(18296):String:String]
									[Default:Dynamic] [Block:Dynamic] [Continue:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local hasConditional(18292):Bool:Bool]
					&&
					[Local hasAssignment(18293):Bool:Bool]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[ObjectDecl:{ type : String, expression : String }]
							type: [Const:String] "filter"
							expression: [Local conditionExpr(18295):String:String]
				[Else:Void] [Block:Void]
					[If:Void]
						[Local hasConditional(18292):Bool:Bool]
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[ObjectDecl:{ type : String, expression : String }]
									type: [Const:String] "filter"
									expression: [Local conditionExpr(18295):String:String]
						[Else:Void] [Block:Void]
							[If:Void]
								[Local hasAssignment(18293):Bool:Bool]
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[ObjectDecl:{ type : String, expression : String }]
											type: [Const:String] "map"
											expression: [Local transformationExpr(18294):String:String]
								[Else:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[ObjectDecl:{ type : String, expression : String }]
											type: [Const:String] "each"
											expression: [Const:String] "item"

	function classifyConditionalPattern[Function:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
		[Arg:haxe.macro.TypedExpr] [Local condition(19019):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local thenExpr(19020):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local elseExpr(19021):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(19022):String]
		[Arg:String] [Local accumVar(19023):String]
		[Block:Dynamic]
			[Var conditionStr(19024):String]
				[Call:String]
					[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
					[Call:Null<String>]
						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.LoopCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								reflaxe.elixir.ElixirCompiler
								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
						[Local condition(19019):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Const:Null<Bool>] null
					[Local indexVar(19022):String:String]
					[Local accumVar(19023):String:String]
					[Const:String] "item"
			[Return:Dynamic]
				[ObjectDecl:{ type : String, expression : String }]
					type: [Const:String] "filter"
					expression: [Local conditionStr(19024):String:String]

	function classifyAssignmentPattern[Function:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> { type : String, expression : String }]
		[Arg:haxe.macro.TypedExpr] [Local target(19027):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local value(19028):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(19029):String]
		[Arg:String] [Local accumVar(19030):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (value.expr) {
	case TBinop(OpAdd, left, right):
		switch (right.expr) {
			case TArrayDecl([transformExpr]):
				var transformStr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, "item");
				return { type : "map", expression : transformStr };			
			case _:
		};	
	case _:
})
				[Block:Void]
					[Var `(19047):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local value(19028):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(19047):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 3
						[Then:Void] [Block:Void]
							[Var `(19048):haxe.macro.Binop]
								[EnumParameter:haxe.macro.Binop]
									[Local `(19047):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									0
							[Var `(19049):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(19047):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									1
							[Var `(19050):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(19047):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									2
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(19048):haxe.macro.Binop:haxe.macro.Binop]
									==
									[Const:Int] 0
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var left(19051):haxe.macro.TypedExpr] [Local `(19049):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var right(19052):haxe.macro.TypedExpr] [Local `(19050):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Void]
											[Meta:Void]
												:ast(switch (right.expr) {
	case TArrayDecl([transformExpr]):
		var transformStr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, "item");
		return { type : "map", expression : transformStr };	
	case _:
})
												[Block:Void]
													[Var `(19053):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Local right(19052):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:Void]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(19053):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:Void] [Block:Void]
															[Var `(19054):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(19053):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[If:Void]
																[Binop:Bool]
																	[Field:Int]
																		[Local `(19054):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																	==
																	[Const:Int] 1
																[Then:Dynamic] [Block:Dynamic]
																	[Var `(19055):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(19054):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																	[Block:Dynamic]
																		[Var transformExpr(19056):haxe.macro.TypedExpr] [Local `(19055):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Var transformStr(19057):String]
																				[Call:String]
																					[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																						[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																							reflaxe.elixir.helpers.LoopCompiler
																							substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
																					[Call:Null<String>]
																						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							[Field:reflaxe.elixir.ElixirCompiler]
																								[Const:reflaxe.elixir.helpers.LoopCompiler] this
																								[FInstance:reflaxe.elixir.ElixirCompiler]
																									reflaxe.elixir.helpers.LoopCompiler
																									compiler:reflaxe.elixir.ElixirCompiler
																							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								reflaxe.elixir.ElixirCompiler
																								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																						[Local transformExpr(19056):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Const:Null<Bool>] null
																					[Local indexVar(19029):String:String]
																					[Local accumVar(19030):String:String]
																					[Const:String] "item"
																			[Return:Dynamic]
																				[ObjectDecl:{ type : String, expression : String }]
																					type: [Const:String] "map"
																					expression: [Local transformStr(19057):String:String]
																[Else:Void] [Block:Void]
														[Else:Void] [Block:Void]
								[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[Return:Dynamic]
				[ObjectDecl:{ type : String, expression : String }]
					type: [Const:String] "reduce"
					expression: [Const:String] "item"

	function substituteVariableNames[Function:(expression : String, indexVar : String, accumVar : String) -> String]
		[Arg:String] [Local expression(28479):String]
		[Arg:String] [Local indexVar(28480):String]
		[Arg:String] [Local accumVar(28481):String]
		[Block:Dynamic]
			[Var result(28482):String] [Local expression(28479):String:String]
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local accumVar(28481):String:String]
								+
								[Const:String] "["
							+
							[Local indexVar(28480):String:String]
						+
						[Const:String] "]"
					[Const:String] "item"
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "Enum.at("
									+
									[Local accumVar(28481):String:String]
								+
								[Const:String] ", "
							+
							[Local indexVar(28480):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local accumVar(28481):String:String]
								+
								[Const:String] ".at("
							+
							[Local indexVar(28480):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "numbers["
							+
							[Local indexVar(28480):String:String]
						+
						[Const:String] "]"
					[Const:String] "item"
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Enum.at(numbers, "
							+
							[Local indexVar(28480):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(28482):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(28482):String:String]
					[Const:String] "n"
					[Const:String] "item"
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:(s : String, start : String) -> Bool]
							[TypeExpr StringTools:Class<StringTools>]
							[FStatic:(s : String, start : String) -> Bool]
								StringTools
								startsWith:(s : String, start : String) -> Bool
						[Local result(28482):String:String]
						[Const:String] "(("
					&&
					[Call:Bool]
						[Field:(s : String, end : String) -> Bool]
							[TypeExpr StringTools:Class<StringTools>]
							[FStatic:(s : String, end : String) -> Bool]
								StringTools
								endsWith:(s : String, end : String) -> Bool
						[Local result(28482):String:String]
						[Const:String] "))"
				[Then:String] [Block:String]
					[Binop:String]
						[Local result(28482):String:String]
						=
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local result(28482):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Const:Int] 2
							[Binop:Int]
								[Field:Int]
									[Local result(28482):String:String]
									[FInstance:Int]
										String
										length:Int
								-
								[Const:Int] 2
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:Bool]
								[Field:(s : String, start : String) -> Bool]
									[TypeExpr StringTools:Class<StringTools>]
									[FStatic:(s : String, start : String) -> Bool]
										StringTools
										startsWith:(s : String, start : String) -> Bool
								[Local result(28482):String:String]
								[Const:String] "("
							&&
							[Call:Bool]
								[Field:(s : String, end : String) -> Bool]
									[TypeExpr StringTools:Class<StringTools>]
									[FStatic:(s : String, end : String) -> Bool]
										StringTools
										endsWith:(s : String, end : String) -> Bool
								[Local result(28482):String:String]
								[Const:String] ")"
						[Then:String] [Block:String]
							[Binop:String]
								[Local result(28482):String:String]
								=
								[Call:String]
									[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
										[Local result(28482):String:String]
										[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
											String
											substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
									[Const:Int] 1
									[Binop:Int]
										[Field:Int]
											[Local result(28482):String:String]
											[FInstance:Int]
												String
												length:Int
										-
										[Const:Int] 1
			[Return:Dynamic] [Local result(28482):String:String]

	function substituteVariableNamesWithItem[Function:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
		[Arg:String] [Local expression(18313):String]
		[Arg:String] [Local indexVar(18314):String]
		[Arg:String] [Local accumVar(18315):String]
		[Arg:String] [Local itemVarName(18316):String]
		[Block:Dynamic]
			[Var result(18317):String] [Local expression(18313):String:String]
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local accumVar(18315):String:String]
								+
								[Const:String] "["
							+
							[Local indexVar(18314):String:String]
						+
						[Const:String] "]"
					[Const:String] "item"
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "Enum.at("
									+
									[Local accumVar(18315):String:String]
								+
								[Const:String] ", "
							+
							[Local indexVar(18314):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local accumVar(18315):String:String]
								+
								[Const:String] ".at("
							+
							[Local indexVar(18314):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "numbers["
							+
							[Local indexVar(18314):String:String]
						+
						[Const:String] "]"
					[Const:String] "item"
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Enum.at(numbers, "
							+
							[Local indexVar(18314):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Binop:String]
				[Local result(18317):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local result(18317):String:String]
					[Local itemVarName(18316):String:String]
					[Const:String] "item"
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:(s : String, start : String) -> Bool]
							[TypeExpr StringTools:Class<StringTools>]
							[FStatic:(s : String, start : String) -> Bool]
								StringTools
								startsWith:(s : String, start : String) -> Bool
						[Local result(18317):String:String]
						[Const:String] "(("
					&&
					[Call:Bool]
						[Field:(s : String, end : String) -> Bool]
							[TypeExpr StringTools:Class<StringTools>]
							[FStatic:(s : String, end : String) -> Bool]
								StringTools
								endsWith:(s : String, end : String) -> Bool
						[Local result(18317):String:String]
						[Const:String] "))"
				[Then:String] [Block:String]
					[Binop:String]
						[Local result(18317):String:String]
						=
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local result(18317):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Const:Int] 2
							[Binop:Int]
								[Field:Int]
									[Local result(18317):String:String]
									[FInstance:Int]
										String
										length:Int
								-
								[Const:Int] 2
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:Bool]
								[Field:(s : String, start : String) -> Bool]
									[TypeExpr StringTools:Class<StringTools>]
									[FStatic:(s : String, start : String) -> Bool]
										StringTools
										startsWith:(s : String, start : String) -> Bool
								[Local result(18317):String:String]
								[Const:String] "("
							&&
							[Call:Bool]
								[Field:(s : String, end : String) -> Bool]
									[TypeExpr StringTools:Class<StringTools>]
									[FStatic:(s : String, end : String) -> Bool]
										StringTools
										endsWith:(s : String, end : String) -> Bool
								[Local result(18317):String:String]
								[Const:String] ")"
						[Then:String] [Block:String]
							[Binop:String]
								[Local result(18317):String:String]
								=
								[Call:String]
									[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
										[Local result(18317):String:String]
										[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
											String
											substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
									[Const:Int] 1
									[Binop:Int]
										[Field:Int]
											[Local result(18317):String:String]
											[FInstance:Int]
												String
												length:Int
										-
										[Const:Int] 1
			[Return:Dynamic] [Local result(18317):String:String]

	function analyzeSimpleArrayLoopBody[Function:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18114):haxe.macro.TypedExpr]
		[Arg:{ indexVar : String, arrayVar : String }] [Local conditionInfo(18115):{ indexVar : String, arrayVar : String }]
		[Block:Void]
			[Meta:Void]
				:ast(switch (ebody.expr) {
	case TBlock(exprs):
		var itemVar:String = null;
		var hasIncrement = false;
		var accumulator:String = null;
		var operation:TypedExpr = null;
		for (i  in  0 ... exprs.length) {
			var expr = exprs[i];
			switch (expr.expr) {
				case TVar(tvar, init) if (init != null):
					itemVar = CompilerUtilities.toElixirVarName(tvar);				
				case TUnop(OpIncrement, _, e):
					hasIncrement = true;				
				case TIf(condition, thenExpr, elseExpr):
					operation = expr;
					accumulator = "evens";				
				case TBinop(OpAssign, target, value):
					operation = expr;
					switch (target.expr) {
						case TLocal(v):
							accumulator = CompilerUtilities.toElixirVarName(v);						
						case _:
							accumulator = "result";						
					};				
				case TCall(fn, args):
					switch (fn.expr) {
						case TField(obj, field):
							switch (field) {
								case FInstance(_, _, cf) if (cf.get().name == "push"):
									switch (obj.expr) {
										case TLocal(v):
											accumulator = CompilerUtilities.toElixirVarName(v);
											operation = expr;										
										case _:
									};								
								case _:
							};						
						case _:
					};				
				case _:
			};
		};
		if (itemVar != null && hasIncrement && operation != null) {
			return { itemVar : itemVar, accumulator : accumulator, hasIncrement : hasIncrement, operation : operation };
		} else {
			return null;
		};	
	case _:
		return null;	
})
				[Block:Void]
					[Var `(18230):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local ebody(18114):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(18230):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 14
						[Then:Void] [Block:Void]
							[Var `(18231):Array<haxe.macro.TypedExpr>]
								[EnumParameter:Array<haxe.macro.TypedExpr>]
									[Local `(18230):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBlock
									0
							[Block:Void]
								[Var exprs(18232):Array<haxe.macro.TypedExpr>] [Local `(18231):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Block:Void]
									[Var itemVar(18233):String] [Const:String] null
									[Var hasIncrement(18234):Bool] [Const:Bool] false
									[Var accumulator(18235):String] [Const:String] null
									[Var operation(18236):haxe.macro.TypedExpr] [Const:haxe.macro.TypedExpr] null
									[Block:Void]
										[Var `(18237):Int] [Const:Int] 0
										[Var `(18238):Int]
											[Field:Int]
												[Local exprs(18232):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
										[While:Void]
											[Binop:Bool]
												[Local `(18237):Int:Int]
												<
												[Local `(18238):Int:Int]
											[Block:Void]
												[Var i(18239):Int]
													[Unop:Int]
														++
														Postfix
														[Local `(18237):Int:Int]
												[Var expr(18240):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local exprs(18232):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local i(18239):Int:Int]
												[Meta:Void]
													:ast(switch (expr.expr) {
	case TVar(tvar, init) if (init != null):
		itemVar = CompilerUtilities.toElixirVarName(tvar);	
	case TUnop(OpIncrement, _, e):
		hasIncrement = true;	
	case TIf(condition, thenExpr, elseExpr):
		operation = expr;
		accumulator = "evens";	
	case TBinop(OpAssign, target, value):
		operation = expr;
		switch (target.expr) {
			case TLocal(v):
				accumulator = CompilerUtilities.toElixirVarName(v);			
			case _:
				accumulator = "result";			
		};	
	case TCall(fn, args):
		switch (fn.expr) {
			case TField(obj, field):
				switch (field) {
					case FInstance(_, _, cf) if (cf.get().name == "push"):
						switch (obj.expr) {
							case TLocal(v):
								accumulator = CompilerUtilities.toElixirVarName(v);
								operation = expr;							
							case _:
						};					
					case _:
				};			
			case _:
		};	
	case _:
})
													[Block:Void]
														[Var `(18241):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local expr(18240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[Switch:Void]
															[EnumIndex:Int] [Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															[Case:Void]
																[Const:Int] 3
																[Block:Void]
																	[Var `(18242):haxe.macro.Binop]
																		[EnumParameter:haxe.macro.Binop]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TBinop
																			0
																	[Var `(18243):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TBinop
																			1
																	[Var `(18244):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TBinop
																			2
																	[If:Void]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(18242):haxe.macro.Binop:haxe.macro.Binop]
																			==
																			[Const:Int] 4
																		[Then:Void] [Block:Void]
																			[Block:Void]
																				[Var target(18245):haxe.macro.TypedExpr] [Local `(18243):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Var value(18246):haxe.macro.TypedExpr] [Local `(18244):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Block:Void]
																					[Binop:haxe.macro.TypedExpr]
																						[Local operation(18236):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						=
																						[Local expr(18240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Meta:Void]
																						:ast(switch (target.expr) {
	case TLocal(v):
		accumulator = CompilerUtilities.toElixirVarName(v);	
	case _:
		accumulator = "result";	
})
																						[Block:Void]
																							[Var `(18247):haxe.macro.TypedExprDef]
																								[Field:haxe.macro.TypedExprDef]
																									[Local target(18245):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																									[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																							[If:Void]
																								[Binop:Bool]
																									[EnumIndex:Int] [Local `(18247):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									==
																									[Const:Int] 1
																								[Then:String] [Block:String]
																									[Var `(18248):haxe.macro.TVar]
																										[EnumParameter:haxe.macro.TVar]
																											[Local `(18247):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																											TLocal
																											0
																									[Block:String]
																										[Var v(18249):haxe.macro.TVar] [Local `(18248):haxe.macro.TVar:haxe.macro.TVar]
																										[Block:String]
																											[Binop:String]
																												[Local accumulator(18235):String:String]
																												=
																												[Call:String]
																													[Field:(v : haxe.macro.TVar) -> String]
																														[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																														[FStatic:(v : haxe.macro.TVar) -> String]
																															reflaxe.elixir.helpers.CompilerUtilities
																															toElixirVarName:(v : haxe.macro.TVar) -> String
																													[Local v(18249):haxe.macro.TVar:haxe.macro.TVar]
																								[Else:String] [Block:String]
																									[Binop:String]
																										[Local accumulator(18235):String:String]
																										=
																										[Const:String] "result"
																		[Else:Void] [Block:Void]
															[Case:Void]
																[Const:Int] 9
																[Block:Void]
																	[Var `(18250):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TCall
																			0
																	[Var `(18251):Array<haxe.macro.TypedExpr>]
																		[EnumParameter:Array<haxe.macro.TypedExpr>]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TCall
																			1
																	[Block:Void]
																		[Var fn(18252):haxe.macro.TypedExpr] [Local `(18250):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var args(18253):Array<haxe.macro.TypedExpr>] [Local `(18251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Block:Void]
																			[Meta:Void]
																				:ast(switch (fn.expr) {
	case TField(obj, field):
		switch (field) {
			case FInstance(_, _, cf) if (cf.get().name == "push"):
				switch (obj.expr) {
					case TLocal(v):
						accumulator = CompilerUtilities.toElixirVarName(v);
						operation = expr;					
					case _:
				};			
			case _:
		};	
	case _:
})
																				[Block:Void]
																					[Var `(18254):haxe.macro.TypedExprDef]
																						[Field:haxe.macro.TypedExprDef]
																							[Local fn(18252):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																					[If:Void]
																						[Binop:Bool]
																							[EnumIndex:Int] [Local `(18254):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																							==
																							[Const:Int] 4
																						[Then:Void] [Block:Void]
																							[Var `(18255):haxe.macro.TypedExpr]
																								[EnumParameter:haxe.macro.TypedExpr]
																									[Local `(18254):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TField
																									0
																							[Var `(18256):haxe.macro.FieldAccess]
																								[EnumParameter:haxe.macro.FieldAccess]
																									[Local `(18254):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TField
																									1
																							[Block:Void]
																								[Var obj(18257):haxe.macro.TypedExpr] [Local `(18255):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																								[Var field(18258):haxe.macro.FieldAccess] [Local `(18256):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																								[Block:Void]
																									[Meta:Void]
																										:ast(switch (field) {
	case FInstance(_, _, cf) if (cf.get().name == "push"):
		switch (obj.expr) {
			case TLocal(v):
				accumulator = CompilerUtilities.toElixirVarName(v);
				operation = expr;			
			case _:
		};	
	case _:
})
																										[If:Void]
																											[Binop:Bool]
																												[EnumIndex:Int] [Local field(18258):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																												==
																												[Const:Int] 0
																											[Then:Void] [Block:Void]
																												[Var `(18259):haxe.macro.Ref<haxe.macro.ClassType>]
																													[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																														[Local field(18258):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																														FInstance
																														0
																												[Var `(18260):Array<haxe.macro.Type>]
																													[EnumParameter:Array<haxe.macro.Type>]
																														[Local field(18258):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																														FInstance
																														1
																												[Var `(18261):haxe.macro.Ref<haxe.macro.ClassField>]
																													[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																														[Local field(18258):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																														FInstance
																														2
																												[Block:Void]
																													[Var cf(18262):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(18261):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																													[If:Void]
																														[Binop:Bool]
																															[Field:String]
																																[Call:haxe.macro.ClassField]
																																	[Field:() -> haxe.macro.ClassField]
																																		[Local cf(18262):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																																		[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																																[FAnon:String] name:String
																															==
																															[Const:String] "push"
																														[Then:Void] [Block:Void]
																															[Meta:Void]
																																:ast(switch (obj.expr) {
	case TLocal(v):
		accumulator = CompilerUtilities.toElixirVarName(v);
		operation = expr;	
	case _:
})
																																[Block:Void]
																																	[Var `(18263):haxe.macro.TypedExprDef]
																																		[Field:haxe.macro.TypedExprDef]
																																			[Local obj(18257):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																			[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																																	[If:Void]
																																		[Binop:Bool]
																																			[EnumIndex:Int] [Local `(18263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																			==
																																			[Const:Int] 1
																																		[Then:haxe.macro.TypedExpr] [Block:haxe.macro.TypedExpr]
																																			[Var `(18264):haxe.macro.TVar]
																																				[EnumParameter:haxe.macro.TVar]
																																					[Local `(18263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																																					TLocal
																																					0
																																			[Block:haxe.macro.TypedExpr]
																																				[Var v(18265):haxe.macro.TVar] [Local `(18264):haxe.macro.TVar:haxe.macro.TVar]
																																				[Block:haxe.macro.TypedExpr]
																																					[Binop:String]
																																						[Local accumulator(18235):String:String]
																																						=
																																						[Call:String]
																																							[Field:(v : haxe.macro.TVar) -> String]
																																								[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																																								[FStatic:(v : haxe.macro.TVar) -> String]
																																									reflaxe.elixir.helpers.CompilerUtilities
																																									toElixirVarName:(v : haxe.macro.TVar) -> String
																																							[Local v(18265):haxe.macro.TVar:haxe.macro.TVar]
																																					[Binop:haxe.macro.TypedExpr]
																																						[Local operation(18236):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																						=
																																						[Local expr(18240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																		[Else:Void] [Block:Void]
																														[Else:Void] [Block:Void]
																											[Else:Void] [Block:Void]
																						[Else:Void] [Block:Void]
															[Case:Void]
																[Const:Int] 11
																[Block:Void]
																	[Var `(18266):haxe.macro.Unop]
																		[EnumParameter:haxe.macro.Unop]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TUnop
																			0
																	[Var `(18267):Bool]
																		[EnumParameter:Bool]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TUnop
																			1
																	[Var `(18268):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TUnop
																			2
																	[If:Void]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(18266):haxe.macro.Unop:haxe.macro.Unop]
																			==
																			[Const:Int] 0
																		[Then:Bool] [Block:Bool]
																			[Block:Bool]
																				[Var e(18269):haxe.macro.TypedExpr] [Local `(18268):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Block:Bool]
																					[Binop:Bool]
																						[Local hasIncrement(18234):Bool:Bool]
																						=
																						[Const:Bool] true
																		[Else:Void] [Block:Void]
															[Case:Void]
																[Const:Int] 13
																[Block:Void]
																	[Var `(18270):haxe.macro.TVar]
																		[EnumParameter:haxe.macro.TVar]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TVar
																			0
																	[Var `(18271):Null<haxe.macro.TypedExpr>]
																		[EnumParameter:Null<haxe.macro.TypedExpr>]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TVar
																			1
																	[Block:Void]
																		[Var tvar(18272):haxe.macro.TVar] [Local `(18270):haxe.macro.TVar:haxe.macro.TVar]
																		[Var init(18273):Null<haxe.macro.TypedExpr>] [Local `(18271):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																		[If:Void]
																			[Binop:Bool]
																				[Local init(18273):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																				!=
																				[Const:Null<haxe.macro.TypedExpr>] null
																			[Then:String] [Block:String]
																				[Binop:String]
																					[Local itemVar(18233):String:String]
																					=
																					[Call:String]
																						[Field:(v : haxe.macro.TVar) -> String]
																							[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																							[FStatic:(v : haxe.macro.TVar) -> String]
																								reflaxe.elixir.helpers.CompilerUtilities
																								toElixirVarName:(v : haxe.macro.TVar) -> String
																						[Local tvar(18272):haxe.macro.TVar:haxe.macro.TVar]
																			[Else:Void] [Block:Void]
															[Case:String]
																[Const:Int] 16
																[Block:String]
																	[Var `(18274):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			0
																	[Var `(18275):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			1
																	[Var `(18276):Null<haxe.macro.TypedExpr>]
																		[EnumParameter:Null<haxe.macro.TypedExpr>]
																			[Local `(18241):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TIf
																			2
																	[Block:String]
																		[Var condition(18277):haxe.macro.TypedExpr] [Local `(18274):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var thenExpr(18278):haxe.macro.TypedExpr] [Local `(18275):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var elseExpr(18279):Null<haxe.macro.TypedExpr>] [Local `(18276):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																		[Block:String]
																			[Binop:haxe.macro.TypedExpr]
																				[Local operation(18236):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				=
																				[Local expr(18240):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Binop:String]
																				[Local accumulator(18235):String:String]
																				=
																				[Const:String] "evens"
															[Default:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Binop:Bool]
													[Local itemVar(18233):String:String]
													!=
													[Const:String] null
												&&
												[Local hasIncrement(18234):Bool:Bool]
											&&
											[Binop:Bool]
												[Local operation(18236):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												!=
												[Const:haxe.macro.TypedExpr] null
										[Then:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[ObjectDecl:{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }]
													itemVar: [Local itemVar(18233):String:String]
													accumulator: [Local accumulator(18235):String:String]
													hasIncrement: [Local hasIncrement(18234):Bool:Bool]
													operation: [Local operation(18236):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>] null
						[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ operation : haxe.macro.TypedExpr, itemVar : String, hasIncrement : Bool, accumulator : String }>] null

	function extractArrayTransformation[Function:(ebody : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(28483):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(28484):String]
		[Arg:String] [Local accumVar(28485):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (ebody.expr) {
	case TBlock(exprs):
		return analyzeAccumulationPattern(exprs, indexVar, accumVar);	
	case TIf(condition, thenExpr, elseExpr):
		return analyzeConditionalAccumulation(condition, thenExpr, elseExpr, indexVar, accumVar);	
	case TBinop(OpAssign, target, value):
		return analyzeDirectAccumulation(target, value, indexVar, accumVar);	
	case _:
		return null;	
})
				[Block:Void]
					[Var `(28720):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local ebody(28483):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 3
							[Block:Void]
								[Var `(28721):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(28722):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(28723):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(28721):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 4
									[Then:Dynamic] [Block:Dynamic]
										[Block:Dynamic]
											[Var target(28724):haxe.macro.TypedExpr] [Local `(28722):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var value(28725):haxe.macro.TypedExpr] [Local `(28723):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
														[Field:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
																reflaxe.elixir.helpers.LoopCompiler
																analyzeDirectAccumulation:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>
														[Local target(28724):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local value(28725):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local indexVar(28484):String:String]
														[Local accumVar(28485):String:String]
									[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ type : String, transform : String, itemExpr : String, condition : String }>] null
						[Case:Dynamic]
							[Const:Int] 14
							[Block:Dynamic]
								[Var `(28726):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Dynamic]
									[Var exprs(28727):Array<haxe.macro.TypedExpr>] [Local `(28726):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
												[Field:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
														reflaxe.elixir.helpers.LoopCompiler
														analyzeAccumulationPattern:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>
												[Local exprs(28727):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local indexVar(28484):String:String]
												[Local accumVar(28485):String:String]
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(28728):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(28729):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(28730):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(28720):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var condition(28731):haxe.macro.TypedExpr] [Local `(28728):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var thenExpr(28732):haxe.macro.TypedExpr] [Local `(28729):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var elseExpr(28733):Null<haxe.macro.TypedExpr>] [Local `(28730):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
												[Field:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
														reflaxe.elixir.helpers.LoopCompiler
														analyzeConditionalAccumulation:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>
												[Local condition(28731):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local thenExpr(28732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local elseExpr(28733):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Local indexVar(28484):String:String]
												[Local accumVar(28485):String:String]
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ type : String, transform : String, itemExpr : String, condition : String }>] null

	function analyzeAccumulationPattern[Function:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local exprs(28487):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local indexVar(28488):String]
		[Arg:String] [Local accumVar(28489):String]
		[Block:Dynamic]
			[Var itemVarName(28490):String] [Const:String] "item"
			[Var hasConditional(28491):Bool] [Const:Bool] false
			[Var conditionExpr(28492):String] [Const:String] null
			[Var transformExpr(28493):String] [Const:String] null
			[Var accumulationType(28494):String] [Const:String] "reduce"
			[Block:Void]
				[Var `(28506):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(28506):Int:Int]
						<
						[Field:Int]
							[Local exprs(28487):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(28495):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(28487):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(28506):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(28506):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TVar(tvar, init) if (init != null):
		itemVarName = CompilerUtilities.toElixirVarName(tvar);
		break;	
	case _:
})
							[Block:Void]
								[Var `(28501):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(28495):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(28501):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										==
										[Const:Int] 13
									[Then:Void] [Block:Void]
										[Var `(28502):haxe.macro.TVar]
											[EnumParameter:haxe.macro.TVar]
												[Local `(28501):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TVar
												0
										[Var `(28503):Null<haxe.macro.TypedExpr>]
											[EnumParameter:Null<haxe.macro.TypedExpr>]
												[Local `(28501):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TVar
												1
										[Block:Void]
											[Var tvar(28504):haxe.macro.TVar] [Local `(28502):haxe.macro.TVar:haxe.macro.TVar]
											[Var init(28505):Null<haxe.macro.TypedExpr>] [Local `(28503):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[If:Void]
												[Binop:Bool]
													[Local init(28505):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:Dynamic] [Block:Dynamic]
													[Binop:String]
														[Local itemVarName(28490):String:String]
														=
														[Call:String]
															[Field:(v : haxe.macro.TVar) -> String]
																[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																[FStatic:(v : haxe.macro.TVar) -> String]
																	reflaxe.elixir.helpers.CompilerUtilities
																	toElixirVarName:(v : haxe.macro.TVar) -> String
															[Local tvar(28504):haxe.macro.TVar:haxe.macro.TVar]
													[Break:Dynamic]
												[Else:Void] [Block:Void]
									[Else:Void] [Block:Void]
			[Block:Void]
				[Var `(28668):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(28668):Int:Int]
						<
						[Field:Int]
							[Local exprs(28487):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(28507):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(28487):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(28668):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(28668):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TIf(condition, thenExpr, elseExpr):
		hasConditional = true;
		conditionExpr = substituteVariableNamesWithItem(compiler.compileExpression(condition), indexVar, accumVar, itemVarName);
		var pushAnalysis = analyzePushOperation(thenExpr, itemVarName);
		if (pushAnalysis.isPush) {
			accumulationType = "filter";
			transformExpr = pushAnalysis.pushedValue;
		};	
	case TBinop(OpAssign, target, value):
		switch (value.expr) {
			case TBinop(OpAdd, left, right):
				switch (right.expr) {
					case TArrayDecl([transformedExpr]):
						accumulationType = "map";
						transformExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformedExpr), indexVar, accumVar, itemVarName);					
					case _:
				};			
			case _:
		};	
	case _:
		continue;	
})
							[Block:Void]
								[Var `(28645):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(28507):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 3
										[Block:Void]
											[Var `(28646):haxe.macro.Binop]
												[EnumParameter:haxe.macro.Binop]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													0
											[Var `(28647):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													1
											[Var `(28648):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													2
											[If:Void]
												[Binop:Bool]
													[EnumIndex:Int] [Local `(28646):haxe.macro.Binop:haxe.macro.Binop]
													==
													[Const:Int] 4
												[Then:Void] [Block:Void]
													[Block:Void]
														[Var target(28649):haxe.macro.TypedExpr] [Local `(28647):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Var value(28650):haxe.macro.TypedExpr] [Local `(28648):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Block:Void]
															[Meta:Void]
																:ast(switch (value.expr) {
	case TBinop(OpAdd, left, right):
		switch (right.expr) {
			case TArrayDecl([transformedExpr]):
				accumulationType = "map";
				transformExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformedExpr), indexVar, accumVar, itemVarName);			
			case _:
		};	
	case _:
})
																[Block:Void]
																	[Var `(28651):haxe.macro.TypedExprDef]
																		[Field:haxe.macro.TypedExprDef]
																			[Local value(28650):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																	[If:Void]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(28651):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			==
																			[Const:Int] 3
																		[Then:Void] [Block:Void]
																			[Var `(28652):haxe.macro.Binop]
																				[EnumParameter:haxe.macro.Binop]
																					[Local `(28651):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					0
																			[Var `(28653):haxe.macro.TypedExpr]
																				[EnumParameter:haxe.macro.TypedExpr]
																					[Local `(28651):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					1
																			[Var `(28654):haxe.macro.TypedExpr]
																				[EnumParameter:haxe.macro.TypedExpr]
																					[Local `(28651):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																					TBinop
																					2
																			[If:Void]
																				[Binop:Bool]
																					[EnumIndex:Int] [Local `(28652):haxe.macro.Binop:haxe.macro.Binop]
																					==
																					[Const:Int] 0
																				[Then:Void] [Block:Void]
																					[Block:Void]
																						[Var left(28655):haxe.macro.TypedExpr] [Local `(28653):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Var right(28656):haxe.macro.TypedExpr] [Local `(28654):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Block:Void]
																							[Meta:Void]
																								:ast(switch (right.expr) {
	case TArrayDecl([transformedExpr]):
		accumulationType = "map";
		transformExpr = substituteVariableNamesWithItem(compiler.compileExpression(transformedExpr), indexVar, accumVar, itemVarName);	
	case _:
})
																								[Block:Void]
																									[Var `(28657):haxe.macro.TypedExprDef]
																										[Field:haxe.macro.TypedExprDef]
																											[Local right(28656):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																											[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																									[If:Void]
																										[Binop:Bool]
																											[EnumIndex:Int] [Local `(28657):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																											==
																											[Const:Int] 8
																										[Then:Void] [Block:Void]
																											[Var `(28658):Array<haxe.macro.TypedExpr>]
																												[EnumParameter:Array<haxe.macro.TypedExpr>]
																													[Local `(28657):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																													TArrayDecl
																													0
																											[If:Void]
																												[Binop:Bool]
																													[Field:Int]
																														[Local `(28658):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																														[FInstance:Int]
																															Array<haxe.macro.TypedExpr>
																															length:Int
																													==
																													[Const:Int] 1
																												[Then:String] [Block:String]
																													[Var `(28659):haxe.macro.TypedExpr]
																														[Array:haxe.macro.TypedExpr]
																															[Local `(28658):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																															[Const:Int] 0
																													[Block:String]
																														[Var transformedExpr(28660):haxe.macro.TypedExpr] [Local `(28659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																														[Block:String]
																															[Binop:String]
																																[Local accumulationType(28494):String:String]
																																=
																																[Const:String] "map"
																															[Binop:String]
																																[Local transformExpr(28493):String:String]
																																=
																																[Call:String]
																																	[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																		[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																																			reflaxe.elixir.helpers.LoopCompiler
																																			substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
																																	[Call:Null<String>]
																																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																			[Field:reflaxe.elixir.ElixirCompiler]
																																				[Const:reflaxe.elixir.helpers.LoopCompiler] this
																																				[FInstance:reflaxe.elixir.ElixirCompiler]
																																					reflaxe.elixir.helpers.LoopCompiler
																																					compiler:reflaxe.elixir.ElixirCompiler
																																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																																				reflaxe.elixir.ElixirCompiler
																																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																																		[Local transformedExpr(28660):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																																		[Const:Null<Bool>] null
																																	[Local indexVar(28488):String:String]
																																	[Local accumVar(28489):String:String]
																																	[Local itemVarName(28490):String:String]
																												[Else:Void] [Block:Void]
																										[Else:Void] [Block:Void]
																				[Else:Void] [Block:Void]
																		[Else:Void] [Block:Void]
												[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
									[Case:Void]
										[Const:Int] 16
										[Block:Void]
											[Var `(28661):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													0
											[Var `(28662):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													1
											[Var `(28663):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(28645):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													2
											[Block:Void]
												[Var condition(28664):haxe.macro.TypedExpr] [Local `(28661):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var thenExpr(28665):haxe.macro.TypedExpr] [Local `(28662):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var elseExpr(28666):Null<haxe.macro.TypedExpr>] [Local `(28663):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:Void]
													[Binop:Bool]
														[Local hasConditional(28491):Bool:Bool]
														=
														[Const:Bool] true
													[Binop:String]
														[Local conditionExpr(28492):String:String]
														=
														[Call:String]
															[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																	reflaxe.elixir.helpers.LoopCompiler
																	substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local condition(28664):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
															[Local indexVar(28488):String:String]
															[Local accumVar(28489):String:String]
															[Local itemVarName(28490):String:String]
													[Var pushAnalysis(28667):{ pushedValue : String, isPush : Bool }]
														[Call:{ pushedValue : String, isPush : Bool }]
															[Field:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }]
																	reflaxe.elixir.helpers.LoopCompiler
																	analyzePushOperation:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }
															[Local thenExpr(28665):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local itemVarName(28490):String:String]
													[If:Void]
														[Field:Bool]
															[Local pushAnalysis(28667):{ pushedValue : String, isPush : Bool }:{ pushedValue : String, isPush : Bool }]
															[FAnon:Bool] isPush:Bool
														[Then:String] [Block:String]
															[Binop:String]
																[Local accumulationType(28494):String:String]
																=
																[Const:String] "filter"
															[Binop:String]
																[Local transformExpr(28493):String:String]
																=
																[Field:String]
																	[Local pushAnalysis(28667):{ pushedValue : String, isPush : Bool }:{ pushedValue : String, isPush : Bool }]
																	[FAnon:String] pushedValue:String
									[Default:Dynamic] [Block:Dynamic] [Continue:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local accumulationType(28494):String:String]
						==
						[Const:String] "filter"
					&&
					[Binop:Bool]
						[Local conditionExpr(28492):String:String]
						!=
						[Const:String] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[ObjectDecl:{ type : String, transform : String, itemExpr : String, condition : String }]
							type: [Const:String] "filter"
							condition: [Local conditionExpr(28492):String:String]
							itemExpr: [If:String]
								[Binop:Bool]
									[Local transformExpr(28493):String:String]
									!=
									[Const:String] null
								[Then:String] [Block:String] [Local transformExpr(28493):String:String]
								[Else:String] [Block:String] [Const:String] "item"
							transform: [Const:String] ""
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local accumulationType(28494):String:String]
								==
								[Const:String] "map"
							&&
							[Binop:Bool]
								[Local transformExpr(28493):String:String]
								!=
								[Const:String] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[ObjectDecl:{ type : String, transform : String, itemExpr : String, condition : String }]
									type: [Const:String] "map"
									condition: [Const:String] ""
									itemExpr: [Const:String] "item"
									transform: [Local transformExpr(28493):String:String]
			[Return:Dynamic] [Const:Null<{ type : String, transform : String, itemExpr : String, condition : String }>] null

	function analyzeConditionalAccumulation[Function:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
		[Arg:haxe.macro.TypedExpr] [Local condition(28672):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local thenExpr(28673):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local elseExpr(28674):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(28675):String]
		[Arg:String] [Local accumVar(28676):String]
		[Block:Dynamic]
			[Var conditionStr(28677):String]
				[Call:String]
					[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
					[Call:Null<String>]
						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.LoopCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.LoopCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								reflaxe.elixir.ElixirCompiler
								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
						[Local condition(28672):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Const:Null<Bool>] null
					[Local indexVar(28675):String:String]
					[Local accumVar(28676):String:String]
					[Const:String] "item"
			[Var pushAnalysis(28678):{ pushedValue : String, isPush : Bool }]
				[Call:{ pushedValue : String, isPush : Bool }]
					[Field:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }]
							reflaxe.elixir.helpers.LoopCompiler
							analyzePushOperation:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }
					[Local thenExpr(28673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:String] "item"
			[If:Void]
				[Field:Bool]
					[Local pushAnalysis(28678):{ pushedValue : String, isPush : Bool }:{ pushedValue : String, isPush : Bool }]
					[FAnon:Bool] isPush:Bool
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[ObjectDecl:{ type : String, transform : String, itemExpr : String, condition : String }]
							type: [Const:String] "filter"
							condition: [Local conditionStr(28677):String:String]
							itemExpr: [Field:String]
								[Local pushAnalysis(28678):{ pushedValue : String, isPush : Bool }:{ pushedValue : String, isPush : Bool }]
								[FAnon:String] pushedValue:String
							transform: [Const:String] ""
			[Return:Dynamic] [Const:Null<{ type : String, transform : String, itemExpr : String, condition : String }>] null

	function analyzeDirectAccumulation[Function:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<{ type : String, transform : String, itemExpr : String, condition : String }>]
		[Arg:haxe.macro.TypedExpr] [Local target(28681):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local value(28682):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(28683):String]
		[Arg:String] [Local accumVar(28684):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (value.expr) {
	case TBinop(OpAdd, left, right):
		switch (right.expr) {
			case TArrayDecl([transformExpr]):
				var transformStr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, "item");
				return { type : "map", condition : "", itemExpr : "item", transform : transformStr };			
			case _:
		};	
	case _:
})
				[Block:Void]
					[Var `(28701):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local value(28682):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(28701):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 3
						[Then:Void] [Block:Void]
							[Var `(28702):haxe.macro.Binop]
								[EnumParameter:haxe.macro.Binop]
									[Local `(28701):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									0
							[Var `(28703):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(28701):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									1
							[Var `(28704):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(28701):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									2
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(28702):haxe.macro.Binop:haxe.macro.Binop]
									==
									[Const:Int] 0
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var left(28705):haxe.macro.TypedExpr] [Local `(28703):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var right(28706):haxe.macro.TypedExpr] [Local `(28704):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Void]
											[Meta:Void]
												:ast(switch (right.expr) {
	case TArrayDecl([transformExpr]):
		var transformStr = substituteVariableNamesWithItem(compiler.compileExpression(transformExpr), indexVar, accumVar, "item");
		return { type : "map", condition : "", itemExpr : "item", transform : transformStr };	
	case _:
})
												[Block:Void]
													[Var `(28707):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Local right(28706):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:Void]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(28707):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:Void] [Block:Void]
															[Var `(28708):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(28707):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[If:Void]
																[Binop:Bool]
																	[Field:Int]
																		[Local `(28708):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																	==
																	[Const:Int] 1
																[Then:Dynamic] [Block:Dynamic]
																	[Var `(28709):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(28708):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																	[Block:Dynamic]
																		[Var transformExpr(28710):haxe.macro.TypedExpr] [Local `(28709):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Var transformStr(28711):String]
																				[Call:String]
																					[Field:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																						[FInstance:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String]
																							reflaxe.elixir.helpers.LoopCompiler
																							substituteVariableNamesWithItem:(expression : String, indexVar : String, accumVar : String, itemVarName : String) -> String
																					[Call:Null<String>]
																						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							[Field:reflaxe.elixir.ElixirCompiler]
																								[Const:reflaxe.elixir.helpers.LoopCompiler] this
																								[FInstance:reflaxe.elixir.ElixirCompiler]
																									reflaxe.elixir.helpers.LoopCompiler
																									compiler:reflaxe.elixir.ElixirCompiler
																							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								reflaxe.elixir.ElixirCompiler
																								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																						[Local transformExpr(28710):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Const:Null<Bool>] null
																					[Local indexVar(28683):String:String]
																					[Local accumVar(28684):String:String]
																					[Const:String] "item"
																			[Return:Dynamic]
																				[ObjectDecl:{ type : String, transform : String, itemExpr : String, condition : String }]
																					type: [Const:String] "map"
																					condition: [Const:String] ""
																					itemExpr: [Const:String] "item"
																					transform: [Local transformStr(28711):String:String]
																[Else:Void] [Block:Void]
														[Else:Void] [Block:Void]
								[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<{ type : String, transform : String, itemExpr : String, condition : String }>] null

	function analyzePushOperation[Function:(expr : haxe.macro.TypedExpr, itemVarName : String) -> { pushedValue : String, isPush : Bool }]
		[Arg:haxe.macro.TypedExpr] [Local expr(28511):haxe.macro.TypedExpr]
		[Arg:String] [Local itemVarName(28512):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TCall(func, args):
		switch (func.expr) {
			case TField(obj, field):
				var fieldName = switch (field) {
					case FStatic(_, cf) | FInstance(_, _, cf):
						cf.get().name;					
					case FEnum(_, ef):
						ef.name;					
					case FAnon(cf):
						cf.get().name;					
					case FDynamic(name):
						name;					
					case FClosure(_, cf):
						cf.get().name;					
				};
				if (fieldName.indexOf("push") != -1 && args.length > 0) {
					var pushedValue = compiler.compileExpression(args[0]);
					pushedValue = StringTools.replace(pushedValue, itemVarName, "item");
					return { isPush : true, pushedValue : pushedValue };
				};			
			case _:
		};	
	case _:
})
				[Block:Void]
					[Var `(28582):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(28511):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(28582):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 9
						[Then:Void] [Block:Void]
							[Var `(28583):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(28582):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TCall
									0
							[Var `(28584):Array<haxe.macro.TypedExpr>]
								[EnumParameter:Array<haxe.macro.TypedExpr>]
									[Local `(28582):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TCall
									1
							[Block:Void]
								[Var func(28585):haxe.macro.TypedExpr] [Local `(28583):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[Var args(28586):Array<haxe.macro.TypedExpr>] [Local `(28584):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Block:Void]
									[Meta:Void]
										:ast(switch (func.expr) {
	case TField(obj, field):
		var fieldName = switch (field) {
			case FStatic(_, cf) | FInstance(_, _, cf):
				cf.get().name;			
			case FEnum(_, ef):
				ef.name;			
			case FAnon(cf):
				cf.get().name;			
			case FDynamic(name):
				name;			
			case FClosure(_, cf):
				cf.get().name;			
		};
		if (fieldName.indexOf("push") != -1 && args.length > 0) {
			var pushedValue = compiler.compileExpression(args[0]);
			pushedValue = StringTools.replace(pushedValue, itemVarName, "item");
			return { isPush : true, pushedValue : pushedValue };
		};	
	case _:
})
										[Block:Void]
											[Var `(28587):haxe.macro.TypedExprDef]
												[Field:haxe.macro.TypedExprDef]
													[Local func(28585):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
											[If:Void]
												[Binop:Bool]
													[EnumIndex:Int] [Local `(28587):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													==
													[Const:Int] 4
												[Then:Void] [Block:Void]
													[Var `(28588):haxe.macro.TypedExpr]
														[EnumParameter:haxe.macro.TypedExpr]
															[Local `(28587):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															TField
															0
													[Var `(28589):haxe.macro.FieldAccess]
														[EnumParameter:haxe.macro.FieldAccess]
															[Local `(28587):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															TField
															1
													[Block:Void]
														[Var obj(28590):haxe.macro.TypedExpr] [Local `(28588):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Var field(28591):haxe.macro.FieldAccess] [Local `(28589):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
														[Block:Void]
															[Var fieldName(28592):String]
																[Meta:String]
																	:ast(switch (field) {
	case FStatic(_, cf) | FInstance(_, _, cf):
		cf.get().name;	
	case FEnum(_, ef):
		ef.name;	
	case FAnon(cf):
		cf.get().name;	
	case FDynamic(name):
		name;	
	case FClosure(_, cf):
		cf.get().name;	
})
																	[Switch:String]
																		[Meta:Int]
																			:exhaustive
																			[EnumIndex:Int] [Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		[Case:String]
																			[Const:Int] 0
																			[Block:String]
																				[Var `(28593):haxe.macro.Ref<haxe.macro.ClassType>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FInstance
																						0
																				[Var `(28594):Array<haxe.macro.Type>]
																					[EnumParameter:Array<haxe.macro.Type>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FInstance
																						1
																				[Var `(28595):haxe.macro.Ref<haxe.macro.ClassField>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FInstance
																						2
																				[Block:String]
																					[Var cf(28596):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(28595):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[Block:String]
																						[Field:String]
																							[Call:haxe.macro.ClassField]
																								[Field:() -> haxe.macro.ClassField]
																									[Local cf(28596):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																									[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																							[FAnon:String] name:String
																		[Case:String]
																			[Const:Int] 1
																			[Block:String]
																				[Var `(28597):haxe.macro.Ref<haxe.macro.ClassType>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FStatic
																						0
																				[Var `(28598):haxe.macro.Ref<haxe.macro.ClassField>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FStatic
																						1
																				[Block:String]
																					[Var cf(28599):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(28598):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[Block:String]
																						[Field:String]
																							[Call:haxe.macro.ClassField]
																								[Field:() -> haxe.macro.ClassField]
																									[Local cf(28599):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																									[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																							[FAnon:String] name:String
																		[Case:String]
																			[Const:Int] 2
																			[Block:String]
																				[Var `(28600):haxe.macro.Ref<haxe.macro.ClassField>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FAnon
																						0
																				[Block:String]
																					[Var cf(28601):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(28600):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[Block:String]
																						[Field:String]
																							[Call:haxe.macro.ClassField]
																								[Field:() -> haxe.macro.ClassField]
																									[Local cf(28601):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																									[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																							[FAnon:String] name:String
																		[Case:String]
																			[Const:Int] 3
																			[Block:String]
																				[Var `(28602):String]
																					[EnumParameter:String]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FDynamic
																						0
																				[Block:String]
																					[Var name(28603):String] [Local `(28602):String:String]
																					[Block:String] [Local name(28603):String:String]
																		[Case:String]
																			[Const:Int] 4
																			[Block:String]
																				[Var `(28604):Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																					[EnumParameter:Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FClosure
																						0
																				[Var `(28605):haxe.macro.Ref<haxe.macro.ClassField>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FClosure
																						1
																				[Block:String]
																					[Var cf(28606):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(28605):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[Block:String]
																						[Field:String]
																							[Call:haxe.macro.ClassField]
																								[Field:() -> haxe.macro.ClassField]
																									[Local cf(28606):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																									[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																							[FAnon:String] name:String
																		[Case:String]
																			[Const:Int] 5
																			[Block:String]
																				[Var `(28607):haxe.macro.Ref<haxe.macro.EnumType>]
																					[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FEnum
																						0
																				[Var `(28608):haxe.macro.EnumField]
																					[EnumParameter:haxe.macro.EnumField]
																						[Local field(28591):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																						FEnum
																						1
																				[Block:String]
																					[Var ef(28609):haxe.macro.EnumField] [Local `(28608):haxe.macro.EnumField:haxe.macro.EnumField]
																					[Block:String]
																						[Field:String]
																							[Local ef(28609):haxe.macro.EnumField:haxe.macro.EnumField]
																							[FAnon:String] name:String
															[If:Void]
																[Binop:Bool]
																	[Binop:Bool]
																		[Call:Int]
																			[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																				[Local fieldName(28592):String:String]
																				[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																					String
																					indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																			[Const:String] "push"
																			[Const:Null<Int>] null
																		!=
																		[Const:Int] -1
																	&&
																	[Binop:Bool]
																		[Field:Int]
																			[Local args(28586):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[FInstance:Int]
																				Array<haxe.macro.TypedExpr>
																				length:Int
																		>
																		[Const:Int] 0
																[Then:Dynamic] [Block:Dynamic]
																	[Var pushedValue(28610):Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.LoopCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Array:haxe.macro.TypedExpr]
																				[Local args(28586):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																				[Const:Int] 0
																			[Const:Null<Bool>] null
																	[Binop:Null<String>]
																		[Local pushedValue(28610):Null<String>:Null<String>]
																		=
																		[Call:String]
																			[Field:(s : String, sub : String, by : String) -> String]
																				[TypeExpr StringTools:Class<StringTools>]
																				[FStatic:(s : String, sub : String, by : String) -> String]
																					StringTools
																					replace:(s : String, sub : String, by : String) -> String
																			[Local pushedValue(28610):Null<String>:Null<String>]
																			[Local itemVarName(28512):String:String]
																			[Const:String] "item"
																	[Return:Dynamic]
																		[ObjectDecl:{ pushedValue : Null<String>, isPush : Bool }]
																			isPush: [Const:Bool] true
																			pushedValue: [Local pushedValue(28610):Null<String>:Null<String>]
												[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[Return:Dynamic]
				[ObjectDecl:{ pushedValue : String, isPush : Bool }]
					isPush: [Const:Bool] false
					pushedValue: [Const:String] "item"

	function extractFromBlockExpressions[Function:(exprs : Array<haxe.macro.TypedExpr>, indexVar : String, accumVar : String) -> Null<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local exprs(28734):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local indexVar(28735):String]
		[Arg:String] [Local accumVar(28736):String]
		[Block:Dynamic]
			[Block:Void]
				[Var `(28803):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(28803):Int:Int]
						<
						[Field:Int]
							[Local exprs(28734):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(28737):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(28734):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(28803):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(28803):Int:Int]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TIf(condition, thenExpr, elseExpr):
		var filterResult = extractFromConditional(condition, thenExpr, elseExpr, indexVar, accumVar);
		if (filterResult != null) return filterResult;	
	case TBinop(OpAssign, target, value):
		var mapResult = extractFromDirectAssignment(target, value, indexVar, accumVar);
		if (mapResult != null) return mapResult;	
	case _:
		continue;	
})
							[Block:Void]
								[Var `(28789):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(28737):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 3
										[Block:Void]
											[Var `(28790):haxe.macro.Binop]
												[EnumParameter:haxe.macro.Binop]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													0
											[Var `(28791):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													1
											[Var `(28792):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													2
											[If:Void]
												[Binop:Bool]
													[EnumIndex:Int] [Local `(28790):haxe.macro.Binop:haxe.macro.Binop]
													==
													[Const:Int] 4
												[Then:Void] [Block:Void]
													[Block:Void]
														[Var target(28793):haxe.macro.TypedExpr] [Local `(28791):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Var value(28794):haxe.macro.TypedExpr] [Local `(28792):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Block:Void]
															[Var mapResult(28795):Null<String>]
																[Call:Null<String>]
																	[Field:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
																			reflaxe.elixir.helpers.LoopCompiler
																			extractFromDirectAssignment:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>
																	[Local target(28793):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local value(28794):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local indexVar(28735):String:String]
																	[Local accumVar(28736):String:String]
															[If:Void]
																[Binop:Bool]
																	[Local mapResult(28795):Null<String>:Null<String>]
																	!=
																	[Const:Null<String>] null
																[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local mapResult(28795):Null<String>:Null<String>]
												[Else:Dynamic] [Block:Dynamic] [Continue:Dynamic]
									[Case:Void]
										[Const:Int] 16
										[Block:Void]
											[Var `(28796):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													0
											[Var `(28797):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													1
											[Var `(28798):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(28789):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													2
											[Block:Void]
												[Var condition(28799):haxe.macro.TypedExpr] [Local `(28796):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var thenExpr(28800):haxe.macro.TypedExpr] [Local `(28797):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var elseExpr(28801):Null<haxe.macro.TypedExpr>] [Local `(28798):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:Void]
													[Var filterResult(28802):Null<String>]
														[Call:Null<String>]
															[Field:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
																	reflaxe.elixir.helpers.LoopCompiler
																	extractFromConditional:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>
															[Local condition(28799):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local thenExpr(28800):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local elseExpr(28801):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															[Local indexVar(28735):String:String]
															[Local accumVar(28736):String:String]
													[If:Void]
														[Binop:Bool]
															[Local filterResult(28802):Null<String>:Null<String>]
															!=
															[Const:Null<String>] null
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local filterResult(28802):Null<String>:Null<String>]
									[Default:Dynamic] [Block:Dynamic] [Continue:Dynamic]
			[Return:Dynamic] [Const:Null<String>] null

	function extractFromConditional[Function:(condition : haxe.macro.TypedExpr, thenExpr : haxe.macro.TypedExpr, elseExpr : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local condition(28741):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local thenExpr(28742):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local elseExpr(28743):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(28744):String]
		[Arg:String] [Local accumVar(28745):String]
		[Block:Dynamic]
			[Var conditionStr(28746):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local condition(28741):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Binop:Null<String>]
				[Local conditionStr(28746):Null<String>:Null<String>]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local conditionStr(28746):Null<String>:Null<String>]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local accumVar(28745):String:String]
								+
								[Const:String] "["
							+
							[Local indexVar(28744):String:String]
						+
						[Const:String] "]"
					[Const:String] "item"
			[Binop:Null<String>]
				[Local conditionStr(28746):Null<String>:Null<String>]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:Class<StringTools>]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local conditionStr(28746):Null<String>:Null<String>]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "Enum.at("
									+
									[Local accumVar(28745):String:String]
								+
								[Const:String] ", "
							+
							[Local indexVar(28744):String:String]
						+
						[Const:String] ")"
					[Const:String] "item"
			[Return:Dynamic] [Local conditionStr(28746):Null<String>:Null<String>]

	function extractFromDirectAssignment[Function:(target : haxe.macro.TypedExpr, value : haxe.macro.TypedExpr, indexVar : String, accumVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local target(28750):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local value(28751):haxe.macro.TypedExpr]
		[Arg:String] [Local indexVar(28752):String]
		[Arg:String] [Local accumVar(28753):String]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (value.expr) {
	case TBinop(OpAdd, left, right):
		switch (right.expr) {
			case TArrayDecl([transformExpr]):
				var transformStr = compiler.compileExpression(transformExpr);
				transformStr = StringTools.replace(transformStr, "${accumVar}[${indexVar}]", "item");
				transformStr = StringTools.replace(transformStr, "Enum.at(${accumVar}, ${indexVar})", "item");
				return transformStr;			
			case _:
		};	
	case _:
})
				[Block:Void]
					[Var `(28770):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local value(28751):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(28770):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 3
						[Then:Void] [Block:Void]
							[Var `(28771):haxe.macro.Binop]
								[EnumParameter:haxe.macro.Binop]
									[Local `(28770):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									0
							[Var `(28772):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(28770):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									1
							[Var `(28773):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(28770):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									2
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(28771):haxe.macro.Binop:haxe.macro.Binop]
									==
									[Const:Int] 0
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var left(28774):haxe.macro.TypedExpr] [Local `(28772):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var right(28775):haxe.macro.TypedExpr] [Local `(28773):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Void]
											[Meta:Void]
												:ast(switch (right.expr) {
	case TArrayDecl([transformExpr]):
		var transformStr = compiler.compileExpression(transformExpr);
		transformStr = StringTools.replace(transformStr, "${accumVar}[${indexVar}]", "item");
		transformStr = StringTools.replace(transformStr, "Enum.at(${accumVar}, ${indexVar})", "item");
		return transformStr;	
	case _:
})
												[Block:Void]
													[Var `(28776):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Local right(28775):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:Void]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(28776):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:Void] [Block:Void]
															[Var `(28777):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(28776):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[If:Void]
																[Binop:Bool]
																	[Field:Int]
																		[Local `(28777):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																	==
																	[Const:Int] 1
																[Then:Dynamic] [Block:Dynamic]
																	[Var `(28778):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(28777):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																	[Block:Dynamic]
																		[Var transformExpr(28779):haxe.macro.TypedExpr] [Local `(28778):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Var transformStr(28780):Null<String>]
																				[Call:Null<String>]
																					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						[Field:reflaxe.elixir.ElixirCompiler]
																							[Const:reflaxe.elixir.helpers.LoopCompiler] this
																							[FInstance:reflaxe.elixir.ElixirCompiler]
																								reflaxe.elixir.helpers.LoopCompiler
																								compiler:reflaxe.elixir.ElixirCompiler
																						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							reflaxe.elixir.ElixirCompiler
																							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																					[Local transformExpr(28779):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Const:Null<Bool>] null
																			[Binop:Null<String>]
																				[Local transformStr(28780):Null<String>:Null<String>]
																				=
																				[Call:String]
																					[Field:(s : String, sub : String, by : String) -> String]
																						[TypeExpr StringTools:Class<StringTools>]
																						[FStatic:(s : String, sub : String, by : String) -> String]
																							StringTools
																							replace:(s : String, sub : String, by : String) -> String
																					[Local transformStr(28780):Null<String>:Null<String>]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Local accumVar(28753):String:String]
																								+
																								[Const:String] "["
																							+
																							[Local indexVar(28752):String:String]
																						+
																						[Const:String] "]"
																					[Const:String] "item"
																			[Binop:Null<String>]
																				[Local transformStr(28780):Null<String>:Null<String>]
																				=
																				[Call:String]
																					[Field:(s : String, sub : String, by : String) -> String]
																						[TypeExpr StringTools:Class<StringTools>]
																						[FStatic:(s : String, sub : String, by : String) -> String]
																							StringTools
																							replace:(s : String, sub : String, by : String) -> String
																					[Local transformStr(28780):Null<String>:Null<String>]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] "Enum.at("
																									+
																									[Local accumVar(28753):String:String]
																								+
																								[Const:String] ", "
																							+
																							[Local indexVar(28752):String:String]
																						+
																						[Const:String] ")"
																					[Const:String] "item"
																			[Return:Dynamic] [Local transformStr(28780):Null<String>:Null<String>]
																[Else:Void] [Block:Void]
														[Else:Void] [Block:Void]
								[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<String>] null

	function compileWhileLoopGeneric[Function:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(18503):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18504):haxe.macro.TypedExpr]
		[Arg:Bool] [Local normalWhile(18505):Bool]
		[Block:Dynamic]
			[Var condition(18506):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local econd(18503):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var modifiedVars(18613):Array<{ type : String, name : String }>]
				[Call:Array<{ type : String, name : String }>]
					[Field:(ebody : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(ebody : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
							reflaxe.elixir.helpers.LoopCompiler
							extractModifiedVariables:(ebody : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>
					[Local ebody(18504):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[Var transformedBody(18687):String]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
						[Const:reflaxe.elixir.helpers.LoopCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
							reflaxe.elixir.helpers.LoopCompiler
							transformLoopBodyMutations:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String
					[Local ebody(18504):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local modifiedVars(18613):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
					[Local normalWhile(18505):Bool:Bool]
					[Local condition(18506):Null<String>:Null<String>]
			[Var varInitializations(18691):Array<String>]
				[Block:Array<String>]
					[Var `(18688):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(18690):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(18690):Int:Int]
								<
								[Field:Int]
									[Local modifiedVars(18613):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
									[FInstance:Int]
										Array<{ type : String, name : String }>
										length:Int
							[Block:Void]
								[Var v(18689):{ type : String, name : String }]
									[Array:{ type : String, name : String }]
										[Local modifiedVars(18613):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
										[Local `(18690):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(18690):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(18688):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Const:String] ""
										+
										[Field:String]
											[Local v(18689):{ type : String, name : String }:{ type : String, name : String }]
											[FAnon:String] name:String
					[Local `(18688):Array<String>:Array<String>]
			[Var varParams(18692):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local varInitializations(18691):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ", "
			[Var hasBreakStatement(18693):Bool]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local transformedBody(18687):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "throw(:break)"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
			[Var result(18708):String]
				[If:String]
					[Local normalWhile(18505):Bool:Bool]
					[Then:String] [Block:String]
						[If:String]
							[Local hasBreakStatement(18693):Bool:Bool]
							[Then:String] [Block:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Binop:String]
																				[Binop:String]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Binop:String]
																										[Binop:String]
																											[Const:String] "(\n"
																											+
																											[Const:String] "  try do\n"
																										+
																										[Binop:String]
																											[Binop:String]
																												[Const:String] "    loop_fn = fn {"
																												+
																												[Local varParams(18692):String:String]
																											+
																											[Const:String] "} ->\n"
																									+
																									[Binop:String]
																										[Binop:String]
																											[Const:String] "      if "
																											+
																											[Local condition(18506):Null<String>:Null<String>]
																										+
																										[Const:String] " do\n"
																								+
																								[Const:String] "        try do\n"
																							+
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Call:String]
																										[Field:(code : String, ?spaces : Int) -> String]
																											[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																											[FStatic:(code : String, ?spaces : Int) -> String]
																												reflaxe.elixir.helpers.CompilerUtilities
																												indentCode:(code : String, ?spaces : Int) -> String
																										[Local transformedBody(18687):String:String]
																										[Const:Int] 10
																								+
																								[Const:String] "\n"
																						+
																						[Binop:String]
																							[Binop:String]
																								[Const:String] "      loop_fn.({"
																								+
																								[Local varParams(18692):String:String]
																							+
																							[Const:String] "})\n"
																					+
																					[Const:String] "        catch\n"
																				+
																				[Binop:String]
																					[Binop:String]
																						[Const:String] "          :break -> {"
																						+
																						[Local varParams(18692):String:String]
																					+
																					[Const:String] "}\n"
																			+
																			[Binop:String]
																				[Binop:String]
																					[Const:String] "          :continue -> loop_fn.({"
																					+
																					[Local varParams(18692):String:String]
																				+
																				[Const:String] "})\n"
																		+
																		[Const:String] "        end\n"
																	+
																	[Const:String] "      else\n"
																+
																[Binop:String]
																	[Binop:String]
																		[Const:String] "        {"
																		+
																		[Local varParams(18692):String:String]
																	+
																	[Const:String] "}\n"
															+
															[Const:String] "      end\n"
														+
														[Const:String] "    end\n"
													+
													[Binop:String]
														[Binop:String]
															[Const:String] "    loop_fn.({"
															+
															[Local varParams(18692):String:String]
														+
														[Const:String] "})\n"
												+
												[Const:String] "  catch\n"
											+
											[Binop:String]
												[Binop:String]
													[Const:String] "    :break -> {"
													+
													[Local varParams(18692):String:String]
												+
												[Const:String] "}\n"
										+
										[Const:String] "  end\n"
									+
									[Const:String] ")"
							[Else:String] [Block:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Const:String] "loop_helper = fn loop_fn, {"
																			+
																			[Local varParams(18692):String:String]
																		+
																		[Const:String] "} ->\n"
																	+
																	[Binop:String]
																		[Binop:String]
																			[Const:String] "  if "
																			+
																			[Local condition(18506):Null<String>:Null<String>]
																		+
																		[Const:String] " do\n"
																+
																[Binop:String]
																	[Binop:String]
																		[Const:String] ""
																		+
																		[Call:String]
																			[Field:(code : String, ?spaces : Int) -> String]
																				[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																				[FStatic:(code : String, ?spaces : Int) -> String]
																					reflaxe.elixir.helpers.CompilerUtilities
																					indentCode:(code : String, ?spaces : Int) -> String
																			[Local transformedBody(18687):String:String]
																			[Const:Int] 4
																	+
																	[Const:String] "\n"
															+
															[Binop:String]
																[Binop:String]
																	[Const:String] "    loop_fn.(loop_fn, {"
																	+
																	[Local varParams(18692):String:String]
																+
																[Const:String] "})\n"
														+
														[Const:String] "  else\n"
													+
													[Binop:String]
														[Binop:String]
															[Const:String] "    {"
															+
															[Local varParams(18692):String:String]
														+
														[Const:String] "}\n"
												+
												[Const:String] "  end\n"
											+
											[Const:String] "end\n"
										+
										[Const:String] "\n"
									+
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "{"
													+
													[Local varParams(18692):String:String]
												+
												[Const:String] "} = loop_helper.(loop_helper, {"
											+
											[Local varParams(18692):String:String]
										+
										[Const:String] "})"
					[Else:String] [Block:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "(\n"
												+
												[Binop:String]
													[Binop:String]
														[Const:String] "  loop_fn = fn {"
														+
														[Local varParams(18692):String:String]
													+
													[Const:String] "} ->\n"
											+
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Call:String]
														[Field:(code : String, ?spaces : Int) -> String]
															[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
															[FStatic:(code : String, ?spaces : Int) -> String]
																reflaxe.elixir.helpers.CompilerUtilities
																indentCode:(code : String, ?spaces : Int) -> String
														[Local transformedBody(18687):String:String]
														[Const:Int] 4
												+
												[Const:String] "\n"
										+
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "    if "
																+
																[Local condition(18506):Null<String>:Null<String>]
															+
															[Const:String] ", do: loop_fn.({"
														+
														[Local varParams(18692):String:String]
													+
													[Const:String] "}), else: {"
												+
												[Local varParams(18692):String:String]
											+
											[Const:String] "}\n"
									+
									[Const:String] "  end\n"
								+
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "  {"
												+
												[Local varParams(18692):String:String]
											+
											[Const:String] "} = loop_fn.({"
										+
										[Local varParams(18692):String:String]
									+
									[Const:String] "})\n"
							+
							[Const:String] ")"
			[Return:Dynamic] [Local result(18708):String:String]

	function extractModifiedVariables[Function:(ebody : haxe.macro.TypedExpr) -> Array<{ type : String, name : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18507):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var `this(18514):reflaxe.elixir.helpers.LoopCompiler] [Const:reflaxe.elixir.helpers.LoopCompiler] this
			[Var modifiedVars(18508):Array<{ type : String, name : String }>] [ArrayDecl:Array<{ type : String, name : String }>]
			[Var findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>] [ArrayDecl:Array<(expr : haxe.macro.TypedExpr) -> Void>] [Const:(expr : haxe.macro.TypedExpr) -> Void] null
			[Binop:(expr : haxe.macro.TypedExpr) -> Void]
				[Array:(expr : haxe.macro.TypedExpr) -> Void]
					[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
					[Const:Int] 0
				=
				[Function:(expr : haxe.macro.TypedExpr) -> Void]
					[Arg:haxe.macro.TypedExpr] [Local expr(18510):haxe.macro.TypedExpr]
					[Block:Void]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TBinop(op, e1, e2):
		switch (op) {
			case OpAssign, OpAssignOp(_):
				if (isVariableAccess(e1)) {
					var varName = extractVariableName(e1);
					if (!Lambda.exists(modifiedVars, function(v) ->  @:implicitReturn return v.name == varName)) {
						modifiedVars.push({ name : varName, type : "Dynamic" });
					};
				};			
			case _:
				findMutations(e1);			
		};
		findMutations(e2);	
	case TVar(tvar, valueExpr):
		var varName = CompilerUtilities.toElixirVarName(tvar);
		if (!Lambda.exists(modifiedVars, function(v) ->  @:implicitReturn return v.name == varName)) {
			modifiedVars.push({ name : varName, type : "Dynamic" });
		};
		if (valueExpr != null) findMutations(valueExpr);	
	case TUnop(op, postFix, e):
		switch (op) {
			case OpIncrement, OpDecrement:
				if (isVariableAccess(e)) {
					var varName = extractVariableName(e);
					if (!Lambda.exists(modifiedVars, function(v) ->  @:implicitReturn return v.name == varName)) {
						modifiedVars.push({ name : varName, type : "Dynamic" });
					};
				};			
			case _:
				findMutations(e);			
		};	
	case TBlock(exprs):
		for (e  in  exprs) findMutations(e);	
	case TIf(cond, thenExpr, elseExpr):
		findMutations(cond);
		findMutations(thenExpr);
		if (elseExpr != null) findMutations(elseExpr);	
	case TCall(e, el):
		findMutations(e);
		for (arg  in  el) findMutations(arg);	
	case _:
})
							[Block:Void]
								[Var `(18571):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(18510):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[Switch:Void]
									[EnumIndex:Int] [Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									[Case:Void]
										[Const:Int] 3
										[Block:Void]
											[Var `(18572):haxe.macro.Binop]
												[EnumParameter:haxe.macro.Binop]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													0
											[Var `(18573):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													1
											[Var `(18574):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBinop
													2
											[Block:Void]
												[Var op(18575):haxe.macro.Binop] [Local `(18572):haxe.macro.Binop:haxe.macro.Binop]
												[Var e1(18576):haxe.macro.TypedExpr] [Local `(18573):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var e2(18577):haxe.macro.TypedExpr] [Local `(18574):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Block:Void]
													[Meta:Void]
														:ast(switch (op) {
	case OpAssign, OpAssignOp(_):
		if (isVariableAccess(e1)) {
			var varName = extractVariableName(e1);
			if (!Lambda.exists(modifiedVars, function(v) ->  @:implicitReturn return v.name == varName)) {
				modifiedVars.push({ name : varName, type : "Dynamic" });
			};
		};	
	case _:
		findMutations(e1);	
})
														[Switch:Void]
															[EnumIndex:Int] [Local op(18575):haxe.macro.Binop:haxe.macro.Binop]
															[Case:Void]
																[Const:Int] 4
																[Block:Void]
																	[Block:Void]
																		[If:Void]
																			[Call:Bool]
																				[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																					[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																					[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																						reflaxe.elixir.helpers.LoopCompiler
																						isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																				[Local e1(18576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Then:Void] [Block:Void]
																				[Var varName(18578):String]
																					[Call:String]
																						[Field:(expr : haxe.macro.TypedExpr) -> String]
																							[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																							[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																								reflaxe.elixir.helpers.LoopCompiler
																								extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																						[Local e1(18576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[If:Void]
																					[Unop:Bool]
																						!
																						Prefix
																						[Call:Bool]
																							[Field:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																								[TypeExpr Lambda:Class<Lambda>]
																								[FStatic:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																									Lambda
																									exists:(it : Iterable<exists.A>, f : ((item : exists.A) -> Bool)) -> Bool
																							[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																							[Function:(v : { type : String, name : String }) -> Bool]
																								[Arg:{ type : String, name : String }] [Local v(18579):{ type : String, name : String }]
																								[Return:Dynamic]
																									[Binop:Bool]
																										[Field:String]
																											[Local v(18579):{ type : String, name : String }:{ type : String, name : String }]
																											[FAnon:String] name:String
																										==
																										[Local varName(18578):String:String]
																					[Then:Int] [Block:Int]
																						[Call:Int]
																							[Field:(x : { type : String, name : String }) -> Int]
																								[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																								[FInstance:(x : { type : String, name : String }) -> Int]
																									Array<{ type : String, name : String }>
																									push:(x : Array.T) -> Int
																							[ObjectDecl:{ type : String, name : String }]
																								name: [Local varName(18578):String:String]
																								type: [Const:String] "Dynamic"
															[Case:Void]
																[Const:Int] 20
																[Block:Void]
																	[Var `(18580):haxe.macro.Binop]
																		[EnumParameter:haxe.macro.Binop]
																			[Local op(18575):haxe.macro.Binop:haxe.macro.Binop]
																			OpAssignOp
																			0
																	[Block:Void]
																		[If:Void]
																			[Call:Bool]
																				[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																					[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																					[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																						reflaxe.elixir.helpers.LoopCompiler
																						isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																				[Local e1(18576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Then:Void] [Block:Void]
																				[Var varName(18581):String]
																					[Call:String]
																						[Field:(expr : haxe.macro.TypedExpr) -> String]
																							[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																							[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																								reflaxe.elixir.helpers.LoopCompiler
																								extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																						[Local e1(18576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[If:Void]
																					[Unop:Bool]
																						!
																						Prefix
																						[Call:Bool]
																							[Field:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																								[TypeExpr Lambda:Class<Lambda>]
																								[FStatic:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																									Lambda
																									exists:(it : Iterable<exists.A>, f : ((item : exists.A) -> Bool)) -> Bool
																							[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																							[Function:(v : { type : String, name : String }) -> Bool]
																								[Arg:{ type : String, name : String }] [Local v(18582):{ type : String, name : String }]
																								[Return:Dynamic]
																									[Binop:Bool]
																										[Field:String]
																											[Local v(18582):{ type : String, name : String }:{ type : String, name : String }]
																											[FAnon:String] name:String
																										==
																										[Local varName(18581):String:String]
																					[Then:Int] [Block:Int]
																						[Call:Int]
																							[Field:(x : { type : String, name : String }) -> Int]
																								[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																								[FInstance:(x : { type : String, name : String }) -> Int]
																									Array<{ type : String, name : String }>
																									push:(x : Array.T) -> Int
																							[ObjectDecl:{ type : String, name : String }]
																								name: [Local varName(18581):String:String]
																								type: [Const:String] "Dynamic"
															[Default:Void]
																[Block:Void]
																	[Call:Void]
																		[Array:(expr : haxe.macro.TypedExpr) -> Void]
																			[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																			[Const:Int] 0
																		[Local e1(18576):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Call:Void]
														[Array:(expr : haxe.macro.TypedExpr) -> Void]
															[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
															[Const:Int] 0
														[Local e2(18577):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Case:Void]
										[Const:Int] 9
										[Block:Void]
											[Var `(18583):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TCall
													0
											[Var `(18584):Array<haxe.macro.TypedExpr>]
												[EnumParameter:Array<haxe.macro.TypedExpr>]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TCall
													1
											[Block:Void]
												[Var e(18585):haxe.macro.TypedExpr] [Local `(18583):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var el(18586):Array<haxe.macro.TypedExpr>] [Local `(18584):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Block:Void]
													[Call:Void]
														[Array:(expr : haxe.macro.TypedExpr) -> Void]
															[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
															[Const:Int] 0
														[Local e(18585):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Block:Void]
														[Var `(18587):Int] [Const:Int] 0
														[While:Void]
															[Binop:Bool]
																[Local `(18587):Int:Int]
																<
																[Field:Int]
																	[Local el(18586):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[FInstance:Int]
																		Array<haxe.macro.TypedExpr>
																		length:Int
															[Block:Void]
																[Var arg(18588):haxe.macro.TypedExpr]
																	[Array:haxe.macro.TypedExpr]
																		[Local el(18586):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Local `(18587):Int:Int]
																[Unop:Int]
																	++
																	Prefix
																	[Local `(18587):Int:Int]
																[Call:Void]
																	[Array:(expr : haxe.macro.TypedExpr) -> Void]
																		[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																		[Const:Int] 0
																	[Local arg(18588):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Case:Void]
										[Const:Int] 11
										[Block:Void]
											[Var `(18589):haxe.macro.Unop]
												[EnumParameter:haxe.macro.Unop]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TUnop
													0
											[Var `(18590):Bool]
												[EnumParameter:Bool]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TUnop
													1
											[Var `(18591):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TUnop
													2
											[Block:Void]
												[Var op(18592):haxe.macro.Unop] [Local `(18589):haxe.macro.Unop:haxe.macro.Unop]
												[Var postFix(18593):Bool] [Local `(18590):Bool:Bool]
												[Var e(18594):haxe.macro.TypedExpr] [Local `(18591):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Block:Void]
													[Meta:Void]
														:ast(switch (op) {
	case OpIncrement, OpDecrement:
		if (isVariableAccess(e)) {
			var varName = extractVariableName(e);
			if (!Lambda.exists(modifiedVars, function(v) ->  @:implicitReturn return v.name == varName)) {
				modifiedVars.push({ name : varName, type : "Dynamic" });
			};
		};	
	case _:
		findMutations(e);	
})
														[Switch:Void]
															[EnumIndex:Int] [Local op(18592):haxe.macro.Unop:haxe.macro.Unop]
															[Case:Void]
																[Const:Int] 0
																[Const:Int] 1
																[Block:Void]
																	[Block:Void]
																		[If:Void]
																			[Call:Bool]
																				[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																					[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																					[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																						reflaxe.elixir.helpers.LoopCompiler
																						isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																				[Local e(18594):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Then:Void] [Block:Void]
																				[Var varName(18595):String]
																					[Call:String]
																						[Field:(expr : haxe.macro.TypedExpr) -> String]
																							[Local `this(18514):reflaxe.elixir.helpers.LoopCompiler:reflaxe.elixir.helpers.LoopCompiler]
																							[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																								reflaxe.elixir.helpers.LoopCompiler
																								extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																						[Local e(18594):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[If:Void]
																					[Unop:Bool]
																						!
																						Prefix
																						[Call:Bool]
																							[Field:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																								[TypeExpr Lambda:Class<Lambda>]
																								[FStatic:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																									Lambda
																									exists:(it : Iterable<exists.A>, f : ((item : exists.A) -> Bool)) -> Bool
																							[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																							[Function:(v : { type : String, name : String }) -> Bool]
																								[Arg:{ type : String, name : String }] [Local v(18596):{ type : String, name : String }]
																								[Return:Dynamic]
																									[Binop:Bool]
																										[Field:String]
																											[Local v(18596):{ type : String, name : String }:{ type : String, name : String }]
																											[FAnon:String] name:String
																										==
																										[Local varName(18595):String:String]
																					[Then:Int] [Block:Int]
																						[Call:Int]
																							[Field:(x : { type : String, name : String }) -> Int]
																								[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																								[FInstance:(x : { type : String, name : String }) -> Int]
																									Array<{ type : String, name : String }>
																									push:(x : Array.T) -> Int
																							[ObjectDecl:{ type : String, name : String }]
																								name: [Local varName(18595):String:String]
																								type: [Const:String] "Dynamic"
															[Default:Void]
																[Block:Void]
																	[Call:Void]
																		[Array:(expr : haxe.macro.TypedExpr) -> Void]
																			[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																			[Const:Int] 0
																		[Local e(18594):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Case:Void]
										[Const:Int] 13
										[Block:Void]
											[Var `(18597):haxe.macro.TVar]
												[EnumParameter:haxe.macro.TVar]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TVar
													0
											[Var `(18598):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TVar
													1
											[Block:Void]
												[Var tvar(18599):haxe.macro.TVar] [Local `(18597):haxe.macro.TVar:haxe.macro.TVar]
												[Var valueExpr(18600):Null<haxe.macro.TypedExpr>] [Local `(18598):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:Void]
													[Var varName(18601):String]
														[Call:String]
															[Field:(v : haxe.macro.TVar) -> String]
																[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																[FStatic:(v : haxe.macro.TVar) -> String]
																	reflaxe.elixir.helpers.CompilerUtilities
																	toElixirVarName:(v : haxe.macro.TVar) -> String
															[Local tvar(18599):haxe.macro.TVar:haxe.macro.TVar]
													[If:Void]
														[Unop:Bool]
															!
															Prefix
															[Call:Bool]
																[Field:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																	[TypeExpr Lambda:Class<Lambda>]
																	[FStatic:(it : Iterable<{ type : String, name : String }>, f : ((item : { type : String, name : String }) -> Bool)) -> Bool]
																		Lambda
																		exists:(it : Iterable<exists.A>, f : ((item : exists.A) -> Bool)) -> Bool
																[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																[Function:(v : { type : String, name : String }) -> Bool]
																	[Arg:{ type : String, name : String }] [Local v(18602):{ type : String, name : String }]
																	[Return:Dynamic]
																		[Binop:Bool]
																			[Field:String]
																				[Local v(18602):{ type : String, name : String }:{ type : String, name : String }]
																				[FAnon:String] name:String
																			==
																			[Local varName(18601):String:String]
														[Then:Int] [Block:Int]
															[Call:Int]
																[Field:(x : { type : String, name : String }) -> Int]
																	[Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
																	[FInstance:(x : { type : String, name : String }) -> Int]
																		Array<{ type : String, name : String }>
																		push:(x : Array.T) -> Int
																[ObjectDecl:{ type : String, name : String }]
																	name: [Local varName(18601):String:String]
																	type: [Const:String] "Dynamic"
													[If:Void]
														[Binop:Bool]
															[Local valueExpr(18600):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															!=
															[Const:Null<haxe.macro.TypedExpr>] null
														[Then:Void] [Block:Void]
															[Call:Void]
																[Array:(expr : haxe.macro.TypedExpr) -> Void]
																	[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																	[Const:Int] 0
																[Local valueExpr(18600):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Case:Void]
										[Const:Int] 14
										[Block:Void]
											[Var `(18603):Array<haxe.macro.TypedExpr>]
												[EnumParameter:Array<haxe.macro.TypedExpr>]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TBlock
													0
											[Block:Void]
												[Var exprs(18604):Array<haxe.macro.TypedExpr>] [Local `(18603):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Block:Void]
													[Block:Void]
														[Var `(18605):Int] [Const:Int] 0
														[While:Void]
															[Binop:Bool]
																[Local `(18605):Int:Int]
																<
																[Field:Int]
																	[Local exprs(18604):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[FInstance:Int]
																		Array<haxe.macro.TypedExpr>
																		length:Int
															[Block:Void]
																[Var e(18606):haxe.macro.TypedExpr]
																	[Array:haxe.macro.TypedExpr]
																		[Local exprs(18604):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Local `(18605):Int:Int]
																[Unop:Int]
																	++
																	Prefix
																	[Local `(18605):Int:Int]
																[Call:Void]
																	[Array:(expr : haxe.macro.TypedExpr) -> Void]
																		[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																		[Const:Int] 0
																	[Local e(18606):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Case:Void]
										[Const:Int] 16
										[Block:Void]
											[Var `(18607):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													0
											[Var `(18608):haxe.macro.TypedExpr]
												[EnumParameter:haxe.macro.TypedExpr]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													1
											[Var `(18609):Null<haxe.macro.TypedExpr>]
												[EnumParameter:Null<haxe.macro.TypedExpr>]
													[Local `(18571):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
													TIf
													2
											[Block:Void]
												[Var cond(18610):haxe.macro.TypedExpr] [Local `(18607):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var thenExpr(18611):haxe.macro.TypedExpr] [Local `(18608):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Var elseExpr(18612):Null<haxe.macro.TypedExpr>] [Local `(18609):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Block:Void]
													[Call:Void]
														[Array:(expr : haxe.macro.TypedExpr) -> Void]
															[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
															[Const:Int] 0
														[Local cond(18610):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Call:Void]
														[Array:(expr : haxe.macro.TypedExpr) -> Void]
															[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
															[Const:Int] 0
														[Local thenExpr(18611):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[If:Void]
														[Binop:Bool]
															[Local elseExpr(18612):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
															!=
															[Const:Null<haxe.macro.TypedExpr>] null
														[Then:Void] [Block:Void]
															[Call:Void]
																[Array:(expr : haxe.macro.TypedExpr) -> Void]
																	[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
																	[Const:Int] 0
																[Local elseExpr(18612):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Default:Void] [Block:Void]
			[Call:Void]
				[Array:(expr : haxe.macro.TypedExpr) -> Void]
					[Local findMutations(18509):Array<(expr : haxe.macro.TypedExpr) -> Void>:Array<(expr : haxe.macro.TypedExpr) -> Void>]
					[Const:Int] 0
				[Local ebody(18507):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[Return:Dynamic] [Local modifiedVars(18508):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]

	function isVariableAccess[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(18515):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TLocal(_):
		true;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(18518):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(18515):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(18518):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 1
							[Then:Bool] [Block:Bool]
								[Var `(18519):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(18518):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:Bool] [Const:Bool] true
							[Else:Bool] [Block:Bool] [Const:Bool] false

	function extractVariableName[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(18520):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TLocal(v):
		CompilerUtilities.toElixirVarName(v);	
	case _:
		"";	
})
					[Block:String]
						[Var `(18524):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(18520):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(18524):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 1
							[Then:String] [Block:String]
								[Var `(18525):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(18524):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:String]
									[Var v(18526):haxe.macro.TVar] [Local `(18525):haxe.macro.TVar:haxe.macro.TVar]
									[Block:String]
										[Call:String]
											[Field:(v : haxe.macro.TVar) -> String]
												[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
												[FStatic:(v : haxe.macro.TVar) -> String]
													reflaxe.elixir.helpers.CompilerUtilities
													toElixirVarName:(v : haxe.macro.TVar) -> String
											[Local v(18526):haxe.macro.TVar:haxe.macro.TVar]
							[Else:String] [Block:String] [Const:String] ""

	function transformLoopBodyMutations[Function:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>, normalWhile : Bool, condition : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(18614):haxe.macro.TypedExpr]
		[Arg:Array<{ type : String, name : String }>] [Local modifiedVars(18615):Array<{ type : String, name : String }>]
		[Arg:Bool] [Local normalWhile(18616):Bool]
		[Arg:String] [Local condition(18617):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBlock(exprs):
		var statements = [for (e  in  exprs) transformStatement(e, modifiedVars)];
		statements.join("\n");	
	case _:
		transformStatement(expr, modifiedVars);	
})
					[Block:String]
						[Var `(18680):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(18614):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(18680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 14
							[Then:String] [Block:String]
								[Var `(18681):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(18680):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:String]
									[Var exprs(18682):Array<haxe.macro.TypedExpr>] [Local `(18681):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:String]
										[Var statements(18683):Array<String>]
											[Block:Array<String>]
												[Var `(18684):Array<String>] [ArrayDecl:Array<String>]
												[Block:Void]
													[Var `(18685):Int] [Const:Int] 0
													[While:Void]
														[Binop:Bool]
															[Local `(18685):Int:Int]
															<
															[Field:Int]
																[Local exprs(18682):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
														[Block:Void]
															[Var e(18686):haxe.macro.TypedExpr]
																[Array:haxe.macro.TypedExpr]
																	[Local exprs(18682):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local `(18685):Int:Int]
															[Unop:Int]
																++
																Prefix
																[Local `(18685):Int:Int]
															[Call:Int]
																[Field:(x : String) -> Int]
																	[Local `(18684):Array<String>:Array<String>]
																	[FInstance:(x : String) -> Int]
																		Array<String>
																		push:(x : Array.T) -> Int
																[Call:String]
																	[Field:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String]
																			reflaxe.elixir.helpers.LoopCompiler
																			transformStatement:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String
																	[Local e(18686):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local modifiedVars(18615):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
												[Local `(18684):Array<String>:Array<String>]
										[Call:String]
											[Field:(sep : String) -> String]
												[Local statements(18683):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] "\n"
							[Else:String] [Block:String]
								[Call:String]
									[Field:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String]
										[Const:reflaxe.elixir.helpers.LoopCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String]
											reflaxe.elixir.helpers.LoopCompiler
											transformStatement:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String
									[Local expr(18614):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local modifiedVars(18615):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]

	function transformStatement[Function:(expr : haxe.macro.TypedExpr, modifiedVars : Array<{ type : String, name : String }>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(18621):haxe.macro.TypedExpr]
		[Arg:Array<{ type : String, name : String }>] [Local modifiedVars(18622):Array<{ type : String, name : String }>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBinop(op, e1, e2):
		switch (op) {
			case OpAssign:
				if (isVariableAccess(e1)) {
					var varName = extractVariableName(e1);
					var value = compiler.compileExpression(e2);
					"${varName} = ${value}";
				} else {
					compiler.compileExpression(expr);
				};			
			case OpAssignOp(assignOp):
				if (isVariableAccess(e1)) {
					var varName = extractVariableName(e1);
					var value = compiler.compileExpression(e2);
					var opStr = switch (assignOp) {
						case OpAdd:
							"+";						
						case OpSub:
							"-";						
						case OpMult:
							"*";						
						case OpDiv:
							"/";						
						case OpMod:
							"rem";						
						case _:
							"+";						
					};
					"${varName} = ${varName} ${opStr} ${value}";
				} else {
					compiler.compileExpression(expr);
				};			
			case _:
				compiler.compileExpression(expr);			
		};	
	case TUnop(op, postFix, e):
		switch (op) {
			case OpIncrement:
				if (isVariableAccess(e)) {
					var varName = extractVariableName(e);
					"${varName} = ${varName} + 1";
				} else {
					compiler.compileExpression(expr);
				};			
			case OpDecrement:
				if (isVariableAccess(e)) {
					var varName = extractVariableName(e);
					"${varName} = ${varName} - 1";
				} else {
					compiler.compileExpression(expr);
				};			
			case _:
				compiler.compileExpression(expr);			
		};	
	case _:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(18654):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 3
								[Block:String]
									[Var `(18655):haxe.macro.Binop]
										[EnumParameter:haxe.macro.Binop]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											0
									[Var `(18656):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											1
									[Var `(18657):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											2
									[Block:String]
										[Var op(18658):haxe.macro.Binop] [Local `(18655):haxe.macro.Binop:haxe.macro.Binop]
										[Var e1(18659):haxe.macro.TypedExpr] [Local `(18656):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var e2(18660):haxe.macro.TypedExpr] [Local `(18657):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:String]
											[Meta:String]
												:ast(switch (op) {
	case OpAssign:
		if (isVariableAccess(e1)) {
			var varName = extractVariableName(e1);
			var value = compiler.compileExpression(e2);
			"${varName} = ${value}";
		} else {
			compiler.compileExpression(expr);
		};	
	case OpAssignOp(assignOp):
		if (isVariableAccess(e1)) {
			var varName = extractVariableName(e1);
			var value = compiler.compileExpression(e2);
			var opStr = switch (assignOp) {
				case OpAdd:
					"+";				
				case OpSub:
					"-";				
				case OpMult:
					"*";				
				case OpDiv:
					"/";				
				case OpMod:
					"rem";				
				case _:
					"+";				
			};
			"${varName} = ${varName} ${opStr} ${value}";
		} else {
			compiler.compileExpression(expr);
		};	
	case _:
		compiler.compileExpression(expr);	
})
												[Switch:String]
													[EnumIndex:Int] [Local op(18658):haxe.macro.Binop:haxe.macro.Binop]
													[Case:String]
														[Const:Int] 4
														[Block:String]
															[Block:String]
																[If:String]
																	[Call:Bool]
																		[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																			[Const:reflaxe.elixir.helpers.LoopCompiler] this
																			[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																				reflaxe.elixir.helpers.LoopCompiler
																				isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																		[Local e1(18659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Then:String] [Block:String]
																		[Var varName(18661):String]
																			[Call:String]
																				[Field:(expr : haxe.macro.TypedExpr) -> String]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																						reflaxe.elixir.helpers.LoopCompiler
																						extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																				[Local e1(18659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var value(18662):Null<String>]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.LoopCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local e2(18660):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
																		[Binop:String]
																			[Binop:String]
																				[Binop:String]
																					[Const:String] ""
																					+
																					[Local varName(18661):String:String]
																				+
																				[Const:String] " = "
																			+
																			[Local value(18662):Null<String>:Null<String>]
																	[Else:Null<String>] [Block:Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.LoopCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Const:Null<Bool>] null
													[Case:String]
														[Const:Int] 20
														[Block:String]
															[Var `(18663):haxe.macro.Binop]
																[EnumParameter:haxe.macro.Binop]
																	[Local op(18658):haxe.macro.Binop:haxe.macro.Binop]
																	OpAssignOp
																	0
															[Block:String]
																[Var assignOp(18664):haxe.macro.Binop] [Local `(18663):haxe.macro.Binop:haxe.macro.Binop]
																[Block:String]
																	[If:String]
																		[Call:Bool]
																			[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																				[Const:reflaxe.elixir.helpers.LoopCompiler] this
																				[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																					reflaxe.elixir.helpers.LoopCompiler
																					isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																			[Local e1(18659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Then:String] [Block:String]
																			[Var varName(18665):String]
																				[Call:String]
																					[Field:(expr : haxe.macro.TypedExpr) -> String]
																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																						[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																							reflaxe.elixir.helpers.LoopCompiler
																							extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																					[Local e1(18659):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Var value(18666):Null<String>]
																				[Call:Null<String>]
																					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						[Field:reflaxe.elixir.ElixirCompiler]
																							[Const:reflaxe.elixir.helpers.LoopCompiler] this
																							[FInstance:reflaxe.elixir.ElixirCompiler]
																								reflaxe.elixir.helpers.LoopCompiler
																								compiler:reflaxe.elixir.ElixirCompiler
																						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							reflaxe.elixir.ElixirCompiler
																							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																					[Local e2(18660):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Const:Null<Bool>] null
																			[Var opStr(18667):String]
																				[Meta:String]
																					:ast(switch (assignOp) {
	case OpAdd:
		"+";	
	case OpSub:
		"-";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpMod:
		"rem";	
	case _:
		"+";	
})
																					[Switch:String]
																						[EnumIndex:Int] [Local assignOp(18664):haxe.macro.Binop:haxe.macro.Binop]
																						[Case:String]
																							[Const:Int] 0
																							[Block:String] [Block:String] [Const:String] "+"
																						[Case:String]
																							[Const:Int] 1
																							[Block:String] [Block:String] [Const:String] "*"
																						[Case:String]
																							[Const:Int] 2
																							[Block:String] [Block:String] [Const:String] "/"
																						[Case:String]
																							[Const:Int] 3
																							[Block:String] [Block:String] [Const:String] "-"
																						[Case:String]
																							[Const:Int] 19
																							[Block:String] [Block:String] [Const:String] "rem"
																						[Default:String] [Block:String] [Const:String] "+"
																			[Binop:String]
																				[Binop:String]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Binop:String]
																										[Const:String] ""
																										+
																										[Local varName(18665):String:String]
																									+
																									[Const:String] " = "
																								+
																								[Local varName(18665):String:String]
																							+
																							[Const:String] " "
																						+
																						[Local opStr(18667):String:String]
																					+
																					[Const:String] " "
																				+
																				[Local value(18666):Null<String>:Null<String>]
																		[Else:Null<String>] [Block:Null<String>]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Const:reflaxe.elixir.helpers.LoopCompiler] this
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.LoopCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
													[Default:Null<String>]
														[Block:Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
							[Case:String]
								[Const:Int] 11
								[Block:String]
									[Var `(18668):haxe.macro.Unop]
										[EnumParameter:haxe.macro.Unop]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											0
									[Var `(18669):Bool]
										[EnumParameter:Bool]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											1
									[Var `(18670):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18654):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											2
									[Block:String]
										[Var op(18671):haxe.macro.Unop] [Local `(18668):haxe.macro.Unop:haxe.macro.Unop]
										[Var postFix(18672):Bool] [Local `(18669):Bool:Bool]
										[Var e(18673):haxe.macro.TypedExpr] [Local `(18670):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:String]
											[Meta:String]
												:ast(switch (op) {
	case OpIncrement:
		if (isVariableAccess(e)) {
			var varName = extractVariableName(e);
			"${varName} = ${varName} + 1";
		} else {
			compiler.compileExpression(expr);
		};	
	case OpDecrement:
		if (isVariableAccess(e)) {
			var varName = extractVariableName(e);
			"${varName} = ${varName} - 1";
		} else {
			compiler.compileExpression(expr);
		};	
	case _:
		compiler.compileExpression(expr);	
})
												[Switch:String]
													[EnumIndex:Int] [Local op(18671):haxe.macro.Unop:haxe.macro.Unop]
													[Case:String]
														[Const:Int] 0
														[Block:String]
															[Block:String]
																[If:String]
																	[Call:Bool]
																		[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																			[Const:reflaxe.elixir.helpers.LoopCompiler] this
																			[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																				reflaxe.elixir.helpers.LoopCompiler
																				isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																		[Local e(18673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Then:String] [Block:String]
																		[Var varName(18674):String]
																			[Call:String]
																				[Field:(expr : haxe.macro.TypedExpr) -> String]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																						reflaxe.elixir.helpers.LoopCompiler
																						extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																				[Local e(18673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Binop:String]
																			[Binop:String]
																				[Binop:String]
																					[Binop:String]
																						[Const:String] ""
																						+
																						[Local varName(18674):String:String]
																					+
																					[Const:String] " = "
																				+
																				[Local varName(18674):String:String]
																			+
																			[Const:String] " + 1"
																	[Else:Null<String>] [Block:Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.LoopCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Const:Null<Bool>] null
													[Case:String]
														[Const:Int] 1
														[Block:String]
															[Block:String]
																[If:String]
																	[Call:Bool]
																		[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																			[Const:reflaxe.elixir.helpers.LoopCompiler] this
																			[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																				reflaxe.elixir.helpers.LoopCompiler
																				isVariableAccess:(expr : haxe.macro.TypedExpr) -> Bool
																		[Local e(18673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Then:String] [Block:String]
																		[Var varName(18675):String]
																			[Call:String]
																				[Field:(expr : haxe.macro.TypedExpr) -> String]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																						reflaxe.elixir.helpers.LoopCompiler
																						extractVariableName:(expr : haxe.macro.TypedExpr) -> String
																				[Local e(18673):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Binop:String]
																			[Binop:String]
																				[Binop:String]
																					[Binop:String]
																						[Const:String] ""
																						+
																						[Local varName(18675):String:String]
																					+
																					[Const:String] " = "
																				+
																				[Local varName(18675):String:String]
																			+
																			[Const:String] " - 1"
																	[Else:Null<String>] [Block:Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.LoopCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.LoopCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Const:Null<Bool>] null
													[Default:Null<String>]
														[Block:Null<String>]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.LoopCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.LoopCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.LoopCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local expr(18621):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null

	public function checkForTForInExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(28804):haxe.macro.TypedExpr]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local expr(28804):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					==
					[Const:haxe.macro.TypedExpr] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TFor(_, _, _):
		return true;	
	case TBlock(exprs):
		for (e  in  exprs) {
			if (checkForTForInExpression(e)) return true;
		};
		return false;	
	case TIf(_, eif, eelse):
		if (checkForTForInExpression(eif)) return true;
		if (eelse != null && checkForTForInExpression(eelse)) return true;
		return false;	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(28818):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(28804):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 14
							[Block:Dynamic]
								[Var `(28819):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Dynamic]
									[Var exprs(28820):Array<haxe.macro.TypedExpr>] [Local `(28819):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Block:Void]
											[Var `(28821):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28821):Int:Int]
													<
													[Field:Int]
														[Local exprs(28820):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(28822):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(28820):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(28821):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28821):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	checkForTForInExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Local e(28822):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 15
							[Block:Dynamic]
								[Var `(28823):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										0
								[Var `(28824):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										1
								[Var `(28825):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										2
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(28826):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(28827):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(28828):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(28818):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var eif(28829):haxe.macro.TypedExpr] [Local `(28827):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eelse(28830):Null<haxe.macro.TypedExpr>] [Local `(28828):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[If:Void]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														checkForTForInExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local eif(28829):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local eelse(28830):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												&&
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															checkForTForInExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local eelse(28830):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function analyzeArrayLoopCondition[Function:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
		[Arg:haxe.macro.TypedExpr] [Local econd(18044):haxe.macro.TypedExpr]
		[Block:Void]
			[Meta:Void]
				:ast(switch (econd.expr) {
	case TParenthesis(e):
		return analyzeArrayLoopCondition(e);	
	case TBinop(OpLt, e1, e2):
		var indexVar = switch (e1.expr) {
			case TLocal(v):
				CompilerUtilities.toElixirVarName(v);			
			case _:
				null;			
		};
		if (indexVar == null) return null;
		var arrayVar = switch (e2.expr) {
			case TField(arrayExpr, FInstance(_, _, cf)):
				if (cf.get().name == "length") {
					switch (arrayExpr.expr) {
						case TLocal(v):
							CompilerUtilities.toElixirVarName(v);						
						case _:
							null;						
					};
				} else {
					null;
				};			
			case _:
				null;			
		};
		if (arrayVar == null) return null;
		return { indexVar : indexVar, arrayVar : arrayVar };	
	case _:
		return null;	
})
				[Block:Void]
					[Var `(18089):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local econd(18044):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(18089):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 3
							[Block:Void]
								[Var `(18090):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(18089):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(18091):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18089):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(18092):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18089):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(18090):haxe.macro.Binop:haxe.macro.Binop]
										==
										[Const:Int] 9
									[Then:Dynamic] [Block:Dynamic]
										[Block:Dynamic]
											[Var e1(18093):haxe.macro.TypedExpr] [Local `(18091):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e2(18094):haxe.macro.TypedExpr] [Local `(18092):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Var indexVar(18095):Null<String>]
													[Meta:Null<String>]
														:ast(switch (e1.expr) {
	case TLocal(v):
		CompilerUtilities.toElixirVarName(v);	
	case _:
		null;	
})
														[Block:Null<String>]
															[Var `(18096):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local e1(18093):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Null<String>]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(18096):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 1
																[Then:String] [Block:String]
																	[Var `(18097):haxe.macro.TVar]
																		[EnumParameter:haxe.macro.TVar]
																			[Local `(18096):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TLocal
																			0
																	[Block:String]
																		[Var v(18098):haxe.macro.TVar] [Local `(18097):haxe.macro.TVar:haxe.macro.TVar]
																		[Block:String]
																			[Call:String]
																				[Field:(v : haxe.macro.TVar) -> String]
																					[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																					[FStatic:(v : haxe.macro.TVar) -> String]
																						reflaxe.elixir.helpers.CompilerUtilities
																						toElixirVarName:(v : haxe.macro.TVar) -> String
																				[Local v(18098):haxe.macro.TVar:haxe.macro.TVar]
																[Else:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
												[If:Void]
													[Binop:Bool]
														[Local indexVar(18095):Null<String>:Null<String>]
														==
														[Const:Null<String>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayVar : String }>] null
												[Var arrayVar(18099):Null<String>]
													[Meta:Null<String>]
														:ast(switch (e2.expr) {
	case TField(arrayExpr, FInstance(_, _, cf)):
		if (cf.get().name == "length") {
			switch (arrayExpr.expr) {
				case TLocal(v):
					CompilerUtilities.toElixirVarName(v);				
				case _:
					null;				
			};
		} else {
			null;
		};	
	case _:
		null;	
})
														[Block:Null<String>]
															[Var `(18100):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local e2(18094):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Null<String>]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(18100):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 4
																[Then:Null<String>] [Block:Null<String>]
																	[Var `(18101):haxe.macro.TypedExpr]
																		[EnumParameter:haxe.macro.TypedExpr]
																			[Local `(18100):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			0
																	[Var `(18102):haxe.macro.FieldAccess]
																		[EnumParameter:haxe.macro.FieldAccess]
																			[Local `(18100):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TField
																			1
																	[If:Null<String>]
																		[Binop:Bool]
																			[EnumIndex:Int] [Local `(18102):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																			==
																			[Const:Int] 0
																		[Then:Null<String>] [Block:Null<String>]
																			[Var `(18103):haxe.macro.Ref<haxe.macro.ClassType>]
																				[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																					[Local `(18102):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																					FInstance
																					0
																			[Var `(18104):Array<haxe.macro.Type>]
																				[EnumParameter:Array<haxe.macro.Type>]
																					[Local `(18102):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																					FInstance
																					1
																			[Var `(18105):haxe.macro.Ref<haxe.macro.ClassField>]
																				[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																					[Local `(18102):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																					FInstance
																					2
																			[Block:Null<String>]
																				[Var cf(18106):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(18105):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																				[Var arrayExpr(18107):haxe.macro.TypedExpr] [Local `(18101):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Block:Null<String>]
																					[If:Null<String>]
																						[Binop:Bool]
																							[Field:String]
																								[Call:haxe.macro.ClassField]
																									[Field:() -> haxe.macro.ClassField]
																										[Local cf(18106):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																										[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																								[FAnon:String] name:String
																							==
																							[Const:String] "length"
																						[Then:Null<String>] [Block:Null<String>]
																							[Meta:Null<String>]
																								:ast(switch (arrayExpr.expr) {
	case TLocal(v):
		CompilerUtilities.toElixirVarName(v);	
	case _:
		null;	
})
																								[Block:Null<String>]
																									[Var `(18108):haxe.macro.TypedExprDef]
																										[Field:haxe.macro.TypedExprDef]
																											[Local arrayExpr(18107):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																											[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																									[If:Null<String>]
																										[Binop:Bool]
																											[EnumIndex:Int] [Local `(18108):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																											==
																											[Const:Int] 1
																										[Then:String] [Block:String]
																											[Var `(18109):haxe.macro.TVar]
																												[EnumParameter:haxe.macro.TVar]
																													[Local `(18108):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																													TLocal
																													0
																											[Block:String]
																												[Var v(18110):haxe.macro.TVar] [Local `(18109):haxe.macro.TVar:haxe.macro.TVar]
																												[Block:String]
																													[Call:String]
																														[Field:(v : haxe.macro.TVar) -> String]
																															[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																															[FStatic:(v : haxe.macro.TVar) -> String]
																																reflaxe.elixir.helpers.CompilerUtilities
																																toElixirVarName:(v : haxe.macro.TVar) -> String
																														[Local v(18110):haxe.macro.TVar:haxe.macro.TVar]
																										[Else:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
																						[Else:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
																		[Else:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
																[Else:Null<Null<String>>] [Block:Null<Null<String>>] [Const:Null<Null<String>>] null
												[If:Void]
													[Binop:Bool]
														[Local arrayVar(18099):Null<String>:Null<String>]
														==
														[Const:Null<String>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayVar : String }>] null
												[Return:Dynamic]
													[ObjectDecl:{ indexVar : Null<String>, arrayVar : Null<String> }]
														indexVar: [Local indexVar(18095):Null<String>:Null<String>]
														arrayVar: [Local arrayVar(18099):Null<String>:Null<String>]
									[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayVar : String }>] null
						[Case:Dynamic]
							[Const:Int] 6
							[Block:Dynamic]
								[Var `(18111):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18089):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TParenthesis
										0
								[Block:Dynamic]
									[Var e(18112):haxe.macro.TypedExpr] [Local `(18111):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Null<{ indexVar : String, arrayVar : String }>]
												[Field:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>]
														reflaxe.elixir.helpers.LoopCompiler
														analyzeArrayLoopCondition:(econd : haxe.macro.TypedExpr) -> Null<{ indexVar : String, arrayVar : String }>
												[Local e(18112):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ indexVar : String, arrayVar : String }>] null

	function analyzeArrayLoopBody[Function:(ebody : haxe.macro.TypedExpr, conditionInfo : { indexVar : String, arrayVar : String }) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
		[Arg:haxe.macro.TypedExpr] [Local ebody(18372):haxe.macro.TypedExpr]
		[Arg:{ indexVar : String, arrayVar : String }] [Local conditionInfo(18373):{ indexVar : String, arrayVar : String }]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (ebody.expr) {
	case TBlock(exprs) if (exprs.length >= 2):
		var itemVar:String = null;
		var sourceArray:TypedExpr = null;
		if (exprs.length > 0) {
			switch (exprs[0].expr) {
				case TVar(tvar, init) if (init != null):
					itemVar = CompilerUtilities.toElixirVarName(tvar);
					switch (init.expr) {
						case TArray(arr, idx):
							sourceArray = arr;						
						case _:
					};				
				case _:
			};
		};
		if (itemVar == null) return null;
		var hasIncrement = false;
		if (exprs.length > 1) {
			switch (exprs[1].expr) {
				case TUnop(OpIncrement, true, e):
					hasIncrement = true;				
				case _:
			};
		};
		if (!hasIncrement) return null;
		if (exprs.length > 2) {
			return analyzeArrayOperation(exprs[2], itemVar, sourceArray);
		};	
	case _:
})
				[Block:Void]
					[Var `(18458):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local ebody(18372):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(18458):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 14
						[Then:Void] [Block:Void]
							[Var `(18459):Array<haxe.macro.TypedExpr>]
								[EnumParameter:Array<haxe.macro.TypedExpr>]
									[Local `(18458):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBlock
									0
							[Block:Void]
								[Var exprs(18460):Array<haxe.macro.TypedExpr>] [Local `(18459):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[If:Void]
									[Binop:Bool]
										[Field:Int]
											[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
										>=
										[Const:Int] 2
									[Then:Void] [Block:Void]
										[Var itemVar(18461):String] [Const:String] null
										[Var sourceArray(18462):haxe.macro.TypedExpr] [Const:haxe.macro.TypedExpr] null
										[If:Void]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 0
											[Then:Void] [Block:Void]
												[Meta:Void]
													:ast(switch (exprs[0].expr) {
	case TVar(tvar, init) if (init != null):
		itemVar = CompilerUtilities.toElixirVarName(tvar);
		switch (init.expr) {
			case TArray(arr, idx):
				sourceArray = arr;			
			case _:
		};	
	case _:
})
													[Block:Void]
														[Var `(18463):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 0
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Void]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(18463):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 13
															[Then:Void] [Block:Void]
																[Var `(18464):haxe.macro.TVar]
																	[EnumParameter:haxe.macro.TVar]
																		[Local `(18463):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TVar
																		0
																[Var `(18465):Null<haxe.macro.TypedExpr>]
																	[EnumParameter:Null<haxe.macro.TypedExpr>]
																		[Local `(18463):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TVar
																		1
																[Block:Void]
																	[Var tvar(18466):haxe.macro.TVar] [Local `(18464):haxe.macro.TVar:haxe.macro.TVar]
																	[Var init(18467):Null<haxe.macro.TypedExpr>] [Local `(18465):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																	[If:Void]
																		[Binop:Bool]
																			[Local init(18467):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																			!=
																			[Const:Null<haxe.macro.TypedExpr>] null
																		[Then:Void] [Block:Void]
																			[Binop:String]
																				[Local itemVar(18461):String:String]
																				=
																				[Call:String]
																					[Field:(v : haxe.macro.TVar) -> String]
																						[TypeExpr reflaxe.elixir.helpers.CompilerUtilities:Class<reflaxe.elixir.helpers.CompilerUtilities>]
																						[FStatic:(v : haxe.macro.TVar) -> String]
																							reflaxe.elixir.helpers.CompilerUtilities
																							toElixirVarName:(v : haxe.macro.TVar) -> String
																					[Local tvar(18466):haxe.macro.TVar:haxe.macro.TVar]
																			[Meta:Void]
																				:ast(switch (init.expr) {
	case TArray(arr, idx):
		sourceArray = arr;	
	case _:
})
																				[Block:Void]
																					[Var `(18468):haxe.macro.TypedExprDef]
																						[Field:haxe.macro.TypedExprDef]
																							[Local init(18467):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																					[If:Void]
																						[Binop:Bool]
																							[EnumIndex:Int] [Local `(18468):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																							==
																							[Const:Int] 2
																						[Then:haxe.macro.TypedExpr] [Block:haxe.macro.TypedExpr]
																							[Var `(18469):haxe.macro.TypedExpr]
																								[EnumParameter:haxe.macro.TypedExpr]
																									[Local `(18468):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TArray
																									0
																							[Var `(18470):haxe.macro.TypedExpr]
																								[EnumParameter:haxe.macro.TypedExpr]
																									[Local `(18468):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																									TArray
																									1
																							[Block:haxe.macro.TypedExpr]
																								[Var arr(18471):haxe.macro.TypedExpr] [Local `(18469):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																								[Var idx(18472):haxe.macro.TypedExpr] [Local `(18470):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																								[Block:haxe.macro.TypedExpr]
																									[Binop:haxe.macro.TypedExpr]
																										[Local sourceArray(18462):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																										=
																										[Local arr(18471):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Else:Void] [Block:Void]
																		[Else:Void] [Block:Void]
															[Else:Void] [Block:Void]
										[If:Void]
											[Binop:Bool]
												[Local itemVar(18461):String:String]
												==
												[Const:String] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>] null
										[Var hasIncrement(18473):Bool] [Const:Bool] false
										[If:Void]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 1
											[Then:Void] [Block:Void]
												[Meta:Void]
													:ast(switch (exprs[1].expr) {
	case TUnop(OpIncrement, true, e):
		hasIncrement = true;	
	case _:
})
													[Block:Void]
														[Var `(18474):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 1
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Void]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(18474):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 11
															[Then:Void] [Block:Void]
																[Var `(18475):haxe.macro.Unop]
																	[EnumParameter:haxe.macro.Unop]
																		[Local `(18474):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TUnop
																		0
																[Var `(18476):Bool]
																	[EnumParameter:Bool]
																		[Local `(18474):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TUnop
																		1
																[Var `(18477):haxe.macro.TypedExpr]
																	[EnumParameter:haxe.macro.TypedExpr]
																		[Local `(18474):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TUnop
																		2
																[If:Void]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(18475):haxe.macro.Unop:haxe.macro.Unop]
																		==
																		[Const:Int] 0
																	[Then:Void] [Block:Void]
																		[If:Void]
																			[Binop:Bool]
																				[Local `(18476):Bool:Bool]
																				==
																				[Const:Bool] true
																			[Then:Bool] [Block:Bool]
																				[Block:Bool]
																					[Var e(18478):haxe.macro.TypedExpr] [Local `(18477):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Block:Bool]
																						[Binop:Bool]
																							[Local hasIncrement(18473):Bool:Bool]
																							=
																							[Const:Bool] true
																			[Else:Void] [Block:Void]
																	[Else:Void] [Block:Void]
															[Else:Void] [Block:Void]
										[If:Void]
											[Unop:Bool]
												!
												Prefix
												[Local hasIncrement(18473):Bool:Bool]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>] null
										[If:Void]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 2
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
														[Field:(expr : haxe.macro.TypedExpr, itemVar : String, sourceArray : haxe.macro.TypedExpr) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, itemVar : String, sourceArray : haxe.macro.TypedExpr) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
																reflaxe.elixir.helpers.LoopCompiler
																analyzeArrayOperation:(expr : haxe.macro.TypedExpr, itemVar : String, sourceArray : haxe.macro.TypedExpr) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>
														[Array:haxe.macro.TypedExpr]
															[Local exprs(18460):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Const:Int] 2
														[Local itemVar(18461):String:String]
														[Local sourceArray(18462):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>] null

	function analyzeArrayOperation[Function:(expr : haxe.macro.TypedExpr, itemVar : String, sourceArray : haxe.macro.TypedExpr) -> Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>]
		[Arg:haxe.macro.TypedExpr] [Local expr(18413):haxe.macro.TypedExpr]
		[Arg:String] [Local itemVar(18414):String]
		[Arg:haxe.macro.TypedExpr] [Local sourceArray(18415):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TIf(cond, thenExpr, null):
		switch (thenExpr.expr) {
			case TCall(e, [arg]):
				return { type : "filter", itemVar : itemVar, accumulator : "_g", sourceArray : sourceArray, transformation : null, condition : cond };			
			case _:
		};	
	case TCall(e, [arg]):
		return { type : "map", itemVar : itemVar, accumulator : "_g", sourceArray : sourceArray, transformation : arg, condition : null };	
	case _:
})
				[Block:Void]
					[Var `(18439):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(18413):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 9
							[Block:Void]
								[Var `(18440):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(18441):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[If:Void]
									[Binop:Bool]
										[Field:Int]
											[Local `(18441):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
										==
										[Const:Int] 1
									[Then:Dynamic] [Block:Dynamic]
										[Var `(18442):haxe.macro.TypedExpr]
											[Array:haxe.macro.TypedExpr]
												[Local `(18441):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Const:Int] 0
										[Block:Dynamic]
											[Var arg(18443):haxe.macro.TypedExpr] [Local `(18442):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var e(18444):haxe.macro.TypedExpr] [Local `(18440):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[ObjectDecl:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
														type: [Const:String] "map"
														itemVar: [Local itemVar(18414):String:String]
														accumulator: [Const:String] "_g"
														sourceArray: [Local sourceArray(18415):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														transformation: [Local arg(18443):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														condition: [Const:haxe.macro.TypedExpr] null
									[Else:Void] [Block:Void]
						[Case:Void]
							[Const:Int] 16
							[Block:Void]
								[Var `(18445):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(18446):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(18447):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(18439):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[If:Void]
									[Binop:Bool]
										[Local `(18447):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										==
										[Const:Null<haxe.macro.TypedExpr>] null
									[Then:Void] [Block:Void]
										[Var thenExpr(18448):haxe.macro.TypedExpr] [Local `(18446):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var cond(18449):haxe.macro.TypedExpr] [Local `(18445):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Void]
											[Meta:Void]
												:ast(switch (thenExpr.expr) {
	case TCall(e, [arg]):
		return { type : "filter", itemVar : itemVar, accumulator : "_g", sourceArray : sourceArray, transformation : null, condition : cond };	
	case _:
})
												[Block:Void]
													[Var `(18450):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Local thenExpr(18448):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:Void]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(18450):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 9
														[Then:Void] [Block:Void]
															[Var `(18451):haxe.macro.TypedExpr]
																[EnumParameter:haxe.macro.TypedExpr]
																	[Local `(18450):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TCall
																	0
															[Var `(18452):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(18450):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TCall
																	1
															[If:Void]
																[Binop:Bool]
																	[Field:Int]
																		[Local `(18452):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																	==
																	[Const:Int] 1
																[Then:Dynamic] [Block:Dynamic]
																	[Var `(18453):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(18452):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																	[Block:Dynamic]
																		[Var arg(18454):haxe.macro.TypedExpr] [Local `(18453):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Var e(18455):haxe.macro.TypedExpr] [Local `(18451):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Return:Dynamic]
																				[ObjectDecl:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
																					type: [Const:String] "filter"
																					itemVar: [Local itemVar(18414):String:String]
																					accumulator: [Const:String] "_g"
																					sourceArray: [Local sourceArray(18415):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					transformation: [Const:haxe.macro.TypedExpr] null
																					condition: [Local cond(18449):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Else:Void] [Block:Void]
														[Else:Void] [Block:Void]
									[Else:Void] [Block:Void]
						[Default:Void] [Block:Void]
			[Return:Dynamic] [Const:Null<{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }>] null

	function generateEnumFunction[Function:(pattern : { type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }, conditionInfo : { indexVar : String, arrayVar : String }) -> String]
		[Arg:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }] [Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
		[Arg:{ indexVar : String, arrayVar : String }] [Local conditionInfo(18481):{ indexVar : String, arrayVar : String }]
		[Block:Void]
			[Var arrayExpr(18482):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.LoopCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.LoopCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Field:haxe.macro.TypedExpr]
						[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
						[FAnon:haxe.macro.TypedExpr] sourceArray:haxe.macro.TypedExpr
					[Const:Null<Bool>] null
			[Meta:Void]
				:ast(switch (pattern.type) {
	case "filter":
		var condition = compiler.compileExpression(pattern.condition);
		var lambdaBody = substituteVariable(condition, pattern.itemVar, pattern.itemVar);
		return "Enum.filter(${arrayExpr}, fn ${pattern.itemVar} -> ${lambdaBody} end)";	
	case "map":
		var transformation = compiler.compileExpression(pattern.transformation);
		var lambdaBody = substituteVariable(transformation, pattern.itemVar, pattern.itemVar);
		return "Enum.map(${arrayExpr}, fn ${pattern.itemVar} -> ${lambdaBody} end)";	
	default:
		return null;	
})
				[Block:Void]
					[Var `(18491):String]
						[Field:String]
							[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
							[FAnon:String] type:String
					[Switch:Void]
						[Local `(18491):String:String]
						[Case:Dynamic]
							[Const:String] "filter"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var condition(18492):Null<String>]
										[Call:Null<String>]
											[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.LoopCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
											[Field:haxe.macro.TypedExpr]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:haxe.macro.TypedExpr] condition:haxe.macro.TypedExpr
											[Const:Null<Bool>] null
									[Var lambdaBody(18493):String]
										[Call:String]
											[Field:(expr : String, oldVar : String, newVar : String) -> String]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(expr : String, oldVar : String, newVar : String) -> String]
													reflaxe.elixir.helpers.LoopCompiler
													substituteVariable:(expr : String, oldVar : String, newVar : String) -> String
											[Local condition(18492):Null<String>:Null<String>]
											[Field:String]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:String] itemVar:String
											[Field:String]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:String] itemVar:String
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "Enum.filter("
																+
																[Local arrayExpr(18482):Null<String>:Null<String>]
															+
															[Const:String] ", fn "
														+
														[Field:String]
															[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
															[FAnon:String] itemVar:String
													+
													[Const:String] " -> "
												+
												[Local lambdaBody(18493):String:String]
											+
											[Const:String] " end)"
						[Case:Dynamic]
							[Const:String] "map"
							[Block:Dynamic]
								[Block:Dynamic]
									[Var transformation(18494):Null<String>]
										[Call:Null<String>]
											[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.LoopCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
											[Field:haxe.macro.TypedExpr]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:haxe.macro.TypedExpr] transformation:haxe.macro.TypedExpr
											[Const:Null<Bool>] null
									[Var lambdaBody(18495):String]
										[Call:String]
											[Field:(expr : String, oldVar : String, newVar : String) -> String]
												[Const:reflaxe.elixir.helpers.LoopCompiler] this
												[FInstance:(expr : String, oldVar : String, newVar : String) -> String]
													reflaxe.elixir.helpers.LoopCompiler
													substituteVariable:(expr : String, oldVar : String, newVar : String) -> String
											[Local transformation(18494):Null<String>:Null<String>]
											[Field:String]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:String] itemVar:String
											[Field:String]
												[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
												[FAnon:String] itemVar:String
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "Enum.map("
																+
																[Local arrayExpr(18482):Null<String>:Null<String>]
															+
															[Const:String] ", fn "
														+
														[Field:String]
															[Local pattern(18480):{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }:{ type : String, transformation : haxe.macro.TypedExpr, sourceArray : haxe.macro.TypedExpr, itemVar : String, condition : haxe.macro.TypedExpr, accumulator : String }]
															[FAnon:String] itemVar:String
													+
													[Const:String] " -> "
												+
												[Local lambdaBody(18495):String:String]
											+
											[Const:String] " end)"
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] null

	function substituteVariable[Function:(expr : String, oldVar : String, newVar : String) -> String]
		[Arg:String] [Local expr(18484):String]
		[Arg:String] [Local oldVar(18485):String]
		[Arg:String] [Local newVar(18486):String]
		[Block:Dynamic] [Return:Dynamic] [Local expr(18484):String:String]

	public function containsTWhileExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(28831):haxe.macro.TypedExpr]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local expr(28831):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					==
					[Const:haxe.macro.TypedExpr] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TWhile(_, _, _):
		return true;	
	case TBlock(exprs):
		for (e  in  exprs) {
			if (containsTWhileExpression(e)) return true;
		};
		return false;	
	case TIf(_, eif, eelse):
		if (containsTWhileExpression(eif)) return true;
		if (eelse != null && containsTWhileExpression(eelse)) return true;
		return false;	
	case TFor(_, _, ebody):
		return containsTWhileExpression(ebody);	
	case TSwitch(_, cases, defaultCase):
		for (c  in  cases) {
			if (containsTWhileExpression(c.expr)) return true;
		};
		if (defaultCase != null && containsTWhileExpression(defaultCase)) return true;
		return false;	
	case TTry(etry, catches):
		if (containsTWhileExpression(etry)) return true;
		for (c  in  catches) {
			if (containsTWhileExpression(c.expr)) return true;
		};
		return false;	
	case TFunction(func):
		return containsTWhileExpression(func.expr);	
	case TCall(e, args):
		if (containsTWhileExpression(e)) return true;
		for (arg  in  args) {
			if (containsTWhileExpression(arg)) return true;
		};
		return false;	
	case TBinop(_, e1, e2):
		return containsTWhileExpression(e1) || containsTWhileExpression(e2);	
	case TUnop(_, _, e):
		return containsTWhileExpression(e);	
	case TArray(e1, e2):
		return containsTWhileExpression(e1) || containsTWhileExpression(e2);	
	case TArrayDecl(exprs):
		for (e  in  exprs) {
			if (containsTWhileExpression(e)) return true;
		};
		return false;	
	case TField(e, _):
		return containsTWhileExpression(e);	
	case TVar(_, init):
		return init != null ? containsTWhileExpression(init) : false;	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(28893):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(28831):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 2
							[Block:Dynamic]
								[Var `(28894):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TArray
										0
								[Var `(28895):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TArray
										1
								[Block:Dynamic]
									[Var e1(28896):haxe.macro.TypedExpr] [Local `(28894):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(28897):haxe.macro.TypedExpr] [Local `(28895):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Binop:Bool]
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local e1(28896):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												||
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local e2(28897):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Dynamic]
							[Const:Int] 3
							[Block:Dynamic]
								[Var `(28898):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(28899):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(28900):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[Block:Dynamic]
									[Var e1(28901):haxe.macro.TypedExpr] [Local `(28899):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(28902):haxe.macro.TypedExpr] [Local `(28900):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Binop:Bool]
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local e1(28901):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												||
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local e2(28902):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Dynamic]
							[Const:Int] 4
							[Block:Dynamic]
								[Var `(28903):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(28904):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[Block:Dynamic]
									[Var e(28905):haxe.macro.TypedExpr] [Local `(28903):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local e(28905):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Dynamic]
							[Const:Int] 8
							[Block:Dynamic]
								[Var `(28906):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TArrayDecl
										0
								[Block:Dynamic]
									[Var exprs(28907):Array<haxe.macro.TypedExpr>] [Local `(28906):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Block:Void]
											[Var `(28908):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28908):Int:Int]
													<
													[Field:Int]
														[Local exprs(28907):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(28909):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(28907):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(28908):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28908):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Local e(28909):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 9
							[Block:Dynamic]
								[Var `(28910):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(28911):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Dynamic]
									[Var e(28912):haxe.macro.TypedExpr] [Local `(28910):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var args(28913):Array<haxe.macro.TypedExpr>] [Local `(28911):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[If:Void]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local e(28912):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Block:Void]
											[Var `(28914):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28914):Int:Int]
													<
													[Field:Int]
														[Local args(28913):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var arg(28915):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local args(28913):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(28914):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28914):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Local arg(28915):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 11
							[Block:Dynamic]
								[Var `(28916):haxe.macro.Unop]
									[EnumParameter:haxe.macro.Unop]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										0
								[Var `(28917):Bool]
									[EnumParameter:Bool]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										1
								[Var `(28918):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										2
								[Block:Dynamic]
									[Var e(28919):haxe.macro.TypedExpr] [Local `(28918):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local e(28919):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Dynamic]
							[Const:Int] 12
							[Block:Dynamic]
								[Var `(28920):haxe.macro.TFunc]
									[EnumParameter:haxe.macro.TFunc]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFunction
										0
								[Block:Dynamic]
									[Var func(28921):haxe.macro.TFunc] [Local `(28920):haxe.macro.TFunc:haxe.macro.TFunc]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Field:haxe.macro.TypedExpr]
													[Local func(28921):haxe.macro.TFunc:haxe.macro.TFunc]
													[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
						[Case:Dynamic]
							[Const:Int] 13
							[Block:Dynamic]
								[Var `(28922):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										0
								[Var `(28923):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										1
								[Block:Dynamic]
									[Var init(28924):Null<haxe.macro.TypedExpr>] [Local `(28923):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Return:Dynamic]
											[If:Bool]
												[Binop:Bool]
													[Local init(28924):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:Bool] [Block:Bool]
													[Call:Bool]
														[Field:(expr : haxe.macro.TypedExpr) -> Bool]
															[Const:reflaxe.elixir.helpers.LoopCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																reflaxe.elixir.helpers.LoopCompiler
																containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
														[Local init(28924):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[Else:Bool] [Block:Bool] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 14
							[Block:Dynamic]
								[Var `(28925):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Dynamic]
									[Var exprs(28926):Array<haxe.macro.TypedExpr>] [Local `(28925):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Block:Void]
											[Var `(28927):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28927):Int:Int]
													<
													[Field:Int]
														[Local exprs(28926):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(28928):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(28926):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(28927):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28927):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Local e(28928):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 15
							[Block:Dynamic]
								[Var `(28929):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										0
								[Var `(28930):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										1
								[Var `(28931):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFor
										2
								[Block:Dynamic]
									[Var ebody(28932):haxe.macro.TypedExpr] [Local `(28931):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local ebody(28932):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(28933):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(28934):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(28935):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var eif(28936):haxe.macro.TypedExpr] [Local `(28934):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eelse(28937):Null<haxe.macro.TypedExpr>] [Local `(28935):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[If:Void]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local eif(28936):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local eelse(28937):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												&&
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local eelse(28937):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 17
							[Block:Dynamic]
								[Var `(28938):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										0
								[Var `(28939):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										1
								[Var `(28940):Bool]
									[EnumParameter:Bool]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										2
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Case:Dynamic]
							[Const:Int] 18
							[Block:Dynamic]
								[Var `(28941):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TSwitch
										0
								[Var `(28942):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
									[EnumParameter:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TSwitch
										1
								[Var `(28943):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TSwitch
										2
								[Block:Dynamic]
									[Var cases(28944):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>] [Local `(28942):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
									[Var defaultCase(28945):Null<haxe.macro.TypedExpr>] [Local `(28943):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Block:Void]
											[Var `(28946):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28946):Int:Int]
													<
													[Field:Int]
														[Local cases(28944):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
														[FInstance:Int]
															Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>
															length:Int
												[Block:Void]
													[Var c(28947):{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
														[Array:{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
															[Local cases(28944):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
															[Local `(28946):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28946):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Field:haxe.macro.TypedExpr]
																[Local c(28947):{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }:{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
																[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local defaultCase(28945):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												&&
												[Call:Bool]
													[Field:(expr : haxe.macro.TypedExpr) -> Bool]
														[Const:reflaxe.elixir.helpers.LoopCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
															reflaxe.elixir.helpers.LoopCompiler
															containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
													[Local defaultCase(28945):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Case:Dynamic]
							[Const:Int] 19
							[Block:Dynamic]
								[Var `(28948):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TTry
										0
								[Var `(28949):Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>]
									[EnumParameter:Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>]
										[Local `(28893):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TTry
										1
								[Block:Dynamic]
									[Var etry(28950):haxe.macro.TypedExpr] [Local `(28948):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var catches(28951):Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>] [Local `(28949):Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>:Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>]
									[Block:Dynamic]
										[If:Void]
											[Call:Bool]
												[Field:(expr : haxe.macro.TypedExpr) -> Bool]
													[Const:reflaxe.elixir.helpers.LoopCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
														reflaxe.elixir.helpers.LoopCompiler
														containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
												[Local etry(28950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Block:Void]
											[Var `(28952):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(28952):Int:Int]
													<
													[Field:Int]
														[Local catches(28951):Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>:Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>]
														[FInstance:Int]
															Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>
															length:Int
												[Block:Void]
													[Var c(28953):{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }]
														[Array:{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }]
															[Local catches(28951):Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>:Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>]
															[Local `(28952):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(28952):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																[Const:reflaxe.elixir.helpers.LoopCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																	reflaxe.elixir.helpers.LoopCompiler
																	containsTWhileExpression:(expr : haxe.macro.TypedExpr) -> Bool
															[Field:haxe.macro.TypedExpr]
																[Local c(28953):{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }:{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }]
																[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
										[Return:Dynamic] [Const:Bool] false
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
}