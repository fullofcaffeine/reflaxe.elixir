# Example type mappings generated by ElixirTyper

# Basic primitive mappings:
# Int → integer()
# Float → float()  
# Bool → boolean()
# String → String.t()
# Void → nil

# Collection mappings:
# Array<String> → list(String.t())
# Array<Int> → list(integer())
# Map<String, Int> → %{String.t() => integer()}

# Nullable mappings:
# Null<String> → String.t() | nil
# Null<Array<Int>> → list(integer()) | nil

# Complex nested mappings:
# Array<Array<String>> → list(list(String.t()))
# Array<Null<String>> → list(String.t() | nil)
# Map<String, Array<Int>> → %{String.t() => list(integer())}

# Phoenix type mappings:
# Conn → Plug.Conn.t()
# Socket → Phoenix.Socket.t()
# LiveView → Phoenix.LiveView.t()
# Channel → Phoenix.Channel.t()

# Ecto type mappings:
# Schema → Ecto.Schema.t()
# Changeset → Ecto.Changeset.t()
# Query → Ecto.Query.t()

# Generated @spec examples:
# From generateFunctionSpec("getUserData", ["String", "Int"], "Map<String, String>")
@spec get_user_data(String.t(), integer()) :: %{String.t() => String.t()}

# From generateFunctionSpec("processItems", ["Array<String>", "Null<Int>"], "Array<String>")  
@spec process_items(list(String.t()), integer() | nil) :: list(String.t())

# Generated @type examples:
# From generateTypeDefinition("User", [{name: "userName", type: "String"}, {name: "userAge", type: "Int"}])
@type t() :: %__MODULE__{
  user_name: String.t(),
  user_age: integer()
}

# Union type example:
# From generateUnionTypeDefinition("Result", ["String", "Int", "Error"])
@type t() ::
  String.t() |
  integer() |
  Error.t()

# Opaque type example:
# From generateOpaqueTypeDefinition("UserId", "String")
@opaque t() :: String.t()

# Function type example:
# From compileType("(String, Int) -> String")  
(String.t(), integer() -> String.t())

# Tuple type example:
# From compileType("{String, Int, Bool}")
{String.t(), integer(), boolean()}

# Custom type examples:
# UserService → UserService.t()
# CustomType<String> → CustomType.t(String.t())

# Complex real-world example - Phoenix controller function:
@spec show(Plug.Conn.t(), %{String.t() => String.t()}) :: Plug.Conn.t()
def show(conn, %{"id" => id}) do
  # Function implementation would go here
  conn
end

# Ecto schema example:
defmodule User do
  use Ecto.Schema
  
  @type t() :: %__MODULE__{
    id: integer() | nil,
    name: String.t(),
    email: String.t(),
    age: integer() | nil,
    active: boolean(),
    metadata: %{String.t() => String.t()} | nil
  }
  
  schema "users" do
    field :name, :string
    field :email, :string  
    field :age, :integer
    field :active, :boolean
    field :metadata, :map
    
    timestamps()
  end
  
  @spec create_user(String.t(), String.t()) :: {:ok, t()} | {:error, Ecto.Changeset.t()}
  def create_user(name, email) do
    # Implementation
  end
end

# LiveView example:
defmodule MyAppWeb.UserLive do
  use Phoenix.LiveView
  
  @type socket_assigns :: %{
    current_user: User.t() | nil,
    users: list(User.t()),
    loading: boolean()
  }
  
  @spec mount(map(), map(), Phoenix.LiveView.Socket.t()) :: {:ok, Phoenix.LiveView.Socket.t()}
  def mount(_params, _session, socket) do
    # Implementation
  end
end