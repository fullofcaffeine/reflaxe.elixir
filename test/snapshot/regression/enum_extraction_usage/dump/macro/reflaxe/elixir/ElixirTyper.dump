class reflaxe.elixir.ElixirTyper {

	public function new[Function:() -> Void]
		[Block:Map<String, String>]
			[Binop:Map<String, String>]
				[Field:Map<String, String>]
					[Const:reflaxe.elixir.ElixirTyper] this
					[FInstance:Map<String, String>]
						reflaxe.elixir.ElixirTyper
						typeCache:Map<String, String>
				=
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>

	@:value(new Map())
	var typeCache:Map<String, String>;

	public function compileType[Function:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local haxeType(13363):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13364):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local haxeType(13363):String:String]
						==
						[Const:String] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local haxeType(13363):String:String]
							[FInstance:Int]
								String
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "term()"
			[If:Void]
				[Block:Bool]
					[Var this(13367):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Const:reflaxe.elixir.ElixirTyper] this
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirTyper
								typeCache:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(13367):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Local haxeType(13363):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var cached(13373):Null<String>]
						[Block:Null<String>]
							[Var this(13371):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[Const:reflaxe.elixir.ElixirTyper] this
									[FInstance:Map<String, String>]
										reflaxe.elixir.ElixirTyper
										typeCache:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(13371):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local haxeType(13363):String:String]
					[Return:Dynamic]
						[If:String]
							[Binop:Bool]
								[Local cached(13373):Null<String>:Null<String>]
								!=
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>] [Local cached(13373):Null<String>:Null<String>]
							[Else:String] [Block:String] [Const:String] "any()"
			[Var result(13442):String]
				[Call:String]
					[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
							reflaxe.elixir.ElixirTyper
							compileTypeInternal:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
					[Local haxeType(13363):String:String]
					[Local context(13364):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Block:Void]
				[Var this(13445):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirTyper
							typeCache:Map<String, String>
				[Call:Void]
					[Field:(key : String, value : String) -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(13445):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:(key : String, value : String) -> Void]
							haxe.ds.StringMap<String>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Local haxeType(13363):String:String]
					[Local result(13442):String:String]
			[Return:Dynamic] [Local result(13442):String:String]

	function compileTypeInternal[Function:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local haxeType(13374):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13375):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local haxeType(13374):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "Null<"
						[Const:Null<Int>] null
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var innerType(13379):String]
						[Call:String]
							[Field:(genericType : String) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(genericType : String) -> String]
									reflaxe.elixir.ElixirTyper
									extractGenericType:(genericType : String) -> String
							[Local haxeType(13374):String:String]
					[Var innerElixirType(13380):String]
						[Call:String]
							[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Local innerType(13379):String:String]
							[Local context(13375):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local innerElixirType(13380):String:String]
							+
							[Const:String] " | nil"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local haxeType(13374):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "Array<"
						[Const:Null<Int>] null
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var elementType(13381):String]
						[Call:String]
							[Field:(genericType : String) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(genericType : String) -> String]
									reflaxe.elixir.ElixirTyper
									extractGenericType:(genericType : String) -> String
							[Local haxeType(13374):String:String]
					[Var elementElixirType(13382):String]
						[Call:String]
							[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Local elementType(13381):String:String]
							[Local context(13375):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "list("
								+
								[Local elementElixirType(13382):String:String]
							+
							[Const:String] ")"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local haxeType(13374):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "Map<"
						[Const:Null<Int>] null
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var typeParams(13390):{ value : String, key : String }]
						[Call:{ value : String, key : String }]
							[Field:(mapType : String) -> { value : String, key : String }]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(mapType : String) -> { value : String, key : String }]
									reflaxe.elixir.ElixirTyper
									extractMapTypes:(mapType : String) -> { value : String, key : String }
							[Local haxeType(13374):String:String]
					[Var keyType(13391):String]
						[Call:String]
							[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Field:String]
								[Local typeParams(13390):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] key:String
							[Local context(13375):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
					[Var valueType(13392):String]
						[Call:String]
							[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Field:String]
								[Local typeParams(13390):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] value:String
							[Local context(13375):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "%{"
										+
										[Local keyType(13391):String:String]
									+
									[Const:String] " => "
								+
								[Local valueType(13392):String:String]
							+
							[Const:String] "}"
			[If:Void]
				[Block:Bool]
					[Var this(13395):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[TypeExpr reflaxe.elixir.ElixirTyper:Class<reflaxe.elixir.ElixirTyper>]
							[FStatic:Map<String, String>]
								reflaxe.elixir.ElixirTyper
								phoenixTypes:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(13395):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Local haxeType(13374):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var phoenixType(13401):Null<String>]
						[Block:Null<String>]
							[Var this(13399):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[TypeExpr reflaxe.elixir.ElixirTyper:Class<reflaxe.elixir.ElixirTyper>]
									[FStatic:Map<String, String>]
										reflaxe.elixir.ElixirTyper
										phoenixTypes:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(13399):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local haxeType(13374):String:String]
					[Return:Dynamic]
						[If:String]
							[Binop:Bool]
								[Local phoenixType(13401):Null<String>:Null<String>]
								!=
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>] [Local phoenixType(13401):Null<String>:Null<String>]
							[Else:String] [Block:String] [Const:String] "any()"
			[If:Void]
				[Block:Bool]
					[Var this(13404):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[TypeExpr reflaxe.elixir.ElixirTyper:Class<reflaxe.elixir.ElixirTyper>]
							[FStatic:Map<String, String>]
								reflaxe.elixir.ElixirTyper
								ectoTypes:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(13404):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Local haxeType(13374):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var ectoType(13410):Null<String>]
						[Block:Null<String>]
							[Var this(13408):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[TypeExpr reflaxe.elixir.ElixirTyper:Class<reflaxe.elixir.ElixirTyper>]
									[FStatic:Map<String, String>]
										reflaxe.elixir.ElixirTyper
										ectoTypes:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(13408):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local haxeType(13374):String:String]
					[Return:Dynamic]
						[If:String]
							[Binop:Bool]
								[Local ectoType(13410):Null<String>:Null<String>]
								!=
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>] [Local ectoType(13410):Null<String>:Null<String>]
							[Else:String] [Block:String] [Const:String] "any()"
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (haxeType) {
	case "Int":
		"integer()";	
	case "Float":
		"float()";	
	case "Bool":
		"boolean()";	
	case "String":
		"String.t()";	
	case "Void":
		"nil";	
	case "Dynamic":
		"term()";	
	case _:
		handleComplexType(haxeType, context);	
})
					[Switch:String]
						[Local haxeType(13374):String:String]
						[Case:String]
							[Const:String] "Bool"
							[Block:String] [Block:String] [Const:String] "boolean()"
						[Case:String]
							[Const:String] "Dynamic"
							[Block:String] [Block:String] [Const:String] "term()"
						[Case:String]
							[Const:String] "Float"
							[Block:String] [Block:String] [Const:String] "float()"
						[Case:String]
							[Const:String] "Int"
							[Block:String] [Block:String] [Const:String] "integer()"
						[Case:String]
							[Const:String] "String"
							[Block:String] [Block:String] [Const:String] "String.t()"
						[Case:String]
							[Const:String] "Void"
							[Block:String] [Block:String] [Const:String] "nil"
						[Default:String]
							[Block:String]
								[Call:String]
									[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										[Const:reflaxe.elixir.ElixirTyper] this
										[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
											reflaxe.elixir.ElixirTyper
											handleComplexType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
									[Local haxeType(13374):String:String]
									[Local context(13375):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]

	@:value({ indentLevel : 1 })
	public function generateFunctionSpec[Function:(funcName : String, paramTypes : Array<String>, returnType : String, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
		[Arg:String] [Local funcName(13448):String]
		[Arg:Array<String>] [Local paramTypes(13449):Array<String>]
		[Arg:String] [Local returnType(13450):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13451):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Arg:Int]
			[Local indentLevel(13452):Int]
			[Const:Int] 1
		[Block:Dynamic]
			[Var `this(13455):reflaxe.elixir.ElixirTyper] [Const:reflaxe.elixir.ElixirTyper] this
			[Var elixirFuncName(13453):String]
				[Call:String]
					[Field:(name : String) -> String]
						[TypeExpr reflaxe.elixir.ast.NameUtils:Class<reflaxe.elixir.ast.NameUtils>]
						[FStatic:(name : String) -> String]
							reflaxe.elixir.ast.NameUtils
							toSnakeCase:(name : String) -> String
					[Local funcName(13448):String:String]
			[Var elixirParamTypes(13456):Array<String>]
				[Call:Array<String>]
					[Field:(f : (String -> String)) -> Array<String>]
						[Local paramTypes(13449):Array<String>:Array<String>]
						[FInstance:(f : (String -> String)) -> Array<String>]
							Array<String>
							map:(f : (Array.T -> map.S)) -> Array<map.S>
					[Function:(type : String) -> String]
						[Arg:String] [Local type(13454):String]
						[Return:Dynamic]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Local `this(13455):reflaxe.elixir.ElixirTyper:reflaxe.elixir.ElixirTyper]
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Local type(13454):String:String]
								[Local context(13451):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Var elixirReturnType(13457):String]
				[Call:String]
					[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
							reflaxe.elixir.ElixirTyper
							compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
					[Local returnType(13450):String:String]
					[Local context(13451):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Var indent(13462):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13458):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13460):Int] [Const:Int] 0
								[Var `(13461):Int] [Local indentLevel(13452):Int:Int]
								[While:Void]
									[Binop:Bool]
										[Local `(13460):Int:Int]
										<
										[Local `(13461):Int:Int]
									[Block:Int]
										[Var i(13459):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13460):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13458):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13458):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var paramsStr(13463):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local elixirParamTypes(13456):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ", "
			[Return:Dynamic]
				[Binop:String]
					[Local indent(13462):String:String]
					+
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "@spec "
										+
										[Local elixirFuncName(13453):String:String]
									+
									[Const:String] "("
								+
								[Local paramsStr(13463):String:String]
							+
							[Const:String] ") :: "
						+
						[Local elixirReturnType(13457):String:String]

	@:value({ indentLevel : 1 })
	public function generateFunctionOverloadSpecs[Function:(funcName : String, overloads : Array<{ returns : String, params : Array<String> }>, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
		[Arg:String] [Local funcName(13464):String]
		[Arg:Array<{ returns : String, params : Array<String> }>] [Local overloads(13465):Array<{ returns : String, params : Array<String> }>]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13466):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Arg:Int]
			[Local indentLevel(13467):Int]
			[Const:Int] 1
		[Block:Dynamic]
			[Var specs(13468):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(13470):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(13470):Int:Int]
						<
						[Field:Int]
							[Local overloads(13465):Array<{ returns : String, params : Array<String> }>:Array<{ returns : String, params : Array<String> }>]
							[FInstance:Int]
								Array<{ returns : String, params : Array<String> }>
								length:Int
					[Block:Void]
						[Var signature(13469):{ returns : String, params : Array<String> }]
							[Array:{ returns : String, params : Array<String> }]
								[Local overloads(13465):Array<{ returns : String, params : Array<String> }>:Array<{ returns : String, params : Array<String> }>]
								[Local `(13470):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(13470):Int:Int]
						[Call:Int]
							[Field:(x : String) -> Int]
								[Local specs(13468):Array<String>:Array<String>]
								[FInstance:(x : String) -> Int]
									Array<String>
									push:(x : Array.T) -> Int
							[Call:String]
								[Field:(funcName : String, paramTypes : Array<String>, returnType : String, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
									[Const:reflaxe.elixir.ElixirTyper] this
									[FInstance:(funcName : String, paramTypes : Array<String>, returnType : String, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
										reflaxe.elixir.ElixirTyper
										generateFunctionSpec:(funcName : String, paramTypes : Array<String>, returnType : String, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String
								[Local funcName(13464):String:String]
								[Field:Array<String>]
									[Local signature(13469):{ returns : String, params : Array<String> }:{ returns : String, params : Array<String> }]
									[FAnon:Array<String>] params:Array<String>
								[Field:String]
									[Local signature(13469):{ returns : String, params : Array<String> }:{ returns : String, params : Array<String> }]
									[FAnon:String] returns:String
								[Local context(13466):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
								[Local indentLevel(13467):Int:Int]
			[Return:Dynamic]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local specs(13468):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] "\n"

	@:value({ indentLevel : 1 })
	public function generateTypeDefinition[Function:(typeName : String, fields : Array<{ type : String, name : String }>, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
		[Arg:String] [Local typeName(13471):String]
		[Arg:Array<{ type : String, name : String }>] [Local fields(13472):Array<{ type : String, name : String }>]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13473):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Arg:Int]
			[Local indentLevel(13474):Int]
			[Const:Int] 1
		[Block:Dynamic]
			[Var baseIndent(13479):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13475):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13477):Int] [Const:Int] 0
								[Var `(13478):Int] [Local indentLevel(13474):Int:Int]
								[While:Void]
									[Binop:Bool]
										[Local `(13477):Int:Int]
										<
										[Local `(13478):Int:Int]
									[Block:Int]
										[Var i(13476):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13477):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13475):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13475):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var fieldIndent(13484):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13480):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13482):Int] [Const:Int] 0
								[Var `(13483):Int]
									[Parenthesis:Int]
										[Binop:Int]
											[Local indentLevel(13474):Int:Int]
											+
											[Const:Int] 1
								[While:Void]
									[Binop:Bool]
										[Local `(13482):Int:Int]
										<
										[Local `(13483):Int:Int]
									[Block:Int]
										[Var i(13481):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13482):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13480):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13480):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var result(13485):String]
				[Binop:String]
					[Local baseIndent(13479):String:String]
					+
					[Const:String] "@type t() :: %__MODULE__{\n"
			[Block:Void]
				[Var `(13491):Int] [Const:Int] 0
				[Var `(13492):Int]
					[Field:Int]
						[Local fields(13472):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
						[FInstance:Int]
							Array<{ type : String, name : String }>
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(13491):Int:Int]
						<
						[Local `(13492):Int:Int]
					[Block:String]
						[Var i(13486):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(13491):Int:Int]
						[Var field(13487):{ type : String, name : String }]
							[Array:{ type : String, name : String }]
								[Local fields(13472):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
								[Local i(13486):Int:Int]
						[Var fieldName(13488):String]
							[Call:String]
								[Field:(name : String) -> String]
									[TypeExpr reflaxe.elixir.ast.NameUtils:Class<reflaxe.elixir.ast.NameUtils>]
									[FStatic:(name : String) -> String]
										reflaxe.elixir.ast.NameUtils
										toSnakeCase:(name : String) -> String
								[Field:String]
									[Local field(13487):{ type : String, name : String }:{ type : String, name : String }]
									[FAnon:String] name:String
						[Var fieldType(13489):String]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Const:reflaxe.elixir.ElixirTyper] this
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Field:String]
									[Local field(13487):{ type : String, name : String }:{ type : String, name : String }]
									[FAnon:String] type:String
								[Local context(13473):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
						[Var comma(13490):String]
							[If:String]
								[Parenthesis:Bool]
									[Binop:Bool]
										[Local i(13486):Int:Int]
										<
										[Binop:Int]
											[Field:Int]
												[Local fields(13472):Array<{ type : String, name : String }>:Array<{ type : String, name : String }>]
												[FInstance:Int]
													Array<{ type : String, name : String }>
													length:Int
											-
											[Const:Int] 1
								[Then:String] [Block:String] [Const:String] ","
								[Else:String] [Block:String] [Const:String] ""
						[Binop:String]
							[Local result(13485):String:String]
							+=
							[Binop:String]
								[Local fieldIndent(13484):String:String]
								+
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local fieldName(13488):String:String]
												+
												[Const:String] ": "
											+
											[Local fieldType(13489):String:String]
										+
										[Local comma(13490):String:String]
									+
									[Const:String] "\n"
			[Binop:String]
				[Local result(13485):String:String]
				+=
				[Binop:String]
					[Local baseIndent(13479):String:String]
					+
					[Const:String] "}"
			[Return:Dynamic] [Local result(13485):String:String]

	@:value({ indentLevel : 1 })
	public function generateUnionTypeDefinition[Function:(typeName : String, variants : Array<String>, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
		[Arg:String] [Local typeName(13493):String]
		[Arg:Array<String>] [Local variants(13494):Array<String>]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13495):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Arg:Int]
			[Local indentLevel(13496):Int]
			[Const:Int] 1
		[Block:Dynamic]
			[Var baseIndent(13501):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13497):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13499):Int] [Const:Int] 0
								[Var `(13500):Int] [Local indentLevel(13496):Int:Int]
								[While:Void]
									[Binop:Bool]
										[Local `(13499):Int:Int]
										<
										[Local `(13500):Int:Int]
									[Block:Int]
										[Var i(13498):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13499):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13497):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13497):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var variantIndent(13506):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13502):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13504):Int] [Const:Int] 0
								[Var `(13505):Int]
									[Parenthesis:Int]
										[Binop:Int]
											[Local indentLevel(13496):Int:Int]
											+
											[Const:Int] 1
								[While:Void]
									[Binop:Bool]
										[Local `(13504):Int:Int]
										<
										[Local `(13505):Int:Int]
									[Block:Int]
										[Var i(13503):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13504):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13502):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13502):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var result(13507):String]
				[Binop:String]
					[Local baseIndent(13501):String:String]
					+
					[Const:String] "@type t() ::\n"
			[Block:Void]
				[Var `(13512):Int] [Const:Int] 0
				[Var `(13513):Int]
					[Field:Int]
						[Local variants(13494):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(13512):Int:Int]
						<
						[Local `(13513):Int:Int]
					[Block:String]
						[Var i(13508):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(13512):Int:Int]
						[Var variant(13509):String]
							[Array:String]
								[Local variants(13494):Array<String>:Array<String>]
								[Local i(13508):Int:Int]
						[Var elixirType(13510):String]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Const:reflaxe.elixir.ElixirTyper] this
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Local variant(13509):String:String]
								[Local context(13495):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
						[Var separator(13511):String]
							[If:String]
								[Parenthesis:Bool]
									[Binop:Bool]
										[Local i(13508):Int:Int]
										<
										[Binop:Int]
											[Field:Int]
												[Local variants(13494):Array<String>:Array<String>]
												[FInstance:Int]
													Array<String>
													length:Int
											-
											[Const:Int] 1
								[Then:String] [Block:String] [Const:String] " |"
								[Else:String] [Block:String] [Const:String] ""
						[Binop:String]
							[Local result(13507):String:String]
							+=
							[Binop:String]
								[Local variantIndent(13506):String:String]
								+
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local elixirType(13510):String:String]
										+
										[Local separator(13511):String:String]
									+
									[Const:String] "\n"
			[Return:Dynamic] [Local result(13507):String:String]

	@:value({ indentLevel : 1 })
	public function generateOpaqueTypeDefinition[Function:(typeName : String, baseType : String, ?context : Null<reflaxe.elixir.TypeContext>, ?indentLevel : Int) -> String]
		[Arg:String] [Local typeName(13514):String]
		[Arg:String] [Local baseType(13515):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13516):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Arg:Int]
			[Local indentLevel(13517):Int]
			[Const:Int] 1
		[Block:Dynamic]
			[Var baseIndent(13522):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(13518):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(13520):Int] [Const:Int] 0
								[Var `(13521):Int] [Local indentLevel(13517):Int:Int]
								[While:Void]
									[Binop:Bool]
										[Local `(13520):Int:Int]
										<
										[Local `(13521):Int:Int]
									[Block:Int]
										[Var i(13519):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(13520):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(13518):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] "  "
							[Local `(13518):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Var elixirBaseType(13523):String]
				[Call:String]
					[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
							reflaxe.elixir.ElixirTyper
							compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
					[Local baseType(13515):String:String]
					[Local context(13516):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Return:Dynamic]
				[Binop:String]
					[Local baseIndent(13522):String:String]
					+
					[Binop:String]
						[Const:String] "@opaque t() :: "
						+
						[Local elixirBaseType(13523):String:String]

	public function isValidElixirType[Function:(typeStr : String) -> Bool]
		[Arg:String] [Local typeStr(13524):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local typeStr(13524):String:String]
						==
						[Const:String] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local typeStr(13524):String:String]
							[FInstance:Int]
								String
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var validPatterns(13525):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "integer()"
					[Const:String] "float()"
					[Const:String] "boolean()"
					[Const:String] "String.t()"
					[Const:String] "nil"
					[Const:String] "list("
					[Const:String] "%{"
					[Const:String] " | "
					[Const:String] "term()"
					[Const:String] "any()"
					[Const:String] "atom()"
			[Block:Void]
				[Var `(13527):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(13527):Int:Int]
						<
						[Field:Int]
							[Local validPatterns(13525):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var pattern(13526):String]
							[Array:String]
								[Local validPatterns(13525):Array<String>:Array<String>]
								[Local `(13527):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(13527):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Call:Int]
									[Field:(str : String, ?startIndex : Null<Int>) -> Int]
										[Local typeStr(13524):String:String]
										[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
											String
											indexOf:(str : String, ?startIndex : Null<Int>) -> Int
									[Local pattern(13526):String:String]
									[Const:Null<Int>] null
								>=
								[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	public function isHaxeType[Function:(typeStr : String) -> Bool]
		[Arg:String] [Local typeStr(13528):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local typeStr(13528):String:String]
						==
						[Const:String] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local typeStr(13528):String:String]
							[FInstance:Int]
								String
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var haxePatterns(13529):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "Array<"
					[Const:String] "Map<"
					[Const:String] "Null<"
					[Const:String] "Int"
					[Const:String] "Float"
					[Const:String] "Bool"
					[Const:String] "String"
					[Const:String] "Void"
					[Const:String] "Dynamic"
			[Block:Void]
				[Var `(13531):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(13531):Int:Int]
						<
						[Field:Int]
							[Local haxePatterns(13529):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var pattern(13530):String]
							[Array:String]
								[Local haxePatterns(13529):Array<String>:Array<String>]
								[Local `(13531):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(13531):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Call:Int]
									[Field:(str : String, ?startIndex : Null<Int>) -> Int]
										[Local typeStr(13528):String:String]
										[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
											String
											indexOf:(str : String, ?startIndex : Null<Int>) -> Int
									[Local pattern(13530):String:String]
									[Const:Null<Int>] null
								>=
								[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local typeStr(13528):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "String.t()"
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local typeStr(13528):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "integer()"
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic] [Const:Bool] true

	function extractGenericType[Function:(genericType : String) -> String]
		[Arg:String] [Local genericType(13376):String]
		[Block:Dynamic]
			[Var startIndex(13377):Int]
				[Binop:Int]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local genericType(13376):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "<"
						[Const:Null<Int>] null
					+
					[Const:Int] 1
			[Var endIndex(13378):Int]
				[Call:Int]
					[Field:(str : String, ?startIndex : Null<Int>) -> Int]
						[Local genericType(13376):String:String]
						[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
							String
							lastIndexOf:(str : String, ?startIndex : Null<Int>) -> Int
					[Const:String] ">"
					[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local startIndex(13377):Int:Int]
						>
						[Const:Int] 0
					&&
					[Binop:Bool]
						[Local endIndex(13378):Int:Int]
						>
						[Local startIndex(13377):Int:Int]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local genericType(13376):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Local startIndex(13377):Int:Int]
							[Local endIndex(13378):Int:Int]
			[Return:Dynamic] [Const:String] "any()"

	function extractMapTypes[Function:(mapType : String) -> { value : String, key : String }]
		[Arg:String] [Local mapType(13383):String]
		[Block:Dynamic]
			[Var startIndex(13384):Int]
				[Binop:Int]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local mapType(13383):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "<"
						[Const:Null<Int>] null
					+
					[Const:Int] 1
			[Var endIndex(13385):Int]
				[Call:Int]
					[Field:(str : String, ?startIndex : Null<Int>) -> Int]
						[Local mapType(13383):String:String]
						[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
							String
							lastIndexOf:(str : String, ?startIndex : Null<Int>) -> Int
					[Const:String] ">"
					[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local startIndex(13384):Int:Int]
						>
						[Const:Int] 0
					&&
					[Binop:Bool]
						[Local endIndex(13385):Int:Int]
						>
						[Local startIndex(13384):Int:Int]
				[Then:Void] [Block:Void]
					[Var typeParams(13386):String]
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local mapType(13383):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Local startIndex(13384):Int:Int]
							[Local endIndex(13385):Int:Int]
					[Var commaIndex(13387):Int]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local typeParams(13386):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] ","
							[Const:Null<Int>] null
					[If:Void]
						[Binop:Bool]
							[Local commaIndex(13387):Int:Int]
							>
							[Const:Int] 0
						[Then:Dynamic] [Block:Dynamic]
							[Var keyType(13388):String]
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Call:String]
										[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
											[Local typeParams(13386):String:String]
											[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
												String
												substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
										[Const:Int] 0
										[Local commaIndex(13387):Int:Int]
							[Var valueType(13389):String]
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Call:String]
										[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
											[Local typeParams(13386):String:String]
											[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
												String
												substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
										[Binop:Int]
											[Local commaIndex(13387):Int:Int]
											+
											[Const:Int] 1
										[Const:Null<Int>] null
							[Return:Dynamic]
								[ObjectDecl:{ value : String, key : String }]
									key: [Local keyType(13388):String:String]
									value: [Local valueType(13389):String:String]
			[Return:Dynamic]
				[ObjectDecl:{ value : String, key : String }]
					key: [Const:String] "any()"
					value: [Const:String] "any()"

	function handleComplexType[Function:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local haxeType(13411):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13412):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local haxeType(13411):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "->"
						[Const:Null<Int>] null
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(funcType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(funcType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileFunctionType:(funcType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Local haxeType(13411):String:String]
							[Local context(13412):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local haxeType(13411):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "{"
							[Const:Null<Int>] null
						==
						[Const:Int] 0
					&&
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local haxeType(13411):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "}"
							[Const:Null<Int>] null
						>
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(tupleType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(tupleType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileTupleType:(tupleType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Local haxeType(13411):String:String]
							[Local context(13412):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:Int]
							[Field:(str : String, ?startIndex : Null<Int>) -> Int]
								[Local haxeType(13411):String:String]
								[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
									String
									indexOf:(str : String, ?startIndex : Null<Int>) -> Int
							[Const:String] "<"
							[Const:Null<Int>] null
						>
						[Const:Int] 0
					&&
					[Unop:Bool]
						!
						Prefix
						[Call:Bool]
							[Field:(genericType : String) -> Bool]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(genericType : String) -> Bool]
									reflaxe.elixir.ElixirTyper
									isBuiltinGeneric:(genericType : String) -> Bool
							[Local haxeType(13411):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(genericType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
								[Const:reflaxe.elixir.ElixirTyper] this
								[FInstance:(genericType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									reflaxe.elixir.ElixirTyper
									compileGenericType:(genericType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
							[Local haxeType(13411):String:String]
							[Local context(13412):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[If:Void]
				[Call:Bool]
					[Field:(s : String) -> Bool]
						[New:EReg]
							EReg
							[Const:String] "^[A-Z]"
							[Const:String] ""
						[FInstance:(s : String) -> Bool]
							EReg
							match:(s : String) -> Bool
					[Local haxeType(13411):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var moduleName(13441):String]
						[Call:String]
							[Field:(typeName : String) -> String]
								[TypeExpr reflaxe.elixir.ast.NameUtils:Class<reflaxe.elixir.ast.NameUtils>]
								[FStatic:(typeName : String) -> String]
									reflaxe.elixir.ast.NameUtils
									getElixirModuleName:(typeName : String) -> String
							[Local haxeType(13411):String:String]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local moduleName(13441):String:String]
							+
							[Const:String] ".t()"
			[If:Void]
				[Call:Bool]
					[Field:(s : String) -> Bool]
						[New:EReg]
							EReg
							[Const:String] "^[a-z]"
							[Const:String] ""
						[FInstance:(s : String) -> Bool]
							EReg
							match:(s : String) -> Bool
					[Local haxeType(13411):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local haxeType(13411):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "("
								[Const:Null<Int>] null
							>
							[Const:Int] -1
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local haxeType(13411):String:String]
					[Return:Dynamic]
						[Binop:String]
							[Const:String] ":"
							+
							[Local haxeType(13411):String:String]
			[Return:Dynamic] [Const:String] "term()"

	function compileFunctionType[Function:(funcType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local funcType(13413):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13414):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[Var `this(13419):reflaxe.elixir.ElixirTyper] [Const:reflaxe.elixir.ElixirTyper] this
			[Var arrowIndex(13415):Int]
				[Call:Int]
					[Field:(str : String, ?startIndex : Null<Int>) -> Int]
						[Local funcType(13413):String:String]
						[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
							String
							indexOf:(str : String, ?startIndex : Null<Int>) -> Int
					[Const:String] "->"
					[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Local arrowIndex(13415):Int:Int]
					<
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "function()"
			[Var paramsPart(13416):String]
				[Call:String]
					[Field:(s : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String) -> String]
							StringTools
							trim:(s : String) -> String
					[Call:String]
						[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
							[Local funcType(13413):String:String]
							[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								String
								substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
						[Const:Int] 0
						[Local arrowIndex(13415):Int:Int]
			[Var returnPart(13417):String]
				[Call:String]
					[Field:(s : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String) -> String]
							StringTools
							trim:(s : String) -> String
					[Call:String]
						[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
							[Local funcType(13413):String:String]
							[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								String
								substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
						[Binop:Int]
							[Local arrowIndex(13415):Int:Int]
							+
							[Const:Int] 2
						[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local paramsPart(13416):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "("
						[Const:Null<Int>] null
					==
					[Const:Int] 0
				[Then:String] [Block:String]
					[Binop:String]
						[Local paramsPart(13416):String:String]
						=
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local paramsPart(13416):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Const:Int] 1
							[Binop:Int]
								[Field:Int]
									[Local paramsPart(13416):String:String]
									[FInstance:Int]
										String
										length:Int
								-
								[Const:Int] 1
			[Var paramTypes(13420):Array<String>]
				[Call:Array<String>]
					[Field:(f : (String -> String)) -> Array<String>]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local paramsPart(13416):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] ","
						[FInstance:(f : (String -> String)) -> Array<String>]
							Array<String>
							map:(f : (Array.T -> map.S)) -> Array<map.S>
					[Function:(p : String) -> String]
						[Arg:String] [Local p(13418):String]
						[Return:Dynamic]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Local `this(13419):reflaxe.elixir.ElixirTyper:reflaxe.elixir.ElixirTyper]
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Local p(13418):String:String]
								[Local context(13414):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Var returnType(13421):String]
				[Call:String]
					[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
							reflaxe.elixir.ElixirTyper
							compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
					[Local returnPart(13417):String:String]
					[Local context(13414):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Var paramStr(13422):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local paramTypes(13420):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ", "
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] "("
								+
								[Local paramStr(13422):String:String]
							+
							[Const:String] " -> "
						+
						[Local returnType(13421):String:String]
					+
					[Const:String] ")"

	function compileTupleType[Function:(tupleType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local tupleType(13423):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13424):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[Var `this(13427):reflaxe.elixir.ElixirTyper] [Const:reflaxe.elixir.ElixirTyper] this
			[Var inner(13425):String]
				[Call:String]
					[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
						[Local tupleType(13423):String:String]
						[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
							String
							substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
					[Const:Int] 1
					[Binop:Int]
						[Field:Int]
							[Local tupleType(13423):String:String]
							[FInstance:Int]
								String
								length:Int
						-
						[Const:Int] 1
			[Var elementTypes(13428):Array<String>]
				[Call:Array<String>]
					[Field:(f : (String -> String)) -> Array<String>]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local inner(13425):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] ","
						[FInstance:(f : (String -> String)) -> Array<String>]
							Array<String>
							map:(f : (Array.T -> map.S)) -> Array<map.S>
					[Function:(t : String) -> String]
						[Arg:String] [Local t(13426):String]
						[Return:Dynamic]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Local `this(13427):reflaxe.elixir.ElixirTyper:reflaxe.elixir.ElixirTyper]
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Local t(13426):String:String]
								[Local context(13424):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Const:String] "{"
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local elementTypes(13428):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] "}"

	function compileGenericType[Function:(genericType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
		[Arg:String] [Local genericType(13433):String]
		[Arg:Null<reflaxe.elixir.TypeContext>]
			[Local context(13434):Null<reflaxe.elixir.TypeContext>]
			[Const:Null<reflaxe.elixir.TypeContext>] null
		[Block:Dynamic]
			[Var `this(13439):reflaxe.elixir.ElixirTyper] [Const:reflaxe.elixir.ElixirTyper] this
			[Var baseType(13435):String]
				[Call:String]
					[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
						[Local genericType(13433):String:String]
						[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
							String
							substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
					[Const:Int] 0
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local genericType(13433):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "<"
						[Const:Null<Int>] null
			[Var typeParams(13436):String]
				[Call:String]
					[Field:(genericType : String) -> String]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:(genericType : String) -> String]
							reflaxe.elixir.ElixirTyper
							extractGenericType:(genericType : String) -> String
					[Local genericType(13433):String:String]
			[Var moduleName(13437):String]
				[Call:String]
					[Field:(typeName : String) -> String]
						[TypeExpr reflaxe.elixir.ast.NameUtils:Class<reflaxe.elixir.ast.NameUtils>]
						[FStatic:(typeName : String) -> String]
							reflaxe.elixir.ast.NameUtils
							getElixirModuleName:(typeName : String) -> String
					[Local baseType(13435):String:String]
			[Var paramTypes(13440):Array<String>]
				[Call:Array<String>]
					[Field:(f : (String -> String)) -> Array<String>]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local typeParams(13436):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] ","
						[FInstance:(f : (String -> String)) -> Array<String>]
							Array<String>
							map:(f : (Array.T -> map.S)) -> Array<map.S>
					[Function:(t : String) -> String]
						[Arg:String] [Local t(13438):String]
						[Return:Dynamic]
							[Call:String]
								[Field:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
									[Local `this(13439):reflaxe.elixir.ElixirTyper:reflaxe.elixir.ElixirTyper]
									[FInstance:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String]
										reflaxe.elixir.ElixirTyper
										compileType:(haxeType : String, ?context : Null<reflaxe.elixir.TypeContext>) -> String
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Local t(13438):String:String]
								[Local context(13434):Null<reflaxe.elixir.TypeContext>:Null<reflaxe.elixir.TypeContext>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local moduleName(13437):String:String]
							+
							[Const:String] ".t("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local paramTypes(13440):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function isBuiltinGeneric[Function:(genericType : String) -> Bool]
		[Arg:String] [Local genericType(13429):String]
		[Block:Dynamic]
			[Var builtins(13430):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "Array<"
					[Const:String] "Map<"
					[Const:String] "Null<"
			[Block:Void]
				[Var `(13432):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(13432):Int:Int]
						<
						[Field:Int]
							[Local builtins(13430):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var builtin(13431):String]
							[Array:String]
								[Local builtins(13430):Array<String>:Array<String>]
								[Local `(13432):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(13432):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Call:Int]
									[Field:(str : String, ?startIndex : Null<Int>) -> Int]
										[Local genericType(13429):String:String]
										[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
											String
											indexOf:(str : String, ?startIndex : Null<Int>) -> Int
									[Local builtin(13431):String:String]
									[Const:Null<Int>] null
								==
								[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	public function clearCache[Function:() -> Void]
		[Block:Void]
			[Block:Void]
				[Var this(13534):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Const:reflaxe.elixir.ElixirTyper] this
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirTyper
							typeCache:Map<String, String>
				[Call:Void]
					[Field:() -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(13534):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:() -> Void]
							haxe.ds.StringMap<String>
							clear:() -> Void

	public function getCacheStats[Function:() -> { size : Int, keys : Array<String> }]
		[Block:Dynamic]
			[Var keys(13535):Array<String>] [ArrayDecl:Array<String>]
			[For:Void]
				[Local key(13539):String]
				[Block:Iterator<String>]
					[Var this(13538):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Const:reflaxe.elixir.ElixirTyper] this
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirTyper
								typeCache:Map<String, String>
					[Call:Iterator<String>]
						[Field:() -> Iterator<String>]
							[Cast:haxe.ds.StringMap<String>] [Local this(13538):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:() -> Iterator<String>]
								haxe.ds.StringMap<String>
								keys:() -> Iterator<String>
				[Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local keys(13535):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Local key(13539):String:String]
			[Return:Dynamic]
				[ObjectDecl:{ size : Int, keys : Array<String> }]
					size: [Field:Int]
						[Local keys(13535):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					keys: [Local keys(13535):Array<String>:Array<String>]

	@:value(["Conn" => "Plug.Conn.t()", "Socket" => "Phoenix.Socket.t()", "LiveView" => "Phoenix.LiveView.t()", "Channel" => "Phoenix.Channel.t()", "Endpoint" => "Phoenix.Endpoint.t()"])
	static var phoenixTypes:Map<String, String> = [Block:haxe.ds.Map<String, String>]
		[Var `(13316):haxe.ds.Map<String, String>]
			[Block:haxe.ds.StringMap<String>]
				[Block:Void]
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Conn"
				[Const:String] "Plug.Conn.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Socket"
				[Const:String] "Phoenix.Socket.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "LiveView"
				[Const:String] "Phoenix.LiveView.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Channel"
				[Const:String] "Phoenix.Channel.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Endpoint"
				[Const:String] "Phoenix.Endpoint.t()"
		[Local `(13316):haxe.ds.Map<String, String>:haxe.ds.Map<String, String>];

	@:value(["Schema" => "Ecto.Schema.t()", "Changeset" => "Ecto.Changeset.t()", "Query" => "Ecto.Query.t()", "Repo" => "Ecto.Repo.t()"])
	static var ectoTypes:Map<String, String> = [Block:haxe.ds.Map<String, String>]
		[Var `(13342):haxe.ds.Map<String, String>]
			[Block:haxe.ds.StringMap<String>]
				[Block:Void]
				[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13342):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Schema"
				[Const:String] "Ecto.Schema.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13342):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Changeset"
				[Const:String] "Ecto.Changeset.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13342):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Query"
				[Const:String] "Ecto.Query.t()"
		[Block:Void]
			[Call:Void]
				[Field:(key : String, value : String) -> Void]
					[Local `(13342):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
					[FInstance:(key : String, value : String) -> Void]
						haxe.ds.StringMap<String>
						set:(key : String, value : haxe.ds.StringMap.T) -> Void
				[Const:String] "Repo"
				[Const:String] "Ecto.Repo.t()"
		[Local `(13342):haxe.ds.Map<String, String>:haxe.ds.Map<String, String>];
}