@:nullSafety(Off)
class reflaxe.elixir.helpers.ADTMethodCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(29551):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.ADTMethodCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.ADTMethodCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(29551):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function isOptionMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22301):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (methodName) {
	case "map", "then", "flatMap", "flatten", "filter", "unwrap", "lazyUnwrap", "or", "lazyOr", "isSome", "isNone", "all", "values", "toResult", "fromResult", "fromNullable", "toNullable", "toReply", "expect", "some", "none", "apply":
		true;	
	case _:
		false;	
})
					[Switch:Bool]
						[Local methodName(22301):String:String]
						[Case:Bool]
							[Const:String] "all"
							[Const:String] "apply"
							[Const:String] "expect"
							[Const:String] "filter"
							[Const:String] "flatMap"
							[Const:String] "flatten"
							[Const:String] "fromNullable"
							[Const:String] "fromResult"
							[Const:String] "isNone"
							[Const:String] "isSome"
							[Const:String] "lazyOr"
							[Const:String] "lazyUnwrap"
							[Const:String] "map"
							[Const:String] "none"
							[Const:String] "or"
							[Const:String] "some"
							[Const:String] "then"
							[Const:String] "toNullable"
							[Const:String] "toReply"
							[Const:String] "toResult"
							[Const:String] "unwrap"
							[Const:String] "values"
							[Block:Bool] [Block:Bool] [Const:Bool] true
						[Default:Bool] [Block:Bool] [Const:Bool] false

	public function isResultMethod[Function:(methodName : String) -> Bool]
		[Arg:String] [Local methodName(22313):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (methodName) {
	case "map", "flatMap", "bind", "fold", "filter", "isOk", "isError", "unwrap", "unwrapOr", "unwrapOrElse", "mapError", "bimap", "ok", "error", "sequence", "traverse", "toOption":
		true;	
	case _:
		false;	
})
					[Switch:Bool]
						[Local methodName(22313):String:String]
						[Case:Bool]
							[Const:String] "bimap"
							[Const:String] "bind"
							[Const:String] "error"
							[Const:String] "filter"
							[Const:String] "flatMap"
							[Const:String] "fold"
							[Const:String] "isError"
							[Const:String] "isOk"
							[Const:String] "map"
							[Const:String] "mapError"
							[Const:String] "ok"
							[Const:String] "sequence"
							[Const:String] "toOption"
							[Const:String] "traverse"
							[Const:String] "unwrap"
							[Const:String] "unwrapOr"
							[Const:String] "unwrapOrElse"
							[Block:Bool] [Block:Bool] [Const:Bool] true
						[Default:Bool] [Block:Bool] [Const:Bool] false

	public function compileADTStaticExtension[Function:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
		[Arg:haxe.macro.EnumType] [Local enumType(22994):haxe.macro.EnumType]
		[Arg:String] [Local methodName(22995):String]
		[Arg:String] [Local objStr(22996):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22997):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23001):reflaxe.elixir.helpers.ADTMethodCompiler] [Const:reflaxe.elixir.helpers.ADTMethodCompiler] this
			[Var toolsModule(22998):String] [Const:String] null
			[Var isExtensionMethod(22999):Bool] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:String]
							[Local enumType(22994):haxe.macro.EnumType:haxe.macro.EnumType]
							[FAnon:String] module:String
						==
						[Const:String] "haxe.ds.Option"
					&&
					[Binop:Bool]
						[Field:String]
							[Local enumType(22994):haxe.macro.EnumType:haxe.macro.EnumType]
							[FAnon:String] name:String
						==
						[Const:String] "Option"
				[Then:Bool] [Block:Bool]
					[Binop:String]
						[Local toolsModule(22998):String:String]
						=
						[Const:String] "OptionTools"
					[Binop:Bool]
						[Local isExtensionMethod(22999):Bool:Bool]
						=
						[Call:Bool]
							[Field:(methodName : String) -> Bool]
								[Const:reflaxe.elixir.helpers.ADTMethodCompiler] this
								[FInstance:(methodName : String) -> Bool]
									reflaxe.elixir.helpers.ADTMethodCompiler
									isOptionMethod:(methodName : String) -> Bool
							[Local methodName(22995):String:String]
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Field:String]
									[Local enumType(22994):haxe.macro.EnumType:haxe.macro.EnumType]
									[FAnon:String] module:String
								==
								[Const:String] "haxe.functional.Result"
							&&
							[Binop:Bool]
								[Field:String]
									[Local enumType(22994):haxe.macro.EnumType:haxe.macro.EnumType]
									[FAnon:String] name:String
								==
								[Const:String] "Result"
						[Then:Bool] [Block:Bool]
							[Binop:String]
								[Local toolsModule(22998):String:String]
								=
								[Const:String] "ResultTools"
							[Binop:Bool]
								[Local isExtensionMethod(22999):Bool:Bool]
								=
								[Call:Bool]
									[Field:(methodName : String) -> Bool]
										[Const:reflaxe.elixir.helpers.ADTMethodCompiler] this
										[FInstance:(methodName : String) -> Bool]
											reflaxe.elixir.helpers.ADTMethodCompiler
											isResultMethod:(methodName : String) -> Bool
									[Local methodName(22995):String:String]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local toolsModule(22998):String:String]
						!=
						[Const:String] null
					&&
					[Local isExtensionMethod(22999):Bool:Bool]
				[Then:Dynamic] [Block:Dynamic]
					[Var compiledArgs(23010):Array<Null<String>>]
						[Block:Array<Null<String>>]
							[Var `(23005):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
							[Block:Void]
								[Var `(23006):Int] [Const:Int] 0
								[Var `(23007):Array<haxe.macro.TypedExpr>] [Local args(22997):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[While:Void]
									[Binop:Bool]
										[Local `(23006):Int:Int]
										<
										[Field:Int]
											[Local `(23007):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
									[Block:Void]
										[Var v(23008):haxe.macro.TypedExpr]
											[Array:haxe.macro.TypedExpr]
												[Local `(23007):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local `(23006):Int:Int]
										[Unop:Int]
											++
											Prefix
											[Local `(23006):Int:Int]
										[Call:Int]
											[Field:(x : Null<String>) -> Int]
												[Local `(23005):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(x : Null<String>) -> Int]
													Array<Null<String>>
													push:(x : Array.T) -> Int
											[Call:Null<String>]
												[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
													[Arg:haxe.macro.TypedExpr] [Local arg(23009):haxe.macro.TypedExpr]
													[Block:Dynamic]
														[Return:Dynamic]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Local `this(23001):reflaxe.elixir.helpers.ADTMethodCompiler:reflaxe.elixir.helpers.ADTMethodCompiler]
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.ADTMethodCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local arg(23009):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
												[Local v(23008):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local `(23005):Array<Null<String>>:Array<Null<String>>]
					[Var result(23011):String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local toolsModule(22998):String:String]
												+
												[Const:String] "."
											+
											[Local methodName(22995):String:String]
										+
										[Const:String] "("
									+
									[Local objStr(22996):String:String]
								+
								[If:String]
									[Binop:Bool]
										[Field:Int]
											[Local compiledArgs(23010):Array<Null<String>>:Array<Null<String>>]
											[FInstance:Int]
												Array<Null<String>>
												length:Int
										>
										[Const:Int] 0
									[Then:String] [Block:String]
										[Binop:String]
											[Const:String] ", "
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(23010):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
									[Else:String] [Block:String] [Const:String] ""
							+
							[Const:String] ")"
					[Return:Dynamic] [Local result(23011):String:String]
			[Return:Dynamic] [Const:Null<String>] null
}