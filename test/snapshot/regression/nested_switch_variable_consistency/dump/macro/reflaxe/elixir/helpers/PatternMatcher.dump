class reflaxe.elixir.helpers.PatternMatcher {

	public function new[Function:() -> Void]
		[Block:Null<reflaxe.elixir.ElixirCompiler>]
			[Binop:Null<reflaxe.elixir.ElixirCompiler>]
				[Field:Null<reflaxe.elixir.ElixirCompiler>]
					[Const:reflaxe.elixir.helpers.PatternMatcher] this
					[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
						reflaxe.elixir.helpers.PatternMatcher
						compiler:Null<reflaxe.elixir.ElixirCompiler>
				=
				[Const:Null<reflaxe.elixir.ElixirCompiler>] null

	@:value({ defaultExpr : null })
	public function compileSwitchExpression[Function:(switchExpr : Dynamic, cases : Array<Dynamic>, ?defaultExpr : Null<Dynamic>) -> String]
		[Arg:Dynamic] [Local switchExpr(24936):Dynamic]
		[Arg:Array<Dynamic>] [Local cases(24937):Array<Dynamic>]
		[Arg:Null<Dynamic>]
			[Local defaultExpr(24938):Null<Dynamic>]
			[Const:Null<Dynamic>] null
		[Block:Dynamic]
			[Var result(24939):StringBuf] [New:StringBuf] StringBuf
			[Var switchValue(24942):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							compileExpression:(expr : Dynamic) -> String
					[Local switchExpr(24936):Dynamic:Dynamic]
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(24939):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "case "
						+
						[Local switchValue(24942):String:String]
					+
					[Const:String] " do\n"
			[Block:Void]
				[Var `(25132):Int] [Const:Int] 0
				[Var `(25133):Array<Dynamic>] [Parenthesis:Array<Dynamic>] [Cast:Array<Dynamic>] [Local cases(24937):Array<Dynamic>:Array<Dynamic>]
				[While:Void]
					[Binop:Bool]
						[Local `(25132):Int:Int]
						<
						[Field:Int]
							[Local `(25133):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(24943):Dynamic]
							[Array:Dynamic]
								[Local `(25133):Array<Dynamic>:Array<Dynamic>]
								[Local `(25132):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25132):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(24943):Dynamic:Dynamic]
									[FDynamic:Dynamic] values
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Block:Void]
									[Var `(25130):Int] [Const:Int] 0
									[Var `(25131):Array<Dynamic>]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Dynamic]
													[Local caseItem(24943):Dynamic:Dynamic]
													[FDynamic:Dynamic] values
									[While:Void]
										[Binop:Bool]
											[Local `(25130):Int:Int]
											<
											[Field:Int]
												[Local `(25131):Array<Dynamic>:Array<Dynamic>]
												[FInstance:Int]
													Array<Dynamic>
													length:Int
										[Block:Void]
											[Var value(24944):Dynamic]
												[Array:Dynamic]
													[Local `(25131):Array<Dynamic>:Array<Dynamic>]
													[Local `(25130):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25130):Int:Int]
											[Var pattern(25085):String]
												[Call:String]
													[Field:(patternExpr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(patternExpr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compilePattern:(patternExpr : Dynamic) -> String
													[Local value(24944):Dynamic:Dynamic]
											[Var guard(25104):String]
												[Call:String]
													[Field:(guardExpr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(guardExpr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compileGuard:(guardExpr : Dynamic) -> String
													[Field:Dynamic]
														[Local caseItem(24943):Dynamic:Dynamic]
														[FDynamic:Dynamic] guard
											[If:Void]
												[Binop:Bool]
													[Field:Null<reflaxe.elixir.ElixirCompiler>]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
															reflaxe.elixir.helpers.PatternMatcher
															compiler:Null<reflaxe.elixir.ElixirCompiler>
													!=
													[Const:Null<reflaxe.elixir.ElixirCompiler>] null
												[Then:Void] [Block:Void]
													[Call:Void]
														[Field:(inCaseArm : Bool) -> Void]
															[Field:Null<reflaxe.elixir.ElixirCompiler>]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
																	reflaxe.elixir.helpers.PatternMatcher
																	compiler:Null<reflaxe.elixir.ElixirCompiler>
															[FInstance:(inCaseArm : Bool) -> Void]
																reflaxe.elixir.ElixirCompiler
																setCaseArmContext:(inCaseArm : Bool) -> Void
														[Const:Bool] true
											[Var caseExpr(25106):String]
												[Call:String]
													[Field:(expr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(expr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compileExpression:(expr : Dynamic) -> String
													[Field:Dynamic]
														[Local caseItem(24943):Dynamic:Dynamic]
														[FDynamic:Dynamic] expr
											[If:Void]
												[Binop:Bool]
													[Field:Null<reflaxe.elixir.ElixirCompiler>]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
															reflaxe.elixir.helpers.PatternMatcher
															compiler:Null<reflaxe.elixir.ElixirCompiler>
													!=
													[Const:Null<reflaxe.elixir.ElixirCompiler>] null
												[Then:Void] [Block:Void]
													[Call:Void]
														[Field:(inCaseArm : Bool) -> Void]
															[Field:Null<reflaxe.elixir.ElixirCompiler>]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
																	reflaxe.elixir.helpers.PatternMatcher
																	compiler:Null<reflaxe.elixir.ElixirCompiler>
															[FInstance:(inCaseArm : Bool) -> Void]
																reflaxe.elixir.ElixirCompiler
																setCaseArmContext:(inCaseArm : Bool) -> Void
														[Const:Bool] false
													[Call:Void]
														[Field:() -> Void]
															[Field:Null<reflaxe.elixir.ElixirCompiler>]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
																	reflaxe.elixir.helpers.PatternMatcher
																	compiler:Null<reflaxe.elixir.ElixirCompiler>
															[FInstance:() -> Void]
																reflaxe.elixir.ElixirCompiler
																clearInlineContext:() -> Void
											[Var lines(25107):Array<String>]
												[Call:Array<String>]
													[Field:(delimiter : String) -> Array<String>]
														[Local caseExpr(25106):String:String]
														[FInstance:(delimiter : String) -> Array<String>]
															String
															split:(delimiter : String) -> Array<String>
													[Const:String] "\n"
											[Var filteredLines(25108):Array<String>] [ArrayDecl:Array<String>]
											[Block:Void]
												[Var `(25117):Int] [Const:Int] 0
												[Var `(25118):Int]
													[Field:Int]
														[Local lines(25107):Array<String>:Array<String>]
														[FInstance:Int]
															Array<String>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(25117):Int:Int]
														<
														[Local `(25118):Int:Int]
													[Block:Int]
														[Var i(25109):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(25117):Int:Int]
														[Var line(25110):String]
															[Call:String]
																[Field:(s : String) -> String]
																	[TypeExpr StringTools:Class<StringTools>]
																	[FStatic:(s : String) -> String]
																		StringTools
																		trim:(s : String) -> String
																[Array:String]
																	[Local lines(25107):Array<String>:Array<String>]
																	[Local i(25109):Int:Int]
														[If:Void]
															[Binop:Bool]
																[Binop:Bool]
																	[Local line(25110):String:String]
																	==
																	[Const:String] "g"
																||
																[Call:Bool]
																	[Field:(s : String) -> Bool]
																		[New:EReg]
																			EReg
																			[Const:String] "^g\\d*$"
																			[Const:String] ""
																		[FInstance:(s : String) -> Bool]
																			EReg
																			match:(s : String) -> Bool
																	[Local line(25110):String:String]
															[Then:Void] [Block:Void]
																[Var foundElemCall(25111):Bool] [Const:Bool] false
																[Var lookbackLimit(25112):Int]
																	[Call:Int]
																		[Field:(x : Float) -> Int]
																			[TypeExpr Std:Class<Std>]
																			[FStatic:(x : Float) -> Int]
																				Std
																				int:(x : Float) -> Int
																		[Call:Float]
																			[Field:(a : Float, b : Float) -> Float]
																				[TypeExpr Math:Class<Math>]
																				[FStatic:(a : Float, b : Float) -> Float]
																					Math
																					min:(a : Float, b : Float) -> Float
																			[Const:Int] 5
																			[Local i(25109):Int:Int]
																[Block:Void]
																	[Var `(25115):Int] [Const:Int] 1
																	[Var `(25116):Int]
																		[Binop:Int]
																			[Local lookbackLimit(25112):Int:Int]
																			+
																			[Const:Int] 1
																	[While:Void]
																		[Binop:Bool]
																			[Local `(25115):Int:Int]
																			<
																			[Local `(25116):Int:Int]
																		[Block:Void]
																			[Var j(25113):Int]
																				[Unop:Int]
																					++
																					Postfix
																					[Local `(25115):Int:Int]
																			[Var checkLine(25114):String]
																				[Call:String]
																					[Field:(s : String) -> String]
																						[TypeExpr StringTools:Class<StringTools>]
																						[FStatic:(s : String) -> String]
																							StringTools
																							trim:(s : String) -> String
																					[Array:String]
																						[Local lines(25107):Array<String>:Array<String>]
																						[Binop:Int]
																							[Local i(25109):Int:Int]
																							-
																							[Local j(25113):Int:Int]
																			[If:Void]
																				[Binop:Bool]
																					[Call:Int]
																						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																							[Local checkLine(25114):String:String]
																							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																								String
																								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																						[Const:String] "elem("
																						[Const:Null<Int>] null
																					>=
																					[Const:Int] 0
																				[Then:Dynamic] [Block:Dynamic]
																					[Binop:Bool]
																						[Local foundElemCall(25111):Bool:Bool]
																						=
																						[Const:Bool] true
																					[Break:Dynamic]
																[If:Void]
																	[Local foundElemCall(25111):Bool:Bool]
																	[Then:Dynamic] [Block:Dynamic] [Continue:Dynamic]
														[Call:Int]
															[Field:(x : String) -> Int]
																[Local filteredLines(25108):Array<String>:Array<String>]
																[FInstance:(x : String) -> Int]
																	Array<String>
																	push:(x : Array.T) -> Int
															[Array:String]
																[Local lines(25107):Array<String>:Array<String>]
																[Local i(25109):Int:Int]
											[Binop:String]
												[Local caseExpr(25106):String:String]
												=
												[Call:String]
													[Field:(sep : String) -> String]
														[Local filteredLines(25108):Array<String>:Array<String>]
														[FInstance:(sep : String) -> String]
															Array<String>
															join:(sep : String) -> String
													[Const:String] "\n"
											[Var guardClause(25119):String]
												[If:String]
													[Parenthesis:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Local guard(25104):String:String]
																!=
																[Const:String] null
															&&
															[Binop:Bool]
																[Field:Int]
																	[Local guard(25104):String:String]
																	[FInstance:Int]
																		String
																		length:Int
																>
																[Const:Int] 0
													[Then:String] [Block:String]
														[Binop:String]
															[Const:String] " when "
															+
															[Local guard(25104):String:String]
													[Else:String] [Block:String] [Const:String] ""
											[Call:Void]
												[Field:(x : String) -> Void]
													[Local result(24939):StringBuf:StringBuf]
													[FInstance:(x : String) -> Void]
														StringBuf
														add:(x : add.T) -> Void
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "  "
															+
															[Local pattern(25085):String:String]
														+
														[Local guardClause(25119):String:String]
													+
													[Const:String] " ->\n"
											[Call:Void]
												[Field:(x : String) -> Void]
													[Local result(24939):StringBuf:StringBuf]
													[FInstance:(x : String) -> Void]
														StringBuf
														add:(x : add.T) -> Void
												[Binop:String]
													[Binop:String]
														[Const:String] "    "
														+
														[Call:String]
															[Field:(expr : String) -> String]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:(expr : String) -> String]
																	reflaxe.elixir.helpers.PatternMatcher
																	indentExpression:(expr : String) -> String
															[Local caseExpr(25106):String:String]
													+
													[Const:String] "\n"
			[If:Void]
				[Binop:Bool]
					[Local defaultExpr(24938):Null<Dynamic>:Null<Dynamic>]
					!=
					[Const:Null<Dynamic>] null
				[Then:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Field:Null<reflaxe.elixir.ElixirCompiler>]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
									reflaxe.elixir.helpers.PatternMatcher
									compiler:Null<reflaxe.elixir.ElixirCompiler>
							!=
							[Const:Null<reflaxe.elixir.ElixirCompiler>] null
						[Then:Void] [Block:Void]
							[Call:Void]
								[Field:(inCaseArm : Bool) -> Void]
									[Field:Null<reflaxe.elixir.ElixirCompiler>]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
											reflaxe.elixir.helpers.PatternMatcher
											compiler:Null<reflaxe.elixir.ElixirCompiler>
									[FInstance:(inCaseArm : Bool) -> Void]
										reflaxe.elixir.ElixirCompiler
										setCaseArmContext:(inCaseArm : Bool) -> Void
								[Const:Bool] true
					[Var defaultCode(25134):String]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									compileExpression:(expr : Dynamic) -> String
							[Local defaultExpr(24938):Null<Dynamic>:Null<Dynamic>]
					[If:Void]
						[Binop:Bool]
							[Field:Null<reflaxe.elixir.ElixirCompiler>]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
									reflaxe.elixir.helpers.PatternMatcher
									compiler:Null<reflaxe.elixir.ElixirCompiler>
							!=
							[Const:Null<reflaxe.elixir.ElixirCompiler>] null
						[Then:Void] [Block:Void]
							[Call:Void]
								[Field:(inCaseArm : Bool) -> Void]
									[Field:Null<reflaxe.elixir.ElixirCompiler>]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
											reflaxe.elixir.helpers.PatternMatcher
											compiler:Null<reflaxe.elixir.ElixirCompiler>
									[FInstance:(inCaseArm : Bool) -> Void]
										reflaxe.elixir.ElixirCompiler
										setCaseArmContext:(inCaseArm : Bool) -> Void
								[Const:Bool] false
							[Call:Void]
								[Field:() -> Void]
									[Field:Null<reflaxe.elixir.ElixirCompiler>]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
											reflaxe.elixir.helpers.PatternMatcher
											compiler:Null<reflaxe.elixir.ElixirCompiler>
									[FInstance:() -> Void]
										reflaxe.elixir.ElixirCompiler
										clearInlineContext:() -> Void
					[Var lines(25135):Array<String>]
						[Call:Array<String>]
							[Field:(delimiter : String) -> Array<String>]
								[Local defaultCode(25134):String:String]
								[FInstance:(delimiter : String) -> Array<String>]
									String
									split:(delimiter : String) -> Array<String>
							[Const:String] "\n"
					[Var filteredLines(25136):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(25145):Int] [Const:Int] 0
						[Var `(25146):Int]
							[Field:Int]
								[Local lines(25135):Array<String>:Array<String>]
								[FInstance:Int]
									Array<String>
									length:Int
						[While:Void]
							[Binop:Bool]
								[Local `(25145):Int:Int]
								<
								[Local `(25146):Int:Int]
							[Block:Int]
								[Var i(25137):Int]
									[Unop:Int]
										++
										Postfix
										[Local `(25145):Int:Int]
								[Var line(25138):String]
									[Call:String]
										[Field:(s : String) -> String]
											[TypeExpr StringTools:Class<StringTools>]
											[FStatic:(s : String) -> String]
												StringTools
												trim:(s : String) -> String
										[Array:String]
											[Local lines(25135):Array<String>:Array<String>]
											[Local i(25137):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Binop:Bool]
											[Local line(25138):String:String]
											==
											[Const:String] "g"
										||
										[Call:Bool]
											[Field:(s : String) -> Bool]
												[New:EReg]
													EReg
													[Const:String] "^g\\d*$"
													[Const:String] ""
												[FInstance:(s : String) -> Bool]
													EReg
													match:(s : String) -> Bool
											[Local line(25138):String:String]
									[Then:Void] [Block:Void]
										[Var foundElemCall(25139):Bool] [Const:Bool] false
										[Var lookbackLimit(25140):Int]
											[Call:Int]
												[Field:(x : Float) -> Int]
													[TypeExpr Std:Class<Std>]
													[FStatic:(x : Float) -> Int]
														Std
														int:(x : Float) -> Int
												[Call:Float]
													[Field:(a : Float, b : Float) -> Float]
														[TypeExpr Math:Class<Math>]
														[FStatic:(a : Float, b : Float) -> Float]
															Math
															min:(a : Float, b : Float) -> Float
													[Const:Int] 5
													[Local i(25137):Int:Int]
										[Block:Void]
											[Var `(25143):Int] [Const:Int] 1
											[Var `(25144):Int]
												[Binop:Int]
													[Local lookbackLimit(25140):Int:Int]
													+
													[Const:Int] 1
											[While:Void]
												[Binop:Bool]
													[Local `(25143):Int:Int]
													<
													[Local `(25144):Int:Int]
												[Block:Void]
													[Var j(25141):Int]
														[Unop:Int]
															++
															Postfix
															[Local `(25143):Int:Int]
													[Var checkLine(25142):String]
														[Call:String]
															[Field:(s : String) -> String]
																[TypeExpr StringTools:Class<StringTools>]
																[FStatic:(s : String) -> String]
																	StringTools
																	trim:(s : String) -> String
															[Array:String]
																[Local lines(25135):Array<String>:Array<String>]
																[Binop:Int]
																	[Local i(25137):Int:Int]
																	-
																	[Local j(25141):Int:Int]
													[If:Void]
														[Binop:Bool]
															[Call:Int]
																[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																	[Local checkLine(25142):String:String]
																	[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																		String
																		indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																[Const:String] "elem("
																[Const:Null<Int>] null
															>=
															[Const:Int] 0
														[Then:Dynamic] [Block:Dynamic]
															[Binop:Bool]
																[Local foundElemCall(25139):Bool:Bool]
																=
																[Const:Bool] true
															[Break:Dynamic]
										[If:Void]
											[Local foundElemCall(25139):Bool:Bool]
											[Then:Dynamic] [Block:Dynamic] [Continue:Dynamic]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local filteredLines(25136):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Array:String]
										[Local lines(25135):Array<String>:Array<String>]
										[Local i(25137):Int:Int]
					[Binop:String]
						[Local defaultCode(25134):String:String]
						=
						[Call:String]
							[Field:(sep : String) -> String]
								[Local filteredLines(25136):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] "\n"
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(24939):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "  _ ->\n"
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(24939):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "    "
								+
								[Call:String]
									[Field:(expr : String) -> String]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(expr : String) -> String]
											reflaxe.elixir.helpers.PatternMatcher
											indentExpression:(expr : String) -> String
									[Local defaultCode(25134):String:String]
							+
							[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(24939):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "end"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(24939):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	public function compilePattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(24945):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local patternExpr(24945):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "_"
			[If:Void]
				[Call:Bool]
					[Field:(expr : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							isBinaryPattern:(expr : Dynamic) -> Bool
					[Local patternExpr(24945):Dynamic:Dynamic]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(patternExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(patternExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									compileBinaryPattern:(patternExpr : Dynamic) -> String
							[Local patternExpr(24945):Dynamic:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(expr : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							isPinPattern:(expr : Dynamic) -> Bool
					[Local patternExpr(24945):Dynamic:Dynamic]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(patternExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(patternExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									compilePinPattern:(patternExpr : Dynamic) -> String
							[Local patternExpr(24945):Dynamic:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (getExprType(patternExpr)) {
	case "TCall":
		compileEnumConstructorPattern(patternExpr);	
	case "TField":
		compileEnumFieldPattern(patternExpr);	
	case "TArrayDecl":
		compileArrayPattern(patternExpr);	
	case "TObjectDecl":
		compileObjectPattern(patternExpr);	
	case "TLocal":
		compileVariablePattern(patternExpr);	
	case "TConst":
		compileConstantPattern(patternExpr);	
	case "TTuple":
		compileTuplePattern(patternExpr);	
	case "TWildcard":
		"_";	
	case _:
		compileExpression(patternExpr);	
})
					[Block:String]
						[Var `(25084):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.PatternMatcher] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.PatternMatcher
										getExprType:(expr : Dynamic) -> String
								[Local patternExpr(24945):Dynamic:Dynamic]
						[Switch:String]
							[Local `(25084):String:String]
							[Case:String]
								[Const:String] "TArrayDecl"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileArrayPattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TCall"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileEnumConstructorPattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TConst"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileConstantPattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TField"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileEnumFieldPattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TLocal"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileVariablePattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TObjectDecl"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileObjectPattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TTuple"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileTuplePattern:(patternExpr : Dynamic) -> String
											[Local patternExpr(24945):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TWildcard"
								[Block:String] [Block:String] [Const:String] "_"
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compileExpression:(expr : Dynamic) -> String
										[Local patternExpr(24945):Dynamic:Dynamic]

	function compileEnumConstructorPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25013):Dynamic]
		[Block:Dynamic]
			[Var call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
				[Field:Dynamic]
					[Local patternExpr(25013):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<{ fa : Null<{ name : Null<String> }> }>]
							[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
							[FAnon:Null<{ fa : Null<{ name : Null<String> }> }>] e:Null<{ fa : Null<{ name : Null<String> }> }>
						!=
						[Const:Null<{ fa : Null<{ name : Null<String> }> }>] null
					&&
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									getExprType:(expr : Dynamic) -> String
							[Field:Null<{ fa : Null<{ name : Null<String> }> }>]
								[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
								[FAnon:Null<{ fa : Null<{ name : Null<String> }> }>] e:Null<{ fa : Null<{ name : Null<String> }> }>
						==
						[Const:String] "TField"
				[Then:Void] [Block:Void]
					[Var field(25015):Null<{ fa : Null<{ name : Null<String> }> }>]
						[Field:Null<{ fa : Null<{ name : Null<String> }> }>]
							[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
							[FAnon:Null<{ fa : Null<{ name : Null<String> }> }>] e:Null<{ fa : Null<{ name : Null<String> }> }>
					[Var enumField(25016):Null<{ name : Null<String> }>]
						[Field:Null<{ name : Null<String> }>]
							[Local field(25015):Null<{ fa : Null<{ name : Null<String> }> }>:Null<{ fa : Null<{ name : Null<String> }> }>]
							[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local enumField(25016):Null<{ name : Null<String> }>:Null<{ name : Null<String> }>]
								!=
								[Const:Null<{ name : Null<String> }>] null
							&&
							[Binop:Bool]
								[Field:Null<String>]
									[Local enumField(25016):Null<{ name : Null<String> }>:Null<{ name : Null<String> }>]
									[FAnon:Null<String>] name:Null<String>
								!=
								[Const:Null<String>] null
						[Then:Void] [Block:Void]
							[Var fieldName(25017):String]
								[Call:String]
									[Field:(camelCase : String) -> String]
										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
										[FStatic:(camelCase : String) -> String]
											reflaxe.elixir.helpers.NamingHelper
											toSnakeCase:(camelCase : String) -> String
									[Field:Null<String>]
										[Local enumField(25016):Null<{ name : Null<String> }>:Null<{ name : Null<String> }>]
										[FAnon:Null<String>] name:Null<String>
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Field:Null<Array<Dynamic>>]
											[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
											[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
										!=
										[Const:Null<Array<Dynamic>>] null
									&&
									[Binop:Bool]
										[Field:Int]
											[Field:Null<Array<Dynamic>>]
												[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
												[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
											[FAnon:Int] length:Int
										>
										[Const:Int] 0
								[Then:Dynamic] [Block:Dynamic]
									[Var args(25018):Array<String>] [ArrayDecl:Array<String>]
									[Block:Void]
										[Var `(25020):Int] [Const:Int] 0
										[Var `(25021):Array<Dynamic>]
											[Parenthesis:Array<Dynamic>]
												[Cast:Array<Dynamic>]
													[Field:Null<Array<Dynamic>>]
														[Local call(25014):{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }:{ el : Null<Array<Dynamic>>, e : Null<{ fa : Null<{ name : Null<String> }> }> }]
														[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
										[While:Void]
											[Binop:Bool]
												[Local `(25020):Int:Int]
												<
												[Field:Int]
													[Local `(25021):Array<Dynamic>:Array<Dynamic>]
													[FInstance:Int]
														Array<Dynamic>
														length:Int
											[Block:Void]
												[Var arg(25019):Dynamic]
													[Array:Dynamic]
														[Local `(25021):Array<Dynamic>:Array<Dynamic>]
														[Local `(25020):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(25020):Int:Int]
												[Call:Int]
													[Field:(x : String) -> Int]
														[Local args(25018):Array<String>:Array<String>]
														[FInstance:(x : String) -> Int]
															Array<String>
															push:(x : Array.T) -> Int
													[Call:String]
														[Field:(patternExpr : Dynamic) -> String]
															[Const:reflaxe.elixir.helpers.PatternMatcher] this
															[FInstance:(patternExpr : Dynamic) -> String]
																reflaxe.elixir.helpers.PatternMatcher
																compilePattern:(patternExpr : Dynamic) -> String
														[Local arg(25019):Dynamic:Dynamic]
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "{:"
														+
														[Local fieldName(25017):String:String]
													+
													[Const:String] ", "
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local args(25018):Array<String>:Array<String>]
														[FInstance:(sep : String) -> String]
															Array<String>
															join:(sep : String) -> String
													[Const:String] ", "
											+
											[Const:String] "}"
								[Else:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Binop:String]
											[Const:String] ":"
											+
											[Local fieldName(25017):String:String]
			[Return:Dynamic] [Const:String] "_"

	function compileEnumFieldPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25022):Dynamic]
		[Block:Dynamic]
			[Var field(25023):{ fa : Null<{ name : Null<String> }> }]
				[Field:Dynamic]
					[Local patternExpr(25022):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<{ name : Null<String> }>]
							[Local field(25023):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
							[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
						!=
						[Const:Null<{ name : Null<String> }>] null
					&&
					[Binop:Bool]
						[Field:Null<String>]
							[Field:Null<{ name : Null<String> }>]
								[Local field(25023):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
								[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
							[FAnon:Null<String>] name:Null<String>
						!=
						[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var fieldName(25024):String]
						[Call:String]
							[Field:(camelCase : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
								[FStatic:(camelCase : String) -> String]
									reflaxe.elixir.helpers.NamingHelper
									toSnakeCase:(camelCase : String) -> String
							[Field:Null<String>]
								[Field:Null<{ name : Null<String> }>]
									[Local field(25023):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
									[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
								[FAnon:Null<String>] name:Null<String>
					[Return:Dynamic]
						[Binop:String]
							[Const:String] ":"
							+
							[Local fieldName(25024):String:String]
			[Return:Dynamic] [Const:String] "_"

	function compileArrayPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25025):Dynamic]
		[Block:Dynamic]
			[Var arr(25026):{ el : Null<Array<Dynamic>> }]
				[Field:Dynamic]
					[Local patternExpr(25025):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local arr(25026):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
						[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Void] [Block:Void]
					[Var elements(25027):Array<String>] [ArrayDecl:Array<String>]
					[Var restElement(25028):Null<String>] [Const:Null<String>] null
					[Var hasRestPattern(25029):Bool] [Const:Bool] false
					[Block:Void]
						[Var `(25033):Int] [Const:Int] 0
						[Var `(25034):Int]
							[Field:Int]
								[Parenthesis:Array<Dynamic>]
									[Cast:Array<Dynamic>]
										[Field:Null<Array<Dynamic>>]
											[Local arr(25026):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
											[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
								[FInstance:Int]
									Array<Dynamic>
									length:Int
						[While:Void]
							[Binop:Bool]
								[Local `(25033):Int:Int]
								<
								[Local `(25034):Int:Int]
							[Block:Void]
								[Var i(25030):Int]
									[Unop:Int]
										++
										Postfix
										[Local `(25033):Int:Int]
								[Var element(25031):Unknown<60>]
									[Array:Dynamic]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Null<Array<Dynamic>>]
													[Local arr(25026):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
													[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
										[Local i(25030):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Call:Bool]
											[Field:(expr : Dynamic) -> Bool]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(expr : Dynamic) -> Bool]
													reflaxe.elixir.helpers.PatternMatcher
													isRestPattern:(expr : Dynamic) -> Bool
											[Local element(25031):Unknown<60>:Unknown<60>]
										||
										[Call:Bool]
											[Field:(expr : Dynamic) -> Bool]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(expr : Dynamic) -> Bool]
													reflaxe.elixir.helpers.PatternMatcher
													isTailPattern:(expr : Dynamic) -> Bool
											[Local element(25031):Unknown<60>:Unknown<60>]
									[Then:Null<String>] [Block:Null<String>]
										[Binop:Bool]
											[Local hasRestPattern(25029):Bool:Bool]
											=
											[Const:Bool] true
										[Binop:Null<String>]
											[Local restElement(25028):Null<String>:Null<String>]
											=
											[Call:String]
												[Field:(patternExpr : Dynamic) -> String]
													[Const:reflaxe.elixir.helpers.PatternMatcher] this
													[FInstance:(patternExpr : Dynamic) -> String]
														reflaxe.elixir.helpers.PatternMatcher
														compilePattern:(patternExpr : Dynamic) -> String
												[Call:Dynamic]
													[Field:(expr : Dynamic) -> Dynamic]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(expr : Dynamic) -> Dynamic]
															reflaxe.elixir.helpers.PatternMatcher
															extractRestVariable:(expr : Dynamic) -> Dynamic
													[Local element(25031):Unknown<60>:Unknown<60>]
									[Else:Void] [Block:Void]
										[If:Void]
											[Unop:Bool]
												!
												Prefix
												[Local hasRestPattern(25029):Bool:Bool]
											[Then:Int] [Block:Int]
												[Call:Int]
													[Field:(x : String) -> Int]
														[Local elements(25027):Array<String>:Array<String>]
														[FInstance:(x : String) -> Int]
															Array<String>
															push:(x : Array.T) -> Int
													[Call:String]
														[Field:(patternExpr : Dynamic) -> String]
															[Const:reflaxe.elixir.helpers.PatternMatcher] this
															[FInstance:(patternExpr : Dynamic) -> String]
																reflaxe.elixir.helpers.PatternMatcher
																compilePattern:(patternExpr : Dynamic) -> String
														[Local element(25031):Unknown<60>:Unknown<60>]
											[Else:Void] [Block:Void]
												[Call:Void]
													[Field:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
														[TypeExpr haxe.Log:Class<haxe.Log>]
														[FStatic:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void]
															haxe.Log
															trace:(v : Dynamic, ?infos : Null<haxe.PosInfos>) -> Void
													[Const:String] "Warning: Elements after rest pattern are not supported in Elixir"
													[ObjectDecl:{ methodName : String, lineNumber : Int, fileName : String, ?customParams : Null<Array<Dynamic>>, className : String }]
														fileName: [Const:String] "../../../src/reflaxe/elixir/helpers/PatternMatcher.hx"
														lineNumber: [Const:Int] 290
														className: [Const:String] "reflaxe.elixir.helpers.PatternMatcher"
														methodName: [Const:String] "compileArrayPattern"
					[If:Void]
						[Binop:Bool]
							[Local restElement(25028):Null<String>:Null<String>]
							!=
							[Const:Null<String>] null
						[Then:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Field:Int]
										[Local elements(25027):Array<String>:Array<String>]
										[FInstance:Int]
											Array<String>
											length:Int
									>
									[Const:Int] 0
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "["
														+
														[Call:String]
															[Field:(sep : String) -> String]
																[Local elements(25027):Array<String>:Array<String>]
																[FInstance:(sep : String) -> String]
																	Array<String>
																	join:(sep : String) -> String
															[Const:String] ", "
													+
													[Const:String] " | "
												+
												[Local restElement(25028):Null<String>:Null<String>]
											+
											[Const:String] "]"
								[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local restElement(25028):Null<String>:Null<String>]
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Field:Int]
										[Local elements(25027):Array<String>:Array<String>]
										[FInstance:Int]
											Array<String>
											length:Int
									>
									[Const:Int] 0
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Const:String] "["
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local elements(25027):Array<String>:Array<String>]
														[FInstance:(sep : String) -> String]
															Array<String>
															join:(sep : String) -> String
													[Const:String] ", "
											+
											[Const:String] "]"
			[Return:Dynamic] [Const:String] "[]"

	function compileObjectPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25035):Dynamic]
		[Block:Dynamic]
			[Var obj(25036):{ fields : Null<Array<Dynamic>> }]
				[Field:Dynamic]
					[Local patternExpr(25035):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local obj(25036):{ fields : Null<Array<Dynamic>> }:{ fields : Null<Array<Dynamic>> }]
						[FAnon:Null<Array<Dynamic>>] fields:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Void] [Block:Void]
					[Var fields(25037):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(25042):Int] [Const:Int] 0
						[Var `(25043):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Null<Array<Dynamic>>]
										[Local obj(25036):{ fields : Null<Array<Dynamic>> }:{ fields : Null<Array<Dynamic>> }]
										[FAnon:Null<Array<Dynamic>>] fields:Null<Array<Dynamic>>
						[While:Void]
							[Binop:Bool]
								[Local `(25042):Int:Int]
								<
								[Field:Int]
									[Local `(25043):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var field(25038):Dynamic]
									[Array:Dynamic]
										[Local `(25043):Array<Dynamic>:Array<Dynamic>]
										[Local `(25042):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25042):Int:Int]
								[Var fieldName(25039):String]
									[Field:Dynamic]
										[Local field(25038):Dynamic:Dynamic]
										[FDynamic:Dynamic] name
								[Var fieldValue(25040):String]
									[Call:String]
										[Field:(patternExpr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(patternExpr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compilePattern:(patternExpr : Dynamic) -> String
										[Field:Dynamic]
											[Local field(25038):Dynamic:Dynamic]
											[FDynamic:Dynamic] expr
								[Var elixirFieldName(25041):String]
									[Call:String]
										[Field:(camelCase : String) -> String]
											[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
											[FStatic:(camelCase : String) -> String]
												reflaxe.elixir.helpers.NamingHelper
												toSnakeCase:(camelCase : String) -> String
										[Local fieldName(25039):String:String]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fields(25037):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] ""
												+
												[Local elixirFieldName(25041):String:String]
											+
											[Const:String] ": "
										+
										[Local fieldValue(25040):String:String]
					[If:Void]
						[Binop:Bool]
							[Field:Dynamic]
								[Local patternExpr(25035):Dynamic:Dynamic]
								[FDynamic:Dynamic] structType
							!=
							[Const:Dynamic] null
						[Then:Dynamic] [Block:Dynamic]
							[Var structName(25044):String]
								[Call:String]
									[Field:(haxeName : String) -> String]
										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
										[FStatic:(haxeName : String) -> String]
											reflaxe.elixir.helpers.NamingHelper
											getElixirModuleName:(haxeName : String) -> String
									[Field:Dynamic]
										[Local patternExpr(25035):Dynamic:Dynamic]
										[FDynamic:Dynamic] structType
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "%"
												+
												[Local structName(25044):String:String]
											+
											[Const:String] "{"
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local fields(25037):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] "}"
						[Else:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Const:String] "%{"
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local fields(25037):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] "}"
			[Return:Dynamic] [Const:String] "%{}"

	function compileVariablePattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(24965):Dynamic]
		[Block:Dynamic]
			[Var local(24966):{ v : Null<{ name : Null<String> }> }]
				[Field:Dynamic]
					[Local patternExpr(24965):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<{ name : Null<String> }>]
							[Local local(24966):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
							[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
						!=
						[Const:Null<{ name : Null<String> }>] null
					&&
					[Binop:Bool]
						[Field:Null<String>]
							[Field:Null<{ name : Null<String> }>]
								[Local local(24966):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
								[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
							[FAnon:Null<String>] name:Null<String>
						!=
						[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(camelCase : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
								[FStatic:(camelCase : String) -> String]
									reflaxe.elixir.helpers.NamingHelper
									toSnakeCase:(camelCase : String) -> String
							[Field:Null<String>]
								[Field:Null<{ name : Null<String> }>]
									[Local local(24966):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
									[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
								[FAnon:Null<String>] name:Null<String>
			[Return:Dynamic] [Const:String] "_"

	function compileConstantPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25045):Dynamic]
		[Block:Dynamic]
			[Var const(25046):haxe.macro.Constant]
				[Field:Dynamic]
					[Local patternExpr(25045):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (const) {
	case CInt(v, _):
		v;	
	case CFloat(f, _):
		f;	
	case CString(s, _):
		"\"${s}\"";	
	case CIdent(s):
		s;	
	case CRegexp(r, opt):
		"~r/${r}/${opt}";	
	case _:
		"nil";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(25062):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										0
								[Var `(25063):Null<String>]
									[EnumParameter:Null<String>]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										1
								[Block:String]
									[Var v(25064):String] [Local `(25062):String:String]
									[Block:String] [Local v(25064):String:String]
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(25065):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										0
								[Var `(25066):Null<String>]
									[EnumParameter:Null<String>]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										1
								[Block:String]
									[Var f(25067):String] [Local `(25065):String:String]
									[Block:String] [Local f(25067):String:String]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(25068):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CString
										0
								[Var `(25069):Null<haxe.macro.StringLiteralKind>]
									[EnumParameter:Null<haxe.macro.StringLiteralKind>]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CString
										1
								[Block:String]
									[Var s(25070):String] [Local `(25068):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "\""
												+
												[Local s(25070):String:String]
											+
											[Const:String] "\""
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(25071):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CIdent
										0
								[Block:String]
									[Var s(25072):String] [Local `(25071):String:String]
									[Block:String] [Local s(25072):String:String]
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(25073):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										0
								[Var `(25074):String]
									[EnumParameter:String]
										[Local const(25046):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										1
								[Block:String]
									[Var r(25075):String] [Local `(25073):String:String]
									[Var opt(25076):String] [Local `(25074):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "~r/"
													+
													[Local r(25075):String:String]
												+
												[Const:String] "/"
											+
											[Local opt(25076):String:String]

	function compileTuplePattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25077):Dynamic]
		[Block:Dynamic]
			[Var tuple(25078):{ el : Null<Array<Dynamic>> }]
				[Field:Dynamic]
					[Local patternExpr(25077):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local tuple(25078):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
						[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var elements(25079):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(25081):Int] [Const:Int] 0
						[Var `(25082):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Null<Array<Dynamic>>]
										[Local tuple(25078):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
										[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
						[While:Void]
							[Binop:Bool]
								[Local `(25081):Int:Int]
								<
								[Field:Int]
									[Local `(25082):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var element(25080):Dynamic]
									[Array:Dynamic]
										[Local `(25082):Array<Dynamic>:Array<Dynamic>]
										[Local `(25081):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25081):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local elements(25079):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:(patternExpr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(patternExpr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compilePattern:(patternExpr : Dynamic) -> String
										[Local element(25080):Dynamic:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "{"
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local elements(25079):Array<String>:Array<String>]
										[FInstance:(sep : String) -> String]
											Array<String>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] "}"
			[Return:Dynamic] [Const:String] "{}"

	public function compileGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(25086):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local guardExpr(25086):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (getExprType(guardExpr)) {
	case "TBinop":
		compileBinaryGuard(guardExpr);	
	case "TCall":
		compileFunctionGuard(guardExpr);	
	case "TLocal":
		compileVariableGuard(guardExpr);	
	case _:
		compileExpression(guardExpr);	
})
					[Block:String]
						[Var `(25103):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.PatternMatcher] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.PatternMatcher
										getExprType:(expr : Dynamic) -> String
								[Local guardExpr(25086):Dynamic:Dynamic]
						[Switch:String]
							[Local `(25103):String:String]
							[Case:String]
								[Const:String] "TBinop"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileBinaryGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(25086):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TCall"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileFunctionGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(25086):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TLocal"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileVariableGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(25086):Dynamic:Dynamic]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compileExpression:(expr : Dynamic) -> String
										[Local guardExpr(25086):Dynamic:Dynamic]

	function compileBinaryGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(25087):Dynamic]
		[Block:Dynamic]
			[Var binop(25088):{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }]
				[Field:Dynamic]
					[Local guardExpr(25087):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var left(25089):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							compileExpression:(expr : Dynamic) -> String
					[Field:Unknown<61>]
						[Local binop(25088):{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }:{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }]
						[FAnon:Unknown<61>] e1:Unknown<61>
			[Var right(25090):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							compileExpression:(expr : Dynamic) -> String
					[Field:Unknown<62>]
						[Local binop(25088):{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }:{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }]
						[FAnon:Unknown<62>] e2:Unknown<62>
			[Var op(25092):String]
				[Call:String]
					[Field:(op : String) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(op : String) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							convertGuardOperator:(op : String) -> String
					[Field:String]
						[Local binop(25088):{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }:{ op : String, e2 : Unknown<62>, e1 : Unknown<61> }]
						[FAnon:String] op:String
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local left(25089):String:String]
								+
								[Const:String] " "
							+
							[Local op(25092):String:String]
						+
						[Const:String] " "
					+
					[Local right(25090):String:String]

	function compileFunctionGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(25093):Dynamic]
		[Block:Dynamic]
			[Var call(25094):{ el : Null<Array<Dynamic>>, e : Unknown<63> }]
				[Field:Dynamic]
					[Local guardExpr(25093):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var funcName(25095):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							getFunctionName:(expr : Dynamic) -> String
					[Field:Unknown<63>]
						[Local call(25094):{ el : Null<Array<Dynamic>>, e : Unknown<63> }:{ el : Null<Array<Dynamic>>, e : Unknown<63> }]
						[FAnon:Unknown<63>] e:Unknown<63>
			[Var args(25096):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local call(25094):{ el : Null<Array<Dynamic>>, e : Unknown<63> }:{ el : Null<Array<Dynamic>>, e : Unknown<63> }]
						[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(25098):Int] [Const:Int] 0
						[Var `(25099):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Null<Array<Dynamic>>]
										[Local call(25094):{ el : Null<Array<Dynamic>>, e : Unknown<63> }:{ el : Null<Array<Dynamic>>, e : Unknown<63> }]
										[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
						[While:Void]
							[Binop:Bool]
								[Local `(25098):Int:Int]
								<
								[Field:Int]
									[Local `(25099):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var arg(25097):Dynamic]
									[Array:Dynamic]
										[Local `(25099):Array<Dynamic>:Array<Dynamic>]
										[Local `(25098):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25098):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local args(25096):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compileExpression:(expr : Dynamic) -> String
										[Local arg(25097):Dynamic:Dynamic]
			[Var elixirFuncName(25100):String]
				[Call:String]
					[Field:(haxeName : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(haxeName : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							getElixirFunctionName:(haxeName : String) -> String
					[Local funcName(25095):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local elixirFuncName(25100):String:String]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local args(25096):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileVariableGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(25101):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(patternExpr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(patternExpr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							compileVariablePattern:(patternExpr : Dynamic) -> String
					[Local guardExpr(25101):Dynamic:Dynamic]

	function convertGuardOperator[Function:(op : String) -> String]
		[Arg:String] [Local op(25091):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (op) {
	case "==":
		"==";	
	case "!=":
		"!=";	
	case ">":
		">";	
	case "<":
		"<";	
	case ">=":
		">=";	
	case "<=":
		"<=";	
	case "&&":
		"and";	
	case "||":
		"or";	
	case "!":
		"not";	
	case _:
		op;	
})
					[Switch:String]
						[Local op(25091):String:String]
						[Case:String]
							[Const:String] "!"
							[Block:String] [Block:String] [Const:String] "not"
						[Case:String]
							[Const:String] "!="
							[Block:String] [Block:String] [Const:String] "!="
						[Case:String]
							[Const:String] "&&"
							[Block:String] [Block:String] [Const:String] "and"
						[Case:String]
							[Const:String] "<"
							[Block:String] [Block:String] [Const:String] "<"
						[Case:String]
							[Const:String] "<="
							[Block:String] [Block:String] [Const:String] "<="
						[Case:String]
							[Const:String] "=="
							[Block:String] [Block:String] [Const:String] "=="
						[Case:String]
							[Const:String] ">"
							[Block:String] [Block:String] [Const:String] ">"
						[Case:String]
							[Const:String] ">="
							[Block:String] [Block:String] [Const:String] ">="
						[Case:String]
							[Const:String] "||"
							[Block:String] [Block:String] [Const:String] "or"
						[Default:String] [Block:String] [Local op(25091):String:String]

	function getExprType[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24947):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local expr(24947):Dynamic:Dynamic]
						==
						[Const:Dynamic] null
					||
					[Binop:Bool]
						[Field:Dynamic]
							[Local expr(24947):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
						==
						[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "null"
			[Return:Dynamic]
				[Call:String]
					[Field:(c : Class<Dynamic>) -> String]
						[TypeExpr Type:Class<Type>]
						[FStatic:(c : Class<Dynamic>) -> String]
							Type
							getClassName:(c : Class<Dynamic>) -> String
					[Call:Class<Unknown<64>>]
						[Field:(o : Unknown<64>) -> Class<Unknown<64>>]
							[TypeExpr Type:Class<Type>]
							[FStatic:(o : Unknown<64>) -> Class<Unknown<64>>]
								Type
								getClass:(o : getClass.T) -> Class<getClass.T>
						[Field:Dynamic]
							[Local expr(24947):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr

	function isRestPattern[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24980):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local expr(24980):Dynamic:Dynamic]
						!=
						[Const:Dynamic] null
					&&
					[Binop:Bool]
						[Field:Dynamic]
							[Local expr(24980):Dynamic:Dynamic]
							[FDynamic:Dynamic] isRest
						==
						[Const:Bool] true

	function isTailPattern[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(25032):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local expr(25032):Dynamic:Dynamic]
						!=
						[Const:Dynamic] null
					&&
					[Parenthesis:Bool]
						[Binop:Bool]
							[Binop:Bool]
								[Field:Dynamic]
									[Local expr(25032):Dynamic:Dynamic]
									[FDynamic:Dynamic] isTail
								==
								[Const:Bool] true
							||
							[Binop:Bool]
								[Field:Dynamic]
									[Local expr(25032):Dynamic:Dynamic]
									[FDynamic:Dynamic] isRest
								==
								[Const:Bool] true

	function extractRestVariable[Function:(expr : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local expr(24981):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local expr(24981):Dynamic:Dynamic]
						!=
						[Const:Dynamic] null
					&&
					[Binop:Bool]
						[Field:Dynamic]
							[Local expr(24981):Dynamic:Dynamic]
							[FDynamic:Dynamic] restVar
						!=
						[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Field:Dynamic]
							[Local expr(24981):Dynamic:Dynamic]
							[FDynamic:Dynamic] restVar
			[Return:Dynamic] [Local expr(24981):Dynamic:Dynamic]

	function getFunctionName[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24950):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24950):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "unknown"
			[Return:Dynamic] [Const:String] "func"

	function isBinaryPattern[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24946):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24946):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local expr(24946):Dynamic:Dynamic]
						[FDynamic:Dynamic] isBinary
					==
					[Const:Bool] true
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24946):Dynamic:Dynamic]
					==
					[Const:String] "TCall"
				[Then:Void] [Block:Void]
					[Var call(24948):{ e : Null<{ isBinaryConstructor : Bool }> }]
						[Field:Dynamic]
							[Local expr(24946):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Null<{ isBinaryConstructor : Bool }>]
								[Local call(24948):{ e : Null<{ isBinaryConstructor : Bool }> }:{ e : Null<{ isBinaryConstructor : Bool }> }]
								[FAnon:Null<{ isBinaryConstructor : Bool }>] e:Null<{ isBinaryConstructor : Bool }>
							!=
							[Const:Null<{ isBinaryConstructor : Bool }>] null
						[Then:Void] [Block:Void]
							[Var funcExpr(24949):Null<{ isBinaryConstructor : Bool }>]
								[Field:Null<{ isBinaryConstructor : Bool }>]
									[Local call(24948):{ e : Null<{ isBinaryConstructor : Bool }> }:{ e : Null<{ isBinaryConstructor : Bool }> }]
									[FAnon:Null<{ isBinaryConstructor : Bool }>] e:Null<{ isBinaryConstructor : Bool }>
							[If:Void]
								[Binop:Bool]
									[Field:Bool]
										[Local funcExpr(24949):Null<{ isBinaryConstructor : Bool }>:Null<{ isBinaryConstructor : Bool }>]
										[FAnon:Bool] isBinaryConstructor:Bool
									==
									[Const:Bool] true
								[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
							[Var funcName(24951):String]
								[Call:String]
									[Field:(expr : Dynamic) -> String]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(expr : Dynamic) -> String]
											reflaxe.elixir.helpers.PatternMatcher
											getFunctionName:(expr : Dynamic) -> String
									[Field:Null<{ isBinaryConstructor : Bool }>]
										[Local call(24948):{ e : Null<{ isBinaryConstructor : Bool }> }:{ e : Null<{ isBinaryConstructor : Bool }> }]
										[FAnon:Null<{ isBinaryConstructor : Bool }>] e:Null<{ isBinaryConstructor : Bool }>
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Binop:Bool]
											[Local funcName(24951):String:String]
											==
											[Const:String] "binary"
										||
										[Binop:Bool]
											[Local funcName(24951):String:String]
											==
											[Const:String] "bytes"
									||
									[Binop:Bool]
										[Local funcName(24951):String:String]
										==
										[Const:String] "bitstring"
								[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24946):Dynamic:Dynamic]
					==
					[Const:String] "TConst"
				[Then:Void] [Block:Void]
					[Var constExpr(24952):Null<Unknown<65>>]
						[Field:Dynamic]
							[Local expr(24946):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local constExpr(24952):Null<Unknown<65>>:Null<Unknown<65>>]
								!=
								[Const:Null<Unknown<65>>] null
							&&
							[Binop:Bool]
								[Field:Dynamic]
									[Local expr(24946):Dynamic:Dynamic]
									[FDynamic:Dynamic] binaryPattern
								==
								[Const:Bool] true
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24946):Dynamic:Dynamic]
					==
					[Const:String] "TArrayDecl"
				[Then:Void] [Block:Void]
					[Var arr(24953):{ isBinarySegments : Bool }]
						[Field:Dynamic]
							[Local expr(24946):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Bool]
								[Local arr(24953):{ isBinarySegments : Bool }:{ isBinarySegments : Bool }]
								[FAnon:Bool] isBinarySegments:Bool
							==
							[Const:Bool] true
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	function compileBinaryPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(24954):Dynamic]
		[Block:Dynamic]
			[Var result(24955):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(24955):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "<<"
			[Var segments(24956):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local patternExpr(24954):Dynamic:Dynamic]
						[FDynamic:Dynamic] segments
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(24968):Int] [Const:Int] 0
						[Var `(24969):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Dynamic]
										[Local patternExpr(24954):Dynamic:Dynamic]
										[FDynamic:Dynamic] segments
						[While:Void]
							[Binop:Bool]
								[Local `(24968):Int:Int]
								<
								[Field:Int]
									[Local `(24969):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var segment(24957):Dynamic]
									[Array:Dynamic]
										[Local `(24969):Array<Dynamic>:Array<Dynamic>]
										[Local `(24968):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(24968):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local segments(24956):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:(segment : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(segment : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compileBinarySegment:(segment : Dynamic) -> String
										[Local segment(24957):Dynamic:Dynamic]
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.PatternMatcher] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.PatternMatcher
										getExprType:(expr : Dynamic) -> String
								[Local patternExpr(24954):Dynamic:Dynamic]
							==
							[Const:String] "TCall"
						[Then:Void] [Block:Void]
							[Var call(24970):{ el : Null<Array<Dynamic>> }]
								[Field:Dynamic]
									[Local patternExpr(24954):Dynamic:Dynamic]
									[FDynamic:Dynamic] expr
							[If:Void]
								[Binop:Bool]
									[Field:Null<Array<Dynamic>>]
										[Local call(24970):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
										[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
									!=
									[Const:Null<Array<Dynamic>>] null
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var `(24974):Int] [Const:Int] 0
										[Var `(24975):Array<Dynamic>]
											[Parenthesis:Array<Dynamic>]
												[Cast:Array<Dynamic>]
													[Field:Null<Array<Dynamic>>]
														[Local call(24970):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
														[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
										[While:Void]
											[Binop:Bool]
												[Local `(24974):Int:Int]
												<
												[Field:Int]
													[Local `(24975):Array<Dynamic>:Array<Dynamic>]
													[FInstance:Int]
														Array<Dynamic>
														length:Int
											[Block:Void]
												[Var arg(24971):Dynamic]
													[Array:Dynamic]
														[Local `(24975):Array<Dynamic>:Array<Dynamic>]
														[Local `(24974):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(24974):Int:Int]
												[Call:Int]
													[Field:(x : String) -> Int]
														[Local segments(24956):Array<String>:Array<String>]
														[FInstance:(x : String) -> Int]
															Array<String>
															push:(x : Array.T) -> Int
													[Call:String]
														[Field:(arg : Dynamic) -> String]
															[Const:reflaxe.elixir.helpers.PatternMatcher] this
															[FInstance:(arg : Dynamic) -> String]
																reflaxe.elixir.helpers.PatternMatcher
																compileBinarySegmentFromArg:(arg : Dynamic) -> String
														[Local arg(24971):Dynamic:Dynamic]
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												getExprType:(expr : Dynamic) -> String
										[Local patternExpr(24954):Dynamic:Dynamic]
									==
									[Const:String] "TArrayDecl"
								[Then:Void] [Block:Void]
									[Var arr(24976):{ el : Null<Array<Dynamic>> }]
										[Field:Dynamic]
											[Local patternExpr(24954):Dynamic:Dynamic]
											[FDynamic:Dynamic] expr
									[If:Void]
										[Binop:Bool]
											[Field:Null<Array<Dynamic>>]
												[Local arr(24976):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
												[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
											!=
											[Const:Null<Array<Dynamic>>] null
										[Then:Void] [Block:Void]
											[Var elements(24977):Array<Dynamic>]
												[Parenthesis:Array<Dynamic>]
													[Cast:Array<Dynamic>]
														[Field:Null<Array<Dynamic>>]
															[Local arr(24976):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
															[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
											[Block:Void]
												[Var `(24985):Int] [Const:Int] 0
												[Var `(24986):Int]
													[Field:Int]
														[Local elements(24977):Array<Dynamic>:Array<Dynamic>]
														[FInstance:Int]
															Array<Dynamic>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(24985):Int:Int]
														<
														[Local `(24986):Int:Int]
													[Block:Void]
														[Var i(24978):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(24985):Int:Int]
														[Var element(24979):Unknown<66>]
															[Array:Dynamic]
																[Local elements(24977):Array<Dynamic>:Array<Dynamic>]
																[Local i(24978):Int:Int]
														[If:Void]
															[Binop:Bool]
																[Binop:Bool]
																	[Local i(24978):Int:Int]
																	==
																	[Binop:Int]
																		[Field:Int]
																			[Local elements(24977):Array<Dynamic>:Array<Dynamic>]
																			[FInstance:Int]
																				Array<Dynamic>
																				length:Int
																		-
																		[Const:Int] 1
																&&
																[Call:Bool]
																	[Field:(expr : Dynamic) -> Bool]
																		[Const:reflaxe.elixir.helpers.PatternMatcher] this
																		[FInstance:(expr : Dynamic) -> Bool]
																			reflaxe.elixir.helpers.PatternMatcher
																			isRestPattern:(expr : Dynamic) -> Bool
																	[Local element(24979):Unknown<66>:Unknown<66>]
															[Then:Int] [Block:Int]
																[Var restVar(24982):Unknown<67>]
																	[Call:Dynamic]
																		[Field:(expr : Dynamic) -> Dynamic]
																			[Const:reflaxe.elixir.helpers.PatternMatcher] this
																			[FInstance:(expr : Dynamic) -> Dynamic]
																				reflaxe.elixir.helpers.PatternMatcher
																				extractRestVariable:(expr : Dynamic) -> Dynamic
																		[Local element(24979):Unknown<66>:Unknown<66>]
																[Var restPattern(24983):String]
																	[Call:String]
																		[Field:(patternExpr : Dynamic) -> String]
																			[Const:reflaxe.elixir.helpers.PatternMatcher] this
																			[FInstance:(patternExpr : Dynamic) -> String]
																				reflaxe.elixir.helpers.PatternMatcher
																				compilePattern:(patternExpr : Dynamic) -> String
																		[Local restVar(24982):Unknown<67>:Unknown<67>]
																[Call:Int]
																	[Field:(x : String) -> Int]
																		[Local segments(24956):Array<String>:Array<String>]
																		[FInstance:(x : String) -> Int]
																			Array<String>
																			push:(x : Array.T) -> Int
																	[Binop:String]
																		[Local restPattern(24983):String:String]
																		+
																		[Const:String] "::binary"
															[Else:Void] [Block:Void]
																[Var pattern(24984):String]
																	[Call:String]
																		[Field:(patternExpr : Dynamic) -> String]
																			[Const:reflaxe.elixir.helpers.PatternMatcher] this
																			[FInstance:(patternExpr : Dynamic) -> String]
																				reflaxe.elixir.helpers.PatternMatcher
																				compilePattern:(patternExpr : Dynamic) -> String
																		[Local element(24979):Unknown<66>:Unknown<66>]
																[If:Void]
																	[Binop:Bool]
																		[Local pattern(24984):String:String]
																		==
																		[Const:String] "_"
																	[Then:Int] [Block:Int]
																		[Call:Int]
																			[Field:(x : String) -> Int]
																				[Local segments(24956):Array<String>:Array<String>]
																				[FInstance:(x : String) -> Int]
																					Array<String>
																					push:(x : Array.T) -> Int
																			[Const:String] "_::8"
																	[Else:Int] [Block:Int]
																		[Call:Int]
																			[Field:(x : String) -> Int]
																				[Local segments(24956):Array<String>:Array<String>]
																				[FInstance:(x : String) -> Int]
																					Array<String>
																					push:(x : Array.T) -> Int
																			[Binop:String]
																				[Local pattern(24984):String:String]
																				+
																				[Const:String] "::8"
								[Else:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Call:String]
												[Field:(expr : Dynamic) -> String]
													[Const:reflaxe.elixir.helpers.PatternMatcher] this
													[FInstance:(expr : Dynamic) -> String]
														reflaxe.elixir.helpers.PatternMatcher
														getExprType:(expr : Dynamic) -> String
												[Local patternExpr(24954):Dynamic:Dynamic]
											==
											[Const:String] "TConst"
										[Then:Void] [Block:Void]
											[Var constExpr(24987):Null<haxe.macro.Constant>]
												[Field:Dynamic]
													[Local patternExpr(24954):Dynamic:Dynamic]
													[FDynamic:Dynamic] expr
											[If:Void]
												[Binop:Bool]
													[Local constExpr(24987):Null<haxe.macro.Constant>:Null<haxe.macro.Constant>]
													!=
													[Const:Null<haxe.macro.Constant>] null
												[Then:Void] [Block:Void]
													[Meta:Void]
														:ast(switch (constExpr) {
	case CString(s, _):
		segments.push("\"" + s + "\"");	
	case _:
		segments.push("_::binary");	
})
														[If:Void]
															[Binop:Bool]
																[Local constExpr(24987):Null<haxe.macro.Constant>:Null<haxe.macro.Constant>]
																==
																[Const:Null<haxe.macro.Constant>] null
															[Then:Int] [Block:Int]
																[Call:Int]
																	[Field:(x : String) -> Int]
																		[Local segments(24956):Array<String>:Array<String>]
																		[FInstance:(x : String) -> Int]
																			Array<String>
																			push:(x : Array.T) -> Int
																	[Const:String] "_::binary"
															[Else:Void] [If:Void]
																[Binop:Bool]
																	[EnumIndex:Int] [Local constExpr(24987):Null<haxe.macro.Constant>:Null<haxe.macro.Constant>]
																	==
																	[Const:Int] 2
																[Then:Int] [Block:Int]
																	[Var `(24991):String]
																		[EnumParameter:String]
																			[Local constExpr(24987):Null<haxe.macro.Constant>:Null<haxe.macro.Constant>]
																			CString
																			0
																	[Var `(24992):Null<haxe.macro.StringLiteralKind>]
																		[EnumParameter:Null<haxe.macro.StringLiteralKind>]
																			[Local constExpr(24987):Null<haxe.macro.Constant>:Null<haxe.macro.Constant>]
																			CString
																			1
																	[Block:Int]
																		[Var s(24993):String] [Local `(24991):String:String]
																		[Block:Int]
																			[Call:Int]
																				[Field:(x : String) -> Int]
																					[Local segments(24956):Array<String>:Array<String>]
																					[FInstance:(x : String) -> Int]
																						Array<String>
																						push:(x : Array.T) -> Int
																				[Binop:String]
																					[Binop:String]
																						[Const:String] "\""
																						+
																						[Local s(24993):String:String]
																					+
																					[Const:String] "\""
																[Else:Int] [Block:Int]
																	[Call:Int]
																		[Field:(x : String) -> Int]
																			[Local segments(24956):Array<String>:Array<String>]
																			[FInstance:(x : String) -> Int]
																				Array<String>
																				push:(x : Array.T) -> Int
																		[Const:String] "_::binary"
										[Else:Void] [Block:Void]
											[Var pattern(24994):String]
												[Call:String]
													[Field:(patternExpr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(patternExpr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compilePattern:(patternExpr : Dynamic) -> String
													[Local patternExpr(24954):Dynamic:Dynamic]
											[If:Void]
												[Binop:Bool]
													[Local pattern(24994):String:String]
													!=
													[Const:String] "_"
												[Then:Int] [Block:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local segments(24956):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Binop:String]
															[Local pattern(24994):String:String]
															+
															[Const:String] "::binary"
												[Else:Int] [Block:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local segments(24956):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Const:String] "_::binary"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local segments(24956):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 0
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local segments(24956):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "_::binary"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(24955):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Call:String]
					[Field:(sep : String) -> String]
						[Local segments(24956):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ", "
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(24955):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] ">>"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(24955):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	function compileBinarySegment[Function:(segment : Dynamic) -> String]
		[Arg:Dynamic] [Local segment(24958):Dynamic]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local segment(24958):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "_::8"
			[Var varName(24959):String] [Const:String] "_"
			[Var size(24960):String] [Const:String] ""
			[Var type(24961):String] [Const:String] "integer"
			[Var signedness(24962):String] [Const:String] ""
			[Var endianness(24963):String] [Const:String] ""
			[Var unit(24964):String] [Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] variable
					!=
					[Const:Dynamic] null
				[Then:String] [Block:String]
					[Binop:String]
						[Local varName(24959):String:String]
						=
						[Call:String]
							[Field:(patternExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(patternExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									compilePattern:(patternExpr : Dynamic) -> String
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] variable
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] name
							!=
							[Const:Dynamic] null
						[Then:String] [Block:String]
							[Binop:String]
								[Local varName(24959):String:String]
								=
								[Call:String]
									[Field:(camelCase : String) -> String]
										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
										[FStatic:(camelCase : String) -> String]
											reflaxe.elixir.helpers.NamingHelper
											toSnakeCase:(camelCase : String) -> String
									[Field:Dynamic]
										[Local segment(24958):Dynamic:Dynamic]
										[FDynamic:Dynamic] name
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												getExprType:(expr : Dynamic) -> String
										[Local segment(24958):Dynamic:Dynamic]
									==
									[Const:String] "TLocal"
								[Then:String] [Block:String]
									[Binop:String]
										[Local varName(24959):String:String]
										=
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compileVariablePattern:(patternExpr : Dynamic) -> String
											[Local segment(24958):Dynamic:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] size
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[If:Void]
						[Call:Bool]
							[Field:(v : Dynamic, t : Dynamic) -> Bool]
								[TypeExpr Std:Class<Std>]
								[FStatic:(v : Dynamic, t : Dynamic) -> Bool]
									Std
									isOfType:(v : Dynamic, t : Dynamic) -> Bool
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] size
							[TypeExpr Int:Abstract<Int>]
						[Then:String] [Block:String]
							[Binop:String]
								[Local size(24960):String:String]
								=
								[Binop:String]
									[Const:String] "::"
									+
									[Call:String]
										[Field:(s : Dynamic) -> String]
											[TypeExpr Std:Class<Std>]
											[FStatic:(s : Dynamic) -> String]
												Std
												string:(s : Dynamic) -> String
										[Field:Dynamic]
											[Local segment(24958):Dynamic:Dynamic]
											[FDynamic:Dynamic] size
						[Else:String] [Block:String]
							[Binop:String]
								[Local size(24960):String:String]
								=
								[Binop:String]
									[Const:String] "::"
									+
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												compileExpression:(expr : Dynamic) -> String
										[Field:Dynamic]
											[Local segment(24958):Dynamic:Dynamic]
											[FDynamic:Dynamic] size
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] type
					!=
					[Const:Dynamic] null
				[Then:String] [Block:String]
					[Binop:String]
						[Local type(24961):String:String]
						=
						[Field:Dynamic]
							[Local segment(24958):Dynamic:Dynamic]
							[FDynamic:Dynamic] type
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] binaryType
							!=
							[Const:Dynamic] null
						[Then:String] [Block:String]
							[Binop:String]
								[Local type(24961):String:String]
								=
								[Field:Dynamic]
									[Local segment(24958):Dynamic:Dynamic]
									[FDynamic:Dynamic] binaryType
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] signed
					==
					[Const:Bool] true
				[Then:String] [Block:String]
					[Binop:String]
						[Local signedness(24962):String:String]
						=
						[Const:String] "-signed"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] unsigned
							==
							[Const:Bool] true
						[Then:String] [Block:String]
							[Binop:String]
								[Local signedness(24962):String:String]
								=
								[Const:String] "-unsigned"
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] big
					==
					[Const:Bool] true
				[Then:String] [Block:String]
					[Binop:String]
						[Local endianness(24963):String:String]
						=
						[Const:String] "-big"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Field:Dynamic]
								[Local segment(24958):Dynamic:Dynamic]
								[FDynamic:Dynamic] little
							==
							[Const:Bool] true
						[Then:String] [Block:String]
							[Binop:String]
								[Local endianness(24963):String:String]
								=
								[Const:String] "-little"
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local segment(24958):Dynamic:Dynamic]
						[FDynamic:Dynamic] unit
					!=
					[Const:Dynamic] null
				[Then:String] [Block:String]
					[Binop:String]
						[Local unit(24964):String:String]
						=
						[Binop:String]
							[Binop:String]
								[Const:String] "-unit("
								+
								[Call:String]
									[Field:(s : Dynamic) -> String]
										[TypeExpr Std:Class<Std>]
										[FStatic:(s : Dynamic) -> String]
											Std
											string:(s : Dynamic) -> String
									[Field:Dynamic]
										[Local segment(24958):Dynamic:Dynamic]
										[FDynamic:Dynamic] unit
							+
							[Const:String] ")"
			[Var typeSpec(24967):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Local type(24961):String:String]
							+
							[Local signedness(24962):String:String]
						+
						[Local endianness(24963):String:String]
					+
					[Local unit(24964):String:String]
			[If:Void]
				[Binop:Bool]
					[Local size(24960):String:String]
					!=
					[Const:String] ""
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] ""
										+
										[Local varName(24959):String:String]
									+
									[Local size(24960):String:String]
								+
								[Const:String] "-"
							+
							[Local typeSpec(24967):String:String]
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Local type(24961):String:String]
							==
							[Const:String] "binary"
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Const:String] ""
										+
										[Local varName(24959):String:String]
									+
									[Const:String] "::binary"
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Local type(24961):String:String]
									==
									[Const:String] "utf8"
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Binop:String]
											[Binop:String]
												[Const:String] ""
												+
												[Local varName(24959):String:String]
											+
											[Const:String] "::utf8"
								[Else:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Local type(24961):String:String]
											==
											[Const:String] "float"
										[Then:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local varName(24959):String:String]
													+
													[Const:String] "::float"
										[Else:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] ""
															+
															[Local varName(24959):String:String]
														+
														[Const:String] "::"
													+
													[Local typeSpec(24967):String:String]

	function compileBinarySegmentFromArg[Function:(arg : Dynamic) -> String]
		[Arg:Dynamic] [Local arg(24972):Dynamic]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local arg(24972):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "_::8"
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local arg(24972):Dynamic:Dynamic]
						[FDynamic:Dynamic] segmentSpec
					!=
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(segment : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(segment : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									compileBinarySegment:(segment : Dynamic) -> String
							[Field:Dynamic]
								[Local arg(24972):Dynamic:Dynamic]
								[FDynamic:Dynamic] segmentSpec
			[Var pattern(24973):String]
				[Call:String]
					[Field:(patternExpr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(patternExpr : Dynamic) -> String]
							reflaxe.elixir.helpers.PatternMatcher
							compilePattern:(patternExpr : Dynamic) -> String
					[Local arg(24972):Dynamic:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local pattern(24973):String:String]
					==
					[Const:String] "_"
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "_::8"
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Local pattern(24973):String:String]
							+
							[Const:String] "::8"

	function isPinPattern[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24995):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24995):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local expr(24995):Dynamic:Dynamic]
						[FDynamic:Dynamic] isPin
					==
					[Const:Bool] true
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local expr(24995):Dynamic:Dynamic]
						[FDynamic:Dynamic] pinned
					==
					[Const:Bool] true
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24995):Dynamic:Dynamic]
					==
					[Const:String] "TLocal"
				[Then:Void] [Block:Void]
					[Var local(24996):{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }]
						[Field:Dynamic]
							[Local expr(24995):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Field:Null<{ name : Null<{ charAt : Int -> String }> }>]
									[Local local(24996):{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }:{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }]
									[FAnon:Null<{ name : Null<{ charAt : Int -> String }> }>] v:Null<{ name : Null<{ charAt : Int -> String }> }>
								!=
								[Const:Null<{ name : Null<{ charAt : Int -> String }> }>] null
							&&
							[Binop:Bool]
								[Field:Null<{ charAt : Int -> String }>]
									[Field:Null<{ name : Null<{ charAt : Int -> String }> }>]
										[Local local(24996):{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }:{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }]
										[FAnon:Null<{ name : Null<{ charAt : Int -> String }> }>] v:Null<{ name : Null<{ charAt : Int -> String }> }>
									[FAnon:Null<{ charAt : Int -> String }>] name:Null<{ charAt : Int -> String }>
								!=
								[Const:Null<{ charAt : Int -> String }>] null
						[Then:Dynamic] [Block:Dynamic]
							[Var name(24997):Null<{ charAt : Int -> String }>]
								[Field:Null<{ charAt : Int -> String }>]
									[Field:Null<{ name : Null<{ charAt : Int -> String }> }>]
										[Local local(24996):{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }:{ v : Null<{ name : Null<{ charAt : Int -> String }> }> }]
										[FAnon:Null<{ name : Null<{ charAt : Int -> String }> }>] v:Null<{ name : Null<{ charAt : Int -> String }> }>
									[FAnon:Null<{ charAt : Int -> String }>] name:Null<{ charAt : Int -> String }>
							[Return:Dynamic]
								[Binop:Bool]
									[Call:String]
										[Field:Int -> String]
											[Local name(24997):Null<{ charAt : Int -> String }>:Null<{ charAt : Int -> String }>]
											[FAnon:Int -> String] charAt:Int -> String
										[Const:Int] 0
									==
									[Const:String] "^"
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24995):Dynamic:Dynamic]
					==
					[Const:String] "TUnop"
				[Then:Void] [Block:Void]
					[Var unop(24998):{ prefix : Bool, op : String }]
						[Field:Dynamic]
							[Local expr(24995):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Field:String]
									[Local unop(24998):{ prefix : Bool, op : String }:{ prefix : Bool, op : String }]
									[FAnon:String] op:String
								==
								[Const:String] "OpNeg"
							&&
							[Binop:Bool]
								[Field:Bool]
									[Local unop(24998):{ prefix : Bool, op : String }:{ prefix : Bool, op : String }]
									[FAnon:Bool] prefix:Bool
								==
								[Const:Bool] true
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24995):Dynamic:Dynamic]
					==
					[Const:String] "TField"
				[Then:Void] [Block:Void]
					[Var field(24999):{ e : Null<Unknown<68>> }]
						[Field:Dynamic]
							[Local expr(24995):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Null<Unknown<68>>]
								[Local field(24999):{ e : Null<Unknown<68>> }:{ e : Null<Unknown<68>> }]
								[FAnon:Null<Unknown<68>>] e:Null<Unknown<68>>
							!=
							[Const:Null<Unknown<68>>] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Call:Bool]
									[Field:(expr : Dynamic) -> Bool]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(expr : Dynamic) -> Bool]
											reflaxe.elixir.helpers.PatternMatcher
											isPinPattern:(expr : Dynamic) -> Bool
									[Field:Null<Unknown<68>>]
										[Local field(24999):{ e : Null<Unknown<68>> }:{ e : Null<Unknown<68>> }]
										[FAnon:Null<Unknown<68>>] e:Null<Unknown<68>>
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local expr(24995):Dynamic:Dynamic]
					==
					[Const:String] "TArray"
				[Then:Void] [Block:Void]
					[Var arrayAccess(25000):{ e1 : Null<Unknown<69>> }]
						[Field:Dynamic]
							[Local expr(24995):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Null<Unknown<69>>]
								[Local arrayAccess(25000):{ e1 : Null<Unknown<69>> }:{ e1 : Null<Unknown<69>> }]
								[FAnon:Null<Unknown<69>>] e1:Null<Unknown<69>>
							!=
							[Const:Null<Unknown<69>>] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Call:Bool]
									[Field:(expr : Dynamic) -> Bool]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(expr : Dynamic) -> Bool]
											reflaxe.elixir.helpers.PatternMatcher
											isPinPattern:(expr : Dynamic) -> Bool
									[Field:Null<Unknown<69>>]
										[Local arrayAccess(25000):{ e1 : Null<Unknown<69>> }:{ e1 : Null<Unknown<69>> }]
										[FAnon:Null<Unknown<69>>] e1:Null<Unknown<69>>
			[Return:Dynamic] [Const:Bool] false

	function compilePinPattern[Function:(patternExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local patternExpr(25001):Dynamic]
		[Block:Void]
			[Var varName(25002):String] [Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local patternExpr(25001):Dynamic:Dynamic]
					==
					[Const:String] "TLocal"
				[Then:Void] [Block:Void]
					[Var local(25003):{ v : Null<{ name : Null<String> }> }]
						[Field:Dynamic]
							[Local patternExpr(25001):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Field:Null<{ name : Null<String> }>]
									[Local local(25003):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
									[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
								!=
								[Const:Null<{ name : Null<String> }>] null
							&&
							[Binop:Bool]
								[Field:Null<String>]
									[Field:Null<{ name : Null<String> }>]
										[Local local(25003):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
										[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
									[FAnon:Null<String>] name:Null<String>
								!=
								[Const:Null<String>] null
						[Then:Void] [Block:Void]
							[Binop:String]
								[Local varName(25002):String:String]
								=
								[Call:String]
									[Field:(camelCase : String) -> String]
										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
										[FStatic:(camelCase : String) -> String]
											reflaxe.elixir.helpers.NamingHelper
											toSnakeCase:(camelCase : String) -> String
									[Field:Null<String>]
										[Field:Null<{ name : Null<String> }>]
											[Local local(25003):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
											[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
										[FAnon:Null<String>] name:Null<String>
							[If:Void]
								[Binop:Bool]
									[Call:String]
										[Field:(index : Int) -> String]
											[Local varName(25002):String:String]
											[FInstance:(index : Int) -> String]
												String
												charAt:(index : Int) -> String
										[Const:Int] 0
									==
									[Const:String] "^"
								[Then:String] [Block:String]
									[Binop:String]
										[Local varName(25002):String:String]
										=
										[Call:String]
											[Field:(pos : Int, ?len : Null<Int>) -> String]
												[Local varName(25002):String:String]
												[FInstance:(pos : Int, ?len : Null<Int>) -> String]
													String
													substr:(pos : Int, ?len : Null<Int>) -> String
											[Const:Int] 1
											[Const:Null<Int>] null
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.PatternMatcher] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.PatternMatcher
										getExprType:(expr : Dynamic) -> String
								[Local patternExpr(25001):Dynamic:Dynamic]
							==
							[Const:String] "TUnop"
						[Then:Void] [Block:Void]
							[Var unop(25004):{ e : Null<Unknown<73>> }]
								[Field:Dynamic]
									[Local patternExpr(25001):Dynamic:Dynamic]
									[FDynamic:Dynamic] expr
							[If:Void]
								[Binop:Bool]
									[Field:Null<Unknown<73>>]
										[Local unop(25004):{ e : Null<Unknown<73>> }:{ e : Null<Unknown<73>> }]
										[FAnon:Null<Unknown<73>>] e:Null<Unknown<73>>
									!=
									[Const:Null<Unknown<73>>] null
								[Then:Void] [Block:Void]
									[Var innerPattern(25005):String]
										[Call:String]
											[Field:(patternExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(patternExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.PatternMatcher
													compilePattern:(patternExpr : Dynamic) -> String
											[Field:Null<Unknown<73>>]
												[Local unop(25004):{ e : Null<Unknown<73>> }:{ e : Null<Unknown<73>> }]
												[FAnon:Null<Unknown<73>>] e:Null<Unknown<73>>
									[If:Void]
										[Binop:Bool]
											[Call:String]
												[Field:(index : Int) -> String]
													[Local innerPattern(25005):String:String]
													[FInstance:(index : Int) -> String]
														String
														charAt:(index : Int) -> String
												[Const:Int] 0
											==
											[Const:String] "^"
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local innerPattern(25005):String:String]
										[Else:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Binop:String]
													[Const:String] "^"
													+
													[Local innerPattern(25005):String:String]
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.PatternMatcher] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.PatternMatcher
												getExprType:(expr : Dynamic) -> String
										[Local patternExpr(25001):Dynamic:Dynamic]
									==
									[Const:String] "TField"
								[Then:Void] [Block:Void]
									[Var field(25006):{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }]
										[Field:Dynamic]
											[Local patternExpr(25001):Dynamic:Dynamic]
											[FDynamic:Dynamic] expr
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Field:Null<Unknown<72>>]
													[Local field(25006):{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }]
													[FAnon:Null<Unknown<72>>] e:Null<Unknown<72>>
												!=
												[Const:Null<Unknown<72>>] null
											&&
											[Binop:Bool]
												[Field:Null<{ name : String }>]
													[Local field(25006):{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }]
													[FAnon:Null<{ name : String }>] fa:Null<{ name : String }>
												!=
												[Const:Null<{ name : String }>] null
										[Then:Void] [Block:Void]
											[Var baseExpr(25007):String]
												[Call:String]
													[Field:(patternExpr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(patternExpr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compilePattern:(patternExpr : Dynamic) -> String
													[Field:Null<Unknown<72>>]
														[Local field(25006):{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }]
														[FAnon:Null<Unknown<72>>] e:Null<Unknown<72>>
											[Var fieldName(25008):String]
												[Call:String]
													[Field:(camelCase : String) -> String]
														[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
														[FStatic:(camelCase : String) -> String]
															reflaxe.elixir.helpers.NamingHelper
															toSnakeCase:(camelCase : String) -> String
													[Field:String]
														[Field:Null<{ name : String }>]
															[Local field(25006):{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<72>> }]
															[FAnon:Null<{ name : String }>] fa:Null<{ name : String }>
														[FAnon:String] name:String
											[If:Void]
												[Binop:Bool]
													[Call:String]
														[Field:(index : Int) -> String]
															[Local baseExpr(25007):String:String]
															[FInstance:(index : Int) -> String]
																String
																charAt:(index : Int) -> String
														[Const:Int] 0
													==
													[Const:String] "^"
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] ""
																	+
																	[Local baseExpr(25007):String:String]
																+
																[Const:String] "."
															+
															[Local fieldName(25008):String:String]
												[Else:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] "^"
																	+
																	[Local baseExpr(25007):String:String]
																+
																[Const:String] "."
															+
															[Local fieldName(25008):String:String]
								[Else:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Call:String]
												[Field:(expr : Dynamic) -> String]
													[Const:reflaxe.elixir.helpers.PatternMatcher] this
													[FInstance:(expr : Dynamic) -> String]
														reflaxe.elixir.helpers.PatternMatcher
														getExprType:(expr : Dynamic) -> String
												[Local patternExpr(25001):Dynamic:Dynamic]
											==
											[Const:String] "TArray"
										[Then:Void] [Block:Void]
											[Var arrayAccess(25009):{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }]
												[Field:Dynamic]
													[Local patternExpr(25001):Dynamic:Dynamic]
													[FDynamic:Dynamic] expr
											[If:Void]
												[Binop:Bool]
													[Binop:Bool]
														[Field:Null<Unknown<70>>]
															[Local arrayAccess(25009):{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }:{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }]
															[FAnon:Null<Unknown<70>>] e1:Null<Unknown<70>>
														!=
														[Const:Null<Unknown<70>>] null
													&&
													[Binop:Bool]
														[Field:Null<Unknown<71>>]
															[Local arrayAccess(25009):{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }:{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }]
															[FAnon:Null<Unknown<71>>] e2:Null<Unknown<71>>
														!=
														[Const:Null<Unknown<71>>] null
												[Then:Dynamic] [Block:Dynamic]
													[Var arrayExpr(25010):String]
														[Call:String]
															[Field:(patternExpr : Dynamic) -> String]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:(patternExpr : Dynamic) -> String]
																	reflaxe.elixir.helpers.PatternMatcher
																	compilePattern:(patternExpr : Dynamic) -> String
															[Field:Null<Unknown<70>>]
																[Local arrayAccess(25009):{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }:{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }]
																[FAnon:Null<Unknown<70>>] e1:Null<Unknown<70>>
													[Var indexExpr(25011):String]
														[Call:String]
															[Field:(expr : Dynamic) -> String]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:(expr : Dynamic) -> String]
																	reflaxe.elixir.helpers.PatternMatcher
																	compileExpression:(expr : Dynamic) -> String
															[Field:Null<Unknown<71>>]
																[Local arrayAccess(25009):{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }:{ e2 : Null<Unknown<71>>, e1 : Null<Unknown<70>> }]
																[FAnon:Null<Unknown<71>>] e2:Null<Unknown<71>>
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "^"
																		+
																		[Local arrayExpr(25010):String:String]
																	+
																	[Const:String] "["
																+
																[Local indexExpr(25011):String:String]
															+
															[Const:String] "]"
										[Else:Void] [Block:Void]
											[Var pattern(25012):String]
												[Call:String]
													[Field:(patternExpr : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(patternExpr : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															compilePattern:(patternExpr : Dynamic) -> String
													[Local patternExpr(25001):Dynamic:Dynamic]
											[If:Void]
												[Binop:Bool]
													[Binop:Bool]
														[Local pattern(25012):String:String]
														!=
														[Const:String] "_"
													&&
													[Binop:Bool]
														[Call:String]
															[Field:(index : Int) -> String]
																[Local pattern(25012):String:String]
																[FInstance:(index : Int) -> String]
																	String
																	charAt:(index : Int) -> String
															[Const:Int] 0
														!=
														[Const:String] "^"
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Binop:String]
															[Const:String] "^"
															+
															[Local pattern(25012):String:String]
												[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local pattern(25012):String:String]
			[If:Void]
				[Binop:Bool]
					[Local varName(25002):String:String]
					!=
					[Const:String] ""
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Const:String] "^"
							+
							[Local varName(25002):String:String]
				[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "^_"

	@:value(null)
	var compiler:Null<reflaxe.elixir.ElixirCompiler>;

	public function setCompiler[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(25147):reflaxe.elixir.ElixirCompiler]
		[Block:Null<reflaxe.elixir.ElixirCompiler>]
			[Binop:Null<reflaxe.elixir.ElixirCompiler>]
				[Field:Null<reflaxe.elixir.ElixirCompiler>]
					[Const:reflaxe.elixir.helpers.PatternMatcher] this
					[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
						reflaxe.elixir.helpers.PatternMatcher
						compiler:Null<reflaxe.elixir.ElixirCompiler>
				=
				[Local compiler(25147):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	function compileExpression[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24940):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24940):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "nil"
			[If:Void]
				[Binop:Bool]
					[Field:Null<reflaxe.elixir.ElixirCompiler>]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
							reflaxe.elixir.helpers.PatternMatcher
							compiler:Null<reflaxe.elixir.ElixirCompiler>
					!=
					[Const:Null<reflaxe.elixir.ElixirCompiler>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var result(24941):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:Null<reflaxe.elixir.ElixirCompiler>]
									[Const:reflaxe.elixir.helpers.PatternMatcher] this
									[FInstance:Null<reflaxe.elixir.ElixirCompiler>]
										reflaxe.elixir.helpers.PatternMatcher
										compiler:Null<reflaxe.elixir.ElixirCompiler>
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local expr(24940):Dynamic:Dynamic]
							[Const:Null<Bool>] null
					[Return:Dynamic]
						[If:String]
							[Binop:Bool]
								[Local result(24941):Null<String>:Null<String>]
								!=
								[Const:Null<String>] null
							[Then:Null<String>] [Block:Null<String>] [Local result(24941):Null<String>:Null<String>]
							[Else:String] [Block:String] [Const:String] "nil"
			[Return:Dynamic] [Const:String] "expr"

	function indentExpression[Function:(expr : String) -> String]
		[Arg:String] [Local expr(25120):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(25120):String:String]
					==
					[Const:String] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Return:Dynamic]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var _this(25123):Array<String>]
								[Call:Array<String>]
									[Field:(delimiter : String) -> Array<String>]
										[Local expr(25120):String:String]
										[FInstance:(delimiter : String) -> Array<String>]
											String
											split:(delimiter : String) -> Array<String>
									[Const:String] "\n"
							[Block:Array<String>]
								[Var `(25125):Array<String>] [ArrayDecl:Array<String>]
								[Block:Void]
									[Var `(25126):Int] [Const:Int] 0
									[Var `(25127):Array<String>] [Local _this(25123):Array<String>:Array<String>]
									[While:Void]
										[Binop:Bool]
											[Local `(25126):Int:Int]
											<
											[Field:Int]
												[Local `(25127):Array<String>:Array<String>]
												[FInstance:Int]
													Array<String>
													length:Int
										[Block:Void]
											[Var v(25128):String]
												[Array:String]
													[Local `(25127):Array<String>:Array<String>]
													[Local `(25126):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25126):Int:Int]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local `(25125):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Call:String]
													[Function:(line : String) -> String]
														[Arg:String] [Local line(25129):String]
														[Block:Dynamic]
															[Return:Dynamic]
																[If:String]
																	[Parenthesis:Bool]
																		[Binop:Bool]
																			[Field:Int]
																				[Local line(25129):String:String]
																				[FInstance:Int]
																					String
																					length:Int
																			>
																			[Const:Int] 0
																	[Then:String] [Local line(25129):String:String]
																	[Else:String] [Const:String] ""
													[Local v(25128):String:String]
								[Local `(25125):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] "\n    "

	@:value({ defaultExpr : null })
	public function validatePatternExhaustiveness[Function:(switchExpr : Dynamic, cases : Array<Dynamic>, ?defaultExpr : Null<Dynamic>) -> Array<String>]
		[Arg:Dynamic] [Local switchExpr(25148):Dynamic]
		[Arg:Array<Dynamic>] [Local cases(25149):Array<Dynamic>]
		[Arg:Null<Dynamic>]
			[Local defaultExpr(25150):Null<Dynamic>]
			[Const:Null<Dynamic>] null
		[Block:Dynamic]
			[Var warnings(25151):Array<String>] [ArrayDecl:Array<String>]
			[Var switchType(25153):Null<{ name : String }>]
				[Call:Dynamic]
					[Field:(expr : Dynamic) -> Dynamic]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(expr : Dynamic) -> Dynamic]
							reflaxe.elixir.helpers.PatternMatcher
							getSwitchExpressionType:(expr : Dynamic) -> Dynamic
					[Local switchExpr(25148):Dynamic:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local switchType(25153):Null<{ name : String }>:Null<{ name : String }>]
					==
					[Const:Null<{ name : String }>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local warnings(25151):Array<String>:Array<String>]
			[Return:Dynamic]
				[Meta:Array<String>]
					:ast(switch (switchType.name) {
	case "Bool":
		validateBooleanExhaustiveness(cases, defaultExpr, warnings);	
	case "Enum":
		validateEnumExhaustiveness(switchType, cases, defaultExpr, warnings);	
	case "Int":
		validateIntegerExhaustiveness(cases, defaultExpr, warnings);	
	case "String":
		validateStringExhaustiveness(cases, defaultExpr, warnings);	
	case "Array":
		validateArrayExhaustiveness(cases, defaultExpr, warnings);	
	case _:
		if (defaultExpr == null && !hasWildcardCase(cases)) {
			warnings.push("Non-exhaustive pattern match for type ${switchType.name}: missing default case");
		};
		warnings;	
})
					[Block:Array<String>]
						[Var `(25241):String]
							[Field:String]
								[Local switchType(25153):Null<{ name : String }>:Null<{ name : String }>]
								[FAnon:String] name:String
						[Switch:Array<String>]
							[Local `(25241):String:String]
							[Case:Array<String>]
								[Const:String] "Array"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.PatternMatcher
													validateArrayExhaustiveness:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
											[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
											[Local warnings(25151):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "Bool"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.PatternMatcher
													validateBooleanExhaustiveness:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
											[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
											[Local warnings(25151):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "Enum"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(enumType : Dynamic, cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(enumType : Dynamic, cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.PatternMatcher
													validateEnumExhaustiveness:(enumType : Dynamic, cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local switchType(25153):Null<{ name : String }>:Null<{ name : String }>]
											[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
											[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
											[Local warnings(25151):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "Int"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.PatternMatcher
													validateIntegerExhaustiveness:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
											[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
											[Local warnings(25151):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "String"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.PatternMatcher] this
												[FInstance:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.PatternMatcher
													validateStringExhaustiveness:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
											[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
											[Local warnings(25151):Array<String>:Array<String>]
							[Default:Array<String>]
								[Block:Array<String>]
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Local defaultExpr(25150):Null<Dynamic>:Null<Dynamic>]
												==
												[Const:Null<Dynamic>] null
											&&
											[Unop:Bool]
												!
												Prefix
												[Call:Bool]
													[Field:(cases : Array<Dynamic>) -> Bool]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(cases : Array<Dynamic>) -> Bool]
															reflaxe.elixir.helpers.PatternMatcher
															hasWildcardCase:(cases : Array<Dynamic>) -> Bool
													[Local cases(25149):Array<Dynamic>:Array<Dynamic>]
										[Then:Int] [Block:Int]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local warnings(25151):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Binop:String]
													[Binop:String]
														[Const:String] "Non-exhaustive pattern match for type "
														+
														[Field:String]
															[Local switchType(25153):Null<{ name : String }>:Null<{ name : String }>]
															[FAnon:String] name:String
													+
													[Const:String] ": missing default case"
									[Local warnings(25151):Array<String>:Array<String>]

	function validateBooleanExhaustiveness[Function:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Array<Dynamic>] [Local cases(25154):Array<Dynamic>]
		[Arg:Dynamic] [Local defaultExpr(25155):Dynamic]
		[Arg:Array<String>] [Local warnings(25156):Array<String>]
		[Block:Dynamic]
			[Var hasTrueCase(25157):Bool] [Const:Bool] false
			[Var hasFalseCase(25158):Bool] [Const:Bool] false
			[Var hasWildcard(25168):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasWildcardCase:(cases : Array<Dynamic>) -> Bool
					[Local cases(25154):Array<Dynamic>:Array<Dynamic>]
			[Block:Void]
				[Var `(25178):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25178):Int:Int]
						<
						[Field:Int]
							[Local cases(25154):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(25169):Dynamic]
							[Array:Dynamic]
								[Local cases(25154):Array<Dynamic>:Array<Dynamic>]
								[Local `(25178):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25178):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(25169):Dynamic:Dynamic]
									[FDynamic:Dynamic] values
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Block:Void]
									[Var `(25176):Int] [Const:Int] 0
									[Var `(25177):Array<Dynamic>]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Dynamic]
													[Local caseItem(25169):Dynamic:Dynamic]
													[FDynamic:Dynamic] values
									[While:Void]
										[Binop:Bool]
											[Local `(25176):Int:Int]
											<
											[Field:Int]
												[Local `(25177):Array<Dynamic>:Array<Dynamic>]
												[FInstance:Int]
													Array<Dynamic>
													length:Int
										[Block:Void]
											[Var value(25170):Dynamic]
												[Array:Dynamic]
													[Local `(25177):Array<Dynamic>:Array<Dynamic>]
													[Local `(25176):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25176):Int:Int]
											[If:Void]
												[Call:Bool]
													[Field:(value : Dynamic, expected : Bool) -> Bool]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(value : Dynamic, expected : Bool) -> Bool]
															reflaxe.elixir.helpers.PatternMatcher
															isBooleanConstant:(value : Dynamic, expected : Bool) -> Bool
													[Local value(25170):Dynamic:Dynamic]
													[Const:Bool] true
												[Then:Bool] [Block:Bool]
													[Binop:Bool]
														[Local hasTrueCase(25157):Bool:Bool]
														=
														[Const:Bool] true
											[If:Void]
												[Call:Bool]
													[Field:(value : Dynamic, expected : Bool) -> Bool]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(value : Dynamic, expected : Bool) -> Bool]
															reflaxe.elixir.helpers.PatternMatcher
															isBooleanConstant:(value : Dynamic, expected : Bool) -> Bool
													[Local value(25170):Dynamic:Dynamic]
													[Const:Bool] false
												[Then:Bool] [Block:Bool]
													[Binop:Bool]
														[Local hasFalseCase(25158):Bool:Bool]
														=
														[Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local defaultExpr(25155):Dynamic:Dynamic]
						==
						[Const:Dynamic] null
					&&
					[Unop:Bool]
						!
						Prefix
						[Local hasWildcard(25168):Bool:Bool]
				[Then:Void] [Block:Void]
					[If:Void]
						[Unop:Bool]
							!
							Prefix
							[Local hasTrueCase(25157):Bool:Bool]
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local warnings(25156):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Non-exhaustive boolean pattern: missing case for 'true'"
					[If:Void]
						[Unop:Bool]
							!
							Prefix
							[Local hasFalseCase(25158):Bool:Bool]
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local warnings(25156):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "Non-exhaustive boolean pattern: missing case for 'false'"
			[Return:Dynamic] [Local warnings(25156):Array<String>:Array<String>]

	function validateEnumExhaustiveness[Function:(enumType : Dynamic, cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local enumType(25179):Dynamic]
		[Arg:Array<Dynamic>] [Local cases(25180):Array<Dynamic>]
		[Arg:Dynamic] [Local defaultExpr(25181):Dynamic]
		[Arg:Array<String>] [Local warnings(25182):Array<String>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local enumType(25179):Dynamic:Dynamic]
						[FDynamic:Dynamic] constructors
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local warnings(25182):Array<String>:Array<String>]
			[Var coveredConstructors(25183):haxe.ds.Map<String, Bool>]
				[Block:haxe.ds.StringMap<Bool>]
					[Block:Void]
					[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Var hasWildcard(25184):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasWildcardCase:(cases : Array<Dynamic>) -> Bool
					[Local cases(25180):Array<Dynamic>:Array<Dynamic>]
			[Block:Void]
				[Var `(25196):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25196):Int:Int]
						<
						[Field:Int]
							[Local cases(25180):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(25185):Dynamic]
							[Array:Dynamic]
								[Local cases(25180):Array<Dynamic>:Array<Dynamic>]
								[Local `(25196):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25196):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(25185):Dynamic:Dynamic]
									[FDynamic:Dynamic] values
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Block:Void]
									[Var `(25194):Int] [Const:Int] 0
									[Var `(25195):Array<Dynamic>]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Dynamic]
													[Local caseItem(25185):Dynamic:Dynamic]
													[FDynamic:Dynamic] values
									[While:Void]
										[Binop:Bool]
											[Local `(25194):Int:Int]
											<
											[Field:Int]
												[Local `(25195):Array<Dynamic>:Array<Dynamic>]
												[FInstance:Int]
													Array<Dynamic>
													length:Int
										[Block:Void]
											[Var value(25186):Dynamic]
												[Array:Dynamic]
													[Local `(25195):Array<Dynamic>:Array<Dynamic>]
													[Local `(25194):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25194):Int:Int]
											[Var constructorName(25188):String]
												[Call:String]
													[Field:(value : Dynamic) -> String]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(value : Dynamic) -> String]
															reflaxe.elixir.helpers.PatternMatcher
															getEnumConstructorName:(value : Dynamic) -> String
													[Local value(25186):Dynamic:Dynamic]
											[If:Void]
												[Binop:Bool]
													[Local constructorName(25188):String:String]
													!=
													[Const:String] null
												[Then:Void] [Block:Void]
													[Block:Void]
														[Call:Void]
															[Field:(key : String, value : Bool) -> Void]
																[Local coveredConstructors(25183):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
																[FInstance:(key : String, value : Bool) -> Void]
																	haxe.ds.StringMap<Bool>
																	set:(key : String, value : haxe.ds.StringMap.T) -> Void
															[Local constructorName(25188):String:String]
															[Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local defaultExpr(25181):Dynamic:Dynamic]
						==
						[Const:Dynamic] null
					&&
					[Unop:Bool]
						!
						Prefix
						[Local hasWildcard(25184):Bool:Bool]
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(25203):Int] [Const:Int] 0
						[Var `(25204):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Dynamic]
										[Local enumType(25179):Dynamic:Dynamic]
										[FDynamic:Dynamic] constructors
						[While:Void]
							[Binop:Bool]
								[Local `(25203):Int:Int]
								<
								[Field:Int]
									[Local `(25204):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var constructor(25197):Dynamic]
									[Array:Dynamic]
										[Local `(25204):Array<Dynamic>:Array<Dynamic>]
										[Local `(25203):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(25203):Int:Int]
								[Var constructorName(25198):String]
									[Field:Dynamic]
										[Local constructor(25197):Dynamic:Dynamic]
										[FDynamic:Dynamic] name
								[If:Void]
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(key : String) -> Bool]
												[Local coveredConstructors(25183):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
												[FInstance:(key : String) -> Bool]
													haxe.ds.StringMap<Bool>
													exists:(key : String) -> Bool
											[Local constructorName(25198):String:String]
									[Then:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local warnings(25182):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Const:String] "Non-exhaustive enum pattern: missing case for constructor \""
													+
													[Local constructorName(25198):String:String]
												+
												[Const:String] "\""
			[Return:Dynamic] [Local warnings(25182):Array<String>:Array<String>]

	function validateIntegerExhaustiveness[Function:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Array<Dynamic>] [Local cases(25205):Array<Dynamic>]
		[Arg:Dynamic] [Local defaultExpr(25206):Dynamic]
		[Arg:Array<String>] [Local warnings(25207):Array<String>]
		[Block:Dynamic]
			[Var hasWildcard(25208):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasWildcardCase:(cases : Array<Dynamic>) -> Bool
					[Local cases(25205):Array<Dynamic>:Array<Dynamic>]
			[Var hasGuardCases(25212):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasGuardCases:(cases : Array<Dynamic>) -> Bool
					[Local cases(25205):Array<Dynamic>:Array<Dynamic>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Local defaultExpr(25206):Dynamic:Dynamic]
							==
							[Const:Dynamic] null
						&&
						[Unop:Bool]
							!
							Prefix
							[Local hasWildcard(25208):Bool:Bool]
					&&
					[Unop:Bool]
						!
						Prefix
						[Call:Bool]
							[Field:(cases : Array<Dynamic>) -> Bool]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(cases : Array<Dynamic>) -> Bool]
									reflaxe.elixir.helpers.PatternMatcher
									hasCompleteGuardCoverage:(cases : Array<Dynamic>) -> Bool
							[Local cases(25205):Array<Dynamic>:Array<Dynamic>]
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(25207):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Non-exhaustive integer pattern: infinite possible values require default case or complete guard coverage"
			[Return:Dynamic] [Local warnings(25207):Array<String>:Array<String>]

	function validateStringExhaustiveness[Function:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Array<Dynamic>] [Local cases(25214):Array<Dynamic>]
		[Arg:Dynamic] [Local defaultExpr(25215):Dynamic]
		[Arg:Array<String>] [Local warnings(25216):Array<String>]
		[Block:Dynamic]
			[Var hasWildcard(25217):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasWildcardCase:(cases : Array<Dynamic>) -> Bool
					[Local cases(25214):Array<Dynamic>:Array<Dynamic>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local defaultExpr(25215):Dynamic:Dynamic]
						==
						[Const:Dynamic] null
					&&
					[Unop:Bool]
						!
						Prefix
						[Local hasWildcard(25217):Bool:Bool]
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(25216):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Non-exhaustive string pattern: infinite possible values require default case"
			[Return:Dynamic] [Local warnings(25216):Array<String>:Array<String>]

	function validateArrayExhaustiveness[Function:(cases : Array<Dynamic>, defaultExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Array<Dynamic>] [Local cases(25218):Array<Dynamic>]
		[Arg:Dynamic] [Local defaultExpr(25219):Dynamic]
		[Arg:Array<String>] [Local warnings(25220):Array<String>]
		[Block:Dynamic]
			[Var hasWildcard(25221):Bool]
				[Call:Bool]
					[Field:(cases : Array<Dynamic>) -> Bool]
						[Const:reflaxe.elixir.helpers.PatternMatcher] this
						[FInstance:(cases : Array<Dynamic>) -> Bool]
							reflaxe.elixir.helpers.PatternMatcher
							hasWildcardCase:(cases : Array<Dynamic>) -> Bool
					[Local cases(25218):Array<Dynamic>:Array<Dynamic>]
			[Var hasEmptyCase(25222):Bool] [Const:Bool] false
			[Var maxFixedLength(25223):Int] [Const:Int] 0
			[Var hasVariableLength(25224):Bool] [Const:Bool] false
			[Block:Void]
				[Var `(25239):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25239):Int:Int]
						<
						[Field:Int]
							[Local cases(25218):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(25225):Dynamic]
							[Array:Dynamic]
								[Local cases(25218):Array<Dynamic>:Array<Dynamic>]
								[Local `(25239):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25239):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(25225):Dynamic:Dynamic]
									[FDynamic:Dynamic] values
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Block:Void]
									[Var `(25237):Int] [Const:Int] 0
									[Var `(25238):Array<Dynamic>]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Dynamic]
													[Local caseItem(25225):Dynamic:Dynamic]
													[FDynamic:Dynamic] values
									[While:Void]
										[Binop:Bool]
											[Local `(25237):Int:Int]
											<
											[Field:Int]
												[Local `(25238):Array<Dynamic>:Array<Dynamic>]
												[FInstance:Int]
													Array<Dynamic>
													length:Int
										[Block:Void]
											[Var value(25226):Dynamic]
												[Array:Dynamic]
													[Local `(25238):Array<Dynamic>:Array<Dynamic>]
													[Local `(25237):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25237):Int:Int]
											[If:Void]
												[Call:Bool]
													[Field:(value : Dynamic) -> Bool]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(value : Dynamic) -> Bool]
															reflaxe.elixir.helpers.PatternMatcher
															isEmptyArrayPattern:(value : Dynamic) -> Bool
													[Local value(25226):Dynamic:Dynamic]
												[Then:Bool] [Block:Bool]
													[Binop:Bool]
														[Local hasEmptyCase(25222):Bool:Bool]
														=
														[Const:Bool] true
												[Else:Void] [Block:Void]
													[Var length(25231):Int]
														[Call:Int]
															[Field:(value : Dynamic) -> Int]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:(value : Dynamic) -> Int]
																	reflaxe.elixir.helpers.PatternMatcher
																	getArrayPatternLength:(value : Dynamic) -> Int
															[Local value(25226):Dynamic:Dynamic]
													[If:Void]
														[Binop:Bool]
															[Local length(25231):Int:Int]
															>
															[Local maxFixedLength(25223):Int:Int]
														[Then:Int] [Block:Int]
															[Binop:Int]
																[Local maxFixedLength(25223):Int:Int]
																=
																[Local length(25231):Int:Int]
													[If:Void]
														[Call:Bool]
															[Field:(value : Dynamic) -> Bool]
																[Const:reflaxe.elixir.helpers.PatternMatcher] this
																[FInstance:(value : Dynamic) -> Bool]
																	reflaxe.elixir.helpers.PatternMatcher
																	hasRestPattern:(value : Dynamic) -> Bool
															[Local value(25226):Dynamic:Dynamic]
														[Then:Bool] [Block:Bool]
															[Binop:Bool]
																[Local hasVariableLength(25224):Bool:Bool]
																=
																[Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Local defaultExpr(25219):Dynamic:Dynamic]
							==
							[Const:Dynamic] null
						&&
						[Unop:Bool]
							!
							Prefix
							[Local hasWildcard(25221):Bool:Bool]
					&&
					[Unop:Bool]
						!
						Prefix
						[Local hasVariableLength(25224):Bool:Bool]
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(25220):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Non-exhaustive array pattern: arrays can have any length, consider adding rest pattern or default case"
			[Return:Dynamic] [Local warnings(25220):Array<String>:Array<String>]

	function getSwitchExpressionType[Function:(expr : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local expr(25152):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[ObjectDecl:{ name : String, constructors : Null<Unknown<74>> }]
					name: [Const:String] "Dynamic"
					constructors: [Const:Null<Unknown<74>>] null

	function hasWildcardCase[Function:(cases : Array<Dynamic>) -> Bool]
		[Arg:Array<Dynamic>] [Local cases(25159):Array<Dynamic>]
		[Block:Dynamic]
			[Block:Void]
				[Var `(25167):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25167):Int:Int]
						<
						[Field:Int]
							[Local cases(25159):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(25160):Dynamic]
							[Array:Dynamic]
								[Local cases(25159):Array<Dynamic>:Array<Dynamic>]
								[Local `(25167):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25167):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(25160):Dynamic:Dynamic]
									[FDynamic:Dynamic] values
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Block:Void]
									[Var `(25165):Int] [Const:Int] 0
									[Var `(25166):Array<Dynamic>]
										[Parenthesis:Array<Dynamic>]
											[Cast:Array<Dynamic>]
												[Field:Dynamic]
													[Local caseItem(25160):Dynamic:Dynamic]
													[FDynamic:Dynamic] values
									[While:Void]
										[Binop:Bool]
											[Local `(25165):Int:Int]
											<
											[Field:Int]
												[Local `(25166):Array<Dynamic>:Array<Dynamic>]
												[FInstance:Int]
													Array<Dynamic>
													length:Int
										[Block:Void]
											[Var value(25161):Dynamic]
												[Array:Dynamic]
													[Local `(25166):Array<Dynamic>:Array<Dynamic>]
													[Local `(25165):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(25165):Int:Int]
											[If:Void]
												[Call:Bool]
													[Field:(value : Dynamic) -> Bool]
														[Const:reflaxe.elixir.helpers.PatternMatcher] this
														[FInstance:(value : Dynamic) -> Bool]
															reflaxe.elixir.helpers.PatternMatcher
															isWildcardPattern:(value : Dynamic) -> Bool
													[Local value(25161):Dynamic:Dynamic]
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	function hasGuardCases[Function:(cases : Array<Dynamic>) -> Bool]
		[Arg:Array<Dynamic>] [Local cases(25209):Array<Dynamic>]
		[Block:Dynamic]
			[Block:Void]
				[Var `(25211):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25211):Int:Int]
						<
						[Field:Int]
							[Local cases(25209):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var caseItem(25210):Dynamic]
							[Array:Dynamic]
								[Local cases(25209):Array<Dynamic>:Array<Dynamic>]
								[Local `(25211):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25211):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local caseItem(25210):Dynamic:Dynamic]
									[FDynamic:Dynamic] guard
								!=
								[Const:Dynamic] null
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	function hasCompleteGuardCoverage[Function:(cases : Array<Dynamic>) -> Bool]
		[Arg:Array<Dynamic>] [Local cases(25213):Array<Dynamic>]
		[Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function isWildcardPattern[Function:(value : Dynamic) -> Bool]
		[Arg:Dynamic] [Local value(25162):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									getExprType:(expr : Dynamic) -> String
							[Local value(25162):Dynamic:Dynamic]
						==
						[Const:String] "TWildcard"
					||
					[Parenthesis:Bool]
						[Binop:Bool]
							[Binop:Bool]
								[Call:String]
									[Field:(expr : Dynamic) -> String]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(expr : Dynamic) -> String]
											reflaxe.elixir.helpers.PatternMatcher
											getExprType:(expr : Dynamic) -> String
									[Local value(25162):Dynamic:Dynamic]
								==
								[Const:String] "TLocal"
							&&
							[Binop:Bool]
								[Call:String]
									[Field:(value : Dynamic) -> String]
										[Const:reflaxe.elixir.helpers.PatternMatcher] this
										[FInstance:(value : Dynamic) -> String]
											reflaxe.elixir.helpers.PatternMatcher
											getVariableName:(value : Dynamic) -> String
									[Local value(25162):Dynamic:Dynamic]
								==
								[Const:String] "_"

	function isBooleanConstant[Function:(value : Dynamic, expected : Bool) -> Bool]
		[Arg:Dynamic] [Local value(25171):Dynamic]
		[Arg:Bool] [Local expected(25172):Bool]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local value(25171):Dynamic:Dynamic]
					==
					[Const:String] "TConst"
				[Then:Void] [Block:Void]
					[Var constExpr(25173):haxe.macro.Constant]
						[Field:Dynamic]
							[Local value(25171):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[Meta:Void]
						:ast(switch (constExpr) {
	case CIdent("true"):
		return expected == true;	
	case CIdent("false"):
		return expected == false;	
	case _:
		return false;	
})
						[If:Void]
							[Binop:Bool]
								[EnumIndex:Int] [Local constExpr(25173):haxe.macro.Constant:haxe.macro.Constant]
								==
								[Const:Int] 3
							[Then:Void] [Block:Void]
								[Var `(25175):String]
									[EnumParameter:String]
										[Local constExpr(25173):haxe.macro.Constant:haxe.macro.Constant]
										CIdent
										0
								[Switch:Void]
									[Local `(25175):String:String]
									[Case:Dynamic]
										[Const:String] "false"
										[Block:Dynamic]
											[Block:Dynamic]
												[Return:Dynamic]
													[Binop:Bool]
														[Local expected(25172):Bool:Bool]
														==
														[Const:Bool] false
									[Case:Dynamic]
										[Const:String] "true"
										[Block:Dynamic]
											[Block:Dynamic]
												[Return:Dynamic]
													[Binop:Bool]
														[Local expected(25172):Bool:Bool]
														==
														[Const:Bool] true
									[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
							[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic] [Const:Bool] false

	function getEnumConstructorName[Function:(value : Dynamic) -> String]
		[Arg:Dynamic] [Local value(25187):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									getExprType:(expr : Dynamic) -> String
							[Local value(25187):Dynamic:Dynamic]
						==
						[Const:String] "TCall"
					||
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.PatternMatcher] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.PatternMatcher
									getExprType:(expr : Dynamic) -> String
							[Local value(25187):Dynamic:Dynamic]
						==
						[Const:String] "TField"
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "EnumConstructor"
			[Return:Dynamic] [Const:String] null

	function isEmptyArrayPattern[Function:(value : Dynamic) -> Bool]
		[Arg:Dynamic] [Local value(25227):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local value(25227):Dynamic:Dynamic]
					==
					[Const:String] "TArrayDecl"
				[Then:Dynamic] [Block:Dynamic]
					[Var arr(25228):{ el : Null<Array<Dynamic>> }]
						[Field:Dynamic]
							[Local value(25227):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[Return:Dynamic]
						[Binop:Bool]
							[Binop:Bool]
								[Field:Null<Array<Dynamic>>]
									[Local arr(25228):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
									[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
								==
								[Const:Null<Array<Dynamic>>] null
							||
							[Binop:Bool]
								[Field:Int]
									[Parenthesis:Array<Dynamic>]
										[Cast:Array<Dynamic>]
											[Field:Null<Array<Dynamic>>]
												[Local arr(25228):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
												[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
									[FInstance:Int]
										Array<Dynamic>
										length:Int
								==
								[Const:Int] 0
			[Return:Dynamic] [Const:Bool] false

	function getArrayPatternLength[Function:(value : Dynamic) -> Int]
		[Arg:Dynamic] [Local value(25229):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local value(25229):Dynamic:Dynamic]
					==
					[Const:String] "TArrayDecl"
				[Then:Void] [Block:Void]
					[Var arr(25230):{ el : Null<Array<Dynamic>> }]
						[Field:Dynamic]
							[Local value(25229):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Null<Array<Dynamic>>]
								[Local arr(25230):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
								[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
							!=
							[Const:Null<Array<Dynamic>>] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Field:Int]
									[Parenthesis:Array<Dynamic>]
										[Cast:Array<Dynamic>]
											[Field:Null<Array<Dynamic>>]
												[Local arr(25230):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
												[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
									[FInstance:Int]
										Array<Dynamic>
										length:Int
			[Return:Dynamic] [Const:Int] 0

	function hasRestPattern[Function:(value : Dynamic) -> Bool]
		[Arg:Dynamic] [Local value(25232):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local value(25232):Dynamic:Dynamic]
					==
					[Const:String] "TArrayDecl"
				[Then:Void] [Block:Void]
					[Var arr(25233):{ el : Null<Array<Dynamic>> }]
						[Field:Dynamic]
							[Local value(25232):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:Null<Array<Dynamic>>]
								[Local arr(25233):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
								[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
							!=
							[Const:Null<Array<Dynamic>>] null
						[Then:Void] [Block:Void]
							[Block:Void]
								[Var `(25235):Int] [Const:Int] 0
								[Var `(25236):Array<Dynamic>]
									[Parenthesis:Array<Dynamic>]
										[Cast:Array<Dynamic>]
											[Field:Null<Array<Dynamic>>]
												[Local arr(25233):{ el : Null<Array<Dynamic>> }:{ el : Null<Array<Dynamic>> }]
												[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
								[While:Void]
									[Binop:Bool]
										[Local `(25235):Int:Int]
										<
										[Field:Int]
											[Local `(25236):Array<Dynamic>:Array<Dynamic>]
											[FInstance:Int]
												Array<Dynamic>
												length:Int
									[Block:Void]
										[Var element(25234):Dynamic]
											[Array:Dynamic]
												[Local `(25236):Array<Dynamic>:Array<Dynamic>]
												[Local `(25235):Int:Int]
										[Unop:Int]
											++
											Prefix
											[Local `(25235):Int:Int]
										[If:Void]
											[Call:Bool]
												[Field:(expr : Dynamic) -> Bool]
													[Const:reflaxe.elixir.helpers.PatternMatcher] this
													[FInstance:(expr : Dynamic) -> Bool]
														reflaxe.elixir.helpers.PatternMatcher
														isRestPattern:(expr : Dynamic) -> Bool
												[Local element(25234):Dynamic:Dynamic]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false

	function getVariableName[Function:(value : Dynamic) -> String]
		[Arg:Dynamic] [Local value(25163):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.PatternMatcher] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.PatternMatcher
								getExprType:(expr : Dynamic) -> String
						[Local value(25163):Dynamic:Dynamic]
					==
					[Const:String] "TLocal"
				[Then:Void] [Block:Void]
					[Var local(25164):{ v : Null<{ name : Null<String> }> }]
						[Field:Dynamic]
							[Local value(25163):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Field:Null<{ name : Null<String> }>]
									[Local local(25164):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
									[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
								!=
								[Const:Null<{ name : Null<String> }>] null
							&&
							[Binop:Bool]
								[Field:Null<String>]
									[Field:Null<{ name : Null<String> }>]
										[Local local(25164):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
										[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
									[FAnon:Null<String>] name:Null<String>
								!=
								[Const:Null<String>] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Field:Null<String>]
									[Field:Null<{ name : Null<String> }>]
										[Local local(25164):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
										[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
									[FAnon:Null<String>] name:Null<String>
			[Return:Dynamic] [Const:String] ""
}