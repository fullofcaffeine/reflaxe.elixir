class reflaxe.elixir.helpers.ExUnitCompiler {

	public static function compile[Function:(classType : haxe.macro.ClassType, compiler : reflaxe.elixir.ElixirCompiler) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(27833):haxe.macro.ClassType]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27834):reflaxe.elixir.ElixirCompiler]
		[Block:Dynamic]
			[Var result(27835):StringBuf] [New:StringBuf] StringBuf
			[Var className(27836):String]
				[Field:String]
					[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27835):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local className(27836):String:String]
					+
					[Const:String] " do\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27835):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  use ExUnit.Case\n\n"
			[If:Void]
				[Binop:Bool]
					[Field:Null<String>]
						[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:Null<String>] doc:Null<String>
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(27835):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "  @moduledoc \"\"\"\n"
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(27835):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Binop:String]
							[Binop:String]
								[Const:String] "  "
								+
								[Field:Null<String>]
									[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
									[FAnon:Null<String>] doc:Null<String>
							+
							[Const:String] "\n"
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(27835):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "  \"\"\"\n\n"
			[Var async(27839):Bool]
				[Call:Bool]
					[Field:(classType : haxe.macro.ClassType) -> Bool]
						[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
						[FStatic:(classType : haxe.macro.ClassType) -> Bool]
							reflaxe.elixir.helpers.ExUnitCompiler
							isAsyncTest:(classType : haxe.macro.ClassType) -> Bool
					[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Local async(27839):Bool:Bool]
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local result(27835):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "  use ExUnit.Case, async: true\n\n"
			[Call:Void]
				[Field:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
					[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
					[FStatic:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
						reflaxe.elixir.helpers.ExUnitCompiler
						compileSetupMethods:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
				[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
				[Local result(27835):StringBuf:StringBuf]
				[Local compiler(27834):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
			[Call:Void]
				[Field:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
					[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
					[FStatic:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
						reflaxe.elixir.helpers.ExUnitCompiler
						compileTestMethods:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
				[Local classType(27833):haxe.macro.ClassType:haxe.macro.ClassType]
				[Local result(27835):StringBuf:StringBuf]
				[Local compiler(27834):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27835):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "end\n"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local result(27835):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function isAsyncTest[Function:(classType : haxe.macro.ClassType) -> Bool]
		[Arg:haxe.macro.ClassType] [Local classType(27837):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var metaEntries(27838):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Field:haxe.macro.MetaAccess]
							[Local classType(27837):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":async"
			[Return:Dynamic]
				[Binop:Bool]
					[Field:Int]
						[Local metaEntries(27838):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
						[FInstance:Int]
							Array<haxe.macro.MetadataEntry>
							length:Int
					>
					[Const:Int] 0

	static function compileSetupMethods[Function:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:haxe.macro.ClassType] [Local classType(27840):haxe.macro.ClassType]
		[Arg:StringBuf] [Local result(27841):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27842):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Block:Void]
				[Var `(27856):Int] [Const:Int] 0
				[Var `(27857):Array<haxe.macro.ClassField>]
					[Call:Array<haxe.macro.ClassField>]
						[Field:() -> Array<haxe.macro.ClassField>]
							[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
								[Local classType(27840):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
							[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
				[While:Void]
					[Binop:Bool]
						[Local `(27856):Int:Int]
						<
						[Field:Int]
							[Local `(27857):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
							[FInstance:Int]
								Array<haxe.macro.ClassField>
								length:Int
					[Block:Void]
						[Var field(27843):haxe.macro.ClassField]
							[Array:haxe.macro.ClassField]
								[Local `(27857):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
								[Local `(27856):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(27856):Int:Int]
						[Meta:Void]
							:ast(switch (field.name) {
	case "setup":
		compileSetupMethod(field, result, compiler, false);	
	case "setupAll":
		compileSetupMethod(field, result, compiler, true);	
	case "teardown":
		compileTeardownMethod(field, result, compiler, false);	
	case "teardownAll":
		compileTeardownMethod(field, result, compiler, true);	
	case _:
})
							[Block:Void]
								[Var `(27855):String]
									[Field:String]
										[Local field(27843):haxe.macro.ClassField:haxe.macro.ClassField]
										[FAnon:String] name:String
								[Switch:Void]
									[Local `(27855):String:String]
									[Case:Void]
										[Const:String] "setup"
										[Block:Void]
											[Block:Void]
												[Call:Void]
													[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
														[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
														[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
															reflaxe.elixir.helpers.ExUnitCompiler
															compileSetupMethod:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void
													[Local field(27843):haxe.macro.ClassField:haxe.macro.ClassField]
													[Local result(27841):StringBuf:StringBuf]
													[Local compiler(27842):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
													[Const:Bool] false
									[Case:Void]
										[Const:String] "setupAll"
										[Block:Void]
											[Block:Void]
												[Call:Void]
													[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
														[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
														[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
															reflaxe.elixir.helpers.ExUnitCompiler
															compileSetupMethod:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void
													[Local field(27843):haxe.macro.ClassField:haxe.macro.ClassField]
													[Local result(27841):StringBuf:StringBuf]
													[Local compiler(27842):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
													[Const:Bool] true
									[Case:Void]
										[Const:String] "teardown"
										[Block:Void]
											[Block:Void]
												[Call:Void]
													[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
														[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
														[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
															reflaxe.elixir.helpers.ExUnitCompiler
															compileTeardownMethod:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void
													[Local field(27843):haxe.macro.ClassField:haxe.macro.ClassField]
													[Local result(27841):StringBuf:StringBuf]
													[Local compiler(27842):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
													[Const:Bool] false
									[Case:Void]
										[Const:String] "teardownAll"
										[Block:Void]
											[Block:Void]
												[Call:Void]
													[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
														[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
														[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
															reflaxe.elixir.helpers.ExUnitCompiler
															compileTeardownMethod:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void
													[Local field(27843):haxe.macro.ClassField:haxe.macro.ClassField]
													[Local result(27841):StringBuf:StringBuf]
													[Local compiler(27842):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
													[Const:Bool] true
									[Default:Void] [Block:Void]

	static function compileSetupMethod[Function:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
		[Arg:haxe.macro.ClassField] [Local field(27844):haxe.macro.ClassField]
		[Arg:StringBuf] [Local result(27845):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27846):reflaxe.elixir.ElixirCompiler]
		[Arg:Bool] [Local all(27847):Bool]
		[Block:Void]
			[Var setupType(27848):String]
				[If:String]
					[Local all(27847):Bool:Bool]
					[Then:String] [Block:String] [Const:String] "setup_all"
					[Else:String] [Block:String] [Const:String] "setup"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27845):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "  "
						+
						[Local setupType(27848):String:String]
					+
					[Const:String] " do\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27845):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "    {:ok, %{}}\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27845):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  end\n\n"

	static function compileTeardownMethod[Function:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler, all : Bool) -> Void]
		[Arg:haxe.macro.ClassField] [Local field(27849):haxe.macro.ClassField]
		[Arg:StringBuf] [Local result(27850):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27851):reflaxe.elixir.ElixirCompiler]
		[Arg:Bool] [Local all(27852):Bool]
		[Block:Void]
			[Var teardownType(27853):String]
				[If:String]
					[Local all(27852):Bool:Bool]
					[Then:String] [Block:String] [Const:String] "on_exit"
					[Else:String] [Block:String] [Const:String] "on_exit"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27850):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "  "
						+
						[Local teardownType(27853):String:String]
					+
					[Const:String] "(fn ->\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27850):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "    :ok\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27850):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  end)\n\n"

	static function compileTestMethods[Function:(classType : haxe.macro.ClassType, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:haxe.macro.ClassType] [Local classType(27858):haxe.macro.ClassType]
		[Arg:StringBuf] [Local result(27859):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27860):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Block:Void]
				[Var `(27954):Int] [Const:Int] 0
				[Var `(27955):Array<haxe.macro.ClassField>]
					[Call:Array<haxe.macro.ClassField>]
						[Field:() -> Array<haxe.macro.ClassField>]
							[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
								[Local classType(27858):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
							[FAnon:() -> Array<haxe.macro.ClassField>] get:() -> Array<haxe.macro.ClassField>
				[While:Void]
					[Binop:Bool]
						[Local `(27954):Int:Int]
						<
						[Field:Int]
							[Local `(27955):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
							[FInstance:Int]
								Array<haxe.macro.ClassField>
								length:Int
					[Block:Void]
						[Var field(27861):haxe.macro.ClassField]
							[Array:haxe.macro.ClassField]
								[Local `(27955):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
								[Local `(27954):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(27954):Int:Int]
						[If:Void]
							[Call:Bool]
								[Field:(name : String) -> Bool]
									[Field:haxe.macro.MetaAccess]
										[Local field(27861):haxe.macro.ClassField:haxe.macro.ClassField]
										[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
									[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
								[Const:String] ":exunit_test_method"
							[Then:Void] [Block:Void]
								[Call:Void]
									[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
										[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
										[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
											reflaxe.elixir.helpers.ExUnitCompiler
											compileTestMethod:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
									[Local field(27861):haxe.macro.ClassField:haxe.macro.ClassField]
									[Local result(27859):StringBuf:StringBuf]
									[Local compiler(27860):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	static function compileTestMethod[Function:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:haxe.macro.ClassField] [Local field(27862):haxe.macro.ClassField]
		[Arg:StringBuf] [Local result(27863):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27864):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Var testName(27865):String] [Const:String] "test"
			[Var metaEntries(27866):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Field:haxe.macro.MetaAccess]
							[Local field(27862):haxe.macro.ClassField:haxe.macro.ClassField]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":exunit_test_method"
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Int]
							[Local metaEntries(27866):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
							[FInstance:Int]
								Array<haxe.macro.MetadataEntry>
								length:Int
						>
						[Const:Int] 0
					&&
					[Binop:Bool]
						[Field:Int]
							[Field:Null<Array<haxe.macro.Expr>>]
								[Array:haxe.macro.MetadataEntry]
									[Local metaEntries(27866):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
									[Const:Int] 0
								[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
							[FInstance:Int]
								Array<haxe.macro.Expr>
								length:Int
						>
						[Const:Int] 0
				[Then:Void] [Block:Void]
					[Meta:Void]
						:ast(switch (metaEntries[0].params[0].expr) {
	case EConst(CString(s, _)):
		testName = s;	
	case _:
		testName = field.name;	
})
						[Block:Void]
							[Var `(27872):haxe.macro.ExprDef]
								[Field:haxe.macro.ExprDef]
									[Array:haxe.macro.Expr]
										[Field:Null<Array<haxe.macro.Expr>>]
											[Array:haxe.macro.MetadataEntry]
												[Local metaEntries(27866):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
												[Const:Int] 0
											[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
										[Const:Int] 0
									[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(27872):haxe.macro.ExprDef:haxe.macro.ExprDef]
									==
									[Const:Int] 0
								[Then:Void] [Block:Void]
									[Var `(27873):haxe.macro.Constant]
										[EnumParameter:haxe.macro.Constant]
											[Local `(27872):haxe.macro.ExprDef:haxe.macro.ExprDef]
											EConst
											0
									[If:Void]
										[Binop:Bool]
											[EnumIndex:Int] [Local `(27873):haxe.macro.Constant:haxe.macro.Constant]
											==
											[Const:Int] 2
										[Then:String] [Block:String]
											[Var `(27874):String]
												[EnumParameter:String]
													[Local `(27873):haxe.macro.Constant:haxe.macro.Constant]
													CString
													0
											[Var `(27875):Null<haxe.macro.StringLiteralKind>]
												[EnumParameter:Null<haxe.macro.StringLiteralKind>]
													[Local `(27873):haxe.macro.Constant:haxe.macro.Constant]
													CString
													1
											[Block:String]
												[Var s(27876):String] [Local `(27874):String:String]
												[Block:String]
													[Binop:String]
														[Local testName(27865):String:String]
														=
														[Local s(27876):String:String]
										[Else:String] [Block:String]
											[Binop:String]
												[Local testName(27865):String:String]
												=
												[Field:String]
													[Local field(27862):haxe.macro.ClassField:haxe.macro.ClassField]
													[FAnon:String] name:String
								[Else:String] [Block:String]
									[Binop:String]
										[Local testName(27865):String:String]
										=
										[Field:String]
											[Local field(27862):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:String] name:String
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27863):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] "  test \""
						+
						[Local testName(27865):String:String]
					+
					[Const:String] "\" do\n"
			[Meta:Void]
				:ast(switch (field.type) {
	case TFun(args, ret):
		compileTestMethodBody(field, result, compiler);	
	case _:
		result.add("    # Fallback: Test method stub - implement logic in Haxe source\n");
		result.add("    assert true\n");	
})
				[Block:Void]
					[Var `(27949):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local field(27862):haxe.macro.ClassField:haxe.macro.ClassField]
							[FAnon:haxe.macro.Type] type:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(27949):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 4
						[Then:Void] [Block:Void]
							[Var `(27950):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
								[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[Local `(27949):haxe.macro.Type:haxe.macro.Type]
									TFun
									0
							[Var `(27951):haxe.macro.Type]
								[EnumParameter:haxe.macro.Type]
									[Local `(27949):haxe.macro.Type:haxe.macro.Type]
									TFun
									1
							[Block:Void]
								[Var args(27952):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(27950):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
								[Var ret(27953):haxe.macro.Type] [Local `(27951):haxe.macro.Type:haxe.macro.Type]
								[Block:Void]
									[Call:Void]
										[Field:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
											[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
											[FStatic:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
												reflaxe.elixir.helpers.ExUnitCompiler
												compileTestMethodBody:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
										[Local field(27862):haxe.macro.ClassField:haxe.macro.ClassField]
										[Local result(27863):StringBuf:StringBuf]
										[Local compiler(27864):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
						[Else:Void] [Block:Void]
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local result(27863):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Const:String] "    # Fallback: Test method stub - implement logic in Haxe source\n"
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local result(27863):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Const:String] "    assert true\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local result(27863):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "  end\n\n"

	static function compileTestMethodBody[Function:(field : haxe.macro.ClassField, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:haxe.macro.ClassField] [Local field(27879):haxe.macro.ClassField]
		[Arg:StringBuf] [Local result(27880):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27881):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Meta:Void]
				:ast(switch (field.expr()) {
	case null:
		result.add("    # Test method: ${field.name}\n");
		result.add("    # No method body available - generating placeholder\n");
		result.add("    assert true\n");	
	case methodExpr:
		switch (methodExpr.expr) {
			case TFunction(tfunc):
				var body = tfunc.expr;
				compileTestMethodExpression(body, result, compiler);			
			case _:
				compileTestMethodExpression(methodExpr, result, compiler);			
		};	
})
				[Block:Void]
					[Var `(27940):Null<haxe.macro.TypedExpr>]
						[Call:Null<haxe.macro.TypedExpr>]
							[Field:() -> Null<haxe.macro.TypedExpr>]
								[Local field(27879):haxe.macro.ClassField:haxe.macro.ClassField]
								[FAnon:() -> Null<haxe.macro.TypedExpr>] expr:() -> Null<haxe.macro.TypedExpr>
					[If:Void]
						[Binop:Bool]
							[Local `(27940):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							==
							[Const:Null<haxe.macro.TypedExpr>] null
						[Then:Void] [Block:Void]
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local result(27880):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Binop:String]
									[Binop:String]
										[Const:String] "    # Test method: "
										+
										[Field:String]
											[Local field(27879):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:String] name:String
									+
									[Const:String] "\n"
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local result(27880):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Const:String] "    # No method body available - generating placeholder\n"
							[Call:Void]
								[Field:(x : String) -> Void]
									[Local result(27880):StringBuf:StringBuf]
									[FInstance:(x : String) -> Void]
										StringBuf
										add:(x : add.T) -> Void
								[Const:String] "    assert true\n"
						[Else:Void] [Block:Void]
							[Var methodExpr(27941):Null<haxe.macro.TypedExpr>] [Local `(27940):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							[Block:Void]
								[Meta:Void]
									:ast(switch (methodExpr.expr) {
	case TFunction(tfunc):
		var body = tfunc.expr;
		compileTestMethodExpression(body, result, compiler);	
	case _:
		compileTestMethodExpression(methodExpr, result, compiler);	
})
									[Block:Void]
										[Var `(27942):haxe.macro.TypedExprDef]
											[Field:haxe.macro.TypedExprDef]
												[Local methodExpr(27941):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
										[If:Void]
											[Binop:Bool]
												[EnumIndex:Int] [Local `(27942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												==
												[Const:Int] 12
											[Then:Void] [Block:Void]
												[Var `(27943):haxe.macro.TFunc]
													[EnumParameter:haxe.macro.TFunc]
														[Local `(27942):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
														TFunction
														0
												[Block:Void]
													[Var tfunc(27944):haxe.macro.TFunc] [Local `(27943):haxe.macro.TFunc:haxe.macro.TFunc]
													[Block:Void]
														[Var body(27945):haxe.macro.TypedExpr]
															[Field:haxe.macro.TypedExpr]
																[Local tfunc(27944):haxe.macro.TFunc:haxe.macro.TFunc]
																[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
														[Call:Void]
															[Field:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
																[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
																[FStatic:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
																	reflaxe.elixir.helpers.ExUnitCompiler
																	compileTestMethodExpression:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
															[Local body(27945):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Local result(27880):StringBuf:StringBuf]
															[Local compiler(27881):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
											[Else:Void] [Block:Void]
												[Call:Void]
													[Field:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
														[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
														[FStatic:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
															reflaxe.elixir.helpers.ExUnitCompiler
															compileTestMethodExpression:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void
													[Local methodExpr(27941):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													[Local result(27880):StringBuf:StringBuf]
													[Local compiler(27881):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	static function compileTestMethodExpression[Function:(expr : haxe.macro.TypedExpr, result : StringBuf, compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local expr(27885):haxe.macro.TypedExpr]
		[Arg:StringBuf] [Local result(27886):StringBuf]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27887):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Var compiledBody(27888):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Local compiler(27887):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local expr(27885):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var transformedBody(27929):String]
				[Call:String]
					[Field:(code : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
						[FStatic:(code : String) -> String]
							reflaxe.elixir.helpers.ExUnitCompiler
							transformAssertCalls:(code : String) -> String
					[Local compiledBody(27888):Null<String>:Null<String>]
			[Var lines(27930):Array<String>]
				[Call:Array<String>]
					[Field:(delimiter : String) -> Array<String>]
						[Local transformedBody(27929):String:String]
						[FInstance:(delimiter : String) -> Array<String>]
							String
							split:(delimiter : String) -> Array<String>
					[Const:String] "\n"
			[Block:Void]
				[Var `(27932):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(27932):Int:Int]
						<
						[Field:Int]
							[Local lines(27930):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var line(27931):String]
							[Array:String]
								[Local lines(27930):Array<String>:Array<String>]
								[Local `(27932):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(27932):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Call:String]
									[Field:(s : String) -> String]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String) -> String]
											StringTools
											trim:(s : String) -> String
									[Local line(27931):String:String]
								!=
								[Const:String] ""
							[Then:Void] [Block:Void]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local result(27886):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Const:String] "    "
											+
											[Local line(27931):String:String]
										+
										[Const:String] "\n"

	static function transformAssertCalls[Function:(code : String) -> String]
		[Arg:String] [Local code(27889):String]
		[Block:Dynamic]
			[Var assertPattern(27890):EReg]
				[New:EReg]
					EReg
					[Const:String] "Assert\\.(\\w+)\\(([^()]*(?:\\([^()]*\\)[^()]*)*)\\)"
					[Const:String] "g"
			[Return:Dynamic]
				[Call:String]
					[Field:(s : String, f : (EReg -> String)) -> String]
						[Local assertPattern(27890):EReg:EReg]
						[FInstance:(s : String, f : (EReg -> String)) -> String]
							EReg
							map:(s : String, f : (EReg -> String)) -> String
					[Local code(27889):String:String]
					[Function:(ereg : EReg) -> String]
						[Arg:EReg] [Local ereg(27891):EReg]
						[Block:Dynamic]
							[Var methodName(27892):String]
								[Call:String]
									[Field:(n : Int) -> String]
										[Local ereg(27891):EReg:EReg]
										[FInstance:(n : Int) -> String]
											EReg
											matched:(n : Int) -> String
									[Const:Int] 1
							[Var argsStr(27893):String]
								[Call:String]
									[Field:(n : Int) -> String]
										[Local ereg(27891):EReg:EReg]
										[FInstance:(n : Int) -> String]
											EReg
											matched:(n : Int) -> String
									[Const:Int] 2
							[Var args(27905):Array<String>]
								[Call:Array<String>]
									[Field:(argsStr : String) -> Array<String>]
										[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
										[FStatic:(argsStr : String) -> Array<String>]
											reflaxe.elixir.helpers.ExUnitCompiler
											parseArguments:(argsStr : String) -> Array<String>
									[Local argsStr(27893):String:String]
							[Var transformedArgs(27918):Array<String>]
								[Block:Array<String>]
									[Var f(27913):String -> String]
										[Field:(arg : String) -> String]
											[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
											[FStatic:(arg : String) -> String]
												reflaxe.elixir.helpers.ExUnitCompiler
												transformEnumConstructors:(arg : String) -> String
									[Block:Array<String>]
										[Var `(27914):Array<String>] [ArrayDecl:Array<String>]
										[Block:Void]
											[Var `(27915):Int] [Const:Int] 0
											[Var `(27916):Array<String>] [Local args(27905):Array<String>:Array<String>]
											[While:Void]
												[Binop:Bool]
													[Local `(27915):Int:Int]
													<
													[Field:Int]
														[Local `(27916):Array<String>:Array<String>]
														[FInstance:Int]
															Array<String>
															length:Int
												[Block:Void]
													[Var v(27917):String]
														[Array:String]
															[Local `(27916):Array<String>:Array<String>]
															[Local `(27915):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(27915):Int:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local `(27914):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Call:String]
															[Local f(27913):String -> String:String -> String]
															[Local v(27917):String:String]
										[Local `(27914):Array<String>:Array<String>]
							[Return:Dynamic]
								[Call:String]
									[Field:(methodName : String, args : Array<String>) -> String]
										[TypeExpr reflaxe.elixir.helpers.ExUnitCompiler:Class<reflaxe.elixir.helpers.ExUnitCompiler>]
										[FStatic:(methodName : String, args : Array<String>) -> String]
											reflaxe.elixir.helpers.ExUnitCompiler
											transformAssertCall:(methodName : String, args : Array<String>) -> String
									[Local methodName(27892):String:String]
									[Local transformedArgs(27918):Array<String>:Array<String>]

	static function transformEnumConstructors[Function:(arg : String) -> String]
		[Arg:String] [Local arg(27906):String]
		[Block:Dynamic]
			[Var somePattern(27907):EReg]
				[New:EReg]
					EReg
					[Const:String] "Some\\(([^)]+)\\)"
					[Const:String] "g"
			[Binop:String]
				[Local arg(27906):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[Local somePattern(27907):EReg:EReg]
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local arg(27906):String:String]
					[Const:String] "{:some, $1}"
			[Var nonePattern(27908):EReg]
				[New:EReg]
					EReg
					[Const:String] "\\bNone\\b"
					[Const:String] "g"
			[Binop:String]
				[Local arg(27906):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[Local nonePattern(27908):EReg:EReg]
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local arg(27906):String:String]
					[Const:String] ":none"
			[Var okPattern(27909):EReg]
				[New:EReg]
					EReg
					[Const:String] "Ok\\(([^)]+)\\)"
					[Const:String] "g"
			[Binop:String]
				[Local arg(27906):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[Local okPattern(27909):EReg:EReg]
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local arg(27906):String:String]
					[Const:String] "{:ok, $1}"
			[Var errorPattern(27910):EReg]
				[New:EReg]
					EReg
					[Const:String] "Error\\(([^)]+)\\)"
					[Const:String] "g"
			[Binop:String]
				[Local arg(27906):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[Local errorPattern(27910):EReg:EReg]
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local arg(27906):String:String]
					[Const:String] "{:error, $1}"
			[Return:Dynamic] [Local arg(27906):String:String]

	static function parseArguments[Function:(argsStr : String) -> Array<String>]
		[Arg:String] [Local argsStr(27894):String]
		[Block:Dynamic]
			[Var args(27895):Array<String>] [ArrayDecl:Array<String>]
			[Var current(27896):String] [Const:String] ""
			[Var parentheses(27897):Int] [Const:Int] 0
			[Var braces(27898):Int] [Const:Int] 0
			[Var inString(27899):Bool] [Const:Bool] false
			[Var stringChar(27900):String] [Const:String] ""
			[Block:Void]
				[Var `(27903):Int] [Const:Int] 0
				[Var `(27904):Int]
					[Field:Int]
						[Local argsStr(27894):String:String]
						[FInstance:Int]
							String
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(27903):Int:Int]
						<
						[Local `(27904):Int:Int]
					[Block:Void]
						[Var i(27901):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(27903):Int:Int]
						[Var char(27902):String]
							[Call:String]
								[Field:(index : Int) -> String]
									[Local argsStr(27894):String:String]
									[FInstance:(index : Int) -> String]
										String
										charAt:(index : Int) -> String
								[Local i(27901):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Unop:Bool]
									!
									Prefix
									[Local inString(27899):Bool:Bool]
								&&
								[Parenthesis:Bool]
									[Binop:Bool]
										[Binop:Bool]
											[Local char(27902):String:String]
											==
											[Const:String] "\""
										||
										[Binop:Bool]
											[Local char(27902):String:String]
											==
											[Const:String] "'"
							[Then:String] [Block:String]
								[Binop:Bool]
									[Local inString(27899):Bool:Bool]
									=
									[Const:Bool] true
								[Binop:String]
									[Local stringChar(27900):String:String]
									=
									[Local char(27902):String:String]
								[Binop:String]
									[Local current(27896):String:String]
									+=
									[Local char(27902):String:String]
							[Else:Void] [Block:Void]
								[If:Void]
									[Binop:Bool]
										[Local inString(27899):Bool:Bool]
										&&
										[Binop:Bool]
											[Local char(27902):String:String]
											==
											[Local stringChar(27900):String:String]
									[Then:String] [Block:String]
										[Binop:Bool]
											[Local inString(27899):Bool:Bool]
											=
											[Const:Bool] false
										[Binop:String]
											[Local stringChar(27900):String:String]
											=
											[Const:String] ""
										[Binop:String]
											[Local current(27896):String:String]
											+=
											[Local char(27902):String:String]
									[Else:Void] [Block:Void]
										[If:Void]
											[Binop:Bool]
												[Unop:Bool]
													!
													Prefix
													[Local inString(27899):Bool:Bool]
												&&
												[Binop:Bool]
													[Local char(27902):String:String]
													==
													[Const:String] "("
											[Then:String] [Block:String]
												[Unop:Int]
													++
													Postfix
													[Local parentheses(27897):Int:Int]
												[Binop:String]
													[Local current(27896):String:String]
													+=
													[Local char(27902):String:String]
											[Else:Void] [Block:Void]
												[If:Void]
													[Binop:Bool]
														[Unop:Bool]
															!
															Prefix
															[Local inString(27899):Bool:Bool]
														&&
														[Binop:Bool]
															[Local char(27902):String:String]
															==
															[Const:String] ")"
													[Then:String] [Block:String]
														[Unop:Int]
															--
															Postfix
															[Local parentheses(27897):Int:Int]
														[Binop:String]
															[Local current(27896):String:String]
															+=
															[Local char(27902):String:String]
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Unop:Bool]
																	!
																	Prefix
																	[Local inString(27899):Bool:Bool]
																&&
																[Binop:Bool]
																	[Local char(27902):String:String]
																	==
																	[Const:String] "{"
															[Then:String] [Block:String]
																[Unop:Int]
																	++
																	Postfix
																	[Local braces(27898):Int:Int]
																[Binop:String]
																	[Local current(27896):String:String]
																	+=
																	[Local char(27902):String:String]
															[Else:Void] [Block:Void]
																[If:Void]
																	[Binop:Bool]
																		[Unop:Bool]
																			!
																			Prefix
																			[Local inString(27899):Bool:Bool]
																		&&
																		[Binop:Bool]
																			[Local char(27902):String:String]
																			==
																			[Const:String] "}"
																	[Then:String] [Block:String]
																		[Unop:Int]
																			--
																			Postfix
																			[Local braces(27898):Int:Int]
																		[Binop:String]
																			[Local current(27896):String:String]
																			+=
																			[Local char(27902):String:String]
																	[Else:Void] [Block:Void]
																		[If:Void]
																			[Binop:Bool]
																				[Binop:Bool]
																					[Binop:Bool]
																						[Unop:Bool]
																							!
																							Prefix
																							[Local inString(27899):Bool:Bool]
																						&&
																						[Binop:Bool]
																							[Local char(27902):String:String]
																							==
																							[Const:String] ","
																					&&
																					[Binop:Bool]
																						[Local parentheses(27897):Int:Int]
																						==
																						[Const:Int] 0
																				&&
																				[Binop:Bool]
																					[Local braces(27898):Int:Int]
																					==
																					[Const:Int] 0
																			[Then:String] [Block:String]
																				[Call:Int]
																					[Field:(x : String) -> Int]
																						[Local args(27895):Array<String>:Array<String>]
																						[FInstance:(x : String) -> Int]
																							Array<String>
																							push:(x : Array.T) -> Int
																					[Call:String]
																						[Field:(s : String) -> String]
																							[TypeExpr StringTools:{ Statics StringTools }]
																							[FStatic:(s : String) -> String]
																								StringTools
																								trim:(s : String) -> String
																						[Local current(27896):String:String]
																				[Binop:String]
																					[Local current(27896):String:String]
																					=
																					[Const:String] ""
																			[Else:String] [Block:String]
																				[Binop:String]
																					[Local current(27896):String:String]
																					+=
																					[Local char(27902):String:String]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(s : String) -> String]
							[TypeExpr StringTools:{ Statics StringTools }]
							[FStatic:(s : String) -> String]
								StringTools
								trim:(s : String) -> String
						[Local current(27896):String:String]
					!=
					[Const:String] ""
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local args(27895):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Call:String]
							[Field:(s : String) -> String]
								[TypeExpr StringTools:{ Statics StringTools }]
								[FStatic:(s : String) -> String]
									StringTools
									trim:(s : String) -> String
							[Local current(27896):String:String]
			[Return:Dynamic] [Local args(27895):Array<String>:Array<String>]

	public static function isExUnitTest[Function:(classType : haxe.macro.ClassType) -> Bool]
		[Arg:haxe.macro.ClassType] [Local classType(27956):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Bool]
						[Field:(name : String) -> Bool]
							[Field:haxe.macro.MetaAccess]
								[Local classType(27956):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
							[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
						[Const:String] ":exunit_test"
					||
					[Call:Bool]
						[Field:(name : String) -> Bool]
							[Field:haxe.macro.MetaAccess]
								[Local classType(27956):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
							[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
						[Const:String] ":exunit"

	public static function transformAssertCall[Function:(methodName : String, args : Array<String>) -> String]
		[Arg:String] [Local methodName(27919):String]
		[Arg:Array<String>] [Local args(27920):Array<String>]
		[Block:Dynamic]
			[Var buildAssert(27921):(template : String, params : Array<String>) -> String]
				[Function:(template : String, params : Array<String>) -> String]
					[Arg:String] [Local template(27922):String]
					[Arg:Array<String>] [Local params(27923):Array<String>]
					[Block:Dynamic]
						[Var result(27924):String] [Local template(27922):String:String]
						[Block:Void]
							[Var `(27927):Int] [Const:Int] 0
							[Var `(27928):Int]
								[Field:Int]
									[Local params(27923):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[While:Void]
								[Binop:Bool]
									[Local `(27927):Int:Int]
									<
									[Local `(27928):Int:Int]
								[Block:String]
									[Var i(27925):Int]
										[Unop:Int]
											++
											Postfix
											[Local `(27927):Int:Int]
									[Var placeholder(27926):String]
										[Binop:String]
											[Const:String] "$"
											+
											[Local i(27925):Int:Int]
									[Binop:String]
										[Local result(27924):String:String]
										=
										[Call:String]
											[Field:(s : String, sub : String, by : String) -> String]
												[TypeExpr StringTools:Class<StringTools>]
												[FStatic:(s : String, sub : String, by : String) -> String]
													StringTools
													replace:(s : String, sub : String, by : String) -> String
											[Local result(27924):String:String]
											[Local placeholder(27926):String:String]
											[Array:String]
												[Local params(27923):Array<String>:Array<String>]
												[Local i(27925):Int:Int]
						[Return:Dynamic] [Local result(27924):String:String]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodName) {
	case "isTrue":
		buildAssert("assert $0", args);	
	case "isFalse":
		buildAssert("refute $0", args);	
	case "equals":
		buildAssert("assert $1 == $0", args);	
	case "notEquals":
		buildAssert("refute $1 == $0", args);	
	case "isNull":
		buildAssert("assert is_nil($0)", args);	
	case "isNotNull":
		buildAssert("refute is_nil($0)", args);	
	case "isSome":
		buildAssert("assert OptionTools.is_some($0)", args);	
	case "isNone":
		buildAssert("assert OptionTools.is_none($0)", args);	
	case "isOk":
		buildAssert("assert ResultTools.is_ok($0)", args);	
	case "isError":
		buildAssert("assert ResultTools.is_error($0)", args);	
	case "contains":
		buildAssert("assert Enum.member?($0, $1)", args);	
	case "containsString":
		buildAssert("assert String.contains?($0, $1)", args);	
	case "doesNotContainString":
		buildAssert("refute String.contains?($0, $1)", args);	
	case "isEmpty":
		buildAssert("assert Enum.empty?($0)", args);	
	case "isNotEmpty":
		buildAssert("refute Enum.empty?($0)", args);	
	case "inDelta":
		buildAssert("assert_in_delta $0, $1, $2", args);	
	case "fail":
		buildAssert("flunk($0)", args);	
	case "raises":
		if (args.length >= 2) {
			buildAssert("assert_raise $1, fn -> $0 end", args);
		} else {
			buildAssert("assert_raise fn -> $0 end", args);
		};	
	case "doesNotRaise":
		buildAssert("$0", args);	
	case "received":
		if (args.length >= 2) {
			buildAssert("assert_receive $0, $1", args);
		} else {
			buildAssert("assert_receive $0", args);
		};	
	case _:
		buildAssert("# Unknown assertion: ${methodName}", []);	
})
					[Switch:String]
						[Local methodName(27919):String:String]
						[Case:String]
							[Const:String] "contains"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert Enum.member?($0, $1)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "containsString"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert String.contains?($0, $1)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "doesNotContainString"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "refute String.contains?($0, $1)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "doesNotRaise"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "$0"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "equals"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert $1 == $0"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "fail"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "flunk($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "inDelta"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert_in_delta $0, $1, $2"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isEmpty"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert Enum.empty?($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isError"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert ResultTools.is_error($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isFalse"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "refute $0"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isNone"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert OptionTools.is_none($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isNotEmpty"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "refute Enum.empty?($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isNotNull"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "refute is_nil($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isNull"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert is_nil($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isOk"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert ResultTools.is_ok($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isSome"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert OptionTools.is_some($0)"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "isTrue"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "assert $0"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "notEquals"
							[Block:String]
								[Block:String]
									[Call:String]
										[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
										[Const:String] "refute $1 == $0"
										[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "raises"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(27920):Array<String>:Array<String>]
												[FInstance:Int]
													Array<String>
													length:Int
											>=
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:String]
												[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
												[Const:String] "assert_raise $1, fn -> $0 end"
												[Local args(27920):Array<String>:Array<String>]
										[Else:String] [Block:String]
											[Call:String]
												[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
												[Const:String] "assert_raise fn -> $0 end"
												[Local args(27920):Array<String>:Array<String>]
						[Case:String]
							[Const:String] "received"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(27920):Array<String>:Array<String>]
												[FInstance:Int]
													Array<String>
													length:Int
											>=
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:String]
												[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
												[Const:String] "assert_receive $0, $1"
												[Local args(27920):Array<String>:Array<String>]
										[Else:String] [Block:String]
											[Call:String]
												[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
												[Const:String] "assert_receive $0"
												[Local args(27920):Array<String>:Array<String>]
						[Default:String]
							[Block:String]
								[Call:String]
									[Local buildAssert(27921):(template : String, params : Array<String>) -> String:(template : String, params : Array<String>) -> String]
									[Binop:String]
										[Const:String] "# Unknown assertion: "
										+
										[Local methodName(27919):String:String]
									[ArrayDecl:Array<String>]
}