@:nullSafety(Off)
class reflaxe.elixir.helpers.NamingConventionCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(32620):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.NamingConventionCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(32620):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function toElixirName[Function:(haxeName : String) -> String]
		[Arg:String] [Local haxeName(22284):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local haxeName(22284):String:String]

	public function convertPackageToDirectoryPath[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(32621):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var packageParts(32622):Array<String>]
				[Field:Array<String>]
					[Local classType(32621):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:Array<String>] pack:Array<String>
			[Var className(32623):String]
				[Field:String]
					[Local classType(32621):haxe.macro.ClassType:haxe.macro.ClassType]
					[FAnon:String] name:String
			[Var snakeClassName(32624):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local className(32623):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local packageParts(32622):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local snakeClassName(32624):String:String]
			[Var snakePackageParts(32634):Array<String>]
				[Block:Array<String>]
					[Var `(32629):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(32630):Int] [Const:Int] 0
						[Var `(32631):Array<String>] [Local packageParts(32622):Array<String>:Array<String>]
						[While:Void]
							[Binop:Bool]
								[Local `(32630):Int:Int]
								<
								[Field:Int]
									[Local `(32631):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var v(32632):String]
									[Array:String]
										[Local `(32631):Array<String>:Array<String>]
										[Local `(32630):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(32630):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local `(32629):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Function:(part : String) -> String]
											[Arg:String] [Local part(32633):String]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:String]
														[Field:(camelCase : String) -> String]
															[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
															[FStatic:(camelCase : String) -> String]
																reflaxe.elixir.helpers.NamingHelper
																toSnakeCase:(camelCase : String) -> String
														[Local part(32633):String:String]
										[Local v(32632):String:String]
					[Local `(32629):Array<String>:Array<String>]
			[Return:Dynamic]
				[Call:String]
					[Field:(paths : Array<String>) -> String]
						[TypeExpr haxe.io.Path:Class<haxe.io.Path>]
						[FStatic:(paths : Array<String>) -> String]
							haxe.io.Path
							join:(paths : Array<String>) -> String
					[Call:Array<String>]
						[Field:(a : Array<String>) -> Array<String>]
							[Local snakePackageParts(32634):Array<String>:Array<String>]
							[FInstance:(a : Array<String>) -> Array<String>]
								Array<String>
								concat:(a : Array<Array.T>) -> Array<Array.T>
						[ArrayDecl:Array<String>] [Local snakeClassName(32624):String:String]

	public function setFrameworkAwareOutputPath[Function:(classType : haxe.macro.ClassType) -> Void]
		[Arg:haxe.macro.ClassType] [Local classType(32635):haxe.macro.ClassType]
		[Block:Void]
			[Var annotationInfo(32636):reflaxe.elixir.helpers.AnnotationInfo]
				[Call:reflaxe.elixir.helpers.AnnotationInfo]
					[Field:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo]
							reflaxe.elixir.helpers.AnnotationSystem
							detectAnnotations:(classType : haxe.macro.ClassType) -> reflaxe.elixir.helpers.AnnotationInfo
					[Local classType(32635):haxe.macro.ClassType:haxe.macro.ClassType]
			[If:Void]
				[Binop:Bool]
					[Field:Null<String>]
						[Local annotationInfo(32636):reflaxe.elixir.helpers.AnnotationInfo:reflaxe.elixir.helpers.AnnotationInfo]
						[FAnon:Null<String>] primaryAnnotation:Null<String>
					!=
					[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Var namingRule(32638):{ fileName : String, dirPath : String }]
						[Call:{ fileName : String, dirPath : String }]
							[Field:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
									reflaxe.elixir.helpers.NamingConventionCompiler
									getComprehensiveNamingRule:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }
							[Local classType(32635):haxe.macro.ClassType:haxe.macro.ClassType]
					[Call:Void]
						[Field:(name : Null<String>) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.NamingConventionCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(name : Null<String>) -> Void]
								reflaxe.BaseCompiler
								setOutputFileName:(name : Null<String>) -> Void
						[Field:String]
							[Local namingRule(32638):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
							[FAnon:String] fileName:String
					[Var safeDir(32639):String]
						[If:String]
							[Binop:Bool]
								[Binop:Bool]
									[Field:String]
										[Local namingRule(32638):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
										[FAnon:String] dirPath:String
									!=
									[Const:String] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Field:String]
											[Local namingRule(32638):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
											[FAnon:String] dirPath:String
										[FInstance:Int]
											String
											length:Int
									>
									[Const:Int] 0
							[Then:String] [Block:String]
								[Field:String]
									[Local namingRule(32638):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
									[FAnon:String] dirPath:String
							[Else:String] [Block:String] [Const:String] "."
					[Call:Void]
						[Field:(dir : Null<String>) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.NamingConventionCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(dir : Null<String>) -> Void]
								reflaxe.BaseCompiler
								setOutputFileDir:(dir : Null<String>) -> Void
						[Local safeDir(32639):String:String]
				[Else:Void] [Block:Void]
					[Call:Void]
						[Field:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
							[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
							[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
								reflaxe.elixir.helpers.NamingConventionCompiler
								setUniversalOutputPath:(moduleName : String, ?pack : Null<Array<String>>) -> Void
						[Field:String]
							[Local classType(32635):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:String] name:String
						[Field:Array<String>]
							[Local classType(32635):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:Array<String>] pack:Array<String>

	@:value({ pack : null })
	public function getUniversalNamingRule[Function:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
		[Arg:String] [Local moduleName(32642):String]
		[Arg:Null<Array<String>>]
			[Local pack(32643):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingHelper
							getUniversalNamingRule:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }
					[Local moduleName(32642):String:String]
					[Local pack(32643):Null<Array<String>>:Null<Array<String>>]

	@:value({ pack : null })
	public function setUniversalOutputPath[Function:(moduleName : String, ?pack : Null<Array<String>>) -> Void]
		[Arg:String] [Local moduleName(32640):String]
		[Arg:Null<Array<String>>]
			[Local pack(32641):Null<Array<String>>]
			[Const:Null<Array<String>>] null
		[Block:Void]
			[Var namingRule(32644):{ fileName : String, dirPath : String }]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.NamingConventionCompiler
							getUniversalNamingRule:(moduleName : String, ?pack : Null<Array<String>>) -> { fileName : String, dirPath : String }
					[Local moduleName(32640):String:String]
					[Local pack(32641):Null<Array<String>>:Null<Array<String>>]
			[Call:Void]
				[Field:(name : Null<String>) -> Void]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.NamingConventionCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:(name : Null<String>) -> Void]
						reflaxe.BaseCompiler
						setOutputFileName:(name : Null<String>) -> Void
				[Field:String]
					[Local namingRule(32644):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
					[FAnon:String] fileName:String
			[Var safeDir(32645):String]
				[If:String]
					[Binop:Bool]
						[Binop:Bool]
							[Field:String]
								[Local namingRule(32644):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
								[FAnon:String] dirPath:String
							!=
							[Const:String] null
						&&
						[Binop:Bool]
							[Field:Int]
								[Field:String]
									[Local namingRule(32644):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
									[FAnon:String] dirPath:String
								[FInstance:Int]
									String
									length:Int
							>
							[Const:Int] 0
					[Then:String] [Block:String]
						[Field:String]
							[Local namingRule(32644):{ fileName : String, dirPath : String }:{ fileName : String, dirPath : String }]
							[FAnon:String] dirPath:String
					[Else:String] [Block:String] [Const:String] "."
			[Call:Void]
				[Field:(dir : Null<String>) -> Void]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.NamingConventionCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.NamingConventionCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:(dir : Null<String>) -> Void]
						reflaxe.BaseCompiler
						setOutputFileDir:(dir : Null<String>) -> Void
				[Local safeDir(32645):String:String]

	public function getComprehensiveNamingRule[Function:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
		[Arg:haxe.macro.ClassType] [Local classType(32637):haxe.macro.ClassType]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:{ fileName : String, dirPath : String }]
					[Field:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
						[TypeExpr reflaxe.elixir.helpers.PhoenixPathGenerator:Class<reflaxe.elixir.helpers.PhoenixPathGenerator>]
						[FStatic:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }]
							reflaxe.elixir.helpers.PhoenixPathGenerator
							getComprehensiveNamingRule:(classType : haxe.macro.ClassType) -> { fileName : String, dirPath : String }
					[Local classType(32637):haxe.macro.ClassType:haxe.macro.ClassType]
}