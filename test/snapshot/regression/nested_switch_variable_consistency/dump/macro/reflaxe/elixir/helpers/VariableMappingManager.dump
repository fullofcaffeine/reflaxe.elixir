@:nullSafety(Off)
class reflaxe.elixir.helpers.VariableMappingManager {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(30247):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Binop:Map<String, Bool>]
				[Field:Map<String, Bool>]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:Map<String, Bool>]
						reflaxe.elixir.helpers.VariableMappingManager
						setupBaseNames:Map<String, Bool>
				=
				[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.VariableMappingManager
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(30247):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.helpers.VariableMappingContext]
				[Field:reflaxe.elixir.helpers.VariableMappingContext]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
						reflaxe.elixir.helpers.VariableMappingManager
						compilationContext:reflaxe.elixir.helpers.VariableMappingContext
				=
				[New:reflaxe.elixir.helpers.VariableMappingContext]
					reflaxe.elixir.helpers.VariableMappingContext
					[Const:Null<Null<String>>] null
					[Const:Null<Null<haxe.macro.ClassType>>] null
					[Const:Null<Null<String>>] null
					[Cast:Null<Int>] [Const:Int] 0
					[Cast:Null<Int>] [Const:Int] 0
					[Cast:Null<Int>] [Const:Int] 0
					[Cast:Null<Bool>] [Const:Bool] false
					[Cast:Null<Bool>] [Const:Bool] false
					[Cast:Null<Bool>] [Const:Bool] false
			[Binop:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
				[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						reflaxe.elixir.helpers.VariableMappingManager
						variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
				=
				[New:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>
			[Binop:Array<String>]
				[Field:Array<String>]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:Array<String>]
						reflaxe.elixir.helpers.VariableMappingManager
						scopeCrossingVariables:Array<String>
				=
				[ArrayDecl:Array<String>]
			[Binop:Array<Map<String, String>>]
				[Field:Array<Map<String, String>>]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:Array<Map<String, String>>]
						reflaxe.elixir.helpers.VariableMappingManager
						savedMappingStates:Array<Map<String, String>>
				=
				[ArrayDecl:Array<Map<String, String>>]
			[Binop:Array<reflaxe.elixir.helpers.VariableMappingContext>]
				[Field:Array<reflaxe.elixir.helpers.VariableMappingContext>]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:Array<reflaxe.elixir.helpers.VariableMappingContext>]
						reflaxe.elixir.helpers.VariableMappingManager
						savedContextStates:Array<reflaxe.elixir.helpers.VariableMappingContext>
				=
				[ArrayDecl:Array<reflaxe.elixir.helpers.VariableMappingContext>]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public var compilationContext:reflaxe.elixir.helpers.VariableMappingContext;

	var variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>;

	var scopeCrossingVariables:Array<String>;

	var savedMappingStates:Array<Map<String, String>>;

	var savedContextStates:Array<reflaxe.elixir.helpers.VariableMappingContext>;

	@:value(new Map<String,Bool>())
	public var setupBaseNames:Map<String, Bool>;

	public function setupArrayDesugatingMappings[Function:(baseVarName : String) -> Void]
		[Arg:String] [Local baseVarName(21793):String]
		[Block:Void]
			[If:Void]
				[Block:Bool]
					[Var this(21796):haxe.IMap<String, Bool>]
						[Field:Map<String, Bool>]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:Map<String, Bool>]
								reflaxe.elixir.helpers.VariableMappingManager
								setupBaseNames:Map<String, Bool>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<Bool>] [Local this(21796):haxe.IMap<String, Bool>:haxe.IMap<String, Bool>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<Bool>
								exists:(key : String) -> Bool
						[Local baseVarName(21793):String:String]
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic]
			[Block:Void]
				[Var this(21800):haxe.IMap<String, Bool>]
					[Field:Map<String, Bool>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Map<String, Bool>]
							reflaxe.elixir.helpers.VariableMappingManager
							setupBaseNames:Map<String, Bool>
				[Call:Void]
					[Field:(key : String, value : Bool) -> Void]
						[Cast:haxe.ds.StringMap<Bool>] [Local this(21800):haxe.IMap<String, Bool>:haxe.IMap<String, Bool>]
						[FInstance:(key : String, value : Bool) -> Void]
							haxe.ds.StringMap<Bool>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Local baseVarName(21793):String:String]
					[Const:Bool] true
			[Block:Void]
				[Var this(21805):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:(key : String, value : String) -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(21805):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:(key : String, value : String) -> Void]
							haxe.ds.StringMap<String>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Binop:String]
						[Const:String] "_"
						+
						[Local baseVarName(21793):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_array"
			[Block:Void]
				[Var this(21810):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:(key : String, value : String) -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(21810):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:(key : String, value : String) -> Void]
							haxe.ds.StringMap<String>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Binop:String]
						[Binop:String]
							[Const:String] "_"
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_array"
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_array"
			[Block:Void]
				[Var this(21815):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:(key : String, value : String) -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(21815):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:(key : String, value : String) -> Void]
							haxe.ds.StringMap<String>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Binop:String]
						[Binop:String]
							[Const:String] "_"
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_counter"
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_counter"
			[Block:Void]
				[Var this(21820):haxe.IMap<String, String>]
					[Field:Map<String, String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Map<String, String>]
							reflaxe.elixir.ElixirCompiler
							currentFunctionParameterMap:Map<String, String>
				[Call:Void]
					[Field:(key : String, value : String) -> Void]
						[Cast:haxe.ds.StringMap<String>] [Local this(21820):haxe.IMap<String, String>:haxe.IMap<String, String>]
						[FInstance:(key : String, value : String) -> Void]
							haxe.ds.StringMap<String>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Local baseVarName(21793):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local baseVarName(21793):String:String]
						+
						[Const:String] "_array"

	public function saveAndClearMappings[Function:(variablesToClear : Array<String>) -> Map<String, String>]
		[Arg:Array<String>] [Local variablesToClear(30248):Array<String>]
		[Block:Dynamic]
			[Var savedState(30249):haxe.ds.Map<String, String>]
				[Block:haxe.ds.StringMap<String>]
					[Block:Void]
					[New:haxe.ds.StringMap<String>] haxe.ds.StringMap<String>
			[Block:Void]
				[Var `(30269):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(30269):Int:Int]
						<
						[Field:Int]
							[Local variablesToClear(30248):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var varName(30250):String]
							[Array:String]
								[Local variablesToClear(30248):Array<String>:Array<String>]
								[Local `(30269):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(30269):Int:Int]
						[If:Void]
							[Block:Bool]
								[Var this(30253):haxe.IMap<String, String>]
									[Field:Map<String, String>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.VariableMappingManager
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:Map<String, String>]
											reflaxe.elixir.ElixirCompiler
											currentFunctionParameterMap:Map<String, String>
								[Call:Bool]
									[Field:(key : String) -> Bool]
										[Cast:haxe.ds.StringMap<String>] [Local this(30253):haxe.IMap<String, String>:haxe.IMap<String, String>]
										[FInstance:(key : String) -> Bool]
											haxe.ds.StringMap<String>
											exists:(key : String) -> Bool
									[Local varName(30250):String:String]
							[Then:Bool] [Block:Bool]
								[Var mapping(30259):Null<String>]
									[Block:Null<String>]
										[Var this(30257):haxe.IMap<String, String>]
											[Field:Map<String, String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.VariableMappingManager
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:Map<String, String>]
													reflaxe.elixir.ElixirCompiler
													currentFunctionParameterMap:Map<String, String>
										[Call:Null<String>]
											[Field:(key : String) -> Null<String>]
												[Cast:haxe.ds.StringMap<String>] [Local this(30257):haxe.IMap<String, String>:haxe.IMap<String, String>]
												[FInstance:(key : String) -> Null<String>]
													haxe.ds.StringMap<String>
													get:(key : String) -> Null<haxe.ds.StringMap.T>
											[Local varName(30250):String:String]
								[Block:Void]
									[Call:Void]
										[Field:(key : String, value : String) -> Void]
											[Local savedState(30249):haxe.ds.Map<String, String>:haxe.ds.StringMap<String>]
											[FInstance:(key : String, value : String) -> Void]
												haxe.ds.StringMap<String>
												set:(key : String, value : haxe.ds.StringMap.T) -> Void
										[Local varName(30250):String:String]
										[Local mapping(30259):Null<String>:Null<String>]
								[Block:Bool]
									[Var this(30267):haxe.IMap<String, String>]
										[Field:Map<String, String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.VariableMappingManager
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:Map<String, String>]
												reflaxe.elixir.ElixirCompiler
												currentFunctionParameterMap:Map<String, String>
									[Call:Bool]
										[Field:(key : String) -> Bool]
											[Cast:haxe.ds.StringMap<String>] [Local this(30267):haxe.IMap<String, String>:haxe.IMap<String, String>]
											[FInstance:(key : String) -> Bool]
												haxe.ds.StringMap<String>
												remove:(key : String) -> Bool
										[Local varName(30250):String:String]
			[Call:Int]
				[Field:(x : Map<String, String>) -> Int]
					[Field:Array<Map<String, String>>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Array<Map<String, String>>]
							reflaxe.elixir.helpers.VariableMappingManager
							savedMappingStates:Array<Map<String, String>>
					[FInstance:(x : Map<String, String>) -> Int]
						Array<Map<String, String>>
						push:(x : Array.T) -> Int
				[Local savedState(30249):haxe.ds.Map<String, String>:haxe.ds.Map<String, String>]
			[Return:Dynamic] [Local savedState(30249):haxe.ds.Map<String, String>:haxe.ds.Map<String, String>]

	public function restoreMappings[Function:(savedState : Map<String, String>) -> Void]
		[Arg:Map<String, String>] [Local savedState(30270):Map<String, String>]
		[Block:Void]
			[Block:Void]
				[Var `(30274):KeyValueIterator<String, String>]
					[Cast:KeyValueIterator<String, String>]
						[New:haxe.iterators.MapKeyValueIterator<String, String>]
							haxe.iterators.MapKeyValueIterator<String, String>
							[Local savedState(30270):Map<String, String>:haxe.ds.StringMap<String>]
				[While:Void]
					[Call:Bool]
						[Field:() -> Bool]
							[Local `(30274):KeyValueIterator<String, String>:KeyValueIterator<String, String>]
							[FAnon:() -> Bool] hasNext:() -> Bool
					[Block:Void]
						[Var `(30275):{ value : String, key : String }]
							[Call:{ value : String, key : String }]
								[Field:() -> { value : String, key : String }]
									[Local `(30274):KeyValueIterator<String, String>:KeyValueIterator<String, String>]
									[FAnon:() -> { value : String, key : String }] next:() -> { value : String, key : String }
						[Var varName(30276):String]
							[Field:String]
								[Local `(30275):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] key:String
						[Var mapping(30277):String]
							[Field:String]
								[Local `(30275):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] value:String
						[Block:Void]
							[If:Void]
								[Binop:Bool]
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(s : String, end : String) -> Bool]
												[TypeExpr StringTools:Class<StringTools>]
												[FStatic:(s : String, end : String) -> Bool]
													StringTools
													endsWith:(s : String, end : String) -> Bool
											[Local mapping(30277):String:String]
											[Const:String] "_counter"
									||
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local varName(30276):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] "_counter"
											[Const:Null<Int>] null
										>=
										[Const:Int] 0
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var this(30280):haxe.IMap<String, String>]
											[Field:Map<String, String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.VariableMappingManager
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:Map<String, String>]
													reflaxe.elixir.ElixirCompiler
													currentFunctionParameterMap:Map<String, String>
										[Call:Void]
											[Field:(key : String, value : String) -> Void]
												[Cast:haxe.ds.StringMap<String>] [Local this(30280):haxe.IMap<String, String>:haxe.IMap<String, String>]
												[FInstance:(key : String, value : String) -> Void]
													haxe.ds.StringMap<String>
													set:(key : String, value : haxe.ds.StringMap.T) -> Void
											[Local varName(30276):String:String]
											[Local mapping(30277):String:String]
								[Else:Void] [Block:Void]

	public function transformVariableName[Function:(haxeVarName : String) -> String]
		[Arg:String] [Local haxeVarName(18045):String]
		[Block:Dynamic]
			[If:Void]
				[Block:Bool]
					[Var this(18048):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.VariableMappingManager
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(18048):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Local haxeVarName(18045):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var mapped(18054):Null<String>]
						[Block:Null<String>]
							[Var this(18052):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.VariableMappingManager] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.VariableMappingManager
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:Map<String, String>]
										reflaxe.elixir.ElixirCompiler
										currentFunctionParameterMap:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(18052):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local haxeVarName(18045):String:String]
					[Return:Dynamic] [Local mapped(18054):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Bool]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Bool]
							reflaxe.elixir.ElixirCompiler
							isCompilingCaseArm:Bool
					&&
					[Call:Bool]
						[Field:(varName : String) -> Bool]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:(varName : String) -> Bool]
								reflaxe.elixir.helpers.VariableMappingManager
								isScopeCrossingVariable:(varName : String) -> Bool
						[Local haxeVarName(18045):String:String]
				[Then:Void] [Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Bool]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Bool]
							reflaxe.elixir.ElixirCompiler
							isInLoopContext:Bool
					&&
					[Call:Bool]
						[Field:(varName : String) -> Bool]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:(varName : String) -> Bool]
								reflaxe.elixir.helpers.VariableMappingManager
								isArrayDesugaringVariable:(varName : String) -> Bool
						[Local haxeVarName(18045):String:String]
				[Then:Void] [Block:Void]
					[Var baseName(18059):String]
						[Call:String]
							[Field:(desugarVar : String) -> String]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:(desugarVar : String) -> String]
									reflaxe.elixir.helpers.VariableMappingManager
									getDesugaringBaseName:(desugarVar : String) -> String
							[Local haxeVarName(18045):String:String]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<Map<String, Bool>>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.VariableMappingManager
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Null<Map<String, Bool>>]
								reflaxe.elixir.ElixirCompiler
								liveViewInstanceVars:Null<Map<String, Bool>>
						!=
						[Const:Null<Map<String, Bool>>] null
					&&
					[Block:Bool]
						[Var this(18062):haxe.IMap<String, Bool>]
							[Field:Null<Map<String, Bool>>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.VariableMappingManager
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:Null<Map<String, Bool>>]
									reflaxe.elixir.ElixirCompiler
									liveViewInstanceVars:Null<Map<String, Bool>>
						[Call:Bool]
							[Field:(key : String) -> Bool]
								[Cast:haxe.ds.StringMap<Bool>] [Local this(18062):haxe.IMap<String, Bool>:haxe.IMap<String, Bool>]
								[FInstance:(key : String) -> Bool]
									haxe.ds.StringMap<Bool>
									exists:(key : String) -> Bool
							[Local haxeVarName(18045):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var snakeCaseName(18064):String]
						[Call:String]
							[Field:(camelCase : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
								[FStatic:(camelCase : String) -> String]
									reflaxe.elixir.helpers.NamingHelper
									toSnakeCase:(camelCase : String) -> String
							[Local haxeVarName(18045):String:String]
					[Return:Dynamic]
						[Binop:String]
							[Const:String] "socket.assigns."
							+
							[Local snakeCaseName(18064):String:String]
			[Var transformed(18065):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local haxeVarName(18045):String:String]
			[Return:Dynamic] [Local transformed(18065):String:String]

	public function isArrayDesugaringVariable[Function:(varName : String) -> Bool]
		[Arg:String] [Local varName(18056):String]
		[Block:Dynamic]
			[Var hasDesugaringPattern(18057):Bool]
				[Parenthesis:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Call:String]
								[Field:(index : Int) -> String]
									[Local varName(18056):String:String]
									[FInstance:(index : Int) -> String]
										String
										charAt:(index : Int) -> String
								[Const:Int] 0
							==
							[Const:String] "_"
						&&
						[Parenthesis:Bool]
							[Binop:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local varName(18056):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] "_array"
											[Const:Null<Int>] null
										>=
										[Const:Int] 0
									||
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local varName(18056):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] "_counter"
											[Const:Null<Int>] null
										>=
										[Const:Int] 0
								||
								[Call:Bool]
									[Field:(s : String) -> Bool]
										[New:EReg]
											EReg
											[Const:String] "^_g\\d*$"
											[Const:String] ""
										[FInstance:(s : String) -> Bool]
											EReg
											match:(s : String) -> Bool
									[Local varName(18056):String:String]
			[If:Void]
				[Binop:Bool]
					[Local hasDesugaringPattern(18057):Bool:Bool]
					&&
					[Field:Bool]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.VariableMappingManager
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Bool]
							reflaxe.elixir.ElixirCompiler
							isInEnumExtraction:Bool
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic] [Local hasDesugaringPattern(18057):Bool:Bool]

	public function getDesugaringBaseName[Function:(desugarVar : String) -> String]
		[Arg:String] [Local desugarVar(18058):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(index : Int) -> String]
							[Local desugarVar(18058):String:String]
							[FInstance:(index : Int) -> String]
								String
								charAt:(index : Int) -> String
						[Const:Int] 0
					==
					[Const:String] "_"
				[Then:String] [Block:String]
					[Binop:String]
						[Local desugarVar(18058):String:String]
						=
						[Call:String]
							[Field:(pos : Int, ?len : Null<Int>) -> String]
								[Local desugarVar(18058):String:String]
								[FInstance:(pos : Int, ?len : Null<Int>) -> String]
									String
									substr:(pos : Int, ?len : Null<Int>) -> String
							[Const:Int] 1
							[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local desugarVar(18058):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "_array"
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(pos : Int, ?len : Null<Int>) -> String]
								[Local desugarVar(18058):String:String]
								[FInstance:(pos : Int, ?len : Null<Int>) -> String]
									String
									substr:(pos : Int, ?len : Null<Int>) -> String
							[Const:Int] 0
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local desugarVar(18058):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "_array"
								[Const:Null<Int>] null
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local desugarVar(18058):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "_counter"
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(pos : Int, ?len : Null<Int>) -> String]
								[Local desugarVar(18058):String:String]
								[FInstance:(pos : Int, ?len : Null<Int>) -> String]
									String
									substr:(pos : Int, ?len : Null<Int>) -> String
							[Const:Int] 0
							[Call:Int]
								[Field:(str : String, ?startIndex : Null<Int>) -> Int]
									[Local desugarVar(18058):String:String]
									[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
										String
										indexOf:(str : String, ?startIndex : Null<Int>) -> Int
								[Const:String] "_counter"
								[Const:Null<Int>] null
			[Return:Dynamic] [Local desugarVar(18058):String:String]

	public function detectMappingConflicts[Function:() -> Array<String>]
		[Block:Dynamic]
			[Var conflicts(30283):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Block:Bool]
					[Var this(30286):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.VariableMappingManager
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(30286):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Const:String] "g"
				[Then:Void] [Block:Void]
					[Var gMapping(30292):Null<String>]
						[Block:Null<String>]
							[Var this(30290):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.VariableMappingManager] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.VariableMappingManager
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:Map<String, String>]
										reflaxe.elixir.ElixirCompiler
										currentFunctionParameterMap:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(30290):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "g"
					[If:Void]
						[Call:Bool]
							[Field:(s : String, end : String) -> Bool]
								[TypeExpr StringTools:Class<StringTools>]
								[FStatic:(s : String, end : String) -> Bool]
									StringTools
									endsWith:(s : String, end : String) -> Bool
							[Local gMapping(30292):Null<String>:Null<String>]
							[Const:String] "_counter"
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local conflicts(30283):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Binop:String]
									[Binop:String]
										[Const:String] "Problematic \"g\" -> \""
										+
										[Local gMapping(30292):Null<String>:Null<String>]
									+
									[Const:String] "\" mapping detected"
			[Block:Void]
				[Var `(30296):KeyValueIterator<String, String>]
					[Block:KeyValueIterator<String, String>]
						[Var this(30295):haxe.IMap<String, String>]
							[Field:Map<String, String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.VariableMappingManager
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:Map<String, String>]
									reflaxe.elixir.ElixirCompiler
									currentFunctionParameterMap:Map<String, String>
						[Cast:KeyValueIterator<String, String>]
							[New:haxe.iterators.MapKeyValueIterator<String, String>]
								haxe.iterators.MapKeyValueIterator<String, String>
								[Cast:haxe.ds.StringMap<String>] [Local this(30295):haxe.IMap<String, String>:haxe.IMap<String, String>]
				[While:Void]
					[Call:Bool]
						[Field:() -> Bool]
							[Local `(30296):KeyValueIterator<String, String>:KeyValueIterator<String, String>]
							[FAnon:() -> Bool] hasNext:() -> Bool
					[Block:Void]
						[Var `(30297):{ value : String, key : String }]
							[Call:{ value : String, key : String }]
								[Field:() -> { value : String, key : String }]
									[Local `(30296):KeyValueIterator<String, String>:KeyValueIterator<String, String>]
									[FAnon:() -> { value : String, key : String }] next:() -> { value : String, key : String }
						[Var key(30298):String]
							[Field:String]
								[Local `(30297):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] key:String
						[Var value(30299):String]
							[Field:String]
								[Local `(30297):{ value : String, key : String }:{ value : String, key : String }]
								[FAnon:String] value:String
						[Block:Void]
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Call:String]
											[Field:(index : Int) -> String]
												[Local key(30298):String:String]
												[FInstance:(index : Int) -> String]
													String
													charAt:(index : Int) -> String
											[Const:Int] 0
										==
										[Const:String] "_"
									&&
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local key(30298):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] "g"
											[Const:Null<Int>] null
										>=
										[Const:Int] 0
								[Then:Void] [Block:Void]
									[Var baseName(30300):String]
										[Call:String]
											[Field:(desugarVar : String) -> String]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:(desugarVar : String) -> String]
													reflaxe.elixir.helpers.VariableMappingManager
													getDesugaringBaseName:(desugarVar : String) -> String
											[Local key(30298):String:String]
									[If:Void]
										[Unop:Bool]
											!
											Prefix
											[Block:Bool]
												[Var this(30303):haxe.IMap<String, String>]
													[Field:Map<String, String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.VariableMappingManager] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.VariableMappingManager
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:Map<String, String>]
															reflaxe.elixir.ElixirCompiler
															currentFunctionParameterMap:Map<String, String>
												[Call:Bool]
													[Field:(key : String) -> Bool]
														[Cast:haxe.ds.StringMap<String>] [Local this(30303):haxe.IMap<String, String>:haxe.IMap<String, String>]
														[FInstance:(key : String) -> Bool]
															haxe.ds.StringMap<String>
															exists:(key : String) -> Bool
													[Local baseName(30300):String:String]
										[Then:Int] [Block:Int]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local conflicts(30283):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Binop:String]
													[Const:String] "Missing base mapping for desugaring variable: "
													+
													[Local key(30298):String:String]
			[Return:Dynamic] [Local conflicts(30283):Array<String>:Array<String>]

	public function isScopeCrossingVariable[Function:(varName : String) -> Bool]
		[Arg:String] [Local varName(18055):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Parenthesis:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Binop:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Binop:Bool]
											[Binop:Bool]
												[Call:Bool]
													[Field:(s : String, start : String) -> Bool]
														[TypeExpr StringTools:Class<StringTools>]
														[FStatic:(s : String, start : String) -> Bool]
															StringTools
															startsWith:(s : String, start : String) -> Bool
													[Local varName(18055):String:String]
													[Const:String] "temp_"
												||
												[Call:Bool]
													[Field:(s : String, start : String) -> Bool]
														[TypeExpr StringTools:Class<StringTools>]
														[FStatic:(s : String, start : String) -> Bool]
															StringTools
															startsWith:(s : String, start : String) -> Bool
													[Local varName(18055):String:String]
													[Const:String] "result_"
											||
											[Call:Bool]
												[Field:(s : String, start : String) -> Bool]
													[TypeExpr StringTools:Class<StringTools>]
													[FStatic:(s : String, start : String) -> Bool]
														StringTools
														startsWith:(s : String, start : String) -> Bool
												[Local varName(18055):String:String]
												[Const:String] "intermediate_"
										||
										[Binop:Bool]
											[Local varName(18055):String:String]
											==
											[Const:String] "temp_array"
									||
									[Binop:Bool]
										[Local varName(18055):String:String]
										==
										[Const:String] "temp_result"
								||
								[Binop:Bool]
									[Local varName(18055):String:String]
									==
									[Const:String] "temp_socket"
							||
							[Binop:Bool]
								[Local varName(18055):String:String]
								==
								[Const:String] "temp_string"
						||
						[Binop:Bool]
							[Local varName(18055):String:String]
							==
							[Const:String] "temp_number"

	public function generateOuterScopeDeclaration[Function:(varName : String) -> String]
		[Arg:String] [Local varName(24606):String]
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(varName : String) -> Bool]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:(varName : String) -> Bool]
							reflaxe.elixir.helpers.VariableMappingManager
							isScopeCrossingVariable:(varName : String) -> Bool
					[Local varName(24606):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local varName(24606):String:String]
							+
							[Const:String] " = nil"
			[Return:Dynamic] [Const:String] ""

	public function generateRequiredOuterScopeDeclarations[Function:(functionExpressions : Array<haxe.macro.TypedExpr>) -> Array<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local functionExpressions(24734):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var declarations(24735):Array<String>] [ArrayDecl:Array<String>]
			[Var scopeCrossingVars(24736):haxe.ds.Map<String, Bool>]
				[Block:haxe.ds.StringMap<Bool>]
					[Block:Void]
					[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Block:Void]
				[Var `(24786):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(24786):Int:Int]
						<
						[Field:Int]
							[Local functionExpressions(24734):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
					[Block:Void]
						[Var expr(24737):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local functionExpressions(24734):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local `(24786):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(24786):Int:Int]
						[Call:Void]
							[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
									reflaxe.elixir.helpers.VariableMappingManager
									findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
							[Local expr(24737):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local scopeCrossingVars(24736):haxe.ds.Map<String, Bool>:haxe.ds.Map<String, Bool>]
			[For:Void]
				[Local varName(24790):String]
				[Call:Iterator<String>]
					[Field:() -> Iterator<String>]
						[Local scopeCrossingVars(24736):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
						[FInstance:() -> Iterator<String>]
							haxe.ds.StringMap<Bool>
							keys:() -> Iterator<String>
				[Block:Void]
					[Var declaration(24791):String]
						[Call:String]
							[Field:(varName : String) -> String]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:(varName : String) -> String]
									reflaxe.elixir.helpers.VariableMappingManager
									generateOuterScopeDeclaration:(varName : String) -> String
							[Local varName(24790):String:String]
					[If:Void]
						[Binop:Bool]
							[Local declaration(24791):String:String]
							!=
							[Const:String] ""
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local declarations(24735):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Local declaration(24791):String:String]
			[Return:Dynamic] [Local declarations(24735):Array<String>:Array<String>]

	function findScopeCrossingVariables[Function:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local expr(24738):haxe.macro.TypedExpr]
		[Arg:Map<String, Bool>] [Local foundVars(24739):Map<String, Bool>]
		[Block:Void]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TVar(tvar, initExpr):
		if (isScopeCrossingVariable(tvar.name)) {
			foundVars.set(tvar.name, true);
		};
		if (initExpr != null) {
			findScopeCrossingVariables(initExpr, foundVars);
		};	
	case TIf(condExpr, ifExpr, elseExpr):
		findScopeCrossingVariables(condExpr, foundVars);
		findScopeCrossingVariables(ifExpr, foundVars);
		if (elseExpr != null) {
			findScopeCrossingVariables(elseExpr, foundVars);
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			findScopeCrossingVariables(e, foundVars);
		};	
	case TLocal(tvar):
		if (isScopeCrossingVariable(tvar.name)) {
			foundVars.set(tvar.name, true);
		};	
	default:
})
				[Block:Void]
					[Var `(24767):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(24738):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 1
							[Block:Void]
								[Var `(24768):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:Void]
									[Var tvar(24769):haxe.macro.TVar] [Local `(24768):haxe.macro.TVar:haxe.macro.TVar]
									[Block:Void]
										[If:Void]
											[Call:Bool]
												[Field:(varName : String) -> Bool]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:(varName : String) -> Bool]
														reflaxe.elixir.helpers.VariableMappingManager
														isScopeCrossingVariable:(varName : String) -> Bool
												[Field:String]
													[Local tvar(24769):haxe.macro.TVar:haxe.macro.TVar]
													[FAnon:String] name:String
											[Then:Void] [Block:Void]
												[Block:Void]
													[Var key(24770):String]
														[Field:String]
															[Local tvar(24769):haxe.macro.TVar:haxe.macro.TVar]
															[FAnon:String] name:String
													[Call:Void]
														[Field:(key : String, value : Bool) -> Void]
															[Local foundVars(24739):Map<String, Bool>:haxe.ds.StringMap<Bool>]
															[FInstance:(key : String, value : Bool) -> Void]
																haxe.ds.StringMap<Bool>
																set:(key : String, value : haxe.ds.StringMap.T) -> Void
														[Local key(24770):String:String]
														[Const:Bool] true
						[Case:Void]
							[Const:Int] 13
							[Block:Void]
								[Var `(24771):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										0
								[Var `(24772):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										1
								[Block:Void]
									[Var tvar(24773):haxe.macro.TVar] [Local `(24771):haxe.macro.TVar:haxe.macro.TVar]
									[Var initExpr(24774):Null<haxe.macro.TypedExpr>] [Local `(24772):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Void]
										[If:Void]
											[Call:Bool]
												[Field:(varName : String) -> Bool]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:(varName : String) -> Bool]
														reflaxe.elixir.helpers.VariableMappingManager
														isScopeCrossingVariable:(varName : String) -> Bool
												[Field:String]
													[Local tvar(24773):haxe.macro.TVar:haxe.macro.TVar]
													[FAnon:String] name:String
											[Then:Void] [Block:Void]
												[Block:Void]
													[Var key(24775):String]
														[Field:String]
															[Local tvar(24773):haxe.macro.TVar:haxe.macro.TVar]
															[FAnon:String] name:String
													[Call:Void]
														[Field:(key : String, value : Bool) -> Void]
															[Local foundVars(24739):Map<String, Bool>:haxe.ds.StringMap<Bool>]
															[FInstance:(key : String, value : Bool) -> Void]
																haxe.ds.StringMap<Bool>
																set:(key : String, value : haxe.ds.StringMap.T) -> Void
														[Local key(24775):String:String]
														[Const:Bool] true
										[If:Void]
											[Binop:Bool]
												[Local initExpr(24774):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Void] [Block:Void]
												[Call:Void]
													[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
														[Const:reflaxe.elixir.helpers.VariableMappingManager] this
														[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
															reflaxe.elixir.helpers.VariableMappingManager
															findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
													[Local initExpr(24774):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													[Local foundVars(24739):Map<String, Bool>:Map<String, Bool>]
						[Case:Void]
							[Const:Int] 14
							[Block:Void]
								[Var `(24776):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Void]
									[Var exprs(24777):Array<haxe.macro.TypedExpr>] [Local `(24776):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Block:Void]
											[Var `(24778):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(24778):Int:Int]
													<
													[Field:Int]
														[Local exprs(24777):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(24779):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(24777):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(24778):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(24778):Int:Int]
													[Call:Void]
														[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
															[Const:reflaxe.elixir.helpers.VariableMappingManager] this
															[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
																reflaxe.elixir.helpers.VariableMappingManager
																findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
														[Local e(24779):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local foundVars(24739):Map<String, Bool>:Map<String, Bool>]
						[Case:Void]
							[Const:Int] 16
							[Block:Void]
								[Var `(24780):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(24781):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(24782):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(24767):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Void]
									[Var condExpr(24783):haxe.macro.TypedExpr] [Local `(24780):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var ifExpr(24784):haxe.macro.TypedExpr] [Local `(24781):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var elseExpr(24785):Null<haxe.macro.TypedExpr>] [Local `(24782):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Void]
										[Call:Void]
											[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
													reflaxe.elixir.helpers.VariableMappingManager
													findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
											[Local condExpr(24783):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local foundVars(24739):Map<String, Bool>:Map<String, Bool>]
										[Call:Void]
											[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
													reflaxe.elixir.helpers.VariableMappingManager
													findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
											[Local ifExpr(24784):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local foundVars(24739):Map<String, Bool>:Map<String, Bool>]
										[If:Void]
											[Binop:Bool]
												[Local elseExpr(24785):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Void] [Block:Void]
												[Call:Void]
													[Field:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
														[Const:reflaxe.elixir.helpers.VariableMappingManager] this
														[FInstance:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void]
															reflaxe.elixir.helpers.VariableMappingManager
															findScopeCrossingVariables:(expr : haxe.macro.TypedExpr, foundVars : Map<String, Bool>) -> Void
													[Local elseExpr(24785):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													[Local foundVars(24739):Map<String, Bool>:Map<String, Bool>]
						[Default:Void] [Block:Void]

	public function enterScope[Function:(scopeType : String) -> Void]
		[Arg:String] [Local scopeType(30305):String]
		[Block:Void]
			[Call:Int]
				[Field:(x : reflaxe.elixir.helpers.VariableMappingContext) -> Int]
					[Field:Array<reflaxe.elixir.helpers.VariableMappingContext>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Array<reflaxe.elixir.helpers.VariableMappingContext>]
							reflaxe.elixir.helpers.VariableMappingManager
							savedContextStates:Array<reflaxe.elixir.helpers.VariableMappingContext>
					[FInstance:(x : reflaxe.elixir.helpers.VariableMappingContext) -> Int]
						Array<reflaxe.elixir.helpers.VariableMappingContext>
						push:(x : Array.T) -> Int
				[Block:reflaxe.elixir.helpers.VariableMappingContext]
					[New:reflaxe.elixir.helpers.VariableMappingContext]
						reflaxe.elixir.helpers.VariableMappingContext
						[Field:Null<String>]
							[Field:reflaxe.elixir.helpers.VariableMappingContext]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
									reflaxe.elixir.helpers.VariableMappingManager
									compilationContext:reflaxe.elixir.helpers.VariableMappingContext
							[FInstance:Null<String>]
								reflaxe.elixir.helpers.VariableMappingContext
								currentFunction:Null<String>
						[Field:Null<haxe.macro.ClassType>]
							[Field:reflaxe.elixir.helpers.VariableMappingContext]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
									reflaxe.elixir.helpers.VariableMappingManager
									compilationContext:reflaxe.elixir.helpers.VariableMappingContext
							[FInstance:Null<haxe.macro.ClassType>]
								reflaxe.elixir.helpers.VariableMappingContext
								currentClass:Null<haxe.macro.ClassType>
						[Field:Null<String>]
							[Field:reflaxe.elixir.helpers.VariableMappingContext]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
									reflaxe.elixir.helpers.VariableMappingManager
									compilationContext:reflaxe.elixir.helpers.VariableMappingContext
							[FInstance:Null<String>]
								reflaxe.elixir.helpers.VariableMappingContext
								currentModule:Null<String>
						[Cast:Null<Int>]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									scopeDepth:Int
						[Cast:Null<Int>]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									loopDepth:Int
						[Cast:Null<Int>]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									conditionalDepth:Int
						[Cast:Null<Bool>]
							[Field:Bool]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Bool]
									reflaxe.elixir.helpers.VariableMappingContext
									isInLiveViewContext:Bool
						[Cast:Null<Bool>]
							[Field:Bool]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Bool]
									reflaxe.elixir.helpers.VariableMappingContext
									isInGenServerContext:Bool
						[Cast:Null<Bool>]
							[Field:Bool]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Bool]
									reflaxe.elixir.helpers.VariableMappingContext
									isInSchemaContext:Bool
			[Var fh(30306):reflaxe.elixir.helpers.VariableMappingContext]
				[Field:reflaxe.elixir.helpers.VariableMappingContext]
					[Const:reflaxe.elixir.helpers.VariableMappingManager] this
					[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
						reflaxe.elixir.helpers.VariableMappingManager
						compilationContext:reflaxe.elixir.helpers.VariableMappingContext
			[Unop:Int]
				++
				Postfix
				[Field:Int]
					[Local fh(30306):reflaxe.elixir.helpers.VariableMappingContext:reflaxe.elixir.helpers.VariableMappingContext]
					[FInstance:Int]
						reflaxe.elixir.helpers.VariableMappingContext
						scopeDepth:Int
			[Meta:Void]
				:ast(switch (scopeType.toLowerCase()) {
	case "loop" | "while" | "for":
		compilationContext.loopDepth++;	
	case "if" | "conditional" | "switch" | "case":
		compilationContext.conditionalDepth++;	
	default:
})
				[Block:Void]
					[Var `(30310):String]
						[Call:String]
							[Field:() -> String]
								[Local scopeType(30305):String:String]
								[FInstance:() -> String]
									String
									toLowerCase:() -> String
					[Switch:Void]
						[Local `(30310):String:String]
						[Case:Int]
							[Const:String] "case"
							[Const:String] "conditional"
							[Const:String] "if"
							[Const:String] "switch"
							[Block:Int]
								[Block:Int]
									[Var fh(30311):reflaxe.elixir.helpers.VariableMappingContext]
										[Field:reflaxe.elixir.helpers.VariableMappingContext]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
												reflaxe.elixir.helpers.VariableMappingManager
												compilationContext:reflaxe.elixir.helpers.VariableMappingContext
									[Unop:Int]
										++
										Postfix
										[Field:Int]
											[Local fh(30311):reflaxe.elixir.helpers.VariableMappingContext:reflaxe.elixir.helpers.VariableMappingContext]
											[FInstance:Int]
												reflaxe.elixir.helpers.VariableMappingContext
												conditionalDepth:Int
						[Case:Int]
							[Const:String] "for"
							[Const:String] "loop"
							[Const:String] "while"
							[Block:Int]
								[Block:Int]
									[Var fh(30312):reflaxe.elixir.helpers.VariableMappingContext]
										[Field:reflaxe.elixir.helpers.VariableMappingContext]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
												reflaxe.elixir.helpers.VariableMappingManager
												compilationContext:reflaxe.elixir.helpers.VariableMappingContext
									[Unop:Int]
										++
										Postfix
										[Field:Int]
											[Local fh(30312):reflaxe.elixir.helpers.VariableMappingContext:reflaxe.elixir.helpers.VariableMappingContext]
											[FInstance:Int]
												reflaxe.elixir.helpers.VariableMappingContext
												loopDepth:Int
						[Default:Void] [Block:Void]

	public function exitScope[Function:(scopeType : String) -> Void]
		[Arg:String] [Local scopeType(30313):String]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Field:Array<reflaxe.elixir.helpers.VariableMappingContext>]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:Array<reflaxe.elixir.helpers.VariableMappingContext>]
								reflaxe.elixir.helpers.VariableMappingManager
								savedContextStates:Array<reflaxe.elixir.helpers.VariableMappingContext>
						[FInstance:Int]
							Array<reflaxe.elixir.helpers.VariableMappingContext>
							length:Int
					>
					[Const:Int] 0
				[Then:reflaxe.elixir.helpers.VariableMappingContext] [Block:reflaxe.elixir.helpers.VariableMappingContext]
					[Binop:reflaxe.elixir.helpers.VariableMappingContext]
						[Field:reflaxe.elixir.helpers.VariableMappingContext]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
								reflaxe.elixir.helpers.VariableMappingManager
								compilationContext:reflaxe.elixir.helpers.VariableMappingContext
						=
						[Call:Null<reflaxe.elixir.helpers.VariableMappingContext>]
							[Field:() -> Null<reflaxe.elixir.helpers.VariableMappingContext>]
								[Field:Array<reflaxe.elixir.helpers.VariableMappingContext>]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:Array<reflaxe.elixir.helpers.VariableMappingContext>]
										reflaxe.elixir.helpers.VariableMappingManager
										savedContextStates:Array<reflaxe.elixir.helpers.VariableMappingContext>
								[FInstance:() -> Null<reflaxe.elixir.helpers.VariableMappingContext>]
									Array<reflaxe.elixir.helpers.VariableMappingContext>
									pop:() -> Null<Array.T>
				[Else:Void] [Block:Void]
					[Binop:Int]
						[Field:Int]
							[Field:reflaxe.elixir.helpers.VariableMappingContext]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
									reflaxe.elixir.helpers.VariableMappingManager
									compilationContext:reflaxe.elixir.helpers.VariableMappingContext
							[FInstance:Int]
								reflaxe.elixir.helpers.VariableMappingContext
								scopeDepth:Int
						=
						[Call:Int]
							[Field:(x : Float) -> Int]
								[TypeExpr Std:Class<Std>]
								[FStatic:(x : Float) -> Int]
									Std
									int:(x : Float) -> Int
							[Call:Float]
								[Field:(a : Float, b : Float) -> Float]
									[TypeExpr Math:Class<Math>]
									[FStatic:(a : Float, b : Float) -> Float]
										Math
										max:(a : Float, b : Float) -> Float
								[Const:Int] 0
								[Binop:Int]
									[Field:Int]
										[Field:reflaxe.elixir.helpers.VariableMappingContext]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
												reflaxe.elixir.helpers.VariableMappingManager
												compilationContext:reflaxe.elixir.helpers.VariableMappingContext
										[FInstance:Int]
											reflaxe.elixir.helpers.VariableMappingContext
											scopeDepth:Int
									-
									[Const:Int] 1
					[Meta:Void]
						:ast(switch (scopeType.toLowerCase()) {
	case "loop" | "while" | "for":
		compilationContext.loopDepth = Std.int(Math.max(0, compilationContext.loopDepth - 1));	
	case "if" | "conditional" | "switch" | "case":
		compilationContext.conditionalDepth = Std.int(Math.max(0, compilationContext.conditionalDepth - 1));	
})
						[Block:Void]
							[Var `(30315):String]
								[Call:String]
									[Field:() -> String]
										[Local scopeType(30313):String:String]
										[FInstance:() -> String]
											String
											toLowerCase:() -> String
							[Switch:Void]
								[Local `(30315):String:String]
								[Case:Int]
									[Const:String] "case"
									[Const:String] "conditional"
									[Const:String] "if"
									[Const:String] "switch"
									[Block:Int]
										[Block:Int]
											[Binop:Int]
												[Field:Int]
													[Field:reflaxe.elixir.helpers.VariableMappingContext]
														[Const:reflaxe.elixir.helpers.VariableMappingManager] this
														[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
															reflaxe.elixir.helpers.VariableMappingManager
															compilationContext:reflaxe.elixir.helpers.VariableMappingContext
													[FInstance:Int]
														reflaxe.elixir.helpers.VariableMappingContext
														conditionalDepth:Int
												=
												[Call:Int]
													[Field:(x : Float) -> Int]
														[TypeExpr Std:Class<Std>]
														[FStatic:(x : Float) -> Int]
															Std
															int:(x : Float) -> Int
													[Call:Float]
														[Field:(a : Float, b : Float) -> Float]
															[TypeExpr Math:Class<Math>]
															[FStatic:(a : Float, b : Float) -> Float]
																Math
																max:(a : Float, b : Float) -> Float
														[Const:Int] 0
														[Binop:Int]
															[Field:Int]
																[Field:reflaxe.elixir.helpers.VariableMappingContext]
																	[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																	[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																		reflaxe.elixir.helpers.VariableMappingManager
																		compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																[FInstance:Int]
																	reflaxe.elixir.helpers.VariableMappingContext
																	conditionalDepth:Int
															-
															[Const:Int] 1
								[Case:Int]
									[Const:String] "for"
									[Const:String] "loop"
									[Const:String] "while"
									[Block:Int]
										[Block:Int]
											[Binop:Int]
												[Field:Int]
													[Field:reflaxe.elixir.helpers.VariableMappingContext]
														[Const:reflaxe.elixir.helpers.VariableMappingManager] this
														[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
															reflaxe.elixir.helpers.VariableMappingManager
															compilationContext:reflaxe.elixir.helpers.VariableMappingContext
													[FInstance:Int]
														reflaxe.elixir.helpers.VariableMappingContext
														loopDepth:Int
												=
												[Call:Int]
													[Field:(x : Float) -> Int]
														[TypeExpr Std:Class<Std>]
														[FStatic:(x : Float) -> Int]
															Std
															int:(x : Float) -> Int
													[Call:Float]
														[Field:(a : Float, b : Float) -> Float]
															[TypeExpr Math:Class<Math>]
															[FStatic:(a : Float, b : Float) -> Float]
																Math
																max:(a : Float, b : Float) -> Float
														[Const:Int] 0
														[Binop:Int]
															[Field:Int]
																[Field:reflaxe.elixir.helpers.VariableMappingContext]
																	[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																	[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																		reflaxe.elixir.helpers.VariableMappingManager
																		compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																[FInstance:Int]
																	reflaxe.elixir.helpers.VariableMappingContext
																	loopDepth:Int
															-
															[Const:Int] 1

	@:value({ pos : null })
	public function trackVariableDeclaration[Function:(varName : String, transformedName : String, ?pos : Null<haxe.macro.Position>) -> Void]
		[Arg:String] [Local varName(30316):String]
		[Arg:String] [Local transformedName(30317):String]
		[Arg:Null<haxe.macro.Position>]
			[Local pos(30318):Null<haxe.macro.Position>]
			[Const:Null<haxe.macro.Position>] null
		[Block:Void]
			[Block:Void]
				[Var this(30321):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
					[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							reflaxe.elixir.helpers.VariableMappingManager
							variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
				[Var value(30323):reflaxe.elixir.helpers.VariableDeclarationInfo]
					[New:reflaxe.elixir.helpers.VariableDeclarationInfo]
						reflaxe.elixir.helpers.VariableDeclarationInfo
						[Field:Int]
							[Field:reflaxe.elixir.helpers.VariableMappingContext]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
									reflaxe.elixir.helpers.VariableMappingManager
									compilationContext:reflaxe.elixir.helpers.VariableMappingContext
							[FInstance:Int]
								reflaxe.elixir.helpers.VariableMappingContext
								scopeDepth:Int
						[Binop:Bool]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									conditionalDepth:Int
							>
							[Const:Int] 0
						[Binop:Bool]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									loopDepth:Int
							>
							[Const:Int] 0
						[Cast:Null<Bool>] [Const:Bool] false
						[Local transformedName(30317):String:String]
						[Local varName(30316):String:String]
						[Local pos(30318):Null<haxe.macro.Position>:Null<haxe.macro.Position>]
						[ArrayDecl:Array<haxe.macro.Position>]
				[Call:Void]
					[Field:(key : String, value : reflaxe.elixir.helpers.VariableDeclarationInfo) -> Void]
						[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] [Local this(30321):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[FInstance:(key : String, value : reflaxe.elixir.helpers.VariableDeclarationInfo) -> Void]
							haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>
							set:(key : String, value : haxe.ds.StringMap.T) -> Void
					[Local varName(30316):String:String]
					[Local value(30323):reflaxe.elixir.helpers.VariableDeclarationInfo:reflaxe.elixir.helpers.VariableDeclarationInfo]

	@:value({ pos : null })
	public function trackVariableUsage[Function:(varName : String, ?pos : Null<haxe.macro.Position>) -> Void]
		[Arg:String] [Local varName(30324):String]
		[Arg:Null<haxe.macro.Position>]
			[Local pos(30325):Null<haxe.macro.Position>]
			[Const:Null<haxe.macro.Position>] null
		[Block:Void]
			[If:Void]
				[Block:Bool]
					[Var this(30328):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[Const:reflaxe.elixir.helpers.VariableMappingManager] this
							[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								reflaxe.elixir.helpers.VariableMappingManager
								variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] [Local this(30328):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>
								exists:(key : String) -> Bool
						[Local varName(30324):String:String]
				[Then:Void] [Block:Void]
					[Var declInfo(30334):Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[Block:Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[Var this(30332):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
										reflaxe.elixir.helpers.VariableMappingManager
										variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
							[Call:Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
								[Field:(key : String) -> Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] [Local this(30332):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[FInstance:(key : String) -> Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
										haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local varName(30324):String:String]
					[If:Void]
						[Binop:Bool]
							[Local pos(30325):Null<haxe.macro.Position>:Null<haxe.macro.Position>]
							!=
							[Const:Null<haxe.macro.Position>] null
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : haxe.macro.Position) -> Int]
									[Field:Array<haxe.macro.Position>]
										[Local declInfo(30334):Null<reflaxe.elixir.helpers.VariableDeclarationInfo>:Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
										[FInstance:Array<haxe.macro.Position>]
											reflaxe.elixir.helpers.VariableDeclarationInfo
											usagePoints:Array<haxe.macro.Position>
									[FInstance:(x : haxe.macro.Position) -> Int]
										Array<haxe.macro.Position>
										push:(x : Array.T) -> Int
								[Local pos(30325):Null<haxe.macro.Position>:Null<haxe.macro.Position>]
					[If:Void]
						[Binop:Bool]
							[Field:Int]
								[Field:reflaxe.elixir.helpers.VariableMappingContext]
									[Const:reflaxe.elixir.helpers.VariableMappingManager] this
									[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
										reflaxe.elixir.helpers.VariableMappingManager
										compilationContext:reflaxe.elixir.helpers.VariableMappingContext
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableMappingContext
									scopeDepth:Int
							<
							[Field:Int]
								[Local declInfo(30334):Null<reflaxe.elixir.helpers.VariableDeclarationInfo>:Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
								[FInstance:Int]
									reflaxe.elixir.helpers.VariableDeclarationInfo
									declaredAtScopeDepth:Int
						[Then:Void] [Block:Void]
							[Binop:Bool]
								[Field:Bool]
									[Local declInfo(30334):Null<reflaxe.elixir.helpers.VariableDeclarationInfo>:Null<reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[FInstance:Bool]
										reflaxe.elixir.helpers.VariableDeclarationInfo
										usedOutsideDeclarationScope:Bool
								=
								[Const:Bool] true
							[If:Void]
								[Binop:Bool]
									[Call:Int]
										[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
											[Field:Array<String>]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:Array<String>]
													reflaxe.elixir.helpers.VariableMappingManager
													scopeCrossingVariables:Array<String>
											[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
												Array<String>
												indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
										[Local varName(30324):String:String]
										[Const:Null<Int>] null
									==
									[Const:Int] -1
								[Then:Int] [Block:Int]
									[Call:Int]
										[Field:(x : String) -> Int]
											[Field:Array<String>]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:Array<String>]
													reflaxe.elixir.helpers.VariableMappingManager
													scopeCrossingVariables:Array<String>
											[FInstance:(x : String) -> Int]
												Array<String>
												push:(x : Array.T) -> Int
										[Local varName(30324):String:String]

	public function setFrameworkContext[Function:(framework : String) -> Void]
		[Arg:String] [Local framework(30335):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (framework.toLowerCase()) {
	case "liveview" | "phoenix_live_view":
		compilationContext.isInLiveViewContext = true;	
	case "genserver" | "gen_server":
		compilationContext.isInGenServerContext = true;	
	case "schema" | "ecto" | "changeset":
		compilationContext.isInSchemaContext = true;	
})
				[Block:Void]
					[Var `(30337):String]
						[Call:String]
							[Field:() -> String]
								[Local framework(30335):String:String]
								[FInstance:() -> String]
									String
									toLowerCase:() -> String
					[Switch:Void]
						[Local `(30337):String:String]
						[Case:Bool]
							[Const:String] "changeset"
							[Const:String] "ecto"
							[Const:String] "schema"
							[Block:Bool]
								[Block:Bool]
									[Binop:Bool]
										[Field:Bool]
											[Field:reflaxe.elixir.helpers.VariableMappingContext]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
													reflaxe.elixir.helpers.VariableMappingManager
													compilationContext:reflaxe.elixir.helpers.VariableMappingContext
											[FInstance:Bool]
												reflaxe.elixir.helpers.VariableMappingContext
												isInSchemaContext:Bool
										=
										[Const:Bool] true
						[Case:Bool]
							[Const:String] "gen_server"
							[Const:String] "genserver"
							[Block:Bool]
								[Block:Bool]
									[Binop:Bool]
										[Field:Bool]
											[Field:reflaxe.elixir.helpers.VariableMappingContext]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
													reflaxe.elixir.helpers.VariableMappingManager
													compilationContext:reflaxe.elixir.helpers.VariableMappingContext
											[FInstance:Bool]
												reflaxe.elixir.helpers.VariableMappingContext
												isInGenServerContext:Bool
										=
										[Const:Bool] true
						[Case:Bool]
							[Const:String] "liveview"
							[Const:String] "phoenix_live_view"
							[Block:Bool]
								[Block:Bool]
									[Binop:Bool]
										[Field:Bool]
											[Field:reflaxe.elixir.helpers.VariableMappingContext]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
													reflaxe.elixir.helpers.VariableMappingManager
													compilationContext:reflaxe.elixir.helpers.VariableMappingContext
											[FInstance:Bool]
												reflaxe.elixir.helpers.VariableMappingContext
												isInLiveViewContext:Bool
										=
										[Const:Bool] true

	public function getScopeCrossingVariables[Function:() -> Array<String>]
		[Block:Dynamic]
			[Var result(30338):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(30342):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
					[Block:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[Var this(30341):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									reflaxe.elixir.helpers.VariableMappingManager
									variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
						[Cast:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[New:haxe.iterators.MapKeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								haxe.iterators.MapKeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
								[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] [Local this(30341):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
				[While:Void]
					[Call:Bool]
						[Field:() -> Bool]
							[Local `(30342):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[FAnon:() -> Bool] hasNext:() -> Bool
					[Block:Void]
						[Var `(30343):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
							[Call:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[Field:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
									[Local `(30342):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[FAnon:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }] next:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }
						[Var varName(30344):String]
							[Field:String]
								[Local `(30343):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[FAnon:String] key:String
						[Var declInfo(30345):reflaxe.elixir.helpers.VariableDeclarationInfo]
							[Field:reflaxe.elixir.helpers.VariableDeclarationInfo]
								[Local `(30343):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[FAnon:reflaxe.elixir.helpers.VariableDeclarationInfo] value:reflaxe.elixir.helpers.VariableDeclarationInfo
						[Block:Void]
							[If:Void]
								[Field:Bool]
									[Local declInfo(30345):reflaxe.elixir.helpers.VariableDeclarationInfo:reflaxe.elixir.helpers.VariableDeclarationInfo]
									[FInstance:Bool]
										reflaxe.elixir.helpers.VariableDeclarationInfo
										usedOutsideDeclarationScope:Bool
								[Then:Int] [Block:Int]
									[Call:Int]
										[Field:(x : String) -> Int]
											[Local result(30338):Array<String>:Array<String>]
											[FInstance:(x : String) -> Int]
												Array<String>
												push:(x : Array.T) -> Int
										[Local varName(30344):String:String]
			[Return:Dynamic]
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local result(30338):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Field:Array<String>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Array<String>]
							reflaxe.elixir.helpers.VariableMappingManager
							scopeCrossingVariables:Array<String>

	@:value({ compiledBody : null })
	public function generateAllRequiredDeclarations[Function:(?compiledBody : Null<String>) -> Array<String>]
		[Arg:Null<String>]
			[Local compiledBody(24592):Null<String>]
			[Const:Null<String>] null
		[Block:Dynamic]
			[Var declarations(24593):Array<String>] [ArrayDecl:Array<String>]
			[Var processed(24594):haxe.ds.Map<String, Bool>]
				[Block:haxe.ds.StringMap<Bool>]
					[Block:Void]
					[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Block:Void]
				[Var `(24598):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
					[Block:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
						[Var this(24597):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									reflaxe.elixir.helpers.VariableMappingManager
									variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
						[Cast:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[New:haxe.iterators.MapKeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
								haxe.iterators.MapKeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
								[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.VariableDeclarationInfo>] [Local this(24597):haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:haxe.IMap<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
				[While:Void]
					[Call:Bool]
						[Field:() -> Bool]
							[Local `(24598):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
							[FAnon:() -> Bool] hasNext:() -> Bool
					[Block:Void]
						[Var `(24599):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
							[Call:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[Field:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
									[Local `(24598):KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>:KeyValueIterator<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
									[FAnon:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }] next:() -> { value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }
						[Var varName(24600):String]
							[Field:String]
								[Local `(24599):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[FAnon:String] key:String
						[Var declInfo(24601):reflaxe.elixir.helpers.VariableDeclarationInfo]
							[Field:reflaxe.elixir.helpers.VariableDeclarationInfo]
								[Local `(24599):{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }:{ value : reflaxe.elixir.helpers.VariableDeclarationInfo, key : String }]
								[FAnon:reflaxe.elixir.helpers.VariableDeclarationInfo] value:reflaxe.elixir.helpers.VariableDeclarationInfo
						[Block:Void]
							[If:Void]
								[Binop:Bool]
									[Field:Bool]
										[Local declInfo(24601):reflaxe.elixir.helpers.VariableDeclarationInfo:reflaxe.elixir.helpers.VariableDeclarationInfo]
										[FInstance:Bool]
											reflaxe.elixir.helpers.VariableDeclarationInfo
											usedOutsideDeclarationScope:Bool
									&&
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(key : String) -> Bool]
												[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
												[FInstance:(key : String) -> Bool]
													haxe.ds.StringMap<Bool>
													exists:(key : String) -> Bool
											[Local varName(24600):String:String]
								[Then:Void] [Block:Void]
									[Var declaration(24607):String]
										[Call:String]
											[Field:(varName : String) -> String]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:(varName : String) -> String]
													reflaxe.elixir.helpers.VariableMappingManager
													generateOuterScopeDeclaration:(varName : String) -> String
											[Field:String]
												[Local declInfo(24601):reflaxe.elixir.helpers.VariableDeclarationInfo:reflaxe.elixir.helpers.VariableDeclarationInfo]
												[FInstance:String]
													reflaxe.elixir.helpers.VariableDeclarationInfo
													transformedName:String
									[If:Void]
										[Binop:Bool]
											[Local declaration(24607):String:String]
											!=
											[Const:String] ""
										[Then:Void] [Block:Void]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local declarations(24593):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Local declaration(24607):String:String]
											[Block:Void]
												[Call:Void]
													[Field:(key : String, value : Bool) -> Void]
														[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
														[FInstance:(key : String, value : Bool) -> Void]
															haxe.ds.StringMap<Bool>
															set:(key : String, value : haxe.ds.StringMap.T) -> Void
													[Local varName(24600):String:String]
													[Const:Bool] true
			[Block:Void]
				[Var `(24625):Int] [Const:Int] 0
				[Var `(24626):Array<String>]
					[Field:Array<String>]
						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
						[FInstance:Array<String>]
							reflaxe.elixir.helpers.VariableMappingManager
							scopeCrossingVariables:Array<String>
				[While:Void]
					[Binop:Bool]
						[Local `(24625):Int:Int]
						<
						[Field:Int]
							[Local `(24626):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var varName(24613):String]
							[Array:String]
								[Local `(24626):Array<String>:Array<String>]
								[Local `(24625):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(24625):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Call:Bool]
									[Field:(key : String) -> Bool]
										[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
										[FInstance:(key : String) -> Bool]
											haxe.ds.StringMap<Bool>
											exists:(key : String) -> Bool
									[Local varName(24613):String:String]
							[Then:Void] [Block:Void]
								[Var transformedName(24618):String]
									[Call:String]
										[Field:(haxeVarName : String) -> String]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:(haxeVarName : String) -> String]
												reflaxe.elixir.helpers.VariableMappingManager
												transformVariableName:(haxeVarName : String) -> String
										[Local varName(24613):String:String]
								[Var declaration(24619):String]
									[Call:String]
										[Field:(varName : String) -> String]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:(varName : String) -> String]
												reflaxe.elixir.helpers.VariableMappingManager
												generateOuterScopeDeclaration:(varName : String) -> String
										[Local transformedName(24618):String:String]
								[If:Void]
									[Binop:Bool]
										[Local declaration(24619):String:String]
										!=
										[Const:String] ""
									[Then:Void] [Block:Void]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local declarations(24593):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Local declaration(24619):String:String]
										[Block:Void]
											[Call:Void]
												[Field:(key : String, value : Bool) -> Void]
													[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
													[FInstance:(key : String, value : Bool) -> Void]
														haxe.ds.StringMap<Bool>
														set:(key : String, value : haxe.ds.StringMap.T) -> Void
												[Local varName(24613):String:String]
												[Const:Bool] true
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local compiledBody(24592):Null<String>:Null<String>]
						!=
						[Const:Null<String>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Local declarations(24593):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
						==
						[Const:Int] 0
				[Then:Void] [Block:Void]
					[Var tempVariables(24654):Array<String>]
						[Call:Array<String>]
							[Field:(compiledBody : String) -> Array<String>]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:(compiledBody : String) -> Array<String>]
									reflaxe.elixir.helpers.VariableMappingManager
									scanCompiledBodyForTempVariables:(compiledBody : String) -> Array<String>
							[Local compiledBody(24592):Null<String>:Null<String>]
					[Block:Void]
						[Var `(24666):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(24666):Int:Int]
								<
								[Field:Int]
									[Local tempVariables(24654):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var varName(24655):String]
									[Array:String]
										[Local tempVariables(24654):Array<String>:Array<String>]
										[Local `(24666):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(24666):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Unop:Bool]
											!
											Prefix
											[Call:Bool]
												[Field:(key : String) -> Bool]
													[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
													[FInstance:(key : String) -> Bool]
														haxe.ds.StringMap<Bool>
														exists:(key : String) -> Bool
												[Local varName(24655):String:String]
										&&
										[Call:Bool]
											[Field:(varName : String) -> Bool]
												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
												[FInstance:(varName : String) -> Bool]
													reflaxe.elixir.helpers.VariableMappingManager
													isScopeCrossingVariable:(varName : String) -> Bool
											[Local varName(24655):String:String]
									[Then:Void] [Block:Void]
										[Var declaration(24660):String]
											[Call:String]
												[Field:(varName : String) -> String]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:(varName : String) -> String]
														reflaxe.elixir.helpers.VariableMappingManager
														generateOuterScopeDeclaration:(varName : String) -> String
												[Local varName(24655):String:String]
										[If:Void]
											[Binop:Bool]
												[Local declaration(24660):String:String]
												!=
												[Const:String] ""
											[Then:Void] [Block:Void]
												[Call:Int]
													[Field:(x : String) -> Int]
														[Local declarations(24593):Array<String>:Array<String>]
														[FInstance:(x : String) -> Int]
															Array<String>
															push:(x : Array.T) -> Int
													[Local declaration(24660):String:String]
												[Block:Void]
													[Call:Void]
														[Field:(key : String, value : Bool) -> Void]
															[Local processed(24594):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
															[FInstance:(key : String, value : Bool) -> Void]
																haxe.ds.StringMap<Bool>
																set:(key : String, value : haxe.ds.StringMap.T) -> Void
														[Local varName(24655):String:String]
														[Const:Bool] true
			[Return:Dynamic] [Local declarations(24593):Array<String>:Array<String>]

	function scanCompiledBodyForTempVariables[Function:(compiledBody : String) -> Array<String>]
		[Arg:String] [Local compiledBody(24627):String]
		[Block:Dynamic]
			[Var tempVars(24628):Array<String>] [ArrayDecl:Array<String>]
			[Var processed(24629):haxe.ds.Map<String, Bool>]
				[Block:haxe.ds.StringMap<Bool>]
					[Block:Void]
					[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Var assignmentPattern(24630):EReg]
				[New:EReg]
					EReg
					[Const:String] "temp_\\w+ ="
					[Const:String] "g"
			[Var pos(24631):Int] [Const:Int] 0
			[While:Void]
				[Call:Bool]
					[Field:(s : String, pos : Int, ?len : Int) -> Bool]
						[Local assignmentPattern(24630):EReg:EReg]
						[FInstance:(s : String, pos : Int, ?len : Int) -> Bool]
							EReg
							matchSub:(s : String, pos : Int, ?len : Int) -> Bool
					[Local compiledBody(24627):String:String]
					[Local pos(24631):Int:Int]
					[Const:Null<Int>] null
				[Block:Int]
					[Var match(24632):String]
						[Call:String]
							[Field:(n : Int) -> String]
								[Local assignmentPattern(24630):EReg:EReg]
								[FInstance:(n : Int) -> String]
									EReg
									matched:(n : Int) -> String
							[Const:Int] 0
					[Var varName(24633):String]
						[Call:String]
							[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
								[Local match(24632):String:String]
								[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									String
									substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
							[Const:Int] 0
							[Binop:Int]
								[Field:Int]
									[Local match(24632):String:String]
									[FInstance:Int]
										String
										length:Int
								-
								[Const:Int] 2
					[If:Void]
						[Unop:Bool]
							!
							Prefix
							[Call:Bool]
								[Field:(key : String) -> Bool]
									[Local processed(24629):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
									[FInstance:(key : String) -> Bool]
										haxe.ds.StringMap<Bool>
										exists:(key : String) -> Bool
								[Local varName(24633):String:String]
						[Then:Void] [Block:Void]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local tempVars(24628):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Local varName(24633):String:String]
							[Block:Void]
								[Call:Void]
									[Field:(key : String, value : Bool) -> Void]
										[Local processed(24629):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
										[FInstance:(key : String, value : Bool) -> Void]
											haxe.ds.StringMap<Bool>
											set:(key : String, value : haxe.ds.StringMap.T) -> Void
									[Local varName(24633):String:String]
									[Const:Bool] true
					[Binop:Int]
						[Local pos(24631):Int:Int]
						=
						[Binop:Int]
							[Field:Int]
								[Call:{ pos : Int, len : Int }]
									[Field:() -> { pos : Int, len : Int }]
										[Local assignmentPattern(24630):EReg:EReg]
										[FInstance:() -> { pos : Int, len : Int }]
											EReg
											matchedPos:() -> { pos : Int, len : Int }
								[FAnon:Int] pos:Int
							+
							[Field:Int]
								[Call:{ pos : Int, len : Int }]
									[Field:() -> { pos : Int, len : Int }]
										[Local assignmentPattern(24630):EReg:EReg]
										[FInstance:() -> { pos : Int, len : Int }]
											EReg
											matchedPos:() -> { pos : Int, len : Int }
								[FAnon:Int] len:Int
			[Var usagePattern(24643):EReg]
				[New:EReg]
					EReg
					[Const:String] "temp_\\w+"
					[Const:String] "g"
			[Binop:Int]
				[Local pos(24631):Int:Int]
				=
				[Const:Int] 0
			[While:Void]
				[Call:Bool]
					[Field:(s : String, pos : Int, ?len : Int) -> Bool]
						[Local usagePattern(24643):EReg:EReg]
						[FInstance:(s : String, pos : Int, ?len : Int) -> Bool]
							EReg
							matchSub:(s : String, pos : Int, ?len : Int) -> Bool
					[Local compiledBody(24627):String:String]
					[Local pos(24631):Int:Int]
					[Const:Null<Int>] null
				[Block:Int]
					[Var varName(24644):String]
						[Call:String]
							[Field:(n : Int) -> String]
								[Local usagePattern(24643):EReg:EReg]
								[FInstance:(n : Int) -> String]
									EReg
									matched:(n : Int) -> String
							[Const:Int] 0
					[If:Void]
						[Unop:Bool]
							!
							Prefix
							[Call:Bool]
								[Field:(key : String) -> Bool]
									[Local processed(24629):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
									[FInstance:(key : String) -> Bool]
										haxe.ds.StringMap<Bool>
										exists:(key : String) -> Bool
								[Local varName(24644):String:String]
						[Then:Void] [Block:Void]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local tempVars(24628):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Local varName(24644):String:String]
							[Block:Void]
								[Call:Void]
									[Field:(key : String, value : Bool) -> Void]
										[Local processed(24629):haxe.ds.Map<String, Bool>:haxe.ds.StringMap<Bool>]
										[FInstance:(key : String, value : Bool) -> Void]
											haxe.ds.StringMap<Bool>
											set:(key : String, value : haxe.ds.StringMap.T) -> Void
									[Local varName(24644):String:String]
									[Const:Bool] true
					[Binop:Int]
						[Local pos(24631):Int:Int]
						=
						[Binop:Int]
							[Field:Int]
								[Call:{ pos : Int, len : Int }]
									[Field:() -> { pos : Int, len : Int }]
										[Local usagePattern(24643):EReg:EReg]
										[FInstance:() -> { pos : Int, len : Int }]
											EReg
											matchedPos:() -> { pos : Int, len : Int }
								[FAnon:Int] pos:Int
							+
							[Field:Int]
								[Call:{ pos : Int, len : Int }]
									[Field:() -> { pos : Int, len : Int }]
										[Local usagePattern(24643):EReg:EReg]
										[FInstance:() -> { pos : Int, len : Int }]
											EReg
											matchedPos:() -> { pos : Int, len : Int }
								[FAnon:Int] len:Int
			[Return:Dynamic] [Local tempVars(24628):Array<String>:Array<String>]

	public function getContextDebugInfo[Function:() -> String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Binop:String]
																				[Binop:String]
																					[Binop:String]
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Binop:String]
																										[Const:String] "VariableMappingContext: {\n    function: "
																										+
																										[Meta:String]
																											:mergeBlock
																											[Block:String]
																												[Var tmp(30346):Null<String>]
																													[Block:Null<String>]
																														[Field:Null<String>]
																															[Field:reflaxe.elixir.helpers.VariableMappingContext]
																																[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																																[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																																	reflaxe.elixir.helpers.VariableMappingManager
																																	compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																															[FInstance:Null<String>]
																																reflaxe.elixir.helpers.VariableMappingContext
																																currentFunction:Null<String>
																												[If:String]
																													[Binop:Bool]
																														[Local tmp(30346):Null<String>:Null<String>]
																														!=
																														[Const:Null<String>] null
																													[Then:Null<String>] [Local tmp(30346):Null<String>:Null<String>]
																													[Else:String] [Block:String] [Const:String] "null"
																									+
																									[Const:String] ",\n    class: "
																								+
																								[Meta:String]
																									:mergeBlock
																									[Block:String]
																										[Var tmp(30348):Null<String>]
																											[Block:Null<String>]
																												[Block:Null<String>]
																													[Var tmp(30347):Null<haxe.macro.ClassType>]
																														[Field:Null<haxe.macro.ClassType>]
																															[Field:reflaxe.elixir.helpers.VariableMappingContext]
																																[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																																[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																																	reflaxe.elixir.helpers.VariableMappingManager
																																	compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																															[FInstance:Null<haxe.macro.ClassType>]
																																reflaxe.elixir.helpers.VariableMappingContext
																																currentClass:Null<haxe.macro.ClassType>
																													[If:Null<String>]
																														[Binop:Bool]
																															[Local tmp(30347):Null<haxe.macro.ClassType>:Null<haxe.macro.ClassType>]
																															!=
																															[Const:Null<haxe.macro.ClassType>] null
																														[Then:String] [Field:String]
																															[Local tmp(30347):Null<haxe.macro.ClassType>:Null<haxe.macro.ClassType>]
																															[FAnon:String] name:String
																														[Else:Null<String>] [Const:Null<String>] null
																										[If:String]
																											[Binop:Bool]
																												[Local tmp(30348):Null<String>:Null<String>]
																												!=
																												[Const:Null<String>] null
																											[Then:Null<String>] [Local tmp(30348):Null<String>:Null<String>]
																											[Else:String] [Block:String] [Const:String] "null"
																							+
																							[Const:String] ",\n    module: "
																						+
																						[Meta:String]
																							:mergeBlock
																							[Block:String]
																								[Var tmp(30349):Null<String>]
																									[Block:Null<String>]
																										[Field:Null<String>]
																											[Field:reflaxe.elixir.helpers.VariableMappingContext]
																												[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																												[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																													reflaxe.elixir.helpers.VariableMappingManager
																													compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																											[FInstance:Null<String>]
																												reflaxe.elixir.helpers.VariableMappingContext
																												currentModule:Null<String>
																								[If:String]
																									[Binop:Bool]
																										[Local tmp(30349):Null<String>:Null<String>]
																										!=
																										[Const:Null<String>] null
																									[Then:Null<String>] [Local tmp(30349):Null<String>:Null<String>]
																									[Else:String] [Block:String] [Const:String] "null"
																					+
																					[Const:String] ",\n    scopeDepth: "
																				+
																				[Field:Int]
																					[Field:reflaxe.elixir.helpers.VariableMappingContext]
																						[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																						[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																							reflaxe.elixir.helpers.VariableMappingManager
																							compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																					[FInstance:Int]
																						reflaxe.elixir.helpers.VariableMappingContext
																						scopeDepth:Int
																			+
																			[Const:String] ",\n    loopDepth: "
																		+
																		[Field:Int]
																			[Field:reflaxe.elixir.helpers.VariableMappingContext]
																				[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																				[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																					reflaxe.elixir.helpers.VariableMappingManager
																					compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																			[FInstance:Int]
																				reflaxe.elixir.helpers.VariableMappingContext
																				loopDepth:Int
																	+
																	[Const:String] ",\n    conditionalDepth: "
																+
																[Field:Int]
																	[Field:reflaxe.elixir.helpers.VariableMappingContext]
																		[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																		[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																			reflaxe.elixir.helpers.VariableMappingManager
																			compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																	[FInstance:Int]
																		reflaxe.elixir.helpers.VariableMappingContext
																		conditionalDepth:Int
															+
															[Const:String] ",\n    isInLiveViewContext: "
														+
														[Call:String]
															[Field:(s : Dynamic) -> String]
																[TypeExpr Std:Class<Std>]
																[FStatic:(s : Dynamic) -> String]
																	Std
																	string:(s : Dynamic) -> String
															[Field:Bool]
																[Field:reflaxe.elixir.helpers.VariableMappingContext]
																	[Const:reflaxe.elixir.helpers.VariableMappingManager] this
																	[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																		reflaxe.elixir.helpers.VariableMappingManager
																		compilationContext:reflaxe.elixir.helpers.VariableMappingContext
																[FInstance:Bool]
																	reflaxe.elixir.helpers.VariableMappingContext
																	isInLiveViewContext:Bool
													+
													[Const:String] ",\n    isInGenServerContext: "
												+
												[Call:String]
													[Field:(s : Dynamic) -> String]
														[TypeExpr Std:Class<Std>]
														[FStatic:(s : Dynamic) -> String]
															Std
															string:(s : Dynamic) -> String
													[Field:Bool]
														[Field:reflaxe.elixir.helpers.VariableMappingContext]
															[Const:reflaxe.elixir.helpers.VariableMappingManager] this
															[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
																reflaxe.elixir.helpers.VariableMappingManager
																compilationContext:reflaxe.elixir.helpers.VariableMappingContext
														[FInstance:Bool]
															reflaxe.elixir.helpers.VariableMappingContext
															isInGenServerContext:Bool
											+
											[Const:String] ",\n    isInSchemaContext: "
										+
										[Call:String]
											[Field:(s : Dynamic) -> String]
												[TypeExpr Std:Class<Std>]
												[FStatic:(s : Dynamic) -> String]
													Std
													string:(s : Dynamic) -> String
											[Field:Bool]
												[Field:reflaxe.elixir.helpers.VariableMappingContext]
													[Const:reflaxe.elixir.helpers.VariableMappingManager] this
													[FInstance:reflaxe.elixir.helpers.VariableMappingContext]
														reflaxe.elixir.helpers.VariableMappingManager
														compilationContext:reflaxe.elixir.helpers.VariableMappingContext
												[FInstance:Bool]
													reflaxe.elixir.helpers.VariableMappingContext
													isInSchemaContext:Bool
									+
									[Const:String] ",\n    trackedVariables: "
								+
								[Call:Int]
									[Field:(it : Iterable<reflaxe.elixir.helpers.VariableDeclarationInfo>, ?pred : Null<(item : reflaxe.elixir.helpers.VariableDeclarationInfo) -> Bool>) -> Int]
										[TypeExpr Lambda:Class<Lambda>]
										[FStatic:(it : Iterable<reflaxe.elixir.helpers.VariableDeclarationInfo>, ?pred : Null<(item : reflaxe.elixir.helpers.VariableDeclarationInfo) -> Bool>) -> Int]
											Lambda
											count:(it : Iterable<count.A>, ?pred : Null<(item : count.A) -> Bool>) -> Int
									[Cast:Iterable<reflaxe.elixir.helpers.VariableDeclarationInfo>]
										[Field:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
											[Const:reflaxe.elixir.helpers.VariableMappingManager] this
											[FInstance:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>]
												reflaxe.elixir.helpers.VariableMappingManager
												variableDeclarations:Map<String, reflaxe.elixir.helpers.VariableDeclarationInfo>
									[Const:Null<(item : reflaxe.elixir.helpers.VariableDeclarationInfo) -> Bool>] null
							+
							[Const:String] ",\n    scopeCrossingVariables: "
						+
						[Field:Int]
							[Field:Array<String>]
								[Const:reflaxe.elixir.helpers.VariableMappingManager] this
								[FInstance:Array<String>]
									reflaxe.elixir.helpers.VariableMappingManager
									scopeCrossingVariables:Array<String>
							[FInstance:Int]
								Array<String>
								length:Int
					+
					[Const:String] "\n}"
}