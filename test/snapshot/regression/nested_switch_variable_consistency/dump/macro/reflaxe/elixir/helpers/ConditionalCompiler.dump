@:nullSafety(Off)
class reflaxe.elixir.helpers.ConditionalCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(27973):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.ConditionalCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(27973):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileIfExpression[Function:(econd : haxe.macro.TypedExpr, eif : haxe.macro.TypedExpr, eelse : Null<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(17908):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local eif(17909):haxe.macro.TypedExpr]
		[Arg:Null<haxe.macro.TypedExpr>] [Local eelse(17910):Null<haxe.macro.TypedExpr>]
		[Block:Void]
			[Var arrayMutation(18201):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
				[Call:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
						[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
							reflaxe.elixir.helpers.ConditionalCompiler
							detectArrayMutation:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>
					[Local eif(17909):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local arrayMutation(18201):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
					!=
					[Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var condStr(18202):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.ConditionalCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local econd(17908):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Const:Null<Bool>] null
					[Var mutationExpr(18215):String]
						[Call:String]
							[Field:(expr : haxe.macro.TypedExpr) -> String]
								[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
								[FInstance:(expr : haxe.macro.TypedExpr) -> String]
									reflaxe.elixir.helpers.ConditionalCompiler
									extractMutationExpression:(expr : haxe.macro.TypedExpr) -> String
							[Local eif(17909):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Var elseMutation(18216):Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>]
						[If:Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>]
							[Binop:Bool]
								[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
								!=
								[Const:Null<haxe.macro.TypedExpr>] null
							[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
								[Call:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
									[Field:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
										[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											reflaxe.elixir.helpers.ConditionalCompiler
											detectArrayMutation:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>
									[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							[Else:Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>] [Block:Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>] [Const:Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>] null
					[Var elseStr(18217):Null<String>]
						[If:Null<String>]
							[Binop:Bool]
								[Local elseMutation(18216):Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>:Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>]
								!=
								[Const:Null<Null<{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }>>] null
							[Then:String] [Block:String]
								[Call:String]
									[Field:(expr : haxe.macro.TypedExpr) -> String]
										[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
										[FInstance:(expr : haxe.macro.TypedExpr) -> String]
											reflaxe.elixir.helpers.ConditionalCompiler
											extractMutationExpression:(expr : haxe.macro.TypedExpr) -> String
									[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							[Else:Null<String>] [Block:Null<String>]
								[If:Null<String>]
									[Binop:Bool]
										[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
										!=
										[Const:Null<haxe.macro.TypedExpr>] null
									[Then:Null<String>] [Block:Null<String>]
										[Call:Null<String>]
											[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.ConditionalCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
											[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
											[Const:Null<Bool>] null
									[Else:String] [Block:String]
										[Field:String]
											[Local arrayMutation(18201):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											[FAnon:String] variable:String
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Field:String]
														[Local arrayMutation(18201):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
														[FAnon:String] variable:String
												+
												[Const:String] " = if "
											+
											[Local condStr(18202):Null<String>:Null<String>]
										+
										[Const:String] ", do: "
									+
									[Local mutationExpr(18215):String:String]
								+
								[Const:String] ", else: "
							+
							[Local elseStr(18217):Null<String>:Null<String>]
			[Var condStr(18218):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ConditionalCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local econd(17908):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var ifStr(18219):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ConditionalCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local eif(17909):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var elseStr(18220):Null<String>]
				[If:Null<String>]
					[Binop:Bool]
						[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
						!=
						[Const:Null<haxe.macro.TypedExpr>] null
					[Then:Null<String>] [Block:Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.ConditionalCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
							[Const:Null<Bool>] null
					[Else:String] [Block:String] [Const:String] "nil"
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:(expr : haxe.macro.TypedExpr) -> Bool]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
								reflaxe.elixir.helpers.ConditionalCompiler
								isSimpleExpression:(expr : haxe.macro.TypedExpr) -> Bool
						[Local eif(17909):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					&&
					[Parenthesis:Bool]
						[Binop:Bool]
							[Binop:Bool]
								[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
								==
								[Const:Null<haxe.macro.TypedExpr>] null
							||
							[Call:Bool]
								[Field:(expr : haxe.macro.TypedExpr) -> Bool]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
										reflaxe.elixir.helpers.ConditionalCompiler
										isSimpleExpression:(expr : haxe.macro.TypedExpr) -> Bool
								[Local eelse(17910):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] "if "
											+
											[Local condStr(18218):Null<String>:Null<String>]
										+
										[Const:String] ", do: "
									+
									[Local ifStr(18219):Null<String>:Null<String>]
								+
								[Const:String] ", else: "
							+
							[Local elseStr(18220):Null<String>:Null<String>]
				[Else:Dynamic] [Block:Dynamic]
					[Var result(18250):String]
						[Binop:String]
							[Binop:String]
								[Const:String] "if "
								+
								[Local condStr(18218):Null<String>:Null<String>]
							+
							[Const:String] " do\n"
					[Binop:String]
						[Local result(18250):String:String]
						+=
						[Binop:String]
							[Call:String]
								[Field:(code : String, ?level : Int) -> String]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:(code : String, ?level : Int) -> String]
										reflaxe.elixir.helpers.ConditionalCompiler
										indent:(code : String, ?level : Int) -> String
								[Local ifStr(18219):Null<String>:Null<String>]
								[Const:Null<Int>] null
							+
							[Const:String] "\n"
					[Binop:String]
						[Local result(18250):String:String]
						+=
						[Const:String] "else\n"
					[Binop:String]
						[Local result(18250):String:String]
						+=
						[Binop:String]
							[Call:String]
								[Field:(code : String, ?level : Int) -> String]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:(code : String, ?level : Int) -> String]
										reflaxe.elixir.helpers.ConditionalCompiler
										indent:(code : String, ?level : Int) -> String
								[Local elseStr(18220):Null<String>:Null<String>]
								[Const:Null<Int>] null
							+
							[Const:String] "\n"
					[Binop:String]
						[Local result(18250):String:String]
						+=
						[Const:String] "end"
					[Return:Dynamic] [Local result(18250):String:String]

	public function compileTernaryExpression[Function:(econd : haxe.macro.TypedExpr, eif : haxe.macro.TypedExpr, eelse : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local econd(27974):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local eif(27975):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TypedExpr] [Local eelse(27976):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var condStr(27977):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ConditionalCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local econd(27974):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var ifStr(27978):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ConditionalCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local eif(27975):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var elseStr(27979):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ConditionalCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local eelse(27976):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "if "
									+
									[Local condStr(27977):Null<String>:Null<String>]
								+
								[Const:String] ", do: "
							+
							[Local ifStr(27978):Null<String>:Null<String>]
						+
						[Const:String] ", else: "
					+
					[Local elseStr(27979):Null<String>:Null<String>]

	public function compileGuardClause[Function:(condition : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local condition(27980):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr) -> String]
						[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr) -> String]
							reflaxe.elixir.helpers.ConditionalCompiler
							compileGuardExpression:(expr : haxe.macro.TypedExpr) -> String
					[Local condition(27980):haxe.macro.TypedExpr:haxe.macro.TypedExpr]

	function isSimpleExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(18221):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.expr) {
	case TConst(_):
		true;	
	case TLocal(_):
		true;	
	case TField(_, _):
		true;	
	case TCall(_, args) if (args.length <= 2):
		true;	
	case TBinop(_, _, _):
		true;	
	case TUnop(_, _, _):
		true;	
	default:
		false;	
})
					[Block:Bool]
						[Var `(18236):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(18221):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Bool]
							[EnumIndex:Int] [Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Bool]
								[Const:Int] 0
								[Block:Bool]
									[Var `(18237):haxe.macro.TConstant]
										[EnumParameter:haxe.macro.TConstant]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TConst
											0
									[Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:Int] 1
								[Block:Bool]
									[Var `(18238):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:Int] 3
								[Block:Bool]
									[Var `(18239):haxe.macro.Binop]
										[EnumParameter:haxe.macro.Binop]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											0
									[Var `(18240):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											1
									[Var `(18241):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											2
									[Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:Int] 4
								[Block:Bool]
									[Var `(18242):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(18243):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:Int] 9
								[Block:Bool]
									[Var `(18244):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(18245):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:Bool]
										[Var args(18246):Array<haxe.macro.TypedExpr>] [Local `(18245):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Bool]
											[Binop:Bool]
												[Field:Int]
													[Local args(18246):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												<=
												[Const:Int] 2
											[Then:Bool] [Block:Bool] [Const:Bool] true
											[Else:Bool] [Block:Bool] [Const:Bool] false
							[Case:Bool]
								[Const:Int] 11
								[Block:Bool]
									[Var `(18247):haxe.macro.Unop]
										[EnumParameter:haxe.macro.Unop]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											0
									[Var `(18248):Bool]
										[EnumParameter:Bool]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											1
									[Var `(18249):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											2
									[Block:Bool] [Const:Bool] true
							[Default:Bool] [Block:Bool] [Const:Bool] false

	function compileGuardExpression[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(27981):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBinop(op, e1, e2):
		var left = compileGuardExpression(e1);
		var right = compileGuardExpression(e2);
		var opStr = switch (op) {
			case OpAdd:
				"+";			
			case OpSub:
				"-";			
			case OpMult:
				"*";			
			case OpDiv:
				"/";			
			case OpMod:
				"rem";			
			case OpEq:
				"==";			
			case OpNotEq:
				"!=";			
			case OpLt:
				"<";			
			case OpLte:
				"<=";			
			case OpGt:
				">";			
			case OpGte:
				">=";			
			case OpBoolAnd:
				"and";			
			case OpBoolOr:
				"or";			
			default:
				"==";			
		};
		"${left} ${opStr} ${right}";	
	case TUnop(op, postFix, e):
		var exprStr = compileGuardExpression(e);
		var opStr = switch (op) {
			case OpNot:
				"not ";			
			case OpNeg:
				"-";			
			case OpIncrement:
				"+1";			
			case OpDecrement:
				"-1";			
			default:
				"";			
		};
		if (postFix && (op == OpIncrement || op == OpDecrement)) {
			"(${exprStr} ${opStr})";
		} else {
			"${opStr}${exprStr}";
		};	
	case TConst(c):
		compiler.expressionDispatcher.literalCompiler.compileConstant(c);	
	case TLocal(v):
		compiler.variableCompiler.compileLocalVariable(v);	
	case TField(e, fa):
		compiler.compileExpression(expr);	
	default:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(28008):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(27981):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 0
								[Block:String]
									[Var `(28009):haxe.macro.TConstant]
										[EnumParameter:haxe.macro.TConstant]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TConst
											0
									[Block:String]
										[Var c(28010):haxe.macro.TConstant] [Local `(28009):haxe.macro.TConstant:haxe.macro.TConstant]
										[Block:String]
											[Call:String]
												[Field:(constant : haxe.macro.TConstant) -> String]
													[Field:reflaxe.elixir.helpers.LiteralCompiler]
														[Field:reflaxe.elixir.helpers.ExpressionDispatcher]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ConditionalCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:reflaxe.elixir.helpers.ExpressionDispatcher]
																reflaxe.elixir.ElixirCompiler
																expressionDispatcher:reflaxe.elixir.helpers.ExpressionDispatcher
														[FInstance:reflaxe.elixir.helpers.LiteralCompiler]
															reflaxe.elixir.helpers.ExpressionDispatcher
															literalCompiler:reflaxe.elixir.helpers.LiteralCompiler
													[FInstance:(constant : haxe.macro.TConstant) -> String]
														reflaxe.elixir.helpers.LiteralCompiler
														compileConstant:(constant : haxe.macro.TConstant) -> String
												[Local c(28010):haxe.macro.TConstant:haxe.macro.TConstant]
							[Case:String]
								[Const:Int] 1
								[Block:String]
									[Var `(28011):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:String]
										[Var v(28012):haxe.macro.TVar] [Local `(28011):haxe.macro.TVar:haxe.macro.TVar]
										[Block:String]
											[Call:String]
												[Field:(v : haxe.macro.TVar) -> String]
													[Field:reflaxe.elixir.helpers.VariableCompiler]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ConditionalCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:reflaxe.elixir.helpers.VariableCompiler]
															reflaxe.elixir.ElixirCompiler
															variableCompiler:reflaxe.elixir.helpers.VariableCompiler
													[FInstance:(v : haxe.macro.TVar) -> String]
														reflaxe.elixir.helpers.VariableCompiler
														compileLocalVariable:(v : haxe.macro.TVar) -> String
												[Local v(28012):haxe.macro.TVar:haxe.macro.TVar]
							[Case:String]
								[Const:Int] 3
								[Block:String]
									[Var `(28013):haxe.macro.Binop]
										[EnumParameter:haxe.macro.Binop]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											0
									[Var `(28014):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											1
									[Var `(28015):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											2
									[Block:String]
										[Var op(28016):haxe.macro.Binop] [Local `(28013):haxe.macro.Binop:haxe.macro.Binop]
										[Var e1(28017):haxe.macro.TypedExpr] [Local `(28014):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var e2(28018):haxe.macro.TypedExpr] [Local `(28015):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:String]
											[Var left(28019):String]
												[Call:String]
													[Field:(expr : haxe.macro.TypedExpr) -> String]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> String]
															reflaxe.elixir.helpers.ConditionalCompiler
															compileGuardExpression:(expr : haxe.macro.TypedExpr) -> String
													[Local e1(28017):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var right(28020):String]
												[Call:String]
													[Field:(expr : haxe.macro.TypedExpr) -> String]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> String]
															reflaxe.elixir.helpers.ConditionalCompiler
															compileGuardExpression:(expr : haxe.macro.TypedExpr) -> String
													[Local e2(28018):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var opStr(28021):String]
												[Meta:String]
													:ast(switch (op) {
	case OpAdd:
		"+";	
	case OpSub:
		"-";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpMod:
		"rem";	
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	case OpBoolAnd:
		"and";	
	case OpBoolOr:
		"or";	
	default:
		"==";	
})
													[Switch:String]
														[EnumIndex:Int] [Local op(28016):haxe.macro.Binop:haxe.macro.Binop]
														[Case:String]
															[Const:Int] 0
															[Block:String] [Block:String] [Const:String] "+"
														[Case:String]
															[Const:Int] 1
															[Block:String] [Block:String] [Const:String] "*"
														[Case:String]
															[Const:Int] 2
															[Block:String] [Block:String] [Const:String] "/"
														[Case:String]
															[Const:Int] 3
															[Block:String] [Block:String] [Const:String] "-"
														[Case:String]
															[Const:Int] 5
															[Block:String] [Block:String] [Const:String] "=="
														[Case:String]
															[Const:Int] 6
															[Block:String] [Block:String] [Const:String] "!="
														[Case:String]
															[Const:Int] 7
															[Block:String] [Block:String] [Const:String] ">"
														[Case:String]
															[Const:Int] 8
															[Block:String] [Block:String] [Const:String] ">="
														[Case:String]
															[Const:Int] 9
															[Block:String] [Block:String] [Const:String] "<"
														[Case:String]
															[Const:Int] 10
															[Block:String] [Block:String] [Const:String] "<="
														[Case:String]
															[Const:Int] 14
															[Block:String] [Block:String] [Const:String] "and"
														[Case:String]
															[Const:Int] 15
															[Block:String] [Block:String] [Const:String] "or"
														[Case:String]
															[Const:Int] 19
															[Block:String] [Block:String] [Const:String] "rem"
														[Default:String] [Block:String] [Const:String] "=="
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] ""
																+
																[Local left(28019):String:String]
															+
															[Const:String] " "
														+
														[Local opStr(28021):String:String]
													+
													[Const:String] " "
												+
												[Local right(28020):String:String]
							[Case:Null<String>]
								[Const:Int] 4
								[Block:Null<String>]
									[Var `(28022):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(28023):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:Null<String>]
										[Var e(28024):haxe.macro.TypedExpr] [Local `(28022):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var fa(28025):haxe.macro.FieldAccess] [Local `(28023):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:Null<String>]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ConditionalCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local expr(27981):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
							[Case:String]
								[Const:Int] 11
								[Block:String]
									[Var `(28026):haxe.macro.Unop]
										[EnumParameter:haxe.macro.Unop]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											0
									[Var `(28027):Bool]
										[EnumParameter:Bool]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											1
									[Var `(28028):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(28008):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TUnop
											2
									[Block:String]
										[Var op(28029):haxe.macro.Unop] [Local `(28026):haxe.macro.Unop:haxe.macro.Unop]
										[Var postFix(28030):Bool] [Local `(28027):Bool:Bool]
										[Var e(28031):haxe.macro.TypedExpr] [Local `(28028):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:String]
											[Var exprStr(28032):String]
												[Call:String]
													[Field:(expr : haxe.macro.TypedExpr) -> String]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> String]
															reflaxe.elixir.helpers.ConditionalCompiler
															compileGuardExpression:(expr : haxe.macro.TypedExpr) -> String
													[Local e(28031):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Var opStr(28033):String]
												[Meta:String]
													:ast(switch (op) {
	case OpNot:
		"not ";	
	case OpNeg:
		"-";	
	case OpIncrement:
		"+1";	
	case OpDecrement:
		"-1";	
	default:
		"";	
})
													[Switch:String]
														[EnumIndex:Int] [Local op(28029):haxe.macro.Unop:haxe.macro.Unop]
														[Case:String]
															[Const:Int] 0
															[Block:String] [Block:String] [Const:String] "+1"
														[Case:String]
															[Const:Int] 1
															[Block:String] [Block:String] [Const:String] "-1"
														[Case:String]
															[Const:Int] 2
															[Block:String] [Block:String] [Const:String] "not "
														[Case:String]
															[Const:Int] 3
															[Block:String] [Block:String] [Const:String] "-"
														[Default:String] [Block:String] [Const:String] ""
											[If:String]
												[Binop:Bool]
													[Local postFix(28030):Bool:Bool]
													&&
													[Parenthesis:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Local op(28029):haxe.macro.Unop:haxe.macro.Unop]
																==
																[Field:haxe.macro.Unop]
																	[TypeExpr haxe.macro.Unop:Enum<haxe.macro.Unop>]
																	[FEnum:haxe.macro.Unop]
																		haxe.macro.Unop
																		OpIncrement
															||
															[Binop:Bool]
																[Local op(28029):haxe.macro.Unop:haxe.macro.Unop]
																==
																[Field:haxe.macro.Unop]
																	[TypeExpr haxe.macro.Unop:Enum<haxe.macro.Unop>]
																	[FEnum:haxe.macro.Unop]
																		haxe.macro.Unop
																		OpDecrement
												[Then:String] [Block:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] "("
																	+
																	[Local exprStr(28032):String:String]
																+
																[Const:String] " "
															+
															[Local opStr(28033):String:String]
														+
														[Const:String] ")"
												[Else:String] [Block:String]
													[Binop:String]
														[Binop:String]
															[Const:String] ""
															+
															[Local opStr(28033):String:String]
														+
														[Local exprStr(28032):String:String]
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.ConditionalCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local expr(27981):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null

	@:value({ level : 2 })
	function indent[Function:(code : String, ?level : Int) -> String]
		[Arg:String] [Local code(18251):String]
		[Arg:Int]
			[Local level(18252):Int]
			[Const:Int] 2
		[Block:Dynamic]
			[Var spaces(18257):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var `(18253):Array<String>] [ArrayDecl:Array<String>]
							[Block:Void]
								[Var `(18255):Int] [Const:Int] 0
								[Var `(18256):Int] [Local level(18252):Int:Int]
								[While:Void]
									[Binop:Bool]
										[Local `(18255):Int:Int]
										<
										[Local `(18256):Int:Int]
									[Block:Int]
										[Var i(18254):Int]
											[Unop:Int]
												++
												Postfix
												[Local `(18255):Int:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local `(18253):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Const:String] " "
							[Local `(18253):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ""
			[Return:Dynamic]
				[Call:String]
					[Field:(sep : String) -> String]
						[Block:Array<String>]
							[Var _this(18260):Array<String>]
								[Call:Array<String>]
									[Field:(delimiter : String) -> Array<String>]
										[Local code(18251):String:String]
										[FInstance:(delimiter : String) -> Array<String>]
											String
											split:(delimiter : String) -> Array<String>
									[Const:String] "\n"
							[Block:Array<String>]
								[Var `(18262):Array<String>] [ArrayDecl:Array<String>]
								[Block:Void]
									[Var `(18263):Int] [Const:Int] 0
									[Var `(18264):Array<String>] [Local _this(18260):Array<String>:Array<String>]
									[While:Void]
										[Binop:Bool]
											[Local `(18263):Int:Int]
											<
											[Field:Int]
												[Local `(18264):Array<String>:Array<String>]
												[FInstance:Int]
													Array<String>
													length:Int
										[Block:Void]
											[Var v(18265):String]
												[Array:String]
													[Local `(18264):Array<String>:Array<String>]
													[Local `(18263):Int:Int]
											[Unop:Int]
												++
												Prefix
												[Local `(18263):Int:Int]
											[Call:Int]
												[Field:(x : String) -> Int]
													[Local `(18262):Array<String>:Array<String>]
													[FInstance:(x : String) -> Int]
														Array<String>
														push:(x : Array.T) -> Int
												[Call:String]
													[Function:(line : String) -> String]
														[Arg:String] [Local line(18266):String]
														[Block:Dynamic]
															[Return:Dynamic]
																[Binop:String]
																	[Local spaces(18257):String:String]
																	+
																	[Local line(18266):String:String]
													[Local v(18265):String:String]
								[Local `(18262):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] "\n"

	function detectArrayMutation[Function:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
		[Arg:haxe.macro.TypedExpr] [Local expr(17911):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(17911):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					==
					[Const:haxe.macro.TypedExpr] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
			[Return:Dynamic]
				[Meta:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
					:ast(switch (expr.expr) {
	case TCall({ expr : TField(arrayExpr, FInstance(_, _, cf)) }, args) if (cf.get().name == "push" || cf.get().name == "concat"):
		{ variable : extractArrayVariableName(arrayExpr), type : cf.get().name, arrayExpr : arrayExpr, args : args };	
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, arr1, arr2) }):
		if (isArrayExpression(arr1)) {
			{ variable : extractArrayVariableName(arr1), type : "concat", arrayExpr : arr1, args : [arr2] };
		} else {
			null;
		};	
	case TBinop(OpAdd, arr1, arr2):
		if (isArrayExpression(arr1)) {
			{ variable : extractArrayVariableName(arr1), type : "concat", arrayExpr : arr1, args : [arr2] };
		} else {
			null;
		};	
	case TBlock(exprs) if (exprs.length > 0):
		detectArrayMutation(exprs[exprs.length - 1]);	
	default:
		null;	
})
					[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
						[Var `(18167):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(17911):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
							[EnumIndex:Int] [Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
								[Const:Int] 3
								[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
									[Var `(18168):haxe.macro.Binop]
										[EnumParameter:haxe.macro.Binop]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											0
									[Var `(18169):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											1
									[Var `(18170):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBinop
											2
									[Switch:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
										[EnumIndex:Int] [Local `(18168):haxe.macro.Binop:haxe.macro.Binop]
										[Case:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											[Const:Int] 0
											[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
												[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[Var arr1(18171):haxe.macro.TypedExpr] [Local `(18169):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Var arr2(18172):haxe.macro.TypedExpr] [Local `(18170):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
														[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															[Call:Bool]
																[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																	[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																	[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																		reflaxe.elixir.helpers.ConditionalCompiler
																		isArrayExpression:(expr : haxe.macro.TypedExpr) -> Bool
																[Local arr1(18171):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Then:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }] [Block:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																[ObjectDecl:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																	variable: [Call:String]
																		[Field:(expr : haxe.macro.TypedExpr) -> String]
																			[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																			[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																				reflaxe.elixir.helpers.ConditionalCompiler
																				extractArrayVariableName:(expr : haxe.macro.TypedExpr) -> String
																		[Local arr1(18171):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	type: [Const:String] "concat"
																	arrayExpr: [Local arr1(18171):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	args: [ArrayDecl:Array<haxe.macro.TypedExpr>] [Local arr2(18172):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
										[Case:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											[Const:Int] 4
											[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
												[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[Var `(18173):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Local `(18169):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[Var `(18174):haxe.macro.Position]
														[Field:haxe.macro.Position]
															[Local `(18169):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.Position] pos:haxe.macro.Position
													[Var `(18175):haxe.macro.Type]
														[Field:haxe.macro.Type]
															[Local `(18169):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.Type] t:haxe.macro.Type
													[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(18173):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 1
														[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															[Var `(18176):haxe.macro.TVar]
																[EnumParameter:haxe.macro.TVar]
																	[Local `(18173):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TLocal
																	0
															[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																[Var `(18177):haxe.macro.TypedExprDef]
																	[Field:haxe.macro.TypedExprDef]
																		[Local `(18170):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																[Var `(18178):haxe.macro.Position]
																	[Field:haxe.macro.Position]
																		[Local `(18170):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Var `(18179):haxe.macro.Type]
																	[Field:haxe.macro.Type]
																		[Local `(18170):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.Type] t:haxe.macro.Type
																[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(18177):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		==
																		[Const:Int] 3
																	[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																		[Var `(18180):haxe.macro.Binop]
																			[EnumParameter:haxe.macro.Binop]
																				[Local `(18177):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TBinop
																				0
																		[Var `(18181):haxe.macro.TypedExpr]
																			[EnumParameter:haxe.macro.TypedExpr]
																				[Local `(18177):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TBinop
																				1
																		[Var `(18182):haxe.macro.TypedExpr]
																			[EnumParameter:haxe.macro.TypedExpr]
																				[Local `(18177):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TBinop
																				2
																		[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																			[Binop:Bool]
																				[EnumIndex:Int] [Local `(18180):haxe.macro.Binop:haxe.macro.Binop]
																				==
																				[Const:Int] 0
																			[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																				[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																					[Var arr1(18183):haxe.macro.TypedExpr] [Local `(18181):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Var arr2(18184):haxe.macro.TypedExpr] [Local `(18182):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Var v(18185):haxe.macro.TVar] [Local `(18176):haxe.macro.TVar:haxe.macro.TVar]
																					[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																						[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																							[Call:Bool]
																								[Field:(expr : haxe.macro.TypedExpr) -> Bool]
																									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																									[FInstance:(expr : haxe.macro.TypedExpr) -> Bool]
																										reflaxe.elixir.helpers.ConditionalCompiler
																										isArrayExpression:(expr : haxe.macro.TypedExpr) -> Bool
																								[Local arr1(18183):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Then:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }] [Block:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																								[ObjectDecl:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																									variable: [Call:String]
																										[Field:(expr : haxe.macro.TypedExpr) -> String]
																											[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																											[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																												reflaxe.elixir.helpers.ConditionalCompiler
																												extractArrayVariableName:(expr : haxe.macro.TypedExpr) -> String
																										[Local arr1(18183):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																									type: [Const:String] "concat"
																									arrayExpr: [Local arr1(18183):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																									args: [ArrayDecl:Array<haxe.macro.TypedExpr>] [Local arr2(18184):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
																			[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
																	[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
														[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
										[Default:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
							[Case:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
								[Const:Int] 9
								[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
									[Var `(18186):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(18187):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
										[Var `(18188):haxe.macro.TypedExprDef]
											[Field:haxe.macro.TypedExprDef]
												[Local `(18186):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
										[Var `(18189):haxe.macro.Position]
											[Field:haxe.macro.Position]
												[Local `(18186):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[FAnon:haxe.macro.Position] pos:haxe.macro.Position
										[Var `(18190):haxe.macro.Type]
											[Field:haxe.macro.Type]
												[Local `(18186):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[FAnon:haxe.macro.Type] t:haxe.macro.Type
										[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											[Binop:Bool]
												[EnumIndex:Int] [Local `(18188):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												==
												[Const:Int] 4
											[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
												[Var `(18191):haxe.macro.TypedExpr]
													[EnumParameter:haxe.macro.TypedExpr]
														[Local `(18188):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
														TField
														0
												[Var `(18192):haxe.macro.FieldAccess]
													[EnumParameter:haxe.macro.FieldAccess]
														[Local `(18188):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
														TField
														1
												[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[Binop:Bool]
														[EnumIndex:Int] [Local `(18192):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
														==
														[Const:Int] 0
													[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
														[Var `(18193):haxe.macro.Ref<haxe.macro.ClassType>]
															[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																[Local `(18192):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																FInstance
																0
														[Var `(18194):Array<haxe.macro.Type>]
															[EnumParameter:Array<haxe.macro.Type>]
																[Local `(18192):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																FInstance
																1
														[Var `(18195):haxe.macro.Ref<haxe.macro.ClassField>]
															[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																[Local `(18192):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																FInstance
																2
														[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															[Var cf(18196):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(18195):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
															[Var arrayExpr(18197):haxe.macro.TypedExpr] [Local `(18191):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Var args(18198):Array<haxe.macro.TypedExpr>] [Local `(18187):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																[Binop:Bool]
																	[Binop:Bool]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(18196):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
																		==
																		[Const:String] "push"
																	||
																	[Binop:Bool]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(18196):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
																		==
																		[Const:String] "concat"
																[Then:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }] [Block:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																	[ObjectDecl:{ variable : String, type : String, arrayExpr : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr> }]
																		variable: [Call:String]
																			[Field:(expr : haxe.macro.TypedExpr) -> String]
																				[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																				[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																					reflaxe.elixir.helpers.ConditionalCompiler
																					extractArrayVariableName:(expr : haxe.macro.TypedExpr) -> String
																			[Local arrayExpr(18197):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		type: [Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(18196):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
																		arrayExpr: [Local arrayExpr(18197):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		args: [Local args(18198):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
													[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
											[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
							[Case:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
								[Const:Int] 14
								[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
									[Var `(18199):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(18167):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TBlock
											0
									[Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
										[Var exprs(18200):Array<haxe.macro.TypedExpr>] [Local `(18199):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
											[Binop:Bool]
												[Field:Int]
													[Local exprs(18200):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
												>
												[Const:Int] 0
											[Then:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
												[Call:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[Field:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															reflaxe.elixir.helpers.ConditionalCompiler
															detectArrayMutation:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>
													[Array:haxe.macro.TypedExpr]
														[Local exprs(18200):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Binop:Int]
															[Field:Int]
																[Local exprs(18200):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
															-
															[Const:Int] 1
											[Else:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
							[Default:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Block:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] [Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null

	function extractArrayVariableName[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(17915):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TLocal(v):
		compiler.variableCompiler.compileLocalVariable(v);	
	case TField(e, _):
		compiler.compileExpression(expr);	
	default:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(18072):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(17915):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(18072):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 1
								[Block:String]
									[Var `(18073):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(18072):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:String]
										[Var v(18074):haxe.macro.TVar] [Local `(18073):haxe.macro.TVar:haxe.macro.TVar]
										[Block:String]
											[Call:String]
												[Field:(v : haxe.macro.TVar) -> String]
													[Field:reflaxe.elixir.helpers.VariableCompiler]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ConditionalCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:reflaxe.elixir.helpers.VariableCompiler]
															reflaxe.elixir.ElixirCompiler
															variableCompiler:reflaxe.elixir.helpers.VariableCompiler
													[FInstance:(v : haxe.macro.TVar) -> String]
														reflaxe.elixir.helpers.VariableCompiler
														compileLocalVariable:(v : haxe.macro.TVar) -> String
												[Local v(18074):haxe.macro.TVar:haxe.macro.TVar]
							[Case:Null<String>]
								[Const:Int] 4
								[Block:Null<String>]
									[Var `(18075):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(18072):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(18076):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(18072):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:Null<String>]
										[Var e(18077):haxe.macro.TypedExpr] [Local `(18075):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Null<String>]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ConditionalCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local expr(17915):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.ConditionalCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local expr(17915):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null

	function isArrayExpression[Function:(expr : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local expr(18081):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (expr.t) {
	case TInst(_.get() => { name : "Array" }, _):
		true;	
	default:
		switch (expr.expr) {
			case TLocal(_):
				true;			
			default:
				false;			
		};	
})
					[Block:Bool]
						[Var `(18111):haxe.macro.Type]
							[Field:haxe.macro.Type]
								[Local expr(18081):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.Type] t:haxe.macro.Type
						[If:Bool]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(18111):haxe.macro.Type:haxe.macro.Type]
								==
								[Const:Int] 2
							[Then:Bool] [Block:Bool]
								[Var `(18112):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local `(18111):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(18113):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local `(18111):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:Bool]
									[Var _hx_tmp(18114):haxe.macro.ClassType]
									[Block:Bool]
										[Var `(18115):Null<haxe.macro.Ref<haxe.macro.ClassField>>]
											[Field:Null<haxe.macro.Ref<haxe.macro.ClassField>>]
												[Parenthesis:haxe.macro.ClassType]
													[Binop:haxe.macro.ClassType]
														[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
														=
														[Call:haxe.macro.ClassType]
															[Field:() -> haxe.macro.ClassType]
																[Local `(18112):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
																[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
												[FAnon:Null<haxe.macro.Ref<haxe.macro.ClassField>>] constructor:Null<haxe.macro.Ref<haxe.macro.ClassField>>
										[Var `(18116):Null<String>]
											[Field:Null<String>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Null<String>] doc:Null<String>
										[Var `(18117):haxe.macro.Ref<Array<haxe.macro.ClassField>>]
											[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] fields:haxe.macro.Ref<Array<haxe.macro.ClassField>>
										[Var `(18118):Null<haxe.macro.TypedExpr>]
											[Field:Null<haxe.macro.TypedExpr>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Null<haxe.macro.TypedExpr>] init:Null<haxe.macro.TypedExpr>
										[Var `(18119):Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
											[Field:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] interfaces:Array<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
										[Var `(18120):Bool]
											[Field:Bool]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Bool] isAbstract:Bool
										[Var `(18121):Bool]
											[Field:Bool]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Bool] isExtern:Bool
										[Var `(18122):Bool]
											[Field:Bool]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Bool] isFinal:Bool
										[Var `(18123):Bool]
											[Field:Bool]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Bool] isInterface:Bool
										[Var `(18124):Bool]
											[Field:Bool]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Bool] isPrivate:Bool
										[Var `(18125):haxe.macro.ClassKind]
											[Field:haxe.macro.ClassKind]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:haxe.macro.ClassKind] kind:haxe.macro.ClassKind
										[Var `(18126):haxe.macro.MetaAccess]
											[Field:haxe.macro.MetaAccess]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
										[Var `(18127):String]
											[Field:String]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:String] module:String
										[Var `(18128):String]
											[Field:String]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:String] name:String
										[Var `(18129):Array<haxe.macro.Ref<haxe.macro.ClassField>>]
											[Field:Array<haxe.macro.Ref<haxe.macro.ClassField>>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Array<haxe.macro.Ref<haxe.macro.ClassField>>] overrides:Array<haxe.macro.Ref<haxe.macro.ClassField>>
										[Var `(18130):Array<String>]
											[Field:Array<String>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Array<String>] pack:Array<String>
										[Var `(18131):Array<haxe.macro.TypeParameter>]
											[Field:Array<haxe.macro.TypeParameter>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Array<haxe.macro.TypeParameter>] params:Array<haxe.macro.TypeParameter>
										[Var `(18132):haxe.macro.Position]
											[Field:haxe.macro.Position]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:haxe.macro.Position] pos:haxe.macro.Position
										[Var `(18133):haxe.macro.Ref<Array<haxe.macro.ClassField>>]
											[Field:haxe.macro.Ref<Array<haxe.macro.ClassField>>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:haxe.macro.Ref<Array<haxe.macro.ClassField>>] statics:haxe.macro.Ref<Array<haxe.macro.ClassField>>
										[Var `(18134):Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
											[Field:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>]
												[Local _hx_tmp(18114):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>] superClass:Null<{ t : haxe.macro.Ref<haxe.macro.ClassType>, params : Array<haxe.macro.Type> }>
										[If:Bool]
											[Binop:Bool]
												[Local `(18128):String:String]
												==
												[Const:String] "Array"
											[Then:Bool] [Block:Bool] [Block:Bool] [Const:Bool] true
											[Else:Bool] [Block:Bool]
												[Meta:Bool]
													:ast(switch (expr.expr) {
	case TLocal(_):
		true;	
	default:
		false;	
})
													[Block:Bool]
														[Var `(18135):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local expr(18081):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Bool]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(18135):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 1
															[Then:Bool] [Block:Bool]
																[Var `(18136):haxe.macro.TVar]
																	[EnumParameter:haxe.macro.TVar]
																		[Local `(18135):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TLocal
																		0
																[Block:Bool] [Const:Bool] true
															[Else:Bool] [Block:Bool] [Const:Bool] false
							[Else:Bool] [Block:Bool]
								[Meta:Bool]
									:ast(switch (expr.expr) {
	case TLocal(_):
		true;	
	default:
		false;	
})
									[Block:Bool]
										[Var `(18137):haxe.macro.TypedExprDef]
											[Field:haxe.macro.TypedExprDef]
												[Local expr(18081):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
										[If:Bool]
											[Binop:Bool]
												[EnumIndex:Int] [Local `(18137):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												==
												[Const:Int] 1
											[Then:Bool] [Block:Bool]
												[Var `(18138):haxe.macro.TVar]
													[EnumParameter:haxe.macro.TVar]
														[Local `(18137):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
														TLocal
														0
												[Block:Bool] [Const:Bool] true
											[Else:Bool] [Block:Bool] [Const:Bool] false

	function extractMutationExpression[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(18203):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
				[Call:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
					[Field:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
						[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
						[FInstance:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
							reflaxe.elixir.helpers.ConditionalCompiler
							detectArrayMutation:(expr : haxe.macro.TypedExpr) -> Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>
					[Local expr(18203):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
			[If:Void]
				[Binop:Bool]
					[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
					==
					[Const:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.ConditionalCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Local expr(18203):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Const:Null<Bool>] null
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (mutation.type) {
	case "push":
		var arrayStr = extractArrayVariableName(mutation.arrayExpr);
		var argStr = if (mutation.args.length > 0) {
			compiler.compileExpression(mutation.args[0]);
		} else {
			"nil";
		};
		"${arrayStr} ++ [${argStr}]";	
	case "concat":
		var arrayStr = extractArrayVariableName(mutation.arrayExpr);
		var argStr = if (mutation.args.length > 0) {
			compiler.compileExpression(mutation.args[0]);
		} else {
			"[]";
		};
		"${arrayStr} ++ ${argStr}";	
	default:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(18210):String]
							[Field:String]
								[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
								[FAnon:String] type:String
						[Switch:String]
							[Local `(18210):String:String]
							[Case:String]
								[Const:String] "concat"
								[Block:String]
									[Block:String]
										[Var arrayStr(18211):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.ConditionalCompiler
														extractArrayVariableName:(expr : haxe.macro.TypedExpr) -> String
												[Field:haxe.macro.TypedExpr]
													[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[FAnon:haxe.macro.TypedExpr] arrayExpr:haxe.macro.TypedExpr
										[Var argStr(18212):Null<String>]
											[If:Null<String>]
												[Binop:Bool]
													[Field:Int]
														[Field:Array<haxe.macro.TypedExpr>]
															[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															[FAnon:Array<haxe.macro.TypedExpr>] args:Array<haxe.macro.TypedExpr>
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
													>
													[Const:Int] 0
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ConditionalCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Field:Array<haxe.macro.TypedExpr>]
																[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																[FAnon:Array<haxe.macro.TypedExpr>] args:Array<haxe.macro.TypedExpr>
															[Const:Int] 0
														[Const:Null<Bool>] null
												[Else:String] [Block:String] [Const:String] "[]"
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] ""
													+
													[Local arrayStr(18211):String:String]
												+
												[Const:String] " ++ "
											+
											[Local argStr(18212):Null<String>:Null<String>]
							[Case:String]
								[Const:String] "push"
								[Block:String]
									[Block:String]
										[Var arrayStr(18213):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.ConditionalCompiler
														extractArrayVariableName:(expr : haxe.macro.TypedExpr) -> String
												[Field:haxe.macro.TypedExpr]
													[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
													[FAnon:haxe.macro.TypedExpr] arrayExpr:haxe.macro.TypedExpr
										[Var argStr(18214):Null<String>]
											[If:Null<String>]
												[Binop:Bool]
													[Field:Int]
														[Field:Array<haxe.macro.TypedExpr>]
															[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
															[FAnon:Array<haxe.macro.TypedExpr>] args:Array<haxe.macro.TypedExpr>
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
													>
													[Const:Int] 0
												[Then:Null<String>] [Block:Null<String>]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ConditionalCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Array:haxe.macro.TypedExpr]
															[Field:Array<haxe.macro.TypedExpr>]
																[Local mutation(18204):Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>:Null<reflaxe.elixir.helpers._ConditionalCompiler.ArrayMutationInfo>]
																[FAnon:Array<haxe.macro.TypedExpr>] args:Array<haxe.macro.TypedExpr>
															[Const:Int] 0
														[Const:Null<Bool>] null
												[Else:String] [Block:String] [Const:String] "nil"
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local arrayStr(18213):String:String]
													+
													[Const:String] " ++ ["
												+
												[Local argStr(18214):Null<String>:Null<String>]
											+
											[Const:String] "]"
							[Default:Null<String>]
								[Block:Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.ConditionalCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.ConditionalCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local expr(18203):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null
}