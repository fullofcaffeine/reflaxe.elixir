@:nullSafety(Off)
class reflaxe.elixir.helpers.CodeFixupCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(29794):reflaxe.elixir.ElixirCompiler]
		[Block:Void]
			[Binop:Null<reflaxe.elixir.SourceMapWriter>]
				[Field:Null<reflaxe.elixir.SourceMapWriter>]
					[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
					[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
						reflaxe.elixir.helpers.CodeFixupCompiler
						currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
				=
				[Const:Null<reflaxe.elixir.SourceMapWriter>] null
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.CodeFixupCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(29794):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	@:value(null)
	var currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>;

	public function fixMalformedConditionals[Function:(code : String) -> String]
		[Arg:String] [Local code(29795):String]
		[Block:Dynamic]
			[Var fixedCode(29796):String] [Local code(29795):String:String]
			[Var lines(29797):Array<String>]
				[Call:Array<String>]
					[Field:(delimiter : String) -> Array<String>]
						[Local fixedCode(29796):String:String]
						[FInstance:(delimiter : String) -> Array<String>]
							String
							split:(delimiter : String) -> Array<String>
					[Const:String] "\n"
			[Var fixedLines(29798):Array<String>] [ArrayDecl:Array<String>]
			[Var fixCount(29799):Int] [Const:Int] 0
			[Block:Void]
				[Var `(29866):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(29866):Int:Int]
						<
						[Field:Int]
							[Local lines(29797):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var line(29800):String]
							[Array:String]
								[Local lines(29797):Array<String>:Array<String>]
								[Local `(29866):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(29866):Int:Int]
						[Var wasFixed(29801):Bool] [Const:Bool] false
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local line(29800):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] ", else:"
											[Const:Null<Int>] null
										!=
										[Const:Int] -1
									&&
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local line(29800):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] " = "
											[Const:Null<Int>] null
										!=
										[Const:Int] -1
								&&
								[Unop:Bool]
									!
									Prefix
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local line(29800):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Const:String] "if ("
											[Const:Null<Int>] null
										!=
										[Const:Int] -1
							[Then:Int] [Block:Int]
								[Var indent(29816):String]
									[Call:String]
										[Field:(line : String) -> String]
											[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
											[FInstance:(line : String) -> String]
												reflaxe.elixir.helpers.CodeFixupCompiler
												extractIndentation:(line : String) -> String
										[Local line(29800):String:String]
								[Var trimmed(29817):String]
									[Call:String]
										[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
											[Local line(29800):String:String]
											[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
												String
												substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
										[Field:Int]
											[Local indent(29816):String:String]
											[FInstance:Int]
												String
												length:Int
										[Const:Null<Int>] null
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fixedLines(29798):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Local indent(29816):String:String]
											+
											[Const:String] "# FIXME: Malformed assignment with else: "
										+
										[Local trimmed(29817):String:String]
								[Binop:Bool]
									[Local wasFixed(29801):Bool:Bool]
									=
									[Const:Bool] true
								[Unop:Int]
									++
									Postfix
									[Local fixCount(29799):Int:Int]
							[Else:Void] [Block:Void]
								[If:Void]
									[Binop:Bool]
										[Binop:Bool]
											[Binop:Bool]
												[Call:Int]
													[Field:(str : String, ?startIndex : Null<Int>) -> Int]
														[Local line(29800):String:String]
														[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
															String
															indexOf:(str : String, ?startIndex : Null<Int>) -> Int
													[Const:String] "}, else:"
													[Const:Null<Int>] null
												!=
												[Const:Int] -1
											&&
											[Binop:Bool]
												[Call:Int]
													[Field:(str : String, ?startIndex : Null<Int>) -> Int]
														[Local line(29800):String:String]
														[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
															String
															indexOf:(str : String, ?startIndex : Null<Int>) -> Int
													[Const:String] " = "
													[Const:Null<Int>] null
												!=
												[Const:Int] -1
										&&
										[Unop:Bool]
											!
											Prefix
											[Binop:Bool]
												[Call:Int]
													[Field:(str : String, ?startIndex : Null<Int>) -> Int]
														[Local line(29800):String:String]
														[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
															String
															indexOf:(str : String, ?startIndex : Null<Int>) -> Int
													[Const:String] "if ("
													[Const:Null<Int>] null
												!=
												[Const:Int] -1
									[Then:Int] [Block:Int]
										[Var indent(29830):String]
											[Call:String]
												[Field:(line : String) -> String]
													[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
													[FInstance:(line : String) -> String]
														reflaxe.elixir.helpers.CodeFixupCompiler
														extractIndentation:(line : String) -> String
												[Local line(29800):String:String]
										[Var trimmed(29831):String]
											[Call:String]
												[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
													[Local line(29800):String:String]
													[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
														String
														substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
												[Field:Int]
													[Local indent(29830):String:String]
													[FInstance:Int]
														String
														length:Int
												[Const:Null<Int>] null
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local fixedLines(29798):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Local indent(29830):String:String]
													+
													[Const:String] "# FIXME: Malformed assignment with hanging else: "
												+
												[Local trimmed(29831):String:String]
										[Binop:Bool]
											[Local wasFixed(29801):Bool:Bool]
											=
											[Const:Bool] true
										[Unop:Int]
											++
											Postfix
											[Local fixCount(29799):Int:Int]
									[Else:Void] [Block:Void]
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local line(29800):String:String]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] " = "
															[Const:Null<Int>] null
														!=
														[Const:Int] -1
													&&
													[Call:Bool]
														[Field:(s : String, end : String) -> Bool]
															[TypeExpr StringTools:{ Statics StringTools }]
															[FStatic:(s : String, end : String) -> Bool]
																StringTools
																endsWith:(s : String, end : String) -> Bool
														[Local line(29800):String:String]
														[Const:String] ", else: nil"
												&&
												[Unop:Bool]
													!
													Prefix
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local line(29800):String:String]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "if ("
															[Const:Null<Int>] null
														!=
														[Const:Int] -1
											[Then:Int] [Block:Int]
												[Var indent(29840):String]
													[Call:String]
														[Field:(line : String) -> String]
															[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
															[FInstance:(line : String) -> String]
																reflaxe.elixir.helpers.CodeFixupCompiler
																extractIndentation:(line : String) -> String
														[Local line(29800):String:String]
												[Var trimmed(29841):String]
													[Call:String]
														[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
															[Local line(29800):String:String]
															[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																String
																substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
														[Field:Int]
															[Local indent(29840):String:String]
															[FInstance:Int]
																String
																length:Int
														[Const:Null<Int>] null
												[Call:Int]
													[Field:(x : String) -> Int]
														[Local fixedLines(29798):Array<String>:Array<String>]
														[FInstance:(x : String) -> Int]
															Array<String>
															push:(x : Array.T) -> Int
													[Binop:String]
														[Binop:String]
															[Local indent(29840):String:String]
															+
															[Const:String] "# FIXME: Assignment with hanging else nil: "
														+
														[Local trimmed(29841):String:String]
												[Binop:Bool]
													[Local wasFixed(29801):Bool:Bool]
													=
													[Const:Bool] true
												[Unop:Int]
													++
													Postfix
													[Local fixCount(29799):Int:Int]
											[Else:Void] [Block:Void]
												[If:Void]
													[Binop:Bool]
														[Binop:Bool]
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local line(29800):String:String]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] " = "
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
															&&
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local line(29800):String:String]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] ", else: nil"
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
														&&
														[Unop:Bool]
															!
															Prefix
															[Binop:Bool]
																[Call:Int]
																	[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																		[Local line(29800):String:String]
																		[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																			String
																			indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																	[Const:String] "if ("
																	[Const:Null<Int>] null
																!=
																[Const:Int] -1
													[Then:Int] [Block:Int]
														[Var indent(29854):String]
															[Call:String]
																[Field:(line : String) -> String]
																	[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
																	[FInstance:(line : String) -> String]
																		reflaxe.elixir.helpers.CodeFixupCompiler
																		extractIndentation:(line : String) -> String
																[Local line(29800):String:String]
														[Var trimmed(29855):String]
															[Call:String]
																[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																	[Local line(29800):String:String]
																	[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																		String
																		substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
																[Field:Int]
																	[Local indent(29854):String:String]
																	[FInstance:Int]
																		String
																		length:Int
																[Const:Null<Int>] null
														[Call:Int]
															[Field:(x : String) -> Int]
																[Local fixedLines(29798):Array<String>:Array<String>]
																[FInstance:(x : String) -> Int]
																	Array<String>
																	push:(x : Array.T) -> Int
															[Binop:String]
																[Binop:String]
																	[Local indent(29854):String:String]
																	+
																	[Const:String] "# FIXME: Assignment with hanging else nil anywhere: "
																+
																[Local trimmed(29855):String:String]
														[Binop:Bool]
															[Local wasFixed(29801):Bool:Bool]
															=
															[Const:Bool] true
														[Unop:Int]
															++
															Postfix
															[Local fixCount(29799):Int:Int]
													[Else:Void] [Block:Void]
														[If:Void]
															[Binop:Bool]
																[Binop:Bool]
																	[Call:Int]
																		[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																			[Local line(29800):String:String]
																			[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																				String
																				indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																		[Const:String] "}, else:"
																		[Const:Null<Int>] null
																	!=
																	[Const:Int] -1
																&&
																[Unop:Bool]
																	!
																	Prefix
																	[Binop:Bool]
																		[Call:Int]
																			[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																				[Local line(29800):String:String]
																				[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																					String
																					indexOf:(str : String, ?startIndex : Null<Int>) -> Int
																			[Const:String] "if ("
																			[Const:Null<Int>] null
																		!=
																		[Const:Int] -1
															[Then:Int] [Block:Int]
																[Var indent(29864):String]
																	[Call:String]
																		[Field:(line : String) -> String]
																			[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
																			[FInstance:(line : String) -> String]
																				reflaxe.elixir.helpers.CodeFixupCompiler
																				extractIndentation:(line : String) -> String
																		[Local line(29800):String:String]
																[Var trimmed(29865):String]
																	[Call:String]
																		[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																			[Local line(29800):String:String]
																			[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
																				String
																				substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
																		[Field:Int]
																			[Local indent(29864):String:String]
																			[FInstance:Int]
																				String
																				length:Int
																		[Const:Null<Int>] null
																[Call:Int]
																	[Field:(x : String) -> Int]
																		[Local fixedLines(29798):Array<String>:Array<String>]
																		[FInstance:(x : String) -> Int]
																			Array<String>
																			push:(x : Array.T) -> Int
																	[Binop:String]
																		[Binop:String]
																			[Local indent(29864):String:String]
																			+
																			[Const:String] "# FIXME: Malformed conditional: "
																		+
																		[Local trimmed(29865):String:String]
																[Binop:Bool]
																	[Local wasFixed(29801):Bool:Bool]
																	=
																	[Const:Bool] true
																[Unop:Int]
																	++
																	Postfix
																	[Local fixCount(29799):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Local wasFixed(29801):Bool:Bool]
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fixedLines(29798):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Local line(29800):String:String]
			[Var result(29867):String]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local fixedLines(29798):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] "\n"
			[Return:Dynamic] [Local result(29867):String:String]

	function extractIndentation[Function:(line : String) -> String]
		[Arg:String] [Local line(29814):String]
		[Block:Dynamic]
			[Var spaceMatch(29815):EReg]
				[New:EReg]
					EReg
					[Const:String] "^(\\s*)"
					[Const:String] ""
			[If:Void]
				[Call:Bool]
					[Field:(s : String) -> Bool]
						[Local spaceMatch(29815):EReg:EReg]
						[FInstance:(s : String) -> Bool]
							EReg
							match:(s : String) -> Bool
					[Local line(29814):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(n : Int) -> String]
								[Local spaceMatch(29815):EReg:EReg]
								[FInstance:(n : Int) -> String]
									EReg
									matched:(n : Int) -> String
							[Const:Int] 1
			[Return:Dynamic] [Const:String] ""

	public function getCurrentAppName[Function:() -> String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Null<haxe.macro.ClassType>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.CodeFixupCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
					!=
					[Const:Null<haxe.macro.ClassType>] null
				[Then:Void] [Block:Void]
					[Var annotatedName(29868):Null<String>]
						[Call:Null<String>]
							[Field:(classType : haxe.macro.ClassType) -> Null<String>]
								[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
								[FStatic:(classType : haxe.macro.ClassType) -> Null<String>]
									reflaxe.elixir.helpers.AnnotationSystem
									getAppName:(classType : haxe.macro.ClassType) -> Null<String>
							[Field:Null<haxe.macro.ClassType>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.CodeFixupCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:Null<haxe.macro.ClassType>]
									reflaxe.elixir.ElixirCompiler
									currentClassType:Null<haxe.macro.ClassType>
					[If:Void]
						[Binop:Bool]
							[Local annotatedName(29868):Null<String>:Null<String>]
							!=
							[Const:Null<String>] null
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local annotatedName(29868):Null<String>:Null<String>]
			[Var globalName(29869):Null<String>]
				[Call:Null<String>]
					[Field:() -> Null<String>]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:() -> Null<String>]
							reflaxe.elixir.helpers.AnnotationSystem
							getGlobalAppName:() -> Null<String>
			[If:Void]
				[Binop:Bool]
					[Local globalName(29869):Null<String>:Null<String>]
					!=
					[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local globalName(29869):Null<String>:Null<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Null<haxe.macro.ClassType>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.CodeFixupCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
					!=
					[Const:Null<haxe.macro.ClassType>] null
				[Then:Void] [Block:Void]
					[Var className(29870):String]
						[Field:String]
							[Field:Null<haxe.macro.ClassType>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.CodeFixupCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:Null<haxe.macro.ClassType>]
									reflaxe.elixir.ElixirCompiler
									currentClassType:Null<haxe.macro.ClassType>
							[FAnon:String] name:String
					[If:Void]
						[Call:Bool]
							[Field:(s : String, end : String) -> Bool]
								[TypeExpr StringTools:{ Statics StringTools }]
								[FStatic:(s : String, end : String) -> Bool]
									StringTools
									endsWith:(s : String, end : String) -> Bool
							[Local className(29870):String:String]
							[Const:String] "App"
						[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local className(29870):String:String]
			[Return:Dynamic] [Const:String] "App"

	public function replaceAppNameCalls[Function:(code : String, classType : haxe.macro.ClassType) -> String]
		[Arg:String] [Local code(29871):String]
		[Arg:haxe.macro.ClassType] [Local classType(29872):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var appName(29873):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.AnnotationSystem
							getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
					[Local classType(29872):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var processedCode(29874):String] [Local code(29871):String:String]
			[Binop:String]
				[Local processedCode(29874):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local processedCode(29874):String:String]
					[Const:String] "getAppName()"
					[Binop:String]
						[Binop:String]
							[Const:String] "\""
							+
							[Local appName(29873):String:String]
						+
						[Const:String] "\""
			[Binop:String]
				[Local processedCode(29874):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[New:EReg]
							EReg
							[Const:String] "([A-Za-z0-9_]+)\\.getAppName\\(\\)"
							[Const:String] "g"
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local processedCode(29874):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "\""
							+
							[Local appName(29873):String:String]
						+
						[Const:String] "\""
			[Binop:String]
				[Local processedCode(29874):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[New:EReg]
							EReg
							[Const:String] "([A-Za-z0-9_]+)\\.get_app_name\\(\\)"
							[Const:String] "g"
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local processedCode(29874):String:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "\""
							+
							[Local appName(29873):String:String]
						+
						[Const:String] "\""
			[Binop:String]
				[Local processedCode(29874):String:String]
				=
				[Call:String]
					[Field:(s : String, by : String) -> String]
						[New:EReg]
							EReg
							[Const:String] "([A-Za-z0-9_]+)\\.\"([^\"]+)\""
							[Const:String] "g"
						[FInstance:(s : String, by : String) -> String]
							EReg
							replace:(s : String, by : String) -> String
					[Local processedCode(29874):String:String]
					[Const:String] "\"$2\""
			[Return:Dynamic] [Local processedCode(29874):String:String]

	public function initSourceMapWriter[Function:(outputPath : String) -> Void]
		[Arg:String] [Local outputPath(29875):String]
		[Block:Void]
			[If:Void]
				[Field:Bool]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.CodeFixupCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:Bool]
						reflaxe.elixir.ElixirCompiler
						sourceMapOutputEnabled:Bool
				[Then:Void] [Block:Void]
					[Binop:Null<reflaxe.elixir.SourceMapWriter>]
						[Field:Null<reflaxe.elixir.SourceMapWriter>]
							[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
							[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
								reflaxe.elixir.helpers.CodeFixupCompiler
								currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
						=
						[New:reflaxe.elixir.SourceMapWriter]
							reflaxe.elixir.SourceMapWriter
							[Local outputPath(29875):String:String]
					[Binop:Null<reflaxe.elixir.SourceMapWriter>]
						[Field:Null<reflaxe.elixir.SourceMapWriter>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.CodeFixupCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
								reflaxe.elixir.ElixirCompiler
								currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
						=
						[Field:Null<reflaxe.elixir.SourceMapWriter>]
							[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
							[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
								reflaxe.elixir.helpers.CodeFixupCompiler
								currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
					[If:Void]
						[Binop:Bool]
							[Field:Array<reflaxe.elixir.SourceMapWriter>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.CodeFixupCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:Array<reflaxe.elixir.SourceMapWriter>]
									reflaxe.elixir.ElixirCompiler
									pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>
							!=
							[Const:Array<reflaxe.elixir.SourceMapWriter>] null
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : reflaxe.elixir.SourceMapWriter) -> Int]
									[Field:Array<reflaxe.elixir.SourceMapWriter>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.CodeFixupCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:Array<reflaxe.elixir.SourceMapWriter>]
											reflaxe.elixir.ElixirCompiler
											pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>
									[FInstance:(x : reflaxe.elixir.SourceMapWriter) -> Int]
										Array<reflaxe.elixir.SourceMapWriter>
										push:(x : Array.T) -> Int
								[Field:Null<reflaxe.elixir.SourceMapWriter>]
									[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
									[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
										reflaxe.elixir.helpers.CodeFixupCompiler
										currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
				[Else:Void] [Block:Void]

	public function finalizeSourceMapWriter[Function:() -> Null<String>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Null<reflaxe.elixir.SourceMapWriter>]
						[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
						[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
							reflaxe.elixir.helpers.CodeFixupCompiler
							currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
					!=
					[Const:Null<reflaxe.elixir.SourceMapWriter>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var mapPath(29876):String]
						[Call:String]
							[Field:() -> String]
								[Field:Null<reflaxe.elixir.SourceMapWriter>]
									[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
									[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
										reflaxe.elixir.helpers.CodeFixupCompiler
										currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
								[FInstance:() -> String]
									reflaxe.elixir.SourceMapWriter
									generateSourceMap:() -> String
					[Binop:Null<reflaxe.elixir.SourceMapWriter>]
						[Field:Null<reflaxe.elixir.SourceMapWriter>]
							[Const:reflaxe.elixir.helpers.CodeFixupCompiler] this
							[FInstance:Null<reflaxe.elixir.SourceMapWriter>]
								reflaxe.elixir.helpers.CodeFixupCompiler
								currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>
						=
						[Const:Null<reflaxe.elixir.SourceMapWriter>] null
					[Return:Dynamic] [Local mapPath(29876):String:String]
			[Return:Dynamic] [Const:Null<String>] null

	public function cleanupSyntaxArtifacts[Function:(code : String) -> String]
		[Arg:String] [Local code(29877):String]
		[Block:Dynamic]
			[Var cleanedCode(29878):String] [Local code(29877):String:String]
			[Binop:String]
				[Local cleanedCode(29878):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local cleanedCode(29878):String:String]
					[Const:String] " <> \"\""
					[Const:String] ""
			[Binop:String]
				[Local cleanedCode(29878):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local cleanedCode(29878):String:String]
					[Const:String] "\"\" <> "
					[Const:String] ""
			[Binop:String]
				[Local cleanedCode(29878):String:String]
				=
				[Call:String]
					[Field:(s : String, sub : String, by : String) -> String]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, sub : String, by : String) -> String]
							StringTools
							replace:(s : String, sub : String, by : String) -> String
					[Local cleanedCode(29878):String:String]
					[Const:String] " <> <> "
					[Const:String] " <> "
			[Return:Dynamic] [Local cleanedCode(29878):String:String]
}