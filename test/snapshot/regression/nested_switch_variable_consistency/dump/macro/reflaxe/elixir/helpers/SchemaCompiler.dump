@:nullSafety(Off)
class reflaxe.elixir.helpers.SchemaCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(26003):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.SchemaCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.SchemaCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(26003):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileSchemaClass[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26004):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(26005):Array<Dynamic>]
		[Arg:Array<Dynamic>] [Local funcFields(26006):Array<Dynamic>]
		[Block:Dynamic]
			[Var moduleName(26008):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.SchemaCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.SchemaCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.ElixirCompiler
							getModuleName:(classType : haxe.macro.ClassType) -> String
					[Local classType(26004):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var tableName(26023):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							extractTableName:(classType : haxe.macro.ClassType) -> String
					[Local classType(26004):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var result(26024):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local moduleName(26008):String:String]
					+
					[Const:String] " do\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Const:String] "  use Ecto.Schema\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Const:String] "  import Ecto.Changeset\n\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "  schema \""
						+
						[Local tableName(26023):String:String]
					+
					[Const:String] "\" do\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Call:String]
					[Field:(varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateSchemaFields:(varFields : Array<Dynamic>) -> String
					[Local varFields(26005):Array<Dynamic>:Array<Dynamic>]
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Const:String] "\n    timestamps()\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Const:String] "  end\n\n"
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateChangesetFunction:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String
					[Local classType(26004):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(26005):Array<Dynamic>:Array<Dynamic>]
			[Block:Void]
				[Var `(26080):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26080):Int:Int]
						<
						[Field:Int]
							[Local funcFields(26006):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var funcField(26076):Dynamic]
							[Array:Dynamic]
								[Local funcFields(26006):Array<Dynamic>:Array<Dynamic>]
								[Local `(26080):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26080):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Call:Bool]
									[Field:(name : String) -> Bool]
										[Const:reflaxe.elixir.helpers.SchemaCompiler] this
										[FInstance:(name : String) -> Bool]
											reflaxe.elixir.helpers.SchemaCompiler
											isSpecialFunction:(name : String) -> Bool
									[Field:Dynamic]
										[Local funcField(26076):Dynamic:Dynamic]
										[FDynamic:Dynamic] name
							[Then:String] [Block:String]
								[Binop:String]
									[Local result(26024):String:String]
									+=
									[Binop:String]
										[Const:String] "\n"
										+
										[Call:String]
											[Field:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.SchemaCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.SchemaCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
													reflaxe.elixir.ElixirCompiler
													compileFunction:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String
											[Local funcField(26076):Dynamic:Dynamic]
											[Const:Bool] true
			[Binop:String]
				[Local result(26024):String:String]
				+=
				[Const:String] "end\n"
			[Return:Dynamic] [Local result(26024):String:String]

	public function compileChangesetClass[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26081):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(26082):Array<Dynamic>]
		[Arg:Array<Dynamic>] [Local funcFields(26083):Array<Dynamic>]
		[Block:Dynamic]
			[Var moduleName(26084):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.SchemaCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.SchemaCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.ElixirCompiler
							getModuleName:(classType : haxe.macro.ClassType) -> String
					[Local classType(26081):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var result(26085):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local moduleName(26084):String:String]
					+
					[Const:String] " do\n"
			[Binop:String]
				[Local result(26085):String:String]
				+=
				[Const:String] "  import Ecto.Changeset\n\n"
			[Block:Void]
				[Var `(26087):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26087):Int:Int]
						<
						[Field:Int]
							[Local funcFields(26083):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var funcField(26086):Dynamic]
							[Array:Dynamic]
								[Local funcFields(26083):Array<Dynamic>:Array<Dynamic>]
								[Local `(26087):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26087):Int:Int]
						[Binop:String]
							[Local result(26085):String:String]
							+=
							[Binop:String]
								[Call:String]
									[Field:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.SchemaCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.SchemaCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
											reflaxe.elixir.ElixirCompiler
											compileFunction:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String
									[Local funcField(26086):Dynamic:Dynamic]
									[Const:Bool] true
								+
								[Const:String] "\n"
			[Binop:String]
				[Local result(26085):String:String]
				+=
				[Const:String] "end\n"
			[Return:Dynamic] [Local result(26085):String:String]

	function extractTableName[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26009):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var tableMeta(26010):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Field:haxe.macro.MetaAccess]
							[Local classType(26009):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":table"
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local tableMeta(26010):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
						!=
						[Const:Array<haxe.macro.MetadataEntry>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Local tableMeta(26010):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
							[FInstance:Int]
								Array<haxe.macro.MetadataEntry>
								length:Int
						>
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Meta:String]
							:ast(switch (tableMeta[0].params[0].expr) {
	case EConst(CString(s)):
		s;	
	default:
		pluralizeTableName(classType.name);	
})
							[Block:String]
								[Var `(26018):haxe.macro.ExprDef]
									[Field:haxe.macro.ExprDef]
										[Array:haxe.macro.Expr]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Array:haxe.macro.MetadataEntry]
													[Local tableMeta(26010):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
													[Const:Int] 0
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											[Const:Int] 0
										[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
								[If:String]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(26018):haxe.macro.ExprDef:haxe.macro.ExprDef]
										==
										[Const:Int] 0
									[Then:String] [Block:String]
										[Var `(26019):haxe.macro.Constant]
											[EnumParameter:haxe.macro.Constant]
												[Local `(26018):haxe.macro.ExprDef:haxe.macro.ExprDef]
												EConst
												0
										[If:String]
											[Binop:Bool]
												[EnumIndex:Int] [Local `(26019):haxe.macro.Constant:haxe.macro.Constant]
												==
												[Const:Int] 2
											[Then:String] [Block:String]
												[Var `(26020):String]
													[EnumParameter:String]
														[Local `(26019):haxe.macro.Constant:haxe.macro.Constant]
														CString
														0
												[Var `(26021):Null<haxe.macro.StringLiteralKind>]
													[EnumParameter:Null<haxe.macro.StringLiteralKind>]
														[Local `(26019):haxe.macro.Constant:haxe.macro.Constant]
														CString
														1
												[Block:String]
													[Var s(26022):String] [Local `(26020):String:String]
													[Block:String] [Local s(26022):String:String]
											[Else:String] [Block:String]
												[Call:String]
													[Field:(name : String) -> String]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:(name : String) -> String]
															reflaxe.elixir.helpers.SchemaCompiler
															pluralizeTableName:(name : String) -> String
													[Field:String]
														[Local classType(26009):haxe.macro.ClassType:haxe.macro.ClassType]
														[FAnon:String] name:String
									[Else:String] [Block:String]
										[Call:String]
											[Field:(name : String) -> String]
												[Const:reflaxe.elixir.helpers.SchemaCompiler] this
												[FInstance:(name : String) -> String]
													reflaxe.elixir.helpers.SchemaCompiler
													pluralizeTableName:(name : String) -> String
											[Field:String]
												[Local classType(26009):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:String] name:String
			[Return:Dynamic]
				[Call:String]
					[Field:(name : String) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(name : String) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							pluralizeTableName:(name : String) -> String
					[Field:String]
						[Local classType(26009):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String

	function pluralizeTableName[Function:(name : String) -> String]
		[Arg:String] [Local name(26012):String]
		[Block:Void]
			[Var snakeName(26013):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local name(26012):String:String]
			[If:Void]
				[Call:Bool]
					[Field:(s : String, end : String) -> Bool]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, end : String) -> Bool]
							StringTools
							endsWith:(s : String, end : String) -> Bool
					[Local snakeName(26013):String:String]
					[Const:String] "y"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Call:String]
								[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									[Local snakeName(26013):String:String]
									[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
										String
										substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
								[Const:Int] 0
								[Binop:Int]
									[Field:Int]
										[Local snakeName(26013):String:String]
										[FInstance:Int]
											String
											length:Int
									-
									[Const:Int] 1
							+
							[Const:String] "ies"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Call:Bool]
									[Field:(s : String, end : String) -> Bool]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String, end : String) -> Bool]
											StringTools
											endsWith:(s : String, end : String) -> Bool
									[Local snakeName(26013):String:String]
									[Const:String] "s"
								||
								[Call:Bool]
									[Field:(s : String, end : String) -> Bool]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String, end : String) -> Bool]
											StringTools
											endsWith:(s : String, end : String) -> Bool
									[Local snakeName(26013):String:String]
									[Const:String] "x"
							||
							[Call:Bool]
								[Field:(s : String, end : String) -> Bool]
									[TypeExpr StringTools:{ Statics StringTools }]
									[FStatic:(s : String, end : String) -> Bool]
										StringTools
										endsWith:(s : String, end : String) -> Bool
								[Local snakeName(26013):String:String]
								[Const:String] "ch"
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Local snakeName(26013):String:String]
									+
									[Const:String] "es"
						[Else:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Local snakeName(26013):String:String]
									+
									[Const:String] "s"

	function generateSchemaFields[Function:(varFields : Array<Dynamic>) -> String]
		[Arg:Array<Dynamic>] [Local varFields(26025):Array<Dynamic>]
		[Block:Dynamic]
			[Var fields(26026):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26054):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26054):Int:Int]
						<
						[Field:Int]
							[Local varFields(26025):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(26027):Dynamic]
							[Array:Dynamic]
								[Local varFields(26025):Array<Dynamic>:Array<Dynamic>]
								[Local `(26054):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26054):Int:Int]
						[Var fieldName(26028):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(26027):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[Var fieldType(26048):String]
							[Call:String]
								[Field:(type : haxe.macro.Type) -> String]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(type : haxe.macro.Type) -> String]
										reflaxe.elixir.helpers.SchemaCompiler
										mapHaxeTypeToEcto:(type : haxe.macro.Type) -> String
								[Field:Dynamic]
									[Local varField(26027):Dynamic:Dynamic]
									[FDynamic:Dynamic] type
						[Var options(26053):Array<String>]
							[Call:Array<String>]
								[Field:(varField : Dynamic) -> Array<String>]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(varField : Dynamic) -> Array<String>]
										reflaxe.elixir.helpers.SchemaCompiler
										extractFieldOptions:(varField : Dynamic) -> Array<String>
								[Local varField(26027):Dynamic:Dynamic]
						[If:Void]
							[Binop:Bool]
								[Field:Int]
									[Local options(26053):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fields(26026):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "    field :"
														+
														[Local fieldName(26028):String:String]
													+
													[Const:String] ", "
												+
												[Local fieldType(26048):String:String]
											+
											[Const:String] ", "
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local options(26053):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] ", "
							[Else:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fields(26026):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "    field :"
												+
												[Local fieldName(26028):String:String]
											+
											[Const:String] ", "
										+
										[Local fieldType(26048):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Call:String]
						[Field:(sep : String) -> String]
							[Local fields(26026):Array<String>:Array<String>]
							[FInstance:(sep : String) -> String]
								Array<String>
								join:(sep : String) -> String
						[Const:String] "\n"
					+
					[Parenthesis:String]
						[If:String]
							[Binop:Bool]
								[Field:Int]
									[Local fields(26026):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:String] [Block:String] [Const:String] "\n"
							[Else:String] [Block:String] [Const:String] ""

	function mapHaxeTypeToEcto[Function:(type : haxe.macro.Type) -> String]
		[Arg:haxe.macro.Type] [Local type(26029):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (type) {
	case TInst(t, _):
		switch (t.get().name) {
			case "String":
				":string";			
			case "Date":
				":utc_datetime";			
			case "Array":
				":array";			
			default:
				":string";			
		};	
	case TAbstract(t, _):
		switch (t.get().name) {
			case "Int":
				":integer";			
			case "Float":
				":float";			
			case "Bool":
				":boolean";			
			default:
				":string";			
		};	
	default:
		":string";	
})
					[Switch:String]
						[EnumIndex:Int] [Local type(26029):haxe.macro.Type:haxe.macro.Type]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(26040):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(26029):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(26041):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(26029):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:String]
									[Var t(26042):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(26040):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Block:String]
										[Meta:String]
											:ast(switch (t.get().name) {
	case "String":
		":string";	
	case "Date":
		":utc_datetime";	
	case "Array":
		":array";	
	default:
		":string";	
})
											[Block:String]
												[Var `(26043):String]
													[Field:String]
														[Call:haxe.macro.ClassType]
															[Field:() -> haxe.macro.ClassType]
																[Local t(26042):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
																[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
														[FAnon:String] name:String
												[Switch:String]
													[Local `(26043):String:String]
													[Case:String]
														[Const:String] "Array"
														[Block:String] [Block:String] [Const:String] ":array"
													[Case:String]
														[Const:String] "Date"
														[Block:String] [Block:String] [Const:String] ":utc_datetime"
													[Case:String]
														[Const:String] "String"
														[Block:String] [Block:String] [Const:String] ":string"
													[Default:String] [Block:String] [Const:String] ":string"
						[Case:String]
							[Const:Int] 8
							[Block:String]
								[Var `(26044):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(26029):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(26045):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(26029):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:String]
									[Var t(26046):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(26044):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Block:String]
										[Meta:String]
											:ast(switch (t.get().name) {
	case "Int":
		":integer";	
	case "Float":
		":float";	
	case "Bool":
		":boolean";	
	default:
		":string";	
})
											[Block:String]
												[Var `(26047):String]
													[Field:String]
														[Call:haxe.macro.AbstractType]
															[Field:() -> haxe.macro.AbstractType]
																[Local t(26046):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
																[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
														[FAnon:String] name:String
												[Switch:String]
													[Local `(26047):String:String]
													[Case:String]
														[Const:String] "Bool"
														[Block:String] [Block:String] [Const:String] ":boolean"
													[Case:String]
														[Const:String] "Float"
														[Block:String] [Block:String] [Const:String] ":float"
													[Case:String]
														[Const:String] "Int"
														[Block:String] [Block:String] [Const:String] ":integer"
													[Default:String] [Block:String] [Const:String] ":string"
						[Default:String] [Block:String] [Const:String] ":string"

	function extractFieldOptions[Function:(varField : Dynamic) -> Array<String>]
		[Arg:Dynamic] [Local varField(26049):Dynamic]
		[Block:Dynamic]
			[Var options(26050):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local varField(26049):Dynamic:Dynamic]
						[FDynamic:Dynamic] meta
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[Var defaultMeta(26051):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
						[Call:Dynamic]
							[Field:Dynamic]
								[Field:Dynamic]
									[Local varField(26049):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								[FDynamic:Dynamic] extract
							[Const:String] ":default"
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local defaultMeta(26051):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
								!=
								[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
							&&
							[Binop:Bool]
								[Field:Int]
									[Local defaultMeta(26051):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									[FAnon:Int] length:Int
								>
								[Const:Int] 0
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local options(26050):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Binop:String]
									[Const:String] "default: "
									+
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.SchemaCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.SchemaCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Array:haxe.macro.TypedExpr]
											[Field:Array<haxe.macro.TypedExpr>]
												[Array:{ params : Array<haxe.macro.TypedExpr> }]
													[Local defaultMeta(26051):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
													[Const:Int] 0
												[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
											[Const:Int] 0
										[Const:Null<Bool>] null
					[Var nullableMeta(26052):Null<{ length : Int }>]
						[Call:Dynamic]
							[Field:Dynamic]
								[Field:Dynamic]
									[Local varField(26049):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								[FDynamic:Dynamic] extract
							[Const:String] ":nullable"
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local nullableMeta(26052):Null<{ length : Int }>:Null<{ length : Int }>]
								!=
								[Const:Null<{ length : Int }>] null
							&&
							[Binop:Bool]
								[Field:Int]
									[Local nullableMeta(26052):Null<{ length : Int }>:Null<{ length : Int }>]
									[FAnon:Int] length:Int
								>
								[Const:Int] 0
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local options(26050):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "nullable: true"
			[Return:Dynamic] [Local options(26050):Array<String>:Array<String>]

	function generateChangesetFunction[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26055):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(26056):Array<Dynamic>]
		[Block:Dynamic]
			[Var schemaVar(26057):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Field:String]
						[Local classType(26055):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
			[Var requiredFields(26058):Array<String>] [ArrayDecl:Array<String>]
			[Var optionalFields(26059):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26064):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26064):Int:Int]
						<
						[Field:Int]
							[Local varFields(26056):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(26060):Dynamic]
							[Array:Dynamic]
								[Local varFields(26056):Array<Dynamic>:Array<Dynamic>]
								[Local `(26064):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26064):Int:Int]
						[Var fieldName(26061):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(26060):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[If:Void]
							[Call:Bool]
								[Field:(varField : Dynamic) -> Bool]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(varField : Dynamic) -> Bool]
										reflaxe.elixir.helpers.SchemaCompiler
										isRequiredField:(varField : Dynamic) -> Bool
								[Local varField(26060):Dynamic:Dynamic]
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local requiredFields(26058):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Const:String] ":"
										+
										[Local fieldName(26061):String:String]
							[Else:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local optionalFields(26059):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Const:String] ":"
										+
										[Local fieldName(26061):String:String]
			[Var allFields(26065):Array<String>]
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local requiredFields(26058):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Local optionalFields(26059):Array<String>:Array<String>]
			[Var result(26066):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "  def changeset("
						+
						[Local schemaVar(26057):String:String]
					+
					[Const:String] ", attrs) do\n"
			[Binop:String]
				[Local result(26066):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "    "
						+
						[Local schemaVar(26057):String:String]
					+
					[Const:String] "\n"
			[Binop:String]
				[Local result(26066):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "    |> cast(attrs, ["
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local allFields(26065):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] "])\n"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local requiredFields(26058):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:String] [Block:String]
					[Binop:String]
						[Local result(26066):String:String]
						+=
						[Binop:String]
							[Binop:String]
								[Const:String] "    |> validate_required(["
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local requiredFields(26058):Array<String>:Array<String>]
										[FInstance:(sep : String) -> String]
											Array<String>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] "])\n"
			[Binop:String]
				[Local result(26066):String:String]
				+=
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateValidations:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String
					[Local classType(26055):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(26056):Array<Dynamic>:Array<Dynamic>]
			[Binop:String]
				[Local result(26066):String:String]
				+=
				[Const:String] "  end\n"
			[Return:Dynamic] [Local result(26066):String:String]

	function isRequiredField[Function:(varField : Dynamic) -> Bool]
		[Arg:Dynamic] [Local varField(26062):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local varField(26062):Dynamic:Dynamic]
						[FDynamic:Dynamic] meta
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var requiredMeta(26063):Null<{ length : Int }>]
				[Call:Dynamic]
					[Field:Dynamic]
						[Field:Dynamic]
							[Local varField(26062):Dynamic:Dynamic]
							[FDynamic:Dynamic] meta
						[FDynamic:Dynamic] extract
					[Const:String] ":required"
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local requiredMeta(26063):Null<{ length : Int }>:Null<{ length : Int }>]
						!=
						[Const:Null<{ length : Int }>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Local requiredMeta(26063):Null<{ length : Int }>:Null<{ length : Int }>]
							[FAnon:Int] length:Int
						>
						[Const:Int] 0

	function generateValidations[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26067):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(26068):Array<Dynamic>]
		[Block:Dynamic]
			[Var validations(26069):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26075):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26075):Int:Int]
						<
						[Field:Int]
							[Local varFields(26068):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(26070):Dynamic]
							[Array:Dynamic]
								[Local varFields(26068):Array<Dynamic>:Array<Dynamic>]
								[Local `(26075):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26075):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local varField(26070):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								==
								[Const:Dynamic] null
							[Then:Dynamic] [Block:Dynamic] [Continue:Dynamic]
						[Var fieldName(26071):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(26070):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[Var lengthMeta(26072):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(26070):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":length"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local lengthMeta(26072):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									!=
									[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local lengthMeta(26072):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(26069):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "    |> validate_length(:"
													+
													[Local fieldName(26071):String:String]
												+
												[Const:String] ", "
											+
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.SchemaCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Array:haxe.macro.TypedExpr]
													[Field:Array<haxe.macro.TypedExpr>]
														[Array:{ params : Array<haxe.macro.TypedExpr> }]
															[Local lengthMeta(26072):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
															[Const:Int] 0
														[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
													[Const:Int] 0
												[Const:Null<Bool>] null
										+
										[Const:String] ")"
						[Var formatMeta(26073):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(26070):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":format"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local formatMeta(26073):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									!=
									[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local formatMeta(26073):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(26069):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "    |> validate_format(:"
													+
													[Local fieldName(26071):String:String]
												+
												[Const:String] ", "
											+
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.SchemaCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Array:haxe.macro.TypedExpr]
													[Field:Array<haxe.macro.TypedExpr>]
														[Array:{ params : Array<haxe.macro.TypedExpr> }]
															[Local formatMeta(26073):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
															[Const:Int] 0
														[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
													[Const:Int] 0
												[Const:Null<Bool>] null
										+
										[Const:String] ")"
						[Var uniqueMeta(26074):Null<{ length : Int }>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(26070):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":unique"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local uniqueMeta(26074):Null<{ length : Int }>:Null<{ length : Int }>]
									!=
									[Const:Null<{ length : Int }>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local uniqueMeta(26074):Null<{ length : Int }>:Null<{ length : Int }>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(26069):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Const:String] "    |> unique_constraint(:"
											+
											[Local fieldName(26071):String:String]
										+
										[Const:String] ")"
			[Return:Dynamic]
				[Binop:String]
					[Call:String]
						[Field:(sep : String) -> String]
							[Local validations(26069):Array<String>:Array<String>]
							[FInstance:(sep : String) -> String]
								Array<String>
								join:(sep : String) -> String
						[Const:String] "\n"
					+
					[Parenthesis:String]
						[If:String]
							[Binop:Bool]
								[Field:Int]
									[Local validations(26069):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:String] [Block:String] [Const:String] "\n"
							[Else:String] [Block:String] [Const:String] ""

	function isSpecialFunction[Function:(name : String) -> Bool]
		[Arg:String] [Local name(26077):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Local name(26077):String:String]
							==
							[Const:String] "new"
						||
						[Binop:Bool]
							[Local name(26077):String:String]
							==
							[Const:String] "changeset"
					||
					[Binop:Bool]
						[Local name(26077):String:String]
						==
						[Const:String] "__construct"
}