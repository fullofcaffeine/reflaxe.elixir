@:nullSafety(Off)
class reflaxe.elixir.helpers.ExpressionVariantCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(30791):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.ExpressionVariantCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(30791):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileExpressionImpl[Function:(expr : haxe.macro.TypedExpr, topLevel : Bool) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(17732):haxe.macro.TypedExpr]
		[Arg:Bool] [Local topLevel(17733):Bool]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Bool]
								reflaxe.elixir.ElixirCompiler
								sourceMapOutputEnabled:Bool
						&&
						[Binop:Bool]
							[Local expr(17732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							!=
							[Const:haxe.macro.TypedExpr] null
					&&
					[Binop:Bool]
						[Field:haxe.macro.Position]
							[Local expr(17732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Position] pos:haxe.macro.Position
						!=
						[Const:haxe.macro.Position] null
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(pos : haxe.macro.Position) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(pos : haxe.macro.Position) -> Void]
								reflaxe.elixir.ElixirCompiler
								trackPosition:(pos : haxe.macro.Position) -> Void
						[Field:haxe.macro.Position]
							[Local expr(17732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Position] pos:haxe.macro.Position
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TLocal(v) if (v.name == "_this"):
		var mappedName = compiler.currentFunctionParameterMap.get("_this");
		if (mappedName != null) {
			return mappedName;
		};
		if (compiler.isCompilingStructMethod) {
			var globalMappedName = compiler.globalStructParameterMap.get("_this");
			if (globalMappedName != null) {
				return globalMappedName;
			};
		};	
	case TLocal(v):
		var compiledName = compiler.variableCompiler.compileVariableReference(v);
		return compiledName;	
	case _:
})
				[Block:Void]
					[Var `(17861):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(17732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(17861):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 1
						[Then:Void] [Block:Void]
							[Var `(17862):haxe.macro.TVar]
								[EnumParameter:haxe.macro.TVar]
									[Local `(17861):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TLocal
									0
							[Block:Void]
								[Var v(17863):haxe.macro.TVar] [Local `(17862):haxe.macro.TVar:haxe.macro.TVar]
								[If:Void]
									[Binop:Bool]
										[Field:String]
											[Local v(17863):haxe.macro.TVar:haxe.macro.TVar]
											[FAnon:String] name:String
										==
										[Const:String] "_this"
									[Then:Void] [Block:Void]
										[Var mappedName(17864):Null<String>]
											[Block:Null<String>]
												[Var this(17865):haxe.IMap<String, String>]
													[Field:Map<String, String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:Map<String, String>]
															reflaxe.elixir.ElixirCompiler
															currentFunctionParameterMap:Map<String, String>
												[Call:Null<String>]
													[Field:(key : String) -> Null<String>]
														[Cast:haxe.ds.StringMap<String>] [Local this(17865):haxe.IMap<String, String>:haxe.IMap<String, String>]
														[FInstance:(key : String) -> Null<String>]
															haxe.ds.StringMap<String>
															get:(key : String) -> Null<haxe.ds.StringMap.T>
													[Const:String] "_this"
										[If:Void]
											[Binop:Bool]
												[Local mappedName(17864):Null<String>:Null<String>]
												!=
												[Const:Null<String>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local mappedName(17864):Null<String>:Null<String>]
										[If:Void]
											[Field:Bool]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:Bool]
													reflaxe.elixir.ElixirCompiler
													isCompilingStructMethod:Bool
											[Then:Void] [Block:Void]
												[Var globalMappedName(17866):Null<String>]
													[Block:Null<String>]
														[Var this(17867):haxe.IMap<String, String>]
															[Field:Map<String, String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:Map<String, String>]
																	reflaxe.elixir.ElixirCompiler
																	globalStructParameterMap:Map<String, String>
														[Call:Null<String>]
															[Field:(key : String) -> Null<String>]
																[Cast:haxe.ds.StringMap<String>] [Local this(17867):haxe.IMap<String, String>:haxe.IMap<String, String>]
																[FInstance:(key : String) -> Null<String>]
																	haxe.ds.StringMap<String>
																	get:(key : String) -> Null<haxe.ds.StringMap.T>
															[Const:String] "_this"
												[If:Void]
													[Binop:Bool]
														[Local globalMappedName(17866):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
													[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local globalMappedName(17866):Null<String>:Null<String>]
									[Else:Dynamic] [Block:Dynamic]
										[Var v(17868):haxe.macro.TVar] [Local `(17862):haxe.macro.TVar:haxe.macro.TVar]
										[Block:Dynamic]
											[Var compiledName(17869):String]
												[Call:String]
													[Field:(tvar : haxe.macro.TVar) -> String]
														[Field:reflaxe.elixir.helpers.VariableCompiler]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:reflaxe.elixir.helpers.VariableCompiler]
																reflaxe.elixir.ElixirCompiler
																variableCompiler:reflaxe.elixir.helpers.VariableCompiler
														[FInstance:(tvar : haxe.macro.TVar) -> String]
															reflaxe.elixir.helpers.VariableCompiler
															compileVariableReference:(tvar : haxe.macro.TVar) -> String
													[Local v(17868):haxe.macro.TVar:haxe.macro.TVar]
											[Return:Dynamic] [Local compiledName(17869):String:String]
						[Else:Void] [Block:Void]
			[Var result(24063):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.helpers.ExpressionDispatcher]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.ExpressionDispatcher]
								reflaxe.elixir.ElixirCompiler
								expressionDispatcher:reflaxe.elixir.helpers.ExpressionDispatcher
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.helpers.ExpressionDispatcher
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local expr(17732):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local topLevel(17733):Bool:Bool]
			[If:Void]
				[Binop:Bool]
					[Field:Bool]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ExpressionVariantCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Bool]
							reflaxe.elixir.ElixirCompiler
							sourceMapOutputEnabled:Bool
					&&
					[Binop:Bool]
						[Local result(24063):Null<String>:Null<String>]
						!=
						[Const:Null<String>] null
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(output : String) -> Void]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(output : String) -> Void]
								reflaxe.elixir.ElixirCompiler
								trackOutput:(output : String) -> Void
						[Local result(24063):Null<String>:Null<String>]
			[Return:Dynamic] [Local result(24063):Null<String>:Null<String>]

	public function compileExpressionWithTypeAwareness[Function:(expr : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(30792):haxe.macro.TypedExpr]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Local expr(30792):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					==
					[Const:haxe.macro.TypedExpr] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "nil"
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TBinop(OpAdd, e1, e2):
		var e1IsString = compiler.isStringType(e1.t);
		var e2IsString = compiler.isStringType(e2.t);
		var isStringConcat = e1IsString || e2IsString;
		if (isStringConcat) {
			var left = switch (e1.expr) {
				case TConst(TString(s)):
					var escaped = StringTools.replace(s, "\\", "\\\\");
					escaped = StringTools.replace(escaped, "\"", "\\\"");
					escaped = StringTools.replace(escaped, "\n", "\\n");
					escaped = StringTools.replace(escaped, "\r", "\\r");
					escaped = StringTools.replace(escaped, "\t", "\\t");
					"\"${escaped}\"";				
				case _:
					compileExpressionWithTypeAwareness(e1);				
			};
			var right = switch (e2.expr) {
				case TConst(TString(s)):
					var escaped = StringTools.replace(s, "\\", "\\\\");
					escaped = StringTools.replace(escaped, "\"", "\\\"");
					escaped = StringTools.replace(escaped, "\n", "\\n");
					escaped = StringTools.replace(escaped, "\r", "\\r");
					escaped = StringTools.replace(escaped, "\t", "\\t");
					"\"${escaped}\"";				
				case _:
					compileExpressionWithTypeAwareness(e2);				
			};
			if (!e1IsString && e2IsString) {
				left = compiler.convertToString(e1, left);
			} else if (e1IsString && !e2IsString) {
				right = compiler.convertToString(e2, right);
			};
			return "${left} <> ${right}";
		} else {
			var left = compileExpressionWithTypeAwareness(e1);
			var right = compileExpressionWithTypeAwareness(e2);
			return "${left} + ${right}";
		};	
	case TBinop(op, e1, e2):
		var left = compileExpressionWithTypeAwareness(e1);
		var right = compileExpressionWithTypeAwareness(e2);
		return "${left} ${compiler.compileBinop(op)} ${right}";	
	case _:
		return compiler.compileExpression(expr);	
})
				[Block:Void]
					[Var `(30831):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(30792):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(30831):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 3
						[Then:Void] [Block:Void]
							[Var `(30832):haxe.macro.Binop]
								[EnumParameter:haxe.macro.Binop]
									[Local `(30831):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									0
							[Var `(30833):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(30831):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									1
							[Var `(30834):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(30831):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TBinop
									2
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(30832):haxe.macro.Binop:haxe.macro.Binop]
									==
									[Const:Int] 0
								[Then:Void] [Block:Void]
									[Block:Void]
										[Var e1(30835):haxe.macro.TypedExpr] [Local `(30833):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var e2(30836):haxe.macro.TypedExpr] [Local `(30834):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Block:Void]
											[Var e1IsString(30837):Bool]
												[Call:Bool]
													[Field:(type : haxe.macro.Type) -> Bool]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(type : haxe.macro.Type) -> Bool]
															reflaxe.elixir.ElixirCompiler
															isStringType:(type : haxe.macro.Type) -> Bool
													[Field:haxe.macro.Type]
														[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[FAnon:haxe.macro.Type] t:haxe.macro.Type
											[Var e2IsString(30838):Bool]
												[Call:Bool]
													[Field:(type : haxe.macro.Type) -> Bool]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(type : haxe.macro.Type) -> Bool]
															reflaxe.elixir.ElixirCompiler
															isStringType:(type : haxe.macro.Type) -> Bool
													[Field:haxe.macro.Type]
														[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[FAnon:haxe.macro.Type] t:haxe.macro.Type
											[Var isStringConcat(30839):Bool]
												[Binop:Bool]
													[Local e1IsString(30837):Bool:Bool]
													||
													[Local e2IsString(30838):Bool:Bool]
											[If:Void]
												[Local isStringConcat(30839):Bool:Bool]
												[Then:Dynamic] [Block:Dynamic]
													[Var left(30840):String]
														[Meta:String]
															:ast(switch (e1.expr) {
	case TConst(TString(s)):
		var escaped = StringTools.replace(s, "\\", "\\\\");
		escaped = StringTools.replace(escaped, "\"", "\\\"");
		escaped = StringTools.replace(escaped, "\n", "\\n");
		escaped = StringTools.replace(escaped, "\r", "\\r");
		escaped = StringTools.replace(escaped, "\t", "\\t");
		"\"${escaped}\"";	
	case _:
		compileExpressionWithTypeAwareness(e1);	
})
															[Block:String]
																[Var `(30841):haxe.macro.TypedExprDef]
																	[Field:haxe.macro.TypedExprDef]
																		[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(30841):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		==
																		[Const:Int] 0
																	[Then:String] [Block:String]
																		[Var `(30842):haxe.macro.TConstant]
																			[EnumParameter:haxe.macro.TConstant]
																				[Local `(30841):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TConst
																				0
																		[If:String]
																			[Binop:Bool]
																				[EnumIndex:Int] [Local `(30842):haxe.macro.TConstant:haxe.macro.TConstant]
																				==
																				[Const:Int] 2
																			[Then:String] [Block:String]
																				[Var `(30843):String]
																					[EnumParameter:String]
																						[Local `(30842):haxe.macro.TConstant:haxe.macro.TConstant]
																						TString
																						0
																				[Block:String]
																					[Var s(30844):String] [Local `(30843):String:String]
																					[Block:String]
																						[Var escaped(30845):String]
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local s(30844):String:String]
																								[Const:String] "\\"
																								[Const:String] "\\\\"
																						[Binop:String]
																							[Local escaped(30845):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30845):String:String]
																								[Const:String] "\""
																								[Const:String] "\\\""
																						[Binop:String]
																							[Local escaped(30845):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30845):String:String]
																								[Const:String] "\n"
																								[Const:String] "\\n"
																						[Binop:String]
																							[Local escaped(30845):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30845):String:String]
																								[Const:String] "\r"
																								[Const:String] "\\r"
																						[Binop:String]
																							[Local escaped(30845):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30845):String:String]
																								[Const:String] "\t"
																								[Const:String] "\\t"
																						[Binop:String]
																							[Binop:String]
																								[Const:String] "\""
																								+
																								[Local escaped(30845):String:String]
																							+
																							[Const:String] "\""
																			[Else:String] [Block:String]
																				[Call:String]
																					[Field:(expr : haxe.macro.TypedExpr) -> String]
																						[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																						[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																							reflaxe.elixir.helpers.ExpressionVariantCompiler
																							compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
																					[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Else:String] [Block:String]
																		[Call:String]
																			[Field:(expr : haxe.macro.TypedExpr) -> String]
																				[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																				[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																					reflaxe.elixir.helpers.ExpressionVariantCompiler
																					compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
																			[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Var right(30846):String]
														[Meta:String]
															:ast(switch (e2.expr) {
	case TConst(TString(s)):
		var escaped = StringTools.replace(s, "\\", "\\\\");
		escaped = StringTools.replace(escaped, "\"", "\\\"");
		escaped = StringTools.replace(escaped, "\n", "\\n");
		escaped = StringTools.replace(escaped, "\r", "\\r");
		escaped = StringTools.replace(escaped, "\t", "\\t");
		"\"${escaped}\"";	
	case _:
		compileExpressionWithTypeAwareness(e2);	
})
															[Block:String]
																[Var `(30847):haxe.macro.TypedExprDef]
																	[Field:haxe.macro.TypedExprDef]
																		[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(30847):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		==
																		[Const:Int] 0
																	[Then:String] [Block:String]
																		[Var `(30848):haxe.macro.TConstant]
																			[EnumParameter:haxe.macro.TConstant]
																				[Local `(30847):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																				TConst
																				0
																		[If:String]
																			[Binop:Bool]
																				[EnumIndex:Int] [Local `(30848):haxe.macro.TConstant:haxe.macro.TConstant]
																				==
																				[Const:Int] 2
																			[Then:String] [Block:String]
																				[Var `(30849):String]
																					[EnumParameter:String]
																						[Local `(30848):haxe.macro.TConstant:haxe.macro.TConstant]
																						TString
																						0
																				[Block:String]
																					[Var s(30850):String] [Local `(30849):String:String]
																					[Block:String]
																						[Var escaped(30851):String]
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local s(30850):String:String]
																								[Const:String] "\\"
																								[Const:String] "\\\\"
																						[Binop:String]
																							[Local escaped(30851):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30851):String:String]
																								[Const:String] "\""
																								[Const:String] "\\\""
																						[Binop:String]
																							[Local escaped(30851):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30851):String:String]
																								[Const:String] "\n"
																								[Const:String] "\\n"
																						[Binop:String]
																							[Local escaped(30851):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30851):String:String]
																								[Const:String] "\r"
																								[Const:String] "\\r"
																						[Binop:String]
																							[Local escaped(30851):String:String]
																							=
																							[Call:String]
																								[Field:(s : String, sub : String, by : String) -> String]
																									[TypeExpr StringTools:Class<StringTools>]
																									[FStatic:(s : String, sub : String, by : String) -> String]
																										StringTools
																										replace:(s : String, sub : String, by : String) -> String
																								[Local escaped(30851):String:String]
																								[Const:String] "\t"
																								[Const:String] "\\t"
																						[Binop:String]
																							[Binop:String]
																								[Const:String] "\""
																								+
																								[Local escaped(30851):String:String]
																							+
																							[Const:String] "\""
																			[Else:String] [Block:String]
																				[Call:String]
																					[Field:(expr : haxe.macro.TypedExpr) -> String]
																						[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																						[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																							reflaxe.elixir.helpers.ExpressionVariantCompiler
																							compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
																					[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Else:String] [Block:String]
																		[Call:String]
																			[Field:(expr : haxe.macro.TypedExpr) -> String]
																				[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																				[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																					reflaxe.elixir.helpers.ExpressionVariantCompiler
																					compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
																			[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[If:Void]
														[Binop:Bool]
															[Unop:Bool]
																!
																Prefix
																[Local e1IsString(30837):Bool:Bool]
															&&
															[Local e2IsString(30838):Bool:Bool]
														[Then:String] [Block:String]
															[Binop:String]
																[Local left(30840):String:String]
																=
																[Call:String]
																	[Field:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																		[Field:reflaxe.elixir.ElixirCompiler]
																			[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																			[FInstance:reflaxe.elixir.ElixirCompiler]
																				reflaxe.elixir.helpers.ExpressionVariantCompiler
																				compiler:reflaxe.elixir.ElixirCompiler
																		[FInstance:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																			reflaxe.elixir.ElixirCompiler
																			convertToString:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String
																	[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local left(30840):String:String]
														[Else:Void] [Block:Void]
															[If:Void]
																[Binop:Bool]
																	[Local e1IsString(30837):Bool:Bool]
																	&&
																	[Unop:Bool]
																		!
																		Prefix
																		[Local e2IsString(30838):Bool:Bool]
																[Then:String] [Block:String]
																	[Binop:String]
																		[Local right(30846):String:String]
																		=
																		[Call:String]
																			[Field:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.ExpressionVariantCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																					reflaxe.elixir.ElixirCompiler
																					convertToString:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String
																			[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																			[Local right(30846):String:String]
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] ""
																	+
																	[Local left(30840):String:String]
																+
																[Const:String] " <> "
															+
															[Local right(30846):String:String]
												[Else:Dynamic] [Block:Dynamic]
													[Var left(30852):String]
														[Call:String]
															[Field:(expr : haxe.macro.TypedExpr) -> String]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
															[Local e1(30835):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Var right(30853):String]
														[Call:String]
															[Field:(expr : haxe.macro.TypedExpr) -> String]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:(expr : haxe.macro.TypedExpr) -> String]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
															[Local e2(30836):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Const:String] ""
																	+
																	[Local left(30852):String:String]
																+
																[Const:String] " + "
															+
															[Local right(30853):String:String]
								[Else:Dynamic] [Block:Dynamic]
									[Var op(30854):haxe.macro.Binop] [Local `(30832):haxe.macro.Binop:haxe.macro.Binop]
									[Var e1(30855):haxe.macro.TypedExpr] [Local `(30833):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(30856):haxe.macro.TypedExpr] [Local `(30834):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Var left(30857):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
												[Local e1(30855):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var right(30858):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTypeAwareness:(expr : haxe.macro.TypedExpr) -> String
												[Local e2(30856):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] ""
																+
																[Local left(30857):String:String]
															+
															[Const:String] " "
														+
														[Call:String]
															[Field:(op : haxe.macro.Binop) -> String]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(op : haxe.macro.Binop) -> String]
																	reflaxe.elixir.ElixirCompiler
																	compileBinop:(op : haxe.macro.Binop) -> String
															[Local op(30854):haxe.macro.Binop:haxe.macro.Binop]
													+
													[Const:String] " "
												+
												[Local right(30858):String:String]
						[Else:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.ExpressionVariantCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											reflaxe.elixir.ElixirCompiler
											compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
									[Local expr(30792):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Const:Null<Bool>] null

	public function compileExpressionWithVarMapping[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(30859):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(30860):String]
		[Arg:String] [Local targetVar(30861):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithVarMapping:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(30859):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(30860):String:String]
					[Local targetVar(30861):String:String]

	public function compileExpressionWithAggressiveSubstitution[Function:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(31004):haxe.macro.TypedExpr]
		[Arg:String] [Local targetVar(31005):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithAggressiveSubstitution:(expr : haxe.macro.TypedExpr, targetVar : String) -> String
					[Local expr(31004):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local targetVar(31005):String:String]

	public function compileExpressionWithRenaming[Function:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(31006):haxe.macro.TypedExpr]
		[Arg:Map<String, String>] [Local renamings(31007):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithRenaming:(expr : haxe.macro.TypedExpr, renamings : Map<String, String>) -> String
					[Local expr(31006):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local renamings(31007):Map<String, String>:Map<String, String>]

	public function compileExpressionWithSubstitution[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(31225):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(31226):String]
		[Arg:String] [Local targetVar(31227):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							compileExpressionWithSubstitution:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(31225):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(31226):String:String]
					[Local targetVar(31227):String:String]

	public function compileExpressionWithTVarSubstitution[Function:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(22401):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TVar] [Local sourceTVar(22402):haxe.macro.TVar]
		[Arg:String] [Local targetVarName(22403):String]
		[Block:Void]
			[Var `this(22452):reflaxe.elixir.helpers.ExpressionVariantCompiler] [Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TLocal(v):
		var varName = compiler.getOriginalVarName(v);
		var sourceVarName = compiler.getOriginalVarName(sourceTVar);
		if (v == sourceTVar) {
			return targetVarName;
		};
		if (varName == sourceVarName && varName != null && varName != "") {
			return targetVarName;
		};
		if (compiler.shouldSubstituteVariable(varName, null, true)) {
			return targetVarName;
		};
		return compiler.compileExpression(expr);	
	case TBinop(op, e1, e2):
		if (op == OpAssign) {
			return compileExpressionWithTVarSubstitution(e2, sourceTVar, targetVarName);
		};
		if (op == OpAdd) {
			var e1IsString = compiler.isStringType(e1.t);
			var e2IsString = compiler.isStringType(e2.t);
			var isStringConcat = e1IsString || e2IsString;
			if (isStringConcat) {
				var left = compileExpressionWithTVarSubstitution(e1, sourceTVar, targetVarName);
				var right = compileExpressionWithTVarSubstitution(e2, sourceTVar, targetVarName);
				if (!e1IsString && e2IsString) {
					left = compiler.convertToString(e1, left);
				} else if (e1IsString && !e2IsString) {
					right = compiler.convertToString(e2, right);
				};
				return "${left} <> ${right}";
			};
		};
		var left = compileExpressionWithTVarSubstitution(e1, sourceTVar, targetVarName);
		var right = compileExpressionWithTVarSubstitution(e2, sourceTVar, targetVarName);
		return "${left} ${compiler.compileBinop(op)} ${right}";	
	case TField(e, fa):
		var obj = compileExpressionWithTVarSubstitution(e, sourceTVar, targetVarName);
		var fieldName = compiler.getFieldName(fa);
		return "${obj}.${fieldName}";	
	case TCall(e, args):
		var obj = compileExpressionWithTVarSubstitution(e, sourceTVar, targetVarName);
		var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compileExpressionWithTVarSubstitution(arg, sourceTVar, targetVarName));
		return "${obj}(${compiledArgs.join(\", \")})";	
	case TArray(e1, e2):
		var arr = compileExpressionWithTVarSubstitution(e1, sourceTVar, targetVarName);
		var index = compileExpressionWithTVarSubstitution(e2, sourceTVar, targetVarName);
		return "Enum.at(${arr}, ${index})";	
	case TConst(c):
		return compiler.expressionDispatcher.literalCompiler.compileConstant(c);	
	case TIf(econd, eif, eelse):
		var condition = compileExpressionWithTVarSubstitution(econd, sourceTVar, targetVarName);
		var thenValue = compileExpressionWithTVarSubstitution(eif, sourceTVar, targetVarName);
		var elseValue = eelse != null ? compileExpressionWithTVarSubstitution(eelse, sourceTVar, targetVarName) : targetVarName;
		return "if ${condition}, do: ${thenValue}, else: ${elseValue}";	
	case TBlock(exprs):
		var compiledExprs = exprs.map(function(e) ->  @:implicitReturn return compileExpressionWithTVarSubstitution(e, sourceTVar, targetVarName));
		return compiledExprs.join("\n");	
	case TParenthesis(e):
		return "(" + compileExpressionWithTVarSubstitution(e, sourceTVar, targetVarName) + ")";	
	case TUnop(op, postFix, e):
		var operand = compileExpressionWithTVarSubstitution(e, sourceTVar, targetVarName);
		var result = switch (op) {
			case OpIncrement:
				"${operand} + 1";			
			case OpDecrement:
				"${operand} - 1";			
			case OpNot:
				"!${operand}";			
			case OpNeg:
				"-${operand}";			
			case OpNegBits:
				"bnot(${operand})";			
			case _:
				operand;			
		};
		return result;	
	case _:
		return compiler.compileExpression(expr);	
})
				[Block:Void]
					[Var `(22510):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(22401):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 0
							[Block:Dynamic]
								[Var `(22511):haxe.macro.TConstant]
									[EnumParameter:haxe.macro.TConstant]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TConst
										0
								[Block:Dynamic]
									[Var c(22512):haxe.macro.TConstant] [Local `(22511):haxe.macro.TConstant:haxe.macro.TConstant]
									[Block:Dynamic]
										[Return:Dynamic]
											[Call:String]
												[Field:(constant : haxe.macro.TConstant) -> String]
													[Field:reflaxe.elixir.helpers.LiteralCompiler]
														[Field:reflaxe.elixir.helpers.ExpressionDispatcher]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:reflaxe.elixir.helpers.ExpressionDispatcher]
																reflaxe.elixir.ElixirCompiler
																expressionDispatcher:reflaxe.elixir.helpers.ExpressionDispatcher
														[FInstance:reflaxe.elixir.helpers.LiteralCompiler]
															reflaxe.elixir.helpers.ExpressionDispatcher
															literalCompiler:reflaxe.elixir.helpers.LiteralCompiler
													[FInstance:(constant : haxe.macro.TConstant) -> String]
														reflaxe.elixir.helpers.LiteralCompiler
														compileConstant:(constant : haxe.macro.TConstant) -> String
												[Local c(22512):haxe.macro.TConstant:haxe.macro.TConstant]
						[Case:Dynamic]
							[Const:Int] 1
							[Block:Dynamic]
								[Var `(22513):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:Dynamic]
									[Var v(22514):haxe.macro.TVar] [Local `(22513):haxe.macro.TVar:haxe.macro.TVar]
									[Block:Dynamic]
										[Var varName(22515):String]
											[Call:String]
												[Field:(v : haxe.macro.TVar) -> String]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ExpressionVariantCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(v : haxe.macro.TVar) -> String]
														reflaxe.elixir.ElixirCompiler
														getOriginalVarName:(v : haxe.macro.TVar) -> String
												[Local v(22514):haxe.macro.TVar:haxe.macro.TVar]
										[Var sourceVarName(22516):String]
											[Call:String]
												[Field:(v : haxe.macro.TVar) -> String]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ExpressionVariantCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(v : haxe.macro.TVar) -> String]
														reflaxe.elixir.ElixirCompiler
														getOriginalVarName:(v : haxe.macro.TVar) -> String
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
										[If:Void]
											[Binop:Bool]
												[Local v(22514):haxe.macro.TVar:haxe.macro.TVar]
												==
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local targetVarName(22403):String:String]
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Binop:Bool]
														[Local varName(22515):String:String]
														==
														[Local sourceVarName(22516):String:String]
													&&
													[Binop:Bool]
														[Local varName(22515):String:String]
														!=
														[Const:String] null
												&&
												[Binop:Bool]
													[Local varName(22515):String:String]
													!=
													[Const:String] ""
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local targetVarName(22403):String:String]
										[If:Void]
											[Call:Bool]
												[Field:(varName : String, ?sourceVar : Null<String>, ?isAggressiveMode : Bool) -> Bool]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ExpressionVariantCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(varName : String, ?sourceVar : Null<String>, ?isAggressiveMode : Bool) -> Bool]
														reflaxe.elixir.ElixirCompiler
														shouldSubstituteVariable:(varName : String, ?sourceVar : Null<String>, ?isAggressiveMode : Bool) -> Bool
												[Local varName(22515):String:String]
												[Const:Null<String>] null
												[Const:Bool] true
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local targetVarName(22403):String:String]
										[Return:Dynamic]
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ExpressionVariantCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Local expr(22401):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Const:Null<Bool>] null
						[Case:Dynamic]
							[Const:Int] 2
							[Block:Dynamic]
								[Var `(22517):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TArray
										0
								[Var `(22518):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TArray
										1
								[Block:Dynamic]
									[Var e1(22519):haxe.macro.TypedExpr] [Local `(22517):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(22520):haxe.macro.TypedExpr] [Local `(22518):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Var arr(22521):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e1(22519):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var index(22522):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e2(22520):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "Enum.at("
															+
															[Local arr(22521):String:String]
														+
														[Const:String] ", "
													+
													[Local index(22522):String:String]
												+
												[Const:String] ")"
						[Case:Dynamic]
							[Const:Int] 3
							[Block:Dynamic]
								[Var `(22523):haxe.macro.Binop]
									[EnumParameter:haxe.macro.Binop]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										0
								[Var `(22524):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										1
								[Var `(22525):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBinop
										2
								[Block:Dynamic]
									[Var op(22526):haxe.macro.Binop] [Local `(22523):haxe.macro.Binop:haxe.macro.Binop]
									[Var e1(22527):haxe.macro.TypedExpr] [Local `(22524):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var e2(22528):haxe.macro.TypedExpr] [Local `(22525):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[If:Void]
											[Binop:Bool]
												[Local op(22526):haxe.macro.Binop:haxe.macro.Binop]
												==
												[Field:haxe.macro.Binop]
													[TypeExpr haxe.macro.Binop:Enum<haxe.macro.Binop>]
													[FEnum:haxe.macro.Binop]
														haxe.macro.Binop
														OpAssign
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Call:String]
														[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
														[Local e2(22528):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
														[Local targetVarName(22403):String:String]
										[If:Void]
											[Binop:Bool]
												[Local op(22526):haxe.macro.Binop:haxe.macro.Binop]
												==
												[Field:haxe.macro.Binop]
													[TypeExpr haxe.macro.Binop:Enum<haxe.macro.Binop>]
													[FEnum:haxe.macro.Binop]
														haxe.macro.Binop
														OpAdd
											[Then:Void] [Block:Void]
												[Var e1IsString(22529):Bool]
													[Call:Bool]
														[Field:(type : haxe.macro.Type) -> Bool]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(type : haxe.macro.Type) -> Bool]
																reflaxe.elixir.ElixirCompiler
																isStringType:(type : haxe.macro.Type) -> Bool
														[Field:haxe.macro.Type]
															[Local e1(22527):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.Type] t:haxe.macro.Type
												[Var e2IsString(22530):Bool]
													[Call:Bool]
														[Field:(type : haxe.macro.Type) -> Bool]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.ExpressionVariantCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(type : haxe.macro.Type) -> Bool]
																reflaxe.elixir.ElixirCompiler
																isStringType:(type : haxe.macro.Type) -> Bool
														[Field:haxe.macro.Type]
															[Local e2(22528):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[FAnon:haxe.macro.Type] t:haxe.macro.Type
												[Var isStringConcat(22531):Bool]
													[Binop:Bool]
														[Local e1IsString(22529):Bool:Bool]
														||
														[Local e2IsString(22530):Bool:Bool]
												[If:Void]
													[Local isStringConcat(22531):Bool:Bool]
													[Then:Dynamic] [Block:Dynamic]
														[Var left(22532):String]
															[Call:String]
																[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
																[Local e1(22527):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
																[Local targetVarName(22403):String:String]
														[Var right(22533):String]
															[Call:String]
																[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
																[Local e2(22528):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
																[Local targetVarName(22403):String:String]
														[If:Void]
															[Binop:Bool]
																[Unop:Bool]
																	!
																	Prefix
																	[Local e1IsString(22529):Bool:Bool]
																&&
																[Local e2IsString(22530):Bool:Bool]
															[Then:String] [Block:String]
																[Binop:String]
																	[Local left(22532):String:String]
																	=
																	[Call:String]
																		[Field:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.ExpressionVariantCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																				reflaxe.elixir.ElixirCompiler
																				convertToString:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String
																		[Local e1(22527):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Local left(22532):String:String]
															[Else:Void] [Block:Void]
																[If:Void]
																	[Binop:Bool]
																		[Local e1IsString(22529):Bool:Bool]
																		&&
																		[Unop:Bool]
																			!
																			Prefix
																			[Local e2IsString(22530):Bool:Bool]
																	[Then:String] [Block:String]
																		[Binop:String]
																			[Local right(22533):String:String]
																			=
																			[Call:String]
																				[Field:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.ExpressionVariantCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String]
																						reflaxe.elixir.ElixirCompiler
																						convertToString:(expr : haxe.macro.TypedExpr, compiledExpr : String) -> String
																				[Local e2(22528):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Local right(22533):String:String]
														[Return:Dynamic]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] ""
																		+
																		[Local left(22532):String:String]
																	+
																	[Const:String] " <> "
																+
																[Local right(22533):String:String]
										[Var left(22534):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e1(22527):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var right(22535):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e2(22528):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] ""
																+
																[Local left(22534):String:String]
															+
															[Const:String] " "
														+
														[Call:String]
															[Field:(op : haxe.macro.Binop) -> String]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(op : haxe.macro.Binop) -> String]
																	reflaxe.elixir.ElixirCompiler
																	compileBinop:(op : haxe.macro.Binop) -> String
															[Local op(22526):haxe.macro.Binop:haxe.macro.Binop]
													+
													[Const:String] " "
												+
												[Local right(22535):String:String]
						[Case:Dynamic]
							[Const:Int] 4
							[Block:Dynamic]
								[Var `(22536):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(22537):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[Block:Dynamic]
									[Var e(22538):haxe.macro.TypedExpr] [Local `(22536):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var fa(22539):haxe.macro.FieldAccess] [Local `(22537):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
									[Block:Dynamic]
										[Var obj(22540):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e(22538):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var fieldName(22541):String]
											[Call:String]
												[Field:(fa : haxe.macro.FieldAccess) -> String]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.ExpressionVariantCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(fa : haxe.macro.FieldAccess) -> String]
														reflaxe.elixir.ElixirCompiler
														getFieldName:(fa : haxe.macro.FieldAccess) -> String
												[Local fa(22539):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local obj(22540):String:String]
													+
													[Const:String] "."
												+
												[Local fieldName(22541):String:String]
						[Case:Dynamic]
							[Const:Int] 6
							[Block:Dynamic]
								[Var `(22542):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TParenthesis
										0
								[Block:Dynamic]
									[Var e(22543):haxe.macro.TypedExpr] [Local `(22542):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Const:String] "("
													+
													[Call:String]
														[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
														[Local e(22543):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
														[Local targetVarName(22403):String:String]
												+
												[Const:String] ")"
						[Case:Dynamic]
							[Const:Int] 9
							[Block:Dynamic]
								[Var `(22544):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(22545):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Dynamic]
									[Var e(22546):haxe.macro.TypedExpr] [Local `(22544):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var args(22547):Array<haxe.macro.TypedExpr>] [Local `(22545):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Var obj(22548):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e(22546):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var compiledArgs(22549):Array<String>]
											[Block:Array<String>]
												[Var `(22550):Array<String>] [ArrayDecl:Array<String>]
												[Block:Void]
													[Var `(22551):Int] [Const:Int] 0
													[Var `(22552):Array<haxe.macro.TypedExpr>] [Local args(22547):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[While:Void]
														[Binop:Bool]
															[Local `(22551):Int:Int]
															<
															[Field:Int]
																[Local `(22552):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
														[Block:Void]
															[Var v(22553):haxe.macro.TypedExpr]
																[Array:haxe.macro.TypedExpr]
																	[Local `(22552):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local `(22551):Int:Int]
															[Unop:Int]
																++
																Prefix
																[Local `(22551):Int:Int]
															[Call:Int]
																[Field:(x : String) -> Int]
																	[Local `(22550):Array<String>:Array<String>]
																	[FInstance:(x : String) -> Int]
																		Array<String>
																		push:(x : Array.T) -> Int
																[Call:String]
																	[Function:(arg : haxe.macro.TypedExpr) -> String]
																		[Arg:haxe.macro.TypedExpr] [Local arg(22554):haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Return:Dynamic]
																				[Call:String]
																					[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																						[Local `this(22452):reflaxe.elixir.helpers.ExpressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler]
																						[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																							reflaxe.elixir.helpers.ExpressionVariantCompiler
																							compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
																					[Local arg(22554):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
																					[Local targetVarName(22403):String:String]
																	[Local v(22553):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local `(22550):Array<String>:Array<String>]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] ""
															+
															[Local obj(22548):String:String]
														+
														[Const:String] "("
													+
													[Call:String]
														[Field:(sep : String) -> String]
															[Local compiledArgs(22549):Array<String>:Array<String>]
															[FInstance:(sep : String) -> String]
																Array<String>
																join:(sep : String) -> String
														[Const:String] ", "
												+
												[Const:String] ")"
						[Case:Dynamic]
							[Const:Int] 11
							[Block:Dynamic]
								[Var `(22555):haxe.macro.Unop]
									[EnumParameter:haxe.macro.Unop]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										0
								[Var `(22556):Bool]
									[EnumParameter:Bool]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										1
								[Var `(22557):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TUnop
										2
								[Block:Dynamic]
									[Var op(22558):haxe.macro.Unop] [Local `(22555):haxe.macro.Unop:haxe.macro.Unop]
									[Var postFix(22559):Bool] [Local `(22556):Bool:Bool]
									[Var e(22560):haxe.macro.TypedExpr] [Local `(22557):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Dynamic]
										[Var operand(22561):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local e(22560):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var result(22562):String]
											[Meta:String]
												:ast(switch (op) {
	case OpIncrement:
		"${operand} + 1";	
	case OpDecrement:
		"${operand} - 1";	
	case OpNot:
		"!${operand}";	
	case OpNeg:
		"-${operand}";	
	case OpNegBits:
		"bnot(${operand})";	
	case _:
		operand;	
})
												[Switch:String]
													[EnumIndex:Int] [Local op(22558):haxe.macro.Unop:haxe.macro.Unop]
													[Case:String]
														[Const:Int] 0
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] ""
																		+
																		[Local operand(22561):String:String]
																	+
																	[Const:String] " + 1"
													[Case:String]
														[Const:Int] 1
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] ""
																		+
																		[Local operand(22561):String:String]
																	+
																	[Const:String] " - 1"
													[Case:String]
														[Const:Int] 2
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Const:String] "!"
																	+
																	[Local operand(22561):String:String]
													[Case:String]
														[Const:Int] 3
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Const:String] "-"
																	+
																	[Local operand(22561):String:String]
													[Case:String]
														[Const:Int] 4
														[Block:String]
															[Block:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "bnot("
																		+
																		[Local operand(22561):String:String]
																	+
																	[Const:String] ")"
													[Default:String] [Block:String] [Local operand(22561):String:String]
										[Return:Dynamic] [Local result(22562):String:String]
						[Case:Dynamic]
							[Const:Int] 14
							[Block:Dynamic]
								[Var `(22563):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:Dynamic]
									[Var exprs(22564):Array<haxe.macro.TypedExpr>] [Local `(22563):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Var compiledExprs(22565):Array<String>]
											[Block:Array<String>]
												[Var `(22566):Array<String>] [ArrayDecl:Array<String>]
												[Block:Void]
													[Var `(22567):Int] [Const:Int] 0
													[Var `(22568):Array<haxe.macro.TypedExpr>] [Local exprs(22564):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[While:Void]
														[Binop:Bool]
															[Local `(22567):Int:Int]
															<
															[Field:Int]
																[Local `(22568):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[FInstance:Int]
																	Array<haxe.macro.TypedExpr>
																	length:Int
														[Block:Void]
															[Var v(22569):haxe.macro.TypedExpr]
																[Array:haxe.macro.TypedExpr]
																	[Local `(22568):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local `(22567):Int:Int]
															[Unop:Int]
																++
																Prefix
																[Local `(22567):Int:Int]
															[Call:Int]
																[Field:(x : String) -> Int]
																	[Local `(22566):Array<String>:Array<String>]
																	[FInstance:(x : String) -> Int]
																		Array<String>
																		push:(x : Array.T) -> Int
																[Call:String]
																	[Function:(e : haxe.macro.TypedExpr) -> String]
																		[Arg:haxe.macro.TypedExpr] [Local e(22570):haxe.macro.TypedExpr]
																		[Block:Dynamic]
																			[Return:Dynamic]
																				[Call:String]
																					[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																						[Local `this(22452):reflaxe.elixir.helpers.ExpressionVariantCompiler:reflaxe.elixir.helpers.ExpressionVariantCompiler]
																						[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																							reflaxe.elixir.helpers.ExpressionVariantCompiler
																							compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
																					[Local e(22570):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																					[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
																					[Local targetVarName(22403):String:String]
																	[Local v(22569):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local `(22566):Array<String>:Array<String>]
										[Return:Dynamic]
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledExprs(22565):Array<String>:Array<String>]
													[FInstance:(sep : String) -> String]
														Array<String>
														join:(sep : String) -> String
												[Const:String] "\n"
						[Case:Dynamic]
							[Const:Int] 16
							[Block:Dynamic]
								[Var `(22571):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										0
								[Var `(22572):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										1
								[Var `(22573):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(22510):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TIf
										2
								[Block:Dynamic]
									[Var econd(22574):haxe.macro.TypedExpr] [Local `(22571):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eif(22575):haxe.macro.TypedExpr] [Local `(22572):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var eelse(22576):Null<haxe.macro.TypedExpr>] [Local `(22573):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Dynamic]
										[Var condition(22577):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local econd(22574):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var thenValue(22578):String]
											[Call:String]
												[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
												[Local eif(22575):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
												[Local targetVarName(22403):String:String]
										[Var elseValue(22579):String]
											[If:String]
												[Binop:Bool]
													[Local eelse(22576):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
													!=
													[Const:Null<haxe.macro.TypedExpr>] null
												[Then:String] [Block:String]
													[Call:String]
														[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compileExpressionWithTVarSubstitution:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
														[Local eelse(22576):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
														[Local sourceTVar(22402):haxe.macro.TVar:haxe.macro.TVar]
														[Local targetVarName(22403):String:String]
												[Else:String] [Block:String] [Local targetVarName(22403):String:String]
										[Return:Dynamic]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "if "
																+
																[Local condition(22577):String:String]
															+
															[Const:String] ", do: "
														+
														[Local thenValue(22578):String:String]
													+
													[Const:String] ", else: "
												+
												[Local elseValue(22579):String:String]
						[Default:Dynamic]
							[Block:Dynamic]
								[Return:Dynamic]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.ExpressionVariantCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Local expr(22401):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Const:Null<Bool>] null

	public function compileSwitchExpression[Function:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local switchExpr(23524):haxe.macro.TypedExpr]
		[Arg:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>] [Local cases(23525):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
		[Arg:Null<haxe.macro.TypedExpr>] [Local defaultExpr(23526):Null<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Block:Void]
				[Var `(23529):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(23529):Int:Int]
						<
						[Field:Int]
							[Local cases(23525):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
							[FInstance:Int]
								Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>
								length:Int
					[Block:Void]
						[Var caseData(23527):{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
							[Array:{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
								[Local cases(23525):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
								[Local `(23529):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(23529):Int:Int]
						[Var usedVariables(23528):Map<String, Bool>]
							[Call:Map<String, Bool>]
								[Field:(expr : haxe.macro.TypedExpr) -> Map<String, Bool>]
									[Field:reflaxe.elixir.helpers.PatternMatchingCompiler]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.ExpressionVariantCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:reflaxe.elixir.helpers.PatternMatchingCompiler]
											reflaxe.elixir.ElixirCompiler
											patternMatchingCompiler:reflaxe.elixir.helpers.PatternMatchingCompiler
									[FInstance:(expr : haxe.macro.TypedExpr) -> Map<String, Bool>]
										reflaxe.elixir.helpers.PatternMatchingCompiler
										findUsedVariables:(expr : haxe.macro.TypedExpr) -> Map<String, Bool>
								[Field:haxe.macro.TypedExpr]
									[Local caseData(23527):{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }:{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }]
									[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local usedVariables(23528):Map<String, Bool>:Map<String, Bool>]
									!=
									[Const:Map<String, Bool>] null
								&&
								[Binop:Bool]
									[Call:Int]
										[Field:(it : Iterable<Bool>, ?pred : Null<(item : Bool) -> Bool>) -> Int]
											[TypeExpr Lambda:Class<Lambda>]
											[FStatic:(it : Iterable<Bool>, ?pred : Null<(item : Bool) -> Bool>) -> Int]
												Lambda
												count:(it : Iterable<count.A>, ?pred : Null<(item : count.A) -> Bool>) -> Int
										[Cast:Iterable<Bool>] [Local usedVariables(23528):Map<String, Bool>:Map<String, Bool>]
										[Const:Null<(item : Bool) -> Bool>] null
									>
									[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic]
								[Binop:Null<Map<String, Bool>>]
									[Field:Null<Map<String, Bool>>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.ExpressionVariantCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:Null<Map<String, Bool>>]
											reflaxe.elixir.ElixirCompiler
											patternUsageContext:Null<Map<String, Bool>>
									=
									[Local usedVariables(23528):Map<String, Bool>:Map<String, Bool>]
								[Break:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Null<Map<String, Bool>>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.ExpressionVariantCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Null<Map<String, Bool>>]
							reflaxe.elixir.ElixirCompiler
							patternUsageContext:Null<Map<String, Bool>>
					==
					[Const:Null<Map<String, Bool>>] null
				[Then:Null<Map<String, Bool>>] [Block:Null<Map<String, Bool>>]
					[Binop:Null<Map<String, Bool>>]
						[Field:Null<Map<String, Bool>>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Null<Map<String, Bool>>]
								reflaxe.elixir.ElixirCompiler
								patternUsageContext:Null<Map<String, Bool>>
						=
						[Block:haxe.ds.StringMap<Bool>]
							[Block:Void]
							[New:haxe.ds.StringMap<Bool>] haxe.ds.StringMap<Bool>
			[Var context(23530):Null<reflaxe.elixir.helpers.FunctionContext>] [Const:Null<reflaxe.elixir.helpers.FunctionContext>] null
			[If:Void]
				[Block:Bool]
					[Var this(23533):haxe.IMap<String, String>]
						[Field:Map<String, String>]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:Map<String, String>]
								reflaxe.elixir.ElixirCompiler
								currentFunctionParameterMap:Map<String, String>
					[Call:Bool]
						[Field:(key : String) -> Bool]
							[Cast:haxe.ds.StringMap<String>] [Local this(23533):haxe.IMap<String, String>:haxe.IMap<String, String>]
							[FInstance:(key : String) -> Bool]
								haxe.ds.StringMap<String>
								exists:(key : String) -> Bool
						[Const:String] "_this"
				[Then:Null<reflaxe.elixir.helpers.FunctionContext>] [Block:Null<reflaxe.elixir.helpers.FunctionContext>]
					[Var structParamName(23539):Null<String>]
						[Block:Null<String>]
							[Var this(23537):haxe.IMap<String, String>]
								[Field:Map<String, String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.ExpressionVariantCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:Map<String, String>]
										reflaxe.elixir.ElixirCompiler
										currentFunctionParameterMap:Map<String, String>
							[Call:Null<String>]
								[Field:(key : String) -> Null<String>]
									[Cast:haxe.ds.StringMap<String>] [Local this(23537):haxe.IMap<String, String>:haxe.IMap<String, String>]
									[FInstance:(key : String) -> Null<String>]
										haxe.ds.StringMap<String>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Const:String] "_this"
					[Binop:Null<reflaxe.elixir.helpers.FunctionContext>]
						[Local context(23530):Null<reflaxe.elixir.helpers.FunctionContext>:Null<reflaxe.elixir.helpers.FunctionContext>]
						=
						[ObjectDecl:{ structParamName : Null<String> }] structParamName: [Local structParamName(23539):Null<String>:Null<String>]
				[Else:Void] [Block:Void]
					[If:Void]
						[Call:Bool]
							[Field:() -> Bool]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.ExpressionVariantCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:() -> Bool]
									reflaxe.elixir.ElixirCompiler
									isStateThreadingEnabled:() -> Bool
						[Then:Null<reflaxe.elixir.helpers.FunctionContext>] [Block:Null<reflaxe.elixir.helpers.FunctionContext>]
							[Binop:Null<reflaxe.elixir.helpers.FunctionContext>]
								[Local context(23530):Null<reflaxe.elixir.helpers.FunctionContext>:Null<reflaxe.elixir.helpers.FunctionContext>]
								=
								[ObjectDecl:{ structParamName : String }] structParamName: [Const:String] "struct"
						[Else:Void] [Block:Void]
			[Var result(23540):String]
				[Call:String]
					[Field:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>, ?context : Null<reflaxe.elixir.helpers.FunctionContext>) -> String]
						[Field:reflaxe.elixir.helpers.PatternMatchingCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.PatternMatchingCompiler]
								reflaxe.elixir.ElixirCompiler
								patternMatchingCompiler:reflaxe.elixir.helpers.PatternMatchingCompiler
						[FInstance:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>, ?context : Null<reflaxe.elixir.helpers.FunctionContext>) -> String]
							reflaxe.elixir.helpers.PatternMatchingCompiler
							compileSwitchExpression:(switchExpr : haxe.macro.TypedExpr, cases : Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>, defaultExpr : Null<haxe.macro.TypedExpr>, ?context : Null<reflaxe.elixir.helpers.FunctionContext>) -> String
					[Local switchExpr(23524):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local cases(23525):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
					[Local defaultExpr(23526):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
					[Local context(23530):Null<reflaxe.elixir.helpers.FunctionContext>:Null<reflaxe.elixir.helpers.FunctionContext>]
			[Binop:Null<Map<String, Bool>>]
				[Field:Null<Map<String, Bool>>]
					[Field:reflaxe.elixir.ElixirCompiler]
						[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
						[FInstance:reflaxe.elixir.ElixirCompiler]
							reflaxe.elixir.helpers.ExpressionVariantCompiler
							compiler:reflaxe.elixir.ElixirCompiler
					[FInstance:Null<Map<String, Bool>>]
						reflaxe.elixir.ElixirCompiler
						patternUsageContext:Null<Map<String, Bool>>
				=
				[Const:Null<Map<String, Bool>>] null
			[Return:Dynamic] [Local result(23540):String:String]

	public function compileBlockExpressionsWithContext[Function:(expressions : Array<haxe.macro.TypedExpr>) -> Array<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local expressions(31364):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var compiledStatements(31365):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
			[Block:Void]
				[Var `(31368):Int] [Const:Int] 0
				[Var `(31369):Int]
					[Field:Int]
						[Local expressions(31364):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
				[While:Void]
					[Binop:Bool]
						[Local `(31368):Int:Int]
						<
						[Local `(31369):Int:Int]
					[Block:Void]
						[Var i(31366):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(31368):Int:Int]
						[Var compiled(31367):Null<String>]
							[Call:Null<String>]
								[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.ExpressionVariantCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										reflaxe.elixir.ElixirCompiler
										compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
								[Array:haxe.macro.TypedExpr]
									[Local expressions(31364):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Local i(31366):Int:Int]
								[Const:Null<Bool>] null
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local compiled(31367):Null<String>:Null<String>]
									!=
									[Const:Null<String>] null
								&&
								[Binop:Bool]
									[Call:String]
										[Field:(s : String) -> String]
											[TypeExpr StringTools:{ Statics StringTools }]
											[FStatic:(s : String) -> String]
												StringTools
												trim:(s : String) -> String
										[Local compiled(31367):Null<String>:Null<String>]
									!=
									[Const:String] ""
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local compiledStatements(31365):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Local compiled(31367):Null<String>:Null<String>]
			[Return:Dynamic] [Local compiledStatements(31365):Array<Null<String>>:Array<Null<String>>]

	public function compileExpressionWithMutationTracking[Function:(expr : haxe.macro.TypedExpr, updates : Map<String, String>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(31370):haxe.macro.TypedExpr]
		[Arg:Map<String, String>] [Local updates(31371):Map<String, String>]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (expr.expr) {
	case TBlock(exprs):
		var optimizedBlock = tryOptimizeArrayAssignmentPattern(exprs);
		if (optimizedBlock != null) {
			return optimizedBlock;
		};
		var tempVarName = compiler.tempVariableOptimizer.detectTempVariablePattern(exprs);
		if (tempVarName != null) {
			return compiler.tempVariableOptimizer.optimizeTempVariablePattern(tempVarName, exprs);
		};
		var results = [];
		for (e  in  exprs) {
			results.push(compiler.compileExpression(e));
		};
		results.join("\n");	
	case _:
		compiler.compileExpression(expr);	
})
					[Block:String]
						[Var `(31820):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(31370):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:String]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(31820):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 14
							[Then:String] [Block:String]
								[Var `(31821):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(31820):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TBlock
										0
								[Block:String]
									[Var exprs(31822):Array<haxe.macro.TypedExpr>] [Local `(31821):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:String]
										[Var optimizedBlock(31823):Null<String>]
											[Call:Null<String>]
												[Field:(exprs : Array<haxe.macro.TypedExpr>) -> Null<String>]
													[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
													[FInstance:(exprs : Array<haxe.macro.TypedExpr>) -> Null<String>]
														reflaxe.elixir.helpers.ExpressionVariantCompiler
														tryOptimizeArrayAssignmentPattern:(exprs : Array<haxe.macro.TypedExpr>) -> Null<String>
												[Local exprs(31822):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Void]
											[Binop:Bool]
												[Local optimizedBlock(31823):Null<String>:Null<String>]
												!=
												[Const:Null<String>] null
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local optimizedBlock(31823):Null<String>:Null<String>]
										[Var tempVarName(31824):Null<String>]
											[Call:Null<String>]
												[Field:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>]
													[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
															reflaxe.elixir.ElixirCompiler
															tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
													[FInstance:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>]
														reflaxe.elixir.helpers.TempVariableOptimizer
														detectTempVariablePattern:(expressions : Array<haxe.macro.TypedExpr>) -> Null<String>
												[Local exprs(31822):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[If:Void]
											[Binop:Bool]
												[Local tempVarName(31824):Null<String>:Null<String>]
												!=
												[Const:Null<String>] null
											[Then:Dynamic] [Block:Dynamic]
												[Return:Dynamic]
													[Call:String]
														[Field:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String]
															[Field:reflaxe.elixir.helpers.TempVariableOptimizer]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:reflaxe.elixir.helpers.TempVariableOptimizer]
																	reflaxe.elixir.ElixirCompiler
																	tempVariableOptimizer:reflaxe.elixir.helpers.TempVariableOptimizer
															[FInstance:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String]
																reflaxe.elixir.helpers.TempVariableOptimizer
																optimizeTempVariablePattern:(tempVarName : String, expressions : Array<haxe.macro.TypedExpr>) -> String
														[Local tempVarName(31824):Null<String>:Null<String>]
														[Local exprs(31822):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Var results(31825):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
										[Block:Void]
											[Var `(31826):Int] [Const:Int] 0
											[While:Void]
												[Binop:Bool]
													[Local `(31826):Int:Int]
													<
													[Field:Int]
														[Local exprs(31822):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[Block:Void]
													[Var e(31827):haxe.macro.TypedExpr]
														[Array:haxe.macro.TypedExpr]
															[Local exprs(31822):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[Local `(31826):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(31826):Int:Int]
													[Call:Int]
														[Field:(x : Null<String>) -> Int]
															[Local results(31825):Array<Null<String>>:Array<Null<String>>]
															[FInstance:(x : Null<String>) -> Int]
																Array<Null<String>>
																push:(x : Array.T) -> Int
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Local e(31827):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
															[Const:Null<Bool>] null
										[Call:String]
											[Field:(sep : String) -> String]
												[Local results(31825):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] "\n"
							[Else:Null<String>] [Block:Null<String>]
								[Call:Null<String>]
									[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.ExpressionVariantCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											reflaxe.elixir.ElixirCompiler
											compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
									[Local expr(31370):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Const:Null<Bool>] null

	function tryOptimizeArrayAssignmentPattern[Function:(exprs : Array<haxe.macro.TypedExpr>) -> Null<String>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local exprs(31373):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					<
					[Const:Int] 2
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Null<String>] null
			[Block:Void]
				[Var `(31423):Int] [Const:Int] 0
				[Var `(31424):Int]
					[Parenthesis:Int]
						[Binop:Int]
							[Field:Int]
								[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[FInstance:Int]
									Array<haxe.macro.TypedExpr>
									length:Int
							-
							[Const:Int] 1
				[While:Void]
					[Binop:Bool]
						[Local `(31423):Int:Int]
						<
						[Local `(31424):Int:Int]
					[Block:Void]
						[Var i(31374):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(31423):Int:Int]
						[Var currentExpr(31375):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Local i(31374):Int:Int]
						[Var nextExpr(31376):haxe.macro.TypedExpr]
							[Array:haxe.macro.TypedExpr]
								[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Binop:Int]
									[Local i(31374):Int:Int]
									+
									[Const:Int] 1
						[Var arrayVar(31394):Null<String>]
							[Call:Null<String>]
								[Field:(expr : haxe.macro.TypedExpr) -> Null<String>]
									[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
									[FInstance:(expr : haxe.macro.TypedExpr) -> Null<String>]
										reflaxe.elixir.helpers.ExpressionVariantCompiler
										extractEmptyArrayAssignment:(expr : haxe.macro.TypedExpr) -> Null<String>
								[Local currentExpr(31375):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[If:Void]
							[Binop:Bool]
								[Local arrayVar(31394):Null<String>:Null<String>]
								!=
								[Const:Null<String>] null
							[Then:Void] [Block:Void]
								[Var loopOptimization(31413):Null<String>]
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, targetVar : String) -> Null<String>]
											[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
											[FInstance:(expr : haxe.macro.TypedExpr, targetVar : String) -> Null<String>]
												reflaxe.elixir.helpers.ExpressionVariantCompiler
												tryOptimizeWhileLoopWithTarget:(expr : haxe.macro.TypedExpr, targetVar : String) -> Null<String>
										[Local nextExpr(31376):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local arrayVar(31394):Null<String>:Null<String>]
								[If:Void]
									[Binop:Bool]
										[Local loopOptimization(31413):Null<String>:Null<String>]
										!=
										[Const:Null<String>] null
									[Then:Dynamic] [Block:Dynamic]
										[Var optimizedAssignment(31414):String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local arrayVar(31394):Null<String>:Null<String>]
													+
													[Const:String] " = "
												+
												[Local loopOptimization(31413):Null<String>:Null<String>]
										[Var remainingResults(31415):Array<String>] [ArrayDecl:Array<String>]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local remainingResults(31415):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Local optimizedAssignment(31414):String:String]
										[Block:Void]
											[Var `(31417):Int]
												[Parenthesis:Int]
													[Binop:Int]
														[Local i(31374):Int:Int]
														+
														[Const:Int] 2
											[Var `(31418):Int]
												[Field:Int]
													[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[While:Void]
												[Binop:Bool]
													[Local `(31417):Int:Int]
													<
													[Local `(31418):Int:Int]
												[Block:Int]
													[Var j(31416):Int]
														[Unop:Int]
															++
															Postfix
															[Local `(31417):Int:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local remainingResults(31415):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Array:haxe.macro.TypedExpr]
																[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local j(31416):Int:Int]
															[Const:Null<Bool>] null
										[Var beforeResults(31419):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
										[Block:Void]
											[Var `(31421):Int] [Const:Int] 0
											[Var `(31422):Int] [Local i(31374):Int:Int]
											[While:Void]
												[Binop:Bool]
													[Local `(31421):Int:Int]
													<
													[Local `(31422):Int:Int]
												[Block:Int]
													[Var k(31420):Int]
														[Unop:Int]
															++
															Postfix
															[Local `(31421):Int:Int]
													[Call:Int]
														[Field:(x : Null<String>) -> Int]
															[Local beforeResults(31419):Array<Null<String>>:Array<Null<String>>]
															[FInstance:(x : Null<String>) -> Int]
																Array<Null<String>>
																push:(x : Array.T) -> Int
														[Call:Null<String>]
															[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.ExpressionVariantCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	reflaxe.elixir.ElixirCompiler
																	compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
															[Array:haxe.macro.TypedExpr]
																[Local exprs(31373):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local k(31420):Int:Int]
															[Const:Null<Bool>] null
										[Return:Dynamic]
											[Call:String]
												[Field:(sep : String) -> String]
													[Parenthesis:Array<Null<String>>]
														[Call:Array<Null<String>>]
															[Field:(a : Array<Null<String>>) -> Array<Null<String>>]
																[Local beforeResults(31419):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(a : Array<Null<String>>) -> Array<Null<String>>]
																	Array<Null<String>>
																	concat:(a : Array<Array.T>) -> Array<Array.T>
															[Local remainingResults(31415):Array<String>:Array<String>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] "\n"
			[Return:Dynamic] [Const:Null<String>] null

	function extractEmptyArrayAssignment[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(31377):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TVar(v, initExpr):
		if (initExpr != null) {
			switch (initExpr.expr) {
				case TArrayDecl([]):
					v.name;				
				case _:
					null;				
			};
		} else {
			null;
		};	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(31387):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(31377):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(31387):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 13
							[Then:Null<String>] [Block:Null<String>]
								[Var `(31388):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(31387):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										0
								[Var `(31389):Null<haxe.macro.TypedExpr>]
									[EnumParameter:Null<haxe.macro.TypedExpr>]
										[Local `(31387):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TVar
										1
								[Block:Null<String>]
									[Var v(31390):haxe.macro.TVar] [Local `(31388):haxe.macro.TVar:haxe.macro.TVar]
									[Var initExpr(31391):Null<haxe.macro.TypedExpr>] [Local `(31389):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
									[Block:Null<String>]
										[If:Null<String>]
											[Binop:Bool]
												[Local initExpr(31391):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
												!=
												[Const:Null<haxe.macro.TypedExpr>] null
											[Then:Null<String>] [Block:Null<String>]
												[Meta:Null<String>]
													:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		v.name;	
	case _:
		null;	
})
													[Block:Null<String>]
														[Var `(31392):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local initExpr(31391):Null<haxe.macro.TypedExpr>:Null<haxe.macro.TypedExpr>]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Null<String>]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(31392):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 8
															[Then:Null<String>] [Block:Null<String>]
																[Var `(31393):Array<haxe.macro.TypedExpr>]
																	[EnumParameter:Array<haxe.macro.TypedExpr>]
																		[Local `(31392):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TArrayDecl
																		0
																[If:Null<String>]
																	[Binop:Bool]
																		[Field:Int]
																			[Local `(31393):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[FInstance:Int]
																				Array<haxe.macro.TypedExpr>
																				length:Int
																		==
																		[Const:Int] 0
																	[Then:String] [Block:String]
																		[Block:String]
																			[Field:String]
																				[Local v(31390):haxe.macro.TVar:haxe.macro.TVar]
																				[FAnon:String] name:String
																	[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
															[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
											[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	function tryOptimizeWhileLoopWithTarget[Function:(expr : haxe.macro.TypedExpr, targetVar : String) -> Null<String>]
		[Arg:haxe.macro.TypedExpr] [Local expr(31395):haxe.macro.TypedExpr]
		[Arg:String] [Local targetVar(31396):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Null<String>]
					:ast(switch (expr.expr) {
	case TWhile(econd, ebody, normalWhile):
		var compiledLoop = compiler.unifiedLoopCompiler.compileWhileLoop(econd, ebody, normalWhile);
		if (compiledLoop != null && compiledLoop != "") {
			return compiledLoop;
		};
		null;	
	case _:
		null;	
})
					[Block:Null<String>]
						[Var `(31405):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local expr(31395):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[If:Null<String>]
							[Binop:Bool]
								[EnumIndex:Int] [Local `(31405):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
								==
								[Const:Int] 17
							[Then:Null<String>] [Block:Null<String>]
								[Var `(31406):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(31405):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										0
								[Var `(31407):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(31405):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										1
								[Var `(31408):Bool]
									[EnumParameter:Bool]
										[Local `(31405):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TWhile
										2
								[Block:Null<String>]
									[Var econd(31409):haxe.macro.TypedExpr] [Local `(31406):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var ebody(31410):haxe.macro.TypedExpr] [Local `(31407):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var normalWhile(31411):Bool] [Local `(31408):Bool:Bool]
									[Block:Null<String>]
										[Var compiledLoop(31412):String]
											[Call:String]
												[Field:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
													[Field:reflaxe.elixir.helpers.UnifiedLoopCompiler]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.ExpressionVariantCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:reflaxe.elixir.helpers.UnifiedLoopCompiler]
															reflaxe.elixir.ElixirCompiler
															unifiedLoopCompiler:reflaxe.elixir.helpers.UnifiedLoopCompiler
													[FInstance:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String]
														reflaxe.elixir.helpers.UnifiedLoopCompiler
														compileWhileLoop:(econd : haxe.macro.TypedExpr, ebody : haxe.macro.TypedExpr, normalWhile : Bool) -> String
												[Local econd(31409):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local ebody(31410):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local normalWhile(31411):Bool:Bool]
										[If:Void]
											[Binop:Bool]
												[Binop:Bool]
													[Local compiledLoop(31412):String:String]
													!=
													[Const:String] null
												&&
												[Binop:Bool]
													[Local compiledLoop(31412):String:String]
													!=
													[Const:String] ""
											[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiledLoop(31412):String:String]
										[Const:Null<String>] null
							[Else:Null<String>] [Block:Null<String>] [Const:Null<String>] null

	public function extractTransformationFromBodyWithTVar[Function:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(31828):haxe.macro.TypedExpr]
		[Arg:haxe.macro.TVar] [Local sourceTVar(31829):haxe.macro.TVar]
		[Arg:String] [Local targetVarName(31830):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							extractTransformationFromBodyWithTVar:(expr : haxe.macro.TypedExpr, sourceTVar : haxe.macro.TVar, targetVarName : String) -> String
					[Local expr(31828):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceTVar(31829):haxe.macro.TVar:haxe.macro.TVar]
					[Local targetVarName(31830):String:String]

	public function extractTransformationFromBody[Function:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
		[Arg:haxe.macro.TypedExpr] [Local expr(32104):haxe.macro.TypedExpr]
		[Arg:String] [Local sourceVar(32105):String]
		[Arg:String] [Local targetVar(32106):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Call:String]
					[Field:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
						[Field:reflaxe.elixir.helpers.SubstitutionCompiler]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.ExpressionVariantCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.ExpressionVariantCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:reflaxe.elixir.helpers.SubstitutionCompiler]
								reflaxe.elixir.ElixirCompiler
								substitutionCompiler:reflaxe.elixir.helpers.SubstitutionCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String]
							reflaxe.elixir.helpers.SubstitutionCompiler
							extractTransformationFromBody:(expr : haxe.macro.TypedExpr, sourceVar : String, targetVar : String) -> String
					[Local expr(32104):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local sourceVar(32105):String:String]
					[Local targetVar(32106):String:String]
}