class reflaxe.elixir.helpers.PatternExtractor {

	@:value(new Map())
	static var patterns:Map<String, reflaxe.elixir.helpers.Pattern> = [Block:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>]
		[Block:Void]
		[New:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>] haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>;

	@:value([])
	static var antiPatterns:Array<reflaxe.elixir.helpers.AntiPattern> = [ArrayDecl:Array<reflaxe.elixir.helpers.AntiPattern>];

	public static function analyzeCode[Function:(expr : haxe.macro.TypedExpr, context : String) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local expr(27663):haxe.macro.TypedExpr]
		[Arg:String] [Local context(27664):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (expr.expr) {
	case TCall(e, args):
		analyzeFunctionCall(e, args, context);	
	case TNew(c, _, args):
		analyzeConstructor(c, args, context);	
	case TMeta(m, e):
		analyzeMetadata(m, e, context);	
	case TFunction(f):
		analyzeFunction(f, context);	
	case _:
})
				[Block:Void]
					[Var `(27760):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local expr(27663):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Void]
							[Const:Int] 9
							[Block:Void]
								[Var `(27761):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										0
								[Var `(27762):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TCall
										1
								[Block:Void]
									[Var e(27763):haxe.macro.TypedExpr] [Local `(27761):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Var args(27764):Array<haxe.macro.TypedExpr>] [Local `(27762):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Call:Void]
											[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
													reflaxe.elixir.helpers.PatternExtractor
													analyzeFunctionCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, context : String) -> Void
											[Local e(27763):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local args(27764):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[Local context(27664):String:String]
						[Case:Void]
							[Const:Int] 10
							[Block:Void]
								[Var `(27765):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TNew
										0
								[Var `(27766):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TNew
										1
								[Var `(27767):Array<haxe.macro.TypedExpr>]
									[EnumParameter:Array<haxe.macro.TypedExpr>]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TNew
										2
								[Block:Void]
									[Var c(27768):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(27765):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Var args(27769):Array<haxe.macro.TypedExpr>] [Local `(27767):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Block:Void]
										[Call:Void]
											[Field:(c : haxe.macro.Ref<haxe.macro.ClassType>, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(c : haxe.macro.Ref<haxe.macro.ClassType>, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
													reflaxe.elixir.helpers.PatternExtractor
													analyzeConstructor:(c : haxe.macro.Ref<haxe.macro.ClassType>, args : Array<haxe.macro.TypedExpr>, context : String) -> Void
											[Local c(27768):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
											[Local args(27769):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[Local context(27664):String:String]
						[Case:Void]
							[Const:Int] 12
							[Block:Void]
								[Var `(27770):haxe.macro.TFunc]
									[EnumParameter:haxe.macro.TFunc]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TFunction
										0
								[Block:Void]
									[Var f(27771):haxe.macro.TFunc] [Local `(27770):haxe.macro.TFunc:haxe.macro.TFunc]
									[Block:Void]
										[Call:Void]
											[Field:(f : haxe.macro.TFunc, context : String) -> Void]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(f : haxe.macro.TFunc, context : String) -> Void]
													reflaxe.elixir.helpers.PatternExtractor
													analyzeFunction:(f : haxe.macro.TFunc, context : String) -> Void
											[Local f(27771):haxe.macro.TFunc:haxe.macro.TFunc]
											[Local context(27664):String:String]
						[Case:Void]
							[Const:Int] 25
							[Block:Void]
								[Var `(27772):haxe.macro.MetadataEntry]
									[EnumParameter:haxe.macro.MetadataEntry]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TMeta
										0
								[Var `(27773):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(27760):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TMeta
										1
								[Block:Void]
									[Var m(27774):haxe.macro.MetadataEntry] [Local `(27772):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
									[Var e(27775):haxe.macro.TypedExpr] [Local `(27773):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Block:Void]
										[Call:Void]
											[Field:(m : haxe.macro.MetadataEntry, e : haxe.macro.TypedExpr, context : String) -> Void]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(m : haxe.macro.MetadataEntry, e : haxe.macro.TypedExpr, context : String) -> Void]
													reflaxe.elixir.helpers.PatternExtractor
													analyzeMetadata:(m : haxe.macro.MetadataEntry, e : haxe.macro.TypedExpr, context : String) -> Void
											[Local m(27774):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
											[Local e(27775):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local context(27664):String:String]
						[Default:Void] [Block:Void]
			[Call:Void]
				[Field:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
					[TypeExpr haxe.macro.TypedExprTools:Class<haxe.macro.TypedExprTools>]
					[FStatic:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
						haxe.macro.TypedExprTools
						iter:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void
				[Local expr(27663):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
				[Function:(e : haxe.macro.TypedExpr) -> Void]
					[Arg:haxe.macro.TypedExpr] [Local e(27776):haxe.macro.TypedExpr]
					[Call:Void]
						[Field:(expr : haxe.macro.TypedExpr, context : String) -> Void]
							[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
							[FStatic:(expr : haxe.macro.TypedExpr, context : String) -> Void]
								reflaxe.elixir.helpers.PatternExtractor
								analyzeCode:(expr : haxe.macro.TypedExpr, context : String) -> Void
						[Local e(27776):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Local context(27664):String:String]

	static function analyzeFunctionCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
		[Arg:haxe.macro.TypedExpr] [Local e(27667):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(27668):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local context(27669):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (e.expr) {
	case TField(_, FStatic(c, cf)):
		var className = c.get().name;
		var methodName = cf.get().name;
		if (className == "Socket" && methodName == "assign") {
			registerPattern("socket-assign", "Socket State Management", "Managing state in LiveView components using socket.assign", "socket.assign(${extractArgPattern(args)})", context);
		};
		if (className == "Repo" && methodName == "insert") {
			registerPattern("repo-insert", "Database Insert", "Inserting records using Ecto.Repo", "Repo.insert(changeset)", context);
		};	
	case _:
})
				[Block:Void]
					[Var `(27699):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local e(27667):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(27699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 4
						[Then:Void] [Block:Void]
							[Var `(27700):haxe.macro.TypedExpr]
								[EnumParameter:haxe.macro.TypedExpr]
									[Local `(27699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TField
									0
							[Var `(27701):haxe.macro.FieldAccess]
								[EnumParameter:haxe.macro.FieldAccess]
									[Local `(27699):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TField
									1
							[If:Void]
								[Binop:Bool]
									[EnumIndex:Int] [Local `(27701):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
									==
									[Const:Int] 1
								[Then:Void] [Block:Void]
									[Var `(27702):haxe.macro.Ref<haxe.macro.ClassType>]
										[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
											[Local `(27701):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
											FStatic
											0
									[Var `(27703):haxe.macro.Ref<haxe.macro.ClassField>]
										[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
											[Local `(27701):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
											FStatic
											1
									[Block:Void]
										[Var c(27704):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(27702):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
										[Var cf(27705):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(27703):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
										[Block:Void]
											[Var className(27706):String]
												[Field:String]
													[Call:haxe.macro.ClassType]
														[Field:() -> haxe.macro.ClassType]
															[Local c(27704):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
															[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
													[FAnon:String] name:String
											[Var methodName(27707):String]
												[Field:String]
													[Call:haxe.macro.ClassField]
														[Field:() -> haxe.macro.ClassField]
															[Local cf(27705):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
															[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
													[FAnon:String] name:String
											[If:Void]
												[Binop:Bool]
													[Binop:Bool]
														[Local className(27706):String:String]
														==
														[Const:String] "Socket"
													&&
													[Binop:Bool]
														[Local methodName(27707):String:String]
														==
														[Const:String] "assign"
												[Then:Void] [Block:Void]
													[Call:Void]
														[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
															[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
															[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
																reflaxe.elixir.helpers.PatternExtractor
																registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
														[Const:String] "socket-assign"
														[Const:String] "Socket State Management"
														[Const:String] "Managing state in LiveView components using socket.assign"
														[Binop:String]
															[Binop:String]
																[Const:String] "socket.assign("
																+
																[Call:String]
																	[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
																		[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
																		[FStatic:(args : Array<haxe.macro.TypedExpr>) -> String]
																			reflaxe.elixir.helpers.PatternExtractor
																			extractArgPattern:(args : Array<haxe.macro.TypedExpr>) -> String
																	[Local args(27668):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															+
															[Const:String] ")"
														[Local context(27669):String:String]
											[If:Void]
												[Binop:Bool]
													[Binop:Bool]
														[Local className(27706):String:String]
														==
														[Const:String] "Repo"
													&&
													[Binop:Bool]
														[Local methodName(27707):String:String]
														==
														[Const:String] "insert"
												[Then:Void] [Block:Void]
													[Call:Void]
														[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
															[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
															[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
																reflaxe.elixir.helpers.PatternExtractor
																registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
														[Const:String] "repo-insert"
														[Const:String] "Database Insert"
														[Const:String] "Inserting records using Ecto.Repo"
														[Const:String] "Repo.insert(changeset)"
														[Local context(27669):String:String]
								[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]

	static function analyzeConstructor[Function:(c : haxe.macro.Ref<haxe.macro.ClassType>, args : Array<haxe.macro.TypedExpr>, context : String) -> Void]
		[Arg:haxe.macro.Ref<haxe.macro.ClassType>] [Local c(27710):haxe.macro.Ref<haxe.macro.ClassType>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(27711):Array<haxe.macro.TypedExpr>]
		[Arg:String] [Local context(27712):String]
		[Block:Void]
			[Var classRef(27713):haxe.macro.ClassType]
				[Call:haxe.macro.ClassType]
					[Field:() -> haxe.macro.ClassType]
						[Local c(27710):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
						[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
			[If:Void]
				[Call:Bool]
					[Field:(name : String) -> Bool]
						[Field:haxe.macro.MetaAccess]
							[Local classRef(27713):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
					[Const:String] ":genserver"
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
							[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
							[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
								reflaxe.elixir.helpers.PatternExtractor
								registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
						[Const:String] "genserver-init"
						[Const:String] "GenServer Initialization"
						[Const:String] "Starting a GenServer process"
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "new "
										+
										[Field:String]
											[Local classRef(27713):haxe.macro.ClassType:haxe.macro.ClassType]
											[FAnon:String] name:String
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
										[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
										[FStatic:(args : Array<haxe.macro.TypedExpr>) -> String]
											reflaxe.elixir.helpers.PatternExtractor
											extractArgPattern:(args : Array<haxe.macro.TypedExpr>) -> String
									[Local args(27711):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							+
							[Const:String] ")"
						[Local context(27712):String:String]

	static function analyzeMetadata[Function:(m : haxe.macro.MetadataEntry, e : haxe.macro.TypedExpr, context : String) -> Void]
		[Arg:haxe.macro.MetadataEntry] [Local m(27716):haxe.macro.MetadataEntry]
		[Arg:haxe.macro.TypedExpr] [Local e(27717):haxe.macro.TypedExpr]
		[Arg:String] [Local context(27718):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (m.name) {
	case ":liveview":
		registerPattern("liveview-component", "LiveView Component", "Defining Phoenix LiveView components", getLiveViewPattern(e), context);	
	case ":schema":
		registerPattern("ecto-schema", "Ecto Schema Definition", "Defining database schemas with Ecto", getSchemaPattern(e), context);	
	case ":changeset":
		registerPattern("ecto-changeset", "Changeset Validation", "Validating data with Ecto changesets", getChangesetPattern(e), context);	
})
				[Block:Void]
					[Var `(27723):String]
						[Field:String]
							[Local m(27716):haxe.macro.MetadataEntry:haxe.macro.MetadataEntry]
							[FAnon:String] name:String
					[Switch:Void]
						[Local `(27723):String:String]
						[Case:Void]
							[Const:String] ":changeset"
							[Block:Void]
								[Block:Void]
									[Call:Void]
										[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
											[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
											[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
												reflaxe.elixir.helpers.PatternExtractor
												registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
										[Const:String] "ecto-changeset"
										[Const:String] "Changeset Validation"
										[Const:String] "Validating data with Ecto changesets"
										[Call:String]
											[Field:(e : haxe.macro.TypedExpr) -> String]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(e : haxe.macro.TypedExpr) -> String]
													reflaxe.elixir.helpers.PatternExtractor
													getChangesetPattern:(e : haxe.macro.TypedExpr) -> String
											[Local e(27717):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local context(27718):String:String]
						[Case:Void]
							[Const:String] ":liveview"
							[Block:Void]
								[Block:Void]
									[Call:Void]
										[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
											[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
											[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
												reflaxe.elixir.helpers.PatternExtractor
												registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
										[Const:String] "liveview-component"
										[Const:String] "LiveView Component"
										[Const:String] "Defining Phoenix LiveView components"
										[Call:String]
											[Field:(e : haxe.macro.TypedExpr) -> String]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(e : haxe.macro.TypedExpr) -> String]
													reflaxe.elixir.helpers.PatternExtractor
													getLiveViewPattern:(e : haxe.macro.TypedExpr) -> String
											[Local e(27717):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local context(27718):String:String]
						[Case:Void]
							[Const:String] ":schema"
							[Block:Void]
								[Block:Void]
									[Call:Void]
										[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
											[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
											[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
												reflaxe.elixir.helpers.PatternExtractor
												registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
										[Const:String] "ecto-schema"
										[Const:String] "Ecto Schema Definition"
										[Const:String] "Defining database schemas with Ecto"
										[Call:String]
											[Field:(e : haxe.macro.TypedExpr) -> String]
												[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
												[FStatic:(e : haxe.macro.TypedExpr) -> String]
													reflaxe.elixir.helpers.PatternExtractor
													getSchemaPattern:(e : haxe.macro.TypedExpr) -> String
											[Local e(27717):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local context(27718):String:String]

	static function analyzeFunction[Function:(f : haxe.macro.TFunc, context : String) -> Void]
		[Arg:haxe.macro.TFunc] [Local f(27725):haxe.macro.TFunc]
		[Arg:String] [Local context(27726):String]
		[Block:Void]
			[If:Void]
				[Call:Bool]
					[Field:(e : haxe.macro.TypedExpr) -> Bool]
						[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
						[FStatic:(e : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.PatternExtractor
							hasPatternMatching:(e : haxe.macro.TypedExpr) -> Bool
					[Field:haxe.macro.TypedExpr]
						[Local f(27725):haxe.macro.TFunc:haxe.macro.TFunc]
						[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
							[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
							[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
								reflaxe.elixir.helpers.PatternExtractor
								registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
						[Const:String] "pattern-matching"
						[Const:String] "Pattern Matching"
						[Const:String] "Using pattern matching in function bodies"
						[Call:String]
							[Field:(f : haxe.macro.TFunc) -> String]
								[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
								[FStatic:(f : haxe.macro.TFunc) -> String]
									reflaxe.elixir.helpers.PatternExtractor
									getPatternMatchingExample:(f : haxe.macro.TFunc) -> String
							[Local f(27725):haxe.macro.TFunc:haxe.macro.TFunc]
						[Local context(27726):String:String]
			[If:Void]
				[Call:Bool]
					[Field:(e : haxe.macro.TypedExpr) -> Bool]
						[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
						[FStatic:(e : haxe.macro.TypedExpr) -> Bool]
							reflaxe.elixir.helpers.PatternExtractor
							hasErrorHandling:(e : haxe.macro.TypedExpr) -> Bool
					[Field:haxe.macro.TypedExpr]
						[Local f(27725):haxe.macro.TFunc:haxe.macro.TFunc]
						[FAnon:haxe.macro.TypedExpr] expr:haxe.macro.TypedExpr
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(id : String, name : String, description : String, code : String, context : String) -> Void]
							[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
							[FStatic:(id : String, name : String, description : String, code : String, context : String) -> Void]
								reflaxe.elixir.helpers.PatternExtractor
								registerPattern:(id : String, name : String, description : String, code : String, context : String) -> Void
						[Const:String] "error-handling"
						[Const:String] "Error Handling"
						[Const:String] "Handling errors with ok/error tuples"
						[Call:String]
							[Field:(f : haxe.macro.TFunc) -> String]
								[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
								[FStatic:(f : haxe.macro.TFunc) -> String]
									reflaxe.elixir.helpers.PatternExtractor
									getErrorHandlingExample:(f : haxe.macro.TFunc) -> String
							[Local f(27725):haxe.macro.TFunc:haxe.macro.TFunc]
						[Local context(27726):String:String]

	static function registerPattern[Function:(id : String, name : String, description : String, code : String, context : String) -> Void]
		[Arg:String] [Local id(27674):String]
		[Arg:String] [Local name(27675):String]
		[Arg:String] [Local description(27676):String]
		[Arg:String] [Local code(27677):String]
		[Arg:String] [Local context(27678):String]
		[Block:Void]
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Block:Bool]
						[Var this(27681):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
							[Field:Map<String, reflaxe.elixir.helpers.Pattern>]
								[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
								[FStatic:Map<String, reflaxe.elixir.helpers.Pattern>]
									reflaxe.elixir.helpers.PatternExtractor
									patterns:Map<String, reflaxe.elixir.helpers.Pattern>
						[Call:Bool]
							[Field:(key : String) -> Bool]
								[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>] [Local this(27681):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>:haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
								[FInstance:(key : String) -> Bool]
									haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>
									exists:(key : String) -> Bool
							[Local id(27674):String:String]
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var this(27685):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
							[Field:Map<String, reflaxe.elixir.helpers.Pattern>]
								[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
								[FStatic:Map<String, reflaxe.elixir.helpers.Pattern>]
									reflaxe.elixir.helpers.PatternExtractor
									patterns:Map<String, reflaxe.elixir.helpers.Pattern>
						[Call:Void]
							[Field:(key : String, value : reflaxe.elixir.helpers.Pattern) -> Void]
								[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>] [Local this(27685):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>:haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
								[FInstance:(key : String, value : reflaxe.elixir.helpers.Pattern) -> Void]
									haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>
									set:(key : String, value : haxe.ds.StringMap.T) -> Void
							[Local id(27674):String:String]
							[ObjectDecl:{ name : String, id : String, frequency : Int, examples : Array<String>, description : String, code : String }]
								id: [Local id(27674):String:String]
								name: [Local name(27675):String:String]
								description: [Local description(27676):String:String]
								code: [Local code(27677):String:String]
								examples: [ArrayDecl:Array<String>] [Local context(27678):String:String]
								frequency: [Const:Int] 1
				[Else:Int] [Block:Int]
					[Var pattern(27692):Null<reflaxe.elixir.helpers.Pattern>]
						[Block:Null<reflaxe.elixir.helpers.Pattern>]
							[Var this(27690):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
								[Field:Map<String, reflaxe.elixir.helpers.Pattern>]
									[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
									[FStatic:Map<String, reflaxe.elixir.helpers.Pattern>]
										reflaxe.elixir.helpers.PatternExtractor
										patterns:Map<String, reflaxe.elixir.helpers.Pattern>
							[Call:Null<reflaxe.elixir.helpers.Pattern>]
								[Field:(key : String) -> Null<reflaxe.elixir.helpers.Pattern>]
									[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>] [Local this(27690):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>:haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
									[FInstance:(key : String) -> Null<reflaxe.elixir.helpers.Pattern>]
										haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>
										get:(key : String) -> Null<haxe.ds.StringMap.T>
								[Local id(27674):String:String]
					[If:Void]
						[Binop:Bool]
							[Call:Int]
								[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
									[Field:Array<String>]
										[Local pattern(27692):Null<reflaxe.elixir.helpers.Pattern>:Null<reflaxe.elixir.helpers.Pattern>]
										[FAnon:Array<String>] examples:Array<String>
									[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
										Array<String>
										indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
								[Local context(27678):String:String]
								[Const:Null<Int>] null
							==
							[Const:Int] -1
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Field:Array<String>]
										[Local pattern(27692):Null<reflaxe.elixir.helpers.Pattern>:Null<reflaxe.elixir.helpers.Pattern>]
										[FAnon:Array<String>] examples:Array<String>
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Local context(27678):String:String]
					[Unop:Int]
						++
						Postfix
						[Field:Int]
							[Local pattern(27692):Null<reflaxe.elixir.helpers.Pattern>:Null<reflaxe.elixir.helpers.Pattern>]
							[FAnon:Int] frequency:Int

	public static function registerAntiPattern[Function:(name : String, description : String, badCode : String, goodCode : String) -> Void]
		[Arg:String] [Local name(27777):String]
		[Arg:String] [Local description(27778):String]
		[Arg:String] [Local badCode(27779):String]
		[Arg:String] [Local goodCode(27780):String]
		[Block:Int]
			[Call:Int]
				[Field:(x : reflaxe.elixir.helpers.AntiPattern) -> Int]
					[Field:Array<reflaxe.elixir.helpers.AntiPattern>]
						[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
						[FStatic:Array<reflaxe.elixir.helpers.AntiPattern>]
							reflaxe.elixir.helpers.PatternExtractor
							antiPatterns:Array<reflaxe.elixir.helpers.AntiPattern>
					[FInstance:(x : reflaxe.elixir.helpers.AntiPattern) -> Int]
						Array<reflaxe.elixir.helpers.AntiPattern>
						push:(x : Array.T) -> Int
				[ObjectDecl:{ name : String, goodCode : String, description : String, badCode : String }]
					name: [Local name(27777):String:String]
					description: [Local description(27778):String:String]
					badCode: [Local badCode(27779):String:String]
					goodCode: [Local goodCode(27780):String:String]

	public static function generatePatternDocs[Function:(outputDir : String) -> Void]
		[Arg:String] [Local outputDir(27781):String]
		[Block:Void]
			[Var content(27782):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local content(27782):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "# Reflaxe.Elixir Patterns\n\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local content(27782):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "*Auto-extracted from example projects*\n\n"
			[Var sortedPatterns(27789):Array<reflaxe.elixir.helpers.Pattern>]
				[Block:Array<reflaxe.elixir.helpers.Pattern>]
					[Var `(27783):Array<reflaxe.elixir.helpers.Pattern>] [ArrayDecl:Array<reflaxe.elixir.helpers.Pattern>]
					[For:Void]
						[Local p(27788):reflaxe.elixir.helpers.Pattern]
						[Block:Iterator<reflaxe.elixir.helpers.Pattern>]
							[Var this(27787):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
								[Field:Map<String, reflaxe.elixir.helpers.Pattern>]
									[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
									[FStatic:Map<String, reflaxe.elixir.helpers.Pattern>]
										reflaxe.elixir.helpers.PatternExtractor
										patterns:Map<String, reflaxe.elixir.helpers.Pattern>
							[Call:Iterator<reflaxe.elixir.helpers.Pattern>]
								[Field:() -> Iterator<reflaxe.elixir.helpers.Pattern>]
									[Cast:haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>] [Local this(27787):haxe.IMap<String, reflaxe.elixir.helpers.Pattern>:haxe.IMap<String, reflaxe.elixir.helpers.Pattern>]
									[FInstance:() -> Iterator<reflaxe.elixir.helpers.Pattern>]
										haxe.ds.StringMap<reflaxe.elixir.helpers.Pattern>
										iterator:() -> Iterator<haxe.ds.StringMap.T>
						[Block:Int]
							[Call:Int]
								[Field:(x : reflaxe.elixir.helpers.Pattern) -> Int]
									[Local `(27783):Array<reflaxe.elixir.helpers.Pattern>:Array<reflaxe.elixir.helpers.Pattern>]
									[FInstance:(x : reflaxe.elixir.helpers.Pattern) -> Int]
										Array<reflaxe.elixir.helpers.Pattern>
										push:(x : Array.T) -> Int
								[Local p(27788):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
					[Local `(27783):Array<reflaxe.elixir.helpers.Pattern>:Array<reflaxe.elixir.helpers.Pattern>]
			[Call:Void]
				[Field:(f : ((reflaxe.elixir.helpers.Pattern, reflaxe.elixir.helpers.Pattern) -> Int)) -> Void]
					[Local sortedPatterns(27789):Array<reflaxe.elixir.helpers.Pattern>:Array<reflaxe.elixir.helpers.Pattern>]
					[FInstance:(f : ((reflaxe.elixir.helpers.Pattern, reflaxe.elixir.helpers.Pattern) -> Int)) -> Void]
						Array<reflaxe.elixir.helpers.Pattern>
						sort:(f : ((Array.T, Array.T) -> Int)) -> Void
				[Function:(a : reflaxe.elixir.helpers.Pattern, b : reflaxe.elixir.helpers.Pattern) -> Int]
					[Arg:reflaxe.elixir.helpers.Pattern] [Local a(27790):reflaxe.elixir.helpers.Pattern]
					[Arg:reflaxe.elixir.helpers.Pattern] [Local b(27791):reflaxe.elixir.helpers.Pattern]
					[Return:Dynamic]
						[Binop:Int]
							[Field:Int]
								[Local b(27791):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
								[FAnon:Int] frequency:Int
							-
							[Field:Int]
								[Local a(27790):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
								[FAnon:Int] frequency:Int
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local content(27782):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "## Most Common Patterns\n\n"
			[Var count(27792):Int] [Const:Int] 0
			[Block:Void]
				[Var `(27794):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(27794):Int:Int]
						<
						[Field:Int]
							[Local sortedPatterns(27789):Array<reflaxe.elixir.helpers.Pattern>:Array<reflaxe.elixir.helpers.Pattern>]
							[FInstance:Int]
								Array<reflaxe.elixir.helpers.Pattern>
								length:Int
					[Block:Void]
						[Var pattern(27793):reflaxe.elixir.helpers.Pattern]
							[Array:reflaxe.elixir.helpers.Pattern]
								[Local sortedPatterns(27789):Array<reflaxe.elixir.helpers.Pattern>:Array<reflaxe.elixir.helpers.Pattern>]
								[Local `(27794):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(27794):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Unop:Int]
									++
									Postfix
									[Local count(27792):Int:Int]
								>=
								[Const:Int] 10
							[Then:Dynamic] [Block:Dynamic] [Break:Dynamic]
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local content(27782):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "### "
									+
									[Field:String]
										[Local pattern(27793):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
										[FAnon:String] name:String
								+
								[Const:String] "\n\n"
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local content(27782):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Field:String]
										[Local pattern(27793):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
										[FAnon:String] description:String
								+
								[Const:String] "\n\n"
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local content(27782):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "**Usage:** Found "
									+
									[Field:Int]
										[Local pattern(27793):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
										[FAnon:Int] frequency:Int
								+
								[Const:String] " times\n\n"
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local content(27782):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "```haxe\n"
									+
									[Field:String]
										[Local pattern(27793):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
										[FAnon:String] code:String
								+
								[Const:String] "\n```\n\n"
						[Call:Void]
							[Field:(x : String) -> Void]
								[Local content(27782):StringBuf:StringBuf]
								[FInstance:(x : String) -> Void]
									StringBuf
									add:(x : add.T) -> Void
							[Binop:String]
								[Binop:String]
									[Const:String] "**Examples:** "
									+
									[Call:String]
										[Field:(sep : String) -> String]
											[Call:Array<String>]
												[Field:(pos : Int, ?end : Null<Int>) -> Array<String>]
													[Field:Array<String>]
														[Local pattern(27793):reflaxe.elixir.helpers.Pattern:reflaxe.elixir.helpers.Pattern]
														[FAnon:Array<String>] examples:Array<String>
													[FInstance:(pos : Int, ?end : Null<Int>) -> Array<String>]
														Array<String>
														slice:(pos : Int, ?end : Null<Int>) -> Array<Array.T>
												[Const:Int] 0
												[Const:Int] 3
											[FInstance:(sep : String) -> String]
												Array<String>
												join:(sep : String) -> String
										[Const:String] ", "
								+
								[Const:String] "\n\n"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Field:Array<reflaxe.elixir.helpers.AntiPattern>]
							[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
							[FStatic:Array<reflaxe.elixir.helpers.AntiPattern>]
								reflaxe.elixir.helpers.PatternExtractor
								antiPatterns:Array<reflaxe.elixir.helpers.AntiPattern>
						[FInstance:Int]
							Array<reflaxe.elixir.helpers.AntiPattern>
							length:Int
					>
					[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local content(27782):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "## Anti-Patterns to Avoid\n\n"
					[Block:Void]
						[Var `(27796):Int] [Const:Int] 0
						[Var `(27797):Array<reflaxe.elixir.helpers.AntiPattern>]
							[Field:Array<reflaxe.elixir.helpers.AntiPattern>]
								[TypeExpr reflaxe.elixir.helpers.PatternExtractor:Class<reflaxe.elixir.helpers.PatternExtractor>]
								[FStatic:Array<reflaxe.elixir.helpers.AntiPattern>]
									reflaxe.elixir.helpers.PatternExtractor
									antiPatterns:Array<reflaxe.elixir.helpers.AntiPattern>
						[While:Void]
							[Binop:Bool]
								[Local `(27796):Int:Int]
								<
								[Field:Int]
									[Local `(27797):Array<reflaxe.elixir.helpers.AntiPattern>:Array<reflaxe.elixir.helpers.AntiPattern>]
									[FInstance:Int]
										Array<reflaxe.elixir.helpers.AntiPattern>
										length:Int
							[Block:Void]
								[Var anti(27795):reflaxe.elixir.helpers.AntiPattern]
									[Array:reflaxe.elixir.helpers.AntiPattern]
										[Local `(27797):Array<reflaxe.elixir.helpers.AntiPattern>:Array<reflaxe.elixir.helpers.AntiPattern>]
										[Local `(27796):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(27796):Int:Int]
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Const:String] "### "
											+
											[Field:String]
												[Local anti(27795):reflaxe.elixir.helpers.AntiPattern:reflaxe.elixir.helpers.AntiPattern]
												[FAnon:String] name:String
										+
										[Const:String] "\n\n"
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Field:String]
												[Local anti(27795):reflaxe.elixir.helpers.AntiPattern:reflaxe.elixir.helpers.AntiPattern]
												[FAnon:String] description:String
										+
										[Const:String] "\n\n"
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Const:String] "**❌ Bad:**\n"
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Const:String] "```haxe\n"
											+
											[Field:String]
												[Local anti(27795):reflaxe.elixir.helpers.AntiPattern:reflaxe.elixir.helpers.AntiPattern]
												[FAnon:String] badCode:String
										+
										[Const:String] "\n```\n\n"
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Const:String] "**✅ Good:**\n"
								[Call:Void]
									[Field:(x : String) -> Void]
										[Local content(27782):StringBuf:StringBuf]
										[FInstance:(x : String) -> Void]
											StringBuf
											add:(x : add.T) -> Void
									[Binop:String]
										[Binop:String]
											[Const:String] "```haxe\n"
											+
											[Field:String]
												[Local anti(27795):reflaxe.elixir.helpers.AntiPattern:reflaxe.elixir.helpers.AntiPattern]
												[FAnon:String] goodCode:String
										+
										[Const:String] "\n```\n\n"
			[Call:Void]
				[Field:(path : String, content : String) -> Void]
					[TypeExpr sys.io.File:Class<sys.io.File>]
					[FStatic:(path : String, content : String) -> Void]
						sys.io.File
						saveContent:(path : String, content : String) -> Void
				[Binop:String]
					[Binop:String]
						[Const:String] ""
						+
						[Local outputDir(27781):String:String]
					+
					[Const:String] "/PATTERNS.md"
				[Call:String]
					[Field:() -> String]
						[Local content(27782):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function extractArgPattern[Function:(args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(27693):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Return:Dynamic]
				[If:String]
					[Binop:Bool]
						[Field:Int]
							[Local args(27693):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
						>
						[Const:Int] 0
					[Then:String] [Block:String] [Const:String] "..."
					[Else:String] [Block:String] [Const:String] ""

	static function getLiveViewPattern[Function:(e : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(27719):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:String] "@:liveview\nclass MyLive {\n    // LiveView implementation\n}"

	static function getSchemaPattern[Function:(e : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(27720):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:String] "@:schema\nclass User {\n    public var id:Int;\n    public var name:String;\n}"

	static function getChangesetPattern[Function:(e : haxe.macro.TypedExpr) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(27721):haxe.macro.TypedExpr]
		[Block:Dynamic] [Return:Dynamic] [Const:String] "@:changeset\npublic static function changeset(struct, params) {\n    // Validation logic\n}"

	static function hasPatternMatching[Function:(e : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local e(27727):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var found(27728):Array<Bool>] [ArrayDecl:Array<Bool>] [Const:Bool] false
			[Call:Void]
				[Field:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
					[TypeExpr haxe.macro.TypedExprTools:Class<haxe.macro.TypedExprTools>]
					[FStatic:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
						haxe.macro.TypedExprTools
						iter:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void
				[Local e(27727):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
				[Function:(expr : haxe.macro.TypedExpr) -> Void]
					[Arg:haxe.macro.TypedExpr] [Local expr(27729):haxe.macro.TypedExpr]
					[Block:Void]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TSwitch(_, _, _):
		found = true;	
	case _:
})
							[Block:Void]
								[Var `(27734):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(27729):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(27734):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										==
										[Const:Int] 18
									[Then:Bool] [Block:Bool]
										[Var `(27735):haxe.macro.TypedExpr]
											[EnumParameter:haxe.macro.TypedExpr]
												[Local `(27734):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TSwitch
												0
										[Var `(27736):Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
											[EnumParameter:Array<{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }>]
												[Local `(27734):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TSwitch
												1
										[Var `(27737):Null<haxe.macro.TypedExpr>]
											[EnumParameter:Null<haxe.macro.TypedExpr>]
												[Local `(27734):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TSwitch
												2
										[Block:Bool]
											[Binop:Bool]
												[Array:Bool]
													[Local found(27728):Array<Bool>:Array<Bool>]
													[Const:Int] 0
												=
												[Const:Bool] true
									[Else:Void] [Block:Void]
			[Return:Dynamic]
				[Array:Bool]
					[Local found(27728):Array<Bool>:Array<Bool>]
					[Const:Int] 0

	static function hasErrorHandling[Function:(e : haxe.macro.TypedExpr) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local e(27739):haxe.macro.TypedExpr]
		[Block:Dynamic]
			[Var found(27740):Array<Bool>] [ArrayDecl:Array<Bool>] [Const:Bool] false
			[Call:Void]
				[Field:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
					[TypeExpr haxe.macro.TypedExprTools:Class<haxe.macro.TypedExprTools>]
					[FStatic:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void]
						haxe.macro.TypedExprTools
						iter:(e : haxe.macro.TypedExpr, f : (haxe.macro.TypedExpr -> Void)) -> Void
				[Local e(27739):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
				[Function:(expr : haxe.macro.TypedExpr) -> Void]
					[Arg:haxe.macro.TypedExpr] [Local expr(27741):haxe.macro.TypedExpr]
					[Block:Void]
						[Meta:Void]
							:ast(switch (expr.expr) {
	case TCall(e, _):
		found = true;	
	case _:
})
							[Block:Void]
								[Var `(27746):haxe.macro.TypedExprDef]
									[Field:haxe.macro.TypedExprDef]
										[Local expr(27741):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(27746):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										==
										[Const:Int] 9
									[Then:Bool] [Block:Bool]
										[Var `(27747):haxe.macro.TypedExpr]
											[EnumParameter:haxe.macro.TypedExpr]
												[Local `(27746):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TCall
												0
										[Var `(27748):Array<haxe.macro.TypedExpr>]
											[EnumParameter:Array<haxe.macro.TypedExpr>]
												[Local `(27746):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
												TCall
												1
										[Block:Bool]
											[Var e(27749):haxe.macro.TypedExpr] [Local `(27747):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Block:Bool]
												[Binop:Bool]
													[Array:Bool]
														[Local found(27740):Array<Bool>:Array<Bool>]
														[Const:Int] 0
													=
													[Const:Bool] true
									[Else:Void] [Block:Void]
			[Return:Dynamic]
				[Array:Bool]
					[Local found(27740):Array<Bool>:Array<Bool>]
					[Const:Int] 0

	static function getPatternMatchingExample[Function:(f : haxe.macro.TFunc) -> String]
		[Arg:haxe.macro.TFunc] [Local f(27738):haxe.macro.TFunc]
		[Block:Dynamic] [Return:Dynamic] [Const:String] "switch(result) {\n    case {ok: value}: handleSuccess(value);\n    case {error: reason}: handleError(reason);\n}"

	static function getErrorHandlingExample[Function:(f : haxe.macro.TFunc) -> String]
		[Arg:haxe.macro.TFunc] [Local f(27750):haxe.macro.TFunc]
		[Block:Dynamic] [Return:Dynamic] [Const:String] "try {\n    performOperation();\n} catch(e:Dynamic) {\n    handleError(e);\n}"
}