@:nullSafety(Off)
class reflaxe.elixir.helpers.MethodCallCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(28911):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.MethodCallCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(28911):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileCallExpression[Function:(e : haxe.macro.TypedExpr, el : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(22222):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local el(22223):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22235):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var result(23514):String]
				[Meta:String]
					:ast(switch (e.expr) {
	case TLocal(v) if (v.name == "getAppName"):
		var appName = AnnotationSystem.getEffectiveAppName(compiler.currentClassType);
		"\"${appName}\"";	
	case TLocal(v):
		var varType = v.t;
		var isFunction = switch (varType) {
			case TFun(_, _):
				true;			
			case _:
				false;			
		};
		if (isFunction) {
			var functionName = NamingHelper.toSnakeCase(v.name);
			var compiledArgs = el.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
			"${functionName}.(${compiledArgs.join(\", \")})";
		} else {
			compileMethodCall(e, el);
		};	
	case TField(obj, field):
		var fieldName = switch (field) {
			case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf):
				cf.get().name;			
			case FAnon(cf):
				cf.get().name;			
			case FEnum(_, ef):
				ef.name;			
			case FDynamic(s):
				s;			
		};
		if (obj.expr.match(TConst(TSuper)) && fieldName == "toString") {
			return "\"Exception\"";
		};
		if (isElixirSyntaxCall(obj, fieldName)) {
			return compileElixirSyntaxCall(fieldName, el);
		};
		if (isTypeSafeChildSpecCall(obj, fieldName)) {
			return compileTypeSafeChildSpecCall(fieldName, el);
		};
		if (fieldName == "getAppName") {
			var appName = AnnotationSystem.getEffectiveAppName(compiler.currentClassType);
			return "\"${appName}\"";
		};
		compileMethodCall(e, el);	
	case _:
		compileMethodCall(e, el);	
})
					[Block:String]
						[Var `(23473):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local e(22222):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(23473):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 1
								[Block:String]
									[Var `(23474):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(23473):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:String]
										[Var v(23475):haxe.macro.TVar] [Local `(23474):haxe.macro.TVar:haxe.macro.TVar]
										[If:String]
											[Binop:Bool]
												[Field:String]
													[Local v(23475):haxe.macro.TVar:haxe.macro.TVar]
													[FAnon:String] name:String
												==
												[Const:String] "getAppName"
											[Then:String] [Block:String]
												[Var appName(23476):String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
														[Field:Null<haxe.macro.ClassType>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:Null<haxe.macro.ClassType>]
																reflaxe.elixir.ElixirCompiler
																currentClassType:Null<haxe.macro.ClassType>
												[Binop:String]
													[Binop:String]
														[Const:String] "\""
														+
														[Local appName(23476):String:String]
													+
													[Const:String] "\""
											[Else:String] [Block:String]
												[Var v(23477):haxe.macro.TVar] [Local `(23474):haxe.macro.TVar:haxe.macro.TVar]
												[Block:String]
													[Var varType(23478):haxe.macro.Type]
														[Field:haxe.macro.Type]
															[Local v(23477):haxe.macro.TVar:haxe.macro.TVar]
															[FAnon:haxe.macro.Type] t:haxe.macro.Type
													[Var isFunction(23479):Bool]
														[Meta:Bool]
															:ast(switch (varType) {
	case TFun(_, _):
		true;	
	case _:
		false;	
})
															[If:Bool]
																[Binop:Bool]
																	[EnumIndex:Int] [Local varType(23478):haxe.macro.Type:haxe.macro.Type]
																	==
																	[Const:Int] 4
																[Then:Bool] [Block:Bool]
																	[Var `(23480):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																			[Local varType(23478):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			0
																	[Var `(23481):haxe.macro.Type]
																		[EnumParameter:haxe.macro.Type]
																			[Local varType(23478):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			1
																	[Block:Bool] [Const:Bool] true
																[Else:Bool] [Block:Bool] [Const:Bool] false
													[If:String]
														[Local isFunction(23479):Bool:Bool]
														[Then:String] [Block:String]
															[Var functionName(23482):String]
																[Call:String]
																	[Field:(camelCase : String) -> String]
																		[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																		[FStatic:(camelCase : String) -> String]
																			reflaxe.elixir.helpers.NamingHelper
																			toSnakeCase:(camelCase : String) -> String
																	[Field:String]
																		[Local v(23477):haxe.macro.TVar:haxe.macro.TVar]
																		[FAnon:String] name:String
															[Var compiledArgs(23483):Array<Null<String>>]
																[Block:Array<Null<String>>]
																	[Var `(23484):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
																	[Block:Void]
																		[Var `(23485):Int] [Const:Int] 0
																		[Var `(23486):Array<haxe.macro.TypedExpr>] [Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[While:Void]
																			[Binop:Bool]
																				[Local `(23485):Int:Int]
																				<
																				[Field:Int]
																					[Local `(23486):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																			[Block:Void]
																				[Var v(23487):haxe.macro.TypedExpr]
																					[Array:haxe.macro.TypedExpr]
																						[Local `(23486):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Local `(23485):Int:Int]
																				[Unop:Int]
																					++
																					Prefix
																					[Local `(23485):Int:Int]
																				[Call:Int]
																					[Field:(x : Null<String>) -> Int]
																						[Local `(23484):Array<Null<String>>:Array<Null<String>>]
																						[FInstance:(x : Null<String>) -> Int]
																							Array<Null<String>>
																							push:(x : Array.T) -> Int
																					[Call:Null<String>]
																						[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																							[Arg:haxe.macro.TypedExpr] [Local arg(23488):haxe.macro.TypedExpr]
																							[Block:Dynamic]
																								[Return:Dynamic]
																									[Call:Null<String>]
																										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																											[Field:reflaxe.elixir.ElixirCompiler]
																												[Local `this(22235):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																												[FInstance:reflaxe.elixir.ElixirCompiler]
																													reflaxe.elixir.helpers.MethodCallCompiler
																													compiler:reflaxe.elixir.ElixirCompiler
																											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																												reflaxe.elixir.ElixirCompiler
																												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																										[Local arg(23488):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																										[Const:Null<Bool>] null
																						[Local v(23487):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local `(23484):Array<Null<String>>:Array<Null<String>>]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Const:String] ""
																			+
																			[Local functionName(23482):String:String]
																		+
																		[Const:String] ".("
																	+
																	[Call:String]
																		[Field:(sep : String) -> String]
																			[Local compiledArgs(23483):Array<Null<String>>:Array<Null<String>>]
																			[FInstance:(sep : String) -> String]
																				Array<Null<String>>
																				join:(sep : String) -> String
																		[Const:String] ", "
																+
																[Const:String] ")"
														[Else:String] [Block:String]
															[Call:String]
																[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
																	[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																	[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
																		reflaxe.elixir.helpers.MethodCallCompiler
																		compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
																[Local e(22222):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Case:String]
								[Const:Int] 4
								[Block:String]
									[Var `(23489):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(23473):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(23490):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(23473):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:String]
										[Var obj(23491):haxe.macro.TypedExpr] [Local `(23489):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var field(23492):haxe.macro.FieldAccess] [Local `(23490):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:String]
											[Var fieldName(23493):String]
												[Meta:String]
													:ast(switch (field) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf):
		cf.get().name;	
	case FAnon(cf):
		cf.get().name;	
	case FEnum(_, ef):
		ef.name;	
	case FDynamic(s):
		s;	
})
													[Switch:String]
														[Meta:Int]
															:exhaustive
															[EnumIndex:Int] [Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
														[Case:String]
															[Const:Int] 0
															[Block:String]
																[Var `(23494):haxe.macro.Ref<haxe.macro.ClassType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		0
																[Var `(23495):Array<haxe.macro.Type>]
																	[EnumParameter:Array<haxe.macro.Type>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		1
																[Var `(23496):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		2
																[Block:String]
																	[Var cf(23497):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23496):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23497):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 1
															[Block:String]
																[Var `(23498):haxe.macro.Ref<haxe.macro.ClassType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FStatic
																		0
																[Var `(23499):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FStatic
																		1
																[Block:String]
																	[Var cf(23500):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23499):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23500):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 2
															[Block:String]
																[Var `(23501):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FAnon
																		0
																[Block:String]
																	[Var cf(23502):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23501):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23502):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 3
															[Block:String]
																[Var `(23503):String]
																	[EnumParameter:String]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FDynamic
																		0
																[Block:String]
																	[Var s(23504):String] [Local `(23503):String:String]
																	[Block:String] [Local s(23504):String:String]
														[Case:String]
															[Const:Int] 4
															[Block:String]
																[Var `(23505):Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																	[EnumParameter:Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FClosure
																		0
																[Var `(23506):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FClosure
																		1
																[Block:String]
																	[Var cf(23507):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23506):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23507):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 5
															[Block:String]
																[Var `(23508):haxe.macro.Ref<haxe.macro.EnumType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FEnum
																		0
																[Var `(23509):haxe.macro.EnumField]
																	[EnumParameter:haxe.macro.EnumField]
																		[Local field(23492):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FEnum
																		1
																[Block:String]
																	[Var ef(23510):haxe.macro.EnumField] [Local `(23509):haxe.macro.EnumField:haxe.macro.EnumField]
																	[Block:String]
																		[Field:String]
																			[Local ef(23510):haxe.macro.EnumField:haxe.macro.EnumField]
																			[FAnon:String] name:String
											[If:Void]
												[Binop:Bool]
													[Block:Bool]
														[Var `(23511):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local obj(23491):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Bool]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23511):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:Bool] [Block:Bool]
																[Var `(23512):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23511):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:Bool]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23512):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 6
																	[Then:Bool] [Block:Bool] [Const:Bool] true
																	[Else:Bool] [Const:Bool] false
															[Else:Bool] [Const:Bool] false
													&&
													[Binop:Bool]
														[Local fieldName(23493):String:String]
														==
														[Const:String] "toString"
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "\"Exception\""
											[If:Void]
												[Call:Bool]
													[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
															reflaxe.elixir.helpers.MethodCallCompiler
															isElixirSyntaxCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
													[Local obj(23491):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local fieldName(23493):String:String]
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Call:String]
															[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compileElixirSyntaxCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
															[Local fieldName(23493):String:String]
															[Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[If:Void]
												[Call:Bool]
													[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
															reflaxe.elixir.helpers.MethodCallCompiler
															isTypeSafeChildSpecCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
													[Local obj(23491):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local fieldName(23493):String:String]
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Call:String]
															[Field:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compileTypeSafeChildSpecCall:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String
															[Local fieldName(23493):String:String]
															[Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[If:Void]
												[Binop:Bool]
													[Local fieldName(23493):String:String]
													==
													[Const:String] "getAppName"
												[Then:Dynamic] [Block:Dynamic]
													[Var appName(23513):String]
														[Call:String]
															[Field:(classType : haxe.macro.ClassType) -> String]
																[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																[FStatic:(classType : haxe.macro.ClassType) -> String]
																	reflaxe.elixir.helpers.AnnotationSystem
																	getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
															[Field:Null<haxe.macro.ClassType>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.MethodCallCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:Null<haxe.macro.ClassType>]
																	reflaxe.elixir.ElixirCompiler
																	currentClassType:Null<haxe.macro.ClassType>
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Const:String] "\""
																+
																[Local appName(23513):String:String]
															+
															[Const:String] "\""
											[Call:String]
												[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
												[Local e(22222):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
												reflaxe.elixir.helpers.MethodCallCompiler
												compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
										[Local e(22222):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local el(22223):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Return:Dynamic] [Local result(23514):String:String]

	public function compileMethodCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(22245):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22246):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var result(23189):String]
				[Meta:String]
					:ast(switch (e.expr) {
	case TField(obj, fa):
		compileFieldMethodCall(obj, fa, args);	
	case TCall(funcExpr, callArgs):
		compileNestedCall(funcExpr, callArgs, args);	
	case _:
		compileGenericCall(e, args);	
})
					[Block:String]
						[Var `(23180):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local e(22245):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 4
								[Block:String]
									[Var `(23181):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(23182):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:String]
										[Var obj(23183):haxe.macro.TypedExpr] [Local `(23181):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var fa(23184):haxe.macro.FieldAccess] [Local `(23182):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:String]
											[Call:String]
												[Field:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileFieldMethodCall:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String
												[Local obj(23183):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local fa(23184):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												[Local args(22246):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Case:String]
								[Const:Int] 9
								[Block:String]
									[Var `(23185):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(23186):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:String]
										[Var funcExpr(23187):haxe.macro.TypedExpr] [Local `(23185):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var callArgs(23188):Array<haxe.macro.TypedExpr>] [Local `(23186):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:String]
											[Call:String]
												[Field:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileNestedCall:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String
												[Local funcExpr(23187):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local callArgs(23188):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local args(22246):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
												reflaxe.elixir.helpers.MethodCallCompiler
												compileGenericCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
										[Local e(22245):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local args(22246):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Return:Dynamic] [Local result(23189):String:String]

	function compileFieldMethodCall[Function:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local obj(22249):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(22250):haxe.macro.FieldAccess]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[Var `this(22273):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var methodName(22255):String]
				[Call:String]
					[Field:(fa : haxe.macro.FieldAccess) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(fa : haxe.macro.FieldAccess) -> String]
							reflaxe.elixir.ElixirCompiler
							getFieldName:(fa : haxe.macro.FieldAccess) -> String
					[Local fa(22250):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
			[Var objStr(22256):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:() -> Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.MethodCallCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:() -> Bool]
								reflaxe.elixir.ElixirCompiler
								isStateThreadingEnabled:() -> Bool
					&&
					[Call:Bool]
						[Field:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
								reflaxe.elixir.helpers.MethodCallCompiler
								isStructMethodCall:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool
						[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Local fa(22250):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
				[Then:Void] [Block:Void]
					[If:Void]
						[Call:Bool]
							[Field:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
									reflaxe.elixir.helpers.MethodCallCompiler
									isMutatingStructMethod:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool
							[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local methodName(22255):String:String]
						[Then:Dynamic] [Block:Dynamic]
							[Var compiledArgs(22282):Array<Null<String>>]
								[Block:Array<Null<String>>]
									[Var `(22277):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(22278):Int] [Const:Int] 0
										[Var `(22279):Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(22278):Int:Int]
												<
												[Field:Int]
													[Local `(22279):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(22280):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(22279):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(22278):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(22278):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(22277):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(22281):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(22273):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(22281):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(22280):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(22277):Array<Null<String>>:Array<Null<String>>]
							[Var callExpression(22285):String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Local objStr(22256):Null<String>:Null<String>]
													+
													[Const:String] "."
												+
												[Call:String]
													[Field:(haxeName : String) -> String]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(haxeName : String) -> String]
															reflaxe.elixir.ElixirCompiler
															toElixirName:(haxeName : String) -> String
													[Local methodName(22255):String:String]
											+
											[Const:String] "("
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(22282):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Local objStr(22256):Null<String>:Null<String>]
										+
										[Const:String] " = "
									+
									[Local callExpression(22285):String:String]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22256):Null<String>:Null<String>]
						==
						[Const:String] "Phoenix.PubSub"
					||
					[Binop:Bool]
						[Local objStr(22256):Null<String>:Null<String>]
						==
						[Const:String] "PubSub"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.helpers.MethodCallCompiler
									compilePubSubCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local methodName(22255):String:String]
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22256):Null<String>:Null<String>]
						==
						[Const:String] "HXX"
					&&
					[Binop:Bool]
						[Local methodName(22255):String:String]
						==
						[Const:String] "hxx"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileHxxCall:(args : Array<haxe.macro.TypedExpr>) -> String
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local methodName(22255):String:String]
						==
						[Const:String] "hxx"
					&&
					[Binop:Bool]
						[Field:Int]
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
						==
						[Const:Int] 1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileHxxCall:(args : Array<haxe.macro.TypedExpr>) -> String
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22256):Null<String>:Null<String>]
						==
						[Const:String] "OptionTools"
					&&
					[Call:Bool]
						[Field:(methodName : String) -> Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.MethodCallCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(methodName : String) -> Bool]
								reflaxe.elixir.ElixirCompiler
								isOptionMethod:(methodName : String) -> Bool
						[Local methodName(22255):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var compiledArgs(22311):Array<Null<String>>]
						[Block:Array<Null<String>>]
							[Var `(22306):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
							[Block:Void]
								[Var `(22307):Int] [Const:Int] 0
								[Var `(22308):Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[While:Void]
									[Binop:Bool]
										[Local `(22307):Int:Int]
										<
										[Field:Int]
											[Local `(22308):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
									[Block:Void]
										[Var v(22309):haxe.macro.TypedExpr]
											[Array:haxe.macro.TypedExpr]
												[Local `(22308):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local `(22307):Int:Int]
										[Unop:Int]
											++
											Prefix
											[Local `(22307):Int:Int]
										[Call:Int]
											[Field:(x : Null<String>) -> Int]
												[Local `(22306):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(x : Null<String>) -> Int]
													Array<Null<String>>
													push:(x : Array.T) -> Int
											[Call:Null<String>]
												[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
													[Arg:haxe.macro.TypedExpr] [Local arg(22310):haxe.macro.TypedExpr]
													[Block:Dynamic]
														[Return:Dynamic]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Local `this(22273):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local arg(22310):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
												[Local v(22309):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local `(22306):Array<Null<String>>:Array<Null<String>>]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "OptionTools."
										+
										[Local methodName(22255):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local compiledArgs(22311):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local objStr(22256):Null<String>:Null<String>]
								==
								[Const:String] "ResultTools"
							&&
							[Call:Bool]
								[Field:(methodName : String) -> Bool]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.MethodCallCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:(methodName : String) -> Bool]
										reflaxe.elixir.ElixirCompiler
										isResultMethod:(methodName : String) -> Bool
								[Local methodName(22255):String:String]
						[Then:Dynamic] [Block:Dynamic]
							[Var compiledArgs(22323):Array<Null<String>>]
								[Block:Array<Null<String>>]
									[Var `(22318):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(22319):Int] [Const:Int] 0
										[Var `(22320):Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(22319):Int:Int]
												<
												[Field:Int]
													[Local `(22320):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(22321):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(22320):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(22319):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(22319):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(22318):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(22322):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(22273):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(22322):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(22321):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(22318):Array<Null<String>>:Array<Null<String>>]
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "ResultTools."
												+
												[Local methodName(22255):String:String]
											+
											[Const:String] "("
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(22323):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Local objStr(22256):Null<String>:Null<String>]
										==
										[Const:String] "ArrayTools"
									&&
									[Call:Bool]
										[Field:(methodName : String) -> Bool]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.MethodCallCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(methodName : String) -> Bool]
												reflaxe.elixir.ElixirCompiler
												isArrayMethod:(methodName : String) -> Bool
										[Local methodName(22255):String:String]
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Call:String]
											[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
												[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
												[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
													reflaxe.elixir.helpers.MethodCallCompiler
													compileArrayToolsCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
											[Local methodName(22255):String:String]
											[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Else:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Local objStr(22256):Null<String>:Null<String>]
												==
												[Const:String] "MapTools"
											&&
											[Call:Bool]
												[Field:(methodName : String) -> Bool]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.MethodCallCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(methodName : String) -> Bool]
														reflaxe.elixir.ElixirCompiler
														isMapMethod:(methodName : String) -> Bool
												[Local methodName(22255):String:String]
										[Then:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Call:String]
													[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
															reflaxe.elixir.helpers.MethodCallCompiler
															compileMapToolsCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
													[Local methodName(22255):String:String]
													[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Meta:Void]
				:ast(switch (obj.t) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var compiled = compiler.compileADTStaticExtension(enumType, methodName, objStr, args);
		if (compiled != null) return compiled;	
	case _:
})
				[Block:Void]
					[Var `(23016):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Type] t:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23016):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 1
						[Then:Void] [Block:Void]
							[Var `(23017):haxe.macro.Ref<haxe.macro.EnumType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
									[Local `(23016):haxe.macro.Type:haxe.macro.Type]
									TEnum
									0
							[Var `(23018):Array<haxe.macro.Type>]
								[EnumParameter:Array<haxe.macro.Type>]
									[Local `(23016):haxe.macro.Type:haxe.macro.Type]
									TEnum
									1
							[Block:Void]
								[Var enumRef(23019):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(23017):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
								[Block:Void]
									[Var enumType(23020):haxe.macro.EnumType]
										[Call:haxe.macro.EnumType]
											[Field:() -> haxe.macro.EnumType]
												[Local enumRef(23019):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
												[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
									[Var compiled(23021):Null<String>]
										[Call:Null<String>]
											[Field:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.MethodCallCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileADTStaticExtension:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>
											[Local enumType(23020):haxe.macro.EnumType:haxe.macro.EnumType]
											[Local methodName(22255):String:String]
											[Local objStr(22256):Null<String>:Null<String>]
											[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[If:Void]
										[Binop:Bool]
											[Local compiled(23021):Null<String>:Null<String>]
											!=
											[Const:Null<String>] null
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiled(23021):Null<String>:Null<String>]
						[Else:Void] [Block:Void]
			[Meta:Void]
				:ast(switch (obj.t) {
	case TInst(t, _):
		var className = t.get().name;
		if (className == "Map" || className == "StringMap" || className == "IntMap" || className == "ObjectMap" || className == "EnumValueMap") {
			var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
			var mapCall = MapCompiler.compileMapMethod(objStr, methodName, compiledArgs);
			if (methodName == "set" && objStr != null) {
				var actualVarName = objStr;
				switch (obj.expr) {
					case TLocal(v):
						if (compiler.variableCompiler != null) {
							var idMapping = compiler.variableCompiler.variableIdMap.get(v.id);
							if (idMapping != null) {
								actualVarName = idMapping;
							} else {
								var snakeName = NamingHelper.toSnakeCase(v.name);
								var prefixedName = compiler.variableCompiler.underscorePrefixMap.get(snakeName);
								if (prefixedName != null) {
									actualVarName = prefixedName;
								} else if (v.meta != null && v.meta.has("-reflaxe.unused")) {
									if (!StringTools.startsWith(actualVarName, "_")) {
										actualVarName = "_" + actualVarName;
									};
								};
							};
						};					
					case _:
				};
				var isSimpleVariable = ~/^[a-z_][a-z0-9_]*$/.match(actualVarName);
				if (isSimpleVariable) {
					var updatedMapCall = StringTools.replace(mapCall, "($objStr,", "($actualVarName,");
					var reassignment = actualVarName + " = " + updatedMapCall;
					return reassignment;
				};
			};
			return mapCall;
		};
		if (className == "Array") {
			return compiler.compileArrayMethod(objStr, methodName, args);
		};	
	case _:
})
				[Block:Void]
					[Var `(23068):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Type] t:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23068):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 2
						[Then:Void] [Block:Void]
							[Var `(23069):haxe.macro.Ref<haxe.macro.ClassType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
									[Local `(23068):haxe.macro.Type:haxe.macro.Type]
									TInst
									0
							[Var `(23070):Array<haxe.macro.Type>]
								[EnumParameter:Array<haxe.macro.Type>]
									[Local `(23068):haxe.macro.Type:haxe.macro.Type]
									TInst
									1
							[Block:Void]
								[Var t(23071):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(23069):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
								[Block:Void]
									[Var className(23072):String]
										[Field:String]
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local t(23071):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
											[FAnon:String] name:String
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Binop:Bool]
													[Binop:Bool]
														[Binop:Bool]
															[Local className(23072):String:String]
															==
															[Const:String] "Map"
														||
														[Binop:Bool]
															[Local className(23072):String:String]
															==
															[Const:String] "StringMap"
													||
													[Binop:Bool]
														[Local className(23072):String:String]
														==
														[Const:String] "IntMap"
												||
												[Binop:Bool]
													[Local className(23072):String:String]
													==
													[Const:String] "ObjectMap"
											||
											[Binop:Bool]
												[Local className(23072):String:String]
												==
												[Const:String] "EnumValueMap"
										[Then:Dynamic] [Block:Dynamic]
											[Var compiledArgs(23073):Array<Null<String>>]
												[Block:Array<Null<String>>]
													[Var `(23074):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
													[Block:Void]
														[Var `(23075):Int] [Const:Int] 0
														[Var `(23076):Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[While:Void]
															[Binop:Bool]
																[Local `(23075):Int:Int]
																<
																[Field:Int]
																	[Local `(23076):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[FInstance:Int]
																		Array<haxe.macro.TypedExpr>
																		length:Int
															[Block:Void]
																[Var v(23077):haxe.macro.TypedExpr]
																	[Array:haxe.macro.TypedExpr]
																		[Local `(23076):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Local `(23075):Int:Int]
																[Unop:Int]
																	++
																	Prefix
																	[Local `(23075):Int:Int]
																[Call:Int]
																	[Field:(x : Null<String>) -> Int]
																		[Local `(23074):Array<Null<String>>:Array<Null<String>>]
																		[FInstance:(x : Null<String>) -> Int]
																			Array<Null<String>>
																			push:(x : Array.T) -> Int
																	[Call:Null<String>]
																		[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																			[Arg:haxe.macro.TypedExpr] [Local arg(23078):haxe.macro.TypedExpr]
																			[Block:Dynamic]
																				[Return:Dynamic]
																					[Call:Null<String>]
																						[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																							[Field:reflaxe.elixir.ElixirCompiler]
																								[Local `this(22273):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																								[FInstance:reflaxe.elixir.ElixirCompiler]
																									reflaxe.elixir.helpers.MethodCallCompiler
																									compiler:reflaxe.elixir.ElixirCompiler
																							[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								reflaxe.elixir.ElixirCompiler
																								compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																						[Local arg(23078):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																						[Const:Null<Bool>] null
																		[Local v(23077):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local `(23074):Array<Null<String>>:Array<Null<String>>]
											[Var mapCall(23079):String]
												[Call:String]
													[Field:(mapExpr : String, methodName : String, args : Array<String>) -> String]
														[TypeExpr reflaxe.elixir.helpers.MapCompiler:Class<reflaxe.elixir.helpers.MapCompiler>]
														[FStatic:(mapExpr : String, methodName : String, args : Array<String>) -> String]
															reflaxe.elixir.helpers.MapCompiler
															compileMapMethod:(mapExpr : String, methodName : String, args : Array<String>) -> String
													[Local objStr(22256):Null<String>:Null<String>]
													[Local methodName(22255):String:String]
													[Local compiledArgs(23073):Array<Null<String>>:Array<Null<String>>]
											[If:Void]
												[Binop:Bool]
													[Binop:Bool]
														[Local methodName(22255):String:String]
														==
														[Const:String] "set"
													&&
													[Binop:Bool]
														[Local objStr(22256):Null<String>:Null<String>]
														!=
														[Const:Null<String>] null
												[Then:Void] [Block:Void]
													[Var actualVarName(23080):Null<String>] [Local objStr(22256):Null<String>:Null<String>]
													[Meta:Void]
														:ast(switch (obj.expr) {
	case TLocal(v):
		if (compiler.variableCompiler != null) {
			var idMapping = compiler.variableCompiler.variableIdMap.get(v.id);
			if (idMapping != null) {
				actualVarName = idMapping;
			} else {
				var snakeName = NamingHelper.toSnakeCase(v.name);
				var prefixedName = compiler.variableCompiler.underscorePrefixMap.get(snakeName);
				if (prefixedName != null) {
					actualVarName = prefixedName;
				} else if (v.meta != null && v.meta.has("-reflaxe.unused")) {
					if (!StringTools.startsWith(actualVarName, "_")) {
						actualVarName = "_" + actualVarName;
					};
				};
			};
		};	
	case _:
})
														[Block:Void]
															[Var `(23081):haxe.macro.TypedExprDef]
																[Field:haxe.macro.TypedExprDef]
																	[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
															[If:Void]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(23081):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	==
																	[Const:Int] 1
																[Then:Void] [Block:Void]
																	[Var `(23082):haxe.macro.TVar]
																		[EnumParameter:haxe.macro.TVar]
																			[Local `(23081):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																			TLocal
																			0
																	[Block:Void]
																		[Var v(23083):haxe.macro.TVar] [Local `(23082):haxe.macro.TVar:haxe.macro.TVar]
																		[Block:Void]
																			[If:Void]
																				[Binop:Bool]
																					[Field:reflaxe.elixir.helpers.VariableCompiler]
																						[Field:reflaxe.elixir.ElixirCompiler]
																							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																							[FInstance:reflaxe.elixir.ElixirCompiler]
																								reflaxe.elixir.helpers.MethodCallCompiler
																								compiler:reflaxe.elixir.ElixirCompiler
																						[FInstance:reflaxe.elixir.helpers.VariableCompiler]
																							reflaxe.elixir.ElixirCompiler
																							variableCompiler:reflaxe.elixir.helpers.VariableCompiler
																					!=
																					[Const:reflaxe.elixir.helpers.VariableCompiler] null
																				[Then:Void] [Block:Void]
																					[Var idMapping(23084):Null<String>]
																						[Block:Null<String>]
																							[Var this(23085):haxe.IMap<Int, String>]
																								[Field:Map<Int, String>]
																									[Field:reflaxe.elixir.helpers.VariableCompiler]
																										[Field:reflaxe.elixir.ElixirCompiler]
																											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																											[FInstance:reflaxe.elixir.ElixirCompiler]
																												reflaxe.elixir.helpers.MethodCallCompiler
																												compiler:reflaxe.elixir.ElixirCompiler
																										[FInstance:reflaxe.elixir.helpers.VariableCompiler]
																											reflaxe.elixir.ElixirCompiler
																											variableCompiler:reflaxe.elixir.helpers.VariableCompiler
																									[FInstance:Map<Int, String>]
																										reflaxe.elixir.helpers.VariableCompiler
																										variableIdMap:Map<Int, String>
																							[Var key(23086):Int]
																								[Field:Int]
																									[Local v(23083):haxe.macro.TVar:haxe.macro.TVar]
																									[FAnon:Int] id:Int
																							[Call:Null<String>]
																								[Field:(key : Int) -> Null<String>]
																									[Cast:haxe.ds.IntMap<String>] [Local this(23085):haxe.IMap<Int, String>:haxe.IMap<Int, String>]
																									[FInstance:(key : Int) -> Null<String>]
																										haxe.ds.IntMap<String>
																										get:(key : Int) -> Null<haxe.ds.IntMap.T>
																								[Local key(23086):Int:Int]
																					[If:Void]
																						[Binop:Bool]
																							[Local idMapping(23084):Null<String>:Null<String>]
																							!=
																							[Const:Null<String>] null
																						[Then:Null<String>] [Block:Null<String>]
																							[Binop:Null<String>]
																								[Local actualVarName(23080):Null<String>:Null<String>]
																								=
																								[Local idMapping(23084):Null<String>:Null<String>]
																						[Else:Void] [Block:Void]
																							[Var snakeName(23087):String]
																								[Call:String]
																									[Field:(camelCase : String) -> String]
																										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																										[FStatic:(camelCase : String) -> String]
																											reflaxe.elixir.helpers.NamingHelper
																											toSnakeCase:(camelCase : String) -> String
																									[Field:String]
																										[Local v(23083):haxe.macro.TVar:haxe.macro.TVar]
																										[FAnon:String] name:String
																							[Var prefixedName(23088):Null<String>]
																								[Block:Null<String>]
																									[Var this(23089):haxe.IMap<String, String>]
																										[Field:Map<String, String>]
																											[Field:reflaxe.elixir.helpers.VariableCompiler]
																												[Field:reflaxe.elixir.ElixirCompiler]
																													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																													[FInstance:reflaxe.elixir.ElixirCompiler]
																														reflaxe.elixir.helpers.MethodCallCompiler
																														compiler:reflaxe.elixir.ElixirCompiler
																												[FInstance:reflaxe.elixir.helpers.VariableCompiler]
																													reflaxe.elixir.ElixirCompiler
																													variableCompiler:reflaxe.elixir.helpers.VariableCompiler
																											[FInstance:Map<String, String>]
																												reflaxe.elixir.helpers.VariableCompiler
																												underscorePrefixMap:Map<String, String>
																									[Call:Null<String>]
																										[Field:(key : String) -> Null<String>]
																											[Cast:haxe.ds.StringMap<String>] [Local this(23089):haxe.IMap<String, String>:haxe.IMap<String, String>]
																											[FInstance:(key : String) -> Null<String>]
																												haxe.ds.StringMap<String>
																												get:(key : String) -> Null<haxe.ds.StringMap.T>
																										[Local snakeName(23087):String:String]
																							[If:Void]
																								[Binop:Bool]
																									[Local prefixedName(23088):Null<String>:Null<String>]
																									!=
																									[Const:Null<String>] null
																								[Then:Null<String>] [Block:Null<String>]
																									[Binop:Null<String>]
																										[Local actualVarName(23080):Null<String>:Null<String>]
																										=
																										[Local prefixedName(23088):Null<String>:Null<String>]
																								[Else:Void] [Block:Void]
																									[If:Void]
																										[Binop:Bool]
																											[Binop:Bool]
																												[Field:Null<haxe.macro.MetaAccess>]
																													[Local v(23083):haxe.macro.TVar:haxe.macro.TVar]
																													[FAnon:Null<haxe.macro.MetaAccess>] meta:Null<haxe.macro.MetaAccess>
																												!=
																												[Const:Null<haxe.macro.MetaAccess>] null
																											&&
																											[Call:Bool]
																												[Field:(name : String) -> Bool]
																													[Field:Null<haxe.macro.MetaAccess>]
																														[Local v(23083):haxe.macro.TVar:haxe.macro.TVar]
																														[FAnon:Null<haxe.macro.MetaAccess>] meta:Null<haxe.macro.MetaAccess>
																													[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
																												[Const:String] "-reflaxe.unused"
																										[Then:Void] [Block:Void]
																											[If:Void]
																												[Unop:Bool]
																													!
																													Prefix
																													[Call:Bool]
																														[Field:(s : String, start : String) -> Bool]
																															[TypeExpr StringTools:Class<StringTools>]
																															[FStatic:(s : String, start : String) -> Bool]
																																StringTools
																																startsWith:(s : String, start : String) -> Bool
																														[Local actualVarName(23080):Null<String>:Null<String>]
																														[Const:String] "_"
																												[Then:Null<String>] [Block:Null<String>]
																													[Binop:Null<String>]
																														[Local actualVarName(23080):Null<String>:Null<String>]
																														=
																														[Binop:String]
																															[Const:String] "_"
																															+
																															[Local actualVarName(23080):Null<String>:Null<String>]
																[Else:Void] [Block:Void]
													[Var isSimpleVariable(23090):Bool]
														[Call:Bool]
															[Field:(s : String) -> Bool]
																[New:EReg]
																	EReg
																	[Const:String] "^[a-z_][a-z0-9_]*$"
																	[Const:String] "i"
																[FInstance:(s : String) -> Bool]
																	EReg
																	match:(s : String) -> Bool
															[Local actualVarName(23080):Null<String>:Null<String>]
													[If:Void]
														[Local isSimpleVariable(23090):Bool:Bool]
														[Then:Dynamic] [Block:Dynamic]
															[Var updatedMapCall(23091):String]
																[Call:String]
																	[Field:(s : String, sub : String, by : String) -> String]
																		[TypeExpr StringTools:Class<StringTools>]
																		[FStatic:(s : String, sub : String, by : String) -> String]
																			StringTools
																			replace:(s : String, sub : String, by : String) -> String
																	[Local mapCall(23079):String:String]
																	[Binop:String]
																		[Binop:String]
																			[Const:String] "("
																			+
																			[Local objStr(22256):Null<String>:Null<String>]
																		+
																		[Const:String] ","
																	[Binop:String]
																		[Binop:String]
																			[Const:String] "("
																			+
																			[Local actualVarName(23080):Null<String>:Null<String>]
																		+
																		[Const:String] ","
															[Var reassignment(23092):String]
																[Binop:String]
																	[Binop:String]
																		[Local actualVarName(23080):Null<String>:Null<String>]
																		+
																		[Const:String] " = "
																	+
																	[Local updatedMapCall(23091):String:String]
															[Return:Dynamic] [Local reassignment(23092):String:String]
											[Return:Dynamic] [Local mapCall(23079):String:String]
									[If:Void]
										[Binop:Bool]
											[Local className(23072):String:String]
											==
											[Const:String] "Array"
										[Then:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Call:String]
													[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
															reflaxe.elixir.ElixirCompiler
															compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
													[Local objStr(22256):Null<String>:Null<String>]
													[Local methodName(22255):String:String]
													[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[Else:Void] [Block:Void]
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:(methodName : String) -> Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.MethodCallCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(methodName : String) -> Bool]
								reflaxe.elixir.ElixirCompiler
								isArrayMethod:(methodName : String) -> Bool
						[Local methodName(22255):String:String]
					&&
					[Unop:Bool]
						!
						Prefix
						[Call:Bool]
							[Field:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
									reflaxe.elixir.helpers.MethodCallCompiler
									isExternModuleCall:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool
							[Local obj(22249):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local fa(22250):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local objStr(22256):Null<String>:Null<String>]
							[Local methodName(22255):String:String]
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Var compiledArgs(23112):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(23107):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(23108):Int] [Const:Int] 0
						[Var `(23109):Array<haxe.macro.TypedExpr>] [Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(23108):Int:Int]
								<
								[Field:Int]
									[Local `(23109):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(23110):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(23109):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(23108):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(23108):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(23107):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(23111):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22273):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(23111):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(23110):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(23107):Array<Null<String>>:Array<Null<String>>]
			[If:Void]
				[Call:Bool]
					[Field:(typeName : String) -> Bool]
						[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
						[FStatic:(typeName : String) -> Bool]
							reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
							isADTTypeName:(typeName : String) -> Bool
					[Local objStr(22256):Null<String>:Null<String>]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.helpers.MethodCallCompiler
									compileADTConstructorCall:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local objStr(22256):Null<String>:Null<String>]
							[Local methodName(22255):String:String]
							[Local args(22251):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local methodName(22255):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "."
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Local methodName(22255):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Call:Array<Null<String>>]
											[Field:(a : Array<Null<String>>) -> Array<Null<String>>]
												[ArrayDecl:Array<Null<String>>] [Local objStr(22256):Null<String>:Null<String>]
												[FInstance:(a : Array<Null<String>>) -> Array<Null<String>>]
													Array<Null<String>>
													concat:(a : Array<Array.T>) -> Array<Array.T>
											[Local compiledArgs(23112):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Local objStr(22256):Null<String>:Null<String>]
											+
											[Const:String] "."
										+
										[Call:String]
											[Field:(haxeName : String) -> String]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.MethodCallCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(haxeName : String) -> String]
													reflaxe.elixir.ElixirCompiler
													toElixirName:(haxeName : String) -> String
											[Local methodName(22255):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local compiledArgs(23112):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"

	function compilePubSubCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22286):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22287):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22289):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var compiledArgs(22298):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(22293):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(22294):Int] [Const:Int] 0
						[Var `(22295):Array<haxe.macro.TypedExpr>] [Local args(22287):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(22294):Int:Int]
								<
								[Field:Int]
									[Local `(22295):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(22296):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(22295):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(22294):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(22294):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(22293):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(22297):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22289):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(22297):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(22296):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(22293):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] "Phoenix.PubSub."
								+
								[Local methodName(22286):String:String]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local compiledArgs(22298):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function isExternModuleCall[Function:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(23093):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(23094):haxe.macro.FieldAccess]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (fa) {
	case FStatic(classRef, _):
		var cls = classRef.get();
		cls.isExtern;	
	case _:
		false;	
})
					[If:Bool]
						[Binop:Bool]
							[EnumIndex:Int] [Local fa(23094):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
							==
							[Const:Int] 1
						[Then:Bool] [Block:Bool]
							[Var `(23099):haxe.macro.Ref<haxe.macro.ClassType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
									[Local fa(23094):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
									FStatic
									0
							[Var `(23100):haxe.macro.Ref<haxe.macro.ClassField>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
									[Local fa(23094):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
									FStatic
									1
							[Block:Bool]
								[Var classRef(23101):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(23099):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
								[Block:Bool]
									[Var cls(23102):haxe.macro.ClassType]
										[Call:haxe.macro.ClassType]
											[Field:() -> haxe.macro.ClassType]
												[Local classRef(23101):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
												[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
									[Field:Bool]
										[Local cls(23102):haxe.macro.ClassType:haxe.macro.ClassType]
										[FAnon:Bool] isExtern:Bool
						[Else:Bool] [Block:Bool] [Const:Bool] false

	function compileArrayToolsCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22326):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22327):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(22327):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var arrayExpr(22328):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Array:haxe.macro.TypedExpr]
								[Local args(22327):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Const:Int] 0
							[Const:Null<Bool>] null
					[Var methodArgs(22329):Array<haxe.macro.TypedExpr>]
						[Call:Array<haxe.macro.TypedExpr>]
							[Field:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
								[Local args(22327):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[FInstance:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
									Array<haxe.macro.TypedExpr>
									slice:(pos : Int, ?end : Null<Int>) -> Array<Array.T>
							[Const:Int] 1
							[Const:Null<Int>] null
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local arrayExpr(22328):Null<String>:Null<String>]
							[Local methodName(22326):String:String]
							[Local methodArgs(22329):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "ArrayTools."
								+
								[Local methodName(22326):String:String]
							+
							[Const:String] "()"

	function compileMapToolsCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22699):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22700):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(22700):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var mapExpr(22701):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Array:haxe.macro.TypedExpr]
								[Local args(22700):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Const:Int] 0
							[Const:Null<Bool>] null
					[Var methodArgs(22702):Array<haxe.macro.TypedExpr>]
						[Call:Array<haxe.macro.TypedExpr>]
							[Field:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
								[Local args(22700):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[FInstance:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
									Array<haxe.macro.TypedExpr>
									slice:(pos : Int, ?end : Null<Int>) -> Array<Array.T>
							[Const:Int] 1
							[Const:Null<Int>] null
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileMapMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local mapExpr(22701):Null<String>:Null<String>]
							[Local methodName(22699):String:String]
							[Local methodArgs(22702):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "MapTools."
								+
								[Local methodName(22699):String:String]
							+
							[Const:String] "()"

	function compileADTConstructorCall[Function:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local objStr(23113):String]
		[Arg:String] [Local methodName(23114):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23115):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23134):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var config(23116):Null<reflaxe.elixir.helpers.ADTConfig>]
				[Call:Null<reflaxe.elixir.helpers.ADTConfig>]
					[Field:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>]
						[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
						[FStatic:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>]
							reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
							getADTConfigByTypeName:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>
					[Local objStr(23113):String:String]
			[If:Void]
				[Binop:Bool]
					[Local config(23116):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
					!=
					[Const:Null<reflaxe.elixir.helpers.ADTConfig>] null
				[Then:Void] [Block:Void]
					[Var enumType(23117):Null<haxe.macro.EnumType>] [Const:Null<haxe.macro.EnumType>] null
					[Try:Void]
						[Block:Void]
							[Var fullTypeName(23118):String]
								[Binop:String]
									[Binop:String]
										[Field:String]
											[Local config(23116):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
											[FAnon:String] moduleName:String
										+
										[Const:String] "."
									+
									[Field:String]
										[Local config(23116):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
										[FAnon:String] typeName:String
							[Var adtType(23119):haxe.macro.Type]
								[Call:haxe.macro.Type]
									[Field:(name : String) -> haxe.macro.Type]
										[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
										[FStatic:(name : String) -> haxe.macro.Type]
											haxe.macro.Context
											getType:(name : String) -> haxe.macro.Type
									[Local fullTypeName(23118):String:String]
							[Meta:Void]
								:ast(switch (adtType) {
	case TEnum(enumRef, _):
		enumType = enumRef.get();
		if (!AlgebraicDataTypeCompiler.isADTType(enumType)) {
			enumType = null;
		};	
	case _:
})
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local adtType(23119):haxe.macro.Type:haxe.macro.Type]
										==
										[Const:Int] 1
									[Then:Void] [Block:Void]
										[Var `(23123):haxe.macro.Ref<haxe.macro.EnumType>]
											[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
												[Local adtType(23119):haxe.macro.Type:haxe.macro.Type]
												TEnum
												0
										[Var `(23124):Array<haxe.macro.Type>]
											[EnumParameter:Array<haxe.macro.Type>]
												[Local adtType(23119):haxe.macro.Type:haxe.macro.Type]
												TEnum
												1
										[Block:Void]
											[Var enumRef(23125):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(23123):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
											[Block:Void]
												[Binop:Null<haxe.macro.EnumType>]
													[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
													=
													[Call:haxe.macro.EnumType]
														[Field:() -> haxe.macro.EnumType]
															[Local enumRef(23125):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
															[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
												[If:Void]
													[Unop:Bool]
														!
														Prefix
														[Call:Bool]
															[Field:(enumType : haxe.macro.EnumType) -> Bool]
																[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
																[FStatic:(enumType : haxe.macro.EnumType) -> Bool]
																	reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
																	isADTType:(enumType : haxe.macro.EnumType) -> Bool
															[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
													[Then:Null<haxe.macro.EnumType>] [Block:Null<haxe.macro.EnumType>]
														[Binop:Null<haxe.macro.EnumType>]
															[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
															=
															[Const:Null<haxe.macro.EnumType>] null
									[Else:Void] [Block:Void]
						Catch [Local `(33806):Dynamic]
							[Block:Void]
								[Block:Void]
								[Block:Void]
								[If:Void]
									[Const:Bool] true
									[Then:Void] [Block:Void]
										[Block:Void]
										[Block:Void]
									[Else:Unknown<59>] [Throw:Unknown<59>] [Local `(33806):Dynamic:Dynamic]
					[If:Void]
						[Binop:Bool]
							[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
							!=
							[Const:Null<haxe.macro.EnumType>] null
						[Then:Void] [Block:Void]
							[Var fakeField(23127):Null<haxe.macro.EnumField>] [Const:Null<haxe.macro.EnumField>] null
							[For:Void]
								[Local field(23132):haxe.macro.EnumField]
								[Block:Iterator<haxe.macro.EnumField>]
									[Var this(23131):haxe.IMap<String, haxe.macro.EnumField>]
										[Field:Map<String, haxe.macro.EnumField>]
											[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
											[FAnon:Map<String, haxe.macro.EnumField>] constructs:Map<String, haxe.macro.EnumField>
									[Call:Iterator<haxe.macro.EnumField>]
										[Field:() -> Iterator<haxe.macro.EnumField>]
											[Cast:haxe.ds.StringMap<haxe.macro.EnumField>] [Local this(23131):haxe.IMap<String, haxe.macro.EnumField>:haxe.IMap<String, haxe.macro.EnumField>]
											[FInstance:() -> Iterator<haxe.macro.EnumField>]
												haxe.ds.StringMap<haxe.macro.EnumField>
												iterator:() -> Iterator<haxe.ds.StringMap.T>
								[Block:Void]
									[If:Void]
										[Binop:Bool]
											[Call:String]
												[Field:() -> String]
													[Field:String]
														[Local field(23132):haxe.macro.EnumField:haxe.macro.EnumField]
														[FAnon:String] name:String
													[FInstance:() -> String]
														String
														toLowerCase:() -> String
											==
											[Call:String]
												[Field:() -> String]
													[Local methodName(23114):String:String]
													[FInstance:() -> String]
														String
														toLowerCase:() -> String
										[Then:Dynamic] [Block:Dynamic]
											[Binop:Null<haxe.macro.EnumField>]
												[Local fakeField(23127):Null<haxe.macro.EnumField>:Null<haxe.macro.EnumField>]
												=
												[Local field(23132):haxe.macro.EnumField:haxe.macro.EnumField]
											[Break:Dynamic]
							[If:Void]
								[Binop:Bool]
									[Local fakeField(23127):Null<haxe.macro.EnumField>:Null<haxe.macro.EnumField>]
									!=
									[Const:Null<haxe.macro.EnumField>] null
								[Then:Void] [Block:Void]
									[Var compiled(23135):Null<String>]
										[Call:Null<String>]
											[Field:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>]
												[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
												[FStatic:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>]
													reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
													compileADTMethodCall:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>
											[Local enumType(23117):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
											[Local methodName(23114):String:String]
											[Local args(23115):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
												[Arg:haxe.macro.TypedExpr] [Local expr(23133):haxe.macro.TypedExpr]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(23134):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local expr(23133):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
									[If:Void]
										[Binop:Bool]
											[Local compiled(23135):Null<String>:Null<String>]
											!=
											[Const:Null<String>] null
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiled(23135):Null<String>:Null<String>]
			[Var compiledArgs(23145):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(23140):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(23141):Int] [Const:Int] 0
						[Var `(23142):Array<haxe.macro.TypedExpr>] [Local args(23115):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(23141):Int:Int]
								<
								[Field:Int]
									[Local `(23142):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(23143):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(23142):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(23141):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(23141):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(23140):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(23144):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(23134):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(23144):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(23143):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(23140):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Local objStr(23113):String:String]
									+
									[Const:String] "."
								+
								[Call:String]
									[Field:(haxeName : String) -> String]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.MethodCallCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(haxeName : String) -> String]
											reflaxe.elixir.ElixirCompiler
											toElixirName:(haxeName : String) -> String
									[Local methodName(23114):String:String]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local compiledArgs(23145):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileNestedCall[Function:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local funcExpr(23148):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local callArgs(23149):Array<haxe.macro.TypedExpr>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23150):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23152):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Call:Null<String>]
								[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.MethodCallCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										reflaxe.elixir.ElixirCompiler
										compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
								[Local funcExpr(23148):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[Const:Null<Bool>] null
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Block:Array<Null<String>>]
									[Var `(23156):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(23157):Int] [Const:Int] 0
										[Var `(23158):Array<haxe.macro.TypedExpr>] [Local args(23150):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(23157):Int:Int]
												<
												[Field:Int]
													[Local `(23158):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(23159):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(23158):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(23157):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(23157):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(23156):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(23160):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(23152):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(23160):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(23159):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(23156):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileGenericCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(23161):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23162):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23165):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var functionName(23163):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local e(23161):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var compiledArgs(23174):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(23169):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(23170):Int] [Const:Int] 0
						[Var `(23171):Array<haxe.macro.TypedExpr>] [Local args(23162):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(23170):Int:Int]
								<
								[Field:Int]
									[Local `(23171):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(23172):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(23171):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(23170):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(23170):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(23169):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(23173):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(23165):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(23173):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(23172):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(23169):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Local functionName(23163):Null<String>:Null<String>]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local compiledArgs(23174):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	public function compileElixirSyntaxCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(23261):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23262):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23302):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodName) {
	case "code":
		if (args.length == 0) {
			Context.error("elixir.Syntax.code requires at least one String argument.", Context.currentPos());
			"";
		} else {
			var codeString = switch (args[0].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.code first parameter must be a constant String.", args[0].pos);
					"";				
			};
			var compiledArgs = [];
			for (i  in  1 ... args.length) {
				compiledArgs.push(compiler.compileExpression(args[i]));
			};
			var placeholderCount = 0;
			~/{(\d+)}/.map(codeString, function(ereg) {
				var num = Std.parseInt(ereg.matched(1));
				if (num != null && num >= placeholderCount) {
					placeholderCount = num + 1;
				};
				return ereg.matched(0);
			});
			if (placeholderCount > compiledArgs.length) {
				Context.error("elixir.Syntax.code() requires ${placeholderCount} arguments but ${compiledArgs.length} provided", Context.currentPos());
			};
			var result = ~/{(\d+)}/.map(codeString, function(ereg) {
				var num = Std.parseInt(ereg.matched(1));
				return (num != null && num < compiledArgs.length) ? compiledArgs[num] : ereg.matched(0);
			});
			return result;
		};	
	case "plainCode":
		if (args.length != 1) {
			Context.error("elixir.Syntax.plainCode requires exactly one String argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.plainCode parameter must be a constant String.", args[0].pos);
					"";				
			};
		};	
	case "atom":
		if (args.length != 1) {
			Context.error("elixir.Syntax.atom requires exactly one String argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TConst(TString(s)):
					":$s";				
				case _:
					var atomName = compiler.compileExpression(args[0]);
					":${atomName}";				
			};
		};	
	case "tuple":
		var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
		"{${compiledArgs.join(\", \")}}";	
	case "keyword":
		if (args.length != 1) {
			Context.error("elixir.Syntax.keyword requires exactly one Array argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TArrayDecl(elements):
					if (elements.length % 2 != 0) {
						Context.error("elixir.Syntax.keyword array must have an even number of elements (key-value pairs).", args[0].pos);
						"";
					} else {
						var pairs = [];
						var i = 0;
						while (i < elements.length) {
							var key = compiler.compileExpression(elements[i]);
							var value = compiler.compileExpression(elements[i + 1]);
							pairs.push("${key}: ${value}");
							i += 2;
						};
						"[${pairs.join(\", \")}]";
					};				
				case _:
					Context.error("elixir.Syntax.keyword parameter must be an array literal.", args[0].pos);
					"";				
			};
		};	
	case "map":
		if (args.length != 1) {
			Context.error("elixir.Syntax.map requires exactly one Array argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TArrayDecl(elements):
					if (elements.length % 2 != 0) {
						Context.error("elixir.Syntax.map array must have an even number of elements (key-value pairs).", args[0].pos);
						"";
					} else {
						var pairs = [];
						var i = 0;
						while (i < elements.length) {
							var key = compiler.compileExpression(elements[i]);
							var value = compiler.compileExpression(elements[i + 1]);
							pairs.push("${key} => ${value}");
							i += 2;
						};
						"%{${pairs.join(\", \")}}";
					};				
				case _:
					Context.error("elixir.Syntax.map parameter must be an array literal.", args[0].pos);
					"";				
			};
		};	
	case "list":
		var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
		"[${compiledArgs.join(\", \")}]";	
	case "pipe":
		if (args.length < 2) {
			Context.error("elixir.Syntax.pipe requires at least two arguments (initial value and operations).", Context.currentPos());
			"";
		} else {
			var initial = compiler.compileExpression(args[0]);
			var operations = [];
			for (i  in  1 ... args.length) {
				operations.push(compiler.compileExpression(args[i]));
			};
			"${initial} |> ${operations.join(\" |> \")}";
		};	
	case "match":
		if (args.length != 2) {
			Context.error("elixir.Syntax.match requires exactly two arguments (value and patterns).", Context.currentPos());
			"";
		} else {
			var value = compiler.compileExpression(args[0]);
			var patterns = switch (args[1].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.match patterns must be a constant String.", args[1].pos);
					"";				
			};
			"case ${value} do\n  ${StringTools.replace(patterns, \"\\n\", \"\n  \")}\nend";
		};	
	case _:
		Context.error("Unknown elixir.Syntax method: ${methodName}", Context.currentPos());
		"";	
})
					[Switch:String]
						[Local methodName(23261):String:String]
						[Case:String]
							[Const:String] "atom"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.atom requires exactly one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		":$s";	
	case _:
		var atomName = compiler.compileExpression(args[0]);
		":${atomName}";	
})
												[Block:String]
													[Var `(23365):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23365):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 0
														[Then:String] [Block:String]
															[Var `(23366):haxe.macro.TConstant]
																[EnumParameter:haxe.macro.TConstant]
																	[Local `(23365):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TConst
																	0
															[If:String]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(23366):haxe.macro.TConstant:haxe.macro.TConstant]
																	==
																	[Const:Int] 2
																[Then:String] [Block:String]
																	[Var `(23367):String]
																		[EnumParameter:String]
																			[Local `(23366):haxe.macro.TConstant:haxe.macro.TConstant]
																			TString
																			0
																	[Block:String]
																		[Var s(23368):String] [Local `(23367):String:String]
																		[Block:String]
																			[Binop:String]
																				[Const:String] ":"
																				+
																				[Local s(23368):String:String]
																[Else:String] [Block:String]
																	[Var atomName(23369):Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.MethodCallCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Array:haxe.macro.TypedExpr]
																				[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																				[Const:Int] 0
																			[Const:Null<Bool>] null
																	[Binop:String]
																		[Const:String] ":"
																		+
																		[Local atomName(23369):Null<String>:Null<String>]
														[Else:String] [Block:String]
															[Var atomName(23370):Null<String>]
																[Call:Null<String>]
																	[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		[Field:reflaxe.elixir.ElixirCompiler]
																			[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																			[FInstance:reflaxe.elixir.ElixirCompiler]
																				reflaxe.elixir.helpers.MethodCallCompiler
																				compiler:reflaxe.elixir.ElixirCompiler
																		[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			reflaxe.elixir.ElixirCompiler
																			compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[Const:Null<Bool>] null
															[Binop:String]
																[Const:String] ":"
																+
																[Local atomName(23370):Null<String>:Null<String>]
						[Case:String]
							[Const:String] "code"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 0
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.code requires at least one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var codeString(23371):String]
												[Meta:String]
													:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.code first parameter must be a constant String.", args[0].pos);
		"";	
})
													[Block:String]
														[Var `(23372):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 0
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:String]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23372):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:String] [Block:String]
																[Var `(23373):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23372):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23373):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 2
																	[Then:String] [Block:String]
																		[Var `(23374):String]
																			[EnumParameter:String]
																				[Local `(23373):haxe.macro.TConstant:haxe.macro.TConstant]
																				TString
																				0
																		[Block:String]
																			[Var s(23375):String] [Local `(23374):String:String]
																			[Block:String] [Local s(23375):String:String]
																	[Else:String] [Block:String]
																		[Call:Dynamic]
																			[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																				[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					haxe.macro.Context
																					error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																			[Const:String] "elixir.Syntax.code first parameter must be a constant String."
																			[Field:haxe.macro.Position]
																				[Array:haxe.macro.TypedExpr]
																					[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[Const:Int] 0
																				[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																			[Const:Null<Int>] null
																		[Const:String] ""
															[Else:String] [Block:String]
																[Call:Dynamic]
																	[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																		[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			haxe.macro.Context
																			error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																	[Const:String] "elixir.Syntax.code first parameter must be a constant String."
																	[Field:haxe.macro.Position]
																		[Array:haxe.macro.TypedExpr]
																			[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																		[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																	[Const:Null<Int>] null
																[Const:String] ""
											[Var compiledArgs(23376):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23377):Int] [Const:Int] 1
												[Var `(23378):Int]
													[Field:Int]
														[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(23377):Int:Int]
														<
														[Local `(23378):Int:Int]
													[Block:Int]
														[Var i(23379):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(23377):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local compiledArgs(23376):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local i(23379):Int:Int]
																[Const:Null<Bool>] null
											[Var placeholderCount(23380):Array<Int>] [ArrayDecl:Array<Int>] [Const:Int] 0
											[Call:String]
												[Field:(s : String, f : (EReg -> String)) -> String]
													[New:EReg]
														EReg
														[Const:String] "{(\\d+)}"
														[Const:String] "g"
													[FInstance:(s : String, f : (EReg -> String)) -> String]
														EReg
														map:(s : String, f : (EReg -> String)) -> String
												[Local codeString(23371):String:String]
												[Function:(ereg : EReg) -> String]
													[Arg:EReg] [Local ereg(23381):EReg]
													[Block:Dynamic]
														[Var num(23382):Null<Int>]
															[Call:Null<Int>]
																[Field:(x : String) -> Null<Int>]
																	[TypeExpr Std:Class<Std>]
																	[FStatic:(x : String) -> Null<Int>]
																		Std
																		parseInt:(x : String) -> Null<Int>
																[Call:String]
																	[Field:(n : Int) -> String]
																		[Local ereg(23381):EReg:EReg]
																		[FInstance:(n : Int) -> String]
																			EReg
																			matched:(n : Int) -> String
																	[Const:Int] 1
														[If:Void]
															[Binop:Bool]
																[Binop:Bool]
																	[Local num(23382):Null<Int>:Null<Int>]
																	!=
																	[Const:Null<Int>] null
																&&
																[Binop:Bool]
																	[Local num(23382):Null<Int>:Null<Int>]
																	>=
																	[Array:Int]
																		[Local placeholderCount(23380):Array<Int>:Array<Int>]
																		[Const:Int] 0
															[Then:Int] [Block:Int]
																[Binop:Int]
																	[Array:Int]
																		[Local placeholderCount(23380):Array<Int>:Array<Int>]
																		[Const:Int] 0
																	=
																	[Binop:Int]
																		[Local num(23382):Null<Int>:Null<Int>]
																		+
																		[Const:Int] 1
														[Return:Dynamic]
															[Call:String]
																[Field:(n : Int) -> String]
																	[Local ereg(23381):EReg:EReg]
																	[FInstance:(n : Int) -> String]
																		EReg
																		matched:(n : Int) -> String
																[Const:Int] 0
											[If:Void]
												[Binop:Bool]
													[Array:Int]
														[Local placeholderCount(23380):Array<Int>:Array<Int>]
														[Const:Int] 0
													>
													[Field:Int]
														[Local compiledArgs(23376):Array<Null<String>>:Array<Null<String>>]
														[FInstance:Int]
															Array<Null<String>>
															length:Int
												[Then:Dynamic] [Block:Dynamic]
													[Call:Dynamic]
														[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
															[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
															[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																haxe.macro.Context
																error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "elixir.Syntax.code() requires "
																		+
																		[Array:Int]
																			[Local placeholderCount(23380):Array<Int>:Array<Int>]
																			[Const:Int] 0
																	+
																	[Const:String] " arguments but "
																+
																[Field:Int]
																	[Local compiledArgs(23376):Array<Null<String>>:Array<Null<String>>]
																	[FInstance:Int]
																		Array<Null<String>>
																		length:Int
															+
															[Const:String] " provided"
														[Call:haxe.macro.Position]
															[Field:() -> haxe.macro.Position]
																[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																[FStatic:() -> haxe.macro.Position]
																	haxe.macro.Context
																	currentPos:() -> haxe.macro.Position
														[Const:Null<Int>] null
											[Var result(23383):String]
												[Call:String]
													[Field:(s : String, f : (EReg -> String)) -> String]
														[New:EReg]
															EReg
															[Const:String] "{(\\d+)}"
															[Const:String] "g"
														[FInstance:(s : String, f : (EReg -> String)) -> String]
															EReg
															map:(s : String, f : (EReg -> String)) -> String
													[Local codeString(23371):String:String]
													[Function:(ereg : EReg) -> String]
														[Arg:EReg] [Local ereg(23384):EReg]
														[Block:Dynamic]
															[Var num(23385):Null<Int>]
																[Call:Null<Int>]
																	[Field:(x : String) -> Null<Int>]
																		[TypeExpr Std:Class<Std>]
																		[FStatic:(x : String) -> Null<Int>]
																			Std
																			parseInt:(x : String) -> Null<Int>
																	[Call:String]
																		[Field:(n : Int) -> String]
																			[Local ereg(23384):EReg:EReg]
																			[FInstance:(n : Int) -> String]
																				EReg
																				matched:(n : Int) -> String
																		[Const:Int] 1
															[Return:Dynamic]
																[If:String]
																	[Parenthesis:Bool]
																		[Binop:Bool]
																			[Binop:Bool]
																				[Local num(23385):Null<Int>:Null<Int>]
																				!=
																				[Const:Null<Int>] null
																			&&
																			[Binop:Bool]
																				[Local num(23385):Null<Int>:Null<Int>]
																				<
																				[Field:Int]
																					[Local compiledArgs(23376):Array<Null<String>>:Array<Null<String>>]
																					[FInstance:Int]
																						Array<Null<String>>
																						length:Int
																	[Then:Null<String>] [Block:Null<String>]
																		[Array:Null<String>]
																			[Local compiledArgs(23376):Array<Null<String>>:Array<Null<String>>]
																			[Local num(23385):Null<Int>:Null<Int>]
																	[Else:String] [Block:String]
																		[Call:String]
																			[Field:(n : Int) -> String]
																				[Local ereg(23384):EReg:EReg]
																				[FInstance:(n : Int) -> String]
																					EReg
																					matched:(n : Int) -> String
																			[Const:Int] 0
											[Return:String] [Local result(23383):String:String]
						[Case:String]
							[Const:String] "keyword"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.keyword requires exactly one Array argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TArrayDecl(elements):
		if (elements.length % 2 != 0) {
			Context.error("elixir.Syntax.keyword array must have an even number of elements (key-value pairs).", args[0].pos);
			"";
		} else {
			var pairs = [];
			var i = 0;
			while (i < elements.length) {
				var key = compiler.compileExpression(elements[i]);
				var value = compiler.compileExpression(elements[i + 1]);
				pairs.push("${key}: ${value}");
				i += 2;
			};
			"[${pairs.join(\", \")}]";
		};	
	case _:
		Context.error("elixir.Syntax.keyword parameter must be an array literal.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23386):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:String] [Block:String]
															[Var `(23387):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(23386):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[Block:String]
																[Var elements(23388):Array<haxe.macro.TypedExpr>] [Local `(23387):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Block:String]
																	[If:String]
																		[Binop:Bool]
																			[Binop:Int]
																				[Field:Int]
																					[Local elements(23388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																				%
																				[Const:Int] 2
																			!=
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Call:Dynamic]
																				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																						haxe.macro.Context
																						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																				[Const:String] "elixir.Syntax.keyword array must have an even number of elements (key-value pairs)."
																				[Field:haxe.macro.Position]
																					[Array:haxe.macro.TypedExpr]
																						[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Const:Int] 0
																					[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																				[Const:Null<Int>] null
																			[Const:String] ""
																		[Else:String] [Block:String]
																			[Var pairs(23389):Array<String>] [ArrayDecl:Array<String>]
																			[Var i(23390):Int] [Const:Int] 0
																			[While:Void]
																				[Binop:Bool]
																					[Local i(23390):Int:Int]
																					<
																					[Field:Int]
																						[Local elements(23388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[FInstance:Int]
																							Array<haxe.macro.TypedExpr>
																							length:Int
																				[Block:Int]
																					[Var key(23391):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Local i(23390):Int:Int]
																							[Const:Null<Bool>] null
																					[Var value(23392):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23388):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Binop:Int]
																									[Local i(23390):Int:Int]
																									+
																									[Const:Int] 1
																							[Const:Null<Bool>] null
																					[Call:Int]
																						[Field:(x : String) -> Int]
																							[Local pairs(23389):Array<String>:Array<String>]
																							[FInstance:(x : String) -> Int]
																								Array<String>
																								push:(x : Array.T) -> Int
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Local key(23391):Null<String>:Null<String>]
																								+
																								[Const:String] ": "
																							+
																							[Local value(23392):Null<String>:Null<String>]
																					[Binop:Int]
																						[Local i(23390):Int:Int]
																						+=
																						[Const:Int] 2
																			[Binop:String]
																				[Binop:String]
																					[Const:String] "["
																					+
																					[Call:String]
																						[Field:(sep : String) -> String]
																							[Local pairs(23389):Array<String>:Array<String>]
																							[FInstance:(sep : String) -> String]
																								Array<String>
																								join:(sep : String) -> String
																						[Const:String] ", "
																				+
																				[Const:String] "]"
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.keyword parameter must be an array literal."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "list"
							[Block:String]
								[Block:String]
									[Var compiledArgs(23393):Array<Null<String>>]
										[Block:Array<Null<String>>]
											[Var `(23394):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23395):Int] [Const:Int] 0
												[Var `(23396):Array<haxe.macro.TypedExpr>] [Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[While:Void]
													[Binop:Bool]
														[Local `(23395):Int:Int]
														<
														[Field:Int]
															[Local `(23396):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var v(23397):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local `(23396):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(23395):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(23395):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local `(23394):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																	[Arg:haxe.macro.TypedExpr] [Local arg(23398):haxe.macro.TypedExpr]
																	[Block:Dynamic]
																		[Return:Dynamic]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Local `this(23302):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.MethodCallCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local arg(23398):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
																[Local v(23397):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local `(23394):Array<Null<String>>:Array<Null<String>>]
									[Binop:String]
										[Binop:String]
											[Const:String] "["
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(23393):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] "]"
						[Case:String]
							[Const:String] "map"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.map requires exactly one Array argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TArrayDecl(elements):
		if (elements.length % 2 != 0) {
			Context.error("elixir.Syntax.map array must have an even number of elements (key-value pairs).", args[0].pos);
			"";
		} else {
			var pairs = [];
			var i = 0;
			while (i < elements.length) {
				var key = compiler.compileExpression(elements[i]);
				var value = compiler.compileExpression(elements[i + 1]);
				pairs.push("${key} => ${value}");
				i += 2;
			};
			"%{${pairs.join(\", \")}}";
		};	
	case _:
		Context.error("elixir.Syntax.map parameter must be an array literal.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23399):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23399):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:String] [Block:String]
															[Var `(23400):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(23399):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[Block:String]
																[Var elements(23401):Array<haxe.macro.TypedExpr>] [Local `(23400):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Block:String]
																	[If:String]
																		[Binop:Bool]
																			[Binop:Int]
																				[Field:Int]
																					[Local elements(23401):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																				%
																				[Const:Int] 2
																			!=
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Call:Dynamic]
																				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																						haxe.macro.Context
																						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																				[Const:String] "elixir.Syntax.map array must have an even number of elements (key-value pairs)."
																				[Field:haxe.macro.Position]
																					[Array:haxe.macro.TypedExpr]
																						[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Const:Int] 0
																					[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																				[Const:Null<Int>] null
																			[Const:String] ""
																		[Else:String] [Block:String]
																			[Var pairs(23402):Array<String>] [ArrayDecl:Array<String>]
																			[Var i(23403):Int] [Const:Int] 0
																			[While:Void]
																				[Binop:Bool]
																					[Local i(23403):Int:Int]
																					<
																					[Field:Int]
																						[Local elements(23401):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[FInstance:Int]
																							Array<haxe.macro.TypedExpr>
																							length:Int
																				[Block:Int]
																					[Var key(23404):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23401):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Local i(23403):Int:Int]
																							[Const:Null<Bool>] null
																					[Var value(23405):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23401):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Binop:Int]
																									[Local i(23403):Int:Int]
																									+
																									[Const:Int] 1
																							[Const:Null<Bool>] null
																					[Call:Int]
																						[Field:(x : String) -> Int]
																							[Local pairs(23402):Array<String>:Array<String>]
																							[FInstance:(x : String) -> Int]
																								Array<String>
																								push:(x : Array.T) -> Int
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Local key(23404):Null<String>:Null<String>]
																								+
																								[Const:String] " => "
																							+
																							[Local value(23405):Null<String>:Null<String>]
																					[Binop:Int]
																						[Local i(23403):Int:Int]
																						+=
																						[Const:Int] 2
																			[Binop:String]
																				[Binop:String]
																					[Const:String] "%{"
																					+
																					[Call:String]
																						[Field:(sep : String) -> String]
																							[Local pairs(23402):Array<String>:Array<String>]
																							[FInstance:(sep : String) -> String]
																								Array<String>
																								join:(sep : String) -> String
																						[Const:String] ", "
																				+
																				[Const:String] "}"
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.map parameter must be an array literal."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "match"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.match requires exactly two arguments (value and patterns)."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var value(23406):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var patterns(23407):String]
												[Meta:String]
													:ast(switch (args[1].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.match patterns must be a constant String.", args[1].pos);
		"";	
})
													[Block:String]
														[Var `(23408):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 1
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:String]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23408):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:String] [Block:String]
																[Var `(23409):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23408):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23409):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 2
																	[Then:String] [Block:String]
																		[Var `(23410):String]
																			[EnumParameter:String]
																				[Local `(23409):haxe.macro.TConstant:haxe.macro.TConstant]
																				TString
																				0
																		[Block:String]
																			[Var s(23411):String] [Local `(23410):String:String]
																			[Block:String] [Local s(23411):String:String]
																	[Else:String] [Block:String]
																		[Call:Dynamic]
																			[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																				[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					haxe.macro.Context
																					error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																			[Const:String] "elixir.Syntax.match patterns must be a constant String."
																			[Field:haxe.macro.Position]
																				[Array:haxe.macro.TypedExpr]
																					[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[Const:Int] 1
																				[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																			[Const:Null<Int>] null
																		[Const:String] ""
															[Else:String] [Block:String]
																[Call:Dynamic]
																	[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																		[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			haxe.macro.Context
																			error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																	[Const:String] "elixir.Syntax.match patterns must be a constant String."
																	[Field:haxe.macro.Position]
																		[Array:haxe.macro.TypedExpr]
																			[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 1
																		[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																	[Const:Null<Int>] null
																[Const:String] ""
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "case "
															+
															[Local value(23406):Null<String>:Null<String>]
														+
														[Const:String] " do\n  "
													+
													[Call:String]
														[Field:(s : String, sub : String, by : String) -> String]
															[TypeExpr StringTools:Class<StringTools>]
															[FStatic:(s : String, sub : String, by : String) -> String]
																StringTools
																replace:(s : String, sub : String, by : String) -> String
														[Local patterns(23407):String:String]
														[Const:String] "\n"
														[Const:String] "\n  "
												+
												[Const:String] "\nend"
						[Case:String]
							[Const:String] "pipe"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											<
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.pipe requires at least two arguments (initial value and operations)."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var initial(23412):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var operations(23413):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23414):Int] [Const:Int] 1
												[Var `(23415):Int]
													[Field:Int]
														[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(23414):Int:Int]
														<
														[Local `(23415):Int:Int]
													[Block:Int]
														[Var i(23416):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(23414):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local operations(23413):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local i(23416):Int:Int]
																[Const:Null<Bool>] null
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local initial(23412):Null<String>:Null<String>]
													+
													[Const:String] " |> "
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local operations(23413):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(sep : String) -> String]
															Array<Null<String>>
															join:(sep : String) -> String
													[Const:String] " |> "
						[Case:String]
							[Const:String] "plainCode"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.plainCode requires exactly one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.plainCode parameter must be a constant String.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23417):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23417):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 0
														[Then:String] [Block:String]
															[Var `(23418):haxe.macro.TConstant]
																[EnumParameter:haxe.macro.TConstant]
																	[Local `(23417):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TConst
																	0
															[If:String]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(23418):haxe.macro.TConstant:haxe.macro.TConstant]
																	==
																	[Const:Int] 2
																[Then:String] [Block:String]
																	[Var `(23419):String]
																		[EnumParameter:String]
																			[Local `(23418):haxe.macro.TConstant:haxe.macro.TConstant]
																			TString
																			0
																	[Block:String]
																		[Var s(23420):String] [Local `(23419):String:String]
																		[Block:String] [Local s(23420):String:String]
																[Else:String] [Block:String]
																	[Call:Dynamic]
																		[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																			[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				haxe.macro.Context
																				error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																		[Const:String] "elixir.Syntax.plainCode parameter must be a constant String."
																		[Field:haxe.macro.Position]
																			[Array:haxe.macro.TypedExpr]
																				[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																				[Const:Int] 0
																			[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																		[Const:Null<Int>] null
																	[Const:String] ""
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.plainCode parameter must be a constant String."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "tuple"
							[Block:String]
								[Block:String]
									[Var compiledArgs(23421):Array<Null<String>>]
										[Block:Array<Null<String>>]
											[Var `(23422):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23423):Int] [Const:Int] 0
												[Var `(23424):Array<haxe.macro.TypedExpr>] [Local args(23262):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[While:Void]
													[Binop:Bool]
														[Local `(23423):Int:Int]
														<
														[Field:Int]
															[Local `(23424):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var v(23425):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local `(23424):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(23423):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(23423):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local `(23422):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																	[Arg:haxe.macro.TypedExpr] [Local arg(23426):haxe.macro.TypedExpr]
																	[Block:Dynamic]
																		[Return:Dynamic]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Local `this(23302):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.MethodCallCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local arg(23426):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
																[Local v(23425):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local `(23422):Array<Null<String>>:Array<Null<String>>]
									[Binop:String]
										[Binop:String]
											[Const:String] "{"
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(23421):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] "}"
						[Default:String]
							[Block:String]
								[Call:Dynamic]
									[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
										[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
										[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
											haxe.macro.Context
											error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
									[Binop:String]
										[Const:String] "Unknown elixir.Syntax method: "
										+
										[Local methodName(23261):String:String]
									[Call:haxe.macro.Position]
										[Field:() -> haxe.macro.Position]
											[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
											[FStatic:() -> haxe.macro.Position]
												haxe.macro.Context
												currentPos:() -> haxe.macro.Position
									[Const:Null<Int>] null
								[Const:String] ""

	public function isTypeSafeChildSpecCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(23427):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(23428):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TTypeExpr(moduleType):
		switch (moduleType) {
			case TEnumDecl(enumRef):
				var enumType = enumRef.get();
				return enumType.name == "TypeSafeChildSpec" && enumType.pack.join(".") == "elixir.otp";			
			case _:
				return false;			
		};	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(23438):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(23427):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23438):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 5
						[Then:Void] [Block:Void]
							[Var `(23439):haxe.macro.ModuleType]
								[EnumParameter:haxe.macro.ModuleType]
									[Local `(23438):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TTypeExpr
									0
							[Block:Void]
								[Var moduleType(23440):haxe.macro.ModuleType] [Local `(23439):haxe.macro.ModuleType:haxe.macro.ModuleType]
								[Block:Void]
									[Meta:Void]
										:ast(switch (moduleType) {
	case TEnumDecl(enumRef):
		var enumType = enumRef.get();
		return enumType.name == "TypeSafeChildSpec" && enumType.pack.join(".") == "elixir.otp";	
	case _:
		return false;	
})
										[If:Void]
											[Binop:Bool]
												[EnumIndex:Int] [Local moduleType(23440):haxe.macro.ModuleType:haxe.macro.ModuleType]
												==
												[Const:Int] 1
											[Then:Dynamic] [Block:Dynamic]
												[Var `(23441):haxe.macro.Ref<haxe.macro.EnumType>]
													[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
														[Local moduleType(23440):haxe.macro.ModuleType:haxe.macro.ModuleType]
														TEnumDecl
														0
												[Block:Dynamic]
													[Var enumRef(23442):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(23441):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
													[Block:Dynamic]
														[Var enumType(23443):haxe.macro.EnumType]
															[Call:haxe.macro.EnumType]
																[Field:() -> haxe.macro.EnumType]
																	[Local enumRef(23442):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
																	[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
														[Return:Dynamic]
															[Binop:Bool]
																[Binop:Bool]
																	[Field:String]
																		[Local enumType(23443):haxe.macro.EnumType:haxe.macro.EnumType]
																		[FAnon:String] name:String
																	==
																	[Const:String] "TypeSafeChildSpec"
																&&
																[Binop:Bool]
																	[Call:String]
																		[Field:(sep : String) -> String]
																			[Field:Array<String>]
																				[Local enumType(23443):haxe.macro.EnumType:haxe.macro.EnumType]
																				[FAnon:Array<String>] pack:Array<String>
																			[FInstance:(sep : String) -> String]
																				Array<String>
																				join:(sep : String) -> String
																		[Const:String] "."
																	==
																	[Const:String] "elixir.otp"
											[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
						[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	public function compileTypeSafeChildSpecCall[Function:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local fieldName(23444):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23445):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23450):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var appName(23446):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.AnnotationSystem
							getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
					[Field:Null<haxe.macro.ClassType>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (fieldName) {
	case "PubSub":
		if (args.length == 1) {
			var nameArg = compiler.compileExpression(args[0]);
			var cleanName = if (nameArg.indexOf("<>") >= 0) {
				nameArg;
			} else {
				StringTools.replace(nameArg, "\"", "");
			};
			"{Phoenix.PubSub, name: ${cleanName}}";
		} else {
			"{Phoenix.PubSub, name: ${appName}.PubSub}";
		};	
	case "Repo":
		"${appName}.Repo";	
	case "Endpoint":
		"${appName}Web.Endpoint";	
	case "Telemetry":
		"${appName}Web.Telemetry";	
	case _:
		if (args.length == 0) {
			":${reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName)}";
		} else {
			var argList = args.map(function(arg) return compiler.compileExpression(arg)).join(", ");
			"{:${reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName)}, ${argList}}";
		};	
})
					[Switch:String]
						[Local fieldName(23444):String:String]
						[Case:String]
							[Const:String] "Endpoint"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23446):String:String]
										+
										[Const:String] "Web.Endpoint"
						[Case:String]
							[Const:String] "PubSub"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23445):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 1
										[Then:String] [Block:String]
											[Var nameArg(23460):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23445):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var cleanName(23461):Null<String>]
												[If:Null<String>]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local nameArg(23460):Null<String>:Null<String>]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "<>"
															[Const:Null<Int>] null
														>=
														[Const:Int] 0
													[Then:Null<String>] [Block:Null<String>] [Local nameArg(23460):Null<String>:Null<String>]
													[Else:String] [Block:String]
														[Call:String]
															[Field:(s : String, sub : String, by : String) -> String]
																[TypeExpr StringTools:Class<StringTools>]
																[FStatic:(s : String, sub : String, by : String) -> String]
																	StringTools
																	replace:(s : String, sub : String, by : String) -> String
															[Local nameArg(23460):Null<String>:Null<String>]
															[Const:String] "\""
															[Const:String] ""
											[Binop:String]
												[Binop:String]
													[Const:String] "{Phoenix.PubSub, name: "
													+
													[Local cleanName(23461):Null<String>:Null<String>]
												+
												[Const:String] "}"
										[Else:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "{Phoenix.PubSub, name: "
													+
													[Local appName(23446):String:String]
												+
												[Const:String] ".PubSub}"
						[Case:String]
							[Const:String] "Repo"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23446):String:String]
										+
										[Const:String] ".Repo"
						[Case:String]
							[Const:String] "Telemetry"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23446):String:String]
										+
										[Const:String] "Web.Telemetry"
						[Default:String]
							[Block:String]
								[If:String]
									[Binop:Bool]
										[Field:Int]
											[Local args(23445):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
										==
										[Const:Int] 0
									[Then:String] [Block:String]
										[Binop:String]
											[Const:String] ":"
											+
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Local fieldName(23444):String:String]
									[Else:String] [Block:String]
										[Var argList(23462):String]
											[Call:String]
												[Field:(sep : String) -> String]
													[Block:Array<Null<String>>]
														[Var `(23463):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
														[Block:Void]
															[Var `(23464):Int] [Const:Int] 0
															[Var `(23465):Array<haxe.macro.TypedExpr>] [Local args(23445):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[While:Void]
																[Binop:Bool]
																	[Local `(23464):Int:Int]
																	<
																	[Field:Int]
																		[Local `(23465):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																[Block:Void]
																	[Var v(23466):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(23465):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Local `(23464):Int:Int]
																	[Unop:Int]
																		++
																		Prefix
																		[Local `(23464):Int:Int]
																	[Call:Int]
																		[Field:(x : Null<String>) -> Int]
																			[Local `(23463):Array<Null<String>>:Array<Null<String>>]
																			[FInstance:(x : Null<String>) -> Int]
																				Array<Null<String>>
																				push:(x : Array.T) -> Int
																		[Call:Null<String>]
																			[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																				[Arg:haxe.macro.TypedExpr] [Local arg(23467):haxe.macro.TypedExpr]
																				[Block:Dynamic]
																					[Return:Dynamic]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Local `this(23450):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Local arg(23467):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Const:Null<Bool>] null
																			[Local v(23466):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local `(23463):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "{:"
														+
														[Call:String]
															[Field:(camelCase : String) -> String]
																[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																[FStatic:(camelCase : String) -> String]
																	reflaxe.elixir.helpers.NamingHelper
																	toSnakeCase:(camelCase : String) -> String
															[Local fieldName(23444):String:String]
													+
													[Const:String] ", "
												+
												[Local argList(23462):String:String]
											+
											[Const:String] "}"

	public function isElixirSyntaxCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(23229):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(23230):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TTypeExpr(moduleType):
		switch (moduleType) {
			case TClassDecl(c):
				var classRef = c.get();
				var fullPath = classRef.pack.join(".") + (classRef.pack.length > 0 ? "." : "") + classRef.name;
				return fullPath == "elixir.Syntax";			
			case TTypeDecl(t):
				var typeRef = t.get();
				var fullPath = typeRef.pack.join(".") + (typeRef.pack.length > 0 ? "." : "") + typeRef.name;
				return fullPath == "elixir.Syntax";			
			case _:
				return false;			
		};	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(23250):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(23229):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23250):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 5
						[Then:Void] [Block:Void]
							[Var `(23251):haxe.macro.ModuleType]
								[EnumParameter:haxe.macro.ModuleType]
									[Local `(23250):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TTypeExpr
									0
							[Block:Void]
								[Var moduleType(23252):haxe.macro.ModuleType] [Local `(23251):haxe.macro.ModuleType:haxe.macro.ModuleType]
								[Block:Void]
									[Meta:Void]
										:ast(switch (moduleType) {
	case TClassDecl(c):
		var classRef = c.get();
		var fullPath = classRef.pack.join(".") + (classRef.pack.length > 0 ? "." : "") + classRef.name;
		return fullPath == "elixir.Syntax";	
	case TTypeDecl(t):
		var typeRef = t.get();
		var fullPath = typeRef.pack.join(".") + (typeRef.pack.length > 0 ? "." : "") + typeRef.name;
		return fullPath == "elixir.Syntax";	
	case _:
		return false;	
})
										[Switch:Void]
											[EnumIndex:Int] [Local moduleType(23252):haxe.macro.ModuleType:haxe.macro.ModuleType]
											[Case:Dynamic]
												[Const:Int] 0
												[Block:Dynamic]
													[Var `(23253):haxe.macro.Ref<haxe.macro.ClassType>]
														[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
															[Local moduleType(23252):haxe.macro.ModuleType:haxe.macro.ModuleType]
															TClassDecl
															0
													[Block:Dynamic]
														[Var c(23254):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(23253):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
														[Block:Dynamic]
															[Var classRef(23255):haxe.macro.ClassType]
																[Call:haxe.macro.ClassType]
																	[Field:() -> haxe.macro.ClassType]
																		[Local c(23254):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
																		[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
															[Var fullPath(23256):String]
																[Binop:String]
																	[Binop:String]
																		[Call:String]
																			[Field:(sep : String) -> String]
																				[Field:Array<String>]
																					[Local classRef(23255):haxe.macro.ClassType:haxe.macro.ClassType]
																					[FAnon:Array<String>] pack:Array<String>
																				[FInstance:(sep : String) -> String]
																					Array<String>
																					join:(sep : String) -> String
																			[Const:String] "."
																		+
																		[Parenthesis:String]
																			[If:String]
																				[Binop:Bool]
																					[Field:Int]
																						[Field:Array<String>]
																							[Local classRef(23255):haxe.macro.ClassType:haxe.macro.ClassType]
																							[FAnon:Array<String>] pack:Array<String>
																						[FInstance:Int]
																							Array<String>
																							length:Int
																					>
																					[Const:Int] 0
																				[Then:String] [Block:String] [Const:String] "."
																				[Else:String] [Block:String] [Const:String] ""
																	+
																	[Field:String]
																		[Local classRef(23255):haxe.macro.ClassType:haxe.macro.ClassType]
																		[FAnon:String] name:String
															[Return:Dynamic]
																[Binop:Bool]
																	[Local fullPath(23256):String:String]
																	==
																	[Const:String] "elixir.Syntax"
											[Case:Dynamic]
												[Const:Int] 2
												[Block:Dynamic]
													[Var `(23257):haxe.macro.Ref<haxe.macro.DefType>]
														[EnumParameter:haxe.macro.Ref<haxe.macro.DefType>]
															[Local moduleType(23252):haxe.macro.ModuleType:haxe.macro.ModuleType]
															TTypeDecl
															0
													[Block:Dynamic]
														[Var t(23258):haxe.macro.Ref<haxe.macro.DefType>] [Local `(23257):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
														[Block:Dynamic]
															[Var typeRef(23259):haxe.macro.DefType]
																[Call:haxe.macro.DefType]
																	[Field:() -> haxe.macro.DefType]
																		[Local t(23258):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
																		[FAnon:() -> haxe.macro.DefType] get:() -> haxe.macro.DefType
															[Var fullPath(23260):String]
																[Binop:String]
																	[Binop:String]
																		[Call:String]
																			[Field:(sep : String) -> String]
																				[Field:Array<String>]
																					[Local typeRef(23259):haxe.macro.DefType:haxe.macro.DefType]
																					[FAnon:Array<String>] pack:Array<String>
																				[FInstance:(sep : String) -> String]
																					Array<String>
																					join:(sep : String) -> String
																			[Const:String] "."
																		+
																		[Parenthesis:String]
																			[If:String]
																				[Binop:Bool]
																					[Field:Int]
																						[Field:Array<String>]
																							[Local typeRef(23259):haxe.macro.DefType:haxe.macro.DefType]
																							[FAnon:Array<String>] pack:Array<String>
																						[FInstance:Int]
																							Array<String>
																							length:Int
																					>
																					[Const:Int] 0
																				[Then:String] [Block:String] [Const:String] "."
																				[Else:String] [Block:String] [Const:String] ""
																	+
																	[Field:String]
																		[Local typeRef(23259):haxe.macro.DefType:haxe.macro.DefType]
																		[FAnon:String] name:String
															[Return:Dynamic]
																[Binop:Bool]
																	[Local fullPath(23260):String:String]
																	==
																	[Const:String] "elixir.Syntax"
											[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
						[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function isStructMethodCall[Function:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(22257):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(22258):haxe.macro.FieldAccess]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TLocal(_):
		return true;	
	case TField(_, _):
		return true;	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(22263):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(22257):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(22263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 1
							[Block:Dynamic]
								[Var `(22264):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(22263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Case:Dynamic]
							[Const:Int] 4
							[Block:Dynamic]
								[Var `(22265):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(22266):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(22263):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function isMutatingStructMethod[Function:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(22267):haxe.macro.TypedExpr]
		[Arg:String] [Local methodName(22268):String]
		[Block:Dynamic]
			[Var mutatingPatterns(22269):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "write"
					[Const:String] "add"
					[Const:String] "push"
					[Const:String] "pop"
					[Const:String] "remove"
					[Const:String] "clear"
					[Const:String] "set"
					[Const:String] "update"
					[Const:String] "append"
					[Const:String] "prepend"
					[Const:String] "insert"
					[Const:String] "delete"
					[Const:String] "merge"
					[Const:String] "replace"
					[Const:String] "quote_"
					[Const:String] "fields_string"
					[Const:String] "class_string"
			[Block:Void]
				[Var `(22271):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(22271):Int:Int]
						<
						[Field:Int]
							[Local mutatingPatterns(22269):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var pattern(22270):String]
							[Array:String]
								[Local mutatingPatterns(22269):Array<String>:Array<String>]
								[Local `(22271):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(22271):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local methodName(22268):String:String]
									==
									[Local pattern(22270):String:String]
								||
								[Binop:Bool]
									[Call:Int]
										[Field:(str : String, ?startIndex : Null<Int>) -> Int]
											[Local methodName(22268):String:String]
											[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
												String
												indexOf:(str : String, ?startIndex : Null<Int>) -> Int
										[Local pattern(22270):String:String]
										[Const:Null<Int>] null
									==
									[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false
}