class reflaxe.elixir.helpers.EctoErrorReporter {

	@:value([{ pattern : "Unknown field .* in schema", solution : "Check that the field exists in your schema definition. Did you mean to add it with @:field annotation?", docs : "See documentation/ANNOTATIONS.md#field-annotation" }, { pattern : "Invalid association type", solution : "Association must be one of: has_one, has_many, belongs_to, many_to_many", docs : "See documentation/guides/ADVANCED_ECTO_GUIDE.md#associations" }, { pattern : "Missing required changeset function", solution : "Classes with @:changeset must have a static changeset function", docs : "See documentation/guides/ADVANCED_ECTO_GUIDE.md#changesets" }, { pattern : "Invalid field type", solution : "Field types must be valid Ecto types: string, integer, boolean, date, datetime, etc.", docs : "See documentation/guides/ADVANCED_ECTO_GUIDE.md#field-types" }, { pattern : "Circular association detected", solution : "Schema has circular associations. Consider using :on_replace option or restructuring associations", docs : "See Ecto documentation on association cycles" }, { pattern : "Reserved keyword in metadata", solution : "Cannot use Haxe reserved keywords (default, interface, operator) in metadata. Use alternatives like 'defaultValue'", docs : "See documentation/TESTING_PRINCIPLES.md#simplification-principle" }])
	static var ERROR_PATTERNS(default,never):Array<{ solution : String, pattern : String, docs : String }> = [ArrayDecl:Array<{ solution : String, pattern : String, docs : String }>]
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Unknown field .* in schema"
			solution: [Const:String] "Check that the field exists in your schema definition. Did you mean to add it with @:field annotation?"
			docs: [Const:String] "See documentation/ANNOTATIONS.md#field-annotation"
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Invalid association type"
			solution: [Const:String] "Association must be one of: has_one, has_many, belongs_to, many_to_many"
			docs: [Const:String] "See documentation/guides/ADVANCED_ECTO_GUIDE.md#associations"
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Missing required changeset function"
			solution: [Const:String] "Classes with @:changeset must have a static changeset function"
			docs: [Const:String] "See documentation/guides/ADVANCED_ECTO_GUIDE.md#changesets"
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Invalid field type"
			solution: [Const:String] "Field types must be valid Ecto types: string, integer, boolean, date, datetime, etc."
			docs: [Const:String] "See documentation/guides/ADVANCED_ECTO_GUIDE.md#field-types"
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Circular association detected"
			solution: [Const:String] "Schema has circular associations. Consider using :on_replace option or restructuring associations"
			docs: [Const:String] "See Ecto documentation on association cycles"
		[ObjectDecl:{ solution : String, pattern : String, docs : String }]
			pattern: [Const:String] "Reserved keyword in metadata"
			solution: [Const:String] "Cannot use Haxe reserved keywords (default, interface, operator) in metadata. Use alternatives like 'defaultValue'"
			docs: [Const:String] "See documentation/TESTING_PRINCIPLES.md#simplification-principle";

	public static function reportSchemaError[Function:(schemaName : String, error : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local schemaName(26212):String]
		[Arg:String] [Local error(26213):String]
		[Arg:haxe.macro.Position] [Local pos(26214):haxe.macro.Position]
		[Block:Dynamic]
			[Var message(26217):String]
				[Call:String]
					[Field:(schemaName : String, error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(schemaName : String, error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							formatSchemaError:(schemaName : String, error : String) -> String
					[Local schemaName(26212):String:String]
					[Local error(26213):String:String]
			[Var suggestion(26226):String]
				[Call:String]
					[Field:(error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getSuggestion:(error : String) -> String
					[Local error(26213):String:String]
			[Var fullMessage(26227):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local message(26217):String:String]
						+
						[Const:String] "\n"
					+
					[Local suggestion(26226):String:String]
			[Call:Dynamic]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
						haxe.macro.Context
						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
				[Local fullMessage(26227):String:String]
				[Local pos(26214):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function reportChangesetError[Function:(className : String, error : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local className(26228):String]
		[Arg:String] [Local error(26229):String]
		[Arg:haxe.macro.Position] [Local pos(26230):haxe.macro.Position]
		[Block:Dynamic]
			[Var message(26231):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Changeset error in "
							+
							[Local className(26228):String:String]
						+
						[Const:String] ": "
					+
					[Local error(26229):String:String]
			[Var suggestion(26245):String]
				[Call:String]
					[Field:(error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getChangesetSuggestion:(error : String) -> String
					[Local error(26229):String:String]
			[Var example(26246):String]
				[Call:String]
					[Field:() -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:() -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getChangesetExample:() -> String
			[Var fullMessage(26247):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local message(26231):String:String]
								+
								[Const:String] "\n"
							+
							[Local suggestion(26245):String:String]
						+
						[Const:String] "\n\nExample:\n"
					+
					[Local example(26246):String:String]
			[Call:Dynamic]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
						haxe.macro.Context
						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
				[Local fullMessage(26247):String:String]
				[Local pos(26230):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function reportQueryError[Function:(queryExpr : String, error : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local queryExpr(26248):String]
		[Arg:String] [Local error(26249):String]
		[Arg:haxe.macro.Position] [Local pos(26250):haxe.macro.Position]
		[Block:Dynamic]
			[Var message(26251):String]
				[Binop:String]
					[Const:String] "Query compilation failed: "
					+
					[Local error(26249):String:String]
			[Var suggestion(26266):String]
				[Call:String]
					[Field:(queryExpr : String, error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(queryExpr : String, error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getQuerySuggestion:(queryExpr : String, error : String) -> String
					[Local queryExpr(26248):String:String]
					[Local error(26249):String:String]
			[Var alternatives(26277):Array<String>]
				[Call:Array<String>]
					[Field:(queryExpr : String) -> Array<String>]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(queryExpr : String) -> Array<String>]
							reflaxe.elixir.helpers.EctoErrorReporter
							getQueryAlternatives:(queryExpr : String) -> Array<String>
					[Local queryExpr(26248):String:String]
			[Var fullMessage(26278):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local message(26251):String:String]
						+
						[Const:String] "\n"
					+
					[Local suggestion(26266):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local alternatives(26277):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:String] [Block:String]
					[Binop:String]
						[Local fullMessage(26278):String:String]
						+=
						[Binop:String]
							[Const:String] "\n\nAlternatives:\n"
							+
							[Call:String]
								[Field:(sep : String) -> String]
									[Local alternatives(26277):Array<String>:Array<String>]
									[FInstance:(sep : String) -> String]
										Array<String>
										join:(sep : String) -> String
								[Const:String] "\n"
			[Call:Dynamic]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
						haxe.macro.Context
						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
				[Local fullMessage(26278):String:String]
				[Local pos(26250):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function reportMigrationError[Function:(operation : String, error : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local operation(26279):String]
		[Arg:String] [Local error(26280):String]
		[Arg:haxe.macro.Position] [Local pos(26281):haxe.macro.Position]
		[Block:Dynamic]
			[Var message(26282):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Migration error in "
							+
							[Local operation(26279):String:String]
						+
						[Const:String] ": "
					+
					[Local error(26280):String:String]
			[Var suggestion(26285):String]
				[Call:String]
					[Field:(operation : String, error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(operation : String, error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getMigrationSuggestion:(operation : String, error : String) -> String
					[Local operation(26279):String:String]
					[Local error(26280):String:String]
			[Var example(26287):String]
				[Call:String]
					[Field:(operation : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(operation : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getMigrationExample:(operation : String) -> String
					[Local operation(26279):String:String]
			[Var fullMessage(26288):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local message(26282):String:String]
								+
								[Const:String] "\n"
							+
							[Local suggestion(26285):String:String]
						+
						[Const:String] "\n\nCorrect usage:\n"
					+
					[Local example(26287):String:String]
			[Call:Dynamic]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
						haxe.macro.Context
						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
				[Local fullMessage(26288):String:String]
				[Local pos(26281):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function reportAssociationError[Function:(field : String, assocType : String, error : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local field(26289):String]
		[Arg:String] [Local assocType(26290):String]
		[Arg:String] [Local error(26291):String]
		[Arg:haxe.macro.Position] [Local pos(26292):haxe.macro.Position]
		[Block:Dynamic]
			[Var message(26293):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] "Association error for field \""
									+
									[Local field(26289):String:String]
								+
								[Const:String] "\" ("
							+
							[Local assocType(26290):String:String]
						+
						[Const:String] "): "
					+
					[Local error(26291):String:String]
			[Var suggestion(26296):String]
				[Call:String]
					[Field:(assocType : String, error : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(assocType : String, error : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getAssociationSuggestion:(assocType : String, error : String) -> String
					[Local assocType(26290):String:String]
					[Local error(26291):String:String]
			[Var requirements(26298):String]
				[Call:String]
					[Field:(assocType : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:(assocType : String) -> String]
							reflaxe.elixir.helpers.EctoErrorReporter
							getAssociationRequirements:(assocType : String) -> String
					[Local assocType(26290):String:String]
			[Var fullMessage(26299):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local message(26293):String:String]
								+
								[Const:String] "\n"
							+
							[Local suggestion(26296):String:String]
						+
						[Const:String] "\n\nRequirements:\n"
					+
					[Local requirements(26298):String:String]
			[Call:Dynamic]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
						haxe.macro.Context
						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
				[Local fullMessage(26299):String:String]
				[Local pos(26292):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function warnAboutPattern[Function:(pattern : String, suggestion : String, pos : haxe.macro.Position) -> Void]
		[Arg:String] [Local pattern(26300):String]
		[Arg:String] [Local suggestion(26301):String]
		[Arg:haxe.macro.Position] [Local pos(26302):haxe.macro.Position]
		[Block:Void]
			[Var message(26303):String]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Warning: "
							+
							[Local pattern(26300):String:String]
						+
						[Const:String] "\nSuggestion: "
					+
					[Local suggestion(26301):String:String]
			[Call:Void]
				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void]
					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void]
						haxe.macro.Context
						warning:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void
				[Local message(26303):String:String]
				[Local pos(26302):haxe.macro.Position:haxe.macro.Position]
				[Const:Null<Int>] null

	public static function validateSchemaFields[Function:(fields : Array<{ type : String, name : String, meta : Dynamic }>, pos : haxe.macro.Position) -> Bool]
		[Arg:Array<{ type : String, name : String, meta : Dynamic }>] [Local fields(26304):Array<{ type : String, name : String, meta : Dynamic }>]
		[Arg:haxe.macro.Position] [Local pos(26305):haxe.macro.Position]
		[Block:Dynamic]
			[Var errors(26306):Array<String>] [ArrayDecl:Array<String>]
			[Var warnings(26307):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26316):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26316):Int:Int]
						<
						[Field:Int]
							[Local fields(26304):Array<{ type : String, name : String, meta : Dynamic }>:Array<{ type : String, name : String, meta : Dynamic }>]
							[FInstance:Int]
								Array<{ type : String, name : String, meta : Dynamic }>
								length:Int
					[Block:Void]
						[Var field(26308):{ type : String, name : String, meta : Dynamic }]
							[Array:{ type : String, name : String, meta : Dynamic }]
								[Local fields(26304):Array<{ type : String, name : String, meta : Dynamic }>:Array<{ type : String, name : String, meta : Dynamic }>]
								[Local `(26316):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26316):Int:Int]
						[If:Void]
							[Call:Bool]
								[Field:(name : String) -> Bool]
									[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
									[FStatic:(name : String) -> Bool]
										reflaxe.elixir.helpers.EctoErrorReporter
										isReservedKeyword:(name : String) -> Bool
								[Field:String]
									[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
									[FAnon:String] name:String
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local errors(26306):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Const:String] "Field name \""
											+
											[Field:String]
												[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
												[FAnon:String] name:String
										+
										[Const:String] "\" is a reserved keyword. Use a different name."
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Call:Bool]
									[Field:(type : String) -> Bool]
										[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
										[FStatic:(type : String) -> Bool]
											reflaxe.elixir.helpers.EctoErrorReporter
											isValidEctoType:(type : String) -> Bool
									[Field:String]
										[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
										[FAnon:String] type:String
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local errors(26306):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "Field \""
													+
													[Field:String]
														[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
														[FAnon:String] name:String
												+
												[Const:String] "\" has invalid type \""
											+
											[Field:String]
												[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
												[FAnon:String] type:String
										+
										[Const:String] "\". Valid types: string, integer, boolean, date, datetime, decimal, map, array"
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
									[FAnon:Dynamic] meta:Dynamic
								!=
								[Const:Dynamic] null
							[Then:Void] [Block:Void]
								[Var metaErrors(26315):Array<String>]
									[Call:Array<String>]
										[Field:(meta : Dynamic) -> Array<String>]
											[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
											[FStatic:(meta : Dynamic) -> Array<String>]
												reflaxe.elixir.helpers.EctoErrorReporter
												validateMetadata:(meta : Dynamic) -> Array<String>
										[Field:Dynamic]
											[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
											[FAnon:Dynamic] meta:Dynamic
								[If:Void]
									[Binop:Bool]
										[Field:Int]
											[Local metaErrors(26315):Array<String>:Array<String>]
											[FInstance:Int]
												Array<String>
												length:Int
										>
										[Const:Int] 0
									[Then:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local errors(26306):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Field \""
														+
														[Field:String]
															[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
															[FAnon:String] name:String
													+
													[Const:String] "\" metadata errors: "
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local metaErrors(26315):Array<String>:Array<String>]
														[FInstance:(sep : String) -> String]
															Array<String>
															join:(sep : String) -> String
													[Const:String] ", "
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Field:String]
											[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
											[FAnon:String] name:String
										==
										[Const:String] "id"
									&&
									[Binop:Bool]
										[Field:Dynamic]
											[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
											[FAnon:Dynamic] meta:Dynamic
										!=
										[Const:Dynamic] null
								&&
								[Binop:Bool]
									[Field:Dynamic]
										[Field:Dynamic]
											[Local field(26308):{ type : String, name : String, meta : Dynamic }:{ type : String, name : String, meta : Dynamic }]
											[FAnon:Dynamic] meta:Dynamic
										[FDynamic:Dynamic] nullable
									==
									[Const:Bool] true
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local warnings(26307):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Const:String] "Primary key \"id\" should not be nullable"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local errors(26306):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var errorMessage(26326):String]
						[Binop:String]
							[Const:String] "Schema validation failed:\n"
							+
							[Call:String]
								[Field:(sep : String) -> String]
									[Block:Array<String>]
										[Var `(26321):Array<String>] [ArrayDecl:Array<String>]
										[Block:Void]
											[Var `(26322):Int] [Const:Int] 0
											[Var `(26323):Array<String>] [Local errors(26306):Array<String>:Array<String>]
											[While:Void]
												[Binop:Bool]
													[Local `(26322):Int:Int]
													<
													[Field:Int]
														[Local `(26323):Array<String>:Array<String>]
														[FInstance:Int]
															Array<String>
															length:Int
												[Block:Void]
													[Var v(26324):String]
														[Array:String]
															[Local `(26323):Array<String>:Array<String>]
															[Local `(26322):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(26322):Int:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local `(26321):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Call:String]
															[Function:(e : String) -> String]
																[Arg:String] [Local e(26325):String]
																[Block:Dynamic]
																	[Return:Dynamic]
																		[Binop:String]
																			[Const:String] "  - "
																			+
																			[Local e(26325):String:String]
															[Local v(26324):String:String]
										[Local `(26321):Array<String>:Array<String>]
									[FInstance:(sep : String) -> String]
										Array<String>
										join:(sep : String) -> String
								[Const:String] "\n"
					[Binop:String]
						[Local errorMessage(26326):String:String]
						+=
						[Const:String] "\n\nSee documentation/guides/ADVANCED_ECTO_GUIDE.md for schema examples"
					[Call:Dynamic]
						[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
								haxe.macro.Context
								error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
						[Local errorMessage(26326):String:String]
						[Local pos(26305):haxe.macro.Position:haxe.macro.Position]
						[Const:Null<Int>] null
					[Return:Dynamic] [Const:Bool] false
			[Block:Void]
				[Var `(26328):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26328):Int:Int]
						<
						[Field:Int]
							[Local warnings(26307):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var warning(26327):String]
							[Array:String]
								[Local warnings(26307):Array<String>:Array<String>]
								[Local `(26328):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26328):Int:Int]
						[Call:Void]
							[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void]
								[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
								[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void]
									haxe.macro.Context
									warning:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Void
							[Local warning(26327):String:String]
							[Local pos(26305):haxe.macro.Position:haxe.macro.Position]
							[Const:Null<Int>] null
			[Return:Dynamic] [Const:Bool] true

	public static function validateChangesetConfig[Function:(className : String, config : Dynamic, pos : haxe.macro.Position) -> Bool]
		[Arg:String] [Local className(26329):String]
		[Arg:Dynamic] [Local config(26330):Dynamic]
		[Arg:haxe.macro.Position] [Local pos(26331):haxe.macro.Position]
		[Block:Dynamic]
			[Var errors(26332):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Call:Bool]
						[Field:(className : String) -> Bool]
							[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
							[FStatic:(className : String) -> Bool]
								reflaxe.elixir.helpers.EctoErrorReporter
								hasChangesetFunction:(className : String) -> Bool
						[Local className(26329):String:String]
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local errors(26332):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Binop:String]
								[Const:String] "Class "
								+
								[Local className(26329):String:String]
							+
							[Const:String] " with @:changeset must have a static changeset function"
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local config(26330):Dynamic:Dynamic]
						[FDynamic:Dynamic] castFields
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[Var castFields(26334):Array<String>]
						[Cast:Array<String>]
							[Field:Dynamic]
								[Local config(26330):Dynamic:Dynamic]
								[FDynamic:Dynamic] castFields
					[Block:Void]
						[Var `(26338):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(26338):Int:Int]
								<
								[Field:Int]
									[Local castFields(26334):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var field(26335):String]
									[Array:String]
										[Local castFields(26334):Array<String>:Array<String>]
										[Local `(26338):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(26338):Int:Int]
								[If:Void]
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(className : String, fieldName : String) -> Bool]
												[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
												[FStatic:(className : String, fieldName : String) -> Bool]
													reflaxe.elixir.helpers.EctoErrorReporter
													schemaHasField:(className : String, fieldName : String) -> Bool
											[Local className(26329):String:String]
											[Local field(26335):String:String]
									[Then:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local errors(26332):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Const:String] "Cast field \""
													+
													[Local field(26335):String:String]
												+
												[Const:String] "\" does not exist in schema"
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local config(26330):Dynamic:Dynamic]
						[FDynamic:Dynamic] requiredFields
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[Var requiredFields(26339):Array<String>]
						[Cast:Array<String>]
							[Field:Dynamic]
								[Local config(26330):Dynamic:Dynamic]
								[FDynamic:Dynamic] requiredFields
					[Block:Void]
						[Var `(26341):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(26341):Int:Int]
								<
								[Field:Int]
									[Local requiredFields(26339):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
							[Block:Void]
								[Var field(26340):String]
									[Array:String]
										[Local requiredFields(26339):Array<String>:Array<String>]
										[Local `(26341):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(26341):Int:Int]
								[If:Void]
									[Unop:Bool]
										!
										Prefix
										[Call:Bool]
											[Field:(className : String, fieldName : String) -> Bool]
												[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
												[FStatic:(className : String, fieldName : String) -> Bool]
													reflaxe.elixir.helpers.EctoErrorReporter
													schemaHasField:(className : String, fieldName : String) -> Bool
											[Local className(26329):String:String]
											[Local field(26340):String:String]
									[Then:Int] [Block:Int]
										[Call:Int]
											[Field:(x : String) -> Int]
												[Local errors(26332):Array<String>:Array<String>]
												[FInstance:(x : String) -> Int]
													Array<String>
													push:(x : Array.T) -> Int
											[Binop:String]
												[Binop:String]
													[Const:String] "Required field \""
													+
													[Local field(26340):String:String]
												+
												[Const:String] "\" does not exist in schema"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local errors(26332):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var errorMessage(26351):String]
						[Binop:String]
							[Const:String] "Changeset validation failed for $className:\n"
							+
							[Call:String]
								[Field:(sep : String) -> String]
									[Block:Array<String>]
										[Var `(26346):Array<String>] [ArrayDecl:Array<String>]
										[Block:Void]
											[Var `(26347):Int] [Const:Int] 0
											[Var `(26348):Array<String>] [Local errors(26332):Array<String>:Array<String>]
											[While:Void]
												[Binop:Bool]
													[Local `(26347):Int:Int]
													<
													[Field:Int]
														[Local `(26348):Array<String>:Array<String>]
														[FInstance:Int]
															Array<String>
															length:Int
												[Block:Void]
													[Var v(26349):String]
														[Array:String]
															[Local `(26348):Array<String>:Array<String>]
															[Local `(26347):Int:Int]
													[Unop:Int]
														++
														Prefix
														[Local `(26347):Int:Int]
													[Call:Int]
														[Field:(x : String) -> Int]
															[Local `(26346):Array<String>:Array<String>]
															[FInstance:(x : String) -> Int]
																Array<String>
																push:(x : Array.T) -> Int
														[Call:String]
															[Function:(e : String) -> String]
																[Arg:String] [Local e(26350):String]
																[Block:Dynamic]
																	[Return:Dynamic]
																		[Binop:String]
																			[Const:String] "  - "
																			+
																			[Local e(26350):String:String]
															[Local v(26349):String:String]
										[Local `(26346):Array<String>:Array<String>]
									[FInstance:(sep : String) -> String]
										Array<String>
										join:(sep : String) -> String
								[Const:String] "\n"
					[Binop:String]
						[Local errorMessage(26351):String:String]
						+=
						[Binop:String]
							[Const:String] "\n\nExample changeset:\n"
							+
							[Call:String]
								[Field:() -> String]
									[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
									[FStatic:() -> String]
										reflaxe.elixir.helpers.EctoErrorReporter
										getChangesetExample:() -> String
					[Call:Dynamic]
						[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
							[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
							[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
								haxe.macro.Context
								error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
						[Local errorMessage(26351):String:String]
						[Local pos(26331):haxe.macro.Position:haxe.macro.Position]
						[Const:Null<Int>] null
					[Return:Dynamic] [Const:Bool] false
			[Return:Dynamic] [Const:Bool] true

	static function formatSchemaError[Function:(schemaName : String, error : String) -> String]
		[Arg:String] [Local schemaName(26215):String]
		[Arg:String] [Local error(26216):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] "Schema \""
							+
							[Local schemaName(26215):String:String]
						+
						[Const:String] "\" compilation failed: "
					+
					[Local error(26216):String:String]

	static function getSuggestion[Function:(error : String) -> String]
		[Arg:String] [Local error(26218):String]
		[Block:Dynamic]
			[Block:Void]
				[Var `(26224):Int] [Const:Int] 0
				[Var `(26225):Array<{ solution : String, pattern : String, docs : String }>]
					[Field:Array<{ solution : String, pattern : String, docs : String }>]
						[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
						[FStatic:Array<{ solution : String, pattern : String, docs : String }>]
							reflaxe.elixir.helpers.EctoErrorReporter
							ERROR_PATTERNS:Array<{ solution : String, pattern : String, docs : String }>
				[While:Void]
					[Binop:Bool]
						[Local `(26224):Int:Int]
						<
						[Field:Int]
							[Local `(26225):Array<{ solution : String, pattern : String, docs : String }>:Array<{ solution : String, pattern : String, docs : String }>]
							[FInstance:Int]
								Array<{ solution : String, pattern : String, docs : String }>
								length:Int
					[Block:Void]
						[Var pattern(26219):{ solution : String, pattern : String, docs : String }]
							[Array:{ solution : String, pattern : String, docs : String }]
								[Local `(26225):Array<{ solution : String, pattern : String, docs : String }>:Array<{ solution : String, pattern : String, docs : String }>]
								[Local `(26224):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26224):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Block:Bool]
									[Var value(26223):String]
										[Field:String]
											[Local pattern(26219):{ solution : String, pattern : String, docs : String }:{ solution : String, pattern : String, docs : String }]
											[FAnon:String] pattern:String
									[Binop:Bool]
										[Call:Int]
											[Field:(str : String, ?startIndex : Null<Int>) -> Int]
												[Local error(26218):String:String]
												[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
													String
													indexOf:(str : String, ?startIndex : Null<Int>) -> Int
											[Local value(26223):String:String]
											[Const:Null<Int>] null
										!=
										[Const:Int] -1
								||
								[Call:Bool]
									[Field:(s : String) -> Bool]
										[New:EReg]
											EReg
											[Field:String]
												[Local pattern(26219):{ solution : String, pattern : String, docs : String }:{ solution : String, pattern : String, docs : String }]
												[FAnon:String] pattern:String
											[Const:String] "i"
										[FInstance:(s : String) -> Bool]
											EReg
											match:(s : String) -> Bool
									[Local error(26218):String:String]
							[Then:Dynamic] [Block:Dynamic]
								[Return:Dynamic]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "Suggestion: "
												+
												[Field:String]
													[Local pattern(26219):{ solution : String, pattern : String, docs : String }:{ solution : String, pattern : String, docs : String }]
													[FAnon:String] solution:String
											+
											[Const:String] "\nDocumentation: "
										+
										[Field:String]
											[Local pattern(26219):{ solution : String, pattern : String, docs : String }:{ solution : String, pattern : String, docs : String }]
											[FAnon:String] docs:String
			[Return:Dynamic] [Const:String] "Check your schema definition and ensure all annotations are correct."

	static function getChangesetSuggestion[Function:(error : String) -> String]
		[Arg:String] [Local error(26232):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26232):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "cast"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Ensure all cast fields exist in your schema and are properly typed"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26232):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "validate"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Validation functions must match Ecto patterns (validate_required, validate_format, etc.)"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26232):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "constraint"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Constraints must reference existing database constraints or indexes"
			[Return:Dynamic] [Const:String] "Review your changeset function for proper Ecto patterns"

	static function getChangesetExample[Function:() -> String] [Block:Dynamic] [Return:Dynamic] [Const:String] "\npublic static function changeset(user: User, params: Dynamic): Dynamic {\n    return user\n        |> cast(params, [\"name\", \"email\", \"age\"])\n        |> validateRequired([\"name\", \"email\"])\n        |> validateFormat(\"email\", ~r/@/)\n        |> validateNumber(\"age\", greaterThan: 0, lessThan: 150)\n        |> uniqueConstraint(\"email\");\n}"

	static function getQuerySuggestion[Function:(queryExpr : String, error : String) -> String]
		[Arg:String] [Local queryExpr(26252):String]
		[Arg:String] [Local error(26253):String]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26253):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "from"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Query must start with 'from' clause: from(u in User)"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26253):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "where"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Where clauses use == for equality: where(u.active == true)"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local error(26253):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "select"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "Select clause must be last: ...select(u)"
			[Return:Dynamic] [Const:String] "Review Ecto.Query syntax in documentation/guides/ADVANCED_ECTO_GUIDE.md"

	static function getQueryAlternatives[Function:(queryExpr : String) -> Array<String>]
		[Arg:String] [Local queryExpr(26267):String]
		[Block:Dynamic]
			[Var alternatives(26268):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local queryExpr(26267):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "User.where"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local alternatives(26268):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "from(u in User) |> where(u.active == true)"
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local queryExpr(26267):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "Repo.get"
						[Const:Null<Int>] null
					!=
					[Const:Int] -1
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local alternatives(26268):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Repo.get(User, id)"
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local alternatives(26268):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Repo.get_by(User, email: \"user@example.com\")"
			[Return:Dynamic] [Local alternatives(26268):Array<String>:Array<String>]

	static function getMigrationSuggestion[Function:(operation : String, error : String) -> String]
		[Arg:String] [Local operation(26283):String]
		[Arg:String] [Local error(26284):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (operation) {
	case "create_table":
		"Table creation requires a block: create table(:users) do ... end";	
	case "add_column":
		"Column addition syntax: add :field_name, :field_type, options";	
	case "create_index":
		"Index creation: create index(:table, [:field1, :field2])";	
	default:
		"Check migration DSL syntax in documentation";	
})
					[Switch:String]
						[Local operation(26283):String:String]
						[Case:String]
							[Const:String] "add_column"
							[Block:String] [Block:String] [Const:String] "Column addition syntax: add :field_name, :field_type, options"
						[Case:String]
							[Const:String] "create_index"
							[Block:String] [Block:String] [Const:String] "Index creation: create index(:table, [:field1, :field2])"
						[Case:String]
							[Const:String] "create_table"
							[Block:String] [Block:String] [Const:String] "Table creation requires a block: create table(:users) do ... end"
						[Default:String] [Block:String] [Const:String] "Check migration DSL syntax in documentation"

	static function getMigrationExample[Function:(operation : String) -> String]
		[Arg:String] [Local operation(26286):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (operation) {
	case "create_table":
		"create table(:users) do\n    add :id, :bigserial, primary_key: true\n    add :name, :string, null: false\n    add :email, :string, null: false\n    timestamps()\nend";	
	case "add_column":
		"alter table(:users) do\n    add :age, :integer, default: 0\nend";	
	default:
		"";	
})
					[Switch:String]
						[Local operation(26286):String:String]
						[Case:String]
							[Const:String] "add_column"
							[Block:String] [Block:String] [Const:String] "alter table(:users) do\n    add :age, :integer, default: 0\nend"
						[Case:String]
							[Const:String] "create_table"
							[Block:String] [Block:String] [Const:String] "create table(:users) do\n    add :id, :bigserial, primary_key: true\n    add :name, :string, null: false\n    add :email, :string, null: false\n    timestamps()\nend"
						[Default:String] [Block:String] [Const:String] ""

	static function getAssociationSuggestion[Function:(assocType : String, error : String) -> String]
		[Arg:String] [Local assocType(26294):String]
		[Arg:String] [Local error(26295):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (assocType) {
	case "has_many":
		"has_many requires: plural field name, target schema, foreign_key option";	
	case "belongs_to":
		"belongs_to requires: singular field name, target schema, creates foreign_key field";	
	case "many_to_many":
		"many_to_many requires: join_through table or schema";	
	default:
		"Check association configuration in documentation";	
})
					[Switch:String]
						[Local assocType(26294):String:String]
						[Case:String]
							[Const:String] "belongs_to"
							[Block:String] [Block:String] [Const:String] "belongs_to requires: singular field name, target schema, creates foreign_key field"
						[Case:String]
							[Const:String] "has_many"
							[Block:String] [Block:String] [Const:String] "has_many requires: plural field name, target schema, foreign_key option"
						[Case:String]
							[Const:String] "many_to_many"
							[Block:String] [Block:String] [Const:String] "many_to_many requires: join_through table or schema"
						[Default:String] [Block:String] [Const:String] "Check association configuration in documentation"

	static function getAssociationRequirements[Function:(assocType : String) -> String]
		[Arg:String] [Local assocType(26297):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (assocType) {
	case "has_many":
		"- Plural field name (e.g., 'posts')\n- Target schema exists\n- Foreign key in target table";	
	case "belongs_to":
		"- Singular field name (e.g., 'user')\n- Creates foreign_key field (e.g., 'user_id')\n- Target schema exists";	
	case "many_to_many":
		"- Join table or schema specified\n- Both foreign keys exist in join table";	
	default:
		"";	
})
					[Switch:String]
						[Local assocType(26297):String:String]
						[Case:String]
							[Const:String] "belongs_to"
							[Block:String] [Block:String] [Const:String] "- Singular field name (e.g., 'user')\n- Creates foreign_key field (e.g., 'user_id')\n- Target schema exists"
						[Case:String]
							[Const:String] "has_many"
							[Block:String] [Block:String] [Const:String] "- Plural field name (e.g., 'posts')\n- Target schema exists\n- Foreign key in target table"
						[Case:String]
							[Const:String] "many_to_many"
							[Block:String] [Block:String] [Const:String] "- Join table or schema specified\n- Both foreign keys exist in join table"
						[Default:String] [Block:String] [Const:String] ""

	static function isReservedKeyword[Function:(name : String) -> Bool]
		[Arg:String] [Local name(26309):String]
		[Block:Dynamic]
			[Var reserved(26310):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "default"
					[Const:String] "interface"
					[Const:String] "operator"
					[Const:String] "overload"
					[Const:String] "class"
					[Const:String] "enum"
					[Const:String] "function"
					[Const:String] "var"
					[Const:String] "if"
					[Const:String] "else"
					[Const:String] "switch"
					[Const:String] "case"
					[Const:String] "return"
					[Const:String] "break"
					[Const:String] "continue"
					[Const:String] "while"
					[Const:String] "for"
					[Const:String] "do"
					[Const:String] "try"
					[Const:String] "catch"
					[Const:String] "throw"
					[Const:String] "new"
			[Return:Dynamic]
				[Call:Bool]
					[Field:(x : String) -> Bool]
						[Local reserved(26310):Array<String>:Array<String>]
						[FInstance:(x : String) -> Bool]
							Array<String>
							contains:(x : Array.T) -> Bool
					[Local name(26309):String:String]

	static function isValidEctoType[Function:(type : String) -> Bool]
		[Arg:String] [Local type(26311):String]
		[Block:Dynamic]
			[Var validTypes(26312):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "string"
					[Const:String] "integer"
					[Const:String] "boolean"
					[Const:String] "date"
					[Const:String] "datetime"
					[Const:String] "naive_datetime"
					[Const:String] "decimal"
					[Const:String] "float"
					[Const:String] "binary"
					[Const:String] "map"
					[Const:String] "array"
					[Const:String] "text"
					[Const:String] "uuid"
					[Const:String] "id"
			[Return:Dynamic]
				[Call:Bool]
					[Field:(x : String) -> Bool]
						[Local validTypes(26312):Array<String>:Array<String>]
						[FInstance:(x : String) -> Bool]
							Array<String>
							contains:(x : Array.T) -> Bool
					[Call:String]
						[Field:() -> String]
							[Local type(26311):String:String]
							[FInstance:() -> String]
								String
								toLowerCase:() -> String

	static function validateMetadata[Function:(meta : Dynamic) -> Array<String>]
		[Arg:Dynamic] [Local meta(26313):Dynamic]
		[Block:Dynamic]
			[Var errors(26314):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Call:Bool]
					[Field:(o : Dynamic, field : String) -> Bool]
						[TypeExpr Reflect:Class<Reflect>]
						[FStatic:(o : Dynamic, field : String) -> Bool]
							Reflect
							hasField:(o : Dynamic, field : String) -> Bool
					[Local meta(26313):Dynamic:Dynamic]
					[Const:String] "default"
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local errors(26314):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Use 'defaultValue' instead of 'default' (reserved keyword)"
			[If:Void]
				[Call:Bool]
					[Field:(o : Dynamic, field : String) -> Bool]
						[TypeExpr Reflect:Class<Reflect>]
						[FStatic:(o : Dynamic, field : String) -> Bool]
							Reflect
							hasField:(o : Dynamic, field : String) -> Bool
					[Local meta(26313):Dynamic:Dynamic]
					[Const:String] "interface"
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local errors(26314):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Cannot use 'interface' in metadata (reserved keyword)"
			[If:Void]
				[Call:Bool]
					[Field:(o : Dynamic, field : String) -> Bool]
						[TypeExpr Reflect:Class<Reflect>]
						[FStatic:(o : Dynamic, field : String) -> Bool]
							Reflect
							hasField:(o : Dynamic, field : String) -> Bool
					[Local meta(26313):Dynamic:Dynamic]
					[Const:String] "operator"
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local errors(26314):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Const:String] "Cannot use 'operator' in metadata (reserved keyword)"
			[Return:Dynamic] [Local errors(26314):Array<String>:Array<String>]

	static function hasChangesetFunction[Function:(className : String) -> Bool]
		[Arg:String] [Local className(26333):String]
		[Block:Dynamic] [Return:Dynamic] [Const:Bool] true

	static function schemaHasField[Function:(className : String, fieldName : String) -> Bool]
		[Arg:String] [Local className(26336):String]
		[Arg:String] [Local fieldName(26337):String]
		[Block:Dynamic] [Return:Dynamic] [Const:Bool] true

	public static function formatErrorWithContext[Function:(error : String, code : String, line : Int, column : Int) -> String]
		[Arg:String] [Local error(26352):String]
		[Arg:String] [Local code(26353):String]
		[Arg:Int] [Local line(26354):Int]
		[Arg:Int] [Local column(26355):Int]
		[Block:Dynamic]
			[Var lines(26356):Array<String>]
				[Call:Array<String>]
					[Field:(delimiter : String) -> Array<String>]
						[Local code(26353):String:String]
						[FInstance:(delimiter : String) -> Array<String>]
							String
							split:(delimiter : String) -> Array<String>
					[Const:String] "\n"
			[Var context(26357):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26359):Int]
					[Call:Int]
						[Field:(x : Float) -> Int]
							[TypeExpr Std:Class<Std>]
							[FStatic:(x : Float) -> Int]
								Std
								int:(x : Float) -> Int
						[Call:Float]
							[Field:(a : Float, b : Float) -> Float]
								[TypeExpr Math:Class<Math>]
								[FStatic:(a : Float, b : Float) -> Float]
									Math
									max:(a : Float, b : Float) -> Float
							[Const:Int] 0
							[Binop:Int]
								[Local line(26354):Int:Int]
								-
								[Const:Int] 2
				[Var `(26360):Int] [Local line(26354):Int:Int]
				[While:Void]
					[Binop:Bool]
						[Local `(26359):Int:Int]
						<
						[Local `(26360):Int:Int]
					[Block:Int]
						[Var i(26358):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(26359):Int:Int]
						[Call:Int]
							[Field:(x : String) -> Int]
								[Local context(26357):Array<String>:Array<String>]
								[FInstance:(x : String) -> Int]
									Array<String>
									push:(x : Array.T) -> Int
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] ""
										+
										[Binop:Int]
											[Local i(26358):Int:Int]
											+
											[Const:Int] 1
									+
									[Const:String] " | "
								+
								[Array:String]
									[Local lines(26356):Array<String>:Array<String>]
									[Local i(26358):Int:Int]
			[If:Void]
				[Binop:Bool]
					[Local line(26354):Int:Int]
					<
					[Field:Int]
						[Local lines(26356):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local context(26357):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Binop:Int]
										[Local line(26354):Int:Int]
										+
										[Const:Int] 1
								+
								[Const:String] " | "
							+
							[Array:String]
								[Local lines(26356):Array<String>:Array<String>]
								[Local line(26354):Int:Int]
					[Var marker(26361):String]
						[Binop:String]
							[Binop:String]
								[Call:String]
									[Field:(s : String, c : String, l : Int) -> String]
										[TypeExpr StringTools:Class<StringTools>]
										[FStatic:(s : String, c : String, l : Int) -> String]
											StringTools
											lpad:(s : String, c : String, l : Int) -> String
									[Const:String] ""
									[Const:String] " "
									[Binop:Int]
										[Local column(26355):Int:Int]
										+
										[Const:Int] 5
								+
								[Const:String] "^--- "
							+
							[Local error(26352):String:String]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local context(26357):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Local marker(26361):String:String]
			[Block:Void]
				[Var `(26363):Int]
					[Parenthesis:Int]
						[Binop:Int]
							[Local line(26354):Int:Int]
							+
							[Const:Int] 1
				[Var `(26364):Int]
					[Call:Int]
						[Field:(x : Float) -> Int]
							[TypeExpr Std:Class<Std>]
							[FStatic:(x : Float) -> Int]
								Std
								int:(x : Float) -> Int
						[Call:Float]
							[Field:(a : Float, b : Float) -> Float]
								[TypeExpr Math:Class<Math>]
								[FStatic:(a : Float, b : Float) -> Float]
									Math
									min:(a : Float, b : Float) -> Float
							[Field:Int]
								[Local lines(26356):Array<String>:Array<String>]
								[FInstance:Int]
									Array<String>
									length:Int
							[Binop:Int]
								[Local line(26354):Int:Int]
								+
								[Const:Int] 3
				[While:Void]
					[Binop:Bool]
						[Local `(26363):Int:Int]
						<
						[Local `(26364):Int:Int]
					[Block:Int]
						[Var i(26362):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(26363):Int:Int]
						[Call:Int]
							[Field:(x : String) -> Int]
								[Local context(26357):Array<String>:Array<String>]
								[FInstance:(x : String) -> Int]
									Array<String>
									push:(x : Array.T) -> Int
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] ""
										+
										[Binop:Int]
											[Local i(26362):Int:Int]
											+
											[Const:Int] 1
									+
									[Const:String] " | "
								+
								[Array:String]
									[Local lines(26356):Array<String>:Array<String>]
									[Local i(26362):Int:Int]
			[Return:Dynamic]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local context(26357):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] "\n"

	public static function suggestFieldName[Function:(wrongName : String, availableFields : Array<String>) -> String]
		[Arg:String] [Local wrongName(26365):String]
		[Arg:Array<String>] [Local availableFields(26366):Array<String>]
		[Block:Dynamic]
			[Var suggestions(26367):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26388):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26388):Int:Int]
						<
						[Field:Int]
							[Local availableFields(26366):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var field(26368):String]
							[Array:String]
								[Local availableFields(26366):Array<String>:Array<String>]
								[Local `(26388):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26388):Int:Int]
						[Var distance(26387):Int]
							[Call:Int]
								[Field:(s1 : String, s2 : String) -> Int]
									[TypeExpr reflaxe.elixir.helpers.EctoErrorReporter:Class<reflaxe.elixir.helpers.EctoErrorReporter>]
									[FStatic:(s1 : String, s2 : String) -> Int]
										reflaxe.elixir.helpers.EctoErrorReporter
										levenshteinDistance:(s1 : String, s2 : String) -> Int
								[Call:String]
									[Field:() -> String]
										[Local wrongName(26365):String:String]
										[FInstance:() -> String]
											String
											toLowerCase:() -> String
								[Call:String]
									[Field:() -> String]
										[Local field(26368):String:String]
										[FInstance:() -> String]
											String
											toLowerCase:() -> String
						[If:Void]
							[Binop:Bool]
								[Local distance(26387):Int:Int]
								<=
								[Const:Int] 2
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local suggestions(26367):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Local field(26368):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local suggestions(26367):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "Did you mean: "
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local suggestions(26367):Array<String>:Array<String>]
										[FInstance:(sep : String) -> String]
											Array<String>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] "?"
			[Return:Dynamic]
				[Binop:String]
					[Const:String] "Available fields: "
					+
					[Call:String]
						[Field:(sep : String) -> String]
							[Local availableFields(26366):Array<String>:Array<String>]
							[FInstance:(sep : String) -> String]
								Array<String>
								join:(sep : String) -> String
						[Const:String] ", "

	static function levenshteinDistance[Function:(s1 : String, s2 : String) -> Int]
		[Arg:String] [Local s1(26369):String]
		[Arg:String] [Local s2(26370):String]
		[Block:Dynamic]
			[Var len1(26371):Int]
				[Field:Int]
					[Local s1(26369):String:String]
					[FInstance:Int]
						String
						length:Int
			[Var len2(26372):Int]
				[Field:Int]
					[Local s2(26370):String:String]
					[FInstance:Int]
						String
						length:Int
			[Var matrix(26373):Array<Array<Int>>] [ArrayDecl:Array<Array<Int>>]
			[Block:Void]
				[Var `(26375):Int] [Const:Int] 0
				[Var `(26376):Int]
					[Parenthesis:Int]
						[Binop:Int]
							[Local len1(26371):Int:Int]
							+
							[Const:Int] 1
				[While:Void]
					[Binop:Bool]
						[Local `(26375):Int:Int]
						<
						[Local `(26376):Int:Int]
					[Block:Int]
						[Var i(26374):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(26375):Int:Int]
						[Binop:Array<Int>]
							[Array:Array<Int>]
								[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
								[Local i(26374):Int:Int]
							=
							[ArrayDecl:Array<Int>]
						[Binop:Int]
							[Array:Int]
								[Array:Array<Int>]
									[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
									[Local i(26374):Int:Int]
								[Const:Int] 0
							=
							[Local i(26374):Int:Int]
			[Block:Void]
				[Var `(26378):Int] [Const:Int] 0
				[Var `(26379):Int]
					[Parenthesis:Int]
						[Binop:Int]
							[Local len2(26372):Int:Int]
							+
							[Const:Int] 1
				[While:Void]
					[Binop:Bool]
						[Local `(26378):Int:Int]
						<
						[Local `(26379):Int:Int]
					[Block:Int]
						[Var j(26377):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(26378):Int:Int]
						[Binop:Int]
							[Array:Int]
								[Array:Array<Int>]
									[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
									[Const:Int] 0
								[Local j(26377):Int:Int]
							=
							[Local j(26377):Int:Int]
			[Block:Void]
				[Var `(26385):Int] [Const:Int] 1
				[Var `(26386):Int]
					[Parenthesis:Int]
						[Binop:Int]
							[Local len1(26371):Int:Int]
							+
							[Const:Int] 1
				[While:Void]
					[Binop:Bool]
						[Local `(26385):Int:Int]
						<
						[Local `(26386):Int:Int]
					[Block:Void]
						[Var i(26380):Int]
							[Unop:Int]
								++
								Postfix
								[Local `(26385):Int:Int]
						[Block:Void]
							[Var `(26383):Int] [Const:Int] 1
							[Var `(26384):Int]
								[Parenthesis:Int]
									[Binop:Int]
										[Local len2(26372):Int:Int]
										+
										[Const:Int] 1
							[While:Void]
								[Binop:Bool]
									[Local `(26383):Int:Int]
									<
									[Local `(26384):Int:Int]
								[Block:Int]
									[Var j(26381):Int]
										[Unop:Int]
											++
											Postfix
											[Local `(26383):Int:Int]
									[Var cost(26382):Int]
										[If:Int]
											[Binop:Bool]
												[Call:String]
													[Field:(index : Int) -> String]
														[Local s1(26369):String:String]
														[FInstance:(index : Int) -> String]
															String
															charAt:(index : Int) -> String
													[Binop:Int]
														[Local i(26380):Int:Int]
														-
														[Const:Int] 1
												==
												[Call:String]
													[Field:(index : Int) -> String]
														[Local s2(26370):String:String]
														[FInstance:(index : Int) -> String]
															String
															charAt:(index : Int) -> String
													[Binop:Int]
														[Local j(26381):Int:Int]
														-
														[Const:Int] 1
											[Then:Int] [Block:Int] [Const:Int] 0
											[Else:Int] [Block:Int] [Const:Int] 1
									[Binop:Int]
										[Array:Int]
											[Array:Array<Int>]
												[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
												[Local i(26380):Int:Int]
											[Local j(26381):Int:Int]
										=
										[Call:Int]
											[Field:(v : Float) -> Int]
												[TypeExpr Math:Class<Math>]
												[FStatic:(v : Float) -> Int]
													Math
													floor:(v : Float) -> Int
											[Call:Float]
												[Field:(a : Float, b : Float) -> Float]
													[TypeExpr Math:Class<Math>]
													[FStatic:(a : Float, b : Float) -> Float]
														Math
														min:(a : Float, b : Float) -> Float
												[Binop:Int]
													[Array:Int]
														[Array:Array<Int>]
															[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
															[Binop:Int]
																[Local i(26380):Int:Int]
																-
																[Const:Int] 1
														[Local j(26381):Int:Int]
													+
													[Const:Int] 1
												[Call:Float]
													[Field:(a : Float, b : Float) -> Float]
														[TypeExpr Math:Class<Math>]
														[FStatic:(a : Float, b : Float) -> Float]
															Math
															min:(a : Float, b : Float) -> Float
													[Binop:Int]
														[Array:Int]
															[Array:Array<Int>]
																[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
																[Local i(26380):Int:Int]
															[Binop:Int]
																[Local j(26381):Int:Int]
																-
																[Const:Int] 1
														+
														[Const:Int] 1
													[Binop:Int]
														[Array:Int]
															[Array:Array<Int>]
																[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
																[Binop:Int]
																	[Local i(26380):Int:Int]
																	-
																	[Const:Int] 1
															[Binop:Int]
																[Local j(26381):Int:Int]
																-
																[Const:Int] 1
														+
														[Local cost(26382):Int:Int]
			[Return:Dynamic]
				[Array:Int]
					[Array:Array<Int>]
						[Local matrix(26373):Array<Array<Int>>:Array<Array<Int>>]
						[Local len1(26371):Int:Int]
					[Local len2(26372):Int:Int]
}