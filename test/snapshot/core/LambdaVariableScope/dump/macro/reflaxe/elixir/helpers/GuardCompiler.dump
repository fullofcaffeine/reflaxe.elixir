class reflaxe.elixir.helpers.GuardCompiler {

	public function new[Function:() -> Void] [Block:Void]

	public function compileGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24284):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local guardExpr(24284):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (getExprType(guardExpr)) {
	case "TBinop":
		compileBinaryGuard(guardExpr);	
	case "TUnop":
		compileUnaryGuard(guardExpr);	
	case "TCall":
		compileFunctionGuard(guardExpr);	
	case "TLocal":
		compileVariableGuard(guardExpr);	
	case "TConst":
		compileConstantGuard(guardExpr);	
	case "TParenthesis":
		compileParenthesesGuard(guardExpr);	
	case _:
		compileComplexGuard(guardExpr);	
})
					[Block:String]
						[Var `(24380):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local guardExpr(24284):Dynamic:Dynamic]
						[Switch:String]
							[Local `(24380):String:String]
							[Case:String]
								[Const:String] "TBinop"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileBinaryGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TCall"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileFunctionGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TConst"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileConstantGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TLocal"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileVariableGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TParenthesis"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileParenthesesGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TUnop"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileUnaryGuard:(guardExpr : Dynamic) -> String
											[Local guardExpr(24284):Dynamic:Dynamic]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(guardExpr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.GuardCompiler] this
											[FInstance:(guardExpr : Dynamic) -> String]
												reflaxe.elixir.helpers.GuardCompiler
												compileComplexGuard:(guardExpr : Dynamic) -> String
										[Local guardExpr(24284):Dynamic:Dynamic]

	function compileBinaryGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24286):Dynamic]
		[Block:Void]
			[Var binop(24287):{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }]
				[Field:Dynamic]
					[Local guardExpr(24286):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var left(24345):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<40>]
						[Local binop(24287):{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }:{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }]
						[FAnon:Unknown<40>] e1:Unknown<40>
			[Var right(24346):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<41>]
						[Local binop(24287):{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }:{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }]
						[FAnon:Unknown<41>] e2:Unknown<41>
			[Var op(24348):String]
				[Call:String]
					[Field:(op : String) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(op : String) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							convertGuardOperator:(op : String) -> String
					[Field:String]
						[Local binop(24287):{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }:{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }]
						[FAnon:String] op:String
			[If:Void]
				[Call:Bool]
					[Field:(op : String) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(op : String) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							isLogicalOperator:(op : String) -> Bool
					[Field:String]
						[Local binop(24287):{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }:{ op : String, e2 : Unknown<41>, e1 : Unknown<40> }]
						[FAnon:String] op:String
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local left(24345):String:String]
										+
										[Const:String] " "
									+
									[Local op(24348):String:String]
								+
								[Const:String] " "
							+
							[Local right(24346):String:String]
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local left(24345):String:String]
										+
										[Const:String] " "
									+
									[Local op(24348):String:String]
								+
								[Const:String] " "
							+
							[Local right(24346):String:String]

	function compileUnaryGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24350):Dynamic]
		[Block:Dynamic]
			[Var unop(24351):{ op : String, e : Unknown<42> }]
				[Field:Dynamic]
					[Local guardExpr(24350):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var operand(24352):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<42>]
						[Local unop(24351):{ op : String, e : Unknown<42> }:{ op : String, e : Unknown<42> }]
						[FAnon:Unknown<42>] e:Unknown<42>
			[Var op(24354):String]
				[Call:String]
					[Field:(op : String) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(op : String) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							convertUnaryOperator:(op : String) -> String
					[Field:String]
						[Local unop(24351):{ op : String, e : Unknown<42> }:{ op : String, e : Unknown<42> }]
						[FAnon:String] op:String
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (unop.op) {
	case "!":
		"not ${operand}";	
	case "-":
		"-${operand}";	
	case _:
		"${op}${operand}";	
})
					[Block:String]
						[Var `(24356):String]
							[Field:String]
								[Local unop(24351):{ op : String, e : Unknown<42> }:{ op : String, e : Unknown<42> }]
								[FAnon:String] op:String
						[Switch:String]
							[Local `(24356):String:String]
							[Case:String]
								[Const:String] "!"
								[Block:String]
									[Block:String]
										[Binop:String]
											[Const:String] "not "
											+
											[Local operand(24352):String:String]
							[Case:String]
								[Const:String] "-"
								[Block:String]
									[Block:String]
										[Binop:String]
											[Const:String] "-"
											+
											[Local operand(24352):String:String]
							[Default:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local op(24354):String:String]
										+
										[Local operand(24352):String:String]

	function compileFunctionGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24323):Dynamic]
		[Block:Dynamic]
			[Var call(24324):{ el : Null<Array<Dynamic>>, e : Unknown<43> }]
				[Field:Dynamic]
					[Local guardExpr(24323):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var funcName(24332):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							extractFunctionName:(expr : Dynamic) -> String
					[Field:Unknown<43>]
						[Local call(24324):{ el : Null<Array<Dynamic>>, e : Unknown<43> }:{ el : Null<Array<Dynamic>>, e : Unknown<43> }]
						[FAnon:Unknown<43>] e:Unknown<43>
			[Var args(24333):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local call(24324):{ el : Null<Array<Dynamic>>, e : Unknown<43> }:{ el : Null<Array<Dynamic>>, e : Unknown<43> }]
						[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(24335):Int] [Const:Int] 0
						[Var `(24336):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Null<Array<Dynamic>>]
										[Local call(24324):{ el : Null<Array<Dynamic>>, e : Unknown<43> }:{ el : Null<Array<Dynamic>>, e : Unknown<43> }]
										[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
						[While:Void]
							[Binop:Bool]
								[Local `(24335):Int:Int]
								<
								[Field:Int]
									[Local `(24336):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var arg(24334):Dynamic]
									[Array:Dynamic]
										[Local `(24336):Array<Dynamic>:Array<Dynamic>]
										[Local `(24335):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(24335):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local args(24333):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:(expr : Dynamic) -> String]
											[Const:reflaxe.elixir.helpers.GuardCompiler] this
											[FInstance:(expr : Dynamic) -> String]
												reflaxe.elixir.helpers.GuardCompiler
												compileGuardOperand:(expr : Dynamic) -> String
										[Local arg(24334):Dynamic:Dynamic]
			[Var elixirFuncName(24338):String]
				[Call:String]
					[Field:(funcName : String) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(funcName : String) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							convertGuardFunction:(funcName : String) -> String
					[Local funcName(24332):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Const:String] ""
								+
								[Local elixirFuncName(24338):String:String]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local args(24333):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileVariableGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24289):Dynamic]
		[Block:Dynamic]
			[Var local(24290):{ v : Null<{ name : Null<String> }> }]
				[Field:Dynamic]
					[Local guardExpr(24289):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<{ name : Null<String> }>]
							[Local local(24290):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
							[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
						!=
						[Const:Null<{ name : Null<String> }>] null
					&&
					[Binop:Bool]
						[Field:Null<String>]
							[Field:Null<{ name : Null<String> }>]
								[Local local(24290):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
								[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
							[FAnon:Null<String>] name:Null<String>
						!=
						[Const:Null<String>] null
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(camelCase : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
								[FStatic:(camelCase : String) -> String]
									reflaxe.elixir.helpers.NamingHelper
									toSnakeCase:(camelCase : String) -> String
							[Field:Null<String>]
								[Field:Null<{ name : Null<String> }>]
									[Local local(24290):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
									[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
								[FAnon:Null<String>] name:Null<String>
			[Return:Dynamic] [Const:String] "_"

	function compileConstantGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24291):Dynamic]
		[Block:Dynamic]
			[Var const(24292):haxe.macro.Constant]
				[Field:Dynamic]
					[Local guardExpr(24291):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (const) {
	case CInt(v, _):
		v;	
	case CFloat(f, _):
		f;	
	case CString(s, _):
		"\"${s}\"";	
	case CIdent(s):
		s;	
	case CRegexp(r, opt):
		"~r/${r}/${opt}";	
	case _:
		"nil";	
})
					[Switch:String]
						[Meta:Int]
							:exhaustive
							[EnumIndex:Int] [Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
						[Case:String]
							[Const:Int] 0
							[Block:String]
								[Var `(24308):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										0
								[Var `(24309):Null<String>]
									[EnumParameter:Null<String>]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CInt
										1
								[Block:String]
									[Var v(24310):String] [Local `(24308):String:String]
									[Block:String] [Local v(24310):String:String]
						[Case:String]
							[Const:Int] 1
							[Block:String]
								[Var `(24311):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										0
								[Var `(24312):Null<String>]
									[EnumParameter:Null<String>]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CFloat
										1
								[Block:String]
									[Var f(24313):String] [Local `(24311):String:String]
									[Block:String] [Local f(24313):String:String]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(24314):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CString
										0
								[Var `(24315):Null<haxe.macro.StringLiteralKind>]
									[EnumParameter:Null<haxe.macro.StringLiteralKind>]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CString
										1
								[Block:String]
									[Var s(24316):String] [Local `(24314):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "\""
												+
												[Local s(24316):String:String]
											+
											[Const:String] "\""
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(24317):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CIdent
										0
								[Block:String]
									[Var s(24318):String] [Local `(24317):String:String]
									[Block:String] [Local s(24318):String:String]
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(24319):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										0
								[Var `(24320):String]
									[EnumParameter:String]
										[Local const(24292):haxe.macro.Constant:haxe.macro.Constant]
										CRegexp
										1
								[Block:String]
									[Var r(24321):String] [Local `(24319):String:String]
									[Var opt(24322):String] [Local `(24320):String:String]
									[Block:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "~r/"
													+
													[Local r(24321):String:String]
												+
												[Const:String] "/"
											+
											[Local opt(24322):String:String]

	function compileParenthesesGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24357):Dynamic]
		[Block:Dynamic]
			[Var paren(24358):{ e : Unknown<44> }]
				[Field:Dynamic]
					[Local guardExpr(24357):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var inner(24359):String]
				[Call:String]
					[Field:(guardExpr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(guardExpr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuard:(guardExpr : Dynamic) -> String
					[Field:Unknown<44>]
						[Local paren(24358):{ e : Unknown<44> }:{ e : Unknown<44> }]
						[FAnon:Unknown<44>] e:Unknown<44>
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Const:String] "("
						+
						[Local inner(24359):String:String]
					+
					[Const:String] ")"

	function compileComplexGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24360):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(expr : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							isRangeGuard:(expr : Dynamic) -> Bool
					[Local guardExpr(24360):Dynamic:Dynamic]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(guardExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(guardExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									compileRangeGuard:(guardExpr : Dynamic) -> String
							[Local guardExpr(24360):Dynamic:Dynamic]
			[If:Void]
				[Call:Bool]
					[Field:(expr : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							isMembershipGuard:(expr : Dynamic) -> Bool
					[Local guardExpr(24360):Dynamic:Dynamic]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(guardExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(guardExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									compileMembershipGuard:(guardExpr : Dynamic) -> String
							[Local guardExpr(24360):Dynamic:Dynamic]
			[Return:Dynamic] [Const:String] "true"

	function isRangeGuard[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24361):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24361):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.GuardCompiler
								getExprType:(expr : Dynamic) -> String
						[Local expr(24361):Dynamic:Dynamic]
					==
					[Const:String] "TBinop"
				[Then:Dynamic] [Block:Dynamic]
					[Var binop(24362):{ op : String, e2 : Unknown<45> }]
						[Field:Dynamic]
							[Local expr(24361):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[Return:Dynamic]
						[Binop:Bool]
							[Binop:Bool]
								[Field:String]
									[Local binop(24362):{ op : String, e2 : Unknown<45> }:{ op : String, e2 : Unknown<45> }]
									[FAnon:String] op:String
								==
								[Const:String] "OpIn"
							&&
							[Call:Bool]
								[Field:(expr : Dynamic) -> Bool]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> Bool]
										reflaxe.elixir.helpers.GuardCompiler
										isRangeExpression:(expr : Dynamic) -> Bool
								[Field:Unknown<45>]
									[Local binop(24362):{ op : String, e2 : Unknown<45> }:{ op : String, e2 : Unknown<45> }]
									[FAnon:Unknown<45>] e2:Unknown<45>
			[Return:Dynamic] [Const:Bool] false

	function isRangeExpression[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24363):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24363):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.GuardCompiler
								getExprType:(expr : Dynamic) -> String
						[Local expr(24363):Dynamic:Dynamic]
					==
					[Const:String] "TBinop"
				[Then:Dynamic] [Block:Dynamic]
					[Var binop(24364):{ op : String }]
						[Field:Dynamic]
							[Local expr(24363):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[Return:Dynamic]
						[Binop:Bool]
							[Field:String]
								[Local binop(24364):{ op : String }:{ op : String }]
								[FAnon:String] op:String
							==
							[Const:String] "OpInterval"
			[Return:Dynamic] [Const:Bool] false

	function compileRangeGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24365):Dynamic]
		[Block:Dynamic]
			[Var binop(24366):{ e2 : Unknown<47>, e1 : Unknown<46> }]
				[Field:Dynamic]
					[Local guardExpr(24365):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var value(24367):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<46>]
						[Local binop(24366):{ e2 : Unknown<47>, e1 : Unknown<46> }:{ e2 : Unknown<47>, e1 : Unknown<46> }]
						[FAnon:Unknown<46>] e1:Unknown<46>
			[Var range(24372):String]
				[Call:String]
					[Field:(rangeExpr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(rangeExpr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileRangeExpression:(rangeExpr : Dynamic) -> String
					[Field:Unknown<47>]
						[Local binop(24366):{ e2 : Unknown<47>, e1 : Unknown<46> }:{ e2 : Unknown<47>, e1 : Unknown<46> }]
						[FAnon:Unknown<47>] e2:Unknown<47>
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local value(24367):String:String]
						+
						[Const:String] " in "
					+
					[Local range(24372):String:String]

	function compileRangeExpression[Function:(rangeExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local rangeExpr(24368):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.GuardCompiler
								getExprType:(expr : Dynamic) -> String
						[Local rangeExpr(24368):Dynamic:Dynamic]
					==
					[Const:String] "TBinop"
				[Then:Void] [Block:Void]
					[Var binop(24369):{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }]
						[Field:Dynamic]
							[Local rangeExpr(24368):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[If:Void]
						[Binop:Bool]
							[Field:String]
								[Local binop(24369):{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }:{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }]
								[FAnon:String] op:String
							==
							[Const:String] "OpInterval"
						[Then:Dynamic] [Block:Dynamic]
							[Var start(24370):String]
								[Call:String]
									[Field:(expr : Dynamic) -> String]
										[Const:reflaxe.elixir.helpers.GuardCompiler] this
										[FInstance:(expr : Dynamic) -> String]
											reflaxe.elixir.helpers.GuardCompiler
											compileGuardOperand:(expr : Dynamic) -> String
									[Field:Unknown<48>]
										[Local binop(24369):{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }:{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }]
										[FAnon:Unknown<48>] e1:Unknown<48>
							[Var end(24371):String]
								[Call:String]
									[Field:(expr : Dynamic) -> String]
										[Const:reflaxe.elixir.helpers.GuardCompiler] this
										[FInstance:(expr : Dynamic) -> String]
											reflaxe.elixir.helpers.GuardCompiler
											compileGuardOperand:(expr : Dynamic) -> String
									[Field:Unknown<49>]
										[Local binop(24369):{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }:{ op : String, e2 : Unknown<49>, e1 : Unknown<48> }]
										[FAnon:Unknown<49>] e2:Unknown<49>
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local start(24370):String:String]
										+
										[Const:String] ".."
									+
									[Local end(24371):String:String]
			[Return:Dynamic] [Const:String] "1..10"

	function isMembershipGuard[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24373):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24373):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.GuardCompiler
								getExprType:(expr : Dynamic) -> String
						[Local expr(24373):Dynamic:Dynamic]
					==
					[Const:String] "TBinop"
				[Then:Dynamic] [Block:Dynamic]
					[Var binop(24374):{ op : String, e2 : Unknown<50> }]
						[Field:Dynamic]
							[Local expr(24373):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
					[Return:Dynamic]
						[Binop:Bool]
							[Binop:Bool]
								[Field:String]
									[Local binop(24374):{ op : String, e2 : Unknown<50> }:{ op : String, e2 : Unknown<50> }]
									[FAnon:String] op:String
								==
								[Const:String] "OpIn"
							&&
							[Unop:Bool]
								!
								Prefix
								[Call:Bool]
									[Field:(expr : Dynamic) -> Bool]
										[Const:reflaxe.elixir.helpers.GuardCompiler] this
										[FInstance:(expr : Dynamic) -> Bool]
											reflaxe.elixir.helpers.GuardCompiler
											isRangeExpression:(expr : Dynamic) -> Bool
									[Field:Unknown<50>]
										[Local binop(24374):{ op : String, e2 : Unknown<50> }:{ op : String, e2 : Unknown<50> }]
										[FAnon:Unknown<50>] e2:Unknown<50>
			[Return:Dynamic] [Const:Bool] false

	function compileMembershipGuard[Function:(guardExpr : Dynamic) -> String]
		[Arg:Dynamic] [Local guardExpr(24375):Dynamic]
		[Block:Dynamic]
			[Var binop(24376):{ e2 : Unknown<52>, e1 : Unknown<51> }]
				[Field:Dynamic]
					[Local guardExpr(24375):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var value(24377):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<51>]
						[Local binop(24376):{ e2 : Unknown<52>, e1 : Unknown<51> }:{ e2 : Unknown<52>, e1 : Unknown<51> }]
						[FAnon:Unknown<51>] e1:Unknown<51>
			[Var list(24378):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuardOperand:(expr : Dynamic) -> String
					[Field:Unknown<52>]
						[Local binop(24376):{ e2 : Unknown<52>, e1 : Unknown<51> }:{ e2 : Unknown<52>, e1 : Unknown<51> }]
						[FAnon:Unknown<52>] e2:Unknown<52>
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Const:String] ""
							+
							[Local value(24377):String:String]
						+
						[Const:String] " in "
					+
					[Local list(24378):String:String]

	function compileGuardOperand[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24288):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24288):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "nil"
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (getExprType(expr)) {
	case "TLocal":
		compileVariableGuard(expr);	
	case "TConst":
		compileConstantGuard(expr);	
	case "TBinop":
		compileBinaryGuard(expr);	
	case "TCall":
		compileFunctionGuard(expr);	
	case "TField":
		compileFieldAccess(expr);	
	case _:
		"expr";	
})
					[Block:String]
						[Var `(24344):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local expr(24288):Dynamic:Dynamic]
						[Switch:String]
							[Local `(24344):String:String]
							[Case:String]
								[Const:String] "TBinop"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileBinaryGuard:(guardExpr : Dynamic) -> String
											[Local expr(24288):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TCall"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileFunctionGuard:(guardExpr : Dynamic) -> String
											[Local expr(24288):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TConst"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileConstantGuard:(guardExpr : Dynamic) -> String
											[Local expr(24288):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TField"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(expr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(expr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileFieldAccess:(expr : Dynamic) -> String
											[Local expr(24288):Dynamic:Dynamic]
							[Case:String]
								[Const:String] "TLocal"
								[Block:String]
									[Block:String]
										[Call:String]
											[Field:(guardExpr : Dynamic) -> String]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> String]
													reflaxe.elixir.helpers.GuardCompiler
													compileVariableGuard:(guardExpr : Dynamic) -> String
											[Local expr(24288):Dynamic:Dynamic]
							[Default:String] [Block:String] [Const:String] "expr"

	function compileFieldAccess[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24339):Dynamic]
		[Block:Dynamic]
			[Var field(24340):{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }]
				[Field:Dynamic]
					[Local expr(24339):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<Unknown<53>>]
							[Local field(24340):{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }]
							[FAnon:Null<Unknown<53>>] e:Null<Unknown<53>>
						!=
						[Const:Null<Unknown<53>>] null
					&&
					[Binop:Bool]
						[Field:Null<{ name : String }>]
							[Local field(24340):{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }]
							[FAnon:Null<{ name : String }>] fa:Null<{ name : String }>
						!=
						[Const:Null<{ name : String }>] null
				[Then:Dynamic] [Block:Dynamic]
					[Var obj(24341):String]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									compileGuardOperand:(expr : Dynamic) -> String
							[Field:Null<Unknown<53>>]
								[Local field(24340):{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }]
								[FAnon:Null<Unknown<53>>] e:Null<Unknown<53>>
					[Var fieldName(24342):String]
						[Call:String]
							[Field:(camelCase : String) -> String]
								[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
								[FStatic:(camelCase : String) -> String]
									reflaxe.elixir.helpers.NamingHelper
									toSnakeCase:(camelCase : String) -> String
							[Field:String]
								[Field:Null<{ name : String }>]
									[Local field(24340):{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }:{ fa : Null<{ name : String }>, e : Null<Unknown<53>> }]
									[FAnon:Null<{ name : String }>] fa:Null<{ name : String }>
								[FAnon:String] name:String
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Const:String] ""
									+
									[Local obj(24341):String:String]
								+
								[Const:String] "."
							+
							[Local fieldName(24342):String:String]
			[Return:Dynamic] [Const:String] "field"

	function convertGuardOperator[Function:(op : String) -> String]
		[Arg:String] [Local op(24347):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (op) {
	case "==":
		"==";	
	case "!=":
		"!=";	
	case ">":
		">";	
	case "<":
		"<";	
	case ">=":
		">=";	
	case "<=":
		"<=";	
	case "&&":
		"and";	
	case "||":
		"or";	
	case "+":
		"+";	
	case "-":
		"-";	
	case "*":
		"*";	
	case "/":
		"/";	
	case "%":
		"rem";	
	case _:
		op;	
})
					[Switch:String]
						[Local op(24347):String:String]
						[Case:String]
							[Const:String] "!="
							[Block:String] [Block:String] [Const:String] "!="
						[Case:String]
							[Const:String] "%"
							[Block:String] [Block:String] [Const:String] "rem"
						[Case:String]
							[Const:String] "&&"
							[Block:String] [Block:String] [Const:String] "and"
						[Case:String]
							[Const:String] "*"
							[Block:String] [Block:String] [Const:String] "*"
						[Case:String]
							[Const:String] "+"
							[Block:String] [Block:String] [Const:String] "+"
						[Case:String]
							[Const:String] "-"
							[Block:String] [Block:String] [Const:String] "-"
						[Case:String]
							[Const:String] "/"
							[Block:String] [Block:String] [Const:String] "/"
						[Case:String]
							[Const:String] "<"
							[Block:String] [Block:String] [Const:String] "<"
						[Case:String]
							[Const:String] "<="
							[Block:String] [Block:String] [Const:String] "<="
						[Case:String]
							[Const:String] "=="
							[Block:String] [Block:String] [Const:String] "=="
						[Case:String]
							[Const:String] ">"
							[Block:String] [Block:String] [Const:String] ">"
						[Case:String]
							[Const:String] ">="
							[Block:String] [Block:String] [Const:String] ">="
						[Case:String]
							[Const:String] "||"
							[Block:String] [Block:String] [Const:String] "or"
						[Default:String] [Block:String] [Local op(24347):String:String]

	function convertUnaryOperator[Function:(op : String) -> String]
		[Arg:String] [Local op(24353):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (op) {
	case "!":
		"not ";	
	case "-":
		"-";	
	case "+":
		"+";	
	case _:
		op;	
})
					[Switch:String]
						[Local op(24353):String:String]
						[Case:String]
							[Const:String] "!"
							[Block:String] [Block:String] [Const:String] "not "
						[Case:String]
							[Const:String] "+"
							[Block:String] [Block:String] [Const:String] "+"
						[Case:String]
							[Const:String] "-"
							[Block:String] [Block:String] [Const:String] "-"
						[Default:String] [Block:String] [Local op(24353):String:String]

	function convertGuardFunction[Function:(funcName : String) -> String]
		[Arg:String] [Local funcName(24337):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (funcName) {
	case "isString":
		"is_binary";	
	case "isBinary":
		"is_binary";	
	case "isInt":
		"is_integer";	
	case "isFloat":
		"is_float";	
	case "isBool":
		"is_boolean";	
	case "isArray":
		"is_list";	
	case "isList":
		"is_list";	
	case "isMap":
		"is_map";	
	case "isAtom":
		"is_atom";	
	case "isTuple":
		"is_tuple";	
	case "isFunction":
		"is_function";	
	case "isNil":
		"is_nil";	
	case "isNumber":
		"is_number";	
	case "isPort":
		"is_port";	
	case "isPid":
		"is_pid";	
	case "isReference":
		"is_reference";	
	case "length":
		"length";	
	case "size":
		"byte_size";	
	case "byteSize":
		"byte_size";	
	case "tupleSize":
		"tuple_size";	
	case "mapSize":
		"map_size";	
	case "bitSize":
		"bit_size";	
	case "abs":
		"abs";	
	case "round":
		"round";	
	case "trunc":
		"trunc";	
	case "floor":
		"floor";	
	case "ceil":
		"ceil";	
	case "elem":
		"elem";	
	case "hd":
		"hd";	
	case "tl":
		"tl";	
	case "div":
		"div";	
	case "rem":
		"rem";	
	case _:
		NamingHelper.getElixirFunctionName(funcName);	
})
					[Switch:String]
						[Local funcName(24337):String:String]
						[Case:String]
							[Const:String] "abs"
							[Block:String] [Block:String] [Const:String] "abs"
						[Case:String]
							[Const:String] "bitSize"
							[Block:String] [Block:String] [Const:String] "bit_size"
						[Case:String]
							[Const:String] "byteSize"
							[Block:String] [Block:String] [Const:String] "byte_size"
						[Case:String]
							[Const:String] "ceil"
							[Block:String] [Block:String] [Const:String] "ceil"
						[Case:String]
							[Const:String] "div"
							[Block:String] [Block:String] [Const:String] "div"
						[Case:String]
							[Const:String] "elem"
							[Block:String] [Block:String] [Const:String] "elem"
						[Case:String]
							[Const:String] "floor"
							[Block:String] [Block:String] [Const:String] "floor"
						[Case:String]
							[Const:String] "hd"
							[Block:String] [Block:String] [Const:String] "hd"
						[Case:String]
							[Const:String] "isArray"
							[Block:String] [Block:String] [Const:String] "is_list"
						[Case:String]
							[Const:String] "isAtom"
							[Block:String] [Block:String] [Const:String] "is_atom"
						[Case:String]
							[Const:String] "isBinary"
							[Block:String] [Block:String] [Const:String] "is_binary"
						[Case:String]
							[Const:String] "isBool"
							[Block:String] [Block:String] [Const:String] "is_boolean"
						[Case:String]
							[Const:String] "isFloat"
							[Block:String] [Block:String] [Const:String] "is_float"
						[Case:String]
							[Const:String] "isFunction"
							[Block:String] [Block:String] [Const:String] "is_function"
						[Case:String]
							[Const:String] "isInt"
							[Block:String] [Block:String] [Const:String] "is_integer"
						[Case:String]
							[Const:String] "isList"
							[Block:String] [Block:String] [Const:String] "is_list"
						[Case:String]
							[Const:String] "isMap"
							[Block:String] [Block:String] [Const:String] "is_map"
						[Case:String]
							[Const:String] "isNil"
							[Block:String] [Block:String] [Const:String] "is_nil"
						[Case:String]
							[Const:String] "isNumber"
							[Block:String] [Block:String] [Const:String] "is_number"
						[Case:String]
							[Const:String] "isPid"
							[Block:String] [Block:String] [Const:String] "is_pid"
						[Case:String]
							[Const:String] "isPort"
							[Block:String] [Block:String] [Const:String] "is_port"
						[Case:String]
							[Const:String] "isReference"
							[Block:String] [Block:String] [Const:String] "is_reference"
						[Case:String]
							[Const:String] "isString"
							[Block:String] [Block:String] [Const:String] "is_binary"
						[Case:String]
							[Const:String] "isTuple"
							[Block:String] [Block:String] [Const:String] "is_tuple"
						[Case:String]
							[Const:String] "length"
							[Block:String] [Block:String] [Const:String] "length"
						[Case:String]
							[Const:String] "mapSize"
							[Block:String] [Block:String] [Const:String] "map_size"
						[Case:String]
							[Const:String] "rem"
							[Block:String] [Block:String] [Const:String] "rem"
						[Case:String]
							[Const:String] "round"
							[Block:String] [Block:String] [Const:String] "round"
						[Case:String]
							[Const:String] "size"
							[Block:String] [Block:String] [Const:String] "byte_size"
						[Case:String]
							[Const:String] "tl"
							[Block:String] [Block:String] [Const:String] "tl"
						[Case:String]
							[Const:String] "trunc"
							[Block:String] [Block:String] [Const:String] "trunc"
						[Case:String]
							[Const:String] "tupleSize"
							[Block:String] [Block:String] [Const:String] "tuple_size"
						[Default:String]
							[Block:String]
								[Call:String]
									[Field:(haxeName : String) -> String]
										[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
										[FStatic:(haxeName : String) -> String]
											reflaxe.elixir.helpers.NamingHelper
											getElixirFunctionName:(haxeName : String) -> String
									[Local funcName(24337):String:String]

	function isLogicalOperator[Function:(op : String) -> Bool]
		[Arg:String] [Local op(24349):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local op(24349):String:String]
						==
						[Const:String] "&&"
					||
					[Binop:Bool]
						[Local op(24349):String:String]
						==
						[Const:String] "||"

	function extractFunctionName[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24325):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24325):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "unknown"
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (getExprType(expr)) {
	case "TField":
		var field = expr.expr;
		if (field.fa != null && field.fa.name != null) {
			field.fa.name;
		} else {
			"func";
		};	
	case "TLocal":
		var local = expr.expr;
		if (local.v != null && local.v.name != null) {
			local.v.name;
		} else {
			"func";
		};	
	case _:
		"func";	
})
					[Block:String]
						[Var `(24329):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local expr(24325):Dynamic:Dynamic]
						[Switch:String]
							[Local `(24329):String:String]
							[Case:String]
								[Const:String] "TField"
								[Block:String]
									[Block:String]
										[Var field(24330):{ fa : Null<{ name : Null<String> }> }]
											[Field:Dynamic]
												[Local expr(24325):Dynamic:Dynamic]
												[FDynamic:Dynamic] expr
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Field:Null<{ name : Null<String> }>]
														[Local field(24330):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
														[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
													!=
													[Const:Null<{ name : Null<String> }>] null
												&&
												[Binop:Bool]
													[Field:Null<String>]
														[Field:Null<{ name : Null<String> }>]
															[Local field(24330):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
															[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
														[FAnon:Null<String>] name:Null<String>
													!=
													[Const:Null<String>] null
											[Then:Null<String>] [Block:Null<String>]
												[Field:Null<String>]
													[Field:Null<{ name : Null<String> }>]
														[Local field(24330):{ fa : Null<{ name : Null<String> }> }:{ fa : Null<{ name : Null<String> }> }]
														[FAnon:Null<{ name : Null<String> }>] fa:Null<{ name : Null<String> }>
													[FAnon:Null<String>] name:Null<String>
											[Else:String] [Block:String] [Const:String] "func"
							[Case:String]
								[Const:String] "TLocal"
								[Block:String]
									[Block:String]
										[Var local(24331):{ v : Null<{ name : Null<String> }> }]
											[Field:Dynamic]
												[Local expr(24325):Dynamic:Dynamic]
												[FDynamic:Dynamic] expr
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Field:Null<{ name : Null<String> }>]
														[Local local(24331):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
														[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
													!=
													[Const:Null<{ name : Null<String> }>] null
												&&
												[Binop:Bool]
													[Field:Null<String>]
														[Field:Null<{ name : Null<String> }>]
															[Local local(24331):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
															[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
														[FAnon:Null<String>] name:Null<String>
													!=
													[Const:Null<String>] null
											[Then:Null<String>] [Block:Null<String>]
												[Field:Null<String>]
													[Field:Null<{ name : Null<String> }>]
														[Local local(24331):{ v : Null<{ name : Null<String> }> }:{ v : Null<{ name : Null<String> }> }]
														[FAnon:Null<{ name : Null<String> }>] v:Null<{ name : Null<String> }>
													[FAnon:Null<String>] name:Null<String>
											[Else:String] [Block:String] [Const:String] "func"
							[Default:String] [Block:String] [Const:String] "func"

	@:value({ op : "and" })
	public function compileMultipleGuards[Function:(guards : Array<Dynamic>, ?op : String) -> String]
		[Arg:Array<Dynamic>] [Local guards(24381):Array<Dynamic>]
		[Arg:String]
			[Local op(24382):String]
			[Const:String] "and"
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
						==
						[Const:Array<Dynamic>] null
					||
					[Binop:Bool]
						[Field:Int]
							[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
						==
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
						[FInstance:Int]
							Array<Dynamic>
							length:Int
					==
					[Const:Int] 1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(guardExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(guardExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									compileGuard:(guardExpr : Dynamic) -> String
							[Array:Dynamic]
								[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
								[Const:Int] 0
			[Var compiledGuards(24383):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(24386):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(24386):Int:Int]
						<
						[Field:Int]
							[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var guard(24384):Dynamic]
							[Array:Dynamic]
								[Local guards(24381):Array<Dynamic>:Array<Dynamic>]
								[Local `(24386):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(24386):Int:Int]
						[Var compiled(24385):String]
							[Call:String]
								[Field:(guardExpr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(guardExpr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										compileGuard:(guardExpr : Dynamic) -> String
								[Local guard(24384):Dynamic:Dynamic]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local compiled(24385):String:String]
									!=
									[Const:String] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local compiled(24385):String:String]
										[FInstance:Int]
											String
											length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local compiledGuards(24383):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Local compiled(24385):String:String]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local compiledGuards(24383):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local compiledGuards(24383):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					==
					[Const:Int] 1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Array:String]
							[Local compiledGuards(24383):Array<String>:Array<String>]
							[Const:Int] 0
			[Var elixirOp(24387):String]
				[Call:String]
					[Field:(op : String) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(op : String) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							convertGuardOperator:(op : String) -> String
					[Local op(24382):String:String]
			[Return:Dynamic]
				[Call:String]
					[Field:(sep : String) -> String]
						[Local compiledGuards(24383):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Binop:String]
						[Binop:String]
							[Const:String] " "
							+
							[Local elixirOp(24387):String:String]
						+
						[Const:String] " "

	public function isValidGuardExpression[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24388):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local expr(24388):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (getExprType(expr)) {
	case "TBinop":
		true;	
	case "TUnop":
		true;	
	case "TCall":
		isGuardFunction(expr);	
	case "TLocal":
		true;	
	case "TConst":
		true;	
	case "TField":
		true;	
	case "TParenthesis":
		true;	
	case _:
		false;	
})
					[Block:Bool]
						[Var `(24394):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local expr(24388):Dynamic:Dynamic]
						[Switch:Bool]
							[Local `(24394):String:String]
							[Case:Bool]
								[Const:String] "TBinop"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:String] "TCall"
								[Block:Bool]
									[Block:Bool]
										[Call:Bool]
											[Field:(callExpr : Dynamic) -> Bool]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(callExpr : Dynamic) -> Bool]
													reflaxe.elixir.helpers.GuardCompiler
													isGuardFunction:(callExpr : Dynamic) -> Bool
											[Local expr(24388):Dynamic:Dynamic]
							[Case:Bool]
								[Const:String] "TConst"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:String] "TField"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:String] "TLocal"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:String] "TParenthesis"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Case:Bool]
								[Const:String] "TUnop"
								[Block:Bool] [Block:Bool] [Const:Bool] true
							[Default:Bool] [Block:Bool] [Const:Bool] false

	function isGuardFunction[Function:(callExpr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local callExpr(24389):Dynamic]
		[Block:Dynamic]
			[Var funcName(24390):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							extractFunctionName:(expr : Dynamic) -> String
					[Field:Dynamic]
						[Field:Dynamic]
							[Local callExpr(24389):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
						[FDynamic:Dynamic] e
			[Var allowedGuardFunctions(24391):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "is_atom"
					[Const:String] "is_binary"
					[Const:String] "is_boolean"
					[Const:String] "is_float"
					[Const:String] "is_function"
					[Const:String] "is_integer"
					[Const:String] "is_list"
					[Const:String] "is_map"
					[Const:String] "is_nil"
					[Const:String] "is_tuple"
					[Const:String] "is_number"
					[Const:String] "is_port"
					[Const:String] "is_pid"
					[Const:String] "is_reference"
					[Const:String] "length"
					[Const:String] "byte_size"
					[Const:String] "tuple_size"
					[Const:String] "map_size"
					[Const:String] "bit_size"
					[Const:String] "abs"
					[Const:String] "round"
					[Const:String] "trunc"
					[Const:String] "floor"
					[Const:String] "ceil"
					[Const:String] "div"
					[Const:String] "rem"
					[Const:String] "hd"
					[Const:String] "tl"
					[Const:String] "elem"
					[Const:String] "in"
					[Const:String] "not"
					[Const:String] "and"
					[Const:String] "or"
			[Var elixirFuncName(24392):String]
				[Call:String]
					[Field:(funcName : String) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(funcName : String) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							convertGuardFunction:(funcName : String) -> String
					[Local funcName(24390):String:String]
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Int]
						[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
							[Local allowedGuardFunctions(24391):Array<String>:Array<String>]
							[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
								Array<String>
								indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
						[Local elixirFuncName(24392):String:String]
						[Const:Null<Int>] null
					>=
					[Const:Int] 0

	@:value({ context : null })
	public function compileOptimizedGuard[Function:(guardExpr : Dynamic, ?context : Null<Dynamic>) -> String]
		[Arg:Dynamic] [Local guardExpr(24395):Dynamic]
		[Arg:Null<Dynamic>]
			[Local context(24396):Null<Dynamic>]
			[Const:Null<Dynamic>] null
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local guardExpr(24395):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] ""
			[Var optimized(24421):Unknown<54>]
				[Call:Dynamic]
					[Field:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
							reflaxe.elixir.helpers.GuardCompiler
							optimizeGuardExpression:(guardExpr : Dynamic, context : Dynamic) -> Dynamic
					[Local guardExpr(24395):Dynamic:Dynamic]
					[Local context(24396):Null<Dynamic>:Null<Dynamic>]
			[If:Void]
				[Binop:Bool]
					[Local optimized(24421):Unknown<54>:Unknown<54>]
					!=
					[Local guardExpr(24395):Dynamic:Dynamic]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(guardExpr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(guardExpr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									compileGuard:(guardExpr : Dynamic) -> String
							[Local optimized(24421):Unknown<54>:Unknown<54>]
			[Return:Dynamic]
				[Call:String]
					[Field:(guardExpr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(guardExpr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							compileGuard:(guardExpr : Dynamic) -> String
					[Local guardExpr(24395):Dynamic:Dynamic]

	function optimizeGuardExpression[Function:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local guardExpr(24397):Dynamic]
		[Arg:Dynamic] [Local context(24398):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local guardExpr(24397):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local guardExpr(24397):Dynamic:Dynamic]
			[Return:Dynamic]
				[Meta:Dynamic]
					:ast(switch (getExprType(guardExpr)) {
	case "TBinop":
		optimizeBinaryGuard(guardExpr, context);	
	case "TCall":
		optimizeFunctionGuard(guardExpr, context);	
	case _:
		guardExpr;	
})
					[Block:Dynamic]
						[Var `(24420):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local guardExpr(24397):Dynamic:Dynamic]
						[Switch:Dynamic]
							[Local `(24420):String:String]
							[Case:Dynamic]
								[Const:String] "TBinop"
								[Block:Dynamic]
									[Block:Dynamic]
										[Call:Dynamic]
											[Field:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
													reflaxe.elixir.helpers.GuardCompiler
													optimizeBinaryGuard:(guardExpr : Dynamic, context : Dynamic) -> Dynamic
											[Local guardExpr(24397):Dynamic:Dynamic]
											[Local context(24398):Dynamic:Dynamic]
							[Case:Dynamic]
								[Const:String] "TCall"
								[Block:Dynamic]
									[Block:Dynamic]
										[Call:Dynamic]
											[Field:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
													reflaxe.elixir.helpers.GuardCompiler
													optimizeFunctionGuard:(guardExpr : Dynamic, context : Dynamic) -> Dynamic
											[Local guardExpr(24397):Dynamic:Dynamic]
											[Local context(24398):Dynamic:Dynamic]
							[Default:Dynamic] [Block:Dynamic] [Local guardExpr(24397):Dynamic:Dynamic]

	function optimizeBinaryGuard[Function:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local guardExpr(24399):Dynamic]
		[Arg:Dynamic] [Local context(24400):Dynamic]
		[Block:Dynamic]
			[Var binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }]
				[Field:Dynamic]
					[Local guardExpr(24399):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Call:Bool]
					[Field:(e1 : Dynamic, e2 : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(e1 : Dynamic, e2 : Dynamic) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							areConstantOperands:(e1 : Dynamic, e2 : Dynamic) -> Bool
					[Field:Unknown<55>]
						[Local binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }:{ e2 : Unknown<56>, e1 : Unknown<55> }]
						[FAnon:Unknown<55>] e1:Unknown<55>
					[Field:Unknown<56>]
						[Local binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }:{ e2 : Unknown<56>, e1 : Unknown<55> }]
						[FAnon:Unknown<56>] e2:Unknown<56>
				[Then:Void] [Block:Void]
					[Var result(24405):Null<Unknown<57>>]
						[Call:Dynamic]
							[Field:(binop : Dynamic) -> Dynamic]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(binop : Dynamic) -> Dynamic]
									reflaxe.elixir.helpers.GuardCompiler
									evaluateConstantBinaryOp:(binop : Dynamic) -> Dynamic
							[Local binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }:{ e2 : Unknown<56>, e1 : Unknown<55> }]
					[If:Void]
						[Binop:Bool]
							[Local result(24405):Null<Unknown<57>>:Null<Unknown<57>>]
							!=
							[Const:Null<Unknown<57>>] null
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Call:Dynamic]
									[Field:(value : Dynamic) -> Dynamic]
										[Const:reflaxe.elixir.helpers.GuardCompiler] this
										[FInstance:(value : Dynamic) -> Dynamic]
											reflaxe.elixir.helpers.GuardCompiler
											createConstantExpression:(value : Dynamic) -> Dynamic
									[Local result(24405):Null<Unknown<57>>:Null<Unknown<57>>]
			[If:Void]
				[Call:Bool]
					[Field:(binop : Dynamic) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(binop : Dynamic) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							isRangePattern:(binop : Dynamic) -> Bool
					[Local binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }:{ e2 : Unknown<56>, e1 : Unknown<55> }]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:Dynamic]
							[Field:(binop : Dynamic) -> Dynamic]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(binop : Dynamic) -> Dynamic]
									reflaxe.elixir.helpers.GuardCompiler
									optimizeToRange:(binop : Dynamic) -> Dynamic
							[Local binop(24401):{ e2 : Unknown<56>, e1 : Unknown<55> }:{ e2 : Unknown<56>, e1 : Unknown<55> }]
			[Return:Dynamic] [Local guardExpr(24399):Dynamic:Dynamic]

	function optimizeFunctionGuard[Function:(guardExpr : Dynamic, context : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local guardExpr(24411):Dynamic]
		[Arg:Dynamic] [Local context(24412):Dynamic]
		[Block:Dynamic]
			[Var call(24413):{ e : Unknown<58> }]
				[Field:Dynamic]
					[Local guardExpr(24411):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var funcName(24414):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							extractFunctionName:(expr : Dynamic) -> String
					[Field:Unknown<58>]
						[Local call(24413):{ e : Unknown<58> }:{ e : Unknown<58> }]
						[FAnon:Unknown<58>] e:Unknown<58>
			[If:Void]
				[Call:Bool]
					[Field:(funcName : String) -> Bool]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(funcName : String) -> Bool]
							reflaxe.elixir.helpers.GuardCompiler
							isTypeCheckFunction:(funcName : String) -> Bool
					[Local funcName(24414):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:Dynamic]
							[Field:(call : Dynamic, context : Dynamic) -> Dynamic]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(call : Dynamic, context : Dynamic) -> Dynamic]
									reflaxe.elixir.helpers.GuardCompiler
									optimizeTypeCheck:(call : Dynamic, context : Dynamic) -> Dynamic
							[Local call(24413):{ e : Unknown<58> }:{ e : Unknown<58> }]
							[Local context(24412):Dynamic:Dynamic]
			[Return:Dynamic] [Local guardExpr(24411):Dynamic:Dynamic]

	public function validateGuardExpression[Function:(guardExpr : Dynamic) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24422):Dynamic]
		[Block:Dynamic]
			[Var warnings(24423):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Local guardExpr(24422):Dynamic:Dynamic]
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local warnings(24423):Array<String>:Array<String>]
			[Return:Dynamic]
				[Meta:Array<String>]
					:ast(switch (getExprType(guardExpr)) {
	case "TBinop":
		validateBinaryGuard(guardExpr, warnings);	
	case "TUnop":
		validateUnaryGuard(guardExpr, warnings);	
	case "TCall":
		validateFunctionGuard(guardExpr, warnings);	
	case "TLocal":
		validateVariableGuard(guardExpr, warnings);	
	case "TConst":
		validateConstantGuard(guardExpr, warnings);	
	case _:
		warnings.push("Unsupported guard expression type: " + getExprType(guardExpr));
		warnings;	
})
					[Block:Array<String>]
						[Var `(24446):String]
							[Call:String]
								[Field:(expr : Dynamic) -> String]
									[Const:reflaxe.elixir.helpers.GuardCompiler] this
									[FInstance:(expr : Dynamic) -> String]
										reflaxe.elixir.helpers.GuardCompiler
										getExprType:(expr : Dynamic) -> String
								[Local guardExpr(24422):Dynamic:Dynamic]
						[Switch:Array<String>]
							[Local `(24446):String:String]
							[Case:Array<String>]
								[Const:String] "TBinop"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateBinaryGuard:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local guardExpr(24422):Dynamic:Dynamic]
											[Local warnings(24423):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "TCall"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateFunctionGuard:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local guardExpr(24422):Dynamic:Dynamic]
											[Local warnings(24423):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "TConst"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateConstantGuard:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local guardExpr(24422):Dynamic:Dynamic]
											[Local warnings(24423):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "TLocal"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateVariableGuard:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local guardExpr(24422):Dynamic:Dynamic]
											[Local warnings(24423):Array<String>:Array<String>]
							[Case:Array<String>]
								[Const:String] "TUnop"
								[Block:Array<String>]
									[Block:Array<String>]
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateUnaryGuard:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>
											[Local guardExpr(24422):Dynamic:Dynamic]
											[Local warnings(24423):Array<String>:Array<String>]
							[Default:Array<String>]
								[Block:Array<String>]
									[Call:Int]
										[Field:(x : String) -> Int]
											[Local warnings(24423):Array<String>:Array<String>]
											[FInstance:(x : String) -> Int]
												Array<String>
												push:(x : Array.T) -> Int
										[Binop:String]
											[Const:String] "Unsupported guard expression type: "
											+
											[Call:String]
												[Field:(expr : Dynamic) -> String]
													[Const:reflaxe.elixir.helpers.GuardCompiler] this
													[FInstance:(expr : Dynamic) -> String]
														reflaxe.elixir.helpers.GuardCompiler
														getExprType:(expr : Dynamic) -> String
												[Local guardExpr(24422):Dynamic:Dynamic]
									[Local warnings(24423):Array<String>:Array<String>]

	function validateBinaryGuard[Function:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24424):Dynamic]
		[Arg:Array<String>] [Local warnings(24425):Array<String>]
		[Block:Dynamic]
			[Var binop(24426):{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }]
				[Field:Dynamic]
					[Local guardExpr(24424):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Call:Bool]
						[Field:(op : String) -> Bool]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(op : String) -> Bool]
								reflaxe.elixir.helpers.GuardCompiler
								isAllowedGuardOperator:(op : String) -> Bool
						[Field:String]
							[Local binop(24426):{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }:{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }]
							[FAnon:String] op:String
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(24425):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Binop:String]
								[Const:String] "Operator \""
								+
								[Field:String]
									[Local binop(24426):{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }:{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }]
									[FAnon:String] op:String
							+
							[Const:String] "\" is not allowed in Elixir guards"
			[Binop:Array<String>]
				[Local warnings(24425):Array<String>:Array<String>]
				=
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local warnings(24425):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Call:Array<String>]
						[Field:(guardExpr : Dynamic) -> Array<String>]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(guardExpr : Dynamic) -> Array<String>]
								reflaxe.elixir.helpers.GuardCompiler
								validateGuardExpression:(guardExpr : Dynamic) -> Array<String>
						[Field:Unknown<59>]
							[Local binop(24426):{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }:{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }]
							[FAnon:Unknown<59>] e1:Unknown<59>
			[Binop:Array<String>]
				[Local warnings(24425):Array<String>:Array<String>]
				=
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local warnings(24425):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Call:Array<String>]
						[Field:(guardExpr : Dynamic) -> Array<String>]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(guardExpr : Dynamic) -> Array<String>]
								reflaxe.elixir.helpers.GuardCompiler
								validateGuardExpression:(guardExpr : Dynamic) -> Array<String>
						[Field:Unknown<60>]
							[Local binop(24426):{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }:{ op : String, e2 : Unknown<60>, e1 : Unknown<59> }]
							[FAnon:Unknown<60>] e2:Unknown<60>
			[Return:Dynamic] [Local warnings(24425):Array<String>:Array<String>]

	function validateUnaryGuard[Function:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24429):Dynamic]
		[Arg:Array<String>] [Local warnings(24430):Array<String>]
		[Block:Dynamic]
			[Var unop(24431):{ op : String, e : Unknown<61> }]
				[Field:Dynamic]
					[Local guardExpr(24429):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Call:Bool]
						[Field:(op : String) -> Bool]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(op : String) -> Bool]
								reflaxe.elixir.helpers.GuardCompiler
								isAllowedGuardUnaryOperator:(op : String) -> Bool
						[Field:String]
							[Local unop(24431):{ op : String, e : Unknown<61> }:{ op : String, e : Unknown<61> }]
							[FAnon:String] op:String
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(24430):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Binop:String]
								[Const:String] "Unary operator \""
								+
								[Field:String]
									[Local unop(24431):{ op : String, e : Unknown<61> }:{ op : String, e : Unknown<61> }]
									[FAnon:String] op:String
							+
							[Const:String] "\" is not allowed in Elixir guards"
			[Binop:Array<String>]
				[Local warnings(24430):Array<String>:Array<String>]
				=
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local warnings(24430):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Call:Array<String>]
						[Field:(guardExpr : Dynamic) -> Array<String>]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(guardExpr : Dynamic) -> Array<String>]
								reflaxe.elixir.helpers.GuardCompiler
								validateGuardExpression:(guardExpr : Dynamic) -> Array<String>
						[Field:Unknown<61>]
							[Local unop(24431):{ op : String, e : Unknown<61> }:{ op : String, e : Unknown<61> }]
							[FAnon:Unknown<61>] e:Unknown<61>
			[Return:Dynamic] [Local warnings(24430):Array<String>:Array<String>]

	function validateFunctionGuard[Function:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24434):Dynamic]
		[Arg:Array<String>] [Local warnings(24435):Array<String>]
		[Block:Dynamic]
			[Var call(24436):{ el : Null<Array<Dynamic>>, e : Unknown<62> }]
				[Field:Dynamic]
					[Local guardExpr(24434):Dynamic:Dynamic]
					[FDynamic:Dynamic] expr
			[Var funcName(24437):String]
				[Call:String]
					[Field:(expr : Dynamic) -> String]
						[Const:reflaxe.elixir.helpers.GuardCompiler] this
						[FInstance:(expr : Dynamic) -> String]
							reflaxe.elixir.helpers.GuardCompiler
							extractFunctionName:(expr : Dynamic) -> String
					[Field:Unknown<62>]
						[Local call(24436):{ el : Null<Array<Dynamic>>, e : Unknown<62> }:{ el : Null<Array<Dynamic>>, e : Unknown<62> }]
						[FAnon:Unknown<62>] e:Unknown<62>
			[If:Void]
				[Unop:Bool]
					!
					Prefix
					[Call:Bool]
						[Field:(callExpr : Dynamic) -> Bool]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(callExpr : Dynamic) -> Bool]
								reflaxe.elixir.helpers.GuardCompiler
								isGuardFunction:(callExpr : Dynamic) -> Bool
						[Local call(24436):{ el : Null<Array<Dynamic>>, e : Unknown<62> }:{ el : Null<Array<Dynamic>>, e : Unknown<62> }]
				[Then:Int] [Block:Int]
					[Call:Int]
						[Field:(x : String) -> Int]
							[Local warnings(24435):Array<String>:Array<String>]
							[FInstance:(x : String) -> Int]
								Array<String>
								push:(x : Array.T) -> Int
						[Binop:String]
							[Binop:String]
								[Const:String] "Function \""
								+
								[Local funcName(24437):String:String]
							+
							[Const:String] "\" is not allowed in Elixir guards"
			[If:Void]
				[Binop:Bool]
					[Field:Null<Array<Dynamic>>]
						[Local call(24436):{ el : Null<Array<Dynamic>>, e : Unknown<62> }:{ el : Null<Array<Dynamic>>, e : Unknown<62> }]
						[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
					!=
					[Const:Null<Array<Dynamic>>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(24439):Int] [Const:Int] 0
						[Var `(24440):Array<Dynamic>]
							[Parenthesis:Array<Dynamic>]
								[Cast:Array<Dynamic>]
									[Field:Null<Array<Dynamic>>]
										[Local call(24436):{ el : Null<Array<Dynamic>>, e : Unknown<62> }:{ el : Null<Array<Dynamic>>, e : Unknown<62> }]
										[FAnon:Null<Array<Dynamic>>] el:Null<Array<Dynamic>>
						[While:Void]
							[Binop:Bool]
								[Local `(24439):Int:Int]
								<
								[Field:Int]
									[Local `(24440):Array<Dynamic>:Array<Dynamic>]
									[FInstance:Int]
										Array<Dynamic>
										length:Int
							[Block:Void]
								[Var arg(24438):Dynamic]
									[Array:Dynamic]
										[Local `(24440):Array<Dynamic>:Array<Dynamic>]
										[Local `(24439):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(24439):Int:Int]
								[Binop:Array<String>]
									[Local warnings(24435):Array<String>:Array<String>]
									=
									[Call:Array<String>]
										[Field:(a : Array<String>) -> Array<String>]
											[Local warnings(24435):Array<String>:Array<String>]
											[FInstance:(a : Array<String>) -> Array<String>]
												Array<String>
												concat:(a : Array<Array.T>) -> Array<Array.T>
										[Call:Array<String>]
											[Field:(guardExpr : Dynamic) -> Array<String>]
												[Const:reflaxe.elixir.helpers.GuardCompiler] this
												[FInstance:(guardExpr : Dynamic) -> Array<String>]
													reflaxe.elixir.helpers.GuardCompiler
													validateGuardExpression:(guardExpr : Dynamic) -> Array<String>
											[Local arg(24438):Dynamic:Dynamic]
			[Return:Dynamic] [Local warnings(24435):Array<String>:Array<String>]

	function validateVariableGuard[Function:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24441):Dynamic]
		[Arg:Array<String>] [Local warnings(24442):Array<String>]
		[Block:Dynamic] [Return:Dynamic] [Local warnings(24442):Array<String>:Array<String>]

	function validateConstantGuard[Function:(guardExpr : Dynamic, warnings : Array<String>) -> Array<String>]
		[Arg:Dynamic] [Local guardExpr(24443):Dynamic]
		[Arg:Array<String>] [Local warnings(24444):Array<String>]
		[Block:Dynamic] [Return:Dynamic] [Local warnings(24444):Array<String>:Array<String>]

	function areConstantOperands[Function:(e1 : Dynamic, e2 : Dynamic) -> Bool]
		[Arg:Dynamic] [Local e1(24402):Dynamic]
		[Arg:Dynamic] [Local e2(24403):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									getExprType:(expr : Dynamic) -> String
							[Local e1(24402):Dynamic:Dynamic]
						==
						[Const:String] "TConst"
					&&
					[Binop:Bool]
						[Call:String]
							[Field:(expr : Dynamic) -> String]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(expr : Dynamic) -> String]
									reflaxe.elixir.helpers.GuardCompiler
									getExprType:(expr : Dynamic) -> String
							[Local e2(24403):Dynamic:Dynamic]
						==
						[Const:String] "TConst"

	function evaluateConstantBinaryOp[Function:(binop : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local binop(24404):Dynamic]
		[Block:Dynamic] [Return:Dynamic] [Const:Dynamic] null

	function createConstantExpression[Function:(value : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local value(24406):Dynamic]
		[Block:Dynamic] [Return:Dynamic] [Const:Dynamic] null

	function isRangePattern[Function:(binop : Dynamic) -> Bool]
		[Arg:Dynamic] [Local binop(24407):Dynamic]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Field:Dynamic]
								[Local binop(24407):Dynamic:Dynamic]
								[FDynamic:Dynamic] op
							==
							[Const:String] "&&"
						&&
						[Call:Bool]
							[Field:(expr : Dynamic) -> Bool]
								[Const:reflaxe.elixir.helpers.GuardCompiler] this
								[FInstance:(expr : Dynamic) -> Bool]
									reflaxe.elixir.helpers.GuardCompiler
									isRangeComparison:(expr : Dynamic) -> Bool
							[Field:Dynamic]
								[Local binop(24407):Dynamic:Dynamic]
								[FDynamic:Dynamic] e1
					&&
					[Call:Bool]
						[Field:(expr : Dynamic) -> Bool]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> Bool]
								reflaxe.elixir.helpers.GuardCompiler
								isRangeComparison:(expr : Dynamic) -> Bool
						[Field:Dynamic]
							[Local binop(24407):Dynamic:Dynamic]
							[FDynamic:Dynamic] e2

	function isRangeComparison[Function:(expr : Dynamic) -> Bool]
		[Arg:Dynamic] [Local expr(24408):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Call:String]
						[Field:(expr : Dynamic) -> String]
							[Const:reflaxe.elixir.helpers.GuardCompiler] this
							[FInstance:(expr : Dynamic) -> String]
								reflaxe.elixir.helpers.GuardCompiler
								getExprType:(expr : Dynamic) -> String
						[Local expr(24408):Dynamic:Dynamic]
					==
					[Const:String] "TBinop"
				[Then:Dynamic] [Block:Dynamic]
					[Var op(24409):String]
						[Field:Dynamic]
							[Field:Dynamic]
								[Local expr(24408):Dynamic:Dynamic]
								[FDynamic:Dynamic] expr
							[FDynamic:Dynamic] op
					[Return:Dynamic]
						[Binop:Bool]
							[Binop:Bool]
								[Binop:Bool]
									[Binop:Bool]
										[Local op(24409):String:String]
										==
										[Const:String] ">="
									||
									[Binop:Bool]
										[Local op(24409):String:String]
										==
										[Const:String] "<="
								||
								[Binop:Bool]
									[Local op(24409):String:String]
									==
									[Const:String] ">"
							||
							[Binop:Bool]
								[Local op(24409):String:String]
								==
								[Const:String] "<"
			[Return:Dynamic] [Const:Bool] false

	function optimizeToRange[Function:(binop : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local binop(24410):Dynamic]
		[Block:Dynamic] [Return:Dynamic] [Local binop(24410):Dynamic:Dynamic]

	function isTypeCheckFunction[Function:(funcName : String) -> Bool]
		[Arg:String] [Local funcName(24415):String]
		[Block:Dynamic]
			[Var typeCheckFunctions(24416):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "isString"
					[Const:String] "isBinary"
					[Const:String] "isInt"
					[Const:String] "isFloat"
					[Const:String] "isBool"
					[Const:String] "isArray"
					[Const:String] "isList"
					[Const:String] "isMap"
					[Const:String] "isAtom"
					[Const:String] "isTuple"
					[Const:String] "isFunction"
					[Const:String] "isNil"
					[Const:String] "isNumber"
					[Const:String] "isPort"
					[Const:String] "isPid"
					[Const:String] "isReference"
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Int]
						[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
							[Local typeCheckFunctions(24416):Array<String>:Array<String>]
							[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
								Array<String>
								indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
						[Local funcName(24415):String:String]
						[Const:Null<Int>] null
					>=
					[Const:Int] 0

	function optimizeTypeCheck[Function:(call : Dynamic, context : Dynamic) -> Dynamic]
		[Arg:Dynamic] [Local call(24417):Dynamic]
		[Arg:Dynamic] [Local context(24418):Dynamic]
		[Block:Dynamic] [Return:Dynamic] [Local call(24417):Dynamic:Dynamic]

	function isAllowedGuardOperator[Function:(op : String) -> Bool]
		[Arg:String] [Local op(24427):String]
		[Block:Dynamic]
			[Var allowedOps(24428):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "=="
					[Const:String] "!="
					[Const:String] "==="
					[Const:String] "!=="
					[Const:String] ">"
					[Const:String] "<"
					[Const:String] ">="
					[Const:String] "<="
					[Const:String] "+"
					[Const:String] "-"
					[Const:String] "*"
					[Const:String] "/"
					[Const:String] "&&"
					[Const:String] "||"
					[Const:String] "%"
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Int]
						[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
							[Local allowedOps(24428):Array<String>:Array<String>]
							[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
								Array<String>
								indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
						[Local op(24427):String:String]
						[Const:Null<Int>] null
					>=
					[Const:Int] 0

	function isAllowedGuardUnaryOperator[Function:(op : String) -> Bool]
		[Arg:String] [Local op(24432):String]
		[Block:Dynamic]
			[Var allowedUnaryOps(24433):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "!"
					[Const:String] "-"
					[Const:String] "+"
			[Return:Dynamic]
				[Binop:Bool]
					[Call:Int]
						[Field:(x : String, ?fromIndex : Null<Int>) -> Int]
							[Local allowedUnaryOps(24433):Array<String>:Array<String>]
							[FInstance:(x : String, ?fromIndex : Null<Int>) -> Int]
								Array<String>
								indexOf:(x : Array.T, ?fromIndex : Null<Int>) -> Int
						[Local op(24432):String:String]
						[Const:Null<Int>] null
					>=
					[Const:Int] 0

	function getExprType[Function:(expr : Dynamic) -> String]
		[Arg:Dynamic] [Local expr(24285):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local expr(24285):Dynamic:Dynamic]
						==
						[Const:Dynamic] null
					||
					[Binop:Bool]
						[Field:Dynamic]
							[Local expr(24285):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
						==
						[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "null"
			[Return:Dynamic]
				[Call:String]
					[Field:(c : Class<Dynamic>) -> String]
						[TypeExpr Type:Class<Type>]
						[FStatic:(c : Class<Dynamic>) -> String]
							Type
							getClassName:(c : Class<Dynamic>) -> String
					[Call:Class<Unknown<63>>]
						[Field:(o : Unknown<63>) -> Class<Unknown<63>>]
							[TypeExpr Type:Class<Type>]
							[FStatic:(o : Unknown<63>) -> Class<Unknown<63>>]
								Type
								getClass:(o : getClass.T) -> Class<getClass.T>
						[Field:Dynamic]
							[Local expr(24285):Dynamic:Dynamic]
							[FDynamic:Dynamic] expr
}