@:nullSafety(Off)
class reflaxe.elixir.helpers.SchemaCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(25048):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.SchemaCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.SchemaCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(25048):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileSchemaClass[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25049):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(25050):Array<Dynamic>]
		[Arg:Array<Dynamic>] [Local funcFields(25051):Array<Dynamic>]
		[Block:Dynamic]
			[Var moduleName(25053):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.SchemaCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.SchemaCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.ElixirCompiler
							getModuleName:(classType : haxe.macro.ClassType) -> String
					[Local classType(25049):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var tableName(25068):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							extractTableName:(classType : haxe.macro.ClassType) -> String
					[Local classType(25049):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var result(25069):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local moduleName(25053):String:String]
					+
					[Const:String] " do\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Const:String] "  use Ecto.Schema\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Const:String] "  import Ecto.Changeset\n\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "  schema \""
						+
						[Local tableName(25068):String:String]
					+
					[Const:String] "\" do\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Call:String]
					[Field:(varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateSchemaFields:(varFields : Array<Dynamic>) -> String
					[Local varFields(25050):Array<Dynamic>:Array<Dynamic>]
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Const:String] "\n    timestamps()\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Const:String] "  end\n\n"
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateChangesetFunction:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String
					[Local classType(25049):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(25050):Array<Dynamic>:Array<Dynamic>]
			[Block:Void]
				[Var `(25149):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25149):Int:Int]
						<
						[Field:Int]
							[Local funcFields(25051):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var funcField(25121):Dynamic]
							[Array:Dynamic]
								[Local funcFields(25051):Array<Dynamic>:Array<Dynamic>]
								[Local `(25149):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25149):Int:Int]
						[If:Void]
							[Unop:Bool]
								!
								Prefix
								[Call:Bool]
									[Field:(name : String) -> Bool]
										[Const:reflaxe.elixir.helpers.SchemaCompiler] this
										[FInstance:(name : String) -> Bool]
											reflaxe.elixir.helpers.SchemaCompiler
											isSpecialFunction:(name : String) -> Bool
									[Field:Dynamic]
										[Local funcField(25121):Dynamic:Dynamic]
										[FDynamic:Dynamic] name
							[Then:String] [Block:String]
								[Binop:String]
									[Local result(25069):String:String]
									+=
									[Binop:String]
										[Const:String] "\n"
										+
										[Call:String]
											[Field:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.SchemaCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.SchemaCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
													reflaxe.elixir.ElixirCompiler
													compileFunction:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String
											[Local funcField(25121):Dynamic:Dynamic]
											[Const:Bool] true
			[Binop:String]
				[Local result(25069):String:String]
				+=
				[Const:String] "end\n"
			[Return:Dynamic] [Local result(25069):String:String]

	public function compileChangesetClass[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>, funcFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25150):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(25151):Array<Dynamic>]
		[Arg:Array<Dynamic>] [Local funcFields(25152):Array<Dynamic>]
		[Block:Dynamic]
			[Var moduleName(25153):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.SchemaCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.SchemaCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.ElixirCompiler
							getModuleName:(classType : haxe.macro.ClassType) -> String
					[Local classType(25150):haxe.macro.ClassType:haxe.macro.ClassType]
			[Var result(25154):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "defmodule "
						+
						[Local moduleName(25153):String:String]
					+
					[Const:String] " do\n"
			[Binop:String]
				[Local result(25154):String:String]
				+=
				[Const:String] "  import Ecto.Changeset\n\n"
			[Block:Void]
				[Var `(25156):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25156):Int:Int]
						<
						[Field:Int]
							[Local funcFields(25152):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var funcField(25155):Dynamic]
							[Array:Dynamic]
								[Local funcFields(25152):Array<Dynamic>:Array<Dynamic>]
								[Local `(25156):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25156):Int:Int]
						[Binop:String]
							[Local result(25154):String:String]
							+=
							[Binop:String]
								[Call:String]
									[Field:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.SchemaCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.SchemaCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String]
											reflaxe.elixir.ElixirCompiler
											compileFunction:(funcField : reflaxe.data.ClassFuncData, ?isStatic : Bool) -> String
									[Local funcField(25155):Dynamic:Dynamic]
									[Const:Bool] true
								+
								[Const:String] "\n"
			[Binop:String]
				[Local result(25154):String:String]
				+=
				[Const:String] "end\n"
			[Return:Dynamic] [Local result(25154):String:String]

	function extractTableName[Function:(classType : haxe.macro.ClassType) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25054):haxe.macro.ClassType]
		[Block:Dynamic]
			[Var tableMeta(25055):Array<haxe.macro.MetadataEntry>]
				[Call:Array<haxe.macro.MetadataEntry>]
					[Field:(name : String) -> Array<haxe.macro.MetadataEntry>]
						[Field:haxe.macro.MetaAccess]
							[Local classType(25054):haxe.macro.ClassType:haxe.macro.ClassType]
							[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
						[FAnon:(name : String) -> Array<haxe.macro.MetadataEntry>] extract:(name : String) -> Array<haxe.macro.MetadataEntry>
					[Const:String] ":table"
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local tableMeta(25055):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
						!=
						[Const:Array<haxe.macro.MetadataEntry>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Local tableMeta(25055):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
							[FInstance:Int]
								Array<haxe.macro.MetadataEntry>
								length:Int
						>
						[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Meta:String]
							:ast(switch (tableMeta[0].params[0].expr) {
	case EConst(CString(s)):
		s;	
	default:
		pluralizeTableName(classType.name);	
})
							[Block:String]
								[Var `(25063):haxe.macro.ExprDef]
									[Field:haxe.macro.ExprDef]
										[Array:haxe.macro.Expr]
											[Field:Null<Array<haxe.macro.Expr>>]
												[Array:haxe.macro.MetadataEntry]
													[Local tableMeta(25055):Array<haxe.macro.MetadataEntry>:Array<haxe.macro.MetadataEntry>]
													[Const:Int] 0
												[FAnon:Null<Array<haxe.macro.Expr>>] params:Null<Array<haxe.macro.Expr>>
											[Const:Int] 0
										[FAnon:haxe.macro.ExprDef] expr:haxe.macro.ExprDef
								[If:String]
									[Binop:Bool]
										[EnumIndex:Int] [Local `(25063):haxe.macro.ExprDef:haxe.macro.ExprDef]
										==
										[Const:Int] 0
									[Then:String] [Block:String]
										[Var `(25064):haxe.macro.Constant]
											[EnumParameter:haxe.macro.Constant]
												[Local `(25063):haxe.macro.ExprDef:haxe.macro.ExprDef]
												EConst
												0
										[If:String]
											[Binop:Bool]
												[EnumIndex:Int] [Local `(25064):haxe.macro.Constant:haxe.macro.Constant]
												==
												[Const:Int] 2
											[Then:String] [Block:String]
												[Var `(25065):String]
													[EnumParameter:String]
														[Local `(25064):haxe.macro.Constant:haxe.macro.Constant]
														CString
														0
												[Var `(25066):Null<haxe.macro.StringLiteralKind>]
													[EnumParameter:Null<haxe.macro.StringLiteralKind>]
														[Local `(25064):haxe.macro.Constant:haxe.macro.Constant]
														CString
														1
												[Block:String]
													[Var s(25067):String] [Local `(25065):String:String]
													[Block:String] [Local s(25067):String:String]
											[Else:String] [Block:String]
												[Call:String]
													[Field:(name : String) -> String]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:(name : String) -> String]
															reflaxe.elixir.helpers.SchemaCompiler
															pluralizeTableName:(name : String) -> String
													[Field:String]
														[Local classType(25054):haxe.macro.ClassType:haxe.macro.ClassType]
														[FAnon:String] name:String
									[Else:String] [Block:String]
										[Call:String]
											[Field:(name : String) -> String]
												[Const:reflaxe.elixir.helpers.SchemaCompiler] this
												[FInstance:(name : String) -> String]
													reflaxe.elixir.helpers.SchemaCompiler
													pluralizeTableName:(name : String) -> String
											[Field:String]
												[Local classType(25054):haxe.macro.ClassType:haxe.macro.ClassType]
												[FAnon:String] name:String
			[Return:Dynamic]
				[Call:String]
					[Field:(name : String) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(name : String) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							pluralizeTableName:(name : String) -> String
					[Field:String]
						[Local classType(25054):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String

	function pluralizeTableName[Function:(name : String) -> String]
		[Arg:String] [Local name(25057):String]
		[Block:Void]
			[Var snakeName(25058):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Local name(25057):String:String]
			[If:Void]
				[Call:Bool]
					[Field:(s : String, end : String) -> Bool]
						[TypeExpr StringTools:{ Statics StringTools }]
						[FStatic:(s : String, end : String) -> Bool]
							StringTools
							endsWith:(s : String, end : String) -> Bool
					[Local snakeName(25058):String:String]
					[Const:String] "y"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Call:String]
								[Field:(startIndex : Int, ?endIndex : Null<Int>) -> String]
									[Local snakeName(25058):String:String]
									[FInstance:(startIndex : Int, ?endIndex : Null<Int>) -> String]
										String
										substring:(startIndex : Int, ?endIndex : Null<Int>) -> String
								[Const:Int] 0
								[Binop:Int]
									[Field:Int]
										[Local snakeName(25058):String:String]
										[FInstance:Int]
											String
											length:Int
									-
									[Const:Int] 1
							+
							[Const:String] "ies"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Call:Bool]
									[Field:(s : String, end : String) -> Bool]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String, end : String) -> Bool]
											StringTools
											endsWith:(s : String, end : String) -> Bool
									[Local snakeName(25058):String:String]
									[Const:String] "s"
								||
								[Call:Bool]
									[Field:(s : String, end : String) -> Bool]
										[TypeExpr StringTools:{ Statics StringTools }]
										[FStatic:(s : String, end : String) -> Bool]
											StringTools
											endsWith:(s : String, end : String) -> Bool
									[Local snakeName(25058):String:String]
									[Const:String] "x"
							||
							[Call:Bool]
								[Field:(s : String, end : String) -> Bool]
									[TypeExpr StringTools:{ Statics StringTools }]
									[FStatic:(s : String, end : String) -> Bool]
										StringTools
										endsWith:(s : String, end : String) -> Bool
								[Local snakeName(25058):String:String]
								[Const:String] "ch"
						[Then:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Local snakeName(25058):String:String]
									+
									[Const:String] "es"
						[Else:Dynamic] [Block:Dynamic]
							[Return:Dynamic]
								[Binop:String]
									[Local snakeName(25058):String:String]
									+
									[Const:String] "s"

	function generateSchemaFields[Function:(varFields : Array<Dynamic>) -> String]
		[Arg:Array<Dynamic>] [Local varFields(25070):Array<Dynamic>]
		[Block:Dynamic]
			[Var fields(25071):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(25099):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25099):Int:Int]
						<
						[Field:Int]
							[Local varFields(25070):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(25072):Dynamic]
							[Array:Dynamic]
								[Local varFields(25070):Array<Dynamic>:Array<Dynamic>]
								[Local `(25099):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25099):Int:Int]
						[Var fieldName(25073):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(25072):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[Var fieldType(25093):String]
							[Call:String]
								[Field:(type : haxe.macro.Type) -> String]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(type : haxe.macro.Type) -> String]
										reflaxe.elixir.helpers.SchemaCompiler
										mapHaxeTypeToEcto:(type : haxe.macro.Type) -> String
								[Field:Dynamic]
									[Local varField(25072):Dynamic:Dynamic]
									[FDynamic:Dynamic] type
						[Var options(25098):Array<String>]
							[Call:Array<String>]
								[Field:(varField : Dynamic) -> Array<String>]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(varField : Dynamic) -> Array<String>]
										reflaxe.elixir.helpers.SchemaCompiler
										extractFieldOptions:(varField : Dynamic) -> Array<String>
								[Local varField(25072):Dynamic:Dynamic]
						[If:Void]
							[Binop:Bool]
								[Field:Int]
									[Local options(25098):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fields(25071):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "    field :"
														+
														[Local fieldName(25073):String:String]
													+
													[Const:String] ", "
												+
												[Local fieldType(25093):String:String]
											+
											[Const:String] ", "
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local options(25098):Array<String>:Array<String>]
												[FInstance:(sep : String) -> String]
													Array<String>
													join:(sep : String) -> String
											[Const:String] ", "
							[Else:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fields(25071):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "    field :"
												+
												[Local fieldName(25073):String:String]
											+
											[Const:String] ", "
										+
										[Local fieldType(25093):String:String]
			[Return:Dynamic]
				[Binop:String]
					[Call:String]
						[Field:(sep : String) -> String]
							[Local fields(25071):Array<String>:Array<String>]
							[FInstance:(sep : String) -> String]
								Array<String>
								join:(sep : String) -> String
						[Const:String] "\n"
					+
					[Parenthesis:String]
						[If:String]
							[Binop:Bool]
								[Field:Int]
									[Local fields(25071):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:String] [Block:String] [Const:String] "\n"
							[Else:String] [Block:String] [Const:String] ""

	function mapHaxeTypeToEcto[Function:(type : haxe.macro.Type) -> String]
		[Arg:haxe.macro.Type] [Local type(25074):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (type) {
	case TInst(t, _):
		switch (t.get().name) {
			case "String":
				":string";			
			case "Date":
				":utc_datetime";			
			case "Array":
				":array";			
			default:
				":string";			
		};	
	case TAbstract(t, _):
		switch (t.get().name) {
			case "Int":
				":integer";			
			case "Float":
				":float";			
			case "Bool":
				":boolean";			
			default:
				":string";			
		};	
	default:
		":string";	
})
					[Switch:String]
						[EnumIndex:Int] [Local type(25074):haxe.macro.Type:haxe.macro.Type]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(25085):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(25074):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(25086):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(25074):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:String]
									[Var t(25087):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(25085):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Block:String]
										[Meta:String]
											:ast(switch (t.get().name) {
	case "String":
		":string";	
	case "Date":
		":utc_datetime";	
	case "Array":
		":array";	
	default:
		":string";	
})
											[Block:String]
												[Var `(25088):String]
													[Field:String]
														[Call:haxe.macro.ClassType]
															[Field:() -> haxe.macro.ClassType]
																[Local t(25087):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
																[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
														[FAnon:String] name:String
												[Switch:String]
													[Local `(25088):String:String]
													[Case:String]
														[Const:String] "Array"
														[Block:String] [Block:String] [Const:String] ":array"
													[Case:String]
														[Const:String] "Date"
														[Block:String] [Block:String] [Const:String] ":utc_datetime"
													[Case:String]
														[Const:String] "String"
														[Block:String] [Block:String] [Const:String] ":string"
													[Default:String] [Block:String] [Const:String] ":string"
						[Case:String]
							[Const:Int] 8
							[Block:String]
								[Var `(25089):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(25074):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(25090):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(25074):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:String]
									[Var t(25091):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(25089):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Block:String]
										[Meta:String]
											:ast(switch (t.get().name) {
	case "Int":
		":integer";	
	case "Float":
		":float";	
	case "Bool":
		":boolean";	
	default:
		":string";	
})
											[Block:String]
												[Var `(25092):String]
													[Field:String]
														[Call:haxe.macro.AbstractType]
															[Field:() -> haxe.macro.AbstractType]
																[Local t(25091):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
																[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
														[FAnon:String] name:String
												[Switch:String]
													[Local `(25092):String:String]
													[Case:String]
														[Const:String] "Bool"
														[Block:String] [Block:String] [Const:String] ":boolean"
													[Case:String]
														[Const:String] "Float"
														[Block:String] [Block:String] [Const:String] ":float"
													[Case:String]
														[Const:String] "Int"
														[Block:String] [Block:String] [Const:String] ":integer"
													[Default:String] [Block:String] [Const:String] ":string"
						[Default:String] [Block:String] [Const:String] ":string"

	function extractFieldOptions[Function:(varField : Dynamic) -> Array<String>]
		[Arg:Dynamic] [Local varField(25094):Dynamic]
		[Block:Dynamic]
			[Var options(25095):Array<String>] [ArrayDecl:Array<String>]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local varField(25094):Dynamic:Dynamic]
						[FDynamic:Dynamic] meta
					!=
					[Const:Dynamic] null
				[Then:Void] [Block:Void]
					[Var defaultMeta(25096):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
						[Call:Dynamic]
							[Field:Dynamic]
								[Field:Dynamic]
									[Local varField(25094):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								[FDynamic:Dynamic] extract
							[Const:String] ":default"
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local defaultMeta(25096):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
								!=
								[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
							&&
							[Binop:Bool]
								[Field:Int]
									[Local defaultMeta(25096):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									[FAnon:Int] length:Int
								>
								[Const:Int] 0
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local options(25095):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Binop:String]
									[Const:String] "default: "
									+
									[Call:Null<String>]
										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.SchemaCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.SchemaCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
												reflaxe.elixir.ElixirCompiler
												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
										[Array:haxe.macro.TypedExpr]
											[Field:Array<haxe.macro.TypedExpr>]
												[Array:{ params : Array<haxe.macro.TypedExpr> }]
													[Local defaultMeta(25096):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
													[Const:Int] 0
												[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
											[Const:Int] 0
										[Const:Null<Bool>] null
					[Var nullableMeta(25097):Null<{ length : Int }>]
						[Call:Dynamic]
							[Field:Dynamic]
								[Field:Dynamic]
									[Local varField(25094):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								[FDynamic:Dynamic] extract
							[Const:String] ":nullable"
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local nullableMeta(25097):Null<{ length : Int }>:Null<{ length : Int }>]
								!=
								[Const:Null<{ length : Int }>] null
							&&
							[Binop:Bool]
								[Field:Int]
									[Local nullableMeta(25097):Null<{ length : Int }>:Null<{ length : Int }>]
									[FAnon:Int] length:Int
								>
								[Const:Int] 0
						[Then:Int] [Block:Int]
							[Call:Int]
								[Field:(x : String) -> Int]
									[Local options(25095):Array<String>:Array<String>]
									[FInstance:(x : String) -> Int]
										Array<String>
										push:(x : Array.T) -> Int
								[Const:String] "nullable: true"
			[Return:Dynamic] [Local options(25095):Array<String>:Array<String>]

	function generateChangesetFunction[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25100):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(25101):Array<Dynamic>]
		[Block:Dynamic]
			[Var schemaVar(25102):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Field:String]
						[Local classType(25100):haxe.macro.ClassType:haxe.macro.ClassType]
						[FAnon:String] name:String
			[Var requiredFields(25103):Array<String>] [ArrayDecl:Array<String>]
			[Var optionalFields(25104):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(25109):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25109):Int:Int]
						<
						[Field:Int]
							[Local varFields(25101):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(25105):Dynamic]
							[Array:Dynamic]
								[Local varFields(25101):Array<Dynamic>:Array<Dynamic>]
								[Local `(25109):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25109):Int:Int]
						[Var fieldName(25106):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(25105):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[If:Void]
							[Call:Bool]
								[Field:(varField : Dynamic) -> Bool]
									[Const:reflaxe.elixir.helpers.SchemaCompiler] this
									[FInstance:(varField : Dynamic) -> Bool]
										reflaxe.elixir.helpers.SchemaCompiler
										isRequiredField:(varField : Dynamic) -> Bool
								[Local varField(25105):Dynamic:Dynamic]
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local requiredFields(25103):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Const:String] ":"
										+
										[Local fieldName(25106):String:String]
							[Else:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local optionalFields(25104):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Const:String] ":"
										+
										[Local fieldName(25106):String:String]
			[Var allFields(25110):Array<String>]
				[Call:Array<String>]
					[Field:(a : Array<String>) -> Array<String>]
						[Local requiredFields(25103):Array<String>:Array<String>]
						[FInstance:(a : Array<String>) -> Array<String>]
							Array<String>
							concat:(a : Array<Array.T>) -> Array<Array.T>
					[Local optionalFields(25104):Array<String>:Array<String>]
			[Var result(25111):String]
				[Binop:String]
					[Binop:String]
						[Const:String] "  def changeset("
						+
						[Local schemaVar(25102):String:String]
					+
					[Const:String] ", attrs) do\n"
			[Binop:String]
				[Local result(25111):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "    "
						+
						[Local schemaVar(25102):String:String]
					+
					[Const:String] "\n"
			[Binop:String]
				[Local result(25111):String:String]
				+=
				[Binop:String]
					[Binop:String]
						[Const:String] "    |> cast(attrs, ["
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local allFields(25110):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] "])\n"
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local requiredFields(25103):Array<String>:Array<String>]
						[FInstance:Int]
							Array<String>
							length:Int
					>
					[Const:Int] 0
				[Then:String] [Block:String]
					[Binop:String]
						[Local result(25111):String:String]
						+=
						[Binop:String]
							[Binop:String]
								[Const:String] "    |> validate_required(["
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local requiredFields(25103):Array<String>:Array<String>]
										[FInstance:(sep : String) -> String]
											Array<String>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] "])\n"
			[Binop:String]
				[Local result(25111):String:String]
				+=
				[Call:String]
					[Field:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
						[Const:reflaxe.elixir.helpers.SchemaCompiler] this
						[FInstance:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
							reflaxe.elixir.helpers.SchemaCompiler
							generateValidations:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String
					[Local classType(25100):haxe.macro.ClassType:haxe.macro.ClassType]
					[Local varFields(25101):Array<Dynamic>:Array<Dynamic>]
			[Binop:String]
				[Local result(25111):String:String]
				+=
				[Const:String] "  end\n"
			[Return:Dynamic] [Local result(25111):String:String]

	function isRequiredField[Function:(varField : Dynamic) -> Bool]
		[Arg:Dynamic] [Local varField(25107):Dynamic]
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Field:Dynamic]
						[Local varField(25107):Dynamic:Dynamic]
						[FDynamic:Dynamic] meta
					==
					[Const:Dynamic] null
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
			[Var requiredMeta(25108):Null<{ length : Int }>]
				[Call:Dynamic]
					[Field:Dynamic]
						[Field:Dynamic]
							[Local varField(25107):Dynamic:Dynamic]
							[FDynamic:Dynamic] meta
						[FDynamic:Dynamic] extract
					[Const:String] ":required"
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Local requiredMeta(25108):Null<{ length : Int }>:Null<{ length : Int }>]
						!=
						[Const:Null<{ length : Int }>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Local requiredMeta(25108):Null<{ length : Int }>:Null<{ length : Int }>]
							[FAnon:Int] length:Int
						>
						[Const:Int] 0

	function generateValidations[Function:(classType : haxe.macro.ClassType, varFields : Array<Dynamic>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(25112):haxe.macro.ClassType]
		[Arg:Array<Dynamic>] [Local varFields(25113):Array<Dynamic>]
		[Block:Dynamic]
			[Var validations(25114):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(25120):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(25120):Int:Int]
						<
						[Field:Int]
							[Local varFields(25113):Array<Dynamic>:Array<Dynamic>]
							[FInstance:Int]
								Array<Dynamic>
								length:Int
					[Block:Void]
						[Var varField(25115):Dynamic]
							[Array:Dynamic]
								[Local varFields(25113):Array<Dynamic>:Array<Dynamic>]
								[Local `(25120):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(25120):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Field:Dynamic]
									[Local varField(25115):Dynamic:Dynamic]
									[FDynamic:Dynamic] meta
								==
								[Const:Dynamic] null
							[Then:Dynamic] [Block:Dynamic] [Continue:Dynamic]
						[Var fieldName(25116):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:Dynamic]
									[Local varField(25115):Dynamic:Dynamic]
									[FDynamic:Dynamic] name
						[Var lengthMeta(25117):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(25115):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":length"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local lengthMeta(25117):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									!=
									[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local lengthMeta(25117):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(25114):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "    |> validate_length(:"
													+
													[Local fieldName(25116):String:String]
												+
												[Const:String] ", "
											+
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.SchemaCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Array:haxe.macro.TypedExpr]
													[Field:Array<haxe.macro.TypedExpr>]
														[Array:{ params : Array<haxe.macro.TypedExpr> }]
															[Local lengthMeta(25117):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
															[Const:Int] 0
														[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
													[Const:Int] 0
												[Const:Null<Bool>] null
										+
										[Const:String] ")"
						[Var formatMeta(25118):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(25115):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":format"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local formatMeta(25118):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
									!=
									[Const:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local formatMeta(25118):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(25114):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "    |> validate_format(:"
													+
													[Local fieldName(25116):String:String]
												+
												[Const:String] ", "
											+
											[Call:Null<String>]
												[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.SchemaCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.SchemaCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														reflaxe.elixir.ElixirCompiler
														compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
												[Array:haxe.macro.TypedExpr]
													[Field:Array<haxe.macro.TypedExpr>]
														[Array:{ params : Array<haxe.macro.TypedExpr> }]
															[Local formatMeta(25118):Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>:Null<Array<{ params : Array<haxe.macro.TypedExpr> }>>]
															[Const:Int] 0
														[FAnon:Array<haxe.macro.TypedExpr>] params:Array<haxe.macro.TypedExpr>
													[Const:Int] 0
												[Const:Null<Bool>] null
										+
										[Const:String] ")"
						[Var uniqueMeta(25119):Null<{ length : Int }>]
							[Call:Dynamic]
								[Field:Dynamic]
									[Field:Dynamic]
										[Local varField(25115):Dynamic:Dynamic]
										[FDynamic:Dynamic] meta
									[FDynamic:Dynamic] extract
								[Const:String] ":unique"
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local uniqueMeta(25119):Null<{ length : Int }>:Null<{ length : Int }>]
									!=
									[Const:Null<{ length : Int }>] null
								&&
								[Binop:Bool]
									[Field:Int]
										[Local uniqueMeta(25119):Null<{ length : Int }>:Null<{ length : Int }>]
										[FAnon:Int] length:Int
									>
									[Const:Int] 0
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local validations(25114):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Const:String] "    |> unique_constraint(:"
											+
											[Local fieldName(25116):String:String]
										+
										[Const:String] ")"
			[Return:Dynamic]
				[Binop:String]
					[Call:String]
						[Field:(sep : String) -> String]
							[Local validations(25114):Array<String>:Array<String>]
							[FInstance:(sep : String) -> String]
								Array<String>
								join:(sep : String) -> String
						[Const:String] "\n"
					+
					[Parenthesis:String]
						[If:String]
							[Binop:Bool]
								[Field:Int]
									[Local validations(25114):Array<String>:Array<String>]
									[FInstance:Int]
										Array<String>
										length:Int
								>
								[Const:Int] 0
							[Then:String] [Block:String] [Const:String] "\n"
							[Else:String] [Block:String] [Const:String] ""

	function isSpecialFunction[Function:(name : String) -> Bool]
		[Arg:String] [Local name(25122):String]
		[Block:Dynamic]
			[Return:Dynamic]
				[Binop:Bool]
					[Binop:Bool]
						[Binop:Bool]
							[Local name(25122):String:String]
							==
							[Const:String] "new"
						||
						[Binop:Bool]
							[Local name(25122):String:String]
							==
							[Const:String] "changeset"
					||
					[Binop:Bool]
						[Local name(25122):String:String]
						==
						[Const:String] "__construct"
}