class reflaxe.elixir.helpers.TypedefCompiler {

	public function new[Function:() -> Void] [Block:Void]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function setCompiler[Function:(c : Dynamic) -> Void]
		[Arg:Dynamic] [Local c(26389):Dynamic]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.TypedefCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.TypedefCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local c(26389):Dynamic:Dynamic]

	public static function compileTypedef[Function:(defType : haxe.macro.DefType) -> String]
		[Arg:haxe.macro.DefType] [Local defType(26390):haxe.macro.DefType]
		[Block:Dynamic]
			[Var output(26391):StringBuf] [New:StringBuf] StringBuf
			[Var typedefName(26392):String]
				[Call:String]
					[Field:(camelCase : String) -> String]
						[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
						[FStatic:(camelCase : String) -> String]
							reflaxe.elixir.helpers.NamingHelper
							toSnakeCase:(camelCase : String) -> String
					[Field:String]
						[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
						[FAnon:String] name:String
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Null<String>]
							[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
							[FAnon:Null<String>] doc:Null<String>
						!=
						[Const:Null<String>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Field:Null<String>]
								[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
								[FAnon:Null<String>] doc:Null<String>
							[FInstance:Int]
								String
								length:Int
						>
						[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "@typedoc \"\"\""
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "\n"
					[Call:Void]
						[Field:(x : Null<String>) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : Null<String>) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Field:Null<String>]
							[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
							[FAnon:Null<String>] doc:Null<String>
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "\n"
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "\"\"\""
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26391):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "@type "
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26391):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Local typedefName(26392):String:String]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Field:Array<haxe.macro.TypeParameter>]
							[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
							[FAnon:Array<haxe.macro.TypeParameter>] params:Array<haxe.macro.TypeParameter>
						!=
						[Const:Array<haxe.macro.TypeParameter>] null
					&&
					[Binop:Bool]
						[Field:Int]
							[Field:Array<haxe.macro.TypeParameter>]
								[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
								[FAnon:Array<haxe.macro.TypeParameter>] params:Array<haxe.macro.TypeParameter>
							[FInstance:Int]
								Array<haxe.macro.TypeParameter>
								length:Int
						>
						[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "("
					[Var paramNames(26393):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(26395):Int] [Const:Int] 0
						[Var `(26396):Array<haxe.macro.TypeParameter>]
							[Field:Array<haxe.macro.TypeParameter>]
								[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
								[FAnon:Array<haxe.macro.TypeParameter>] params:Array<haxe.macro.TypeParameter>
						[While:Void]
							[Binop:Bool]
								[Local `(26395):Int:Int]
								<
								[Field:Int]
									[Local `(26396):Array<haxe.macro.TypeParameter>:Array<haxe.macro.TypeParameter>]
									[FInstance:Int]
										Array<haxe.macro.TypeParameter>
										length:Int
							[Block:Void]
								[Var param(26394):haxe.macro.TypeParameter]
									[Array:haxe.macro.TypeParameter]
										[Local `(26396):Array<haxe.macro.TypeParameter>:Array<haxe.macro.TypeParameter>]
										[Local `(26395):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(26395):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local paramNames(26393):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:() -> String]
											[Field:String]
												[Local param(26394):haxe.macro.TypeParameter:haxe.macro.TypeParameter]
												[FAnon:String] name:String
											[FInstance:() -> String]
												String
												toLowerCase:() -> String
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Call:String]
							[Field:(sep : String) -> String]
								[Local paramNames(26393):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26391):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] ")"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26391):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] " :: "
			[Var typeSpec(26499):String]
				[Call:String]
					[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
						[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
						[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
							reflaxe.elixir.helpers.TypedefCompiler
							compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
					[Field:haxe.macro.Type]
						[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
						[FAnon:haxe.macro.Type] type:haxe.macro.Type
					[Field:Array<haxe.macro.TypeParameter>]
						[Local defType(26390):haxe.macro.DefType:haxe.macro.DefType]
						[FAnon:Array<haxe.macro.TypeParameter>] params:Array<haxe.macro.TypeParameter>
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26391):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Local typeSpec(26499):String:String]
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(26391):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	public static function compileType[Function:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
		[Arg:haxe.macro.Type] [Local type(26397):haxe.macro.Type]
		[Arg:Null<Array<haxe.macro.TypeParameter>>]
			[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>]
			[Const:Null<Array<haxe.macro.TypeParameter>>] null
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (type) {
	case TAnonymous(a):
		compileAnonymousType(a.get(), typeParams);	
	case TInst(t, params):
		var className = t.get().name;
		if (typeParams != null) {
			for (param  in  typeParams) {
				if (param.name == className) {
					return param.name.toLowerCase();
				};
			};
		};
		compileInstType(t.get(), params, typeParams);	
	case TAbstract(a, params):
		compileAbstractType(a.get(), params, typeParams);	
	case TFun(args, ret):
		compileFunctionType(args, ret, typeParams);	
	case TDynamic(_):
		"any()";	
	case TType(t, params):
		var refName = NamingHelper.toSnakeCase(t.get().name);
		if (params != null && params.length > 0) {
			var paramSpecs = params.map(function(p) ->  @:implicitReturn return compileType(p, typeParams));
			refName + "(" + paramSpecs.join(", ") + ")";
		} else {
			refName + "()";
		};	
	default:
		"any()";	
})
					[Switch:String]
						[EnumIndex:Int] [Local type(26397):haxe.macro.Type:haxe.macro.Type]
						[Case:String]
							[Const:Int] 2
							[Block:String]
								[Var `(26470):haxe.macro.Ref<haxe.macro.ClassType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TInst
										0
								[Var `(26471):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TInst
										1
								[Block:String]
									[Var t(26472):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(26470):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
									[Var params(26473):Array<haxe.macro.Type>] [Local `(26471):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
									[Block:String]
										[Var className(26474):String]
											[Field:String]
												[Call:haxe.macro.ClassType]
													[Field:() -> haxe.macro.ClassType]
														[Local t(26472):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
														[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
												[FAnon:String] name:String
										[If:Void]
											[Binop:Bool]
												[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
												!=
												[Const:Null<Array<haxe.macro.TypeParameter>>] null
											[Then:Void] [Block:Void]
												[Block:Void]
													[Var `(26475):Int] [Const:Int] 0
													[While:Void]
														[Binop:Bool]
															[Local `(26475):Int:Int]
															<
															[Field:Int]
																[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
																[FInstance:Int]
																	Array<haxe.macro.TypeParameter>
																	length:Int
														[Block:Void]
															[Var param(26476):haxe.macro.TypeParameter]
																[Array:haxe.macro.TypeParameter]
																	[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
																	[Local `(26475):Int:Int]
															[Unop:Int]
																++
																Prefix
																[Local `(26475):Int:Int]
															[If:Void]
																[Binop:Bool]
																	[Field:String]
																		[Local param(26476):haxe.macro.TypeParameter:haxe.macro.TypeParameter]
																		[FAnon:String] name:String
																	==
																	[Local className(26474):String:String]
																[Then:Dynamic] [Block:Dynamic]
																	[Return:Dynamic]
																		[Call:String]
																			[Field:() -> String]
																				[Field:String]
																					[Local param(26476):haxe.macro.TypeParameter:haxe.macro.TypeParameter]
																					[FAnon:String] name:String
																				[FInstance:() -> String]
																					String
																					toLowerCase:() -> String
										[Call:String]
											[Field:(classType : haxe.macro.ClassType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
												[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
												[FStatic:(classType : haxe.macro.ClassType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
													reflaxe.elixir.helpers.TypedefCompiler
													compileInstType:(classType : haxe.macro.ClassType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local t(26472):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
											[Local params(26473):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
											[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
						[Case:String]
							[Const:Int] 3
							[Block:String]
								[Var `(26477):haxe.macro.Ref<haxe.macro.DefType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.DefType>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TType
										0
								[Var `(26478):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TType
										1
								[Block:String]
									[Var t(26479):haxe.macro.Ref<haxe.macro.DefType>] [Local `(26477):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
									[Var params(26480):Array<haxe.macro.Type>] [Local `(26478):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
									[Block:String]
										[Var refName(26481):String]
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Field:String]
													[Call:haxe.macro.DefType]
														[Field:() -> haxe.macro.DefType]
															[Local t(26479):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
															[FAnon:() -> haxe.macro.DefType] get:() -> haxe.macro.DefType
													[FAnon:String] name:String
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Local params(26480):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
													!=
													[Const:Array<haxe.macro.Type>] null
												&&
												[Binop:Bool]
													[Field:Int]
														[Local params(26480):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
														[FInstance:Int]
															Array<haxe.macro.Type>
															length:Int
													>
													[Const:Int] 0
											[Then:String] [Block:String]
												[Var paramSpecs(26482):Array<String>]
													[Block:Array<String>]
														[Var `(26483):Array<String>] [ArrayDecl:Array<String>]
														[Block:Void]
															[Var `(26484):Int] [Const:Int] 0
															[Var `(26485):Array<haxe.macro.Type>] [Local params(26480):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
															[While:Void]
																[Binop:Bool]
																	[Local `(26484):Int:Int]
																	<
																	[Field:Int]
																		[Local `(26485):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
																		[FInstance:Int]
																			Array<haxe.macro.Type>
																			length:Int
																[Block:Void]
																	[Var v(26486):haxe.macro.Type]
																		[Array:haxe.macro.Type]
																			[Local `(26485):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
																			[Local `(26484):Int:Int]
																	[Unop:Int]
																		++
																		Prefix
																		[Local `(26484):Int:Int]
																	[Call:Int]
																		[Field:(x : String) -> Int]
																			[Local `(26483):Array<String>:Array<String>]
																			[FInstance:(x : String) -> Int]
																				Array<String>
																				push:(x : Array.T) -> Int
																		[Call:String]
																			[Function:(p : haxe.macro.Type) -> String]
																				[Arg:haxe.macro.Type] [Local p(26487):haxe.macro.Type]
																				[Block:Dynamic]
																					[Return:Dynamic]
																						[Call:String]
																							[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																								[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
																								[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																									reflaxe.elixir.helpers.TypedefCompiler
																									compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
																							[Local p(26487):haxe.macro.Type:haxe.macro.Type]
																							[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
																			[Local v(26486):haxe.macro.Type:haxe.macro.Type]
														[Local `(26483):Array<String>:Array<String>]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Local refName(26481):String:String]
															+
															[Const:String] "("
														+
														[Call:String]
															[Field:(sep : String) -> String]
																[Local paramSpecs(26482):Array<String>:Array<String>]
																[FInstance:(sep : String) -> String]
																	Array<String>
																	join:(sep : String) -> String
															[Const:String] ", "
													+
													[Const:String] ")"
											[Else:String] [Block:String]
												[Binop:String]
													[Local refName(26481):String:String]
													+
													[Const:String] "()"
						[Case:String]
							[Const:Int] 4
							[Block:String]
								[Var `(26488):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TFun
										0
								[Var `(26489):haxe.macro.Type]
									[EnumParameter:haxe.macro.Type]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TFun
										1
								[Block:String]
									[Var args(26490):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local `(26488):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[Var ret(26491):haxe.macro.Type] [Local `(26489):haxe.macro.Type:haxe.macro.Type]
									[Block:String]
										[Call:String]
											[Field:(args : Array<{ t : haxe.macro.Type, opt : Bool, name : String }>, ret : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
												[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
												[FStatic:(args : Array<{ t : haxe.macro.Type, opt : Bool, name : String }>, ret : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
													reflaxe.elixir.helpers.TypedefCompiler
													compileFunctionType:(args : Array<{ t : haxe.macro.Type, opt : Bool, name : String }>, ret : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
											[Local args(26490):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
											[Local ret(26491):haxe.macro.Type:haxe.macro.Type]
											[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
						[Case:String]
							[Const:Int] 5
							[Block:String]
								[Var `(26492):haxe.macro.Ref<haxe.macro.AnonType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AnonType>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TAnonymous
										0
								[Block:String]
									[Var a(26493):haxe.macro.Ref<haxe.macro.AnonType>] [Local `(26492):haxe.macro.Ref<haxe.macro.AnonType>:haxe.macro.Ref<haxe.macro.AnonType>]
									[Block:String]
										[Call:String]
											[Field:(anon : haxe.macro.AnonType, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
												[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
												[FStatic:(anon : haxe.macro.AnonType, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
													reflaxe.elixir.helpers.TypedefCompiler
													compileAnonymousType:(anon : haxe.macro.AnonType, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
											[Call:haxe.macro.AnonType]
												[Field:() -> haxe.macro.AnonType]
													[Local a(26493):haxe.macro.Ref<haxe.macro.AnonType>:haxe.macro.Ref<haxe.macro.AnonType>]
													[FAnon:() -> haxe.macro.AnonType] get:() -> haxe.macro.AnonType
											[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
						[Case:String]
							[Const:Int] 6
							[Block:String]
								[Var `(26494):Null<haxe.macro.Type>]
									[EnumParameter:Null<haxe.macro.Type>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TDynamic
										0
								[Block:String] [Const:String] "any()"
						[Case:String]
							[Const:Int] 8
							[Block:String]
								[Var `(26495):haxe.macro.Ref<haxe.macro.AbstractType>]
									[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										0
								[Var `(26496):Array<haxe.macro.Type>]
									[EnumParameter:Array<haxe.macro.Type>]
										[Local type(26397):haxe.macro.Type:haxe.macro.Type]
										TAbstract
										1
								[Block:String]
									[Var a(26497):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(26495):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Var params(26498):Array<haxe.macro.Type>] [Local `(26496):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
									[Block:String]
										[Call:String]
											[Field:(abstractType : haxe.macro.AbstractType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
												[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
												[FStatic:(abstractType : haxe.macro.AbstractType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
													reflaxe.elixir.helpers.TypedefCompiler
													compileAbstractType:(abstractType : haxe.macro.AbstractType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
											[Call:haxe.macro.AbstractType]
												[Field:() -> haxe.macro.AbstractType]
													[Local a(26497):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
													[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
											[Local params(26498):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
											[Local typeParams(26398):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
						[Default:String] [Block:String] [Const:String] "any()"

	static function compileAnonymousType[Function:(anon : haxe.macro.AnonType, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
		[Arg:haxe.macro.AnonType] [Local anon(26400):haxe.macro.AnonType]
		[Arg:Null<Array<haxe.macro.TypeParameter>>]
			[Local typeParams(26401):Null<Array<haxe.macro.TypeParameter>>]
			[Const:Null<Array<haxe.macro.TypeParameter>>] null
		[Block:Dynamic]
			[Var fields(26402):Array<haxe.macro.ClassField>]
				[Field:Array<haxe.macro.ClassField>]
					[Local anon(26400):haxe.macro.AnonType:haxe.macro.AnonType]
					[FAnon:Array<haxe.macro.ClassField>] fields:Array<haxe.macro.ClassField>
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local fields(26402):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
						[FInstance:Int]
							Array<haxe.macro.ClassField>
							length:Int
					==
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "%{}"
			[Var output(26403):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26403):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "%{\n"
			[Var fieldSpecs(26404):Array<String>] [ArrayDecl:Array<String>]
			[Block:Void]
				[Var `(26416):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(26416):Int:Int]
						<
						[Field:Int]
							[Local fields(26402):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
							[FInstance:Int]
								Array<haxe.macro.ClassField>
								length:Int
					[Block:Void]
						[Var field(26405):haxe.macro.ClassField]
							[Array:haxe.macro.ClassField]
								[Local fields(26402):Array<haxe.macro.ClassField>:Array<haxe.macro.ClassField>]
								[Local `(26416):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(26416):Int:Int]
						[Var fieldName(26406):String]
							[Call:String]
								[Field:(camelCase : String) -> String]
									[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
									[FStatic:(camelCase : String) -> String]
										reflaxe.elixir.helpers.NamingHelper
										toSnakeCase:(camelCase : String) -> String
								[Field:String]
									[Local field(26405):haxe.macro.ClassField:haxe.macro.ClassField]
									[FAnon:String] name:String
						[Var fieldType(26407):String]
							[Call:String]
								[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
									[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
									[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
										reflaxe.elixir.helpers.TypedefCompiler
										compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
								[Field:haxe.macro.Type]
									[Local field(26405):haxe.macro.ClassField:haxe.macro.ClassField]
									[FAnon:haxe.macro.Type] type:haxe.macro.Type
								[Local typeParams(26401):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
						[Var isOptional(26415):Bool]
							[Binop:Bool]
								[Call:Bool]
									[Field:(name : String) -> Bool]
										[Field:haxe.macro.MetaAccess]
											[Local field(26405):haxe.macro.ClassField:haxe.macro.ClassField]
											[FAnon:haxe.macro.MetaAccess] meta:haxe.macro.MetaAccess
										[FAnon:(name : String) -> Bool] has:(name : String) -> Bool
									[Const:String] ":optional"
								||
								[Call:Bool]
									[Field:(type : haxe.macro.Type) -> Bool]
										[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
										[FStatic:(type : haxe.macro.Type) -> Bool]
											reflaxe.elixir.helpers.TypedefCompiler
											isNullableType:(type : haxe.macro.Type) -> Bool
									[Field:haxe.macro.Type]
										[Local field(26405):haxe.macro.ClassField:haxe.macro.ClassField]
										[FAnon:haxe.macro.Type] type:haxe.macro.Type
						[If:Void]
							[Local isOptional(26415):Bool:Bool]
							[Then:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fieldSpecs(26404):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "  optional(:"
												+
												[Local fieldName(26406):String:String]
											+
											[Const:String] ") => "
										+
										[Local fieldType(26407):String:String]
							[Else:Int] [Block:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local fieldSpecs(26404):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "  "
												+
												[Local fieldName(26406):String:String]
											+
											[Const:String] ": "
										+
										[Local fieldType(26407):String:String]
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26403):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Call:String]
					[Field:(sep : String) -> String]
						[Local fieldSpecs(26404):Array<String>:Array<String>]
						[FInstance:(sep : String) -> String]
							Array<String>
							join:(sep : String) -> String
					[Const:String] ",\n"
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26403):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "\n}"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(26403):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String

	static function isNullableType[Function:(type : haxe.macro.Type) -> Bool]
		[Arg:haxe.macro.Type] [Local type(26408):haxe.macro.Type]
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:Bool]
					:ast(switch (type) {
	case TAbstract(a, _) if (a.get().name == "Null"):
		true;	
	default:
		false;	
})
					[If:Bool]
						[Binop:Bool]
							[EnumIndex:Int] [Local type(26408):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 8
						[Then:Bool] [Block:Bool]
							[Var `(26412):haxe.macro.Ref<haxe.macro.AbstractType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.AbstractType>]
									[Local type(26408):haxe.macro.Type:haxe.macro.Type]
									TAbstract
									0
							[Var `(26413):Array<haxe.macro.Type>]
								[EnumParameter:Array<haxe.macro.Type>]
									[Local type(26408):haxe.macro.Type:haxe.macro.Type]
									TAbstract
									1
							[Block:Bool]
								[Var a(26414):haxe.macro.Ref<haxe.macro.AbstractType>] [Local `(26412):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
								[If:Bool]
									[Binop:Bool]
										[Field:String]
											[Call:haxe.macro.AbstractType]
												[Field:() -> haxe.macro.AbstractType]
													[Local a(26414):haxe.macro.Ref<haxe.macro.AbstractType>:haxe.macro.Ref<haxe.macro.AbstractType>]
													[FAnon:() -> haxe.macro.AbstractType] get:() -> haxe.macro.AbstractType
											[FAnon:String] name:String
										==
										[Const:String] "Null"
									[Then:Bool] [Block:Bool] [Const:Bool] true
									[Else:Bool] [Block:Bool] [Const:Bool] false
						[Else:Bool] [Block:Bool] [Const:Bool] false

	static function compileInstType[Function:(classType : haxe.macro.ClassType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
		[Arg:haxe.macro.ClassType] [Local classType(26422):haxe.macro.ClassType]
		[Arg:Array<haxe.macro.Type>] [Local params(26423):Array<haxe.macro.Type>]
		[Arg:Null<Array<haxe.macro.TypeParameter>>]
			[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>]
			[Const:Null<Array<haxe.macro.TypeParameter>>] null
		[Block:Dynamic]
			[If:Void]
				[Binop:Bool]
					[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
					!=
					[Const:Null<Array<haxe.macro.TypeParameter>>] null
				[Then:Void] [Block:Void]
					[Block:Void]
						[Var `(26426):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(26426):Int:Int]
								<
								[Field:Int]
									[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
									[FInstance:Int]
										Array<haxe.macro.TypeParameter>
										length:Int
							[Block:Void]
								[Var param(26425):haxe.macro.TypeParameter]
									[Array:haxe.macro.TypeParameter]
										[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
										[Local `(26426):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(26426):Int:Int]
								[If:Void]
									[Binop:Bool]
										[Field:String]
											[Local param(26425):haxe.macro.TypeParameter:haxe.macro.TypeParameter]
											[FAnon:String] name:String
										==
										[Field:String]
											[Local classType(26422):haxe.macro.ClassType:haxe.macro.ClassType]
											[FAnon:String] name:String
									[Then:Dynamic] [Block:Dynamic]
										[Return:Dynamic]
											[Call:String]
												[Field:() -> String]
													[Field:String]
														[Local param(26425):haxe.macro.TypeParameter:haxe.macro.TypeParameter]
														[FAnon:String] name:String
													[FInstance:() -> String]
														String
														toLowerCase:() -> String
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (classType.name) {
	case "String":
		"String.t()";	
	case "Array":
		if (params != null && params.length > 0) {
			"list(" + compileType(params[0], typeParams) + ")";
		} else {
			"list(any())";
		};	
	case "Map":
		if (params != null && params.length >= 2) {
			"%{optional(" + compileType(params[0], typeParams) + ") => " + compileType(params[1], typeParams) + "}";
		} else {
			"map()";
		};	
	default:
		var moduleName = classType.name;
		moduleName + ".t()";	
})
					[Block:String]
						[Var `(26429):String]
							[Field:String]
								[Local classType(26422):haxe.macro.ClassType:haxe.macro.ClassType]
								[FAnon:String] name:String
						[Switch:String]
							[Local `(26429):String:String]
							[Case:String]
								[Const:String] "Array"
								[Block:String]
									[Block:String]
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
													!=
													[Const:Array<haxe.macro.Type>] null
												&&
												[Binop:Bool]
													[Field:Int]
														[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
														[FInstance:Int]
															Array<haxe.macro.Type>
															length:Int
													>
													[Const:Int] 0
											[Then:String] [Block:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "list("
														+
														[Call:String]
															[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
																[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																	reflaxe.elixir.helpers.TypedefCompiler
																	compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
															[Array:haxe.macro.Type]
																[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
																[Const:Int] 0
															[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
													+
													[Const:String] ")"
											[Else:String] [Block:String] [Const:String] "list(any())"
							[Case:String]
								[Const:String] "Map"
								[Block:String]
									[Block:String]
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
													!=
													[Const:Array<haxe.macro.Type>] null
												&&
												[Binop:Bool]
													[Field:Int]
														[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
														[FInstance:Int]
															Array<haxe.macro.Type>
															length:Int
													>=
													[Const:Int] 2
											[Then:String] [Block:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Binop:String]
																[Const:String] "%{optional("
																+
																[Call:String]
																	[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																		[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
																		[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																			reflaxe.elixir.helpers.TypedefCompiler
																			compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
																	[Array:haxe.macro.Type]
																		[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
																		[Const:Int] 0
																	[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
															+
															[Const:String] ") => "
														+
														[Call:String]
															[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
																[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																	reflaxe.elixir.helpers.TypedefCompiler
																	compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
															[Array:haxe.macro.Type]
																[Local params(26423):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
																[Const:Int] 1
															[Local typeParams(26424):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
													+
													[Const:String] "}"
											[Else:String] [Block:String] [Const:String] "map()"
							[Case:String]
								[Const:String] "String"
								[Block:String] [Block:String] [Const:String] "String.t()"
							[Default:String]
								[Block:String]
									[Var moduleName(26430):String]
										[Field:String]
											[Local classType(26422):haxe.macro.ClassType:haxe.macro.ClassType]
											[FAnon:String] name:String
									[Binop:String]
										[Local moduleName(26430):String:String]
										+
										[Const:String] ".t()"

	static function compileAbstractType[Function:(abstractType : haxe.macro.AbstractType, params : Array<haxe.macro.Type>, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
		[Arg:haxe.macro.AbstractType] [Local abstractType(26433):haxe.macro.AbstractType]
		[Arg:Array<haxe.macro.Type>] [Local params(26434):Array<haxe.macro.Type>]
		[Arg:Null<Array<haxe.macro.TypeParameter>>]
			[Local typeParams(26435):Null<Array<haxe.macro.TypeParameter>>]
			[Const:Null<Array<haxe.macro.TypeParameter>>] null
		[Block:Dynamic]
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (abstractType.name) {
	case "Int":
		"integer()";	
	case "Float":
		"float()";	
	case "Bool":
		"boolean()";	
	case "Void":
		":ok";	
	case "Null":
		if (params != null && params.length > 0) {
			compileType(params[0], typeParams) + " | nil";
		} else {
			"nil";
		};	
	case "Dynamic":
		"any()";	
	default:
		"any()";	
})
					[Block:String]
						[Var `(26437):String]
							[Field:String]
								[Local abstractType(26433):haxe.macro.AbstractType:haxe.macro.AbstractType]
								[FAnon:String] name:String
						[Switch:String]
							[Local `(26437):String:String]
							[Case:String]
								[Const:String] "Bool"
								[Block:String] [Block:String] [Const:String] "boolean()"
							[Case:String]
								[Const:String] "Dynamic"
								[Block:String] [Block:String] [Const:String] "any()"
							[Case:String]
								[Const:String] "Float"
								[Block:String] [Block:String] [Const:String] "float()"
							[Case:String]
								[Const:String] "Int"
								[Block:String] [Block:String] [Const:String] "integer()"
							[Case:String]
								[Const:String] "Null"
								[Block:String]
									[Block:String]
										[If:String]
											[Binop:Bool]
												[Binop:Bool]
													[Local params(26434):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
													!=
													[Const:Array<haxe.macro.Type>] null
												&&
												[Binop:Bool]
													[Field:Int]
														[Local params(26434):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
														[FInstance:Int]
															Array<haxe.macro.Type>
															length:Int
													>
													[Const:Int] 0
											[Then:String] [Block:String]
												[Binop:String]
													[Call:String]
														[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
															[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
															[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
																reflaxe.elixir.helpers.TypedefCompiler
																compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
														[Array:haxe.macro.Type]
															[Local params(26434):Array<haxe.macro.Type>:Array<haxe.macro.Type>]
															[Const:Int] 0
														[Local typeParams(26435):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
													+
													[Const:String] " | nil"
											[Else:String] [Block:String] [Const:String] "nil"
							[Case:String]
								[Const:String] "Void"
								[Block:String] [Block:String] [Const:String] ":ok"
							[Default:String] [Block:String] [Const:String] "any()"

	static function compileFunctionType[Function:(args : Array<{ t : haxe.macro.Type, opt : Bool, name : String }>, ret : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
		[Arg:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>] [Local args(26440):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
		[Arg:haxe.macro.Type] [Local ret(26441):haxe.macro.Type]
		[Arg:Null<Array<haxe.macro.TypeParameter>>]
			[Local typeParams(26442):Null<Array<haxe.macro.TypeParameter>>]
			[Const:Null<Array<haxe.macro.TypeParameter>>] null
		[Block:Dynamic]
			[Var output(26443):StringBuf] [New:StringBuf] StringBuf
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26443):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] "("
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(26440):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
						[FInstance:Int]
							Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
							length:Int
					==
					[Const:Int] 0
				[Then:Void] [Block:Void]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26443):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] "() -> "
				[Else:Void] [Block:Void]
					[Var argTypes(26444):Array<String>] [ArrayDecl:Array<String>]
					[Block:Void]
						[Var `(26446):Int] [Const:Int] 0
						[While:Void]
							[Binop:Bool]
								[Local `(26446):Int:Int]
								<
								[Field:Int]
									[Local args(26440):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
									[FInstance:Int]
										Array<{ t : haxe.macro.Type, opt : Bool, name : String }>
										length:Int
							[Block:Void]
								[Var arg(26445):{ t : haxe.macro.Type, opt : Bool, name : String }]
									[Array:{ t : haxe.macro.Type, opt : Bool, name : String }]
										[Local args(26440):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
										[Local `(26446):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(26446):Int:Int]
								[Call:Int]
									[Field:(x : String) -> Int]
										[Local argTypes(26444):Array<String>:Array<String>]
										[FInstance:(x : String) -> Int]
											Array<String>
											push:(x : Array.T) -> Int
									[Call:String]
										[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
											[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
											[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
												reflaxe.elixir.helpers.TypedefCompiler
												compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
										[Field:haxe.macro.Type]
											[Local arg(26445):{ t : haxe.macro.Type, opt : Bool, name : String }:{ t : haxe.macro.Type, opt : Bool, name : String }]
											[FAnon:haxe.macro.Type] t:haxe.macro.Type
										[Local typeParams(26442):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26443):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Call:String]
							[Field:(sep : String) -> String]
								[Local argTypes(26444):Array<String>:Array<String>]
								[FInstance:(sep : String) -> String]
									Array<String>
									join:(sep : String) -> String
							[Const:String] ", "
					[Call:Void]
						[Field:(x : String) -> Void]
							[Local output(26443):StringBuf:StringBuf]
							[FInstance:(x : String) -> Void]
								StringBuf
								add:(x : add.T) -> Void
						[Const:String] " -> "
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26443):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Call:String]
					[Field:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
						[TypeExpr reflaxe.elixir.helpers.TypedefCompiler:Class<reflaxe.elixir.helpers.TypedefCompiler>]
						[FStatic:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String]
							reflaxe.elixir.helpers.TypedefCompiler
							compileType:(type : haxe.macro.Type, ?typeParams : Null<Array<haxe.macro.TypeParameter>>) -> String
					[Local ret(26441):haxe.macro.Type:haxe.macro.Type]
					[Local typeParams(26442):Null<Array<haxe.macro.TypeParameter>>:Null<Array<haxe.macro.TypeParameter>>]
			[Call:Void]
				[Field:(x : String) -> Void]
					[Local output(26443):StringBuf:StringBuf]
					[FInstance:(x : String) -> Void]
						StringBuf
						add:(x : add.T) -> Void
				[Const:String] ")"
			[Return:Dynamic]
				[Call:String]
					[Field:() -> String]
						[Local output(26443):StringBuf:StringBuf]
						[FInstance:() -> String]
							StringBuf
							toString:() -> String
}