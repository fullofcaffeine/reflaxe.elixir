@:nullSafety(Off)
class reflaxe.elixir.helpers.MethodCallCompiler {

	public function new[Function:(compiler : reflaxe.elixir.ElixirCompiler) -> Void]
		[Arg:reflaxe.elixir.ElixirCompiler] [Local compiler(28280):reflaxe.elixir.ElixirCompiler]
		[Block:reflaxe.elixir.ElixirCompiler]
			[Binop:reflaxe.elixir.ElixirCompiler]
				[Field:reflaxe.elixir.ElixirCompiler]
					[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
					[FInstance:reflaxe.elixir.ElixirCompiler]
						reflaxe.elixir.helpers.MethodCallCompiler
						compiler:reflaxe.elixir.ElixirCompiler
				=
				[Local compiler(28280):reflaxe.elixir.ElixirCompiler:reflaxe.elixir.ElixirCompiler]

	var compiler:reflaxe.elixir.ElixirCompiler;

	public function compileCallExpression[Function:(e : haxe.macro.TypedExpr, el : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(21965):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local el(21966):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(21978):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var result(23277):String]
				[Meta:String]
					:ast(switch (e.expr) {
	case TLocal(v) if (v.name == "getAppName"):
		var appName = AnnotationSystem.getEffectiveAppName(compiler.currentClassType);
		"\"${appName}\"";	
	case TLocal(v):
		var varType = v.t;
		var isFunction = switch (varType) {
			case TFun(_, _):
				true;			
			case _:
				false;			
		};
		if (isFunction) {
			var functionName = NamingHelper.toSnakeCase(v.name);
			var compiledArgs = el.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
			"${functionName}.(${compiledArgs.join(\", \")})";
		} else {
			compileMethodCall(e, el);
		};	
	case TField(obj, field):
		var fieldName = switch (field) {
			case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf):
				cf.get().name;			
			case FAnon(cf):
				cf.get().name;			
			case FEnum(_, ef):
				ef.name;			
			case FDynamic(s):
				s;			
		};
		if (obj.expr.match(TConst(TSuper)) && fieldName == "toString") {
			return "\"Exception\"";
		};
		if (isElixirSyntaxCall(obj, fieldName)) {
			return compileElixirSyntaxCall(fieldName, el);
		};
		if (isTypeSafeChildSpecCall(obj, fieldName)) {
			return compileTypeSafeChildSpecCall(fieldName, el);
		};
		if (fieldName == "getAppName") {
			var appName = AnnotationSystem.getEffectiveAppName(compiler.currentClassType);
			return "\"${appName}\"";
		};
		compileMethodCall(e, el);	
	case _:
		compileMethodCall(e, el);	
})
					[Block:String]
						[Var `(23236):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local e(21965):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(23236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 1
								[Block:String]
									[Var `(23237):haxe.macro.TVar]
										[EnumParameter:haxe.macro.TVar]
											[Local `(23236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TLocal
											0
									[Block:String]
										[Var v(23238):haxe.macro.TVar] [Local `(23237):haxe.macro.TVar:haxe.macro.TVar]
										[If:String]
											[Binop:Bool]
												[Field:String]
													[Local v(23238):haxe.macro.TVar:haxe.macro.TVar]
													[FAnon:String] name:String
												==
												[Const:String] "getAppName"
											[Then:String] [Block:String]
												[Var appName(23239):String]
													[Call:String]
														[Field:(classType : haxe.macro.ClassType) -> String]
															[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
															[FStatic:(classType : haxe.macro.ClassType) -> String]
																reflaxe.elixir.helpers.AnnotationSystem
																getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
														[Field:Null<haxe.macro.ClassType>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:Null<haxe.macro.ClassType>]
																reflaxe.elixir.ElixirCompiler
																currentClassType:Null<haxe.macro.ClassType>
												[Binop:String]
													[Binop:String]
														[Const:String] "\""
														+
														[Local appName(23239):String:String]
													+
													[Const:String] "\""
											[Else:String] [Block:String]
												[Var v(23240):haxe.macro.TVar] [Local `(23237):haxe.macro.TVar:haxe.macro.TVar]
												[Block:String]
													[Var varType(23241):haxe.macro.Type]
														[Field:haxe.macro.Type]
															[Local v(23240):haxe.macro.TVar:haxe.macro.TVar]
															[FAnon:haxe.macro.Type] t:haxe.macro.Type
													[Var isFunction(23242):Bool]
														[Meta:Bool]
															:ast(switch (varType) {
	case TFun(_, _):
		true;	
	case _:
		false;	
})
															[If:Bool]
																[Binop:Bool]
																	[EnumIndex:Int] [Local varType(23241):haxe.macro.Type:haxe.macro.Type]
																	==
																	[Const:Int] 4
																[Then:Bool] [Block:Bool]
																	[Var `(23243):Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																		[EnumParameter:Array<{ t : haxe.macro.Type, opt : Bool, name : String }>]
																			[Local varType(23241):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			0
																	[Var `(23244):haxe.macro.Type]
																		[EnumParameter:haxe.macro.Type]
																			[Local varType(23241):haxe.macro.Type:haxe.macro.Type]
																			TFun
																			1
																	[Block:Bool] [Const:Bool] true
																[Else:Bool] [Block:Bool] [Const:Bool] false
													[If:String]
														[Local isFunction(23242):Bool:Bool]
														[Then:String] [Block:String]
															[Var functionName(23245):String]
																[Call:String]
																	[Field:(camelCase : String) -> String]
																		[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																		[FStatic:(camelCase : String) -> String]
																			reflaxe.elixir.helpers.NamingHelper
																			toSnakeCase:(camelCase : String) -> String
																	[Field:String]
																		[Local v(23240):haxe.macro.TVar:haxe.macro.TVar]
																		[FAnon:String] name:String
															[Var compiledArgs(23246):Array<Null<String>>]
																[Block:Array<Null<String>>]
																	[Var `(23247):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
																	[Block:Void]
																		[Var `(23248):Int] [Const:Int] 0
																		[Var `(23249):Array<haxe.macro.TypedExpr>] [Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[While:Void]
																			[Binop:Bool]
																				[Local `(23248):Int:Int]
																				<
																				[Field:Int]
																					[Local `(23249):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																			[Block:Void]
																				[Var v(23250):haxe.macro.TypedExpr]
																					[Array:haxe.macro.TypedExpr]
																						[Local `(23249):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Local `(23248):Int:Int]
																				[Unop:Int]
																					++
																					Prefix
																					[Local `(23248):Int:Int]
																				[Call:Int]
																					[Field:(x : Null<String>) -> Int]
																						[Local `(23247):Array<Null<String>>:Array<Null<String>>]
																						[FInstance:(x : Null<String>) -> Int]
																							Array<Null<String>>
																							push:(x : Array.T) -> Int
																					[Call:Null<String>]
																						[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																							[Arg:haxe.macro.TypedExpr] [Local arg(23251):haxe.macro.TypedExpr]
																							[Block:Dynamic]
																								[Return:Dynamic]
																									[Call:Null<String>]
																										[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																											[Field:reflaxe.elixir.ElixirCompiler]
																												[Local `this(21978):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																												[FInstance:reflaxe.elixir.ElixirCompiler]
																													reflaxe.elixir.helpers.MethodCallCompiler
																													compiler:reflaxe.elixir.ElixirCompiler
																											[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																												reflaxe.elixir.ElixirCompiler
																												compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																										[Local arg(23251):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																										[Const:Null<Bool>] null
																						[Local v(23250):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																	[Local `(23247):Array<Null<String>>:Array<Null<String>>]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Binop:String]
																			[Const:String] ""
																			+
																			[Local functionName(23245):String:String]
																		+
																		[Const:String] ".("
																	+
																	[Call:String]
																		[Field:(sep : String) -> String]
																			[Local compiledArgs(23246):Array<Null<String>>:Array<Null<String>>]
																			[FInstance:(sep : String) -> String]
																				Array<Null<String>>
																				join:(sep : String) -> String
																		[Const:String] ", "
																+
																[Const:String] ")"
														[Else:String] [Block:String]
															[Call:String]
																[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
																	[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																	[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
																		reflaxe.elixir.helpers.MethodCallCompiler
																		compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
																[Local e(21965):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Case:String]
								[Const:Int] 4
								[Block:String]
									[Var `(23252):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(23236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(23253):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(23236):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:String]
										[Var obj(23254):haxe.macro.TypedExpr] [Local `(23252):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var field(23255):haxe.macro.FieldAccess] [Local `(23253):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:String]
											[Var fieldName(23256):String]
												[Meta:String]
													:ast(switch (field) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf):
		cf.get().name;	
	case FAnon(cf):
		cf.get().name;	
	case FEnum(_, ef):
		ef.name;	
	case FDynamic(s):
		s;	
})
													[Switch:String]
														[Meta:Int]
															:exhaustive
															[EnumIndex:Int] [Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
														[Case:String]
															[Const:Int] 0
															[Block:String]
																[Var `(23257):haxe.macro.Ref<haxe.macro.ClassType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		0
																[Var `(23258):Array<haxe.macro.Type>]
																	[EnumParameter:Array<haxe.macro.Type>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		1
																[Var `(23259):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FInstance
																		2
																[Block:String]
																	[Var cf(23260):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23259):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23260):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 1
															[Block:String]
																[Var `(23261):haxe.macro.Ref<haxe.macro.ClassType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FStatic
																		0
																[Var `(23262):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FStatic
																		1
																[Block:String]
																	[Var cf(23263):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23262):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23263):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 2
															[Block:String]
																[Var `(23264):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FAnon
																		0
																[Block:String]
																	[Var cf(23265):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23264):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23265):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 3
															[Block:String]
																[Var `(23266):String]
																	[EnumParameter:String]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FDynamic
																		0
																[Block:String]
																	[Var s(23267):String] [Local `(23266):String:String]
																	[Block:String] [Local s(23267):String:String]
														[Case:String]
															[Const:Int] 4
															[Block:String]
																[Var `(23268):Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																	[EnumParameter:Null<{ params : Array<haxe.macro.Type>, c : haxe.macro.Ref<haxe.macro.ClassType> }>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FClosure
																		0
																[Var `(23269):haxe.macro.Ref<haxe.macro.ClassField>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.ClassField>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FClosure
																		1
																[Block:String]
																	[Var cf(23270):haxe.macro.Ref<haxe.macro.ClassField>] [Local `(23269):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																	[Block:String]
																		[Field:String]
																			[Call:haxe.macro.ClassField]
																				[Field:() -> haxe.macro.ClassField]
																					[Local cf(23270):haxe.macro.Ref<haxe.macro.ClassField>:haxe.macro.Ref<haxe.macro.ClassField>]
																					[FAnon:() -> haxe.macro.ClassField] get:() -> haxe.macro.ClassField
																			[FAnon:String] name:String
														[Case:String]
															[Const:Int] 5
															[Block:String]
																[Var `(23271):haxe.macro.Ref<haxe.macro.EnumType>]
																	[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FEnum
																		0
																[Var `(23272):haxe.macro.EnumField]
																	[EnumParameter:haxe.macro.EnumField]
																		[Local field(23255):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
																		FEnum
																		1
																[Block:String]
																	[Var ef(23273):haxe.macro.EnumField] [Local `(23272):haxe.macro.EnumField:haxe.macro.EnumField]
																	[Block:String]
																		[Field:String]
																			[Local ef(23273):haxe.macro.EnumField:haxe.macro.EnumField]
																			[FAnon:String] name:String
											[If:Void]
												[Binop:Bool]
													[Block:Bool]
														[Var `(23274):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Local obj(23254):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:Bool]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23274):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:Bool] [Block:Bool]
																[Var `(23275):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23274):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:Bool]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23275):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 6
																	[Then:Bool] [Block:Bool] [Const:Bool] true
																	[Else:Bool] [Const:Bool] false
															[Else:Bool] [Const:Bool] false
													&&
													[Binop:Bool]
														[Local fieldName(23256):String:String]
														==
														[Const:String] "toString"
												[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:String] "\"Exception\""
											[If:Void]
												[Call:Bool]
													[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
															reflaxe.elixir.helpers.MethodCallCompiler
															isElixirSyntaxCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
													[Local obj(23254):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local fieldName(23256):String:String]
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Call:String]
															[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compileElixirSyntaxCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
															[Local fieldName(23256):String:String]
															[Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[If:Void]
												[Call:Bool]
													[Field:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
															reflaxe.elixir.helpers.MethodCallCompiler
															isTypeSafeChildSpecCall:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool
													[Local obj(23254):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
													[Local fieldName(23256):String:String]
												[Then:Dynamic] [Block:Dynamic]
													[Return:Dynamic]
														[Call:String]
															[Field:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																[FInstance:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compileTypeSafeChildSpecCall:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String
															[Local fieldName(23256):String:String]
															[Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[If:Void]
												[Binop:Bool]
													[Local fieldName(23256):String:String]
													==
													[Const:String] "getAppName"
												[Then:Dynamic] [Block:Dynamic]
													[Var appName(23276):String]
														[Call:String]
															[Field:(classType : haxe.macro.ClassType) -> String]
																[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
																[FStatic:(classType : haxe.macro.ClassType) -> String]
																	reflaxe.elixir.helpers.AnnotationSystem
																	getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
															[Field:Null<haxe.macro.ClassType>]
																[Field:reflaxe.elixir.ElixirCompiler]
																	[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																	[FInstance:reflaxe.elixir.ElixirCompiler]
																		reflaxe.elixir.helpers.MethodCallCompiler
																		compiler:reflaxe.elixir.ElixirCompiler
																[FInstance:Null<haxe.macro.ClassType>]
																	reflaxe.elixir.ElixirCompiler
																	currentClassType:Null<haxe.macro.ClassType>
													[Return:Dynamic]
														[Binop:String]
															[Binop:String]
																[Const:String] "\""
																+
																[Local appName(23276):String:String]
															+
															[Const:String] "\""
											[Call:String]
												[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
												[Local e(21965):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
												reflaxe.elixir.helpers.MethodCallCompiler
												compileMethodCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
										[Local e(21965):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local el(21966):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Return:Dynamic] [Local result(23277):String:String]

	public function compileMethodCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(21988):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(21989):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var result(22952):String]
				[Meta:String]
					:ast(switch (e.expr) {
	case TField(obj, fa):
		compileFieldMethodCall(obj, fa, args);	
	case TCall(funcExpr, callArgs):
		compileNestedCall(funcExpr, callArgs, args);	
	case _:
		compileGenericCall(e, args);	
})
					[Block:String]
						[Var `(22943):haxe.macro.TypedExprDef]
							[Field:haxe.macro.TypedExprDef]
								[Local e(21988):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
						[Switch:String]
							[EnumIndex:Int] [Local `(22943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							[Case:String]
								[Const:Int] 4
								[Block:String]
									[Var `(22944):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(22943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											0
									[Var `(22945):haxe.macro.FieldAccess]
										[EnumParameter:haxe.macro.FieldAccess]
											[Local `(22943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TField
											1
									[Block:String]
										[Var obj(22946):haxe.macro.TypedExpr] [Local `(22944):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var fa(22947):haxe.macro.FieldAccess] [Local `(22945):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
										[Block:String]
											[Call:String]
												[Field:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileFieldMethodCall:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String
												[Local obj(22946):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local fa(22947):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
												[Local args(21989):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Case:String]
								[Const:Int] 9
								[Block:String]
									[Var `(22948):haxe.macro.TypedExpr]
										[EnumParameter:haxe.macro.TypedExpr]
											[Local `(22943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											0
									[Var `(22949):Array<haxe.macro.TypedExpr>]
										[EnumParameter:Array<haxe.macro.TypedExpr>]
											[Local `(22943):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
											TCall
											1
									[Block:String]
										[Var funcExpr(22950):haxe.macro.TypedExpr] [Local `(22948):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Var callArgs(22951):Array<haxe.macro.TypedExpr>] [Local `(22949):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Block:String]
											[Call:String]
												[Field:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.helpers.MethodCallCompiler
														compileNestedCall:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String
												[Local funcExpr(22950):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
												[Local callArgs(22951):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local args(21989):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[Default:String]
								[Block:String]
									[Call:String]
										[Field:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
												reflaxe.elixir.helpers.MethodCallCompiler
												compileGenericCall:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String
										[Local e(21988):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
										[Local args(21989):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Return:Dynamic] [Local result(22952):String:String]

	function compileFieldMethodCall[Function:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local obj(21992):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(21993):haxe.macro.FieldAccess]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(21994):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[Var `this(22104):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var methodName(22086):String]
				[Call:String]
					[Field:(fa : haxe.macro.FieldAccess) -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(fa : haxe.macro.FieldAccess) -> String]
							reflaxe.elixir.ElixirCompiler
							getFieldName:(fa : haxe.macro.FieldAccess) -> String
					[Local fa(21993):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
			[Var objStr(22087):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local obj(21992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[If:Void]
				[Binop:Bool]
					[Call:Bool]
						[Field:() -> Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.MethodCallCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:() -> Bool]
								reflaxe.elixir.ElixirCompiler
								isStateThreadingEnabled:() -> Bool
					&&
					[Call:Bool]
						[Field:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
								reflaxe.elixir.helpers.MethodCallCompiler
								isStructMethodCall:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool
						[Local obj(21992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
						[Local fa(21993):haxe.macro.FieldAccess:haxe.macro.FieldAccess]
				[Then:Void] [Block:Void]
					[If:Void]
						[Call:Bool]
							[Field:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
									reflaxe.elixir.helpers.MethodCallCompiler
									isMutatingStructMethod:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool
							[Local obj(21992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local methodName(22086):String:String]
						[Then:Dynamic] [Block:Dynamic]
							[Var compiledArgs(22113):Array<Null<String>>]
								[Block:Array<Null<String>>]
									[Var `(22108):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(22109):Int] [Const:Int] 0
										[Var `(22110):Array<haxe.macro.TypedExpr>] [Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(22109):Int:Int]
												<
												[Field:Int]
													[Local `(22110):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(22111):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(22110):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(22109):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(22109):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(22108):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(22112):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(22104):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(22112):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(22111):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(22108):Array<Null<String>>:Array<Null<String>>]
							[Var callExpression(22116):String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Local objStr(22087):Null<String>:Null<String>]
													+
													[Const:String] "."
												+
												[Call:String]
													[Field:(haxeName : String) -> String]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(haxeName : String) -> String]
															reflaxe.elixir.ElixirCompiler
															toElixirName:(haxeName : String) -> String
													[Local methodName(22086):String:String]
											+
											[Const:String] "("
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(22113):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Local objStr(22087):Null<String>:Null<String>]
										+
										[Const:String] " = "
									+
									[Local callExpression(22116):String:String]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22087):Null<String>:Null<String>]
						==
						[Const:String] "Phoenix.PubSub"
					||
					[Binop:Bool]
						[Local objStr(22087):Null<String>:Null<String>]
						==
						[Const:String] "PubSub"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.helpers.MethodCallCompiler
									compilePubSubCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local methodName(22086):String:String]
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22087):Null<String>:Null<String>]
						==
						[Const:String] "HXX"
					&&
					[Binop:Bool]
						[Local methodName(22086):String:String]
						==
						[Const:String] "hxx"
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileHxxCall:(args : Array<haxe.macro.TypedExpr>) -> String
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local methodName(22086):String:String]
						==
						[Const:String] "hxx"
					&&
					[Binop:Bool]
						[Field:Int]
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
							[FInstance:Int]
								Array<haxe.macro.TypedExpr>
								length:Int
						==
						[Const:Int] 1
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileHxxCall:(args : Array<haxe.macro.TypedExpr>) -> String
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Binop:Bool]
						[Local objStr(22087):Null<String>:Null<String>]
						==
						[Const:String] "OptionTools"
					&&
					[Call:Bool]
						[Field:(methodName : String) -> Bool]
							[Field:reflaxe.elixir.ElixirCompiler]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:reflaxe.elixir.ElixirCompiler]
									reflaxe.elixir.helpers.MethodCallCompiler
									compiler:reflaxe.elixir.ElixirCompiler
							[FInstance:(methodName : String) -> Bool]
								reflaxe.elixir.ElixirCompiler
								isOptionMethod:(methodName : String) -> Bool
						[Local methodName(22086):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Var compiledArgs(22147):Array<Null<String>>]
						[Block:Array<Null<String>>]
							[Var `(22142):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
							[Block:Void]
								[Var `(22143):Int] [Const:Int] 0
								[Var `(22144):Array<haxe.macro.TypedExpr>] [Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[While:Void]
									[Binop:Bool]
										[Local `(22143):Int:Int]
										<
										[Field:Int]
											[Local `(22144):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
									[Block:Void]
										[Var v(22145):haxe.macro.TypedExpr]
											[Array:haxe.macro.TypedExpr]
												[Local `(22144):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[Local `(22143):Int:Int]
										[Unop:Int]
											++
											Prefix
											[Local `(22143):Int:Int]
										[Call:Int]
											[Field:(x : Null<String>) -> Int]
												[Local `(22142):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(x : Null<String>) -> Int]
													Array<Null<String>>
													push:(x : Array.T) -> Int
											[Call:Null<String>]
												[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
													[Arg:haxe.macro.TypedExpr] [Local arg(22146):haxe.macro.TypedExpr]
													[Block:Dynamic]
														[Return:Dynamic]
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Local `this(22104):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Local arg(22146):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																[Const:Null<Bool>] null
												[Local v(22145):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[Local `(22142):Array<Null<String>>:Array<Null<String>>]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Const:String] "OptionTools."
										+
										[Local methodName(22086):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local compiledArgs(22147):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"
				[Else:Void] [Block:Void]
					[If:Void]
						[Binop:Bool]
							[Binop:Bool]
								[Local objStr(22087):Null<String>:Null<String>]
								==
								[Const:String] "ResultTools"
							&&
							[Call:Bool]
								[Field:(methodName : String) -> Bool]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.MethodCallCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:(methodName : String) -> Bool]
										reflaxe.elixir.ElixirCompiler
										isResultMethod:(methodName : String) -> Bool
								[Local methodName(22086):String:String]
						[Then:Dynamic] [Block:Dynamic]
							[Var compiledArgs(22159):Array<Null<String>>]
								[Block:Array<Null<String>>]
									[Var `(22154):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(22155):Int] [Const:Int] 0
										[Var `(22156):Array<haxe.macro.TypedExpr>] [Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(22155):Int:Int]
												<
												[Field:Int]
													[Local `(22156):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(22157):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(22156):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(22155):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(22155):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(22154):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(22158):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(22104):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(22158):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(22157):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(22154):Array<Null<String>>:Array<Null<String>>]
							[Return:Dynamic]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Const:String] "ResultTools."
												+
												[Local methodName(22086):String:String]
											+
											[Const:String] "("
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(22159):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"
						[Else:Void] [Block:Void]
							[If:Void]
								[Binop:Bool]
									[Binop:Bool]
										[Local objStr(22087):Null<String>:Null<String>]
										==
										[Const:String] "ArrayTools"
									&&
									[Call:Bool]
										[Field:(methodName : String) -> Bool]
											[Field:reflaxe.elixir.ElixirCompiler]
												[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
												[FInstance:reflaxe.elixir.ElixirCompiler]
													reflaxe.elixir.helpers.MethodCallCompiler
													compiler:reflaxe.elixir.ElixirCompiler
											[FInstance:(methodName : String) -> Bool]
												reflaxe.elixir.ElixirCompiler
												isArrayMethod:(methodName : String) -> Bool
										[Local methodName(22086):String:String]
								[Then:Dynamic] [Block:Dynamic]
									[Return:Dynamic]
										[Call:String]
											[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
												[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
												[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
													reflaxe.elixir.helpers.MethodCallCompiler
													compileArrayToolsCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
											[Local methodName(22086):String:String]
											[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Else:Void] [Block:Void]
									[If:Void]
										[Binop:Bool]
											[Binop:Bool]
												[Local objStr(22087):Null<String>:Null<String>]
												==
												[Const:String] "MapTools"
											&&
											[Call:Bool]
												[Field:(methodName : String) -> Bool]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.MethodCallCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(methodName : String) -> Bool]
														reflaxe.elixir.ElixirCompiler
														isMapMethod:(methodName : String) -> Bool
												[Local methodName(22086):String:String]
										[Then:Dynamic] [Block:Dynamic]
											[Return:Dynamic]
												[Call:String]
													[Field:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
															reflaxe.elixir.helpers.MethodCallCompiler
															compileMapToolsCall:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
													[Local methodName(22086):String:String]
													[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Meta:Void]
				:ast(switch (obj.t) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var compiled = compiler.compileADTStaticExtension(enumType, methodName, objStr, args);
		if (compiled != null) return compiled;	
	case _:
})
				[Block:Void]
					[Var `(22852):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local obj(21992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Type] t:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(22852):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 1
						[Then:Void] [Block:Void]
							[Var `(22853):haxe.macro.Ref<haxe.macro.EnumType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
									[Local `(22852):haxe.macro.Type:haxe.macro.Type]
									TEnum
									0
							[Var `(22854):Array<haxe.macro.Type>]
								[EnumParameter:Array<haxe.macro.Type>]
									[Local `(22852):haxe.macro.Type:haxe.macro.Type]
									TEnum
									1
							[Block:Void]
								[Var enumRef(22855):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(22853):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
								[Block:Void]
									[Var enumType(22856):haxe.macro.EnumType]
										[Call:haxe.macro.EnumType]
											[Field:() -> haxe.macro.EnumType]
												[Local enumRef(22855):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
												[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
									[Var compiled(22857):Null<String>]
										[Call:Null<String>]
											[Field:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.MethodCallCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>]
													reflaxe.elixir.ElixirCompiler
													compileADTStaticExtension:(enumType : haxe.macro.EnumType, methodName : String, objStr : String, args : Array<haxe.macro.TypedExpr>) -> Null<String>
											[Local enumType(22856):haxe.macro.EnumType:haxe.macro.EnumType]
											[Local methodName(22086):String:String]
											[Local objStr(22087):Null<String>:Null<String>]
											[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[If:Void]
										[Binop:Bool]
											[Local compiled(22857):Null<String>:Null<String>]
											!=
											[Const:Null<String>] null
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiled(22857):Null<String>:Null<String>]
						[Else:Void] [Block:Void]
			[Meta:Void]
				:ast(switch (obj.t) {
	case TInst(t, _) if (t.get().name == "Array"):
		return compiler.compileArrayMethod(objStr, methodName, args);	
	case _:
})
				[Block:Void]
					[Var `(22862):haxe.macro.Type]
						[Field:haxe.macro.Type]
							[Local obj(21992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.Type] t:haxe.macro.Type
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(22862):haxe.macro.Type:haxe.macro.Type]
							==
							[Const:Int] 2
						[Then:Void] [Block:Void]
							[Var `(22863):haxe.macro.Ref<haxe.macro.ClassType>]
								[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
									[Local `(22862):haxe.macro.Type:haxe.macro.Type]
									TInst
									0
							[Var `(22864):Array<haxe.macro.Type>]
								[EnumParameter:Array<haxe.macro.Type>]
									[Local `(22862):haxe.macro.Type:haxe.macro.Type]
									TInst
									1
							[Block:Void]
								[Var t(22865):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(22863):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
								[If:Void]
									[Binop:Bool]
										[Field:String]
											[Call:haxe.macro.ClassType]
												[Field:() -> haxe.macro.ClassType]
													[Local t(22865):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
													[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
											[FAnon:String] name:String
										==
										[Const:String] "Array"
									[Then:Dynamic] [Block:Dynamic]
										[Return:Dynamic]
											[Call:String]
												[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
													[Field:reflaxe.elixir.ElixirCompiler]
														[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
														[FInstance:reflaxe.elixir.ElixirCompiler]
															reflaxe.elixir.helpers.MethodCallCompiler
															compiler:reflaxe.elixir.ElixirCompiler
													[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
														reflaxe.elixir.ElixirCompiler
														compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
												[Local objStr(22087):Null<String>:Null<String>]
												[Local methodName(22086):String:String]
												[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[Else:Void] [Block:Void]
						[Else:Void] [Block:Void]
			[If:Void]
				[Call:Bool]
					[Field:(methodName : String) -> Bool]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(methodName : String) -> Bool]
							reflaxe.elixir.ElixirCompiler
							isArrayMethod:(methodName : String) -> Bool
					[Local methodName(22086):String:String]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local objStr(22087):Null<String>:Null<String>]
							[Local methodName(22086):String:String]
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[Var compiledArgs(22875):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(22870):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(22871):Int] [Const:Int] 0
						[Var `(22872):Array<haxe.macro.TypedExpr>] [Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(22871):Int:Int]
								<
								[Field:Int]
									[Local `(22872):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(22873):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(22872):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(22871):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(22871):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(22870):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(22874):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22104):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(22874):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(22873):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(22870):Array<Null<String>>:Array<Null<String>>]
			[If:Void]
				[Call:Bool]
					[Field:(typeName : String) -> Bool]
						[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
						[FStatic:(typeName : String) -> Bool]
							reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
							isADTTypeName:(typeName : String) -> Bool
					[Local objStr(22087):Null<String>:Null<String>]
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.helpers.MethodCallCompiler
									compileADTConstructorCall:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local objStr(22087):Null<String>:Null<String>]
							[Local methodName(22086):String:String]
							[Local args(21994):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
			[If:Void]
				[Binop:Bool]
					[Call:Int]
						[Field:(str : String, ?startIndex : Null<Int>) -> Int]
							[Local methodName(22086):String:String]
							[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
								String
								indexOf:(str : String, ?startIndex : Null<Int>) -> Int
						[Const:String] "."
						[Const:Null<Int>] null
					>=
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Local methodName(22086):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Call:Array<Null<String>>]
											[Field:(a : Array<Null<String>>) -> Array<Null<String>>]
												[ArrayDecl:Array<Null<String>>] [Local objStr(22087):Null<String>:Null<String>]
												[FInstance:(a : Array<Null<String>>) -> Array<Null<String>>]
													Array<Null<String>>
													concat:(a : Array<Array.T>) -> Array<Array.T>
											[Local compiledArgs(22875):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Local objStr(22087):Null<String>:Null<String>]
											+
											[Const:String] "."
										+
										[Call:String]
											[Field:(haxeName : String) -> String]
												[Field:reflaxe.elixir.ElixirCompiler]
													[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
													[FInstance:reflaxe.elixir.ElixirCompiler]
														reflaxe.elixir.helpers.MethodCallCompiler
														compiler:reflaxe.elixir.ElixirCompiler
												[FInstance:(haxeName : String) -> String]
													reflaxe.elixir.ElixirCompiler
													toElixirName:(haxeName : String) -> String
											[Local methodName(22086):String:String]
									+
									[Const:String] "("
								+
								[Call:String]
									[Field:(sep : String) -> String]
										[Local compiledArgs(22875):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(sep : String) -> String]
											Array<Null<String>>
											join:(sep : String) -> String
									[Const:String] ", "
							+
							[Const:String] ")"

	function compilePubSubCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22117):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22118):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22120):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var compiledArgs(22129):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(22124):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(22125):Int] [Const:Int] 0
						[Var `(22126):Array<haxe.macro.TypedExpr>] [Local args(22118):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(22125):Int:Int]
								<
								[Field:Int]
									[Local `(22126):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(22127):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(22126):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(22125):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(22125):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(22124):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(22128):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22120):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(22128):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(22127):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(22124):Array<Null<String>>:Array<Null<String>>]
			[Var appName(22133):String]
				[Call:String]
					[Field:() -> String]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:() -> String]
							reflaxe.elixir.ElixirCompiler
							getCurrentAppName:() -> String
			[Var pubsubModule(22134):String]
				[Binop:String]
					[Local appName(22133):String:String]
					+
					[Const:String] ".PubSub"
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodName) {
	case "subscribe":
		"Phoenix.PubSub.subscribe(" + pubsubModule + ", " + compiledArgs.join(", ") + ")";	
	case "broadcast":
		"Phoenix.PubSub.broadcast(" + pubsubModule + ", " + compiledArgs.join(", ") + ")";	
	case "broadcast_from":
		"Phoenix.PubSub.broadcast_from(" + pubsubModule + ", " + compiledArgs.join(", ") + ")";	
	default:
		"Phoenix.PubSub." + methodName + "(" + pubsubModule + ", " + compiledArgs.join(", ") + ")";	
})
					[Switch:String]
						[Local methodName(22117):String:String]
						[Case:String]
							[Const:String] "broadcast"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "Phoenix.PubSub.broadcast("
													+
													[Local pubsubModule(22134):String:String]
												+
												[Const:String] ", "
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(22129):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] ")"
						[Case:String]
							[Const:String] "broadcast_from"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "Phoenix.PubSub.broadcast_from("
													+
													[Local pubsubModule(22134):String:String]
												+
												[Const:String] ", "
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(22129):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] ")"
						[Case:String]
							[Const:String] "subscribe"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "Phoenix.PubSub.subscribe("
													+
													[Local pubsubModule(22134):String:String]
												+
												[Const:String] ", "
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(22129):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] ")"
						[Default:String]
							[Block:String]
								[Binop:String]
									[Binop:String]
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "Phoenix.PubSub."
														+
														[Local methodName(22117):String:String]
													+
													[Const:String] "("
												+
												[Local pubsubModule(22134):String:String]
											+
											[Const:String] ", "
										+
										[Call:String]
											[Field:(sep : String) -> String]
												[Local compiledArgs(22129):Array<Null<String>>:Array<Null<String>>]
												[FInstance:(sep : String) -> String]
													Array<Null<String>>
													join:(sep : String) -> String
											[Const:String] ", "
									+
									[Const:String] ")"

	function compileArrayToolsCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22162):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22163):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(22163):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var arrayExpr(22164):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Array:haxe.macro.TypedExpr]
								[Local args(22163):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Const:Int] 0
							[Const:Null<Bool>] null
					[Var methodArgs(22165):Array<haxe.macro.TypedExpr>]
						[Call:Array<haxe.macro.TypedExpr>]
							[Field:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
								[Local args(22163):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[FInstance:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
									Array<haxe.macro.TypedExpr>
									slice:(pos : Int, ?end : Null<Int>) -> Array<Array.T>
							[Const:Int] 1
							[Const:Null<Int>] null
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileArrayMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local arrayExpr(22164):Null<String>:Null<String>]
							[Local methodName(22162):String:String]
							[Local methodArgs(22165):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "ArrayTools."
								+
								[Local methodName(22162):String:String]
							+
							[Const:String] "()"

	function compileMapToolsCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(22535):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22536):Array<haxe.macro.TypedExpr>]
		[Block:Void]
			[If:Void]
				[Binop:Bool]
					[Field:Int]
						[Local args(22536):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[FInstance:Int]
							Array<haxe.macro.TypedExpr>
							length:Int
					>
					[Const:Int] 0
				[Then:Dynamic] [Block:Dynamic]
					[Var mapExpr(22537):Null<String>]
						[Call:Null<String>]
							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									reflaxe.elixir.ElixirCompiler
									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
							[Array:haxe.macro.TypedExpr]
								[Local args(22536):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[Const:Int] 0
							[Const:Null<Bool>] null
					[Var methodArgs(22538):Array<haxe.macro.TypedExpr>]
						[Call:Array<haxe.macro.TypedExpr>]
							[Field:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
								[Local args(22536):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
								[FInstance:(pos : Int, ?end : Null<Int>) -> Array<haxe.macro.TypedExpr>]
									Array<haxe.macro.TypedExpr>
									slice:(pos : Int, ?end : Null<Int>) -> Array<Array.T>
							[Const:Int] 1
							[Const:Null<Int>] null
					[Return:Dynamic]
						[Call:String]
							[Field:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
								[Field:reflaxe.elixir.ElixirCompiler]
									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
									[FInstance:reflaxe.elixir.ElixirCompiler]
										reflaxe.elixir.helpers.MethodCallCompiler
										compiler:reflaxe.elixir.ElixirCompiler
								[FInstance:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
									reflaxe.elixir.ElixirCompiler
									compileMapMethod:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String
							[Local mapExpr(22537):Null<String>:Null<String>]
							[Local methodName(22535):String:String]
							[Local methodArgs(22538):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
				[Else:Dynamic] [Block:Dynamic]
					[Return:Dynamic]
						[Binop:String]
							[Binop:String]
								[Const:String] "MapTools."
								+
								[Local methodName(22535):String:String]
							+
							[Const:String] "()"

	function compileADTConstructorCall[Function:(objStr : String, methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local objStr(22876):String]
		[Arg:String] [Local methodName(22877):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22878):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22897):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var config(22879):Null<reflaxe.elixir.helpers.ADTConfig>]
				[Call:Null<reflaxe.elixir.helpers.ADTConfig>]
					[Field:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>]
						[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
						[FStatic:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>]
							reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
							getADTConfigByTypeName:(typeName : String) -> Null<reflaxe.elixir.helpers.ADTConfig>
					[Local objStr(22876):String:String]
			[If:Void]
				[Binop:Bool]
					[Local config(22879):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
					!=
					[Const:Null<reflaxe.elixir.helpers.ADTConfig>] null
				[Then:Void] [Block:Void]
					[Var enumType(22880):Null<haxe.macro.EnumType>] [Const:Null<haxe.macro.EnumType>] null
					[Try:Void]
						[Block:Void]
							[Var fullTypeName(22881):String]
								[Binop:String]
									[Binop:String]
										[Field:String]
											[Local config(22879):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
											[FAnon:String] moduleName:String
										+
										[Const:String] "."
									+
									[Field:String]
										[Local config(22879):Null<reflaxe.elixir.helpers.ADTConfig>:Null<reflaxe.elixir.helpers.ADTConfig>]
										[FAnon:String] typeName:String
							[Var adtType(22882):haxe.macro.Type]
								[Call:haxe.macro.Type]
									[Field:(name : String) -> haxe.macro.Type]
										[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
										[FStatic:(name : String) -> haxe.macro.Type]
											haxe.macro.Context
											getType:(name : String) -> haxe.macro.Type
									[Local fullTypeName(22881):String:String]
							[Meta:Void]
								:ast(switch (adtType) {
	case TEnum(enumRef, _):
		enumType = enumRef.get();
		if (!AlgebraicDataTypeCompiler.isADTType(enumType)) {
			enumType = null;
		};	
	case _:
})
								[If:Void]
									[Binop:Bool]
										[EnumIndex:Int] [Local adtType(22882):haxe.macro.Type:haxe.macro.Type]
										==
										[Const:Int] 1
									[Then:Void] [Block:Void]
										[Var `(22886):haxe.macro.Ref<haxe.macro.EnumType>]
											[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
												[Local adtType(22882):haxe.macro.Type:haxe.macro.Type]
												TEnum
												0
										[Var `(22887):Array<haxe.macro.Type>]
											[EnumParameter:Array<haxe.macro.Type>]
												[Local adtType(22882):haxe.macro.Type:haxe.macro.Type]
												TEnum
												1
										[Block:Void]
											[Var enumRef(22888):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(22886):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
											[Block:Void]
												[Binop:Null<haxe.macro.EnumType>]
													[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
													=
													[Call:haxe.macro.EnumType]
														[Field:() -> haxe.macro.EnumType]
															[Local enumRef(22888):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
															[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
												[If:Void]
													[Unop:Bool]
														!
														Prefix
														[Call:Bool]
															[Field:(enumType : haxe.macro.EnumType) -> Bool]
																[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
																[FStatic:(enumType : haxe.macro.EnumType) -> Bool]
																	reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
																	isADTType:(enumType : haxe.macro.EnumType) -> Bool
															[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
													[Then:Null<haxe.macro.EnumType>] [Block:Null<haxe.macro.EnumType>]
														[Binop:Null<haxe.macro.EnumType>]
															[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
															=
															[Const:Null<haxe.macro.EnumType>] null
									[Else:Void] [Block:Void]
						Catch [Local `(34261):Dynamic]
							[Block:Void]
								[Block:Void]
								[Block:Void]
								[If:Void]
									[Const:Bool] true
									[Then:Void] [Block:Void]
										[Block:Void]
										[Block:Void]
									[Else:Unknown<65>] [Throw:Unknown<65>] [Local `(34261):Dynamic:Dynamic]
					[If:Void]
						[Binop:Bool]
							[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
							!=
							[Const:Null<haxe.macro.EnumType>] null
						[Then:Void] [Block:Void]
							[Var fakeField(22890):Null<haxe.macro.EnumField>] [Const:Null<haxe.macro.EnumField>] null
							[For:Void]
								[Local field(22895):haxe.macro.EnumField]
								[Block:Iterator<haxe.macro.EnumField>]
									[Var this(22894):haxe.IMap<String, haxe.macro.EnumField>]
										[Field:Map<String, haxe.macro.EnumField>]
											[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
											[FAnon:Map<String, haxe.macro.EnumField>] constructs:Map<String, haxe.macro.EnumField>
									[Call:Iterator<haxe.macro.EnumField>]
										[Field:() -> Iterator<haxe.macro.EnumField>]
											[Cast:haxe.ds.StringMap<haxe.macro.EnumField>] [Local this(22894):haxe.IMap<String, haxe.macro.EnumField>:haxe.IMap<String, haxe.macro.EnumField>]
											[FInstance:() -> Iterator<haxe.macro.EnumField>]
												haxe.ds.StringMap<haxe.macro.EnumField>
												iterator:() -> Iterator<haxe.ds.StringMap.T>
								[Block:Void]
									[If:Void]
										[Binop:Bool]
											[Call:String]
												[Field:() -> String]
													[Field:String]
														[Local field(22895):haxe.macro.EnumField:haxe.macro.EnumField]
														[FAnon:String] name:String
													[FInstance:() -> String]
														String
														toLowerCase:() -> String
											==
											[Call:String]
												[Field:() -> String]
													[Local methodName(22877):String:String]
													[FInstance:() -> String]
														String
														toLowerCase:() -> String
										[Then:Dynamic] [Block:Dynamic]
											[Binop:Null<haxe.macro.EnumField>]
												[Local fakeField(22890):Null<haxe.macro.EnumField>:Null<haxe.macro.EnumField>]
												=
												[Local field(22895):haxe.macro.EnumField:haxe.macro.EnumField]
											[Break:Dynamic]
							[If:Void]
								[Binop:Bool]
									[Local fakeField(22890):Null<haxe.macro.EnumField>:Null<haxe.macro.EnumField>]
									!=
									[Const:Null<haxe.macro.EnumField>] null
								[Then:Void] [Block:Void]
									[Var compiled(22898):Null<String>]
										[Call:Null<String>]
											[Field:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>]
												[TypeExpr reflaxe.elixir.helpers.AlgebraicDataTypeCompiler:Class<reflaxe.elixir.helpers.AlgebraicDataTypeCompiler>]
												[FStatic:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>]
													reflaxe.elixir.helpers.AlgebraicDataTypeCompiler
													compileADTMethodCall:(enumType : haxe.macro.EnumType, methodName : String, args : Array<haxe.macro.TypedExpr>, compileExpr : (haxe.macro.TypedExpr -> Null<String>)) -> Null<String>
											[Local enumType(22880):Null<haxe.macro.EnumType>:Null<haxe.macro.EnumType>]
											[Local methodName(22877):String:String]
											[Local args(22878):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[Function:(expr : haxe.macro.TypedExpr) -> Null<String>]
												[Arg:haxe.macro.TypedExpr] [Local expr(22896):haxe.macro.TypedExpr]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22897):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local expr(22896):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
									[If:Void]
										[Binop:Bool]
											[Local compiled(22898):Null<String>:Null<String>]
											!=
											[Const:Null<String>] null
										[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Local compiled(22898):Null<String>:Null<String>]
			[Var compiledArgs(22908):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(22903):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(22904):Int] [Const:Int] 0
						[Var `(22905):Array<haxe.macro.TypedExpr>] [Local args(22878):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(22904):Int:Int]
								<
								[Field:Int]
									[Local `(22905):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(22906):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(22905):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(22904):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(22904):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(22903):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(22907):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22897):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(22907):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(22906):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(22903):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Binop:String]
								[Binop:String]
									[Local objStr(22876):String:String]
									+
									[Const:String] "."
								+
								[Call:String]
									[Field:(haxeName : String) -> String]
										[Field:reflaxe.elixir.ElixirCompiler]
											[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
											[FInstance:reflaxe.elixir.ElixirCompiler]
												reflaxe.elixir.helpers.MethodCallCompiler
												compiler:reflaxe.elixir.ElixirCompiler
										[FInstance:(haxeName : String) -> String]
											reflaxe.elixir.ElixirCompiler
											toElixirName:(haxeName : String) -> String
									[Local methodName(22877):String:String]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local compiledArgs(22908):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileNestedCall[Function:(funcExpr : haxe.macro.TypedExpr, callArgs : Array<haxe.macro.TypedExpr>, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local funcExpr(22911):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local callArgs(22912):Array<haxe.macro.TypedExpr>]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22913):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22915):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Call:Null<String>]
								[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
									[Field:reflaxe.elixir.ElixirCompiler]
										[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
										[FInstance:reflaxe.elixir.ElixirCompiler]
											reflaxe.elixir.helpers.MethodCallCompiler
											compiler:reflaxe.elixir.ElixirCompiler
									[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
										reflaxe.elixir.ElixirCompiler
										compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
								[Local funcExpr(22911):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
								[Const:Null<Bool>] null
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Block:Array<Null<String>>]
									[Var `(22919):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
									[Block:Void]
										[Var `(22920):Int] [Const:Int] 0
										[Var `(22921):Array<haxe.macro.TypedExpr>] [Local args(22913):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[While:Void]
											[Binop:Bool]
												[Local `(22920):Int:Int]
												<
												[Field:Int]
													[Local `(22921):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
													[FInstance:Int]
														Array<haxe.macro.TypedExpr>
														length:Int
											[Block:Void]
												[Var v(22922):haxe.macro.TypedExpr]
													[Array:haxe.macro.TypedExpr]
														[Local `(22921):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Local `(22920):Int:Int]
												[Unop:Int]
													++
													Prefix
													[Local `(22920):Int:Int]
												[Call:Int]
													[Field:(x : Null<String>) -> Int]
														[Local `(22919):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(x : Null<String>) -> Int]
															Array<Null<String>>
															push:(x : Array.T) -> Int
													[Call:Null<String>]
														[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
															[Arg:haxe.macro.TypedExpr] [Local arg(22923):haxe.macro.TypedExpr]
															[Block:Dynamic]
																[Return:Dynamic]
																	[Call:Null<String>]
																		[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			[Field:reflaxe.elixir.ElixirCompiler]
																				[Local `this(22915):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																				[FInstance:reflaxe.elixir.ElixirCompiler]
																					reflaxe.elixir.helpers.MethodCallCompiler
																					compiler:reflaxe.elixir.ElixirCompiler
																			[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				reflaxe.elixir.ElixirCompiler
																				compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																		[Local arg(22923):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																		[Const:Null<Bool>] null
														[Local v(22922):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
									[Local `(22919):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	function compileGenericCall[Function:(e : haxe.macro.TypedExpr, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:haxe.macro.TypedExpr] [Local e(22924):haxe.macro.TypedExpr]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(22925):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(22928):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var functionName(22926):Null<String>]
				[Call:Null<String>]
					[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
							reflaxe.elixir.ElixirCompiler
							compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
					[Local e(22924):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Const:Null<Bool>] null
			[Var compiledArgs(22937):Array<Null<String>>]
				[Block:Array<Null<String>>]
					[Var `(22932):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
					[Block:Void]
						[Var `(22933):Int] [Const:Int] 0
						[Var `(22934):Array<haxe.macro.TypedExpr>] [Local args(22925):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
						[While:Void]
							[Binop:Bool]
								[Local `(22933):Int:Int]
								<
								[Field:Int]
									[Local `(22934):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
									[FInstance:Int]
										Array<haxe.macro.TypedExpr>
										length:Int
							[Block:Void]
								[Var v(22935):haxe.macro.TypedExpr]
									[Array:haxe.macro.TypedExpr]
										[Local `(22934):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
										[Local `(22933):Int:Int]
								[Unop:Int]
									++
									Prefix
									[Local `(22933):Int:Int]
								[Call:Int]
									[Field:(x : Null<String>) -> Int]
										[Local `(22932):Array<Null<String>>:Array<Null<String>>]
										[FInstance:(x : Null<String>) -> Int]
											Array<Null<String>>
											push:(x : Array.T) -> Int
									[Call:Null<String>]
										[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
											[Arg:haxe.macro.TypedExpr] [Local arg(22936):haxe.macro.TypedExpr]
											[Block:Dynamic]
												[Return:Dynamic]
													[Call:Null<String>]
														[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															[Field:reflaxe.elixir.ElixirCompiler]
																[Local `this(22928):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																[FInstance:reflaxe.elixir.ElixirCompiler]
																	reflaxe.elixir.helpers.MethodCallCompiler
																	compiler:reflaxe.elixir.ElixirCompiler
															[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																reflaxe.elixir.ElixirCompiler
																compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
														[Local arg(22936):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Const:Null<Bool>] null
										[Local v(22935):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
					[Local `(22932):Array<Null<String>>:Array<Null<String>>]
			[Return:Dynamic]
				[Binop:String]
					[Binop:String]
						[Binop:String]
							[Local functionName(22926):Null<String>:Null<String>]
							+
							[Const:String] "("
						+
						[Call:String]
							[Field:(sep : String) -> String]
								[Local compiledArgs(22937):Array<Null<String>>:Array<Null<String>>]
								[FInstance:(sep : String) -> String]
									Array<Null<String>>
									join:(sep : String) -> String
							[Const:String] ", "
					+
					[Const:String] ")"

	public function compileElixirSyntaxCall[Function:(methodName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local methodName(23024):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23025):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23065):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (methodName) {
	case "code":
		if (args.length == 0) {
			Context.error("elixir.Syntax.code requires at least one String argument.", Context.currentPos());
			"";
		} else {
			var codeString = switch (args[0].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.code first parameter must be a constant String.", args[0].pos);
					"";				
			};
			var compiledArgs = [];
			for (i  in  1 ... args.length) {
				compiledArgs.push(compiler.compileExpression(args[i]));
			};
			var placeholderCount = 0;
			~/{(\d+)}/.map(codeString, function(ereg) {
				var num = Std.parseInt(ereg.matched(1));
				if (num != null && num >= placeholderCount) {
					placeholderCount = num + 1;
				};
				return ereg.matched(0);
			});
			if (placeholderCount > compiledArgs.length) {
				Context.error("elixir.Syntax.code() requires ${placeholderCount} arguments but ${compiledArgs.length} provided", Context.currentPos());
			};
			var result = ~/{(\d+)}/.map(codeString, function(ereg) {
				var num = Std.parseInt(ereg.matched(1));
				return (num != null && num < compiledArgs.length) ? compiledArgs[num] : ereg.matched(0);
			});
			return result;
		};	
	case "plainCode":
		if (args.length != 1) {
			Context.error("elixir.Syntax.plainCode requires exactly one String argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.plainCode parameter must be a constant String.", args[0].pos);
					"";				
			};
		};	
	case "atom":
		if (args.length != 1) {
			Context.error("elixir.Syntax.atom requires exactly one String argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TConst(TString(s)):
					":$s";				
				case _:
					var atomName = compiler.compileExpression(args[0]);
					":${atomName}";				
			};
		};	
	case "tuple":
		var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
		"{${compiledArgs.join(\", \")}}";	
	case "keyword":
		if (args.length != 1) {
			Context.error("elixir.Syntax.keyword requires exactly one Array argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TArrayDecl(elements):
					if (elements.length % 2 != 0) {
						Context.error("elixir.Syntax.keyword array must have an even number of elements (key-value pairs).", args[0].pos);
						"";
					} else {
						var pairs = [];
						var i = 0;
						while (i < elements.length) {
							var key = compiler.compileExpression(elements[i]);
							var value = compiler.compileExpression(elements[i + 1]);
							pairs.push("${key}: ${value}");
							i += 2;
						};
						"[${pairs.join(\", \")}]";
					};				
				case _:
					Context.error("elixir.Syntax.keyword parameter must be an array literal.", args[0].pos);
					"";				
			};
		};	
	case "map":
		if (args.length != 1) {
			Context.error("elixir.Syntax.map requires exactly one Array argument.", Context.currentPos());
			"";
		} else {
			switch (args[0].expr) {
				case TArrayDecl(elements):
					if (elements.length % 2 != 0) {
						Context.error("elixir.Syntax.map array must have an even number of elements (key-value pairs).", args[0].pos);
						"";
					} else {
						var pairs = [];
						var i = 0;
						while (i < elements.length) {
							var key = compiler.compileExpression(elements[i]);
							var value = compiler.compileExpression(elements[i + 1]);
							pairs.push("${key} => ${value}");
							i += 2;
						};
						"%{${pairs.join(\", \")}}";
					};				
				case _:
					Context.error("elixir.Syntax.map parameter must be an array literal.", args[0].pos);
					"";				
			};
		};	
	case "list":
		var compiledArgs = args.map(function(arg) ->  @:implicitReturn return compiler.compileExpression(arg));
		"[${compiledArgs.join(\", \")}]";	
	case "pipe":
		if (args.length < 2) {
			Context.error("elixir.Syntax.pipe requires at least two arguments (initial value and operations).", Context.currentPos());
			"";
		} else {
			var initial = compiler.compileExpression(args[0]);
			var operations = [];
			for (i  in  1 ... args.length) {
				operations.push(compiler.compileExpression(args[i]));
			};
			"${initial} |> ${operations.join(\" |> \")}";
		};	
	case "match":
		if (args.length != 2) {
			Context.error("elixir.Syntax.match requires exactly two arguments (value and patterns).", Context.currentPos());
			"";
		} else {
			var value = compiler.compileExpression(args[0]);
			var patterns = switch (args[1].expr) {
				case TConst(TString(s)):
					s;				
				case _:
					Context.error("elixir.Syntax.match patterns must be a constant String.", args[1].pos);
					"";				
			};
			"case ${value} do\n  ${StringTools.replace(patterns, \"\\n\", \"\n  \")}\nend";
		};	
	case _:
		Context.error("Unknown elixir.Syntax method: ${methodName}", Context.currentPos());
		"";	
})
					[Switch:String]
						[Local methodName(23024):String:String]
						[Case:String]
							[Const:String] "atom"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.atom requires exactly one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		":$s";	
	case _:
		var atomName = compiler.compileExpression(args[0]);
		":${atomName}";	
})
												[Block:String]
													[Var `(23128):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23128):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 0
														[Then:String] [Block:String]
															[Var `(23129):haxe.macro.TConstant]
																[EnumParameter:haxe.macro.TConstant]
																	[Local `(23128):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TConst
																	0
															[If:String]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(23129):haxe.macro.TConstant:haxe.macro.TConstant]
																	==
																	[Const:Int] 2
																[Then:String] [Block:String]
																	[Var `(23130):String]
																		[EnumParameter:String]
																			[Local `(23129):haxe.macro.TConstant:haxe.macro.TConstant]
																			TString
																			0
																	[Block:String]
																		[Var s(23131):String] [Local `(23130):String:String]
																		[Block:String]
																			[Binop:String]
																				[Const:String] ":"
																				+
																				[Local s(23131):String:String]
																[Else:String] [Block:String]
																	[Var atomName(23132):Null<String>]
																		[Call:Null<String>]
																			[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																				[Field:reflaxe.elixir.ElixirCompiler]
																					[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																					[FInstance:reflaxe.elixir.ElixirCompiler]
																						reflaxe.elixir.helpers.MethodCallCompiler
																						compiler:reflaxe.elixir.ElixirCompiler
																				[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					reflaxe.elixir.ElixirCompiler
																					compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																			[Array:haxe.macro.TypedExpr]
																				[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																				[Const:Int] 0
																			[Const:Null<Bool>] null
																	[Binop:String]
																		[Const:String] ":"
																		+
																		[Local atomName(23132):Null<String>:Null<String>]
														[Else:String] [Block:String]
															[Var atomName(23133):Null<String>]
																[Call:Null<String>]
																	[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		[Field:reflaxe.elixir.ElixirCompiler]
																			[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																			[FInstance:reflaxe.elixir.ElixirCompiler]
																				reflaxe.elixir.helpers.MethodCallCompiler
																				compiler:reflaxe.elixir.ElixirCompiler
																		[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																			reflaxe.elixir.ElixirCompiler
																			compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[Const:Null<Bool>] null
															[Binop:String]
																[Const:String] ":"
																+
																[Local atomName(23133):Null<String>:Null<String>]
						[Case:String]
							[Const:String] "code"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 0
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.code requires at least one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var codeString(23134):String]
												[Meta:String]
													:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.code first parameter must be a constant String.", args[0].pos);
		"";	
})
													[Block:String]
														[Var `(23135):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 0
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:String]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23135):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:String] [Block:String]
																[Var `(23136):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23135):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23136):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 2
																	[Then:String] [Block:String]
																		[Var `(23137):String]
																			[EnumParameter:String]
																				[Local `(23136):haxe.macro.TConstant:haxe.macro.TConstant]
																				TString
																				0
																		[Block:String]
																			[Var s(23138):String] [Local `(23137):String:String]
																			[Block:String] [Local s(23138):String:String]
																	[Else:String] [Block:String]
																		[Call:Dynamic]
																			[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																				[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					haxe.macro.Context
																					error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																			[Const:String] "elixir.Syntax.code first parameter must be a constant String."
																			[Field:haxe.macro.Position]
																				[Array:haxe.macro.TypedExpr]
																					[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[Const:Int] 0
																				[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																			[Const:Null<Int>] null
																		[Const:String] ""
															[Else:String] [Block:String]
																[Call:Dynamic]
																	[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																		[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			haxe.macro.Context
																			error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																	[Const:String] "elixir.Syntax.code first parameter must be a constant String."
																	[Field:haxe.macro.Position]
																		[Array:haxe.macro.TypedExpr]
																			[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 0
																		[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																	[Const:Null<Int>] null
																[Const:String] ""
											[Var compiledArgs(23139):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23140):Int] [Const:Int] 1
												[Var `(23141):Int]
													[Field:Int]
														[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(23140):Int:Int]
														<
														[Local `(23141):Int:Int]
													[Block:Int]
														[Var i(23142):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(23140):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local compiledArgs(23139):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local i(23142):Int:Int]
																[Const:Null<Bool>] null
											[Var placeholderCount(23143):Array<Int>] [ArrayDecl:Array<Int>] [Const:Int] 0
											[Call:String]
												[Field:(s : String, f : (EReg -> String)) -> String]
													[New:EReg]
														EReg
														[Const:String] "{(\\d+)}"
														[Const:String] "g"
													[FInstance:(s : String, f : (EReg -> String)) -> String]
														EReg
														map:(s : String, f : (EReg -> String)) -> String
												[Local codeString(23134):String:String]
												[Function:(ereg : EReg) -> String]
													[Arg:EReg] [Local ereg(23144):EReg]
													[Block:Dynamic]
														[Var num(23145):Null<Int>]
															[Call:Null<Int>]
																[Field:(x : String) -> Null<Int>]
																	[TypeExpr Std:Class<Std>]
																	[FStatic:(x : String) -> Null<Int>]
																		Std
																		parseInt:(x : String) -> Null<Int>
																[Call:String]
																	[Field:(n : Int) -> String]
																		[Local ereg(23144):EReg:EReg]
																		[FInstance:(n : Int) -> String]
																			EReg
																			matched:(n : Int) -> String
																	[Const:Int] 1
														[If:Void]
															[Binop:Bool]
																[Binop:Bool]
																	[Local num(23145):Null<Int>:Null<Int>]
																	!=
																	[Const:Null<Int>] null
																&&
																[Binop:Bool]
																	[Local num(23145):Null<Int>:Null<Int>]
																	>=
																	[Array:Int]
																		[Local placeholderCount(23143):Array<Int>:Array<Int>]
																		[Const:Int] 0
															[Then:Int] [Block:Int]
																[Binop:Int]
																	[Array:Int]
																		[Local placeholderCount(23143):Array<Int>:Array<Int>]
																		[Const:Int] 0
																	=
																	[Binop:Int]
																		[Local num(23145):Null<Int>:Null<Int>]
																		+
																		[Const:Int] 1
														[Return:Dynamic]
															[Call:String]
																[Field:(n : Int) -> String]
																	[Local ereg(23144):EReg:EReg]
																	[FInstance:(n : Int) -> String]
																		EReg
																		matched:(n : Int) -> String
																[Const:Int] 0
											[If:Void]
												[Binop:Bool]
													[Array:Int]
														[Local placeholderCount(23143):Array<Int>:Array<Int>]
														[Const:Int] 0
													>
													[Field:Int]
														[Local compiledArgs(23139):Array<Null<String>>:Array<Null<String>>]
														[FInstance:Int]
															Array<Null<String>>
															length:Int
												[Then:Dynamic] [Block:Dynamic]
													[Call:Dynamic]
														[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
															[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
															[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																haxe.macro.Context
																error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
														[Binop:String]
															[Binop:String]
																[Binop:String]
																	[Binop:String]
																		[Const:String] "elixir.Syntax.code() requires "
																		+
																		[Array:Int]
																			[Local placeholderCount(23143):Array<Int>:Array<Int>]
																			[Const:Int] 0
																	+
																	[Const:String] " arguments but "
																+
																[Field:Int]
																	[Local compiledArgs(23139):Array<Null<String>>:Array<Null<String>>]
																	[FInstance:Int]
																		Array<Null<String>>
																		length:Int
															+
															[Const:String] " provided"
														[Call:haxe.macro.Position]
															[Field:() -> haxe.macro.Position]
																[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																[FStatic:() -> haxe.macro.Position]
																	haxe.macro.Context
																	currentPos:() -> haxe.macro.Position
														[Const:Null<Int>] null
											[Var result(23146):String]
												[Call:String]
													[Field:(s : String, f : (EReg -> String)) -> String]
														[New:EReg]
															EReg
															[Const:String] "{(\\d+)}"
															[Const:String] "g"
														[FInstance:(s : String, f : (EReg -> String)) -> String]
															EReg
															map:(s : String, f : (EReg -> String)) -> String
													[Local codeString(23134):String:String]
													[Function:(ereg : EReg) -> String]
														[Arg:EReg] [Local ereg(23147):EReg]
														[Block:Dynamic]
															[Var num(23148):Null<Int>]
																[Call:Null<Int>]
																	[Field:(x : String) -> Null<Int>]
																		[TypeExpr Std:Class<Std>]
																		[FStatic:(x : String) -> Null<Int>]
																			Std
																			parseInt:(x : String) -> Null<Int>
																	[Call:String]
																		[Field:(n : Int) -> String]
																			[Local ereg(23147):EReg:EReg]
																			[FInstance:(n : Int) -> String]
																				EReg
																				matched:(n : Int) -> String
																		[Const:Int] 1
															[Return:Dynamic]
																[If:String]
																	[Parenthesis:Bool]
																		[Binop:Bool]
																			[Binop:Bool]
																				[Local num(23148):Null<Int>:Null<Int>]
																				!=
																				[Const:Null<Int>] null
																			&&
																			[Binop:Bool]
																				[Local num(23148):Null<Int>:Null<Int>]
																				<
																				[Field:Int]
																					[Local compiledArgs(23139):Array<Null<String>>:Array<Null<String>>]
																					[FInstance:Int]
																						Array<Null<String>>
																						length:Int
																	[Then:Null<String>] [Block:Null<String>]
																		[Array:Null<String>]
																			[Local compiledArgs(23139):Array<Null<String>>:Array<Null<String>>]
																			[Local num(23148):Null<Int>:Null<Int>]
																	[Else:String] [Block:String]
																		[Call:String]
																			[Field:(n : Int) -> String]
																				[Local ereg(23147):EReg:EReg]
																				[FInstance:(n : Int) -> String]
																					EReg
																					matched:(n : Int) -> String
																			[Const:Int] 0
											[Return:String] [Local result(23146):String:String]
						[Case:String]
							[Const:String] "keyword"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.keyword requires exactly one Array argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TArrayDecl(elements):
		if (elements.length % 2 != 0) {
			Context.error("elixir.Syntax.keyword array must have an even number of elements (key-value pairs).", args[0].pos);
			"";
		} else {
			var pairs = [];
			var i = 0;
			while (i < elements.length) {
				var key = compiler.compileExpression(elements[i]);
				var value = compiler.compileExpression(elements[i + 1]);
				pairs.push("${key}: ${value}");
				i += 2;
			};
			"[${pairs.join(\", \")}]";
		};	
	case _:
		Context.error("elixir.Syntax.keyword parameter must be an array literal.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23149):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23149):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:String] [Block:String]
															[Var `(23150):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(23149):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[Block:String]
																[Var elements(23151):Array<haxe.macro.TypedExpr>] [Local `(23150):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Block:String]
																	[If:String]
																		[Binop:Bool]
																			[Binop:Int]
																				[Field:Int]
																					[Local elements(23151):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																				%
																				[Const:Int] 2
																			!=
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Call:Dynamic]
																				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																						haxe.macro.Context
																						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																				[Const:String] "elixir.Syntax.keyword array must have an even number of elements (key-value pairs)."
																				[Field:haxe.macro.Position]
																					[Array:haxe.macro.TypedExpr]
																						[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Const:Int] 0
																					[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																				[Const:Null<Int>] null
																			[Const:String] ""
																		[Else:String] [Block:String]
																			[Var pairs(23152):Array<String>] [ArrayDecl:Array<String>]
																			[Var i(23153):Int] [Const:Int] 0
																			[While:Void]
																				[Binop:Bool]
																					[Local i(23153):Int:Int]
																					<
																					[Field:Int]
																						[Local elements(23151):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[FInstance:Int]
																							Array<haxe.macro.TypedExpr>
																							length:Int
																				[Block:Int]
																					[Var key(23154):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23151):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Local i(23153):Int:Int]
																							[Const:Null<Bool>] null
																					[Var value(23155):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23151):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Binop:Int]
																									[Local i(23153):Int:Int]
																									+
																									[Const:Int] 1
																							[Const:Null<Bool>] null
																					[Call:Int]
																						[Field:(x : String) -> Int]
																							[Local pairs(23152):Array<String>:Array<String>]
																							[FInstance:(x : String) -> Int]
																								Array<String>
																								push:(x : Array.T) -> Int
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Local key(23154):Null<String>:Null<String>]
																								+
																								[Const:String] ": "
																							+
																							[Local value(23155):Null<String>:Null<String>]
																					[Binop:Int]
																						[Local i(23153):Int:Int]
																						+=
																						[Const:Int] 2
																			[Binop:String]
																				[Binop:String]
																					[Const:String] "["
																					+
																					[Call:String]
																						[Field:(sep : String) -> String]
																							[Local pairs(23152):Array<String>:Array<String>]
																							[FInstance:(sep : String) -> String]
																								Array<String>
																								join:(sep : String) -> String
																						[Const:String] ", "
																				+
																				[Const:String] "]"
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.keyword parameter must be an array literal."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "list"
							[Block:String]
								[Block:String]
									[Var compiledArgs(23156):Array<Null<String>>]
										[Block:Array<Null<String>>]
											[Var `(23157):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23158):Int] [Const:Int] 0
												[Var `(23159):Array<haxe.macro.TypedExpr>] [Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[While:Void]
													[Binop:Bool]
														[Local `(23158):Int:Int]
														<
														[Field:Int]
															[Local `(23159):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var v(23160):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local `(23159):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(23158):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(23158):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local `(23157):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																	[Arg:haxe.macro.TypedExpr] [Local arg(23161):haxe.macro.TypedExpr]
																	[Block:Dynamic]
																		[Return:Dynamic]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Local `this(23065):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.MethodCallCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local arg(23161):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
																[Local v(23160):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local `(23157):Array<Null<String>>:Array<Null<String>>]
									[Binop:String]
										[Binop:String]
											[Const:String] "["
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(23156):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] "]"
						[Case:String]
							[Const:String] "map"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.map requires exactly one Array argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TArrayDecl(elements):
		if (elements.length % 2 != 0) {
			Context.error("elixir.Syntax.map array must have an even number of elements (key-value pairs).", args[0].pos);
			"";
		} else {
			var pairs = [];
			var i = 0;
			while (i < elements.length) {
				var key = compiler.compileExpression(elements[i]);
				var value = compiler.compileExpression(elements[i + 1]);
				pairs.push("${key} => ${value}");
				i += 2;
			};
			"%{${pairs.join(\", \")}}";
		};	
	case _:
		Context.error("elixir.Syntax.map parameter must be an array literal.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23162):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23162):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 8
														[Then:String] [Block:String]
															[Var `(23163):Array<haxe.macro.TypedExpr>]
																[EnumParameter:Array<haxe.macro.TypedExpr>]
																	[Local `(23162):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TArrayDecl
																	0
															[Block:String]
																[Var elements(23164):Array<haxe.macro.TypedExpr>] [Local `(23163):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Block:String]
																	[If:String]
																		[Binop:Bool]
																			[Binop:Int]
																				[Field:Int]
																					[Local elements(23164):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[FInstance:Int]
																						Array<haxe.macro.TypedExpr>
																						length:Int
																				%
																				[Const:Int] 2
																			!=
																			[Const:Int] 0
																		[Then:String] [Block:String]
																			[Call:Dynamic]
																				[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																					[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																						haxe.macro.Context
																						error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																				[Const:String] "elixir.Syntax.map array must have an even number of elements (key-value pairs)."
																				[Field:haxe.macro.Position]
																					[Array:haxe.macro.TypedExpr]
																						[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[Const:Int] 0
																					[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																				[Const:Null<Int>] null
																			[Const:String] ""
																		[Else:String] [Block:String]
																			[Var pairs(23165):Array<String>] [ArrayDecl:Array<String>]
																			[Var i(23166):Int] [Const:Int] 0
																			[While:Void]
																				[Binop:Bool]
																					[Local i(23166):Int:Int]
																					<
																					[Field:Int]
																						[Local elements(23164):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																						[FInstance:Int]
																							Array<haxe.macro.TypedExpr>
																							length:Int
																				[Block:Int]
																					[Var key(23167):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23164):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Local i(23166):Int:Int]
																							[Const:Null<Bool>] null
																					[Var value(23168):Null<String>]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Array:haxe.macro.TypedExpr]
																								[Local elements(23164):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																								[Binop:Int]
																									[Local i(23166):Int:Int]
																									+
																									[Const:Int] 1
																							[Const:Null<Bool>] null
																					[Call:Int]
																						[Field:(x : String) -> Int]
																							[Local pairs(23165):Array<String>:Array<String>]
																							[FInstance:(x : String) -> Int]
																								Array<String>
																								push:(x : Array.T) -> Int
																						[Binop:String]
																							[Binop:String]
																								[Binop:String]
																									[Const:String] ""
																									+
																									[Local key(23167):Null<String>:Null<String>]
																								+
																								[Const:String] " => "
																							+
																							[Local value(23168):Null<String>:Null<String>]
																					[Binop:Int]
																						[Local i(23166):Int:Int]
																						+=
																						[Const:Int] 2
																			[Binop:String]
																				[Binop:String]
																					[Const:String] "%{"
																					+
																					[Call:String]
																						[Field:(sep : String) -> String]
																							[Local pairs(23165):Array<String>:Array<String>]
																							[FInstance:(sep : String) -> String]
																								Array<String>
																								join:(sep : String) -> String
																						[Const:String] ", "
																				+
																				[Const:String] "}"
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.map parameter must be an array literal."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "match"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.match requires exactly two arguments (value and patterns)."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var value(23169):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var patterns(23170):String]
												[Meta:String]
													:ast(switch (args[1].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.match patterns must be a constant String.", args[1].pos);
		"";	
})
													[Block:String]
														[Var `(23171):haxe.macro.TypedExprDef]
															[Field:haxe.macro.TypedExprDef]
																[Array:haxe.macro.TypedExpr]
																	[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Const:Int] 1
																[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
														[If:String]
															[Binop:Bool]
																[EnumIndex:Int] [Local `(23171):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																==
																[Const:Int] 0
															[Then:String] [Block:String]
																[Var `(23172):haxe.macro.TConstant]
																	[EnumParameter:haxe.macro.TConstant]
																		[Local `(23171):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																		TConst
																		0
																[If:String]
																	[Binop:Bool]
																		[EnumIndex:Int] [Local `(23172):haxe.macro.TConstant:haxe.macro.TConstant]
																		==
																		[Const:Int] 2
																	[Then:String] [Block:String]
																		[Var `(23173):String]
																			[EnumParameter:String]
																				[Local `(23172):haxe.macro.TConstant:haxe.macro.TConstant]
																				TString
																				0
																		[Block:String]
																			[Var s(23174):String] [Local `(23173):String:String]
																			[Block:String] [Local s(23174):String:String]
																	[Else:String] [Block:String]
																		[Call:Dynamic]
																			[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																				[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																					haxe.macro.Context
																					error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																			[Const:String] "elixir.Syntax.match patterns must be a constant String."
																			[Field:haxe.macro.Position]
																				[Array:haxe.macro.TypedExpr]
																					[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																					[Const:Int] 1
																				[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																			[Const:Null<Int>] null
																		[Const:String] ""
															[Else:String] [Block:String]
																[Call:Dynamic]
																	[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																		[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			haxe.macro.Context
																			error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																	[Const:String] "elixir.Syntax.match patterns must be a constant String."
																	[Field:haxe.macro.Position]
																		[Array:haxe.macro.TypedExpr]
																			[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Const:Int] 1
																		[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																	[Const:Null<Int>] null
																[Const:String] ""
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Binop:String]
															[Const:String] "case "
															+
															[Local value(23169):Null<String>:Null<String>]
														+
														[Const:String] " do\n  "
													+
													[Call:String]
														[Field:(s : String, sub : String, by : String) -> String]
															[TypeExpr StringTools:Class<StringTools>]
															[FStatic:(s : String, sub : String, by : String) -> String]
																StringTools
																replace:(s : String, sub : String, by : String) -> String
														[Local patterns(23170):String:String]
														[Const:String] "\n"
														[Const:String] "\n  "
												+
												[Const:String] "\nend"
						[Case:String]
							[Const:String] "pipe"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											<
											[Const:Int] 2
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.pipe requires at least two arguments (initial value and operations)."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Var initial(23175):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var operations(23176):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23177):Int] [Const:Int] 1
												[Var `(23178):Int]
													[Field:Int]
														[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[FInstance:Int]
															Array<haxe.macro.TypedExpr>
															length:Int
												[While:Void]
													[Binop:Bool]
														[Local `(23177):Int:Int]
														<
														[Local `(23178):Int:Int]
													[Block:Int]
														[Var i(23179):Int]
															[Unop:Int]
																++
																Postfix
																[Local `(23177):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local operations(23176):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																	[Field:reflaxe.elixir.ElixirCompiler]
																		[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
																		[FInstance:reflaxe.elixir.ElixirCompiler]
																			reflaxe.elixir.helpers.MethodCallCompiler
																			compiler:reflaxe.elixir.ElixirCompiler
																	[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																		reflaxe.elixir.ElixirCompiler
																		compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																[Array:haxe.macro.TypedExpr]
																	[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																	[Local i(23179):Int:Int]
																[Const:Null<Bool>] null
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] ""
														+
														[Local initial(23175):Null<String>:Null<String>]
													+
													[Const:String] " |> "
												+
												[Call:String]
													[Field:(sep : String) -> String]
														[Local operations(23176):Array<Null<String>>:Array<Null<String>>]
														[FInstance:(sep : String) -> String]
															Array<Null<String>>
															join:(sep : String) -> String
													[Const:String] " |> "
						[Case:String]
							[Const:String] "plainCode"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											!=
											[Const:Int] 1
										[Then:String] [Block:String]
											[Call:Dynamic]
												[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
													[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
													[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
														haxe.macro.Context
														error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
												[Const:String] "elixir.Syntax.plainCode requires exactly one String argument."
												[Call:haxe.macro.Position]
													[Field:() -> haxe.macro.Position]
														[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
														[FStatic:() -> haxe.macro.Position]
															haxe.macro.Context
															currentPos:() -> haxe.macro.Position
												[Const:Null<Int>] null
											[Const:String] ""
										[Else:String] [Block:String]
											[Meta:String]
												:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		Context.error("elixir.Syntax.plainCode parameter must be a constant String.", args[0].pos);
		"";	
})
												[Block:String]
													[Var `(23180):haxe.macro.TypedExprDef]
														[Field:haxe.macro.TypedExprDef]
															[Array:haxe.macro.TypedExpr]
																[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Const:Int] 0
															[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
													[If:String]
														[Binop:Bool]
															[EnumIndex:Int] [Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
															==
															[Const:Int] 0
														[Then:String] [Block:String]
															[Var `(23181):haxe.macro.TConstant]
																[EnumParameter:haxe.macro.TConstant]
																	[Local `(23180):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
																	TConst
																	0
															[If:String]
																[Binop:Bool]
																	[EnumIndex:Int] [Local `(23181):haxe.macro.TConstant:haxe.macro.TConstant]
																	==
																	[Const:Int] 2
																[Then:String] [Block:String]
																	[Var `(23182):String]
																		[EnumParameter:String]
																			[Local `(23181):haxe.macro.TConstant:haxe.macro.TConstant]
																			TString
																			0
																	[Block:String]
																		[Var s(23183):String] [Local `(23182):String:String]
																		[Block:String] [Local s(23183):String:String]
																[Else:String] [Block:String]
																	[Call:Dynamic]
																		[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																			[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																			[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																				haxe.macro.Context
																				error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																		[Const:String] "elixir.Syntax.plainCode parameter must be a constant String."
																		[Field:haxe.macro.Position]
																			[Array:haxe.macro.TypedExpr]
																				[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																				[Const:Int] 0
																			[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																		[Const:Null<Int>] null
																	[Const:String] ""
														[Else:String] [Block:String]
															[Call:Dynamic]
																[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																	[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
																	[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
																		haxe.macro.Context
																		error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
																[Const:String] "elixir.Syntax.plainCode parameter must be a constant String."
																[Field:haxe.macro.Position]
																	[Array:haxe.macro.TypedExpr]
																		[Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[Const:Int] 0
																	[FAnon:haxe.macro.Position] pos:haxe.macro.Position
																[Const:Null<Int>] null
															[Const:String] ""
						[Case:String]
							[Const:String] "tuple"
							[Block:String]
								[Block:String]
									[Var compiledArgs(23184):Array<Null<String>>]
										[Block:Array<Null<String>>]
											[Var `(23185):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
											[Block:Void]
												[Var `(23186):Int] [Const:Int] 0
												[Var `(23187):Array<haxe.macro.TypedExpr>] [Local args(23025):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[While:Void]
													[Binop:Bool]
														[Local `(23186):Int:Int]
														<
														[Field:Int]
															[Local `(23187):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[FInstance:Int]
																Array<haxe.macro.TypedExpr>
																length:Int
													[Block:Void]
														[Var v(23188):haxe.macro.TypedExpr]
															[Array:haxe.macro.TypedExpr]
																[Local `(23187):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																[Local `(23186):Int:Int]
														[Unop:Int]
															++
															Prefix
															[Local `(23186):Int:Int]
														[Call:Int]
															[Field:(x : Null<String>) -> Int]
																[Local `(23185):Array<Null<String>>:Array<Null<String>>]
																[FInstance:(x : Null<String>) -> Int]
																	Array<Null<String>>
																	push:(x : Array.T) -> Int
															[Call:Null<String>]
																[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																	[Arg:haxe.macro.TypedExpr] [Local arg(23189):haxe.macro.TypedExpr]
																	[Block:Dynamic]
																		[Return:Dynamic]
																			[Call:Null<String>]
																				[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																					[Field:reflaxe.elixir.ElixirCompiler]
																						[Local `this(23065):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																						[FInstance:reflaxe.elixir.ElixirCompiler]
																							reflaxe.elixir.helpers.MethodCallCompiler
																							compiler:reflaxe.elixir.ElixirCompiler
																					[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																						reflaxe.elixir.ElixirCompiler
																						compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																				[Local arg(23189):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																				[Const:Null<Bool>] null
																[Local v(23188):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
											[Local `(23185):Array<Null<String>>:Array<Null<String>>]
									[Binop:String]
										[Binop:String]
											[Const:String] "{"
											+
											[Call:String]
												[Field:(sep : String) -> String]
													[Local compiledArgs(23184):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										+
										[Const:String] "}"
						[Default:String]
							[Block:String]
								[Call:Dynamic]
									[Field:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
										[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
										[FStatic:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic]
											haxe.macro.Context
											error:(msg : String, pos : haxe.macro.Position, ?depth : Null<Int>) -> Dynamic
									[Binop:String]
										[Const:String] "Unknown elixir.Syntax method: "
										+
										[Local methodName(23024):String:String]
									[Call:haxe.macro.Position]
										[Field:() -> haxe.macro.Position]
											[TypeExpr haxe.macro.Context:Class<haxe.macro.Context>]
											[FStatic:() -> haxe.macro.Position]
												haxe.macro.Context
												currentPos:() -> haxe.macro.Position
									[Const:Null<Int>] null
								[Const:String] ""

	public function isTypeSafeChildSpecCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(23190):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(23191):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TTypeExpr(moduleType):
		switch (moduleType) {
			case TEnumDecl(enumRef):
				var enumType = enumRef.get();
				return enumType.name == "TypeSafeChildSpec" && enumType.pack.join(".") == "elixir.otp";			
			case _:
				return false;			
		};	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(23201):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(23190):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23201):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 5
						[Then:Void] [Block:Void]
							[Var `(23202):haxe.macro.ModuleType]
								[EnumParameter:haxe.macro.ModuleType]
									[Local `(23201):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TTypeExpr
									0
							[Block:Void]
								[Var moduleType(23203):haxe.macro.ModuleType] [Local `(23202):haxe.macro.ModuleType:haxe.macro.ModuleType]
								[Block:Void]
									[Meta:Void]
										:ast(switch (moduleType) {
	case TEnumDecl(enumRef):
		var enumType = enumRef.get();
		return enumType.name == "TypeSafeChildSpec" && enumType.pack.join(".") == "elixir.otp";	
	case _:
		return false;	
})
										[If:Void]
											[Binop:Bool]
												[EnumIndex:Int] [Local moduleType(23203):haxe.macro.ModuleType:haxe.macro.ModuleType]
												==
												[Const:Int] 1
											[Then:Dynamic] [Block:Dynamic]
												[Var `(23204):haxe.macro.Ref<haxe.macro.EnumType>]
													[EnumParameter:haxe.macro.Ref<haxe.macro.EnumType>]
														[Local moduleType(23203):haxe.macro.ModuleType:haxe.macro.ModuleType]
														TEnumDecl
														0
												[Block:Dynamic]
													[Var enumRef(23205):haxe.macro.Ref<haxe.macro.EnumType>] [Local `(23204):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
													[Block:Dynamic]
														[Var enumType(23206):haxe.macro.EnumType]
															[Call:haxe.macro.EnumType]
																[Field:() -> haxe.macro.EnumType]
																	[Local enumRef(23205):haxe.macro.Ref<haxe.macro.EnumType>:haxe.macro.Ref<haxe.macro.EnumType>]
																	[FAnon:() -> haxe.macro.EnumType] get:() -> haxe.macro.EnumType
														[Return:Dynamic]
															[Binop:Bool]
																[Binop:Bool]
																	[Field:String]
																		[Local enumType(23206):haxe.macro.EnumType:haxe.macro.EnumType]
																		[FAnon:String] name:String
																	==
																	[Const:String] "TypeSafeChildSpec"
																&&
																[Binop:Bool]
																	[Call:String]
																		[Field:(sep : String) -> String]
																			[Field:Array<String>]
																				[Local enumType(23206):haxe.macro.EnumType:haxe.macro.EnumType]
																				[FAnon:Array<String>] pack:Array<String>
																			[FInstance:(sep : String) -> String]
																				Array<String>
																				join:(sep : String) -> String
																		[Const:String] "."
																	==
																	[Const:String] "elixir.otp"
											[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
						[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	public function compileTypeSafeChildSpecCall[Function:(fieldName : String, args : Array<haxe.macro.TypedExpr>) -> String]
		[Arg:String] [Local fieldName(23207):String]
		[Arg:Array<haxe.macro.TypedExpr>] [Local args(23208):Array<haxe.macro.TypedExpr>]
		[Block:Dynamic]
			[Var `this(23213):reflaxe.elixir.helpers.MethodCallCompiler] [Const:reflaxe.elixir.helpers.MethodCallCompiler] this
			[Var appName(23209):String]
				[Call:String]
					[Field:(classType : haxe.macro.ClassType) -> String]
						[TypeExpr reflaxe.elixir.helpers.AnnotationSystem:Class<reflaxe.elixir.helpers.AnnotationSystem>]
						[FStatic:(classType : haxe.macro.ClassType) -> String]
							reflaxe.elixir.helpers.AnnotationSystem
							getEffectiveAppName:(classType : haxe.macro.ClassType) -> String
					[Field:Null<haxe.macro.ClassType>]
						[Field:reflaxe.elixir.ElixirCompiler]
							[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
							[FInstance:reflaxe.elixir.ElixirCompiler]
								reflaxe.elixir.helpers.MethodCallCompiler
								compiler:reflaxe.elixir.ElixirCompiler
						[FInstance:Null<haxe.macro.ClassType>]
							reflaxe.elixir.ElixirCompiler
							currentClassType:Null<haxe.macro.ClassType>
			[Return:Dynamic]
				[Meta:String]
					:ast(switch (fieldName) {
	case "PubSub":
		if (args.length == 1) {
			var nameArg = compiler.compileExpression(args[0]);
			var cleanName = if (nameArg.indexOf("<>") >= 0) {
				nameArg;
			} else {
				StringTools.replace(nameArg, "\"", "");
			};
			"{Phoenix.PubSub, name: ${cleanName}}";
		} else {
			"{Phoenix.PubSub, name: ${appName}.PubSub}";
		};	
	case "Repo":
		"${appName}.Repo";	
	case "Endpoint":
		"${appName}Web.Endpoint";	
	case "Telemetry":
		"${appName}Web.Telemetry";	
	case _:
		if (args.length == 0) {
			":${reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName)}";
		} else {
			var argList = args.map(function(arg) return compiler.compileExpression(arg)).join(", ");
			"{:${reflaxe.elixir.helpers.NamingHelper.toSnakeCase(fieldName)}, ${argList}}";
		};	
})
					[Switch:String]
						[Local fieldName(23207):String:String]
						[Case:String]
							[Const:String] "Endpoint"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23209):String:String]
										+
										[Const:String] "Web.Endpoint"
						[Case:String]
							[Const:String] "PubSub"
							[Block:String]
								[Block:String]
									[If:String]
										[Binop:Bool]
											[Field:Int]
												[Local args(23208):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
												[FInstance:Int]
													Array<haxe.macro.TypedExpr>
													length:Int
											==
											[Const:Int] 1
										[Then:String] [Block:String]
											[Var nameArg(23223):Null<String>]
												[Call:Null<String>]
													[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
														[Field:reflaxe.elixir.ElixirCompiler]
															[Const:reflaxe.elixir.helpers.MethodCallCompiler] this
															[FInstance:reflaxe.elixir.ElixirCompiler]
																reflaxe.elixir.helpers.MethodCallCompiler
																compiler:reflaxe.elixir.ElixirCompiler
														[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
															reflaxe.elixir.ElixirCompiler
															compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
													[Array:haxe.macro.TypedExpr]
														[Local args(23208):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
														[Const:Int] 0
													[Const:Null<Bool>] null
											[Var cleanName(23224):Null<String>]
												[If:Null<String>]
													[Binop:Bool]
														[Call:Int]
															[Field:(str : String, ?startIndex : Null<Int>) -> Int]
																[Local nameArg(23223):Null<String>:Null<String>]
																[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
																	String
																	indexOf:(str : String, ?startIndex : Null<Int>) -> Int
															[Const:String] "<>"
															[Const:Null<Int>] null
														>=
														[Const:Int] 0
													[Then:Null<String>] [Block:Null<String>] [Local nameArg(23223):Null<String>:Null<String>]
													[Else:String] [Block:String]
														[Call:String]
															[Field:(s : String, sub : String, by : String) -> String]
																[TypeExpr StringTools:Class<StringTools>]
																[FStatic:(s : String, sub : String, by : String) -> String]
																	StringTools
																	replace:(s : String, sub : String, by : String) -> String
															[Local nameArg(23223):Null<String>:Null<String>]
															[Const:String] "\""
															[Const:String] ""
											[Binop:String]
												[Binop:String]
													[Const:String] "{Phoenix.PubSub, name: "
													+
													[Local cleanName(23224):Null<String>:Null<String>]
												+
												[Const:String] "}"
										[Else:String] [Block:String]
											[Binop:String]
												[Binop:String]
													[Const:String] "{Phoenix.PubSub, name: "
													+
													[Local appName(23209):String:String]
												+
												[Const:String] ".PubSub}"
						[Case:String]
							[Const:String] "Repo"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23209):String:String]
										+
										[Const:String] ".Repo"
						[Case:String]
							[Const:String] "Telemetry"
							[Block:String]
								[Block:String]
									[Binop:String]
										[Binop:String]
											[Const:String] ""
											+
											[Local appName(23209):String:String]
										+
										[Const:String] "Web.Telemetry"
						[Default:String]
							[Block:String]
								[If:String]
									[Binop:Bool]
										[Field:Int]
											[Local args(23208):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
											[FInstance:Int]
												Array<haxe.macro.TypedExpr>
												length:Int
										==
										[Const:Int] 0
									[Then:String] [Block:String]
										[Binop:String]
											[Const:String] ":"
											+
											[Call:String]
												[Field:(camelCase : String) -> String]
													[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
													[FStatic:(camelCase : String) -> String]
														reflaxe.elixir.helpers.NamingHelper
														toSnakeCase:(camelCase : String) -> String
												[Local fieldName(23207):String:String]
									[Else:String] [Block:String]
										[Var argList(23225):String]
											[Call:String]
												[Field:(sep : String) -> String]
													[Block:Array<Null<String>>]
														[Var `(23226):Array<Null<String>>] [ArrayDecl:Array<Null<String>>]
														[Block:Void]
															[Var `(23227):Int] [Const:Int] 0
															[Var `(23228):Array<haxe.macro.TypedExpr>] [Local args(23208):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
															[While:Void]
																[Binop:Bool]
																	[Local `(23227):Int:Int]
																	<
																	[Field:Int]
																		[Local `(23228):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																		[FInstance:Int]
																			Array<haxe.macro.TypedExpr>
																			length:Int
																[Block:Void]
																	[Var v(23229):haxe.macro.TypedExpr]
																		[Array:haxe.macro.TypedExpr]
																			[Local `(23228):Array<haxe.macro.TypedExpr>:Array<haxe.macro.TypedExpr>]
																			[Local `(23227):Int:Int]
																	[Unop:Int]
																		++
																		Prefix
																		[Local `(23227):Int:Int]
																	[Call:Int]
																		[Field:(x : Null<String>) -> Int]
																			[Local `(23226):Array<Null<String>>:Array<Null<String>>]
																			[FInstance:(x : Null<String>) -> Int]
																				Array<Null<String>>
																				push:(x : Array.T) -> Int
																		[Call:Null<String>]
																			[Function:(arg : haxe.macro.TypedExpr) -> Null<String>]
																				[Arg:haxe.macro.TypedExpr] [Local arg(23230):haxe.macro.TypedExpr]
																				[Block:Dynamic]
																					[Return:Dynamic]
																						[Call:Null<String>]
																							[Field:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																								[Field:reflaxe.elixir.ElixirCompiler]
																									[Local `this(23213):reflaxe.elixir.helpers.MethodCallCompiler:reflaxe.elixir.helpers.MethodCallCompiler]
																									[FInstance:reflaxe.elixir.ElixirCompiler]
																										reflaxe.elixir.helpers.MethodCallCompiler
																										compiler:reflaxe.elixir.ElixirCompiler
																								[FInstance:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>]
																									reflaxe.elixir.ElixirCompiler
																									compileExpression:(expr : haxe.macro.TypedExpr, ?topLevel : Bool) -> Null<String>
																							[Local arg(23230):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
																							[Const:Null<Bool>] null
																			[Local v(23229):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
														[Local `(23226):Array<Null<String>>:Array<Null<String>>]
													[FInstance:(sep : String) -> String]
														Array<Null<String>>
														join:(sep : String) -> String
												[Const:String] ", "
										[Binop:String]
											[Binop:String]
												[Binop:String]
													[Binop:String]
														[Const:String] "{:"
														+
														[Call:String]
															[Field:(camelCase : String) -> String]
																[TypeExpr reflaxe.elixir.helpers.NamingHelper:Class<reflaxe.elixir.helpers.NamingHelper>]
																[FStatic:(camelCase : String) -> String]
																	reflaxe.elixir.helpers.NamingHelper
																	toSnakeCase:(camelCase : String) -> String
															[Local fieldName(23207):String:String]
													+
													[Const:String] ", "
												+
												[Local argList(23225):String:String]
											+
											[Const:String] "}"

	public function isElixirSyntaxCall[Function:(obj : haxe.macro.TypedExpr, fieldName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(22992):haxe.macro.TypedExpr]
		[Arg:String] [Local fieldName(22993):String]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TTypeExpr(moduleType):
		switch (moduleType) {
			case TClassDecl(c):
				var classRef = c.get();
				var fullPath = classRef.pack.join(".") + (classRef.pack.length > 0 ? "." : "") + classRef.name;
				return fullPath == "elixir.Syntax";			
			case TTypeDecl(t):
				var typeRef = t.get();
				var fullPath = typeRef.pack.join(".") + (typeRef.pack.length > 0 ? "." : "") + typeRef.name;
				return fullPath == "elixir.Syntax";			
			case _:
				return false;			
		};	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(23013):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(22992):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[If:Void]
						[Binop:Bool]
							[EnumIndex:Int] [Local `(23013):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
							==
							[Const:Int] 5
						[Then:Void] [Block:Void]
							[Var `(23014):haxe.macro.ModuleType]
								[EnumParameter:haxe.macro.ModuleType]
									[Local `(23013):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
									TTypeExpr
									0
							[Block:Void]
								[Var moduleType(23015):haxe.macro.ModuleType] [Local `(23014):haxe.macro.ModuleType:haxe.macro.ModuleType]
								[Block:Void]
									[Meta:Void]
										:ast(switch (moduleType) {
	case TClassDecl(c):
		var classRef = c.get();
		var fullPath = classRef.pack.join(".") + (classRef.pack.length > 0 ? "." : "") + classRef.name;
		return fullPath == "elixir.Syntax";	
	case TTypeDecl(t):
		var typeRef = t.get();
		var fullPath = typeRef.pack.join(".") + (typeRef.pack.length > 0 ? "." : "") + typeRef.name;
		return fullPath == "elixir.Syntax";	
	case _:
		return false;	
})
										[Switch:Void]
											[EnumIndex:Int] [Local moduleType(23015):haxe.macro.ModuleType:haxe.macro.ModuleType]
											[Case:Dynamic]
												[Const:Int] 0
												[Block:Dynamic]
													[Var `(23016):haxe.macro.Ref<haxe.macro.ClassType>]
														[EnumParameter:haxe.macro.Ref<haxe.macro.ClassType>]
															[Local moduleType(23015):haxe.macro.ModuleType:haxe.macro.ModuleType]
															TClassDecl
															0
													[Block:Dynamic]
														[Var c(23017):haxe.macro.Ref<haxe.macro.ClassType>] [Local `(23016):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
														[Block:Dynamic]
															[Var classRef(23018):haxe.macro.ClassType]
																[Call:haxe.macro.ClassType]
																	[Field:() -> haxe.macro.ClassType]
																		[Local c(23017):haxe.macro.Ref<haxe.macro.ClassType>:haxe.macro.Ref<haxe.macro.ClassType>]
																		[FAnon:() -> haxe.macro.ClassType] get:() -> haxe.macro.ClassType
															[Var fullPath(23019):String]
																[Binop:String]
																	[Binop:String]
																		[Call:String]
																			[Field:(sep : String) -> String]
																				[Field:Array<String>]
																					[Local classRef(23018):haxe.macro.ClassType:haxe.macro.ClassType]
																					[FAnon:Array<String>] pack:Array<String>
																				[FInstance:(sep : String) -> String]
																					Array<String>
																					join:(sep : String) -> String
																			[Const:String] "."
																		+
																		[Parenthesis:String]
																			[If:String]
																				[Binop:Bool]
																					[Field:Int]
																						[Field:Array<String>]
																							[Local classRef(23018):haxe.macro.ClassType:haxe.macro.ClassType]
																							[FAnon:Array<String>] pack:Array<String>
																						[FInstance:Int]
																							Array<String>
																							length:Int
																					>
																					[Const:Int] 0
																				[Then:String] [Block:String] [Const:String] "."
																				[Else:String] [Block:String] [Const:String] ""
																	+
																	[Field:String]
																		[Local classRef(23018):haxe.macro.ClassType:haxe.macro.ClassType]
																		[FAnon:String] name:String
															[Return:Dynamic]
																[Binop:Bool]
																	[Local fullPath(23019):String:String]
																	==
																	[Const:String] "elixir.Syntax"
											[Case:Dynamic]
												[Const:Int] 2
												[Block:Dynamic]
													[Var `(23020):haxe.macro.Ref<haxe.macro.DefType>]
														[EnumParameter:haxe.macro.Ref<haxe.macro.DefType>]
															[Local moduleType(23015):haxe.macro.ModuleType:haxe.macro.ModuleType]
															TTypeDecl
															0
													[Block:Dynamic]
														[Var t(23021):haxe.macro.Ref<haxe.macro.DefType>] [Local `(23020):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
														[Block:Dynamic]
															[Var typeRef(23022):haxe.macro.DefType]
																[Call:haxe.macro.DefType]
																	[Field:() -> haxe.macro.DefType]
																		[Local t(23021):haxe.macro.Ref<haxe.macro.DefType>:haxe.macro.Ref<haxe.macro.DefType>]
																		[FAnon:() -> haxe.macro.DefType] get:() -> haxe.macro.DefType
															[Var fullPath(23023):String]
																[Binop:String]
																	[Binop:String]
																		[Call:String]
																			[Field:(sep : String) -> String]
																				[Field:Array<String>]
																					[Local typeRef(23022):haxe.macro.DefType:haxe.macro.DefType]
																					[FAnon:Array<String>] pack:Array<String>
																				[FInstance:(sep : String) -> String]
																					Array<String>
																					join:(sep : String) -> String
																			[Const:String] "."
																		+
																		[Parenthesis:String]
																			[If:String]
																				[Binop:Bool]
																					[Field:Int]
																						[Field:Array<String>]
																							[Local typeRef(23022):haxe.macro.DefType:haxe.macro.DefType]
																							[FAnon:Array<String>] pack:Array<String>
																						[FInstance:Int]
																							Array<String>
																							length:Int
																					>
																					[Const:Int] 0
																				[Then:String] [Block:String] [Const:String] "."
																				[Else:String] [Block:String] [Const:String] ""
																	+
																	[Field:String]
																		[Local typeRef(23022):haxe.macro.DefType:haxe.macro.DefType]
																		[FAnon:String] name:String
															[Return:Dynamic]
																[Binop:Bool]
																	[Local fullPath(23023):String:String]
																	==
																	[Const:String] "elixir.Syntax"
											[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false
						[Else:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function isStructMethodCall[Function:(obj : haxe.macro.TypedExpr, fa : haxe.macro.FieldAccess) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(22088):haxe.macro.TypedExpr]
		[Arg:haxe.macro.FieldAccess] [Local fa(22089):haxe.macro.FieldAccess]
		[Block:Void]
			[Meta:Void]
				:ast(switch (obj.expr) {
	case TLocal(_):
		return true;	
	case TField(_, _):
		return true;	
	case _:
		return false;	
})
				[Block:Void]
					[Var `(22094):haxe.macro.TypedExprDef]
						[Field:haxe.macro.TypedExprDef]
							[Local obj(22088):haxe.macro.TypedExpr:haxe.macro.TypedExpr]
							[FAnon:haxe.macro.TypedExprDef] expr:haxe.macro.TypedExprDef
					[Switch:Void]
						[EnumIndex:Int] [Local `(22094):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
						[Case:Dynamic]
							[Const:Int] 1
							[Block:Dynamic]
								[Var `(22095):haxe.macro.TVar]
									[EnumParameter:haxe.macro.TVar]
										[Local `(22094):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TLocal
										0
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Case:Dynamic]
							[Const:Int] 4
							[Block:Dynamic]
								[Var `(22096):haxe.macro.TypedExpr]
									[EnumParameter:haxe.macro.TypedExpr]
										[Local `(22094):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										0
								[Var `(22097):haxe.macro.FieldAccess]
									[EnumParameter:haxe.macro.FieldAccess]
										[Local `(22094):haxe.macro.TypedExprDef:haxe.macro.TypedExprDef]
										TField
										1
								[Block:Dynamic] [Return:Dynamic] [Const:Bool] true
						[Default:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] false

	function isMutatingStructMethod[Function:(obj : haxe.macro.TypedExpr, methodName : String) -> Bool]
		[Arg:haxe.macro.TypedExpr] [Local obj(22098):haxe.macro.TypedExpr]
		[Arg:String] [Local methodName(22099):String]
		[Block:Dynamic]
			[Var mutatingPatterns(22100):Array<String>]
				[ArrayDecl:Array<String>]
					[Const:String] "write"
					[Const:String] "add"
					[Const:String] "push"
					[Const:String] "pop"
					[Const:String] "remove"
					[Const:String] "clear"
					[Const:String] "set"
					[Const:String] "update"
					[Const:String] "append"
					[Const:String] "prepend"
					[Const:String] "insert"
					[Const:String] "delete"
					[Const:String] "merge"
					[Const:String] "replace"
					[Const:String] "quote_"
					[Const:String] "fields_string"
					[Const:String] "class_string"
			[Block:Void]
				[Var `(22102):Int] [Const:Int] 0
				[While:Void]
					[Binop:Bool]
						[Local `(22102):Int:Int]
						<
						[Field:Int]
							[Local mutatingPatterns(22100):Array<String>:Array<String>]
							[FInstance:Int]
								Array<String>
								length:Int
					[Block:Void]
						[Var pattern(22101):String]
							[Array:String]
								[Local mutatingPatterns(22100):Array<String>:Array<String>]
								[Local `(22102):Int:Int]
						[Unop:Int]
							++
							Prefix
							[Local `(22102):Int:Int]
						[If:Void]
							[Binop:Bool]
								[Binop:Bool]
									[Local methodName(22099):String:String]
									==
									[Local pattern(22101):String:String]
								||
								[Binop:Bool]
									[Call:Int]
										[Field:(str : String, ?startIndex : Null<Int>) -> Int]
											[Local methodName(22099):String:String]
											[FInstance:(str : String, ?startIndex : Null<Int>) -> Int]
												String
												indexOf:(str : String, ?startIndex : Null<Int>) -> Int
										[Local pattern(22101):String:String]
										[Const:Null<Int>] null
									==
									[Const:Int] 0
							[Then:Dynamic] [Block:Dynamic] [Return:Dynamic] [Const:Bool] true
			[Return:Dynamic] [Const:Bool] false
}