@:directlyUsed @:used @:coreApi
class haxe.io.Bytes {

	function new(length:Int, b:Dynamic) {
		this.length = length;
		this.b = b;
	}

	public var length(default,null):Int;

	var b:Dynamic;

	@:has_untyped
	public function getString(pos:Int, len:Int, encoding:Null<haxe.io.Encoding> = null) {
		if ((encoding == null)) encoding = haxe.io.Encoding.UTF8;
		if ((pos < 0 || len < 0 || pos + len > this.length)) throw "Out of bounds";
		var slice = __elixir__(":binary.part({0}, {1}, {2})", this.b, pos, len);
		return __elixir__(":unicode.characters_to_list({0}, :utf8)", slice);
	}

	public function toString() {
		return this.getString(0, this.length);
	}

	@:has_untyped
	public function get(pos:Int) {
		if ((pos < 0 || pos >= this.length)) throw "Out of bounds";
		return __elixir__(":binary.at({0}, {1})", this.b, pos);
	}

	@:has_untyped
	public function set(pos:Int, v:Int) {
		if ((pos < 0 || pos >= this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos < this.length - 1)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 1, this.length - pos - 1) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::8, {2}::binary>>", beforePart, v, afterPart);
	}

	@:has_untyped
	public function blit(pos:Int, src:haxe.io.Bytes, srcpos:Int, len:Int) {
		if ((pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length)) throw "Out of bounds";
		var srcSlice = __elixir__(":binary.part({0}, {1}, {2})", src.b, srcpos, len);
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + len < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + len, this.length - pos - len) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::binary, {2}::binary>>", beforePart, srcSlice, afterPart);
	}

	@:has_untyped
	public function sub(pos:Int, len:Int) {
		if ((pos < 0 || len < 0 || pos + len > this.length)) throw "Out of bounds";
		var subBinary = __elixir__(":binary.part({0}, {1}, {2})", this.b, pos, len);
		return new haxe.io.Bytes(len, subBinary);
	}

	@:has_untyped
	public function fill(pos:Int, len:Int, value:Int) {
		if ((pos < 0 || len < 0 || pos + len > this.length)) throw "Out of bounds";
		var fillBytes = __elixir__(":binary.copy(<<{0}::8>>, {1})", value, len);
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + len < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + len, this.length - pos - len) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::binary, {2}::binary>>", beforePart, fillBytes, afterPart);
	}

	@:has_untyped
	public function compare(other:haxe.io.Bytes) {
		return __elixir__("case {0} do\n            x when x < {1} -> -1\n            x when x > {1} -> 1\n            _ -> 0\n        end", this.b, other.b);
	}

	public function getData() {
		return this.b;
	}

	@:has_untyped
	public function getDouble(pos:Int) {
		if ((pos < 0 || pos + 8 > this.length)) throw "Out of bounds";
		return __elixir__("<<value::float-little-size(64)>> = :binary.part({0}, {1}, 8); value", this.b, pos);
	}

	@:has_untyped
	public function setDouble(pos:Int, v:Float) {
		if ((pos < 0 || pos + 8 > this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + 8 < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 8, this.length - pos - 8) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::float-little-size(64), {2}::binary>>", beforePart, v, afterPart);
	}

	@:has_untyped
	public function getFloat(pos:Int) {
		if ((pos < 0 || pos + 4 > this.length)) throw "Out of bounds";
		return __elixir__("<<value::float-little-size(32)>> = :binary.part({0}, {1}, 4); value", this.b, pos);
	}

	@:has_untyped
	public function setFloat(pos:Int, v:Float) {
		if ((pos < 0 || pos + 4 > this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + 4 < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 4, this.length - pos - 4) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::float-little-size(32), {2}::binary>>", beforePart, v, afterPart);
	}

	@:has_untyped
	public function getUInt16(pos:Int) {
		if ((pos < 0 || pos + 2 > this.length)) throw "Out of bounds";
		return __elixir__("<<value::little-unsigned-size(16)>> = :binary.part({0}, {1}, 2); value", this.b, pos);
	}

	@:has_untyped
	public function setUInt16(pos:Int, v:Int) {
		if ((pos < 0 || pos + 2 > this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + 2 < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 2, this.length - pos - 2) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::little-unsigned-size(16), {2}::binary>>", beforePart, v, afterPart);
	}

	@:has_untyped
	public function getInt32(pos:Int) {
		if ((pos < 0 || pos + 4 > this.length)) throw "Out of bounds";
		return __elixir__("<<value::little-signed-size(32)>> = :binary.part({0}, {1}, 4); value", this.b, pos);
	}

	@:has_untyped
	public function setInt32(pos:Int, v:Int) {
		if ((pos < 0 || pos + 4 > this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + 4 < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 4, this.length - pos - 4) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::little-signed-size(32), {2}::binary>>", beforePart, v, afterPart);
	}

	@:has_untyped
	public function getInt64(pos:Int) {
		if ((pos < 0 || pos + 8 > this.length)) throw "Out of bounds";
		return __elixir__("<<value::little-signed-size(64)>> = :binary.part({0}, {1}, 8); value", this.b, pos);
	}

	@:has_untyped
	public function setInt64(pos:Int, v:haxe.Int64) {
		if ((pos < 0 || pos + 8 > this.length)) throw "Out of bounds";
		var beforePart = if ((pos > 0)) __elixir__(":binary.part({0}, 0, {1})", this.b, pos) else __elixir__("<<>>");
		var afterPart = if ((pos + 8 < this.length)) __elixir__(":binary.part({0}, {1}, {2})", this.b, pos + 8, this.length - pos - 8) else __elixir__("<<>>");
		this.b = __elixir__("<<{0}::binary, {1}::little-signed-size(64), {2}::binary>>", beforePart, v, afterPart);
	}

	public function readString(pos:Int, len:Int) {
		return this.getString(pos, len);
	}

	@:has_untyped
	public function toHex() {
		return __elixir__("Base.encode16({0}, case: :lower)", this.b);
	}

	@:has_untyped
	public static function alloc(length:Int) {
		var b = __elixir__(":binary.copy(<<0>>, {0})", length);
		return new haxe.io.Bytes(length, b);
	}

	@:has_untyped @:value({ encoding : UTF8 })
	public static function ofString(s:String, encoding:haxe.io.Encoding = haxe.io.Encoding.UTF8) {
		var binary = __elixir__(":unicode.characters_to_binary({0}, :utf8)", s);
		var length = __elixir__("byte_size({0})", binary);
		return new haxe.io.Bytes(length, binary);
	}

	public static function ofString

	@:has_untyped
	public static inline function fastGet(b:haxe.io.BytesData, pos:Int) {
		return __elixir__(":binary.at({0}, {1})", b, pos);
	}

	@:has_untyped
	public static function ofHex(s:String) {
		var binary = __elixir__("Base.decode16!({0}, case: :mixed)", s);
		var length = __elixir__("byte_size({0})", binary);
		return new haxe.io.Bytes(length, binary);
	}

	@:has_untyped
	public static function ofData(b:haxe.io.BytesData) {
		var length = __elixir__("byte_size({0})", b);
		return new haxe.io.Bytes(length, b);
	}
}