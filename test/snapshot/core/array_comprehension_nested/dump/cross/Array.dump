@:used @:coreApi
class Array<T> {

	@:has_untyped
	public function new() {
		__elixir__("[]");
	}

	@:realPath("length") @:native("length")
	public var length(default,null):Int;

	@:has_untyped
	public function map<S>(f:Array.T -> map.S) {
		return __elixir__("Enum.map({0}, {1})", this, f);
	}

	@:has_untyped
	public function filter(f:Array.T -> Bool) {
		return __elixir__("Enum.filter({0}, {1})", this, f);
	}

	@:has_untyped
	public function concat(a:Array<Array.T>) {
		return __elixir__("{0} ++ {1}", this, a);
	}

	@:has_untyped
	public function copy() {
		return __elixir__("{0}", this);
	}

	@:has_untyped
	public function contains(x:Array.T) {
		return __elixir__("Enum.member?({0}, {1})", this, x);
	}

	@:has_untyped
	public function join(sep:String) {
		return __elixir__("Enum.join({0}, {1})", this, sep);
	}

	@:has_untyped
	public function shift() {
		return __elixir__("List.first({0})", this);
	}

	@:has_untyped
	public function pop() {
		return __elixir__("List.last({0})", this);
	}

	@:has_untyped
	public function push(x:Array.T) {
		__elixir__("{0} ++ [{1}]", this, x);
		return this.length;
	}

	@:has_untyped
	public function toString() {
		return __elixir__("inspect({0})", this);
	}

	@:has_untyped
	public function reverse() {
		__elixir__("Enum.reverse({0})", this);
	}

	@:has_untyped
	public function sort(f:(Array.T, Array.T) -> Int) {
		__elixir__("Enum.sort({0}, {1})", this, f);
	}

	@:has_untyped
	public function lastIndexOf(x:Array.T, fromIndex:Null<Int> = null) {
		if ((fromIndex == null)) return __elixir__("\n                case Enum.reverse({0}) |> Enum.find_index(fn item -> item == {1} end) do\n                    nil -> -1\n                    idx -> length({0}) - idx - 1\n                end\n            ", this, x) else return __elixir__("\n                {0}\n                |> Enum.slice(0, {2} + 1)\n                |> Enum.reverse()\n                |> Enum.find_index(fn item -> item == {1} end)\n                |> case do\n                    nil -> -1\n                    idx -> {2} - idx\n                end\n            ", this, x, fromIndex);
	}

	@:has_untyped
	public function unshift(x:Array.T) {
		__elixir__("[{1} | {0}]", this, x);
	}

	@:has_untyped
	public function slice(pos:Int, end:Null<Int> = null) {
		if ((end == null)) return __elixir__("Enum.slice({0}, {1}..-1//1)", this, pos) else return __elixir__("Enum.slice({0}, {1}..{2}//1)", this, pos, end - 1);
	}

	@:has_untyped
	public function splice(pos:Int, len:Int) {
		return __elixir__("\n            {removed, remaining} = {0} |> Enum.split({1})\n            {splice, kept} = remaining |> Enum.split({2})\n            {0} = removed ++ kept\n            splice\n        ", this, pos, len);
	}

	@:has_untyped
	public function insert(pos:Int, x:Array.T) {
		__elixir__("List.insert_at({0}, {1}, {2})", this, pos, x);
	}

	@:has_untyped
	public function remove(x:Array.T) {
		var result = __elixir__("List.delete({0}, {1})", this, x);
		return __elixir__("{0} != {1}", result, this);
	}

	public inline function iterator() {
		return new haxe.iterators.ArrayIterator(this);
	}

	public inline function keyValueIterator() {
		return new haxe.iterators.ArrayKeyValueIterator(this);
	}

	@:has_untyped
	public function resize(len:Int) {
		__elixir__("Enum.take({0}, {1})", this, len);
	}
}