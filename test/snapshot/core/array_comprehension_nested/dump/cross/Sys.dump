@:used @:coreApi
class Sys {

	@:has_untyped
	public static inline function println(v:Dynamic) {
		__elixir__("IO.puts({0})", v);
	}

	@:has_untyped
	public static inline function print(v:Dynamic) {
		__elixir__("IO.write({0})", v);
	}

	@:has_untyped
	public static inline function stdin() {
		return __elixir__("Process.group_leader()");
	}

	@:has_untyped
	public static inline function stdout() {
		return __elixir__("Process.group_leader()");
	}

	@:has_untyped
	public static inline function stderr() {
		return __elixir__(":standard_error");
	}

	@:has_untyped
	public static function getChar(echo:Bool) {
		var char = __elixir__("\n            # Save current terminal settings\n            {:ok, old_settings} = :io.getopts(:standard_io)\n            \n            # Set terminal to raw mode if echo is false\n            if not {0} do\n                :io.setopts(:standard_io, [{:echo, false}])\n            end\n            \n            # Read single character\n            char = IO.getn(\"\", 1)\n            \n            # Restore terminal settings\n            :io.setopts(:standard_io, old_settings)\n            \n            # Convert to character code\n            case char do\n                <<c::utf8>> -> c\n                _ -> 0\n            end\n        ", echo);
		return char;
	}

	@:has_untyped
	public static function environment() {
		var env = new haxe.ds.StringMap();
		var elixirEnv = __elixir__("System.get_env()");
		__elixir__("\n            Enum.each({0}, fn {k, v} -> \n                {1}.set(k, v)\n                nil\n            end)", elixirEnv, env);
		return env;
	}

	@:has_untyped
	public static inline function getEnv(s:String) {
		return __elixir__("System.get_env({0})", s);
	}

	@:has_untyped
	public static inline function putEnv(s:String, v:String) {
		__elixir__("System.put_env({0}, {1})", s, v);
	}

	@:has_untyped
	public static inline function getCwd() {
		return __elixir__("File.cwd!()");
	}

	@:has_untyped
	public static inline function setCwd(s:String) {
		__elixir__("File.cd!({0})", s);
	}

	@:has_untyped
	public static function args() {
		return __elixir__("System.argv()");
	}

	@:has_untyped
	public static inline function exit(code:Int) {
		__elixir__("System.halt({0})", code);
	}

	@:has_untyped
	public static function command(cmd:String, args:Null<Array<String>> = null) {
		if ((args == null || args.length == 0)) return __elixir__("\n                case System.cmd(\"sh\", [\"-c\", {0}]) do\n                    {_, 0} -> 0\n                    {_, code} -> code\n                end", cmd) else return __elixir__("\n                case System.cmd({0}, {1}) do\n                    {_, 0} -> 0\n                    {_, code} -> code\n                end", cmd, args);
	}

	@:has_untyped
	public static inline function time() {
		return __elixir__("System.system_time(:second)");
	}

	@:has_untyped
	public static inline function cpuTime() {
		return __elixir__("\n            {total, _} = :erlang.statistics(:runtime)\n            total / 1000.0\n        ");
	}

	@:has_untyped
	public static inline function sleep(seconds:Float) {
		var milliseconds = Std.int(seconds * 1000);
		__elixir__("Process.sleep({0})", milliseconds);
	}

	@:has_untyped
	public static function systemName() {
		return __elixir__("\n            case :os.type() do\n                {:unix, :linux} -> \"linux\"\n                {:unix, :darwin} -> \"darwin\"\n                {:win32, _} -> \"windows\"\n                {:unix, name} -> Atom.to_string(name)\n                {family, name} -> Atom.to_string(family) <> \"_\" <> Atom.to_string(name)\n            end\n        ");
	}

	@:has_untyped
	public static function executablePath() {
		return __elixir__("\n            case :init.get_argument(:progname) do\n                {:ok, [[path | _]]} -> List.to_string(path)\n                _ -> System.find_executable(\"erl\") || \"\"\n            end\n        ");
	}

	public static function programPath() {
		return Sys.executablePath();
	}

	@:has_untyped
	public static function setTimeLocale(loc:String) {
		__elixir__("\n            Application.put_env(:elixir, :locale, {0})\n        ", loc);
		return true;
	}
}