class reflaxe.elixir.ast.builders.ModuleBuilder {

	public static function buildClassModule(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
		var previousModule = reflaxe.elixir.ast.ElixirASTBuilder.currentModule;
		reflaxe.elixir.ast.ElixirASTBuilder.currentModule = classType.name;
		var metadata = reflaxe.elixir.ast.builders.ModuleBuilder.createModuleMetadata(classType);
		var fqcn = if ((classType.pack != null && classType.pack.length > 0)) {
			(classType.pack.join(".") + "." + classType.name);
		} else {
			classType.name;
		};
		metadata.haxeFqcn = fqcn;
		if (metadata.isSchema) {
			metadata.schemaFields = [];
			metadata.hasTimestamps = classType.meta.has(":timestamps");
			{
				var ` = 0;
				while (` < varFields.length) {
					var vf = varFields[`];
					++ `;
					var t = reflaxe.elixir.ast.builders.ModuleBuilder.inferFieldType(vf.type);
					metadata.schemaFields.push({name : vf.name, type : t});
				};
			};
		};
		var moduleBody = if (metadata.isPhoenixWeb) {
			reflaxe.elixir.ast.builders.ModuleBuilder.buildMinimalBody(classType, varFields, funcFields);
		} else {
			if (metadata.isEndpoint) {
				reflaxe.elixir.ast.builders.ModuleBuilder.buildMinimalBody(classType, varFields, funcFields);
			} else {
				if (metadata.isController) {
					reflaxe.elixir.ast.builders.ModuleBuilder.buildControllerBody(classType, varFields, funcFields);
				} else {
					if (metadata.isLiveView) {
						reflaxe.elixir.ast.builders.ModuleBuilder.buildLiveViewBody(classType, varFields, funcFields);
					} else {
						if (metadata.isSchema) {
							reflaxe.elixir.ast.builders.ModuleBuilder.buildSchemaBody(classType, varFields, funcFields);
						} else {
							if (metadata.isRepo) {
								reflaxe.elixir.ast.builders.ModuleBuilder.buildMinimalBody(classType, varFields, funcFields);
							} else {
								if (metadata.isApplication) {
									reflaxe.elixir.ast.builders.ModuleBuilder.buildApplicationBody(classType, varFields, funcFields);
								} else {
									if (metadata.isPresence) {
										reflaxe.elixir.ast.builders.ModuleBuilder.buildRegularModuleBody(classType, varFields, funcFields);
									} else {
										if (metadata.isExunit) {
											reflaxe.elixir.ast.builders.ModuleBuilder.buildExUnitBody(classType, varFields, funcFields);
										} else {
											if (metadata.isDbTypes) {
												reflaxe.elixir.ast.builders.ModuleBuilder.buildDbTypesBody(classType, metadata);
											} else {
												reflaxe.elixir.ast.builders.ModuleBuilder.buildRegularModuleBody(classType, varFields, funcFields);
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
		var moduleAST = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(moduleName, moduleBody), metadata : metadata, pos : pos};
		};
		var hasStaticMain = false;
		{
			var ` = 0;
			var ` = classType.statics.get();
			while (` < `.length) {
				var staticField = `[`];
				++ `;
				if (staticField.name == "main") {
					hasStaticMain = true;
					break;
				};
			};
		};
		var entrypointMode = reflaxe.elixir.ast.builders.ModuleBuilder.determineEntrypointMode(classType, hasStaticMain);
		if (entrypointMode == reflaxe.elixir.ast.builders.EntrypointMode.Main && reflaxe.elixir.ast.ElixirASTBuilder.compiler != null) {
			if (reflaxe.elixir.ast.ElixirASTBuilder.compiler.modulesWithBootstrap.indexOf(moduleName, null) < 0) {
				reflaxe.elixir.ast.ElixirASTBuilder.compiler.modulesWithBootstrap.push(moduleName);
			};
		};
		if (entrypointMode == reflaxe.elixir.ast.builders.EntrypointMode.Main && reflaxe.elixir.ast.builders.ModuleBuilder.getBootstrapStrategy() == reflaxe.elixir.ast.builders.BootstrapStrategy.Inline) {
			var blockElements = [];
			blockElements = blockElements.concat(reflaxe.elixir.ast.builders.ModuleBuilder.generateRequireStatements(classType, moduleName));
			blockElements.push(moduleAST);
			var bootstrapCode = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, moduleName + ".main", []), metadata : {}, pos : pos};
			};
			blockElements.push(bootstrapCode);
			moduleAST = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(blockElements), metadata : {}, pos : pos};
			};
		};
		reflaxe.elixir.ast.ElixirASTBuilder.currentModule = previousModule;
		return moduleAST;
	}

	static function inferFieldType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TType(tt, params):
		var n = tt.get().name;
		if (n == "Null" && params != null && params.length == 1) {
			inferFieldType(params[0]);
		} else {
			var underlying = tt.get().type;
			if (underlying != null) inferFieldType(underlying) else "Dynamic";
		};	
	case TInst(ti, params):
		var n = ti.get().name;
		if (n == "Array" && params != null && params.length == 1) {
			return switch (params[0]) {
				case TInst(ti2, _):
					(ti2.get().name == "String") ? "Array<String>" : "Array<Dynamic>";				
				case TType(_, _):
					var inner = inferFieldType(params[0]);
					(inner == "String") ? "Array<String>" : "Array<Dynamic>";				
				case _:
					"Array<Dynamic>";				
			};
		};
		return switch (n) {
			case "String":
				"String";			
			case "Int":
				"Int";			
			case "Bool":
				"Bool";			
			case "Date":
				"NaiveDateTime";			
			default:
				"Dynamic";			
		};	
	case TAbstract(ta, _):
		var n = ta.get().name;
		return switch (n) {
			case "Int":
				"Int";			
			case "Bool":
				"Bool";			
			case "Single", "Float":
				"Float";			
			default:
				"Dynamic";			
		};	
	case _:
		"Dynamic";	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var ti = `;
					var params = `;
					{
						var n = ti.get().name;
						if (n == "Array" && params != null && params.length == 1) {
							return @:ast(switch (params[0]) {
	case TInst(ti2, _):
		(ti2.get().name == "String") ? "Array<String>" : "Array<Dynamic>";	
	case TType(_, _):
		var inner = inferFieldType(params[0]);
		(inner == "String") ? "Array<String>" : "Array<Dynamic>";	
	case _:
		"Array<Dynamic>";	
}) {
								var ` = params[0];
								switch (enumIndex `) {
									case 2: {
										var ` = `[0];
										var ` = `[1];
										{
											var ti2 = `;
											{
												if ((ti2.get().name == "String")) {
													"Array<String>";
												} else {
													"Array<Dynamic>";
												};
											};
										};
									};
									case 3: {
										var ` = `[0];
										var ` = `[1];
										{
											var inner = reflaxe.elixir.ast.builders.ModuleBuilder.inferFieldType(params[0]);
											if ((inner == "String")) {
												"Array<String>";
											} else {
												"Array<Dynamic>";
											};
										};
									};
									default: {
										"Array<Dynamic>";
									}
								};
							};
						};
						return @:ast(switch (n) {
	case "String":
		"String";	
	case "Int":
		"Int";	
	case "Bool":
		"Bool";	
	case "Date":
		"NaiveDateTime";	
	default:
		"Dynamic";	
}) switch (n) {
							case "Bool": {
								{
									"Bool";
								};
							};
							case "Date": {
								{
									"NaiveDateTime";
								};
							};
							case "Int": {
								{
									"Int";
								};
							};
							case "String": {
								{
									"String";
								};
							};
							default: {
								"Dynamic";
							}
						};
					};
				};
			};
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var tt = `;
					var params = `;
					{
						var n = tt.get().name;
						if (n == "Null" && params != null && params.length == 1) {
							reflaxe.elixir.ast.builders.ModuleBuilder.inferFieldType(params[0]);
						} else {
							var underlying = tt.get().type;
							if (underlying != null) {
								reflaxe.elixir.ast.builders.ModuleBuilder.inferFieldType(underlying);
							} else {
								"Dynamic";
							};
						};
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var ta = `;
					{
						var n = ta.get().name;
						return @:ast(switch (n) {
	case "Int":
		"Int";	
	case "Bool":
		"Bool";	
	case "Single", "Float":
		"Float";	
	default:
		"Dynamic";	
}) switch (n) {
							case "Bool": {
								{
									"Bool";
								};
							};
							case "Float", "Single": {
								{
									"Float";
								};
							};
							case "Int": {
								{
									"Int";
								};
							};
							default: {
								"Dynamic";
							}
						};
					};
				};
			};
			default: {
				"Dynamic";
			}
		};
	}

	static function determineEntrypointMode(classType:haxe.macro.ClassType, hasStaticMain:Bool) {
		if (classType.meta.has(":application")) {
			return reflaxe.elixir.ast.builders.EntrypointMode.Otp;
		};
		if (hasStaticMain) {
			var ep = haxe.macro.Context.definedValue("entrypoint");
			if (ep != null) {
				@:ast(switch (ep.toLowerCase()) {
	case "none":
		return EntrypointMode.None;	
	case "otp":
		return EntrypointMode.Otp;	
	case "main":
		return EntrypointMode.Main;	
	default:
}) {
					var ` = ep.toLowerCase();
					switch (`) {
						case "main": {
							{
								return reflaxe.elixir.ast.builders.EntrypointMode.Main;
							};
						};
						case "none": {
							{
								return reflaxe.elixir.ast.builders.EntrypointMode.None;
							};
						};
						case "otp": {
							{
								return reflaxe.elixir.ast.builders.EntrypointMode.Otp;
							};
						};
						default: {}
					};
				};
			};
			return reflaxe.elixir.ast.builders.EntrypointMode.Main;
		};
		return reflaxe.elixir.ast.builders.EntrypointMode.None;
	}

	public static function getBootstrapStrategy() {
		var val = haxe.macro.Context.definedValue("bootstrap_strategy");
		if (val != null) {
			var v = val.toLowerCase();
			if (v == "inline") {
				return reflaxe.elixir.ast.builders.BootstrapStrategy.Inline;
			};
			if (v == "inline_deterministic") {
				return reflaxe.elixir.ast.builders.BootstrapStrategy.InlineDeterministic;
			};
			if (v == "external") {
				return reflaxe.elixir.ast.builders.BootstrapStrategy.External;
			};
		};
		if (haxe.macro.Context.defined("inline_bootstrap")) {
			return reflaxe.elixir.ast.builders.BootstrapStrategy.Inline;
		};
		return reflaxe.elixir.ast.builders.BootstrapStrategy.External;
	}

	static function generateRequireStatements(classType:haxe.macro.ClassType, moduleName:String) {
		var requires = [];
		if (reflaxe.elixir.ast.ElixirASTBuilder.compiler != null) {
			var deps = {
				var this = reflaxe.elixir.ast.ElixirASTBuilder.compiler.moduleDependencies;
				cast this.get(moduleName);
			};
			if (deps != null) {
				var closure = reflaxe.elixir.ast.builders.ModuleBuilder.computeTransitiveDependencies(moduleName);
				var outputPaths = reflaxe.elixir.ast.ElixirASTBuilder.compiler.moduleOutputPaths;
				var topo = reflaxe.elixir.ast.ElixirASTBuilder.compiler.getSortedModules();
				var ordered = [];
				{
					var ` = 0;
					while (` < topo.length) {
						var depModule = topo[`];
						++ `;
						if (closure.exists(depModule)) {
							ordered.push(depModule);
						};
					};
				};
				if (ordered.length < Lambda.count(cast closure, null)) {
					var allKeys = {
						var ` = [];
						for (k in closure.keys()) {
							`.push(k);
						};
						`;
					};
					allKeys.sort(function(a:String, b:String) return Reflect.compare(a, b));
					ordered = allKeys;
				};
				{
					var ` = 0;
					while (` < ordered.length) {
						var depModule = ordered[`];
						++ `;
						var filePath = cast outputPaths.get(depModule);
						if (filePath == null) {
							var modulePack = {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.compiler.modulePackages;
								cast this.get(depModule);
							};
							filePath = reflaxe.elixir.ast.ElixirASTBuilder.compiler.getModuleOutputPath(depModule, modulePack);
						};
						if (filePath != null) {
							requires.push({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Code.require_file", [{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EString(filePath), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("__DIR__"), metadata : {}, pos : pos};
								}]), metadata : {}, pos : pos};
							});
						};
					};
				};
			};
		};
		return requires;
	}

	static function computeTransitiveDependencies(root:String) {
		var result = {
			{};
			new haxe.ds.StringMap();
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.compiler == null) {
			return result;
		};
		var graph = reflaxe.elixir.ast.ElixirASTBuilder.compiler.moduleDependencies;
		var stack = [];
		var direct = cast graph.get(root);
		if (direct != null) {
			for (k in direct.keys()) {
				stack.push(k);
			};
		};
		while (stack.length > 0) {
			var m = stack.pop();
			if (m == null) {
				break;
			};
			if (m == root) {
				continue;
			};
			if (result.exists(m)) {
				continue;
			};
			{
				result.set(m, true);
			};
			var next = cast graph.get(m);
			if (next != null) {
				for (n in next.keys()) {
					if (! result.exists(n)) {
						stack.push(n);
					};
				};
			};
		};
		return result;
	}

	public static function extractModuleName(classType:haxe.macro.ClassType) {
		if (classType.meta.has(":native")) {
			var nativeMeta = classType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		return s;	
	default:
}) {
					var ` = nativeMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									return s;
								};
							};
						} else {};
					} else {};
				};
			};
		};
		return classType.name;
	}

	static function createModuleMetadata(classType:haxe.macro.ClassType) {
		var metadata = {};
		if (classType.meta.has(":endpoint")) {
			metadata.isEndpoint = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
		};
		if (classType.meta.has(":liveview")) {
			metadata.isLiveView = true;
		};
		if (classType.meta.has(":schema")) {
			metadata.isSchema = true;
			metadata.tableName = reflaxe.elixir.ast.builders.ModuleBuilder.extractTableName(classType);
		};
		if (classType.meta.has(":repo")) {
			metadata.isRepo = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
			var meta = classType.meta.extract(":repo");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				@:ast(switch (meta[0].params[0].expr) {
	case EObjectDecl(fields):
		for (field  in  fields) {
			switch (field.field) {
				case "adapter":
					switch (field.expr.expr) {
						case EConst(CIdent(s)) | EField(_, s):
							metadata.dbAdapter = switch (s) {
								case "Postgres":
									"postgrex";								
								case "MySQL":
									"mysql";								
								case "SQLite3":
									"sqlite3";								
								case "SQLServer":
									"mssql";								
								case _:
									"postgrex";								
							};						
						default:
					};				
				case "json":
					switch (field.expr.expr) {
						case EConst(CIdent(s)) | EField(_, s):
							metadata.jsonModule = switch (s) {
								case "Jason":
									"Jason";								
								case "Poison":
									"Poison";								
								case "None":
									null;								
								case _:
									"Jason";								
							};						
						default:
					};				
				case "extensions":
					switch (field.expr.expr) {
						case EArrayDecl(values):
							metadata.extensions = [];
							for (v  in  values) {
								switch (v.expr) {
									case EConst(CIdent(s)) | EField(_, s):
										var ext = switch (s) {
											case "UuidOssp":
												"uuid-ossp";											
											case "PostGIS":
												"postgis";											
											case "HStore":
												"hstore";											
											case "PgTrgm":
												"pg_trgm";											
											case "PgCrypto":
												"pgcrypto";											
											case "JsonbPlv8":
												"jsonb_plv8";											
											case _:
												s;											
										};
										metadata.extensions.push(ext);									
									default:
								};
							};						
						default:
					};				
				case "poolSize":
					switch (field.expr.expr) {
						case EConst(CInt(i)):
							metadata.poolSize = Std.parseInt(i);						
						default:
					};				
			};
		};
		if (metadata.dbAdapter == "postgrex") {
			metadata.needsPostgrexTypes = true;
			if (metadata.jsonModule == null) metadata.jsonModule = "Jason";
			if (metadata.extensions == null) metadata.extensions = [];
		};	
	default:
}) {
					var ` = meta[0].params[0].expr;
					if (enumIndex ` == 5) {
						var ` = `[0];
						{
							var fields = `;
							{
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										@:ast(switch (field.field) {
	case "adapter":
		switch (field.expr.expr) {
			case EConst(CIdent(s)) | EField(_, s):
				metadata.dbAdapter = switch (s) {
					case "Postgres":
						"postgrex";					
					case "MySQL":
						"mysql";					
					case "SQLite3":
						"sqlite3";					
					case "SQLServer":
						"mssql";					
					case _:
						"postgrex";					
				};			
			default:
		};	
	case "json":
		switch (field.expr.expr) {
			case EConst(CIdent(s)) | EField(_, s):
				metadata.jsonModule = switch (s) {
					case "Jason":
						"Jason";					
					case "Poison":
						"Poison";					
					case "None":
						null;					
					case _:
						"Jason";					
				};			
			default:
		};	
	case "extensions":
		switch (field.expr.expr) {
			case EArrayDecl(values):
				metadata.extensions = [];
				for (v  in  values) {
					switch (v.expr) {
						case EConst(CIdent(s)) | EField(_, s):
							var ext = switch (s) {
								case "UuidOssp":
									"uuid-ossp";								
								case "PostGIS":
									"postgis";								
								case "HStore":
									"hstore";								
								case "PgTrgm":
									"pg_trgm";								
								case "PgCrypto":
									"pgcrypto";								
								case "JsonbPlv8":
									"jsonb_plv8";								
								case _:
									s;								
							};
							metadata.extensions.push(ext);						
						default:
					};
				};			
			default:
		};	
	case "poolSize":
		switch (field.expr.expr) {
			case EConst(CInt(i)):
				metadata.poolSize = Std.parseInt(i);			
			default:
		};	
}) {
											var ` = field.field;
											switch (`) {
												case "adapter": {
													{
														@:ast(switch (field.expr.expr) {
	case EConst(CIdent(s)) | EField(_, s):
		metadata.dbAdapter = switch (s) {
			case "Postgres":
				"postgrex";			
			case "MySQL":
				"mysql";			
			case "SQLite3":
				"sqlite3";			
			case "SQLServer":
				"mssql";			
			case _:
				"postgrex";			
		};	
	default:
}) {
															var ` = field.expr.expr;
															switch (enumIndex `) {
																case 0: {
																	var ` = `[0];
																	if (enumIndex ` == 3) {
																		var ` = `[0];
																		{
																			var s = `;
																			{
																				metadata.dbAdapter = @:ast(switch (s) {
	case "Postgres":
		"postgrex";	
	case "MySQL":
		"mysql";	
	case "SQLite3":
		"sqlite3";	
	case "SQLServer":
		"mssql";	
	case _:
		"postgrex";	
}) switch (s) {
																					case "MySQL": {
																						{
																							"mysql";
																						};
																					};
																					case "Postgres": {
																						{
																							"postgrex";
																						};
																					};
																					case "SQLServer": {
																						{
																							"mssql";
																						};
																					};
																					case "SQLite3": {
																						{
																							"sqlite3";
																						};
																					};
																					default: {
																						"postgrex";
																					}
																				};
																			};
																		};
																	} else {};
																};
																case 3: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var s = `;
																		{
																			metadata.dbAdapter = @:ast(switch (s) {
	case "Postgres":
		"postgrex";	
	case "MySQL":
		"mysql";	
	case "SQLite3":
		"sqlite3";	
	case "SQLServer":
		"mssql";	
	case _:
		"postgrex";	
}) switch (s) {
																				case "MySQL": {
																					{
																						"mysql";
																					};
																				};
																				case "Postgres": {
																					{
																						"postgrex";
																					};
																				};
																				case "SQLServer": {
																					{
																						"mssql";
																					};
																				};
																				case "SQLite3": {
																					{
																						"sqlite3";
																					};
																				};
																				default: {
																					"postgrex";
																				}
																			};
																		};
																	};
																};
																default: {}
															};
														};
													};
												};
												case "extensions": {
													{
														@:ast(switch (field.expr.expr) {
	case EArrayDecl(values):
		metadata.extensions = [];
		for (v  in  values) {
			switch (v.expr) {
				case EConst(CIdent(s)) | EField(_, s):
					var ext = switch (s) {
						case "UuidOssp":
							"uuid-ossp";						
						case "PostGIS":
							"postgis";						
						case "HStore":
							"hstore";						
						case "PgTrgm":
							"pg_trgm";						
						case "PgCrypto":
							"pgcrypto";						
						case "JsonbPlv8":
							"jsonb_plv8";						
						case _:
							s;						
					};
					metadata.extensions.push(ext);				
				default:
			};
		};	
	default:
}) {
															var ` = field.expr.expr;
															if (enumIndex ` == 6) {
																var ` = `[0];
																{
																	var values = `;
																	{
																		metadata.extensions = [];
																		{
																			var ` = 0;
																			while (` < values.length) {
																				var v = values[`];
																				++ `;
																				@:ast(switch (v.expr) {
	case EConst(CIdent(s)) | EField(_, s):
		var ext = switch (s) {
			case "UuidOssp":
				"uuid-ossp";			
			case "PostGIS":
				"postgis";			
			case "HStore":
				"hstore";			
			case "PgTrgm":
				"pg_trgm";			
			case "PgCrypto":
				"pgcrypto";			
			case "JsonbPlv8":
				"jsonb_plv8";			
			case _:
				s;			
		};
		metadata.extensions.push(ext);	
	default:
}) {
																					var ` = v.expr;
																					switch (enumIndex `) {
																						case 0: {
																							var ` = `[0];
																							if (enumIndex ` == 3) {
																								var ` = `[0];
																								{
																									var s = `;
																									{
																										var ext = @:ast(switch (s) {
	case "UuidOssp":
		"uuid-ossp";	
	case "PostGIS":
		"postgis";	
	case "HStore":
		"hstore";	
	case "PgTrgm":
		"pg_trgm";	
	case "PgCrypto":
		"pgcrypto";	
	case "JsonbPlv8":
		"jsonb_plv8";	
	case _:
		s;	
}) switch (s) {
																											case "HStore": {
																												{
																													"hstore";
																												};
																											};
																											case "JsonbPlv8": {
																												{
																													"jsonb_plv8";
																												};
																											};
																											case "PgCrypto": {
																												{
																													"pgcrypto";
																												};
																											};
																											case "PgTrgm": {
																												{
																													"pg_trgm";
																												};
																											};
																											case "PostGIS": {
																												{
																													"postgis";
																												};
																											};
																											case "UuidOssp": {
																												{
																													"uuid-ossp";
																												};
																											};
																											default: {
																												s;
																											}
																										};
																										metadata.extensions.push(ext);
																									};
																								};
																							} else {};
																						};
																						case 3: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var s = `;
																								{
																									var ext = @:ast(switch (s) {
	case "UuidOssp":
		"uuid-ossp";	
	case "PostGIS":
		"postgis";	
	case "HStore":
		"hstore";	
	case "PgTrgm":
		"pg_trgm";	
	case "PgCrypto":
		"pgcrypto";	
	case "JsonbPlv8":
		"jsonb_plv8";	
	case _:
		s;	
}) switch (s) {
																										case "HStore": {
																											{
																												"hstore";
																											};
																										};
																										case "JsonbPlv8": {
																											{
																												"jsonb_plv8";
																											};
																										};
																										case "PgCrypto": {
																											{
																												"pgcrypto";
																											};
																										};
																										case "PgTrgm": {
																											{
																												"pg_trgm";
																											};
																										};
																										case "PostGIS": {
																											{
																												"postgis";
																											};
																										};
																										case "UuidOssp": {
																											{
																												"uuid-ossp";
																											};
																										};
																										default: {
																											s;
																										}
																									};
																									metadata.extensions.push(ext);
																								};
																							};
																						};
																						default: {}
																					};
																				};
																			};
																		};
																	};
																};
															} else {};
														};
													};
												};
												case "json": {
													{
														@:ast(switch (field.expr.expr) {
	case EConst(CIdent(s)) | EField(_, s):
		metadata.jsonModule = switch (s) {
			case "Jason":
				"Jason";			
			case "Poison":
				"Poison";			
			case "None":
				null;			
			case _:
				"Jason";			
		};	
	default:
}) {
															var ` = field.expr.expr;
															switch (enumIndex `) {
																case 0: {
																	var ` = `[0];
																	if (enumIndex ` == 3) {
																		var ` = `[0];
																		{
																			var s = `;
																			{
																				metadata.jsonModule = @:ast(switch (s) {
	case "Jason":
		"Jason";	
	case "Poison":
		"Poison";	
	case "None":
		null;	
	case _:
		"Jason";	
}) switch (s) {
																					case "Jason": {
																						{
																							"Jason";
																						};
																					};
																					case "None": {
																						{
																							null;
																						};
																					};
																					case "Poison": {
																						{
																							"Poison";
																						};
																					};
																					default: {
																						"Jason";
																					}
																				};
																			};
																		};
																	} else {};
																};
																case 3: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var s = `;
																		{
																			metadata.jsonModule = @:ast(switch (s) {
	case "Jason":
		"Jason";	
	case "Poison":
		"Poison";	
	case "None":
		null;	
	case _:
		"Jason";	
}) switch (s) {
																				case "Jason": {
																					{
																						"Jason";
																					};
																				};
																				case "None": {
																					{
																						null;
																					};
																				};
																				case "Poison": {
																					{
																						"Poison";
																					};
																				};
																				default: {
																					"Jason";
																				}
																			};
																		};
																	};
																};
																default: {}
															};
														};
													};
												};
												case "poolSize": {
													{
														@:ast(switch (field.expr.expr) {
	case EConst(CInt(i)):
		metadata.poolSize = Std.parseInt(i);	
	default:
}) {
															var ` = field.expr.expr;
															if (enumIndex ` == 0) {
																var ` = `[0];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var i = `;
																		{
																			metadata.poolSize = Std.parseInt(i);
																		};
																	};
																} else {};
															} else {};
														};
													};
												};
											};
										};
									};
								};
								if (metadata.dbAdapter == "postgrex") {
									metadata.needsPostgrexTypes = true;
									if (metadata.jsonModule == null) {
										metadata.jsonModule = "Jason";
									};
									if (metadata.extensions == null) {
										metadata.extensions = [];
									};
								};
							};
						};
					} else {};
				};
			};
		};
		if (classType.meta.has(":postgrexTypes")) {
			metadata.isPostgrexTypes = true;
			var meta = classType.meta.extract(":postgrexTypes");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				@:ast(switch (meta[0].params[0].expr) {
	case EConst(CString(s, _)):
		metadata.jsonModule = s;	
	default:
}) {
					var ` = meta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									metadata.jsonModule = s;
								};
							};
						} else {};
					} else {};
				};
			};
			if (metadata.jsonModule == null) {
				metadata.jsonModule = "Jason";
			};
			metadata.isDbTypes = true;
			metadata.dbAdapter = "postgrex";
			if (metadata.extensions == null) {
				metadata.extensions = [];
			};
		};
		if (classType.meta.has(":dbTypes")) {
			metadata.isDbTypes = true;
			var meta = classType.meta.extract(":dbTypes");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				var params = meta[0].params;
				@:ast(switch (params[0].expr) {
	case EConst(CString(s, _)):
		metadata.dbAdapter = s;	
	default:
		metadata.dbAdapter = "postgrex";	
}) {
					var ` = params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									metadata.dbAdapter = s;
								};
							};
						} else {
							metadata.dbAdapter = "postgrex";
						};
					} else {
						metadata.dbAdapter = "postgrex";
					};
				};
				if (params.length > 1) {
					@:ast(switch (params[1].expr) {
	case EConst(CString(s, _)):
		metadata.jsonModule = s;	
	default:
}) {
						var ` = params[1].expr;
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (enumIndex ` == 2) {
								var ` = `[0];
								var ` = `[1];
								{
									var s = `;
									{
										metadata.jsonModule = s;
									};
								};
							} else {};
						} else {};
					};
				};
				if (params.length > 2) {
					@:ast(switch (params[2].expr) {
	case EArrayDecl(values):
		var exts:Array<String> = [];
		for (v  in  values) switch (v.expr) {
			case EConst(CString(s, _)):
				exts.push(s);			
			default:
		};
		metadata.extensions = exts;	
	default:
}) {
						var ` = params[2].expr;
						if (enumIndex ` == 6) {
							var ` = `[0];
							{
								var values = `;
								{
									var exts = [];
									{
										var ` = 0;
										while (` < values.length) {
											var v = values[`];
											++ `;
											@:ast(switch (v.expr) {
	case EConst(CString(s, _)):
		exts.push(s);	
	default:
}) {
												var ` = v.expr;
												if (enumIndex ` == 0) {
													var ` = `[0];
													if (enumIndex ` == 2) {
														var ` = `[0];
														var ` = `[1];
														{
															var s = `;
															{
																exts.push(s);
															};
														};
													} else {};
												} else {};
											};
										};
									};
									metadata.extensions = exts;
								};
							};
						} else {};
					};
				};
			};
			if (metadata.jsonModule == null) {
				metadata.jsonModule = "Jason";
			};
			if (metadata.extensions == null) {
				metadata.extensions = [];
			};
		};
		if (classType.meta.has(":application")) {
			metadata.isApplication = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
		};
		if (classType.meta.has(":genserver")) {
			metadata.isGenServer = true;
		};
		if (classType.meta.has(":router")) {
			metadata.isRouter = true;
		};
		if (classType.meta.has(":controller")) {
			metadata.isController = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
		};
		if (classType.meta.has(":presence")) {
			metadata.isPresence = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
		};
		if (classType.meta.has(":phoenixWeb") || classType.meta.has(":phoenixWebModule")) {
			metadata.isPhoenixWeb = true;
			metadata.appName = reflaxe.elixir.ast.builders.ModuleBuilder.extractAppName(classType);
		};
		if (classType.meta.has(":exunit") || classType.meta.has(":elixir.exunit")) {
			metadata.isExunit = true;
		};
		return metadata;
	}

	static function extractAppName(classType:haxe.macro.ClassType) {
		if (classType.meta.has(":appName")) {
			var appNameMeta = classType.meta.extract(":appName");
			if (appNameMeta.length > 0 && appNameMeta[0].params != null && appNameMeta[0].params.length > 0) {
				@:ast(switch (appNameMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		return NameUtils.toSnakeCase(s);	
	default:
}) {
					var ` = appNameMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									return reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
								};
							};
						} else {};
					} else {};
				};
			};
		};
		var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
		var appName = moduleName.split("Web")[0];
		return reflaxe.elixir.ast.NameUtils.toSnakeCase(appName);
	}

	static function extractTableName(classType:haxe.macro.ClassType) {
		var schemaMeta = classType.meta.extract(":schema");
		if (schemaMeta.length > 0 && schemaMeta[0].params != null && schemaMeta[0].params.length > 0) {
			@:ast(switch (schemaMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		return s;	
	default:
}) {
				var ` = schemaMeta[0].params[0].expr;
				if (enumIndex ` == 0) {
					var ` = `[0];
					if (enumIndex ` == 2) {
						var ` = `[0];
						var ` = `[1];
						{
							var s = `;
							{
								return s;
							};
						};
					} else {};
				} else {};
			};
		};
		var className = reflaxe.elixir.ast.NameUtils.toSnakeCase(classType.name);
		return className + "s";
	}

	static function buildMinimalBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([]), metadata : {}, pos : pos};
		};
	}

	static function buildDbTypesBody(classType:haxe.macro.ClassType, metadata:reflaxe.elixir.ast.ElixirMetadata) {
		var statements = [];
		var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
		if (metadata.dbAdapter == "postgrex") {
			var extensionsAST = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EList([]), metadata : {}, pos : pos};
			};
			if (metadata.extensions != null && metadata.extensions.length > 0) {
				var extElements = {
					var _this = metadata.extensions;
					{
						var ` = [];
						{
							var ` = 0;
							var ` = _this;
							while (` < `.length) {
								var v = `[`];
								++ `;
								`.push(function(ext:String) {
									return {
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(ext);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									};
								}(v));
							};
						};
						`;
					};
				};
				extensionsAST = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EList(extElements), metadata : {}, pos : pos};
				};
			};
			var options = [];
			if (metadata.jsonModule != null) {
				var jsonAtom = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "json"), metadata : {}, pos : pos};
				};
				var jsonModule = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(metadata.jsonModule), metadata : {}, pos : pos};
				};
				var keywordElement = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([jsonAtom, jsonModule]), metadata : {}, pos : pos};
				};
				options.push(keywordElement);
			};
			var moduleRef = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
			};
			var args = [moduleRef, extensionsAST, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EList(options), metadata : {}, pos : pos};
			}];
			var defineCall = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Postgrex.Types"), metadata : {}, pos : pos};
				}, "define", args), metadata : {}, pos : pos};
			};
			statements.push(defineCall);
		} else {
			var rawExpr = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("# Database types for adapter: " + metadata.dbAdapter), metadata : {}, pos : pos};
			};
			statements.push(rawExpr);
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildControllerBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				if (func.expr() != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					var funcExpr = func.expr();
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		var args = [];
		for (arg  in  tfunc.args) {
			var paramName = NameUtils.toSnakeCase(arg.v.name);
			args.push(PVar(paramName));
		};
		var functionUsageMap = if (tfunc.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
		} else {
			null;
		};
		var body = if (tfunc.expr != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
		} else {
			makeAST(ENil);
		};
		if (func.isPublic) {
			statements.push(makeAST(EDef(funcName, args, null, body)));
		} else {
			statements.push(makeAST(EDefp(funcName, args, null, body)));
		};	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									var args = [];
									{
										var ` = 0;
										var ` = tfunc.args;
										while (` < `.length) {
											var arg = `[`];
											++ `;
											var paramName = reflaxe.elixir.ast.NameUtils.toSnakeCase(arg.v.name);
											args.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
										};
									};
									var functionUsageMap = if (tfunc.expr != null) {
										reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
									} else {
										null;
									};
									var body = if (tfunc.expr != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									};
									if (func.isPublic) {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, body), metadata : {}, pos : pos};
										});
									} else {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, args, null, body), metadata : {}, pos : pos};
										});
									};
								};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildLiveViewBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		var phoenixComponentFunctions = ["assign", "assign_multiple", "assign_new", "update", "get_assign"];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				if (phoenixComponentFunctions.indexOf(func.name, null) != -1) {
					continue;
				};
				if (func.expr() != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					var funcExpr = func.expr();
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		var args = [];
		for (arg  in  tfunc.args) {
			var paramName = NameUtils.toSnakeCase(arg.v.name);
			args.push(PVar(paramName));
		};
		var functionUsageMap = if (tfunc.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
		} else {
			null;
		};
		var body = if (tfunc.expr != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
		} else {
			makeAST(ENil);
		};
		var isTestFunction = func.meta.has(":test");
		var funcAst = makeAST(EDef(funcName, args, null, body));
		if (isTestFunction) {
			var metadata = funcAst.metadata != null ? funcAst.metadata : { };
			metadata.isTest = true;
			funcAst = makeASTWithMeta(funcAst.def, metadata, funcAst.pos);
		};
		statements.push(funcAst);	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									var args = [];
									{
										var ` = 0;
										var ` = tfunc.args;
										while (` < `.length) {
											var arg = `[`];
											++ `;
											var paramName = reflaxe.elixir.ast.NameUtils.toSnakeCase(arg.v.name);
											args.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
										};
									};
									var functionUsageMap = if (tfunc.expr != null) {
										reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
									} else {
										null;
									};
									var body = if (tfunc.expr != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									};
									var isTestFunction = func.meta.has(":test");
									var funcAst = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, body), metadata : {}, pos : pos};
									};
									if (isTestFunction) {
										var metadata = if (funcAst.metadata != null) {
											funcAst.metadata;
										} else {};
										metadata.isTest = true;
										funcAst = {def : funcAst.def, metadata : metadata, pos : funcAst.pos};
									};
									statements.push(funcAst);
								};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildSchemaBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				var funcExpr = func.expr();
				if (funcExpr != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		var args = [];
		for (arg  in  tfunc.args) {
			var paramName = NameUtils.toSnakeCase(arg.v.name);
			args.push(PVar(paramName));
		};
		var functionUsageMap = if (tfunc.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
		} else {
			null;
		};
		var body = if (tfunc.expr != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
		} else {
			makeAST(ENil);
		};
		if (func.isPublic) {
			statements.push(makeAST(EDef(funcName, args, null, body)));
		} else {
			statements.push(makeAST(EDefp(funcName, args, null, body)));
		};	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									var args = [];
									{
										var ` = 0;
										var ` = tfunc.args;
										while (` < `.length) {
											var arg = `[`];
											++ `;
											var paramName = reflaxe.elixir.ast.NameUtils.toSnakeCase(arg.v.name);
											args.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
										};
									};
									var functionUsageMap = if (tfunc.expr != null) {
										reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
									} else {
										null;
									};
									var body = if (tfunc.expr != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									};
									if (func.isPublic) {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, body), metadata : {}, pos : pos};
										});
									} else {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, args, null, body), metadata : {}, pos : pos};
										});
									};
								};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildApplicationBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				var funcExpr = func.expr();
				if (funcExpr != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		var args = [];
		for (arg  in  tfunc.args) {
			var paramName = NameUtils.toSnakeCase(arg.v.name);
			args.push(PVar(paramName));
		};
		var functionUsageMap = if (tfunc.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
		} else {
			null;
		};
		var body = if (tfunc.expr != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
		} else {
			makeAST(ENil);
		};
		if (func.isPublic) {
			statements.push(makeAST(EDef(funcName, args, null, body)));
		} else {
			statements.push(makeAST(EDefp(funcName, args, null, body)));
		};	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									var args = [];
									{
										var ` = 0;
										var ` = tfunc.args;
										while (` < `.length) {
											var arg = `[`];
											++ `;
											var paramName = reflaxe.elixir.ast.NameUtils.toSnakeCase(arg.v.name);
											args.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
										};
									};
									var functionUsageMap = if (tfunc.expr != null) {
										reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
									} else {
										null;
									};
									var body = if (tfunc.expr != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									};
									if (func.isPublic) {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, body), metadata : {}, pos : pos};
										});
									} else {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, args, null, body), metadata : {}, pos : pos};
										});
									};
								};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildRegularModuleBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		var hasStaticMain = false;
		{
			var ` = 0;
			var ` = classType.statics.get();
			while (` < `.length) {
				var staticField = `[`];
				++ `;
				if (staticField.name == "main") {
					hasStaticMain = true;
					break;
				};
			};
		};
		if (hasStaticMain) {};
		{
			var ` = 0;
			while (` < varFields.length) {
				var field = varFields[`];
				++ `;
				var fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
				statements.push({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EModuleAttribute(fieldName, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					}), metadata : {}, pos : pos};
				});
			};
		};
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				var funcExpr = func.expr();
				if (funcExpr != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					var functionUsageMap = @:ast(switch (funcExpr.expr) {
	case TFunction(tfunc) if (tfunc.expr != null):
		reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);	
	case _:
		null;	
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								if (tfunc.expr != null) {
									reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
					var funcAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(funcExpr, functionUsageMap);
					@:ast(switch (funcAst.def) {
	case EFn(clauses) if (clauses.length > 0):
		var clause = clauses[0];
		var args = clause.args;
		var isStatic = false;
		for (staticField  in  classType.statics.get()) {
			if (staticField.name == func.name) {
				isStatic = true;
				break;
			};
		};
		if (!isStatic && func.name != "new") {
			var thisIsUsed = switch (funcExpr.expr) {
				case TFunction(tfunc):
					reflaxe.elixir.helpers.VariableUsageAnalyzer.containsThisReference(tfunc.expr);				
				default:
					true;				
			};
			var structParamName = "struct";
			args = [EPattern.PVar(structParamName)].concat(args);
		};
		var forcePublic = (funcName == "main" && isStatic);
		if (func.isPublic || forcePublic) {
			statements.push(makeAST(EDef(funcName, args, null, clause.body)));
		} else {
			statements.push(makeAST(EDefp(funcName, args, null, clause.body)));
		};	
	case _:
}) {
						var ` = funcAst.def;
						if (enumIndex ` == 42) {
							var ` = `[0];
							{
								var clauses = `;
								if (clauses.length > 0) {
									var clause = clauses[0];
									var args = clause.args;
									var isStatic = false;
									{
										var ` = 0;
										var ` = classType.statics.get();
										while (` < `.length) {
											var staticField = `[`];
											++ `;
											if (staticField.name == func.name) {
												isStatic = true;
												break;
											};
										};
									};
									if (! isStatic && func.name != "new") {
										var thisIsUsed = @:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		reflaxe.elixir.helpers.VariableUsageAnalyzer.containsThisReference(tfunc.expr);	
	default:
		true;	
}) {
											var ` = funcExpr.expr;
											if (enumIndex ` == 12) {
												var ` = `[0];
												{
													var tfunc = `;
													{
														reflaxe.elixir.helpers.VariableUsageAnalyzer.containsThisReference(tfunc.expr);
													};
												};
											} else {
												true;
											};
										};
										var structParamName = "struct";
										args = [reflaxe.elixir.ast.EPattern.PVar(structParamName)].concat(args);
									};
									var forcePublic = (funcName == "main" && isStatic);
									if (func.isPublic || forcePublic) {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, clause.body), metadata : {}, pos : pos};
										});
									} else {
										statements.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, args, null, clause.body), metadata : {}, pos : pos};
										});
									};
								} else {};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}

	static function buildExUnitBody(classType:haxe.macro.ClassType, varFields:Array<haxe.macro.ClassField>, funcFields:Array<haxe.macro.ClassField>) {
		var statements = [];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				var funcExpr = func.expr();
				if (funcExpr != null) {
					var funcName = reflaxe.elixir.ast.NameUtils.toSnakeCase(func.name);
					var isTest = false;
					var isSetup = false;
					var isSetupAll = false;
					var isTeardown = false;
					var isTeardownAll = false;
					var describeBlock = null;
					var isAsync = false;
					var testTags = [];
					if (func.meta != null && func.meta.has != null) {
						isTest = func.meta.has(":test") || func.meta.has("test") || func.meta.has(":elixir.test");
						if (func.meta.has(":elixir.setup") || func.name == "setup") {
							isSetup = true;
						} else {
							if (func.meta.has(":elixir.setupAll") || func.name == "setupAll") {
								isSetupAll = true;
							} else {
								if (func.meta.has(":elixir.teardown") || func.name == "teardown") {
									isTeardown = true;
								} else {
									if (func.meta.has(":elixir.teardownAll") || func.name == "teardownAll") {
										isTeardownAll = true;
									};
								};
							};
						};
						if (func.meta.has(":elixir.describe")) {
							var describeMeta = func.meta.extract(":elixir.describe");
							if (describeMeta != null && describeMeta.length > 0 && describeMeta[0].params != null && describeMeta[0].params.length > 0) {
								@:ast(switch (describeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		describeBlock = s;	
	default:
}) {
									var ` = describeMeta[0].params[0].expr;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var s = `;
												{
													describeBlock = s;
												};
											};
										} else {};
									} else {};
								};
							};
						};
						if (func.meta.has(":elixir.async")) {
							isAsync = true;
						};
						if (func.meta.has(":elixir.tag")) {
							var tagMetas = func.meta.extract(":elixir.tag");
							if (tagMetas != null) {
								{
									var ` = 0;
									while (` < tagMetas.length) {
										var tagMeta = tagMetas[`];
										++ `;
										if (tagMeta.params != null && tagMeta.params.length > 0) {
											@:ast(switch (tagMeta.params[0].expr) {
	case EConst(CString(s, _)):
		testTags.push(s);	
	default:
}) {
												var ` = tagMeta.params[0].expr;
												if (enumIndex ` == 0) {
													var ` = `[0];
													if (enumIndex ` == 2) {
														var ` = `[0];
														var ` = `[1];
														{
															var s = `;
															{
																testTags.push(s);
															};
														};
													} else {};
												} else {};
											};
										};
									};
								};
							};
						};
					};
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		var args = [];
		for (arg  in  tfunc.args) {
			var paramName = NameUtils.toSnakeCase(arg.v.name);
			args.push(PVar(paramName));
		};
		var functionUsageMap = if (tfunc.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
		} else {
			null;
		};
		var body = if (tfunc.expr != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
		} else {
			makeAST(ENil);
		};
		var funcAST = if (func.isPublic) {
			makeAST(EDef(funcName, args, null, body));
		} else {
			makeAST(EDefp(funcName, args, null, body));
		};
		var metadata:Dynamic = { };
		if (isTest) metadata.isTest = true;
		if (isSetup) metadata.isSetup = true;
		if (isSetupAll) metadata.isSetupAll = true;
		if (isTeardown) metadata.isTeardown = true;
		if (isTeardownAll) metadata.isTeardownAll = true;
		if (describeBlock != null) metadata.describeBlock = describeBlock;
		if (isAsync) metadata.isAsync = true;
		if (testTags.length > 0) metadata.testTags = testTags;
		if (isTest || isSetup || isSetupAll || isTeardown || isTeardownAll || describeBlock != null || isAsync || testTags.length > 0) {
			funcAST = makeASTWithMeta(funcAST.def, metadata, funcAST.pos);
		};
		statements.push(funcAST);	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									var args = [];
									{
										var ` = 0;
										var ` = tfunc.args;
										while (` < `.length) {
											var arg = `[`];
											++ `;
											var paramName = reflaxe.elixir.ast.NameUtils.toSnakeCase(arg.v.name);
											args.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
										};
									};
									var functionUsageMap = if (tfunc.expr != null) {
										reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
									} else {
										null;
									};
									var body = if (tfunc.expr != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, functionUsageMap);
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									};
									var funcAST = if (func.isPublic) {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, body), metadata : {}, pos : pos};
										};
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, args, null, body), metadata : {}, pos : pos};
										};
									};
									var metadata = {};
									if (isTest) {
										metadata.isTest = true;
									};
									if (isSetup) {
										metadata.isSetup = true;
									};
									if (isSetupAll) {
										metadata.isSetupAll = true;
									};
									if (isTeardown) {
										metadata.isTeardown = true;
									};
									if (isTeardownAll) {
										metadata.isTeardownAll = true;
									};
									if (describeBlock != null) {
										metadata.describeBlock = describeBlock;
									};
									if (isAsync) {
										metadata.isAsync = true;
									};
									if (testTags.length > 0) {
										metadata.testTags = testTags;
									};
									if (isTest || isSetup || isSetupAll || isTeardown || isTeardownAll || describeBlock != null || isAsync || testTags.length > 0) {
										funcAST = {def : funcAST.def, metadata : cast metadata, pos : funcAST.pos};
									};
									statements.push(funcAST);
								};
							};
						} else {};
					};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
		};
	}
}