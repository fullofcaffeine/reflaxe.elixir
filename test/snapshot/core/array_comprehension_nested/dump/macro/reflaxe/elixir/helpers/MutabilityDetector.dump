@:nullSafety(Off)
class reflaxe.elixir.helpers.MutabilityDetector {

	public static function detectMutatedVariables(expr:haxe.macro.TypedExpr) {
		var mutatedVars = {
			{};
			new haxe.ds.IntMap();
		};
		reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(expr, mutatedVars);
		return mutatedVars;
	}

	public static function isVariableMutated(varId:Int, expr:haxe.macro.TypedExpr) {
		var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(expr);
		return mutatedVars.exists(varId);
	}

	static function detectMutationsRecursive(expr:haxe.macro.TypedExpr, mutatedVars:Map<Int, haxe.macro.TVar>) {
		if (expr == null) {
			return;
		};
		@:ast(switch (expr.expr) {
	case TBinop(OpAssign, e1, e2):
		switch (e1.expr) {
			case TLocal(v):
				mutatedVars.set(v.id, v);			
			default:
				detectMutationsRecursive(e1, mutatedVars);			
		};
		detectMutationsRecursive(e2, mutatedVars);	
	case TBinop(OpAssignOp(_), e1, e2):
		switch (e1.expr) {
			case TLocal(v):
				mutatedVars.set(v.id, v);			
			default:
				detectMutationsRecursive(e1, mutatedVars);			
		};
		detectMutationsRecursive(e2, mutatedVars);	
	case TUnop(OpIncrement | OpDecrement, _, e):
		switch (e.expr) {
			case TLocal(v):
				mutatedVars.set(v.id, v);			
			default:
				detectMutationsRecursive(e, mutatedVars);			
		};	
	case TCall(e, el):
		detectMutationsRecursive(e, mutatedVars);
		for (arg  in  el) {
			detectMutationsRecursive(arg, mutatedVars);
		};	
	case TBlock(el):
		for (e  in  el) {
			detectMutationsRecursive(e, mutatedVars);
		};	
	case TIf(econd, eif, eelse):
		detectMutationsRecursive(econd, mutatedVars);
		detectMutationsRecursive(eif, mutatedVars);
		if (eelse != null) {
			detectMutationsRecursive(eelse, mutatedVars);
		};	
	case TSwitch(e, cases, edef):
		detectMutationsRecursive(e, mutatedVars);
		for (c  in  cases) {
			for (v  in  c.values) {
				detectMutationsRecursive(v, mutatedVars);
			};
			detectMutationsRecursive(c.expr, mutatedVars);
		};
		if (edef != null) {
			detectMutationsRecursive(edef, mutatedVars);
		};	
	case TWhile(econd, e, _):
		detectMutationsRecursive(econd, mutatedVars);
		detectMutationsRecursive(e, mutatedVars);	
	case TFor(v, e1, e2):
		detectMutationsRecursive(e1, mutatedVars);
		detectMutationsRecursive(e2, mutatedVars);	
	case TTry(e, catches):
		detectMutationsRecursive(e, mutatedVars);
		for (c  in  catches) {
			detectMutationsRecursive(c.expr, mutatedVars);
		};	
	case TVar(v, expr):
		if (expr != null) {
			detectMutationsRecursive(expr, mutatedVars);
		};	
	case TReturn(e):
		if (e != null) {
			detectMutationsRecursive(e, mutatedVars);
		};	
	case TThrow(e):
		detectMutationsRecursive(e, mutatedVars);	
	case TArrayDecl(el):
		for (e  in  el) {
			detectMutationsRecursive(e, mutatedVars);
		};	
	case TObjectDecl(fields):
		for (f  in  fields) {
			detectMutationsRecursive(f.expr, mutatedVars);
		};	
	case TFunction(tfunc):
		if (tfunc.expr != null) {
			detectMutationsRecursive(tfunc.expr, mutatedVars);
		};	
	case TField(e, _):
		detectMutationsRecursive(e, mutatedVars);	
	case TParenthesis(e):
		detectMutationsRecursive(e, mutatedVars);	
	case TCast(e, _):
		detectMutationsRecursive(e, mutatedVars);	
	case TMeta(_, e):
		detectMutationsRecursive(e, mutatedVars);	
	case TContinue | TBreak:
	case TLocal(_) | TIdent(_) | TConst(_):
	case TNew(_, _, el):
		for (e  in  el) {
			detectMutationsRecursive(e, mutatedVars);
		};	
	case TEnumParameter(e, _, _):
		detectMutationsRecursive(e, mutatedVars);	
	case TEnumIndex(e):
		detectMutationsRecursive(e, mutatedVars);	
	case TBinop(_, e1, e2):
		detectMutationsRecursive(e1, mutatedVars);
		detectMutationsRecursive(e2, mutatedVars);	
	case TUnop(_, _, e):
		detectMutationsRecursive(e, mutatedVars);	
	case TArray(e1, e2):
		detectMutationsRecursive(e1, mutatedVars);
		detectMutationsRecursive(e2, mutatedVars);	
	case TTypeExpr(_):
}) {
			var ` = expr.expr;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					{};
				};
				case 1: {
					var ` = `[0];
					{};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e1, mutatedVars);
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e2, mutatedVars);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								var e1 = `;
								var e2 = `;
								{
									@:ast(switch (e1.expr) {
	case TLocal(v):
		mutatedVars.set(v.id, v);	
	default:
		detectMutationsRecursive(e1, mutatedVars);	
}) {
										var ` = e1.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													{
														var key = v.id;
														mutatedVars.set(key, v);
													};
												};
											};
										} else {
											reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e1, mutatedVars);
										};
									};
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e2, mutatedVars);
								};
							};
						};
						case 20: {
							var ` = `[0];
							{
								var e1 = `;
								var e2 = `;
								{
									@:ast(switch (e1.expr) {
	case TLocal(v):
		mutatedVars.set(v.id, v);	
	default:
		detectMutationsRecursive(e1, mutatedVars);	
}) {
										var ` = e1.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													{
														var key = v.id;
														mutatedVars.set(key, v);
													};
												};
											};
										} else {
											reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e1, mutatedVars);
										};
									};
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e2, mutatedVars);
								};
							};
						};
						default: {
							var e1 = `;
							var e2 = `;
							{
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e1, mutatedVars);
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e2, mutatedVars);
							};
						}
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 5: {
					var ` = `[0];
					{};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(f.expr, mutatedVars);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
								};
							};
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
							{
								var ` = 0;
								while (` < el.length) {
									var arg = el[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(arg, mutatedVars);
								};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
								};
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								var e = `;
								{
									@:ast(switch (e.expr) {
	case TLocal(v):
		mutatedVars.set(v.id, v);	
	default:
		detectMutationsRecursive(e, mutatedVars);	
}) {
										var ` = e.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													{
														var key = v.id;
														mutatedVars.set(key, v);
													};
												};
											};
										} else {
											reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
										};
									};
								};
							};
						};
						default: {
							var e = `;
							{
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
							};
						}
					};
				};
				case 12: {
					var ` = `[0];
					{
						var tfunc = `;
						{
							if (tfunc.expr != null) {
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(tfunc.expr, mutatedVars);
							};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var expr = `;
						{
							if (expr != null) {
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(expr, mutatedVars);
							};
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
								};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var v = `;
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e1, mutatedVars);
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e2, mutatedVars);
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(econd, mutatedVars);
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(eif, mutatedVars);
							if (eelse != null) {
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(eelse, mutatedVars);
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(econd, mutatedVars);
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var cases = `;
						var edef = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									{
										var ` = 0;
										var ` = c.values;
										while (` < `.length) {
											var v = `[`];
											++ `;
											reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(v, mutatedVars);
										};
									};
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(c.expr, mutatedVars);
								};
							};
							if (edef != null) {
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(edef, mutatedVars);
							};
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
							{
								var ` = 0;
								while (` < catches.length) {
									var c = catches[`];
									++ `;
									reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(c.expr, mutatedVars);
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var e = `;
						{
							if (e != null) {
								reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
							};
						};
					};
				};
				case 21, 22: {
					{};
				};
				case 23: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.helpers.MutabilityDetector.detectMutationsRecursive(e, mutatedVars);
						};
					};
				};
				case 28: {
					var ` = `[0];
					{};
				};
			};
		};
	}

	public static function extractAccumulatorVariables(expr:haxe.macro.TypedExpr, mutatedVars:Map<Int, haxe.macro.TVar>) {
		var result = [];
		for (v in mutatedVars.iterator()) {
			result.push(v);
		};
		return result;
	}
}