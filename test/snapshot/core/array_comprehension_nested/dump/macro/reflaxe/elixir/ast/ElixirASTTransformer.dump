class reflaxe.elixir.ast.ElixirASTTransformer {

	public static function transform(ast:reflaxe.elixir.ast.ElixirAST) {
		var passes = reflaxe.elixir.ast.ElixirASTTransformer.getEnabledPasses();
		var result = ast;
		{
			var ` = 0;
			while (` < passes.length) {
				var passConfig = passes[`];
				++ `;
				result = passConfig.pass(result);
			};
		};
		return result;
	}

	static function getEnabledPasses() {
		var passes = [];
		passes.push({name : "Identity", description : "Pass-through transformation (no changes)", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.identityPass});
		passes.push({name : "ResolveClauseLocals", description : "Resolve variable references in case clauses using varIdToName metadata", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.resolveClauseLocalsPass});
		passes.push({name : "ThrowStatementTransform", description : "Transform complex throw expressions to avoid syntax errors", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.throwStatementTransformPass});
		passes.push({name : "InlineMethodCallCombiner", description : "Combine split inline expansion patterns from stdlib", enabled : true, pass : reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass});
		passes.push({name : "FunctionReferenceTransform", description : "Transform function references to use capture operator (&Module.func/arity)", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.functionReferenceTransformPass});
		passes.push({name : "BitwiseImport", description : "Add Bitwise import when bitwise operators are used", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.bitwiseImportPass});
		passes.push({name : "InlineTempBindingInExpr", description : "Collapse EBlock([tmp = exprA, exprB(tmp)]) to exprB(exprA) in expression positions", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.inlineTempBindingInExprPass});
		passes.push({name : "XRayMapBlocks", description : "Debug pass to log map fields containing EBlock values", enabled : false, pass : function(ast:reflaxe.elixir.ast.ElixirAST) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
				@:ast(switch (node.def) {
	case EMap(pairs):
		for (p  in  pairs) {
			switch (p.value.def) {
				case EBlock(exprs):
					trace("[XRayMapBlocks] Found EBlock in map value with " + exprs.length + " exprs");
					for (i  in  0 ... exprs.length) trace("  expr[" + i + "]: " + ElixirASTPrinter.print(exprs[i], 0));				
				default:
			};
		};
		return node;	
	default:
		return node;	
}) {
					var ` = node.def;
					if (enumIndex ` == 17) {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										@:ast(switch (p.value.def) {
	case EBlock(exprs):
		trace("[XRayMapBlocks] Found EBlock in map value with " + exprs.length + " exprs");
		for (i  in  0 ... exprs.length) trace("  expr[" + i + "]: " + ElixirASTPrinter.print(exprs[i], 0));	
	default:
}) {
											var ` = p.value.def;
											if (enumIndex ` == 53) {
												var ` = `[0];
												{
													var exprs = `;
													{
														haxe.Log.trace("[XRayMapBlocks] Found EBlock in map value with " + exprs.length + " exprs", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTTransformer.hx", lineNumber : 173, className : "reflaxe.elixir.ast.ElixirASTTransformer", methodName : "getEnabledPasses"});
														{
															var ` = 0;
															var ` = exprs.length;
															while (` < `) {
																var i = ` ++;
																haxe.Log.trace("  expr[" + i + "]: " + reflaxe.elixir.ast.ElixirASTPrinter.print(exprs[i], 0), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTTransformer.hx", lineNumber : 174, className : "reflaxe.elixir.ast.ElixirASTTransformer", methodName : "getEnabledPasses"});
															};
														};
													};
												};
											} else {};
										};
									};
								};
								return node;
							};
						};
					} else {
						return node;
					};
				};
			});
		}});
		passes.push({name : "PhoenixWebTransform", description : "Transform @:phoenixWeb modules into Phoenix Web helper module", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.phoenixWebTransformPass});
		passes.push({name : "EndpointTransform", description : "Transform @:endpoint modules into Phoenix.Endpoint structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.endpointTransformPass});
		passes.push({name : "LiveViewTransform", description : "Transform @:liveview modules into Phoenix.LiveView structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.liveViewTransformPass});
		passes.push({name : "PresenceTransform", description : "Transform @:presence modules into Phoenix.Presence structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.presenceTransformPass});
		passes.push({name : "PhoenixComponentImport", description : "Add Phoenix.Component import when ~H sigil is used (unless LiveView already includes it)", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.phoenixComponentImportPass});
		passes.push({name : "LiveViewCoreComponentsImport", description : "Add CoreComponents import for LiveView modules that use components", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.liveViewCoreComponentsImportPass});
		passes.push({name : "PhoenixFunctionMapping", description : "Map custom function names to Phoenix conventions", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.phoenixFunctionMappingPass});
		passes.push({name : "ControllerTransform", description : "Transform @:controller modules into Phoenix.Controller structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.controllerTransformPass});
		passes.push({name : "RouterTransform", description : "Transform @:router modules into Phoenix.Router structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.routerTransformPass});
		passes.push({name : "SchemaTransform", description : "Transform @:schema modules into Ecto.Schema structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.schemaTransformPass});
		passes.push({name : "RepoTransform", description : "Transform @:repo modules into Ecto.Repo structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.repoTransformPass});
		passes.push({name : "PostgrexTypesTransform", description : "Transform @:postgrexTypes modules into Postgrex types definition", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.postgrexTypesTransformPass});
		passes.push({name : "DbTypesTransform", description : "Transform @:dbTypes modules into DB adapter types definition", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.dbTypesTransformPass});
		passes.push({name : "ApplicationTransform", description : "Transform @:application modules into OTP Application structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.applicationTransformPass});
		passes.push({name : "ExUnitTransform", description : "Transform @:exunit modules into ExUnit.Case test structure", enabled : true, pass : reflaxe.elixir.ast.transformers.AnnotationTransforms.exunitTransformPass});
		passes.push({name : "ConstantFolding", description : "Fold constant expressions at compile time", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.constantFoldingPass});
		passes.push({name : "ConditionalReassignment", description : "Convert conditional reassignments to functional style", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.conditionalReassignmentPass});
		passes.push({name : "RemoveRedundantNilInit", description : "Remove redundant nil initialization when variable is immediately reassigned", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass});
		passes.push({name : "StringMethodTransform", description : "Convert string method calls to String module calls", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.stringMethodTransformPass});
		passes.push({name : "PipelineOptimization", description : "Convert sequential operations to pipeline", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.pipelineOptimizationPass});
		passes.push({name : "ComprehensionConversion", description : "Convert imperative loops to comprehensions", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.comprehensionConversionPass});
		passes.push({name : "ListEffectLifting", description : "Lift side-effecting expressions out of list literals", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.listEffectLiftingPass});
		passes.push({name : "ImmutabilityTransform", description : "Convert mutable patterns to immutable", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.immutabilityTransformPass});
		passes.push({name : "NullCoalescingInline", description : "Convert null coalescing blocks to inline expressions", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.nullCoalescingInlinePass});
		passes.push({name : "StatementContextTransform", description : "Add reassignments for immutable operations in statement context", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.statementContextTransformPass});
		passes.unshift({name : "SelfReferenceTransform", description : "Convert self/this references to struct parameter", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.selfReferenceTransformPass});
		passes.push({name : "StructFieldAssignmentTransform", description : "Convert struct field assignments to struct update syntax", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.structFieldAssignmentTransformPass});
		passes.push({name : "AssignmentExtraction", description : "Extract assignments from binary operations and other expression contexts", enabled : true, pass : reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.assignmentExtractionPass});
		passes.push({name : "ReduceWhileAccumulator", description : "Fix variable shadowing in reduce_while loops by proper accumulator threading", enabled : true, pass : reflaxe.elixir.ast.transformers.ReduceWhileAccumulatorTransform.reduceWhileAccumulatorPass});
		passes.push({name : "StructUpdateTransform", description : "Transform instance field assignments to avoid unused variable warnings", enabled : true, pass : reflaxe.elixir.ast.transformers.StructUpdateTransform.structUpdateTransformPass});
		passes.push({name : "ArrayLengthFieldToFunction", description : "Transform array.length field access to length(array) function calls", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass});
		passes.push({name : "TupleElemFieldToFunction", description : "Transform tuple.elem field access to elem(tuple, index) function calls", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass});
		passes.push({name : "IdiomaticEnumPatternMatching", description : "Transform enum tuple access patterns to idiomatic pattern matching", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass});
		passes.push({name : "UnderscoreVariableCleanup", description : "Remove underscore prefix from used temporary variables", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.underscoreVariableCleanupPass});
		passes.push({name : "AbstractMethodThis", description : "Fix 'this' references in abstract methods", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.abstractMethodThisPass});
		passes.push({name : "SupervisorOptionsTransform", description : "Convert supervisor option maps to keyword lists", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.supervisorOptionsTransformPass});
		passes.push({name : "OTPChildSpecTransform", description : "Convert enum-based child specs to proper OTP child specifications", enabled : true, pass : reflaxe.elixir.ast.ElixirASTTransformer.otpChildSpecTransformPass});
		passes.push({name : "HygienicNaming", description : "Eliminate variable shadowing with scope-aware renaming", enabled : false, pass : reflaxe.elixir.ast.transformers.HygieneTransforms.hygienicNamingPass});
		passes.push({name : "UsageAnalysis", description : "Detect and mark unused variables with underscore prefix", enabled : true, pass : reflaxe.elixir.ast.transformers.HygieneTransforms.usageAnalysisPass});
		passes.push({name : "AtomNormalization", description : "Remove unnecessary quotes from atoms", enabled : false, pass : reflaxe.elixir.ast.transformers.HygieneTransforms.atomNormalizationPass});
		passes.push({name : "EqualityToPattern", description : "Transform == comparisons to pattern matching", enabled : false, pass : reflaxe.elixir.ast.transformers.HygieneTransforms.equalityToPatternPass});
		return {
			var ` = [];
			{
				var ` = 0;
				var ` = passes;
				while (` < `.length) {
					var v = `[`];
					++ `;
					if (function(p:reflaxe.elixir.ast.PassConfig) {
						return p.enabled;
					}(v)) {
						`.push(v);
					};
				};
			};
			`;
		};
	}

	static function inlineTempBindingInExprPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var replaceVar = function(node:reflaxe.elixir.ast.ElixirAST, name:String, replacement:reflaxe.elixir.ast.ElixirAST) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case EVar(v) if (v == name):
		makeAST(EParen(replacement));	
	case _:
		n;	
}) {
					var ` = n.def;
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var v = `;
							if (v == name) {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EParen(replacement), metadata : {}, pos : pos};
								};
							} else {
								n;
							};
						};
					} else {
						n;
					};
				};
			});
		};
		var containsVar = function(node:reflaxe.elixir.ast.ElixirAST, varName:String) {
			var found = [false];
			reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				@:ast(switch (n.def) {
	case EVar(v) if (v == varName):
		found = true;	
	default:
}) {
					var ` = n.def;
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var v = `;
							if (v == varName) {
								found[0] = true;
							} else {};
						};
					} else {};
				};
			});
			return found[0];
		};
		var isInExpressionContext = function(parent:reflaxe.elixir.ast.ElixirAST, child:reflaxe.elixir.ast.ElixirAST) {
			if (parent == null) {
				return false;
			};
			return @:ast(switch (parent.def) {
	case EMap(pairs):
		true;	
	case EKeywordList(pairs):
		true;	
	case ECall(_, _, _):
		true;	
	case EBinary(_, _, _):
		true;	
	case EUnary(_, _):
		true;	
	case EParen(_):
		true;	
	case EList(_):
		true;	
	case ETuple(_):
		true;	
	case EMatch(_, _):
		true;	
	case ECase(_, clauses):
		false;	
	case EDef(_, _, _, _):
		false;	
	case EDefp(_, _, _, _):
		false;	
	case EDefmodule(_, _):
		false;	
	case EBlock(_):
		false;	
	case EIf(_, _, _):
		false;	
	case ECond(clauses):
		false;	
	default:
		false;	
}) {
				var ` = parent.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							false;
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							false;
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							false;
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var clauses = `;
							{
								false;
							};
						};
					};
					case 7: {
						var ` = `[0];
						{
							var clauses = `;
							{
								false;
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							true;
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							false;
						};
					};
					case 15: {
						var ` = `[0];
						{
							true;
						};
					};
					case 16: {
						var ` = `[0];
						{
							true;
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								true;
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								true;
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							true;
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							true;
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							true;
						};
					};
					case 53: {
						var ` = `[0];
						{
							false;
						};
					};
					case 54: {
						var ` = `[0];
						{
							true;
						};
					};
					default: {
						false;
					}
				};
			};
		};
		var parentOf = new haxe.ds.ObjectMap();
		var walk = [null];
		walk[0] = function(node:reflaxe.elixir.ast.ElixirAST, parent:Null<reflaxe.elixir.ast.ElixirAST>) {
			if (node == null) {
				return;
			};
			if (parent != null) {
				parentOf.set(node, parent);
			};
			@:ast(switch (node.def) {
	case EBlock(exprs):
		for (e  in  exprs) walk(e, node);	
	case ECall(target, method, args):
		walk(target, node);
		for (a  in  args) walk(a, node);	
	case EMap(pairs):
		for (p  in  pairs) walk(p.value, node);	
	case EKeywordList(pairs):
		for (p  in  pairs) walk(p.value, node);	
	case ETuple(values):
		for (v  in  values) walk(v, node);	
	case EList(items):
		for (i  in  items) walk(i, node);	
	case EBinary(op, left, right):
		walk(left, node);
		walk(right, node);	
	case EUnary(op, expr):
		walk(expr, node);	
	case ECase(expr, clauses):
		walk(expr, node);
		for (c  in  clauses) {
			if (c.guard != null) walk(c.guard, node);
			walk(c.body, node);
		};	
	case EIf(cond, thenB, elseB):
		walk(cond, node);
		walk(thenB, node);
		if (elseB != null) walk(elseB, node);	
	case ECond(clauses):
		for (c  in  clauses) {
			walk(c.condition, node);
			walk(c.body, node);
		};	
	case EDef(name, args, guards, body):
		if (guards != null) walk(guards, node);
		walk(body, node);	
	case EDefp(name, args, guards, body):
		if (guards != null) walk(guards, node);
		walk(body, node);	
	case EDefmodule(name, body):
		walk(body, node);	
	case EAssign(name):
	case EParen(expr):
		walk(expr, node);	
	case EMatch(pattern, expr):
		walk(expr, node);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var body = `;
							{
								walk[0](body, node);
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								if (guards != null) {
									walk[0](guards, node);
								};
								walk[0](body, node);
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								if (guards != null) {
									walk[0](guards, node);
								};
								walk[0](body, node);
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								walk[0](expr, node);
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										if (c.guard != null) {
											walk[0](c.guard, node);
										};
										walk[0](c.body, node);
									};
								};
							};
						};
					};
					case 7: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										walk[0](c.condition, node);
										walk[0](c.body, node);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenB = `;
							var elseB = `;
							{
								walk[0](cond, node);
								walk[0](thenB, node);
								if (elseB != null) {
									walk[0](elseB, node);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var items = `;
							{
								{
									var ` = 0;
									while (` < items.length) {
										var i = items[`];
										++ `;
										walk[0](i, node);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var values = `;
							{
								{
									var ` = 0;
									while (` < values.length) {
										var v = values[`];
										++ `;
										walk[0](v, node);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										walk[0](p.value, node);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										walk[0](p.value, node);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var method = `;
							var args = `;
							{
								walk[0](target, node);
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										walk[0](a, node);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								walk[0](left, node);
								walk[0](right, node);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										walk[0](e, node);
									};
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 63: {
						var ` = `[0];
						{
							var name = `;
							{};
						};
					};
					default: {}
				};
			};
		};
		walk[0](ast, null);
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			var parent = if (parentOf.exists(node)) {
				parentOf.get(node);
			} else {
				null;
			};
			var inExpr = parent != null && isInExpressionContext(parent, node);
			var shouldCollapse = @:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length == 2):
		inExpr;	
	default:
		false;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length == 2) {
							inExpr;
						} else {
							false;
						};
					};
				} else {
					false;
				};
			};
			if (! shouldCollapse) {
				return node;
			};
			@:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length == 2):
		switch (exprs[0].def) {
			case EMatch(PVar(tmp), bindExpr):
				var second = exprs[1];
				if (containsVar(second, tmp)) {
					var collapsed = replaceVar(second, tmp, bindExpr);
					return collapsed;
				};			
			default:
		};	
	default:
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length == 2) {
							@:ast(switch (exprs[0].def) {
	case EMatch(PVar(tmp), bindExpr):
		var second = exprs[1];
		if (containsVar(second, tmp)) {
			var collapsed = replaceVar(second, tmp, bindExpr);
			return collapsed;
		};	
	default:
}) {
								var ` = exprs[0].def;
								if (enumIndex ` == 8) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										{
											var tmp = `;
											var bindExpr = `;
											{
												var second = exprs[1];
												if (containsVar(second, tmp)) {
													var collapsed = replaceVar(second, tmp, bindExpr);
													return collapsed;
												};
											};
										};
									} else {};
								} else {};
							};
						} else {};
					};
				} else {};
			};
			return node;
		});
	}

	static function throwStatementTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EThrow(value):
		var transformedValue = transformThrowValue(value);
		{ def : EThrow(transformedValue), metadata : ast.metadata, pos : ast.pos };	
	default:
		transformAST(ast, throwStatementTransformPass);	
}) {
			var ` = ast.def;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var value = `;
					{
						var transformedValue = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(value);
						{def : reflaxe.elixir.ast.ElixirASTDef.EThrow(transformedValue), metadata : ast.metadata, pos : ast.pos};
					};
				};
			} else {
				reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.throwStatementTransformPass);
			};
		};
	}

	static function transformThrowValue(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EBinary(StringConcat, left, right):
		var leftTransformed = transformThrowValue(left);
		var rightTransformed = transformThrowValue(right);
		var rightWrapped = switch (rightTransformed.def) {
			case EIf(_, _, _):
				{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };			
			case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
				{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };			
			default:
				rightTransformed;			
		};
		{ def : EBinary(StringConcat, leftTransformed, rightWrapped), metadata : expr.metadata, pos : expr.pos };	
	case EIf(cond, then, els):
		{ def : EParen(expr), metadata : expr.metadata, pos : expr.pos };	
	default:
		expr;	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var then = `;
						var els = `;
						{
							{def : reflaxe.elixir.ast.ElixirASTDef.EParen(expr), metadata : expr.metadata, pos : expr.pos};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								var leftTransformed = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(left);
								var rightTransformed = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(right);
								var rightWrapped = @:ast(switch (rightTransformed.def) {
	case EIf(_, _, _):
		{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };	
	case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
		{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };	
	default:
		rightTransformed;	
}) {
									var ` = rightTransformed.def;
									switch (enumIndex `) {
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												{def : reflaxe.elixir.ast.ElixirASTDef.EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos};
											};
										};
										case 22: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (reflaxe.elixir.ast.ElixirASTTransformer.hasConditionalInCall(rightTransformed)) {
												{def : reflaxe.elixir.ast.ElixirASTDef.EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos};
											} else {
												rightTransformed;
											};
										};
										default: {
											rightTransformed;
										}
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.StringConcat, leftTransformed, rightWrapped), metadata : expr.metadata, pos : expr.pos};
							};
						};
					} else {
						expr;
					};
				};
				default: {
					expr;
				}
			};
		};
	}

	static function hasConditionalInCall(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case ECall(_, _, args):
		Lambda.exists(args, function(arg) {
			return switch (arg.def) {
				case EIf(_, _, _):
					true;				
				default:
					false;				
			};
		});	
	default:
		false;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 22) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var args = `;
					{
						Lambda.exists(args, function(arg:reflaxe.elixir.ast.ElixirAST) {
							return @:ast(switch (arg.def) {
	case EIf(_, _, _):
		true;	
	default:
		false;	
}) {
								var ` = arg.def;
								if (enumIndex ` == 10) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										true;
									};
								} else {
									false;
								};
							};
						});
					};
				};
			} else {
				false;
			};
		};
	}

	static function identityPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return ast;
	}

	static function resolveClauseLocalsPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node.metadata != null && node.metadata.varIdToName != null) {
				var varIdToName = node.metadata.varIdToName;
				return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(inner:reflaxe.elixir.ast.ElixirAST) {
					@:ast(switch (inner.def) {
	case EVar(currentName):
		if (inner.metadata != null && inner.metadata.sourceVarId != null) {
			var sourceId = inner.metadata.sourceVarId;
			if (varIdToName.exists(sourceId)) {
				var newName = varIdToName.get(sourceId);
				return makeASTWithMeta(EVar(newName), inner.metadata, inner.pos);
			};
		};
		return inner;	
	default:
		return inner;	
}) {
						var ` = inner.def;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var currentName = `;
								{
									if (inner.metadata != null && inner.metadata.sourceVarId != null) {
										var sourceId = inner.metadata.sourceVarId;
										if (varIdToName.exists(sourceId)) {
											var newName = cast varIdToName.get(sourceId);
											return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(newName), metadata : inner.metadata, pos : inner.pos};
										};
									};
									return inner;
								};
							};
						} else {
							return inner;
						};
					};
				});
			};
			return node;
		});
	}

	static function functionReferenceTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EField(target, field):
		if (field.indexOf("__FUNC_REF__") != -1) {
			var parts = field.split("__FUNC_REF__");
			var actualField = parts[0];
			var arity = parts.length > 1 ? Std.parseInt(parts[1]) : 0;
			if (arity == null) arity = 0;
			var cleanField = makeAST(EField(target, actualField));
			return makeAST(ECapture(cleanField, arity));
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 28) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var field = `;
						{
							if (field.indexOf("__FUNC_REF__", null) != -1) {
								var parts = field.split("__FUNC_REF__");
								var actualField = parts[0];
								var arity = if (parts.length > 1) {
									Std.parseInt(parts[1]);
								} else {
									0;
								};
								if (arity == null) {
									arity = 0;
								};
								var cleanField = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EField(target, actualField), metadata : {}, pos : pos};
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ECapture(cleanField, arity), metadata : {}, pos : pos};
								};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function nullCoalescingInlinePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EMatch(PVar(name), value) if (value != null):
		switch (value.def) {
			case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
				switch (assign.def) {
					case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
						switch (ifExpr.def) {
							case EIf(condition, thenBranch, elseBranch):
								switch (condition.def) {
									case EBinary(NotEqual, tmpVar, nilExpr):
										switch (tmpVar.def) {
											case EVar(checkName) if (checkName == tmpName):
												var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
												var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
												makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));											
											default:
												node;											
										};									
									default:
										node;									
								};							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 8) {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var name = `;
							var value = `;
							if (value != null) {
								@:ast(switch (value.def) {
	case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
		switch (assign.def) {
			case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
				switch (ifExpr.def) {
					case EIf(condition, thenBranch, elseBranch):
						switch (condition.def) {
							case EBinary(NotEqual, tmpVar, nilExpr):
								switch (tmpVar.def) {
									case EVar(checkName) if (checkName == tmpName):
										var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
										var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
										makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));									
									default:
										node;									
								};							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
									var ` = value.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var assign = `;
												var ifExpr = `;
												if (assign != null && ifExpr != null) {
													@:ast(switch (assign.def) {
	case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
		switch (ifExpr.def) {
			case EIf(condition, thenBranch, elseBranch):
				switch (condition.def) {
					case EBinary(NotEqual, tmpVar, nilExpr):
						switch (tmpVar.def) {
							case EVar(checkName) if (checkName == tmpName):
								var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
								var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
								makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
														var ` = assign.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var tmpName = `;
																	var expr = `;
																	if (tmpName != null && tmpName.indexOf("tmp", null) >= 0) {
																		@:ast(switch (ifExpr.def) {
	case EIf(condition, thenBranch, elseBranch):
		switch (condition.def) {
			case EBinary(NotEqual, tmpVar, nilExpr):
				switch (tmpVar.def) {
					case EVar(checkName) if (checkName == tmpName):
						var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
						var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
						makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
																			var ` = ifExpr.def;
																			if (enumIndex ` == 10) {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var condition = `;
																					var thenBranch = `;
																					var elseBranch = `;
																					{
																						@:ast(switch (condition.def) {
	case EBinary(NotEqual, tmpVar, nilExpr):
		switch (tmpVar.def) {
			case EVar(checkName) if (checkName == tmpName):
				var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
				var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
				makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));			
			default:
				node;			
		};	
	default:
		node;	
}) {
																							var ` = condition.def;
																							if (enumIndex ` == 26) {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 7) {
																									{
																										var tmpVar = `;
																										var nilExpr = `;
																										{
																											@:ast(switch (tmpVar.def) {
	case EVar(checkName) if (checkName == tmpName):
		var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
		var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
		makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));	
	default:
		node;	
}) {
																												var ` = tmpVar.def;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var checkName = `;
																														if (checkName == tmpName) {
																															var assignExpr = {
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpName), expr), metadata : {}, pos : pos};
																															};
																															var inlineCondition = {
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.EParen(assignExpr), metadata : {}, pos : pos};
																																}, {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																																}), metadata : {}, pos : pos};
																															};
																															{
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.EIf(inlineCondition, thenBranch, elseBranch), metadata : {}, pos : pos};
																																}), metadata : {}, pos : pos};
																															};
																														} else {
																															node;
																														};
																													};
																												} else {
																													node;
																												};
																											};
																										};
																									};
																								} else {
																									node;
																								};
																							} else {
																								node;
																							};
																						};
																					};
																				};
																			} else {
																				node;
																			};
																		};
																	} else {
																		node;
																	};
																};
															} else {
																node;
															};
														} else {
															node;
														};
													};
												} else {
													node;
												};
											};
										} else {
											node;
										};
									} else {
										node;
									};
								};
							} else {
								node;
							};
						};
					} else {
						node;
					};
				} else {
					node;
				};
			};
		});
	}

	static function selfReferenceTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EField(target, fieldName):
		switch (target.def) {
			case EVar("self"):
				makeAST(EField(makeAST(EVar("struct")), fieldName));			
			case EVar("super"):
				var parentModule = extractParentModule(node);
				if (parentModule != null) {
					var elixirMethodName = toSnakeCase(fieldName);
					makeAST(ECall(makeAST(EVar(parentModule)), elixirMethodName, [makeAST(EVar("struct"))]));
				} else {
					makeAST(ECall(null, toSnakeCase(fieldName), [makeAST(EVar("struct"))]));
				};			
			default:
				node;			
		};	
	case EVar("self"):
		makeAST(EVar("struct"));	
	case EVar("super"):
		makeAST(ENil);	
	case ECall(target, funcName, args):
		if (funcName == "__super__") {
			makeAST(ENil);
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var funcName = `;
							var args = `;
							{
								if (funcName == "__super__") {
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									};
								} else {
									node;
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var fieldName = `;
							{
								@:ast(switch (target.def) {
	case EVar("self"):
		makeAST(EField(makeAST(EVar("struct")), fieldName));	
	case EVar("super"):
		var parentModule = extractParentModule(node);
		if (parentModule != null) {
			var elixirMethodName = toSnakeCase(fieldName);
			makeAST(ECall(makeAST(EVar(parentModule)), elixirMethodName, [makeAST(EVar("struct"))]));
		} else {
			makeAST(ECall(null, toSnakeCase(fieldName), [makeAST(EVar("struct"))]));
		};	
	default:
		node;	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										switch (`) {
											case "self": {
												{
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EField({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
														}, fieldName), metadata : {}, pos : pos};
													};
												};
											};
											case "super": {
												{
													var parentModule = reflaxe.elixir.ast.ElixirASTTransformer.extractParentModule(node);
													if (parentModule != null) {
														var elixirMethodName = reflaxe.elixir.ast.ElixirASTTransformer.toSnakeCase(fieldName);
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar(parentModule), metadata : {}, pos : pos};
															}, elixirMethodName, [{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
															}]), metadata : {}, pos : pos};
														};
													} else {
														{
															var def = reflaxe.elixir.ast.ElixirASTDef.ECall(null, reflaxe.elixir.ast.ElixirASTTransformer.toSnakeCase(fieldName), [{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
															}]);
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														};
													};
												};
											};
											default: {
												node;
											}
										};
									} else {
										node;
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						switch (`) {
							case "self": {
								{
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
									};
								};
							};
							case "super": {
								{
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									};
								};
							};
							default: {
								node;
							}
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function phoenixComponentImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsPhoenixComponent = [false];
		var checkForHSigil = [null];
		checkForHSigil[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ESigil(type, _, _):
		if (type == "H") {
			needsPhoenixComponent = true;
		};	
	default:
		iterateAST(node, checkForHSigil);	
}) {
				var ` = node.def;
				if (enumIndex ` == 61) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var type = `;
						{
							if (type == "H") {
								needsPhoenixComponent[0] = true;
							};
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForHSigil[0]);
				};
			};
		};
		checkForHSigil[0](ast);
		if (! needsPhoenixComponent[0]) {
			return ast;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				var hasLiveViewUse = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == "Phoenix.Component") {
								hasImport = true;
								break;
							};						
						case EUse(module, opts):
							if (module == "Phoenix.Component") {
								hasImport = true;
								break;
							};
							if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
								for (opt  in  opts) {
									switch (opt.def) {
										case EAtom(atom) if (atom == "live_view"):
											hasLiveViewUse = true;
											hasImport = true;
											break;										
										default:
									};
								};
							};						
						default:
					};
				};
				if (hasLiveViewUse) {
					return node;
				};
				if (!hasImport) {
					var importStmt = makeAST(EUse("Phoenix.Component", []));
					var newStatements = [importStmt].concat(statements);
					var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
					return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
				};
				return node;			
			default:
				var importStmt = makeAST(EUse("Phoenix.Component", []));
				var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
				return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);			
		};	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 1) {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		var hasLiveViewUse = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == "Phoenix.Component") {
						hasImport = true;
						break;
					};				
				case EUse(module, opts):
					if (module == "Phoenix.Component") {
						hasImport = true;
						break;
					};
					if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
						for (opt  in  opts) {
							switch (opt.def) {
								case EAtom(atom) if (atom == "live_view"):
									hasLiveViewUse = true;
									hasImport = true;
									break;								
								default:
							};
						};
					};				
				default:
			};
		};
		if (hasLiveViewUse) {
			return node;
		};
		if (!hasImport) {
			var importStmt = makeAST(EUse("Phoenix.Component", []));
			var newStatements = [importStmt].concat(statements);
			var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
			return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
		};
		return node;	
	default:
		var importStmt = makeAST(EUse("Phoenix.Component", []));
		var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
		return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);	
}) {
								var ` = doBlock.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var statements = `;
										{
											var hasImport = false;
											var hasLiveViewUse = false;
											{
												var ` = 0;
												while (` < statements.length) {
													var stmt = statements[`];
													++ `;
													@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == "Phoenix.Component") {
			hasImport = true;
			break;
		};	
	case EUse(module, opts):
		if (module == "Phoenix.Component") {
			hasImport = true;
			break;
		};
		if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
			for (opt  in  opts) {
				switch (opt.def) {
					case EAtom(atom) if (atom == "live_view"):
						hasLiveViewUse = true;
						hasImport = true;
						break;					
					default:
				};
			};
		};	
	default:
}) {
														var ` = stmt.def;
														switch (enumIndex `) {
															case 45: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var module = `;
																	{
																		if (module == "Phoenix.Component") {
																			hasImport = true;
																			break;
																		};
																	};
																};
															};
															case 46: {
																var ` = `[0];
																var ` = `[1];
																{
																	var module = `;
																	var opts = `;
																	{
																		if (module == "Phoenix.Component") {
																			hasImport = true;
																			break;
																		};
																		if (module.indexOf("Web", null) != -1 && opts != null && opts.length > 0) {
																			{
																				var ` = 0;
																				while (` < opts.length) {
																					var opt = opts[`];
																					++ `;
																					@:ast(switch (opt.def) {
	case EAtom(atom) if (atom == "live_view"):
		hasLiveViewUse = true;
		hasImport = true;
		break;	
	default:
}) {
																						var ` = opt.def;
																						if (enumIndex ` == 31) {
																							var ` = `[0];
																							{
																								var atom = `;
																								if (atom == "live_view") {
																									hasLiveViewUse = true;
																									hasImport = true;
																									break;
																								} else {};
																							};
																						} else {};
																					};
																				};
																			};
																		};
																	};
																};
															};
															default: {}
														};
													};
												};
											};
											if (hasLiveViewUse) {
												return node;
											};
											if (! hasImport) {
												var importStmt = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EUse("Phoenix.Component", []), metadata : {}, pos : pos};
												};
												var newStatements = [importStmt].concat(statements);
												var newDoBlock = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
												return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
											};
											return node;
										};
									};
								} else {
									var importStmt = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EUse("Phoenix.Component", []), metadata : {}, pos : pos};
									};
									var newDoBlock = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([importStmt, doBlock]), metadata : {}, pos : pos};
									};
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
								};
							};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function phoenixFunctionMappingPass(node:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case ECall(null, "assign_multiple", args):
		return makeASTWithMeta(ECall(null, "assign", args), n.metadata, n.pos);	
	default:
		return n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 22) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == null) if (` == "assign_multiple") {
						{
							var args = `;
							{
								return {def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "assign", args), metadata : n.metadata, pos : n.pos};
							};
						};
					} else {
						return n;
					} else {
						return n;
					};
				} else {
					return n;
				};
			};
		});
	}

	static function liveViewCoreComponentsImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsCoreComponents = [false];
		var moduleName = [""];
		var findModuleName = [null];
		findModuleName[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, _):
		moduleName = name;
		return;	
	default:
		iterateAST(node, findModuleName);	
}) {
				var ` = node.def;
				if (enumIndex ` == 1) {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						{
							moduleName[0] = name;
							return;
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, findModuleName[0]);
				};
			};
		};
		findModuleName[0](ast);
		if (moduleName[0] == "" || moduleName[0].indexOf("Live", null) == -1) {
			return ast;
		};
		var checkForComponents = [null];
		checkForComponents[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ESigil(type, content, _):
		if (type == "H") {
			if (content.indexOf("<.") != -1) {
				needsCoreComponents = true;
			};
		};	
	default:
		iterateAST(node, checkForComponents);	
}) {
				var ` = node.def;
				if (enumIndex ` == 61) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var type = `;
						var content = `;
						{
							if (type == "H") {
								if (content.indexOf("<.", null) != -1) {
									needsCoreComponents[0] = true;
								};
							};
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForComponents[0]);
				};
			};
		};
		checkForComponents[0](ast);
		if (! needsCoreComponents[0]) {
			return ast;
		};
		var appWebName = "";
		if (moduleName[0].indexOf(".", null) != -1) {
			var parts = moduleName[0].split(".");
			if (parts.length > 0) {
				appWebName = parts[0];
			};
		};
		if (appWebName == "") {
			return ast;
		};
		var coreComponentsModule = appWebName + ".CoreComponents";
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == coreComponentsModule) {
								hasImport = true;
								break;
							};						
						default:
					};
				};
				if (!hasImport) {
					var exceptOptions:Array<EImportOption> = [{ name : "label", arity : 1 }];
					var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
					var newStatements = [];
					var importAdded = false;
					for (stmt  in  statements) {
						newStatements.push(stmt);
						if (!importAdded) {
							switch (stmt.def) {
								case EUse(_, _):
									newStatements.push(importStmt);
									importAdded = true;								
								default:
							};
						};
					};
					if (!importAdded) {
						newStatements = [importStmt].concat(statements);
					};
					var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
					return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
				};
				return node;			
			default:
				return node;			
		};	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 1) {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == coreComponentsModule) {
						hasImport = true;
						break;
					};				
				default:
			};
		};
		if (!hasImport) {
			var exceptOptions:Array<EImportOption> = [{ name : "label", arity : 1 }];
			var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
			var newStatements = [];
			var importAdded = false;
			for (stmt  in  statements) {
				newStatements.push(stmt);
				if (!importAdded) {
					switch (stmt.def) {
						case EUse(_, _):
							newStatements.push(importStmt);
							importAdded = true;						
						default:
					};
				};
			};
			if (!importAdded) {
				newStatements = [importStmt].concat(statements);
			};
			var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
			return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
								var ` = doBlock.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var statements = `;
										{
											var hasImport = false;
											{
												var ` = 0;
												while (` < statements.length) {
													var stmt = statements[`];
													++ `;
													@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == coreComponentsModule) {
			hasImport = true;
			break;
		};	
	default:
}) {
														var ` = stmt.def;
														if (enumIndex ` == 45) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var module = `;
																{
																	if (module == coreComponentsModule) {
																		hasImport = true;
																		break;
																	};
																};
															};
														} else {};
													};
												};
											};
											if (! hasImport) {
												var exceptOptions = [{name : "label", arity : 1}];
												var importStmt = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EImport(coreComponentsModule, null, exceptOptions), metadata : {}, pos : pos};
												};
												var newStatements = [];
												var importAdded = false;
												{
													var ` = 0;
													while (` < statements.length) {
														var stmt = statements[`];
														++ `;
														newStatements.push(stmt);
														if (! importAdded) {
															@:ast(switch (stmt.def) {
	case EUse(_, _):
		newStatements.push(importStmt);
		importAdded = true;	
	default:
}) {
																var ` = stmt.def;
																if (enumIndex ` == 46) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		newStatements.push(importStmt);
																		importAdded = true;
																	};
																} else {};
															};
														};
													};
												};
												if (! importAdded) {
													newStatements = [importStmt].concat(statements);
												};
												var newDoBlock = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
												return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
											};
											return node;
										};
									};
								} else {
									return node;
								};
							};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function stringMethodTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall(target, methodName, args) if (target != null):
		var stringMethod = switch (methodName) {
			case "charAt":
				"at";			
			case "charCodeAt":
				"to_charlist";			
			case "toLowerCase":
				"downcase";			
			case "toUpperCase":
				"upcase";			
			case "indexOf":
				"index";			
			case "substring" | "substr":
				"slice";			
			case "split":
				"split";			
			case _:
				null;			
		};
		if (stringMethod != null) {
			if (methodName == "charCodeAt") {
				makeASTWithMeta(ERemoteCall(makeAST(EAtom(ElixirAtom.raw("binary"))), "at", [target].concat(args)), node.metadata, node.pos);
			} else {
				var newArgs = [target].concat(args);
				makeASTWithMeta(ERemoteCall(makeAST(EVar("String")), stringMethod, newArgs), node.metadata, node.pos);
			};
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 22) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var methodName = `;
						var args = `;
						if (target != null) {
							var stringMethod = @:ast(switch (methodName) {
	case "charAt":
		"at";	
	case "charCodeAt":
		"to_charlist";	
	case "toLowerCase":
		"downcase";	
	case "toUpperCase":
		"upcase";	
	case "indexOf":
		"index";	
	case "substring" | "substr":
		"slice";	
	case "split":
		"split";	
	case _:
		null;	
}) switch (methodName) {
								case "charAt": {
									{
										"at";
									};
								};
								case "charCodeAt": {
									{
										"to_charlist";
									};
								};
								case "indexOf": {
									{
										"index";
									};
								};
								case "split": {
									{
										"split";
									};
								};
								case "substr", "substring": {
									{
										"slice";
									};
								};
								case "toLowerCase": {
									{
										"downcase";
									};
								};
								case "toUpperCase": {
									{
										"upcase";
									};
								};
								default: {
									null;
								}
							};
							if (stringMethod != null) {
								if (methodName == "charCodeAt") {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "binary"), metadata : {}, pos : pos};
										}, "at", [target].concat(args));
										var meta = node.metadata;
										var pos = node.pos;
										{def : def, metadata : meta, pos : pos};
									};
								} else {
									var newArgs = [target].concat(args);
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
									}, stringMethod, newArgs), metadata : node.metadata, pos : node.pos};
								};
							} else {
								node;
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function constantFoldingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBinary(op, left, right):
		switch ([left.def, right.def]) {
			case [EInteger(l), EInteger(r)]:
				var result = switch (op) {
					case Add:
						l + r;					
					case Subtract:
						l - r;					
					case Multiply:
						l * r;					
					case Divide:
						Math.floor(l / r);					
					case Remainder:
						l % r;					
					case Less:
						l < r ? 1 : 0;					
					case Greater:
						l > r ? 1 : 0;					
					case LessEqual:
						l <= r ? 1 : 0;					
					case GreaterEqual:
						l >= r ? 1 : 0;					
					case Equal:
						l == r ? 1 : 0;					
					case NotEqual:
						l != r ? 1 : 0;					
					default:
						null;					
				};
				if (result != null) {
					if (op == Less || op == Greater || op == LessEqual || op == GreaterEqual || op == Equal || op == NotEqual) {
						makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
					} else {
						makeASTWithMeta(EInteger(result), node.metadata, node.pos);
					};
				} else {
					node;
				};			
			case [EString(l), EString(r)] if (op == StringConcat):
				makeASTWithMeta(EString(l + r), node.metadata, node.pos);			
			case [EList(l), EList(r)] if (op == Concat):
				makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);			
			default:
				node;			
		};	
	case EUnary(op, expr):
		switch (expr.def) {
			case EInteger(i) if (op == Negate):
				makeASTWithMeta(EInteger(-i), node.metadata, node.pos);			
			case EBoolean(b) if (op == Not):
				makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								@:ast(switch ([left.def, right.def]) {
	case [EInteger(l), EInteger(r)]:
		var result = switch (op) {
			case Add:
				l + r;			
			case Subtract:
				l - r;			
			case Multiply:
				l * r;			
			case Divide:
				Math.floor(l / r);			
			case Remainder:
				l % r;			
			case Less:
				l < r ? 1 : 0;			
			case Greater:
				l > r ? 1 : 0;			
			case LessEqual:
				l <= r ? 1 : 0;			
			case GreaterEqual:
				l >= r ? 1 : 0;			
			case Equal:
				l == r ? 1 : 0;			
			case NotEqual:
				l != r ? 1 : 0;			
			default:
				null;			
		};
		if (result != null) {
			if (op == Less || op == Greater || op == LessEqual || op == GreaterEqual || op == Equal || op == NotEqual) {
				makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
			} else {
				makeASTWithMeta(EInteger(result), node.metadata, node.pos);
			};
		} else {
			node;
		};	
	case [EString(l), EString(r)] if (op == StringConcat):
		makeASTWithMeta(EString(l + r), node.metadata, node.pos);	
	case [EList(l), EList(r)] if (op == Concat):
		makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = left.def;
									var ` = right.def;
									switch (enumIndex `) {
										case 15: {
											var ` = `[0];
											if (enumIndex ` == 15) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													if (op == reflaxe.elixir.ast.EBinaryOp.Concat) {
														{
															var def = reflaxe.elixir.ast.ElixirASTDef.EList(l.concat(r));
															var meta = node.metadata;
															var pos = node.pos;
															{def : def, metadata : meta, pos : pos};
														};
													} else {
														node;
													};
												};
											} else {
												node;
											};
										};
										case 32: {
											var ` = `[0];
											if (enumIndex ` == 32) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													if (op == reflaxe.elixir.ast.EBinaryOp.StringConcat) {
														{def : reflaxe.elixir.ast.ElixirASTDef.EString(l + r), metadata : node.metadata, pos : node.pos};
													} else {
														node;
													};
												};
											} else {
												node;
											};
										};
										case 33: {
											var ` = `[0];
											if (enumIndex ` == 33) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													{
														var result = @:ast(switch (op) {
	case Add:
		l + r;	
	case Subtract:
		l - r;	
	case Multiply:
		l * r;	
	case Divide:
		Math.floor(l / r);	
	case Remainder:
		l % r;	
	case Less:
		l < r ? 1 : 0;	
	case Greater:
		l > r ? 1 : 0;	
	case LessEqual:
		l <= r ? 1 : 0;	
	case GreaterEqual:
		l >= r ? 1 : 0;	
	case Equal:
		l == r ? 1 : 0;	
	case NotEqual:
		l != r ? 1 : 0;	
	default:
		null;	
}) switch (enumIndex op) {
															case 0: {
																{
																	l + r;
																};
															};
															case 1: {
																{
																	l - r;
																};
															};
															case 2: {
																{
																	l * r;
																};
															};
															case 3: {
																{
																	Math.floor(l / r);
																};
															};
															case 4: {
																{
																	l % r;
																};
															};
															case 6: {
																{
																	if (l == r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 7: {
																{
																	if (l != r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 10: {
																{
																	if (l < r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 11: {
																{
																	if (l > r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 12: {
																{
																	if (l <= r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 13: {
																{
																	if (l >= r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															default: {
																null;
															}
														};
														if (result != null) {
															if (op == reflaxe.elixir.ast.EBinaryOp.Less || op == reflaxe.elixir.ast.EBinaryOp.Greater || op == reflaxe.elixir.ast.EBinaryOp.LessEqual || op == reflaxe.elixir.ast.EBinaryOp.GreaterEqual || op == reflaxe.elixir.ast.EBinaryOp.Equal || op == reflaxe.elixir.ast.EBinaryOp.NotEqual) {
																{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(result == 1), metadata : node.metadata, pos : node.pos};
															} else {
																{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(result), metadata : node.metadata, pos : node.pos};
															};
														} else {
															node;
														};
													};
												};
											} else {
												node;
											};
										};
										default: {
											node;
										}
									};
								};
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var expr = `;
							{
								@:ast(switch (expr.def) {
	case EInteger(i) if (op == Negate):
		makeASTWithMeta(EInteger(-i), node.metadata, node.pos);	
	case EBoolean(b) if (op == Not):
		makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = expr.def;
									switch (enumIndex `) {
										case 33: {
											var ` = `[0];
											{
												var i = `;
												if (op == reflaxe.elixir.ast.EUnaryOp.Negate) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(- i), metadata : node.metadata, pos : node.pos};
												} else {
													node;
												};
											};
										};
										case 35: {
											var ` = `[0];
											{
												var b = `;
												if (op == reflaxe.elixir.ast.EUnaryOp.Not) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(! b), metadata : node.metadata, pos : node.pos};
												} else {
													node;
												};
											};
										};
										default: {
											node;
										}
									};
								};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function pipelineOptimizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(expressions):
		var optimized = detectAndOptimizePipeline(expressions);
		if (optimized != null) {
			optimized;
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var optimized = reflaxe.elixir.ast.ElixirASTTransformer.detectAndOptimizePipeline(expressions);
							if (optimized != null) {
								optimized;
							} else {
								node;
							};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function comprehensionConversionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var generatedFunctions = [];
		var loopCounter = [0];
		var transformLoops = [null];
		transformLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EFor(generators, filters, body, into, uniq):
		node;	
	case ECall(null, "while_loop", [condition, body]):
		var funcName = "loop_" + (loopCounter++);
		var transformedCondition = transformNode(condition, transformLoops);
		var transformedBody = transformNode(body, transformLoops);
		var recursiveFunc = makeAST(EDefp(funcName, [], null, makeAST(EIf(transformedCondition, makeAST(EBlock([transformedBody, makeAST(ECall(null, funcName, []))])), makeAST(EAtom(ElixirAtom.ok()))))));
		generatedFunctions.push(recursiveFunc);
		makeAST(ECall(null, funcName, []));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) if (` == "while_loop") {
							if (`.length == 2) {
								var ` = `[0];
								var ` = `[1];
								{
									var condition = `;
									var body = `;
									{
										var funcName = "loop_" + (loopCounter[0] ++);
										var transformedCondition = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(condition, transformLoops[0]);
										var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformLoops[0]);
										var recursiveFunc = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, [], null, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, funcName, []), metadata : {}, pos : pos};
													}]), metadata : {}, pos : pos};
												}, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										};
										generatedFunctions.push(recursiveFunc);
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, funcName, []), metadata : {}, pos : pos};
										};
									};
								};
							} else {
								node;
							};
						} else {
							node;
						} else {
							node;
						};
					};
					case 41: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						var ` = `[4];
						{
							var generators = `;
							var filters = `;
							var body = `;
							var into = `;
							var uniq = `;
							{
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		};
		var transformed = transformLoops[0](ast);
		if (generatedFunctions.length > 0) {
			@:ast(switch (transformed.def) {
	case EModule(name, attributes, body):
		var newBody = body.concat(generatedFunctions);
		return makeAST(EModule(name, attributes, newBody));	
	default:
		return transformed;	
}) {
				var ` = transformed.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							var newBody = body.concat(generatedFunctions);
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, newBody), metadata : {}, pos : pos};
							};
						};
					};
				} else {
					return transformed;
				};
			};
		};
		return transformed;
	}

	static function abstractMethodThisPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EFn(clauses):
		var fixedClauses = [];
		var hasChanges = false;
		for (clause  in  clauses) {
			if (clause.args.length > 0) {
				switch (clause.args[0]) {
					case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
						var fixedBody = replaceStructWithParam(clause.body, paramName);
						hasChanges = true;
						fixedClauses.push({ args : clause.args, guard : clause.guard, body : fixedBody });					
					default:
						fixedClauses.push(clause);					
				};
			} else {
				fixedClauses.push(clause);
			};
		};
		if (hasChanges) {
			return makeASTWithMeta(EFn(fixedClauses), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var fixedClauses = [];
							var hasChanges = false;
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause.args.length > 0) {
										@:ast(switch (clause.args[0]) {
	case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
		var fixedBody = replaceStructWithParam(clause.body, paramName);
		hasChanges = true;
		fixedClauses.push({ args : clause.args, guard : clause.guard, body : fixedBody });	
	default:
		fixedClauses.push(clause);	
}) {
											var ` = clause.args[0];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var paramName = `;
													if (paramName.indexOf("this", null) == 0 || paramName == "_struct" || paramName == "struct") {
														var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.replaceStructWithParam(clause.body, paramName);
														hasChanges = true;
														fixedClauses.push({args : clause.args, guard : clause.guard, body : fixedBody});
													} else {
														fixedClauses.push(clause);
													};
												};
											} else {
												fixedClauses.push(clause);
											};
										};
									} else {
										fixedClauses.push(clause);
									};
								};
							};
							if (hasChanges) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(fixedClauses), metadata : node.metadata, pos : node.pos};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function replaceStructWithParam(ast:reflaxe.elixir.ast.ElixirAST, paramName:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar("struct") | EVar("this"):
		return makeASTWithMeta(EVar(paramName), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					switch (`) {
						case "struct", "this": {
							{
								return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(paramName), metadata : node.metadata, pos : node.pos};
							};
						};
						default: {
							return node;
						}
					};
				} else {
					return node;
				};
			};
		});
	}

	static function bitwiseImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsBitwise = [false];
		var checkForBitwise = [null];
		checkForBitwise[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBinary(op, left, right):
		switch (op) {
			case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
				needsBitwise = true;			
			default:
		};
		checkForBitwise(left);
		checkForBitwise(right);	
	case EUnary(BitwiseNot, expr):
		needsBitwise = true;
		checkForBitwise(expr);	
	default:
		iterateAST(node, checkForBitwise);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								@:ast(switch (op) {
	case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
		needsBitwise = true;	
	default:
}) switch (enumIndex op) {
									case 18, 19, 20, 21, 22: {
										{
											needsBitwise[0] = true;
										};
									};
									default: {}
								};
								checkForBitwise[0](left);
								checkForBitwise[0](right);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 3) {
							{
								var expr = `;
								{
									needsBitwise[0] = true;
									checkForBitwise[0](expr);
								};
							};
						} else {
							reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForBitwise[0]);
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForBitwise[0]);
					}
				};
			};
		};
		checkForBitwise[0](ast);
		if (! needsBitwise[0]) {
			return ast;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == "Bitwise") {
								hasImport = true;
								break;
							};						
						default:
					};
				};
				if (!hasImport) {
					var newStatements = statements.copy();
					newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));
					return makeASTWithMeta(EDefmodule(name, makeAST(EBlock(newStatements))), node.metadata, node.pos);
				};			
			default:
		};
		return node;	
	case EModule(name, attributes, body):
		var hasImport = false;
		for (attr  in  attributes) {
			if (attr.name == "import" && attr.value != null) {
				switch (attr.value.def) {
					case EAtom(atomVal) if (atomVal == "Bitwise"):
						hasImport = true;					
					case EVar("Bitwise"):
						hasImport = true;					
					default:
				};
			};
		};
		if (!hasImport) {
			var newAttributes = attributes.copy();
			newAttributes.insert(0, { name : "import", value : makeAST(EAtom(ElixirAtom.raw("Bitwise"))) });
			return makeASTWithMeta(EModule(name, newAttributes, body), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								var hasImport = false;
								{
									var ` = 0;
									while (` < attributes.length) {
										var attr = attributes[`];
										++ `;
										if (attr.name == "import" && attr.value != null) {
											@:ast(switch (attr.value.def) {
	case EAtom(atomVal) if (atomVal == "Bitwise"):
		hasImport = true;	
	case EVar("Bitwise"):
		hasImport = true;	
	default:
}) {
												var ` = attr.value.def;
												switch (enumIndex `) {
													case 31: {
														var ` = `[0];
														{
															var atomVal = `;
															if (atomVal == "Bitwise") {
																hasImport = true;
															} else {};
														};
													};
													case 38: {
														var ` = `[0];
														if (` == "Bitwise") {
															{
																hasImport = true;
															};
														} else {};
													};
													default: {}
												};
											};
										};
									};
								};
								if (! hasImport) {
									var newAttributes = attributes.copy();
									newAttributes.insert(0, {name : "import", value : {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Bitwise"), metadata : {}, pos : pos};
									}});
									return {def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, newAttributes, body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == "Bitwise") {
						hasImport = true;
						break;
					};				
				default:
			};
		};
		if (!hasImport) {
			var newStatements = statements.copy();
			newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));
			return makeASTWithMeta(EDefmodule(name, makeAST(EBlock(newStatements))), node.metadata, node.pos);
		};	
	default:
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var statements = `;
											{
												var hasImport = false;
												{
													var ` = 0;
													while (` < statements.length) {
														var stmt = statements[`];
														++ `;
														@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == "Bitwise") {
			hasImport = true;
			break;
		};	
	default:
}) {
															var ` = stmt.def;
															if (enumIndex ` == 45) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var module = `;
																	{
																		if (module == "Bitwise") {
																			hasImport = true;
																			break;
																		};
																	};
																};
															} else {};
														};
													};
												};
												if (! hasImport) {
													var newStatements = statements.copy();
													newStatements.insert(0, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EImport("Bitwise", null, null), metadata : {}, pos : pos};
													});
													return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : {}, pos : pos};
													}), metadata : node.metadata, pos : node.pos};
												};
											};
										};
									} else {};
								};
								return node;
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function listEffectLiftingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EList(elements):
		var hasEffects = false;
		var liftedStatements:Array<ElixirAST> = [];
		var pureElements:Array<ElixirAST> = [];
		for (i  in  0 ... elements.length) {
			var elem = elements[i];
			switch (elem.def) {
				case EMatch(left, right):
					hasEffects = true;
					liftedStatements.push(elem);
					switch (left) {
						case PVar(name):
							pureElements.push(makeAST(EVar(name)));						
						default:
							pureElements.push(makeAST(EVar("_lifted_var")));						
					};				
				case EBlock(exprs) if (exprs.length > 0):
					hasEffects = true;
					for (j  in  0 ... exprs.length - 1) {
						liftedStatements.push(exprs[j]);
					};
					pureElements.push(exprs[exprs.length - 1]);				
				case EBinary(Concat, left, right):
					switch (right.def) {
						case EList(innerElements) if (innerElements.length > 0):
							var innerHasEffects = false;
							for (innerElem  in  innerElements) {
								switch (innerElem.def) {
									case EMatch(_, _) | EBlock(_):
										innerHasEffects = true;
										break;									
									default:
								};
							};
							if (innerHasEffects) {
								var processedInner = listEffectLiftingPass(makeAST(right.def));
								switch (processedInner.def) {
									case EBlock(stmts) if (stmts.length > 0):
										hasEffects = true;
										for (k  in  0 ... stmts.length - 1) {
											liftedStatements.push(stmts[k]);
										};
										pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));									
									default:
										pureElements.push(elem);									
								};
							} else {
								pureElements.push(elem);
							};						
						default:
							pureElements.push(elem);						
					};				
				default:
					pureElements.push(elem);				
			};
		};
		if (hasEffects) {
			var allStatements = liftedStatements.copy();
			allStatements.push(makeAST(EList(pureElements)));
			return makeAST(EBlock(allStatements));
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 15) {
					var ` = `[0];
					{
						var elements = `;
						{
							var hasEffects = false;
							var liftedStatements = [];
							var pureElements = [];
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									var elem = elements[i];
									@:ast(switch (elem.def) {
	case EMatch(left, right):
		hasEffects = true;
		liftedStatements.push(elem);
		switch (left) {
			case PVar(name):
				pureElements.push(makeAST(EVar(name)));			
			default:
				pureElements.push(makeAST(EVar("_lifted_var")));			
		};	
	case EBlock(exprs) if (exprs.length > 0):
		hasEffects = true;
		for (j  in  0 ... exprs.length - 1) {
			liftedStatements.push(exprs[j]);
		};
		pureElements.push(exprs[exprs.length - 1]);	
	case EBinary(Concat, left, right):
		switch (right.def) {
			case EList(innerElements) if (innerElements.length > 0):
				var innerHasEffects = false;
				for (innerElem  in  innerElements) {
					switch (innerElem.def) {
						case EMatch(_, _) | EBlock(_):
							innerHasEffects = true;
							break;						
						default:
					};
				};
				if (innerHasEffects) {
					var processedInner = listEffectLiftingPass(makeAST(right.def));
					switch (processedInner.def) {
						case EBlock(stmts) if (stmts.length > 0):
							hasEffects = true;
							for (k  in  0 ... stmts.length - 1) {
								liftedStatements.push(stmts[k]);
							};
							pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));						
						default:
							pureElements.push(elem);						
					};
				} else {
					pureElements.push(elem);
				};			
			default:
				pureElements.push(elem);			
		};	
	default:
		pureElements.push(elem);	
}) {
										var ` = elem.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var left = `;
													var right = `;
													{
														hasEffects = true;
														liftedStatements.push(elem);
														@:ast(switch (left) {
	case PVar(name):
		pureElements.push(makeAST(EVar(name)));	
	default:
		pureElements.push(makeAST(EVar("_lifted_var")));	
}) if (enumIndex left == 0) {
															var ` = left[0];
															{
																var name = `;
																{
																	pureElements.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
																	});
																};
															};
														} else {
															pureElements.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_lifted_var"), metadata : {}, pos : pos};
															});
														};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 23) {
													{
														var left = `;
														var right = `;
														{
															@:ast(switch (right.def) {
	case EList(innerElements) if (innerElements.length > 0):
		var innerHasEffects = false;
		for (innerElem  in  innerElements) {
			switch (innerElem.def) {
				case EMatch(_, _) | EBlock(_):
					innerHasEffects = true;
					break;				
				default:
			};
		};
		if (innerHasEffects) {
			var processedInner = listEffectLiftingPass(makeAST(right.def));
			switch (processedInner.def) {
				case EBlock(stmts) if (stmts.length > 0):
					hasEffects = true;
					for (k  in  0 ... stmts.length - 1) {
						liftedStatements.push(stmts[k]);
					};
					pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));				
				default:
					pureElements.push(elem);				
			};
		} else {
			pureElements.push(elem);
		};	
	default:
		pureElements.push(elem);	
}) {
																var ` = right.def;
																if (enumIndex ` == 15) {
																	var ` = `[0];
																	{
																		var innerElements = `;
																		if (innerElements.length > 0) {
																			var innerHasEffects = false;
																			{
																				var ` = 0;
																				while (` < innerElements.length) {
																					var innerElem = innerElements[`];
																					++ `;
																					@:ast(switch (innerElem.def) {
	case EMatch(_, _) | EBlock(_):
		innerHasEffects = true;
		break;	
	default:
}) {
																						var ` = innerElem.def;
																						switch (enumIndex `) {
																							case 8: {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									innerHasEffects = true;
																									break;
																								};
																							};
																							case 53: {
																								var ` = `[0];
																								{
																									innerHasEffects = true;
																									break;
																								};
																							};
																							default: {}
																						};
																					};
																				};
																			};
																			if (innerHasEffects) {
																				var processedInner = reflaxe.elixir.ast.ElixirASTTransformer.listEffectLiftingPass({
																					var pos = null;
																					{def : right.def, metadata : {}, pos : pos};
																				});
																				@:ast(switch (processedInner.def) {
	case EBlock(stmts) if (stmts.length > 0):
		hasEffects = true;
		for (k  in  0 ... stmts.length - 1) {
			liftedStatements.push(stmts[k]);
		};
		pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));	
	default:
		pureElements.push(elem);	
}) {
																					var ` = processedInner.def;
																					if (enumIndex ` == 53) {
																						var ` = `[0];
																						{
																							var stmts = `;
																							if (stmts.length > 0) {
																								hasEffects = true;
																								{
																									var ` = 0;
																									var ` = stmts.length - 1;
																									while (` < `) {
																										var k = ` ++;
																										liftedStatements.push(stmts[k]);
																									};
																								};
																								pureElements.push({
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, left, stmts[stmts.length - 1]), metadata : {}, pos : pos};
																								});
																							} else {
																								pureElements.push(elem);
																							};
																						};
																					} else {
																						pureElements.push(elem);
																					};
																				};
																			} else {
																				pureElements.push(elem);
																			};
																		} else {
																			pureElements.push(elem);
																		};
																	};
																} else {
																	pureElements.push(elem);
																};
															};
														};
													};
												} else {
													pureElements.push(elem);
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 0) {
														hasEffects = true;
														{
															var ` = 0;
															var ` = exprs.length - 1;
															while (` < `) {
																var j = ` ++;
																liftedStatements.push(exprs[j]);
															};
														};
														pureElements.push(exprs[exprs.length - 1]);
													} else {
														pureElements.push(elem);
													};
												};
											};
											default: {
												pureElements.push(elem);
											}
										};
									};
								};
							};
							if (hasEffects) {
								var allStatements = liftedStatements.copy();
								allStatements.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EList(pureElements), metadata : {}, pos : pos};
								});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(allStatements), metadata : {}, pos : pos};
								};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function structFieldAssignmentTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var structVarTracking = {
			{};
			new haxe.ds.StringMap();
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(expressions):
		var transformed = [];
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			switch (expr.def) {
				case EMatch(PVar(varName), rhs):
					switch (rhs.def) {
						case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
							structVarTracking.set(varName, varName);						
						case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
							structVarTracking.set(varName, varName);						
						default:
					};
					if (i + 1 < expressions.length) {
						var nextExpr = expressions[i + 1];
						switch (nextExpr.def) {
							case EMatch(PVar(fieldName), fieldValue):
								if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
									transformed.push(expr);
									var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
									transformed.push(mapPut);
									i += 2;
									continue;
								};							
							default:
						};
					};
					transformed.push(expr);				
				default:
					transformed.push(expr);				
			};
			i++;
		};
		if (transformed.length > 0) {
			return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var transformed = [];
							var i = 0;
							while (i < expressions.length) {
								var expr = expressions[i];
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), rhs):
		switch (rhs.def) {
			case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
				structVarTracking.set(varName, varName);			
			case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
				structVarTracking.set(varName, varName);			
			default:
		};
		if (i + 1 < expressions.length) {
			var nextExpr = expressions[i + 1];
			switch (nextExpr.def) {
				case EMatch(PVar(fieldName), fieldValue):
					if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
						transformed.push(expr);
						var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
						transformed.push(mapPut);
						i += 2;
						continue;
					};				
				default:
			};
		};
		transformed.push(expr);	
	default:
		transformed.push(expr);	
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var rhs = `;
												{
													@:ast(switch (rhs.def) {
	case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
		structVarTracking.set(varName, varName);	
	case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
		structVarTracking.set(varName, varName);	
	default:
}) {
														var ` = rhs.def;
														switch (enumIndex `) {
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var funcName = `;
																	if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker") {
																		{
																			structVarTracking.set(varName, varName);
																		};
																	} else {};
																};
															};
															case 24: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var funcName = `;
																	if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker") {
																		{
																			structVarTracking.set(varName, varName);
																		};
																	} else {};
																};
															};
															default: {}
														};
													};
													if (i + 1 < expressions.length) {
														var nextExpr = expressions[i + 1];
														@:ast(switch (nextExpr.def) {
	case EMatch(PVar(fieldName), fieldValue):
		if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
			transformed.push(expr);
			var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
			transformed.push(mapPut);
			i += 2;
			continue;
		};	
	default:
}) {
															var ` = nextExpr.def;
															if (enumIndex ` == 8) {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var fieldName = `;
																		var fieldValue = `;
																		{
																			if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
																				transformed.push(expr);
																				var mapPut = {
																					var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), {
																						var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "put", [{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
																						}, {
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						}, fieldValue]);
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					});
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				};
																				transformed.push(mapPut);
																				i += 2;
																				continue;
																			};
																		};
																	};
																} else {};
															} else {};
														};
													};
													transformed.push(expr);
												};
											};
										} else {
											transformed.push(expr);
										};
									} else {
										transformed.push(expr);
									};
								};
								i ++;
							};
							if (transformed.length > 0) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformed), metadata : node.metadata, pos : node.pos};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function statementContextTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformWithContext = [null];
		transformWithContext[0] = function(node:reflaxe.elixir.ast.ElixirAST, isStatementContext:Bool) {
			var transformed = @:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		makeASTWithMeta(EDefmodule(name, transformWithContext(doBlock, true)), node.metadata, node.pos);	
	case EBlock(expressions):
		var newExpressions = [];
		for (i  in  0 ... expressions.length) {
			var isLast = (i == expressions.length - 1);
			var childContext = isLast ? isStatementContext : true;
			newExpressions.push(transformWithContext(expressions[i], childContext));
		};
		makeASTWithMeta(EBlock(newExpressions), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, transformWithContext(body, false)), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, transformWithContext(body, false)), node.metadata, node.pos);	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformWithContext(condition, false), transformWithContext(thenBranch, isStatementContext), elseBranch != null ? transformWithContext(elseBranch, isStatementContext) : null), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformWithContext(expr, false), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformWithContext(c.guard, false) : null, body : transformWithContext(c.body, isStatementContext) })), node.metadata, node.pos);	
	default:
		switch (node.def) {
			case EModule(name, attributes, body):
				makeASTWithMeta(EModule(name, attributes, body.map(function(e) ->  @:implicitReturn return transformWithContext(e, true))), node.metadata, node.pos);			
			case ECall(target, funcName, args):
				makeASTWithMeta(ECall(target != null ? transformWithContext(target, false) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);			
			case ERemoteCall(module, funcName, args):
				makeASTWithMeta(ERemoteCall(transformWithContext(module, false), funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);			
			case EBinary(op, left, right):
				makeASTWithMeta(EBinary(op, transformWithContext(left, false), transformWithContext(right, false)), node.metadata, node.pos);			
			case EMatch(pattern, expr):
				makeASTWithMeta(EMatch(pattern, transformWithContext(expr, false)), node.metadata, node.pos);			
			default:
				node;			
		};	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformWithContext[0](doBlock, true));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformWithContext[0](body, false));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformWithContext[0](body, false));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformWithContext[0](expr, false), {
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformWithContext[0](v.guard, false) else null, body : transformWithContext[0](v.body, isStatementContext)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformWithContext[0](condition, false), transformWithContext[0](thenBranch, isStatementContext), if ((elseBranch != null)) transformWithContext[0](elseBranch, isStatementContext) else null);
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var expressions = `;
							{
								var newExpressions = [];
								{
									var ` = 0;
									var ` = expressions.length;
									while (` < `) {
										var i = ` ++;
										var isLast = (i == expressions.length - 1);
										var childContext = if (isLast) {
											isStatementContext;
										} else {
											true;
										};
										newExpressions.push(transformWithContext[0](expressions[i], childContext));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newExpressions), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						@:ast(switch (node.def) {
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(function(e) ->  @:implicitReturn return transformWithContext(e, true))), node.metadata, node.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformWithContext(target, false) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);	
	case ERemoteCall(module, funcName, args):
		makeASTWithMeta(ERemoteCall(transformWithContext(module, false), funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformWithContext(left, false), transformWithContext(right, false)), node.metadata, node.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transformWithContext(expr, false)), node.metadata, node.pos);	
	default:
		node;	
}) {
							var ` = node.def;
							switch (enumIndex `) {
								case 0: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var name = `;
										var attributes = `;
										var body = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
													var ` = [];
													{
														var ` = 0;
														var ` = body;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, true));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 8: {
									var ` = `[0];
									var ` = `[1];
									{
										var pattern = `;
										var expr = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformWithContext[0](expr, false));
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 22: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var target = `;
										var funcName = `;
										var args = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformWithContext[0](target, false) else null, funcName, {
													var ` = [];
													{
														var ` = 0;
														var ` = args;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, false));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 24: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var module = `;
										var funcName = `;
										var args = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(transformWithContext[0](module, false), funcName, {
													var ` = [];
													{
														var ` = 0;
														var ` = args;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, false));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 26: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var op = `;
										var left = `;
										var right = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformWithContext[0](left, false), transformWithContext[0](right, false));
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								default: {
									node;
								}
							};
						};
					}
				};
			};
			if (isStatementContext) {
				@:ast(switch (transformed.def) {
	case ERemoteCall(module, funcName, args):
		var moduleName:Null<String> = switch (module.def) {
			case EAtom(atom):
				atom;			
			case EVar(name):
				name;			
			default:
				null;			
		};
		if (moduleName != null) {
			var needsReassignment = switch (moduleName) {
				case "Map":
					["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;				
				case "List":
					["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;				
				case "MapSet":
					["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;				
				case "Keyword":
					["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;				
				case "String":
					["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;				
				default:
					false;				
			};
			if (needsReassignment && args.length >= 1) {
				switch (args[0].def) {
					case EVar(varName):
						return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);					
					default:
				};
			};
		};	
	case EBinary(Concat, left, right):
		switch (left.def) {
			case EVar(varName):
				return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);			
			default:
		};	
	default:
}) {
					var ` = transformed.def;
					switch (enumIndex `) {
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var module = `;
								var funcName = `;
								var args = `;
								{
									var moduleName = @:ast(switch (module.def) {
	case EAtom(atom):
		atom;	
	case EVar(name):
		name;	
	default:
		null;	
}) {
										var ` = module.def;
										switch (enumIndex `) {
											case 31: {
												var ` = `[0];
												{
													var atom = `;
													{
														atom;
													};
												};
											};
											case 38: {
												var ` = `[0];
												{
													var name = `;
													{
														name;
													};
												};
											};
											default: {
												null;
											}
										};
									};
									if (moduleName != null) {
										var needsReassignment = @:ast(switch (moduleName) {
	case "Map":
		["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;	
	case "List":
		["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;	
	case "MapSet":
		["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;	
	case "Keyword":
		["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;	
	case "String":
		["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;	
	default:
		false;	
}) if (moduleName == null) {
											false;
										} else switch (moduleName) {
											case "Keyword": {
												{
													["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName, null) >= 0;
												};
											};
											case "List": {
												{
													["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName, null) >= 0;
												};
											};
											case "Map": {
												{
													["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName, null) >= 0;
												};
											};
											case "MapSet": {
												{
													["put", "delete", "union", "intersection", "difference"].indexOf(funcName, null) >= 0;
												};
											};
											case "String": {
												{
													["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName, null) >= 0;
												};
											};
											default: {
												false;
											}
										};
										if (needsReassignment && args.length >= 1) {
											@:ast(switch (args[0].def) {
	case EVar(varName):
		return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);	
	default:
}) {
												var ` = args[0].def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var varName = `;
														{
															return {def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), transformed), metadata : node.metadata, pos : node.pos};
														};
													};
												} else {};
											};
										};
									};
								};
							};
						};
						case 26: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 23) {
								{
									var left = `;
									var right = `;
									{
										@:ast(switch (left.def) {
	case EVar(varName):
		return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);	
	default:
}) {
											var ` = left.def;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var varName = `;
													{
														return {def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), transformed), metadata : node.metadata, pos : node.pos};
													};
												};
											} else {};
										};
									};
								};
							} else {};
						};
						default: {}
					};
				};
			};
			return transformed;
		};
		return transformWithContext[0](ast, true);
	}

	static function immutabilityTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		ast = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EDef(name, args, guards, body) if ((name == "set" || name == "remove") && args.length > 0 && switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}):
		var updatedBody = transformStructFieldAssignments(body, args);
		if (updatedBody != body) {
			makeASTWithMeta(EDef(name, args, guards, updatedBody), node.metadata, node.pos);
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 2) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						if ((name == "set" || name == "remove") && args.length > 0 && @:ast(switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}) {
							var ` = args[0];
							if (enumIndex ` == 0) {
								var ` = `[0];
								if (` == "struct") {
									{
										true;
									};
								} else {
									false;
								};
							} else {
								false;
							};
						}) {
							var updatedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformStructFieldAssignments(body, args);
							if (updatedBody != body) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, updatedBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall(null, "pre_inc", [expr]):
		switch (expr.def) {
			case EVar(name):
				makeAST(EMatch(PVar(name), makeAST(EBinary(Add, expr, makeAST(EInteger(1))))));			
			default:
				node;			
		};	
	case ECall(null, "pre_dec", [expr]):
		switch (expr.def) {
			case EVar(name):
				makeAST(EMatch(PVar(name), makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))));			
			default:
				node;			
		};	
	case EBinary(Remainder, left, right):
		makeAST(ECall(null, "rem", [left, right]));	
	case ECall(target, "push", [item]):
		makeAST(EBinary(Concat, target, makeAST(EList([item]))));	
	case ECall(target, "pop", []):
		makeAST(ERemoteCall(makeAST(EAtom(ElixirAtom.raw("List"))), "delete_at", [target, makeAST(EInteger(-1))]));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) switch (`) {
							case "pop": {
								if (`.length == 0) {
									{
										var target = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "List"), metadata : {}, pos : pos};
												}, "delete_at", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							case "pre_dec": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var expr = `;
										{
											@:ast(switch (expr.def) {
	case EVar(name):
		makeAST(EMatch(PVar(name), makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))));	
	default:
		node;	
}) {
												var ` = expr.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var name = `;
														{
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, expr, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																	}), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
													};
												} else {
													node;
												};
											};
										};
									};
								} else {
									node;
								};
							};
							case "pre_inc": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var expr = `;
										{
											@:ast(switch (expr.def) {
	case EVar(name):
		makeAST(EMatch(PVar(name), makeAST(EBinary(Add, expr, makeAST(EInteger(1))))));	
	default:
		node;	
}) {
												var ` = expr.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var name = `;
														{
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, expr, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																	}), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
													};
												} else {
													node;
												};
											};
										};
									};
								} else {
									node;
								};
							};
							case "push": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var target = `;
										var item = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							default: {
								node;
							}
						} else switch (`) {
							case "pop": {
								if (`.length == 0) {
									{
										var target = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "List"), metadata : {}, pos : pos};
												}, "delete_at", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							case "push": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var target = `;
										var item = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							default: {
								node;
							}
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 4) {
							{
								var left = `;
								var right = `;
								{
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "rem", [left, right]), metadata : {}, pos : pos};
									};
								};
							};
						} else {
							node;
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function transformStructFieldAssignments(body:reflaxe.elixir.ast.ElixirAST, args:Array<reflaxe.elixir.ast.EPattern>) {
		var hasStructParam = args.length > 0 && @:ast(switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}) {
			var ` = args[0];
			if (enumIndex ` == 0) {
				var ` = `[0];
				if (` == "struct") {
					{
						true;
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
		if (! hasStructParam) {
			return body;
		};
		var hasFieldAssignment = [false];
		var fieldUpdates = {
			{};
			new haxe.ds.StringMap();
		};
		var analyzeNode = [null];
		analyzeNode[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EMatch(PVar("root"), value):
		hasFieldAssignment = true;
		fieldUpdates.set("root", value);	
	case EBlock(statements):
		for (stmt  in  statements) {
			analyzeNode(stmt);
		};	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (` == "root") {
								{
									var value = `;
									{
										hasFieldAssignment[0] = true;
										{
											fieldUpdates.set("root", value);
										};
									};
								};
							} else {};
						} else {};
					};
					case 53: {
						var ` = `[0];
						{
							var statements = `;
							{
								{
									var ` = 0;
									while (` < statements.length) {
										var stmt = statements[`];
										++ `;
										analyzeNode[0](stmt);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		analyzeNode[0](body);
		if (hasFieldAssignment[0] && fieldUpdates.exists("root")) {
			var statements = [];
			@:ast(switch (body.def) {
	case EBlock(stmts):
		statements = stmts.copy();	
	default:
		statements = [body];	
}) {
				var ` = body.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							statements = stmts.copy();
						};
					};
				} else {
					statements = [body];
				};
			};
			var structUpdate = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
				}, [{key : "root", value : {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("root"), metadata : {}, pos : pos};
				}}]), metadata : {}, pos : pos};
			};
			statements.push(structUpdate);
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
			};
		};
		return body;
	}

	static function extractParentModule(node:reflaxe.elixir.ast.ElixirAST) {
		if (node.metadata != null && node.metadata.sourceExpr != null) {};
		return null;
	}

	static function arrayLengthFieldToFunctionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EField(target, "length"):
		{ def : ECall(null, "length", [transformAST(target, arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };	
	case ECall(expr, funcName, args):
		{ def : ECall(expr != null ? transformAST(expr, arrayLengthFieldToFunctionPass) : null, funcName, [for (arg  in  args) transformAST(arg, arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };	
	default:
		transformAST(ast, arrayLengthFieldToFunctionPass);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var expr = `;
						var funcName = `;
						var args = `;
						{
							{def : reflaxe.elixir.ast.ElixirASTDef.ECall(if (expr != null) {
								reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
							} else {
								null;
							}, funcName, {
								var ` = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass));
									};
								};
								`;
							}), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (` == "length") {
						{
							var target = `;
							{
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "length", [reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
				}
			};
		};
	}

	static function toSnakeCase(name:String) {
		var result = "";
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
					result += "_";
				};
				result += char.toLowerCase();
			};
		};
		return result;
	}

	public static function transformNode(ast:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		var transformed = @:ast(switch (ast.def) {
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards != null ? transformNode(guards, transformer) : null, transformNode(body, transformer)), ast.metadata, ast.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards != null ? transformNode(guards, transformer) : null, transformNode(body, transformer)), ast.metadata, ast.pos);	
	case EBlock(expressions):
		makeASTWithMeta(EBlock(expressions.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformNode(condition, transformer), transformNode(thenBranch, transformer), elseBranch != null ? transformNode(elseBranch, transformer) : null), ast.metadata, ast.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformNode(expr, transformer), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformNode(c.guard, transformer) : null, body : transformNode(c.body, transformer) })), ast.metadata, ast.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformNode(left, transformer), transformNode(right, transformer)), ast.metadata, ast.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, transformNode(expr, transformer)), ast.metadata, ast.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformNode(target, transformer) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformNode(a, transformer))), ast.metadata, ast.pos);	
	case EList(elements):
		makeASTWithMeta(EList(elements.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case ETuple(elements):
		makeASTWithMeta(ETuple(elements.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case EMap(pairs):
		makeASTWithMeta(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformNode(p.key, transformer), value : transformNode(p.value, transformer) })), ast.metadata, ast.pos);	
	case EFor(generators, filters, body, into, uniq):
		makeASTWithMeta(EFor(generators.map(function(g) ->  @:implicitReturn return { pattern : g.pattern, expr : transformNode(g.expr, transformer) }), filters.map(function(f) ->  @:implicitReturn return transformNode(f, transformer)), transformNode(body, transformer), into != null ? transformNode(into, transformer) : null, uniq), ast.metadata, ast.pos);	
	case ERaw(code):
		return ast;	
	case EDefmodule(name, body):
		makeASTWithMeta(EDefmodule(name, transformNode(body, transformer)), ast.metadata, ast.pos);	
	default:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, if ((guards != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(guards, transformer) else null, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, if ((guards != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(guards, transformer) else null, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, transformer), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.guard, transformer) else null, body : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.body, transformer)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(condition, transformer), reflaxe.elixir.ast.ElixirASTTransformer.transformNode(thenBranch, transformer), if ((elseBranch != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(elseBranch, transformer) else null);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.key, transformer), value : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.value, transformer)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(target, transformer) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(left, transformer), reflaxe.elixir.ast.ElixirASTTransformer.transformNode(right, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFor({
									var ` = [];
									{
										var ` = 0;
										var ` = generators;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, expr : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.expr, transformer)});
										};
									};
									`;
								}, {
									var ` = [];
									{
										var ` = 0;
										var ` = filters;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								}, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer), if ((into != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(into, transformer) else null, uniq);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = expressions;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var code = `;
						{
							return ast;
						};
					};
				};
				default: {
					ast;
				}
			};
		};
		return transformer(transformed);
	}

	static function detectAndOptimizePipeline(expressions:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (expressions.length < 2) {
			return null;
		};
		var pipelineOps = [];
		var baseVar = null;
		var lastExpr = null;
		{
			var ` = 0;
			while (` < expressions.length) {
				var expr = expressions[`];
				++ `;
				@:ast(switch (expr.def) {
	case EMatch(PVar(name), call):
		switch (call.def) {
			case ECall(target, func, args):
				if (args.length > 0) {
					switch (args[0].def) {
						case EVar(argName) if (argName == name):
							if (baseVar == null) {
								baseVar = name;
							};
							if (baseVar == name) {
								pipelineOps.push({ func : func, args : args.slice(1), target : target });
								lastExpr = expr;
								continue;
							};						
						default:
					};
				};			
			case ERemoteCall(module, func, args):
				if (args.length > 0) {
					switch (args[0].def) {
						case EVar(argName) if (argName == name):
							if (baseVar == null) {
								baseVar = name;
							};
							if (baseVar == name) {
								pipelineOps.push({ func : func, args : args.slice(1), target : module });
								lastExpr = expr;
								continue;
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
					var ` = expr.def;
					if (enumIndex ` == 8) {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var name = `;
								var call = `;
								{
									@:ast(switch (call.def) {
	case ECall(target, func, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(argName) if (argName == name):
					if (baseVar == null) {
						baseVar = name;
					};
					if (baseVar == name) {
						pipelineOps.push({ func : func, args : args.slice(1), target : target });
						lastExpr = expr;
						continue;
					};				
				default:
			};
		};	
	case ERemoteCall(module, func, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(argName) if (argName == name):
					if (baseVar == null) {
						baseVar = name;
					};
					if (baseVar == name) {
						pipelineOps.push({ func : func, args : args.slice(1), target : module });
						lastExpr = expr;
						continue;
					};				
				default:
			};
		};	
	default:
}) {
										var ` = call.def;
										switch (enumIndex `) {
											case 22: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var target = `;
													var func = `;
													var args = `;
													{
														if (args.length > 0) {
															@:ast(switch (args[0].def) {
	case EVar(argName) if (argName == name):
		if (baseVar == null) {
			baseVar = name;
		};
		if (baseVar == name) {
			pipelineOps.push({ func : func, args : args.slice(1), target : target });
			lastExpr = expr;
			continue;
		};	
	default:
}) {
																var ` = args[0].def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var argName = `;
																		if (argName == name) {
																			if (baseVar == null) {
																				baseVar = name;
																			};
																			if (baseVar == name) {
																				pipelineOps.push({func : func, args : args.slice(1, null), target : target});
																				lastExpr = expr;
																				continue;
																			};
																		} else {};
																	};
																} else {};
															};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var module = `;
													var func = `;
													var args = `;
													{
														if (args.length > 0) {
															@:ast(switch (args[0].def) {
	case EVar(argName) if (argName == name):
		if (baseVar == null) {
			baseVar = name;
		};
		if (baseVar == name) {
			pipelineOps.push({ func : func, args : args.slice(1), target : module });
			lastExpr = expr;
			continue;
		};	
	default:
}) {
																var ` = args[0].def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var argName = `;
																		if (argName == name) {
																			if (baseVar == null) {
																				baseVar = name;
																			};
																			if (baseVar == name) {
																				pipelineOps.push({func : func, args : args.slice(1, null), target : module});
																				lastExpr = expr;
																				continue;
																			};
																		} else {};
																	};
																} else {};
															};
														};
													};
												};
											};
											default: {}
										};
									};
								};
							};
						} else {};
					} else {};
				};
				if (pipelineOps.length >= 2) {
					break;
				} else {
					pipelineOps = [];
					baseVar = null;
				};
			};
		};
		if (pipelineOps.length >= 2) {
			var pipeline = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(baseVar), metadata : {}, pos : pos};
			};
			{
				var ` = 0;
				while (` < pipelineOps.length) {
					var op = pipelineOps[`];
					++ `;
					if (op.target != null) {
						pipeline = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EPipe(pipeline, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(op.target, op.func, op.args), metadata : {}, pos : pos};
							}), metadata : {}, pos : pos};
						};
					} else {
						pipeline = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EPipe(pipeline, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, op.func, op.args), metadata : {}, pos : pos};
							}), metadata : {}, pos : pos};
						};
					};
				};
			};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(baseVar), pipeline), metadata : {}, pos : pos};
			};
		};
		return null;
	}

	static function conditionalReassignmentPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(expressions):
		var transformed = [];
		for (expr  in  expressions) {
			switch (expr.def) {
				case EIf(cond, thenBranch, null):
					switch (thenBranch.def) {
						case EMatch(PVar(varName), value):
							if (referencesVariable(value, varName)) {
								var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
								transformed.push(makeAST(EMatch(PVar(varName), newIf)));
							} else {
								transformed.push(expr);
							};						
						default:
							transformed.push(expr);						
					};				
				default:
					transformed.push(expr);				
			};
		};
		return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var transformed = [];
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									@:ast(switch (expr.def) {
	case EIf(cond, thenBranch, null):
		switch (thenBranch.def) {
			case EMatch(PVar(varName), value):
				if (referencesVariable(value, varName)) {
					var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
					transformed.push(makeAST(EMatch(PVar(varName), newIf)));
				} else {
					transformed.push(expr);
				};			
			default:
				transformed.push(expr);			
		};	
	default:
		transformed.push(expr);	
}) {
										var ` = expr.def;
										if (enumIndex ` == 10) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (` == null) {
												var thenBranch = `;
												var cond = `;
												{
													@:ast(switch (thenBranch.def) {
	case EMatch(PVar(varName), value):
		if (referencesVariable(value, varName)) {
			var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
			transformed.push(makeAST(EMatch(PVar(varName), newIf)));
		} else {
			transformed.push(expr);
		};	
	default:
		transformed.push(expr);	
}) {
														var ` = thenBranch.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var varName = `;
																	var value = `;
																	{
																		if (reflaxe.elixir.ast.ElixirASTTransformer.referencesVariable(value, varName)) {
																			var newIf = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, value, {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			};
																			transformed.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), newIf), metadata : {}, pos : pos};
																			});
																		} else {
																			transformed.push(expr);
																		};
																	};
																};
															} else {
																transformed.push(expr);
															};
														} else {
															transformed.push(expr);
														};
													};
												};
											} else {
												transformed.push(expr);
											};
										} else {
											transformed.push(expr);
										};
									};
								};
							};
							return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformed), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function referencesVariable(ast:reflaxe.elixir.ast.ElixirAST, varName:String) {
		var found = [false];
		var visitor = [null];
		visitor[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (found[0]) {
				return;
			};
			@:ast(switch (node.def) {
	case EVar(name) if (name == varName):
		found = true;	
	case ERemoteCall(_, _, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(name) if (name == varName):
					found = true;				
				default:
					for (arg  in  args) {
						visitor(arg);
					};				
			};
		};	
	default:
		transformAST(node, function(n) {
			visitor(n);
			return n;
		});	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var args = `;
							{
								if (args.length > 0) {
									@:ast(switch (args[0].def) {
	case EVar(name) if (name == varName):
		found = true;	
	default:
		for (arg  in  args) {
			visitor(arg);
		};	
}) {
										var ` = args[0].def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var name = `;
												if (name == varName) {
													found[0] = true;
												} else {
													{
														var ` = 0;
														while (` < args.length) {
															var arg = args[`];
															++ `;
															visitor[0](arg);
														};
													};
												};
											};
										} else {
											{
												var ` = 0;
												while (` < args.length) {
													var arg = args[`];
													++ `;
													visitor[0](arg);
												};
											};
										};
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							if (name == varName) {
								found[0] = true;
							} else {
								reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
									visitor[0](n);
									return n;
								});
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
							visitor[0](n);
							return n;
						});
					}
				};
			};
		};
		visitor[0](ast);
		return found[0];
	}

	static function removeRedundantNilInitPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body) if (name == "_new"):
		var transformedBody = switch (body.def) {
			case EBlock(expressions) if (expressions.length >= 2):
				var filteredExprs = [];
				var i = 0;
				while (i < expressions.length) {
					var expr = expressions[i];
					var shouldSkip = false;
					switch (expr.def) {
						case EMatch(PVar("this1"), nilValue):
							switch (nilValue.def) {
								case ENil:
									if (i + 1 < expressions.length) {
										switch (expressions[i + 1].def) {
											case EMatch(PVar("this1"), value):
												switch (value.def) {
													case ENil:
													default:
														shouldSkip = true;													
												};											
											default:
										};
									};								
								default:
							};						
						default:
					};
					if (!shouldSkip) {
						filteredExprs.push(expr);
					};
					i++;
				};
				if (filteredExprs.length != expressions.length) {
					makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
				} else {
					body;
				};			
			default:
				body;			
		};
		return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EBlock(expressions):
		var filtered = [];
		var nilAssignments = new Map<String,Int>();
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			switch (expr.def) {
				case EMatch(PVar(varName), nilValue):
					switch (nilValue.def) {
						case ENil:
							nilAssignments.set(varName, i);						
						default:
					};				
				default:
			};
			i++;
		};
		i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar(varName), nilValue):
					switch (nilValue.def) {
						case ENil:
							if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
								if (i + 1 < expressions.length) {
									switch (expressions[i + 1].def) {
										case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
											switch (value.def) {
												case ENil:
												default:
													shouldSkip = true;												
											};										
										default:
									};
								};
							};
							if (!shouldSkip) {
								var j = i + 1;
								while (j < expressions.length) {
									switch (expressions[j].def) {
										case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
											switch (value.def) {
												case ENil:
												default:
													shouldSkip = true;
													break;												
											};										
										default:
									};
									j++;
								};
							};						
						default:
					};				
				default:
			};
			if (!shouldSkip) {
				filtered.push(expr);
			};
			i++;
		};
		if (filtered.length != expressions.length) {
			return makeASTWithMeta(EBlock(filtered), node.metadata, node.pos);
		} else {
			return node;
		};	
	case EFn(clauses):
		var transformedClauses = [for (clause  in  clauses) { args : clause.args, guard : clause.guard, body : removeRedundantNilInitPass(clause.body) }];
		return makeASTWithMeta(EFn(transformedClauses), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		var transformedBody = removeRedundantNilInitPass(body);
		return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		var transformedBody = removeRedundantNilInitPass(body);
		return makeASTWithMeta(EDefp(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EParen(inner):
		var transformedInner = switch (inner.def) {
			case EBlock(expressions) if (expressions.length == 3):
				var hasRedundantNil = false;
				switch (expressions[0].def) {
					case EMatch(PVar("this1"), nilValue):
						switch (nilValue.def) {
							case ENil:
								switch (expressions[1].def) {
									case EMatch(PVar("this1"), _):
										switch (expressions[2].def) {
											case EVar("this1"):
												hasRedundantNil = true;											
											default:
										};									
									default:
								};							
							default:
						};					
					default:
				};
				if (hasRedundantNil) {
					makeASTWithMeta(EBlock([expressions[1], expressions[2]]), inner.metadata, inner.pos);
				} else {
					removeRedundantNilInitPass(inner);
				};			
			default:
				removeRedundantNilInitPass(inner);			
		};
		return makeASTWithMeta(EParen(transformedInner), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							if (name == "_new") {
								var transformedBody = @:ast(switch (body.def) {
	case EBlock(expressions) if (expressions.length >= 2):
		var filteredExprs = [];
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar("this1"), nilValue):
					switch (nilValue.def) {
						case ENil:
							if (i + 1 < expressions.length) {
								switch (expressions[i + 1].def) {
									case EMatch(PVar("this1"), value):
										switch (value.def) {
											case ENil:
											default:
												shouldSkip = true;											
										};									
									default:
								};
							};						
						default:
					};				
				default:
			};
			if (!shouldSkip) {
				filteredExprs.push(expr);
			};
			i++;
		};
		if (filteredExprs.length != expressions.length) {
			makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
		} else {
			body;
		};	
	default:
		body;	
}) {
									var ` = body.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var expressions = `;
											if (expressions.length >= 2) {
												var filteredExprs = [];
												var i = 0;
												while (i < expressions.length) {
													var expr = expressions[i];
													var shouldSkip = false;
													@:ast(switch (expr.def) {
	case EMatch(PVar("this1"), nilValue):
		switch (nilValue.def) {
			case ENil:
				if (i + 1 < expressions.length) {
					switch (expressions[i + 1].def) {
						case EMatch(PVar("this1"), value):
							switch (value.def) {
								case ENil:
								default:
									shouldSkip = true;								
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
														var ` = expr.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																if (` == "this1") {
																	{
																		var nilValue = `;
																		{
																			@:ast(switch (nilValue.def) {
	case ENil:
		if (i + 1 < expressions.length) {
			switch (expressions[i + 1].def) {
				case EMatch(PVar("this1"), value):
					switch (value.def) {
						case ENil:
						default:
							shouldSkip = true;						
					};				
				default:
			};
		};	
	default:
}) {
																				var ` = nilValue.def;
																				if (enumIndex ` == 36) {
																					{
																						if (i + 1 < expressions.length) {
																							@:ast(switch (expressions[i + 1].def) {
	case EMatch(PVar("this1"), value):
		switch (value.def) {
			case ENil:
			default:
				shouldSkip = true;			
		};	
	default:
}) {
																								var ` = expressions[i + 1].def;
																								if (enumIndex ` == 8) {
																									var ` = `[0];
																									var ` = `[1];
																									if (enumIndex ` == 0) {
																										var ` = `[0];
																										if (` == "this1") {
																											{
																												var value = `;
																												{
																													@:ast(switch (value.def) {
	case ENil:
	default:
		shouldSkip = true;	
}) {
																														var ` = value.def;
																														if (enumIndex ` == 36) {
																															{};
																														} else {
																															shouldSkip = true;
																														};
																													};
																												};
																											};
																										} else {};
																									} else {};
																								} else {};
																							};
																						};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															} else {};
														} else {};
													};
													if (! shouldSkip) {
														filteredExprs.push(expr);
													};
													i ++;
												};
												if (filteredExprs.length != expressions.length) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filteredExprs), metadata : body.metadata, pos : body.pos};
												} else {
													body;
												};
											} else {
												body;
											};
										};
									} else {
										body;
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
							} else {
								var name = `;
								var args = `;
								var guards = `;
								var body = `;
								{
									var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(body);
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(body);
								return {def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var transformedClauses = {
									var ` = [];
									{
										var ` = 0;
										while (` < clauses.length) {
											var clause = clauses[`];
											++ `;
											`.push({args : clause.args, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(clause.body)});
										};
									};
									`;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(transformedClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var expressions = `;
							{
								var filtered = [];
								var nilAssignments = {
									{};
									new haxe.ds.StringMap();
								};
								var i = 0;
								while (i < expressions.length) {
									var expr = expressions[i];
									@:ast(switch (expr.def) {
	case EMatch(PVar(varName), nilValue):
		switch (nilValue.def) {
			case ENil:
				nilAssignments.set(varName, i);			
			default:
		};	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var varName = `;
													var nilValue = `;
													{
														@:ast(switch (nilValue.def) {
	case ENil:
		nilAssignments.set(varName, i);	
	default:
}) {
															var ` = nilValue.def;
															if (enumIndex ` == 36) {
																{
																	{
																		nilAssignments.set(varName, i);
																	};
																};
															} else {};
														};
													};
												};
											} else {};
										} else {};
									};
									i ++;
								};
								i = 0;
								while (i < expressions.length) {
									var expr = expressions[i];
									var shouldSkip = false;
									@:ast(switch (expr.def) {
	case EMatch(PVar(varName), nilValue):
		switch (nilValue.def) {
			case ENil:
				if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
					if (i + 1 < expressions.length) {
						switch (expressions[i + 1].def) {
							case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
								switch (value.def) {
									case ENil:
									default:
										shouldSkip = true;									
								};							
							default:
						};
					};
				};
				if (!shouldSkip) {
					var j = i + 1;
					while (j < expressions.length) {
						switch (expressions[j].def) {
							case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
								switch (value.def) {
									case ENil:
									default:
										shouldSkip = true;
										break;									
								};							
							default:
						};
						j++;
					};
				};			
			default:
		};	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var varName = `;
													var nilValue = `;
													{
														@:ast(switch (nilValue.def) {
	case ENil:
		if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
			if (i + 1 < expressions.length) {
				switch (expressions[i + 1].def) {
					case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
						switch (value.def) {
							case ENil:
							default:
								shouldSkip = true;							
						};					
					default:
				};
			};
		};
		if (!shouldSkip) {
			var j = i + 1;
			while (j < expressions.length) {
				switch (expressions[j].def) {
					case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
						switch (value.def) {
							case ENil:
							default:
								shouldSkip = true;
								break;							
						};					
					default:
				};
				j++;
			};
		};	
	default:
}) {
															var ` = nilValue.def;
															if (enumIndex ` == 36) {
																{
																	if (varName == "this1" || varName == "this" || StringTools.startsWith(varName, "this")) {
																		if (i + 1 < expressions.length) {
																			@:ast(switch (expressions[i + 1].def) {
	case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
		switch (value.def) {
			case ENil:
			default:
				shouldSkip = true;			
		};	
	default:
}) {
																				var ` = expressions[i + 1].def;
																				if (enumIndex ` == 8) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						{
																							var nextVarName = `;
																							var value = `;
																							if (nextVarName == varName) {
																								@:ast(switch (value.def) {
	case ENil:
	default:
		shouldSkip = true;	
}) {
																									var ` = value.def;
																									if (enumIndex ` == 36) {
																										{};
																									} else {
																										shouldSkip = true;
																									};
																								};
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																	if (! shouldSkip) {
																		var j = i + 1;
																		while (j < expressions.length) {
																			@:ast(switch (expressions[j].def) {
	case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
		switch (value.def) {
			case ENil:
			default:
				shouldSkip = true;
				break;			
		};	
	default:
}) {
																				var ` = expressions[j].def;
																				if (enumIndex ` == 8) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						{
																							var nextVarName = `;
																							var value = `;
																							if (nextVarName == varName) {
																								@:ast(switch (value.def) {
	case ENil:
	default:
		shouldSkip = true;
		break;	
}) {
																									var ` = value.def;
																									if (enumIndex ` == 36) {
																										{};
																									} else {
																										shouldSkip = true;
																										break;
																									};
																								};
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																			j ++;
																		};
																	};
																};
															} else {};
														};
													};
												};
											} else {};
										} else {};
									};
									if (! shouldSkip) {
										filtered.push(expr);
									};
									i ++;
								};
								if (filtered.length != expressions.length) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filtered), metadata : node.metadata, pos : node.pos};
								} else {
									return node;
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var inner = `;
							{
								var transformedInner = @:ast(switch (inner.def) {
	case EBlock(expressions) if (expressions.length == 3):
		var hasRedundantNil = false;
		switch (expressions[0].def) {
			case EMatch(PVar("this1"), nilValue):
				switch (nilValue.def) {
					case ENil:
						switch (expressions[1].def) {
							case EMatch(PVar("this1"), _):
								switch (expressions[2].def) {
									case EVar("this1"):
										hasRedundantNil = true;									
									default:
								};							
							default:
						};					
					default:
				};			
			default:
		};
		if (hasRedundantNil) {
			makeASTWithMeta(EBlock([expressions[1], expressions[2]]), inner.metadata, inner.pos);
		} else {
			removeRedundantNilInitPass(inner);
		};	
	default:
		removeRedundantNilInitPass(inner);	
}) {
									var ` = inner.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var expressions = `;
											if (expressions.length == 3) {
												var hasRedundantNil = false;
												@:ast(switch (expressions[0].def) {
	case EMatch(PVar("this1"), nilValue):
		switch (nilValue.def) {
			case ENil:
				switch (expressions[1].def) {
					case EMatch(PVar("this1"), _):
						switch (expressions[2].def) {
							case EVar("this1"):
								hasRedundantNil = true;							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
													var ` = expressions[0].def;
													if (enumIndex ` == 8) {
														var ` = `[0];
														var ` = `[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (` == "this1") {
																{
																	var nilValue = `;
																	{
																		@:ast(switch (nilValue.def) {
	case ENil:
		switch (expressions[1].def) {
			case EMatch(PVar("this1"), _):
				switch (expressions[2].def) {
					case EVar("this1"):
						hasRedundantNil = true;					
					default:
				};			
			default:
		};	
	default:
}) {
																			var ` = nilValue.def;
																			if (enumIndex ` == 36) {
																				{
																					@:ast(switch (expressions[1].def) {
	case EMatch(PVar("this1"), _):
		switch (expressions[2].def) {
			case EVar("this1"):
				hasRedundantNil = true;			
			default:
		};	
	default:
}) {
																						var ` = expressions[1].def;
																						if (enumIndex ` == 8) {
																							var ` = `[0];
																							var ` = `[1];
																							if (enumIndex ` == 0) {
																								var ` = `[0];
																								if (` == "this1") {
																									{
																										@:ast(switch (expressions[2].def) {
	case EVar("this1"):
		hasRedundantNil = true;	
	default:
}) {
																											var ` = expressions[2].def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												if (` == "this1") {
																													{
																														hasRedundantNil = true;
																													};
																												} else {};
																											} else {};
																										};
																									};
																								} else {};
																							} else {};
																						} else {};
																					};
																				};
																			} else {};
																		};
																	};
																};
															} else {};
														} else {};
													} else {};
												};
												if (hasRedundantNil) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([expressions[1], expressions[2]]), metadata : inner.metadata, pos : inner.pos};
												} else {
													reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
												};
											} else {
												reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
											};
										};
									} else {
										reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EParen(transformedInner), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function prefixUnusedParametersPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDef(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefp(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefp(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefmacro(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefmacro(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefmacrop(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefmacrop(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EFn(clauses):
		var hasAnyChange = false;
		var newClauses = [];
		for (clause  in  clauses) {
			var result = handleFunctionParameters(clause.args, clause.guard, clause.body);
			if (result.hasChanges) {
				hasAnyChange = true;
				newClauses.push({ args : result.args, guard : clause.guard, body : result.body });
			} else {
				newClauses.push(clause);
			};
		};
		if (hasAnyChange) {
			return makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmacro(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmacrop(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var hasAnyChange = false;
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(clause.args, clause.guard, clause.body);
										if (result.hasChanges) {
											hasAnyChange = true;
											newClauses.push({args : result.args, guard : clause.guard, body : result.body});
										} else {
											newClauses.push(clause);
										};
									};
								};
								if (hasAnyChange) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function handleFunctionParameters(args:Array<reflaxe.elixir.ast.EPattern>, guards:Null<reflaxe.elixir.ast.ElixirAST>, body:reflaxe.elixir.ast.ElixirAST) {
		var paramNames = {
			{};
			new haxe.ds.StringMap();
		};
		var paramRenames = {
			{};
			new haxe.ds.StringMap();
		};
		var extractParamNames = [null];
		extractParamNames[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pattern) {
	case PVar(name):
		if (!name.startsWith("_")) {
			paramNames.set(name, false);
		};	
	case PTuple(patterns):
		for (p  in  patterns) extractParamNames(p);	
	case PList(patterns):
		for (p  in  patterns) extractParamNames(p);	
	case PMap(pairs):
		for (pair  in  pairs) extractParamNames(pair.value);	
	case PCons(head, tail):
		extractParamNames(head);
		extractParamNames(tail);	
	case PPin(pattern):
		extractParamNames(pattern);	
	default:
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (! StringTools.startsWith(name, "_")) {
								{
									paramNames.set(name, false);
								};
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									extractParamNames[0](p);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									extractParamNames[0](p);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							extractParamNames[0](head);
							extractParamNames[0](tail);
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									extractParamNames[0](pair.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pattern[0];
					{
						var pattern = `;
						{
							extractParamNames[0](pattern);
						};
					};
				};
				default: {}
			};
		};
		{
			var ` = 0;
			while (` < args.length) {
				var arg = args[`];
				++ `;
				extractParamNames[0](arg);
			};
		};
		if (Lambda.count(cast paramNames, null) == 0) {
			return {args : args, body : body, hasChanges : false};
		};
		var markUsedVars = [null];
		markUsedVars[0] = function(ast:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (ast.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	case EField(target, _):
		switch (target.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(target);			
		};	
	case EAccess(target, key):
		switch (target.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(target);			
		};
		markUsedVars(key);	
	case EStructUpdate(struct, fields):
		switch (struct.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(struct);			
		};
		for (field  in  fields) {
			markUsedVars(field.value);
		};	
	case ERaw(code):
		for (name => _  in  paramNames) {
			var pattern = "\\b${name}\\b";
			if (new EReg(pattern, "").match(code)) {
				paramNames.set(name, true);
			};
		};	
	case EKeywordList(pairs):
		for (pair  in  pairs) {
			markUsedVars(pair.value);
		};	
	default:
		iterateAST(ast, markUsedVars);	
}) {
				var ` = ast.def;
				switch (enumIndex `) {
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var struct = `;
							var fields = `;
							{
								@:ast(switch (struct.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(struct);	
}) {
									var ` = struct.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](struct);
									};
								};
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										markUsedVars[0](field.value);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var pair = pairs[`];
										++ `;
										markUsedVars[0](pair.value);
									};
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							{
								@:ast(switch (target.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(target);	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](target);
									};
								};
							};
						};
					};
					case 29: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var key = `;
							{
								@:ast(switch (target.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(target);	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](target);
									};
								};
								markUsedVars[0](key);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (paramNames.exists(name)) {
									{
										paramNames.set(name, true);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								{
									var ` = cast new haxe.iterators.MapKeyValueIterator(paramNames);
									while (`.hasNext()) {
										var ` = `.next();
										var name = `.key;
										var _ = `.value;
										{
											var pattern = "\\b" + name + "\\b";
											if (new EReg(pattern, "").match(code)) {
												{
													paramNames.set(name, true);
												};
											};
										};
									};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(ast, markUsedVars[0]);
					}
				};
			};
		};
		if (guards != null) {
			markUsedVars[0](guards);
		};
		markUsedVars[0](body);
		var hasChanges = false;
		{
			var ` = cast new haxe.iterators.MapKeyValueIterator(paramNames);
			while (`.hasNext()) {
				var ` = `.next();
				var name = `.key;
				var used = `.value;
				{
					if (! used && ! StringTools.startsWith(name, "_")) {
						var newName = "_" + name;
						{
							paramRenames.set(name, newName);
						};
						hasChanges = true;
					};
				};
			};
		};
		if (! hasChanges) {
			return {args : args, body : body, hasChanges : false};
		};
		var renameInPattern = [null];
		renameInPattern[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pattern) {
	case PVar(name):
		if (paramRenames.exists(name)) {
			return PVar(paramRenames.get(name));
		};
		return pattern;	
	case PTuple(patterns):
		return PTuple(patterns.map(renameInPattern));	
	case PList(patterns):
		return PList(patterns.map(renameInPattern));	
	case PMap(pairs):
		return PMap([for (pair  in  pairs) { key : pair.key, value : renameInPattern(pair.value) }]);	
	case PCons(head, tail):
		return PCons(renameInPattern(head), renameInPattern(tail));	
	case PPin(p):
		return PPin(renameInPattern(p));	
	default:
		return pattern;	
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (paramRenames.exists(name)) {
								return reflaxe.elixir.ast.EPattern.PVar(cast paramRenames.get(name));
							};
							return pattern;
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							return reflaxe.elixir.ast.EPattern.PTuple({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							return reflaxe.elixir.ast.EPattern.PList({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							return reflaxe.elixir.ast.EPattern.PCons(renameInPattern[0](head), renameInPattern[0](tail));
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							return reflaxe.elixir.ast.EPattern.PMap({
								var ` = [];
								{
									var ` = 0;
									while (` < pairs.length) {
										var pair = pairs[`];
										++ `;
										`.push({key : pair.key, value : renameInPattern[0](pair.value)});
									};
								};
								`;
							});
						};
					};
				};
				case 7: {
					var ` = pattern[0];
					{
						var p = `;
						{
							return reflaxe.elixir.ast.EPattern.PPin(renameInPattern[0](p));
						};
					};
				};
				default: {
					return pattern;
				}
			};
		};
		var newArgs = {
			var f = renameInPattern[0];
			{
				var ` = [];
				{
					var ` = 0;
					var ` = args;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		};
		var renameInAST = [null];
		renameInAST[0] = function(ast:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (ast.def) {
	case EVar(name):
		if (paramRenames.exists(name)) {
			return { def : EVar(paramRenames.get(name)), metadata : ast.metadata };
		};
		return ast;	
	default:
		return transformAST(ast, renameInAST);	
}) {
				var ` = ast.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var name = `;
						{
							if (paramRenames.exists(name)) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(cast paramRenames.get(name)), metadata : ast.metadata};
							};
							return ast;
						};
					};
				} else {
					return reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, renameInAST[0]);
				};
			};
		};
		var newBody = renameInAST[0](body);
		return {args : newArgs, body : newBody, hasChanges : true};
	}

	@:value(0)
	static var uniqueCounter:Int = 0;

	static function generateUniqueId() {
		return Std.string(reflaxe.elixir.ast.ElixirASTTransformer.uniqueCounter ++);
	}

	static function iterateAST(node:reflaxe.elixir.ast.ElixirAST, visitor:reflaxe.elixir.ast.ElixirAST -> Void) {
		@:ast(switch (node.def) {
	case EBlock(expressions):
		for (expr  in  expressions) visitor(expr);	
	case EModule(name, attributes, body):
		for (b  in  body) visitor(b);	
	case EDefmodule(name, doBlock):
		visitor(doBlock);	
	case EDef(name, args, guards, body):
		visitor(body);	
	case EDefp(name, args, guards, body):
		visitor(body);	
	case EIf(condition, thenBranch, elseBranch):
		visitor(condition);
		visitor(thenBranch);
		if (elseBranch != null) visitor(elseBranch);	
	case ECase(expr, clauses):
		visitor(expr);
		for (clause  in  clauses) {
			if (clause.guard != null) visitor(clause.guard);
			visitor(clause.body);
		};	
	case EMatch(pattern, expr):
		visitor(expr);	
	case EBinary(op, left, right):
		visitor(left);
		visitor(right);	
	case EUnary(op, expr):
		visitor(expr);	
	case ECall(target, funcName, args):
		if (target != null) visitor(target);
		for (arg  in  args) visitor(arg);	
	case EMacroCall(macroName, args, doBlock):
		for (arg  in  args) visitor(arg);
		visitor(doBlock);	
	case ETuple(elements):
		for (elem  in  elements) visitor(elem);	
	case EList(elements):
		for (elem  in  elements) visitor(elem);	
	case EMap(pairs):
		for (pair  in  pairs) {
			visitor(pair.key);
			visitor(pair.value);
		};	
	case EStruct(name, fields):
		for (field  in  fields) visitor(field.value);	
	case EFor(generators, filters, body, into, uniq):
		for (gen  in  generators) {
			visitor(gen.expr);
		};
		for (filter  in  filters) visitor(filter);
		visitor(body);
		if (into != null) visitor(into);	
	case EFn(clauses):
		for (clause  in  clauses) {
			if (clause.guard != null) visitor(clause.guard);
			visitor(clause.body);
		};	
	case EReceive(clauses, after):
		for (clause  in  clauses) {
			if (clause.guard != null) visitor(clause.guard);
			visitor(clause.body);
		};
		if (after != null) {
			visitor(after.timeout);
			visitor(after.body);
		};	
	case ERemoteCall(module, funcName, args):
		if (module != null) visitor(module);
		for (arg  in  args) visitor(arg);	
	case EParen(expr):
		visitor(expr);	
	case EDo(body):
		for (stmt  in  body) visitor(stmt);	
	case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
		visitor(body);
		if (rescue != null) {
			for (clause  in  rescue) {
				visitor(clause.body);
			};
		};
		if (catchClauses != null) {
			for (clause  in  catchClauses) {
				visitor(clause.body);
			};
		};
		if (afterBlock != null) visitor(afterBlock);
		if (elseBlock != null) visitor(elseBlock);	
	case EWith(clauses, doBlock, elseBlock):
		for (clause  in  clauses) {
			visitor(clause.expr);
		};
		visitor(doBlock);
		if (elseBlock != null) visitor(elseBlock);	
	case ECond(clauses):
		for (clause  in  clauses) {
			visitor(clause.condition);
			visitor(clause.body);
		};	
	case EField(object, field):
		visitor(object);	
	case EModuleAttribute(name, value):
		visitor(value);	
	case EKeywordList(pairs):
		for (pair  in  pairs) {
			visitor(pair.value);
		};	
	case _:
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							{
								var ` = 0;
								while (` < body.length) {
									var b = body[`];
									++ `;
									visitor(b);
								};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							visitor(doBlock);
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							visitor(body);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							visitor(body);
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							visitor(expr);
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause.guard != null) {
										visitor(clause.guard);
									};
									visitor(clause.body);
								};
							};
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									visitor(clause.condition);
									visitor(clause.body);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							visitor(expr);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var clauses = `;
						var doBlock = `;
						var elseBlock = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									visitor(clause.expr);
								};
							};
							visitor(doBlock);
							if (elseBlock != null) {
								visitor(elseBlock);
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							visitor(condition);
							visitor(thenBranch);
							if (elseBranch != null) {
								visitor(elseBranch);
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var body = `;
						var rescue = `;
						var catchClauses = `;
						var afterBlock = `;
						var elseBlock = `;
						{
							visitor(body);
							if (rescue != null) {
								{
									var ` = 0;
									while (` < rescue.length) {
										var clause = rescue[`];
										++ `;
										visitor(clause.body);
									};
								};
							};
							if (catchClauses != null) {
								{
									var ` = 0;
									while (` < catchClauses.length) {
										var clause = catchClauses[`];
										++ `;
										visitor(clause.body);
									};
								};
							};
							if (afterBlock != null) {
								visitor(afterBlock);
							};
							if (elseBlock != null) {
								visitor(elseBlock);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									visitor(elem);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									visitor(elem);
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									visitor(pair.key);
									visitor(pair.value);
								};
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									visitor(field.value);
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									visitor(pair.value);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							if (target != null) {
								visitor(target);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									visitor(arg);
								};
							};
						};
					};
				};
				case 23: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var macroName = `;
						var args = `;
						var doBlock = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									visitor(arg);
								};
							};
							visitor(doBlock);
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							if (module != null) {
								visitor(module);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									visitor(arg);
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							visitor(left);
							visitor(right);
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							visitor(expr);
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var object = `;
						var field = `;
						{
							visitor(object);
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var ` = 0;
								while (` < generators.length) {
									var gen = generators[`];
									++ `;
									visitor(gen.expr);
								};
							};
							{
								var ` = 0;
								while (` < filters.length) {
									var filter = filters[`];
									++ `;
									visitor(filter);
								};
							};
							visitor(body);
							if (into != null) {
								visitor(into);
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause.guard != null) {
										visitor(clause.guard);
									};
									visitor(clause.body);
								};
							};
						};
					};
				};
				case 51: {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						var after = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause.guard != null) {
										visitor(clause.guard);
									};
									visitor(clause.body);
								};
							};
							if (after != null) {
								visitor(after.timeout);
								visitor(after.body);
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									visitor(expr);
								};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							visitor(expr);
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var body = `;
						{
							{
								var ` = 0;
								while (` < body.length) {
									var stmt = body[`];
									++ `;
									visitor(stmt);
								};
							};
						};
					};
				};
				case 56: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var value = `;
						{
							visitor(value);
						};
					};
				};
				default: {}
			};
		};
	}

	public static function transformAST(node:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		if (node == null) {
			return null;
		};
		var transformed = @:ast(switch (node.def) {
	case EBlock(expressions):
		makeASTWithMeta(EBlock(expressions.map(transformer)), node.metadata, node.pos);	
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(transformer)), node.metadata, node.pos);	
	case EDefmodule(name, doBlock):
		makeASTWithMeta(EDefmodule(name, transformer(doBlock)), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, transformer(body)), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, transformer(body)), node.metadata, node.pos);	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformer(condition), transformer(thenBranch), elseBranch != null ? transformer(elseBranch) : null), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformer(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })), node.metadata, node.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transformer(expr)), node.metadata, node.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformer(left), transformer(right)), node.metadata, node.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, transformer(expr)), node.metadata, node.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformer(target) : null, funcName, args.map(transformer)), node.metadata, node.pos);	
	case EMacroCall(macroName, args, doBlock):
		makeASTWithMeta(EMacroCall(macroName, args.map(transformer), transformer(doBlock)), node.metadata, node.pos);	
	case ETuple(elements):
		makeASTWithMeta(ETuple(elements.map(transformer)), node.metadata, node.pos);	
	case EList(elements):
		makeASTWithMeta(EList(elements.map(transformer)), node.metadata, node.pos);	
	case EMap(pairs):
		makeASTWithMeta(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformer(p.key), value : transformer(p.value) })), node.metadata, node.pos);	
	case EKeywordList(pairs):
		makeASTWithMeta(EKeywordList(pairs.map(function(p) ->  @:implicitReturn return { key : p.key, value : transformer(p.value) })), node.metadata, node.pos);	
	case EStruct(name, fields):
		makeASTWithMeta(EStruct(name, fields.map(function(f) ->  @:implicitReturn return { key : f.key, value : transformer(f.value) })), node.metadata, node.pos);	
	case EFor(generators, filters, body, into, uniq):
		makeASTWithMeta(EFor(generators.map(function(g) ->  @:implicitReturn return { pattern : g.pattern, expr : transformer(g.expr) }), filters.map(transformer), transformer(body), into != null ? transformer(into) : null, uniq), node.metadata, node.pos);	
	case EFn(clauses):
		makeASTWithMeta(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })), node.metadata, node.pos);	
	case EReceive(clauses, after):
		makeASTWithMeta(EReceive(clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) }), after != null ? { timeout : transformer(after.timeout), body : transformer(after.body) } : null), node.metadata, node.pos);	
	case EModuleAttribute(name, value):
		makeASTWithMeta(EModuleAttribute(name, transformer(value)), node.metadata, node.pos);	
	case ERemoteCall(module, funcName, args):
		makeASTWithMeta(ERemoteCall(module != null ? transformer(module) : null, funcName, args.map(transformer)), node.metadata, node.pos);	
	case EParen(expr):
		makeASTWithMeta(EParen(transformer(expr)), node.metadata, node.pos);	
	case _:
		node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformer(doBlock));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformer(body));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformer(body));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformer(expr), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformer(condition), transformer(thenBranch), if ((elseBranch != null)) transformer(elseBranch) else null);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : transformer(v.key), value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EStruct(name, {
									var ` = [];
									{
										var ` = 0;
										var ` = fields;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : v.key, value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EKeywordList({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : v.key, value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformer(target) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 23: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var macroName = `;
						var args = `;
						var doBlock = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMacroCall(macroName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								}, transformer(doBlock));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(if ((module != null)) transformer(module) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformer(left), transformer(right));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFor({
									var ` = [];
									{
										var ` = 0;
										var ` = generators;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, expr : transformer(v.expr)});
										};
									};
									`;
								}, {
									var ` = [];
									{
										var ` = 0;
										var ` = filters;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								}, transformer(body), if ((into != null)) transformer(into) else null, uniq);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({args : v.args, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 51: {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						var after = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EReceive({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								}, if ((after != null)) {timeout : transformer(after.timeout), body : transformer(after.body)} else null);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = expressions;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 56: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var value = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EModuleAttribute(name, transformer(value));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					node;
				}
			};
		};
		return transformed;
	}

	static function supervisorOptionsTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.SupervisorOptionsTransformPass.transform(ast);
	}

	static function otpChildSpecTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformCount = 0;
		var transformIdiomaticNode = [null];
		transformIdiomaticNode[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			var nodeWithTransformedChildren = reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, transformIdiomaticNode[0]);
			if (nodeWithTransformedChildren == null) {
				return null;
			};
			if (nodeWithTransformedChildren.metadata != null && nodeWithTransformedChildren.metadata.requiresIdiomaticTransform == true) {
				var transformed = reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.applyIdiomaticEnumTransformation(nodeWithTransformedChildren);
				return transformed;
			};
			return nodeWithTransformedChildren;
		};
		var result = transformIdiomaticNode[0](ast);
		return result;
	}

	static function tupleElemFieldToFunctionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EField(target, "elem"):
		{ def : EField(transformAST(target, tupleElemFieldToFunctionPass), "elem"), metadata : ast.metadata, pos : ast.pos };	
	case ECall(expr, funcName, args):
		if (funcName == "elem" && expr != null) {
			{ def : ECall(null, "elem", [transformAST(expr, tupleElemFieldToFunctionPass)].concat([for (arg  in  args) transformAST(arg, tupleElemFieldToFunctionPass)])), metadata : ast.metadata, pos : ast.pos };
		} else {
			{ def : ECall(expr != null ? transformAST(expr, tupleElemFieldToFunctionPass) : null, funcName, [for (arg  in  args) transformAST(arg, tupleElemFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };
		};	
	default:
		transformAST(ast, tupleElemFieldToFunctionPass);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var expr = `;
						var funcName = `;
						var args = `;
						{
							if (funcName == "elem" && expr != null) {
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass)].concat({
									var ` = [];
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass));
										};
									};
									`;
								})), metadata : ast.metadata, pos : ast.pos};
							} else {
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(if (expr != null) {
									reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
								} else {
									null;
								}, funcName, {
									var ` = [];
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass));
										};
									};
									`;
								}), metadata : ast.metadata, pos : ast.pos};
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (` == "elem") {
						{
							var target = `;
							{
								{def : reflaxe.elixir.ast.ElixirASTDef.EField(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass), "elem"), metadata : ast.metadata, pos : ast.pos};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
				}
			};
		};
	}

	static function idiomaticEnumPatternMatchingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case ECase(expr, clauses):
		var isEnumTagCheck = false;
		var baseExpr = expr;
		switch (expr.def) {
			case ECall(tupleExpr, "elem", [arg]):
				switch (arg.def) {
					case EInteger(0):
						isEnumTagCheck = true;
						baseExpr = tupleExpr;					
					default:
				};			
			case EField(tupleExpr, "elem"):
				isEnumTagCheck = true;
				baseExpr = tupleExpr;			
			default:
		};
		if (isEnumTagCheck) {
			var transformedClauses = [];
			for (clause  in  clauses) {
				var transformedClause = transformEnumClause(clause, baseExpr);
				transformedClauses.push(transformedClause);
			};
			{ def : ECase(baseExpr, transformedClauses), metadata : ast.metadata, pos : ast.pos };
		} else {
			transformAST(ast, idiomaticEnumPatternMatchingPass);
		};	
	default:
		transformAST(ast, idiomaticEnumPatternMatchingPass);	
}) {
			var ` = ast.def;
			if (enumIndex ` == 6) {
				var ` = `[0];
				var ` = `[1];
				{
					var expr = `;
					var clauses = `;
					{
						var isEnumTagCheck = false;
						var baseExpr = expr;
						@:ast(switch (expr.def) {
	case ECall(tupleExpr, "elem", [arg]):
		switch (arg.def) {
			case EInteger(0):
				isEnumTagCheck = true;
				baseExpr = tupleExpr;			
			default:
		};	
	case EField(tupleExpr, "elem"):
		isEnumTagCheck = true;
		baseExpr = tupleExpr;	
	default:
}) {
							var ` = expr.def;
							switch (enumIndex `) {
								case 22: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (` == "elem") {
										if (`.length == 1) {
											var ` = `[0];
											{
												var arg = `;
												var tupleExpr = `;
												{
													@:ast(switch (arg.def) {
	case EInteger(0):
		isEnumTagCheck = true;
		baseExpr = tupleExpr;	
	default:
}) {
														var ` = arg.def;
														if (enumIndex ` == 33) {
															var ` = `[0];
															if (` == 0) {
																{
																	isEnumTagCheck = true;
																	baseExpr = tupleExpr;
																};
															} else {};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
								case 28: {
									var ` = `[0];
									var ` = `[1];
									if (` == "elem") {
										{
											var tupleExpr = `;
											{
												isEnumTagCheck = true;
												baseExpr = tupleExpr;
											};
										};
									} else {};
								};
								default: {}
							};
						};
						if (isEnumTagCheck) {
							var transformedClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var transformedClause = reflaxe.elixir.ast.ElixirASTTransformer.transformEnumClause(clause, baseExpr);
									transformedClauses.push(transformedClause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(baseExpr, transformedClauses), metadata : ast.metadata, pos : ast.pos};
						} else {
							reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass);
						};
					};
				};
			} else {
				reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass);
			};
		};
	}

	static function transformEnumClause(clause:reflaxe.elixir.ast.ECaseClause, baseExpr:reflaxe.elixir.ast.ElixirAST) {
		var tagValue = @:ast(switch (clause.pattern) {
	case PLiteral(ast):
		switch (ast.def) {
			case EInteger(tag):
				tag;			
			default:
				return clause;			
		};	
	default:
		return clause;	
}) {
			var ` = clause.pattern;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var ast = `;
					{
						@:ast(switch (ast.def) {
	case EInteger(tag):
		tag;	
	default:
		return clause;	
}) {
							var ` = ast.def;
							if (enumIndex ` == 33) {
								var ` = `[0];
								{
									var tag = `;
									{
										tag;
									};
								};
							} else {
								return clause;
							};
						};
					};
				};
			} else {
				return clause;
			};
		};
		var extractedParams = reflaxe.elixir.ast.ElixirASTTransformer.analyzeEnumParameterExtraction(clause.body, baseExpr);
		var tuplePattern = if (extractedParams.length > 0) {
			var patterns = [reflaxe.elixir.ast.EPattern.PLiteral({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(tagValue), metadata : {}, pos : pos};
			})];
			{
				var ` = 0;
				while (` < extractedParams.length) {
					var param = extractedParams[`];
					++ `;
					patterns.push(reflaxe.elixir.ast.EPattern.PVar(param.finalName));
				};
			};
			reflaxe.elixir.ast.EPattern.PTuple(patterns);
		} else {
			reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(tagValue), metadata : {}, pos : pos};
			}), reflaxe.elixir.ast.EPattern.PWildcard]);
		};
		var cleanedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeEnumParameterExtractions(clause.body, extractedParams);
		return {pattern : tuplePattern, guard : clause.guard, body : cleanedBody};
	}

	static function analyzeEnumParameterExtraction(body:reflaxe.elixir.ast.ElixirAST, baseExpr:reflaxe.elixir.ast.ElixirAST) {
		var params = [];
		@:ast(switch (body.def) {
	case EBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.def) {
				case EMatch(PVar(varName), ast):
					switch (ast.def) {
						case ECall(tupleExpr, "elem", [arg]):
							switch (arg.def) {
								case EInteger(1):
									if (astEquals(tupleExpr, baseExpr)) {
										var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
										if (finalName != null) {
											params.push({ tempName : varName, finalName : finalName });
										} else {
											params.push({ tempName : varName, finalName : varName.replace("_", "") });
										};
									};								
								default:
							};						
						default:
					};				
				default:
			};
		};	
	default:
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), ast):
		switch (ast.def) {
			case ECall(tupleExpr, "elem", [arg]):
				switch (arg.def) {
					case EInteger(1):
						if (astEquals(tupleExpr, baseExpr)) {
							var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
							if (finalName != null) {
								params.push({ tempName : varName, finalName : finalName });
							} else {
								params.push({ tempName : varName, finalName : varName.replace("_", "") });
							};
						};					
					default:
				};			
			default:
		};	
	default:
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var ast = `;
												{
													@:ast(switch (ast.def) {
	case ECall(tupleExpr, "elem", [arg]):
		switch (arg.def) {
			case EInteger(1):
				if (astEquals(tupleExpr, baseExpr)) {
					var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
					if (finalName != null) {
						params.push({ tempName : varName, finalName : finalName });
					} else {
						params.push({ tempName : varName, finalName : varName.replace("_", "") });
					};
				};			
			default:
		};	
	default:
}) {
														var ` = ast.def;
														if (enumIndex ` == 22) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == "elem") {
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var arg = `;
																		var tupleExpr = `;
																		{
																			@:ast(switch (arg.def) {
	case EInteger(1):
		if (astEquals(tupleExpr, baseExpr)) {
			var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
			if (finalName != null) {
				params.push({ tempName : varName, finalName : finalName });
			} else {
				params.push({ tempName : varName, finalName : varName.replace("_", "") });
			};
		};	
	default:
}) {
																				var ` = arg.def;
																				if (enumIndex ` == 33) {
																					var ` = `[0];
																					if (` == 1) {
																						{
																							if (reflaxe.elixir.ast.ElixirASTTransformer.astEquals(tupleExpr, baseExpr)) {
																								var finalName = reflaxe.elixir.ast.ElixirASTTransformer.findSubsequentAssignment(exprs, StringTools.replace(varName, "_", ""));
																								if (finalName != null) {
																									params.push({tempName : varName, finalName : finalName});
																								} else {
																									params.push({tempName : varName, finalName : StringTools.replace(varName, "_", "")});
																								};
																							};
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																} else {};
															} else {};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
				};
			} else {};
		};
		return params;
	}

	static function findSubsequentAssignment(exprs:Array<reflaxe.elixir.ast.ElixirAST>, tempVarWithoutUnderscore:String) {
		{
			var ` = 0;
			while (` < exprs.length) {
				var expr = exprs[`];
				++ `;
				@:ast(switch (expr.def) {
	case EMatch(PVar(finalName), ast):
		switch (ast.def) {
			case EVar(srcVar):
				if (srcVar == tempVarWithoutUnderscore) {
					return finalName;
				};			
			default:
		};	
	default:
}) {
					var ` = expr.def;
					if (enumIndex ` == 8) {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var finalName = `;
								var ast = `;
								{
									@:ast(switch (ast.def) {
	case EVar(srcVar):
		if (srcVar == tempVarWithoutUnderscore) {
			return finalName;
		};	
	default:
}) {
										var ` = ast.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var srcVar = `;
												{
													if (srcVar == tempVarWithoutUnderscore) {
														return finalName;
													};
												};
											};
										} else {};
									};
								};
							};
						} else {};
					} else {};
				};
			};
		};
		return null;
	}

	static function removeEnumParameterExtractions(body:reflaxe.elixir.ast.ElixirAST, extractedParams:Array<{ tempName : String, finalName : String }>) {
		@:ast(switch (body.def) {
	case EBlock(exprs):
		var cleanedExprs = [];
		var skip = false;
		for (i  in  0 ... exprs.length) {
			var expr = exprs[i];
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar(varName), ast):
					switch (ast.def) {
						case ECall(_, "elem", [arg]):
							switch (arg.def) {
								case EInteger(1):
									for (param  in  extractedParams) {
										if (varName == param.tempName) {
											shouldSkip = true;
											break;
										};
									};								
								default:
							};						
						case EVar(srcVar):
							for (param  in  extractedParams) {
								if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
									shouldSkip = true;
									break;
								};
							};						
						default:
					};				
				default:
			};
			if (!shouldSkip) {
				cleanedExprs.push(expr);
			};
		};
		if (cleanedExprs.length == 1) {
			return cleanedExprs[0];
		} else if (cleanedExprs.length == 0) {
			return makeAST(EAtom(ElixirAtom.nil()));
		} else {
			return { def : EBlock(cleanedExprs), metadata : body.metadata, pos : body.pos };
		};	
	default:
		return body;	
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var cleanedExprs = [];
						var skip = false;
						{
							var ` = 0;
							var ` = exprs.length;
							while (` < `) {
								var i = ` ++;
								var expr = exprs[i];
								var shouldSkip = false;
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), ast):
		switch (ast.def) {
			case ECall(_, "elem", [arg]):
				switch (arg.def) {
					case EInteger(1):
						for (param  in  extractedParams) {
							if (varName == param.tempName) {
								shouldSkip = true;
								break;
							};
						};					
					default:
				};			
			case EVar(srcVar):
				for (param  in  extractedParams) {
					if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
						shouldSkip = true;
						break;
					};
				};			
			default:
		};	
	default:
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var ast = `;
												{
													@:ast(switch (ast.def) {
	case ECall(_, "elem", [arg]):
		switch (arg.def) {
			case EInteger(1):
				for (param  in  extractedParams) {
					if (varName == param.tempName) {
						shouldSkip = true;
						break;
					};
				};			
			default:
		};	
	case EVar(srcVar):
		for (param  in  extractedParams) {
			if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
				shouldSkip = true;
				break;
			};
		};	
	default:
}) {
														var ` = ast.def;
														switch (enumIndex `) {
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (` == "elem") {
																	if (`.length == 1) {
																		var ` = `[0];
																		{
																			var arg = `;
																			{
																				@:ast(switch (arg.def) {
	case EInteger(1):
		for (param  in  extractedParams) {
			if (varName == param.tempName) {
				shouldSkip = true;
				break;
			};
		};	
	default:
}) {
																					var ` = arg.def;
																					if (enumIndex ` == 33) {
																						var ` = `[0];
																						if (` == 1) {
																							{
																								{
																									var ` = 0;
																									while (` < extractedParams.length) {
																										var param = extractedParams[`];
																										++ `;
																										if (varName == param.tempName) {
																											shouldSkip = true;
																											break;
																										};
																									};
																								};
																							};
																						} else {};
																					} else {};
																				};
																			};
																		};
																	} else {};
																} else {};
															};
															case 38: {
																var ` = `[0];
																{
																	var srcVar = `;
																	{
																		{
																			var ` = 0;
																			while (` < extractedParams.length) {
																				var param = extractedParams[`];
																				++ `;
																				if (varName == param.finalName && srcVar == StringTools.replace(param.tempName, "_", "")) {
																					shouldSkip = true;
																					break;
																				};
																			};
																		};
																	};
																};
															};
															default: {}
														};
													};
												};
											};
										} else {};
									} else {};
								};
								if (! shouldSkip) {
									cleanedExprs.push(expr);
								};
							};
						};
						if (cleanedExprs.length == 1) {
							return cleanedExprs[0];
						} else {
							if (cleanedExprs.length == 0) {
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "nil"), metadata : {}, pos : pos};
								};
							} else {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(cleanedExprs), metadata : body.metadata, pos : body.pos};
							};
						};
					};
				};
			} else {
				return body;
			};
		};
	}

	static function astEquals(a:reflaxe.elixir.ast.ElixirAST, b:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch ([a.def, b.def]) {
	case [EVar(name1), EVar(name2)]:
		name1 == name2;	
	case [EField(obj1, field1), EField(obj2, field2)]:
		field1 == field2 && astEquals(obj1, obj2);	
	default:
		false;	
}) {
			var ` = a.def;
			var ` = b.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 28) {
						var ` = `[0];
						var ` = `[1];
						{
							var obj2 = `;
							var field2 = `;
							var field1 = `;
							var obj1 = `;
							{
								field1 == field2 && reflaxe.elixir.ast.ElixirASTTransformer.astEquals(obj1, obj2);
							};
						};
					} else {
						false;
					};
				};
				case 38: {
					var ` = `[0];
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var name2 = `;
							var name1 = `;
							{
								name1 == name2;
							};
						};
					} else {
						false;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function transformIdiomaticEnum(elements:Array<reflaxe.elixir.ast.ElixirAST>, node:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.applyIdiomaticEnumTransformation(node);
	}

	static function isModuleName(s:String) {
		if (s == null || s.length == 0) {
			return false;
		};
		var firstChar = s.charAt(0);
		if (firstChar != firstChar.toUpperCase()) {
			return false;
		};
		var segments = s.split(".");
		{
			var ` = 0;
			while (` < segments.length) {
				var segment = segments[`];
				++ `;
				if (segment.length == 0) {
					return false;
				};
				var first = segment.charAt(0);
				if (first != first.toUpperCase() || first == first.toLowerCase()) {
					return false;
				};
			};
		};
		return true;
	}

	static function toIdiomaticAtom(tag:String) {
		@:ast(switch (tag.toLowerCase()) {
	case "ok":
		return "ok";	
	case "error":
		return "error";	
	case "some":
		return "ok";	
	case "none":
		return "error";	
	default:
		return toSnakeCase(tag);	
}) {
			var ` = tag.toLowerCase();
			switch (`) {
				case "error": {
					{
						return "error";
					};
				};
				case "none": {
					{
						return "error";
					};
				};
				case "ok": {
					{
						return "ok";
					};
				};
				case "some": {
					{
						return "ok";
					};
				};
				default: {
					return reflaxe.elixir.ast.ElixirASTTransformer.toSnakeCase(tag);
				}
			};
		};
	}

	static function underscoreVariableCleanupPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var underscoreVars = {
			{};
			new haxe.ds.StringMap();
		};
		var varDeclarations = {
			{};
			new haxe.ds.StringMap();
		};
		var allUnderscoreVars = {
			{};
			new haxe.ds.StringMap();
		};
		var collectPatternVars = [null];
		collectPatternVars[0] = function(pattern:reflaxe.elixir.ast.EPattern, vars:Map<String, Bool>) {
			@:ast(switch (pattern) {
	case PVar(name):
		vars.set(name, true);
		if (name.charAt(0) == "_" && name.length > 1) {
			allUnderscoreVars.set(name, true);
			if (!underscoreVars.exists(name)) {
				underscoreVars.set(name, false);
			};
		};	
	case PTuple(patterns):
		for (p  in  patterns) collectPatternVars(p, vars);	
	case PList(patterns):
		for (p  in  patterns) collectPatternVars(p, vars);	
	case PCons(head, tail):
		collectPatternVars(head, vars);
		collectPatternVars(tail, vars);	
	case PMap(pairs):
		for (pair  in  pairs) collectPatternVars(pair.value, vars);	
	case PStruct(name, fields):
		for (field  in  fields) collectPatternVars(field.value, vars);	
	case _:
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							{
								vars.set(name, true);
							};
							if (name.charAt(0) == "_" && name.length > 1) {
								{
									allUnderscoreVars.set(name, true);
								};
								if (! underscoreVars.exists(name)) {
									{
										underscoreVars.set(name, false);
									};
								};
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									collectPatternVars[0](p, vars);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									collectPatternVars[0](p, vars);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							collectPatternVars[0](head, vars);
							collectPatternVars[0](tail, vars);
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									collectPatternVars[0](pair.value, vars);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									collectPatternVars[0](field.value, vars);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		var collectVariables = [null];
		collectVariables[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EMatch(pattern, expr):
		collectPatternVars(pattern, varDeclarations);
		collectVariables(expr);	
	case EVar(name):
		if (name.charAt(0) == "_" && name.length > 1) {
			underscoreVars.set(name, true);
			allUnderscoreVars.set(name, true);
		};	
	case ERemoteCall(module, funcName, args):
		if (module != null) collectVariables(module);
		for (arg  in  args) {
			collectVariables(arg);
		};	
	case EFn(clauses):
		for (clause  in  clauses) {
			if (clause.guard != null) collectVariables(clause.guard);
			collectVariables(clause.body);
		};	
	case _:
		iterateAST(node, collectVariables);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								collectPatternVars[0](pattern, varDeclarations);
								collectVariables[0](expr);
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var funcName = `;
							var args = `;
							{
								if (module != null) {
									collectVariables[0](module);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										collectVariables[0](arg);
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (name.charAt(0) == "_" && name.length > 1) {
									{
										underscoreVars.set(name, true);
									};
									{
										allUnderscoreVars.set(name, true);
									};
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										if (clause.guard != null) {
											collectVariables[0](clause.guard);
										};
										collectVariables[0](clause.body);
									};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, collectVariables[0]);
					}
				};
			};
		};
		collectVariables[0](ast);
		var renameMap = {
			{};
			new haxe.ds.StringMap();
		};
		for (varName in allUnderscoreVars.keys()) {
			var isUsed = underscoreVars.exists(varName) && cast underscoreVars.get(varName);
			if (isUsed) {
				if (new EReg("^_g(_?\\d*)?$", "").match(varName)) {
					var newName = varName.substr(1, null);
					{
						renameMap.set(varName, newName);
					};
				} else {
					if (new EReg("^_\\d+$", "").match(varName)) {
						var newName = "temp" + varName.substr(1, null);
						{
							renameMap.set(varName, newName);
						};
					};
				};
			} else {};
		};
		if (renameMap.keys().hasNext()) {
			return reflaxe.elixir.ast.ElixirASTTransformer.applyVariableRenaming(ast, renameMap);
		};
		return ast;
	}

	static function applyVariableRenaming(ast:reflaxe.elixir.ast.ElixirAST, renameMap:Map<String, String>) {
		var renameInPattern = [null];
		renameInPattern[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			return @:ast(switch (pattern) {
	case PVar(name):
		renameMap.exists(name) ? PVar(renameMap.get(name)) : pattern;	
	case PTuple(patterns):
		PTuple(patterns.map(renameInPattern));	
	case PList(patterns):
		PList(patterns.map(renameInPattern));	
	case PCons(head, tail):
		PCons(renameInPattern(head), renameInPattern(tail));	
	case PMap(pairs):
		PMap(pairs.map(function(p) ->  @:implicitReturn return { key : p.key, value : renameInPattern(p.value) }));	
	case PStruct(name, fields):
		PStruct(name, fields.map(function(f) ->  @:implicitReturn return { key : f.key, value : renameInPattern(f.value) }));	
	case _:
		pattern;	
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (renameMap.exists(name)) {
								reflaxe.elixir.ast.EPattern.PVar(cast renameMap.get(name));
							} else {
								pattern;
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							reflaxe.elixir.ast.EPattern.PTuple({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							reflaxe.elixir.ast.EPattern.PList({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							reflaxe.elixir.ast.EPattern.PCons(renameInPattern[0](head), renameInPattern[0](tail));
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							reflaxe.elixir.ast.EPattern.PMap({
								var ` = [];
								{
									var ` = 0;
									var ` = pairs;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(p:{ value : reflaxe.elixir.ast.EPattern, key : reflaxe.elixir.ast.ElixirAST }) {
											return {key : p.key, value : renameInPattern[0](p.value)};
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				case 6: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var name = `;
						var fields = `;
						{
							reflaxe.elixir.ast.EPattern.PStruct(name, {
								var ` = [];
								{
									var ` = 0;
									var ` = fields;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(f:{ value : reflaxe.elixir.ast.EPattern, key : String }) {
											return {key : f.key, value : renameInPattern[0](f.value)};
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				default: {
					pattern;
				}
			};
		};
		var renameInAST = [null];
		renameInAST[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			var transformed = @:ast(switch (node.def) {
	case EVar(name):
		if (renameMap.exists(name)) {
			makeASTWithMeta(EVar(renameMap.get(name)), node.metadata, node.pos);
		} else {
			node;
		};	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(renameInPattern(pattern), renameInAST(expr)), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(renameInAST(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : renameInPattern(c.pattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) })), node.metadata, node.pos);	
	case EReceive(clauses, after):
		makeASTWithMeta(EReceive(clauses.map(function(c) ->  @:implicitReturn return { pattern : renameInPattern(c.pattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) }), after != null ? { timeout : renameInAST(after.timeout), body : renameInAST(after.body) } : null), node.metadata, node.pos);	
	case EFn(clauses):
		makeASTWithMeta(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args.map(renameInPattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) })), node.metadata, node.pos);	
	case _:
		transformAST(node, renameInAST);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECase(renameInAST[0](expr), {
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : renameInPattern[0](v.pattern), guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(renameInPattern[0](pattern), renameInAST[0](expr));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (renameMap.exists(name)) {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renameMap.get(name));
										var meta = node.metadata;
										var pos = node.pos;
										{def : def, metadata : meta, pos : pos};
									};
								} else {
									node;
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({args : {
													var _this = v.args;
													var f = renameInPattern[0];
													{
														var ` = [];
														{
															var ` = 0;
															var ` = _this;
															while ((` < `.length)) {
																var v = `[`];
																++ `;
																`.push(f(v));
															};
														};
														`;
													};
												}, guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 51: {
						var ` = `[0];
						var ` = `[1];
						{
							var clauses = `;
							var after = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EReceive({
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : renameInPattern[0](v.pattern), guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									}, if ((after != null)) {timeout : renameInAST[0](after.timeout), body : renameInAST[0](after.body)} else null);
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, renameInAST[0]);
					}
				};
			};
			return transformed;
		};
		return renameInAST[0](ast);
	}
}