class reflaxe.elixir.ast.ElixirASTBuilder {

	@:value(0)
	static var loopCounter:Int = 0;

	@:value(new Map())
	public static var tempVarRenameMap:Map<String, String> = {
		{};
		new haxe.ds.StringMap();
	};

	@:value(new Map())
	public static var functionParameterIds:Map<String, Bool> = {
		{};
		new haxe.ds.StringMap();
	};

	@:value(false)
	public static var isInClassMethodContext:Bool = false;

	@:value(null)
	public static var currentReceiverParamName:Null<String> = null;

	@:value(0)
	static var whileLoopCounter:Int = 0;

	@:value(null)
	public static var currentModule:String = null;

	@:value(null)
	public static var variableUsageMap:Null<Map<Int, Bool>> = null;

	@:value(null)
	public static var currentClauseContext:Null<reflaxe.elixir.ast.ClauseContext> = null;

	@:value(null) @:allow(reflaxe.elixir.ElixirCompiler) @:allow(reflaxe.elixir.ast.builders.ModuleBuilder)
	public static var compiler:reflaxe.elixir.ElixirCompiler = null;

	static function trackDependency(moduleName:String) {
		var builtins = ["Map", "Enum", "String", "Kernel", "List", "IO", "Process", "GenServer", "Supervisor", "Agent", "File", "Path", "System", "Code", "Module", "Application", "Integer", "Float", "Regex", "Date", "DateTime", "NaiveDateTime"];
		if (builtins.indexOf(moduleName, null) >= 0) {
			return;
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.compiler != null && reflaxe.elixir.ast.ElixirASTBuilder.compiler.currentCompiledModule != null) {
			var deps = {
				var this = reflaxe.elixir.ast.ElixirASTBuilder.compiler.moduleDependencies;
				var key = reflaxe.elixir.ast.ElixirASTBuilder.compiler.currentCompiledModule;
				cast this.get(key);
			};
			if (deps != null && moduleName != reflaxe.elixir.ast.ElixirASTBuilder.compiler.currentCompiledModule) {
				{
					deps.set(moduleName, true);
				};
			};
		};
	}

	static function replaceNullCoalVar(expr:haxe.macro.TypedExpr, varId:Int, initExpr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) if (v.id == varId):
		{ expr : TBinop(OpNullCoal, initExpr, defaultExpr), pos : expr.pos, t : expr.t };	
	case TVar(v, init) if (init != null):
		{ expr : TVar(v, replaceNullCoalVar(init, varId, initExpr)), pos : expr.pos, t : expr.t };	
	case TObjectDecl(fields):
		var newFields = [for (field  in  fields) { name : field.name, expr : replaceNullCoalVar(field.expr, varId, initExpr) }];
		{ expr : TObjectDecl(newFields), pos : expr.pos, t : expr.t };	
	case _:
		expr;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 24) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var defaultExpr = `;
									if (v.id == varId) {
										{expr : haxe.macro.TypedExprDef.TBinop(haxe.macro.Binop.OpNullCoal, initExpr, defaultExpr), pos : expr.pos, t : expr.t};
									} else {
										expr;
									};
								};
							} else {
								expr;
							};
						};
					} else {
						expr;
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							var newFields = {
								var ` = [];
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										`.push({name : field.name, expr : reflaxe.elixir.ast.ElixirASTBuilder.replaceNullCoalVar(field.expr, varId, initExpr)});
									};
								};
								`;
							};
							{expr : haxe.macro.TypedExprDef.TObjectDecl(newFields), pos : expr.pos, t : expr.t};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							{expr : haxe.macro.TypedExprDef.TVar(v, reflaxe.elixir.ast.ElixirASTBuilder.replaceNullCoalVar(init, varId, initExpr)), pos : expr.pos, t : expr.t};
						} else {
							expr;
						};
					};
				};
				default: {
					expr;
				}
			};
		};
	}

	public static function buildFromTypedExpr(expr:haxe.macro.TypedExpr, usageMap:Null<Map<Int, Bool>> = null) {
		if (usageMap != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap = usageMap;
		} else {
			if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap == null) {
				reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(expr);
			};
		};
		haxe.Log.trace("[XRay AST Builder] Converting TypedExpr: " + Std.string(expr.expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 272, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "buildFromTypedExpr"});
		if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap != null) {
			haxe.Log.trace("[XRay AST Builder] Using variable usage map with " + Lambda.count(cast reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap, null) + " entries", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 274, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "buildFromTypedExpr"});
		};
		var metadata = reflaxe.elixir.ast.ElixirASTBuilder.createMetadata(expr);
		var astDef = reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(expr);
		@:ast(switch (expr.expr) {
	case TCall(e, _) if (e != null && isEnumConstructor(e) && hasIdiomaticMetadata(e)):
		metadata.requiresIdiomaticTransform = true;
		metadata.idiomaticEnumType = getEnumTypeName(e);
		trace("[AST Builder] Marked direct enum constructor for transformer: ${getEnumTypeName(e)}");	
	case TCall(_, _):
		switch (expr.t) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				if (enumType.meta.has(":elixirIdiomatic")) {
					metadata.requiresIdiomaticTransform = true;
					metadata.idiomaticEnumType = enumType.name;
					trace("[AST Builder] Marked function return value as idiomatic enum: ${enumType.name}");
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					if (e != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e) && reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
						metadata.requiresIdiomaticTransform = true;
						metadata.idiomaticEnumType = reflaxe.elixir.ast.ElixirASTBuilder.getEnumTypeName(e);
						haxe.Log.trace("[AST Builder] Marked direct enum constructor for transformer: " + reflaxe.elixir.ast.ElixirASTBuilder.getEnumTypeName(e), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 289, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "buildFromTypedExpr"});
					} else {
						@:ast(switch (expr.t) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		if (enumType.meta.has(":elixirIdiomatic")) {
			metadata.requiresIdiomaticTransform = true;
			metadata.idiomaticEnumType = enumType.name;
			trace("[AST Builder] Marked function return value as idiomatic enum: ${enumType.name}");
		};	
	default:
}) {
							var ` = expr.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								var ` = `[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										if (enumType.meta.has(":elixirIdiomatic")) {
											metadata.requiresIdiomaticTransform = true;
											metadata.idiomaticEnumType = enumType.name;
											haxe.Log.trace("[AST Builder] Marked function return value as idiomatic enum: " + enumType.name, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 300, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "buildFromTypedExpr"});
										};
									};
								};
							} else {};
						};
					};
				};
			} else {};
		};
		var result = {def : astDef, metadata : metadata, pos : expr.pos};
		haxe.Log.trace("[XRay AST Builder] Generated AST: " + Std.string(astDef), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 311, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "buildFromTypedExpr"});
		return result;
	}

	static function convertExpression(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(TInt(i)):
		EInteger(i);	
	case TConst(TFloat(f)):
		EFloat(Std.parseFloat(f));	
	case TConst(TString(s)):
		EString(s);	
	case TConst(TBool(b)):
		EBoolean(b);	
	case TConst(TNull):
		ENil;	
	case TConst(TThis):
		var receiverName = if (currentReceiverParamName != null) {
			currentReceiverParamName;
		} else {
			"struct";
		};
		EVar(receiverName);	
	case TConst(TSuper):
		ENil;	
	case TLocal(v):
		var varName = v.name;
		if (currentClauseContext != null && currentClauseContext.localToName.exists(v.id)) {
			varName = currentClauseContext.localToName.get(v.id);
			trace("[AST Builder] TLocal: Using mapped name from ClauseContext: ${v.name} (id=${v.id}) -> ${varName}");
		} else if (currentClauseContext != null && v.name == "error") {
			trace("[AST Builder] TLocal: No mapping for ${v.name} (id=${v.id}). Available mappings: ${[for (k in currentClauseContext.localToName.keys()) k + \"->\" + currentClauseContext.localToName.get(k)].join(\", \")}");
		};
		var idKey = Std.string(v.id);
		var wasMapped = false;
		if (tempVarRenameMap.exists(idKey)) {
			varName = tempVarRenameMap.get(idKey);
			wasMapped = true;
		} else if (varName.charAt(0) == "_" && varName.charAt(1) != "g" && varName.length > 1) {
			varName = varName.substr(1);
		};
		var finalName = if (wasMapped) {
			varName;
		} else {
			var isUsed = if (variableUsageMap != null) {
				variableUsageMap.exists(v.id) && variableUsageMap.get(v.id);
			} else {
				true;
			};
			var preserveUnderscore = false;
			toElixirVarName(varName, preserveUnderscore);
		};
		var varNode = makeAST(EVar(finalName));
		if (varNode.metadata == null) varNode.metadata = { };
		varNode.metadata.sourceVarId = v.id;
		varNode.def;	
	case TVar(v, init):
		var isEnumExtraction = false;
		var extractedFromTemp = "";
		if (init != null) {
			switch (init.expr) {
				case TEnumParameter(_, _, _):
					isEnumExtraction = true;				
				case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)):
					extractedFromTemp = tempVar.name;				
				case _:
			};
		};
		var varName = v.name;
		var idKey = Std.string(v.id);
		var isUnused = false;
		var baseName = if (tempVarRenameMap.exists(idKey)) {
			tempVarRenameMap.get(idKey);
		} else {
			var isUsed = if (variableUsageMap != null) {
				variableUsageMap.exists(v.id) && variableUsageMap.get(v.id);
			} else {
				true;
			};
			if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
				toElixirVarName(varName, false);
			} else {
				toElixirVarName(varName, false);
			};
		};
		var isActuallyUsed = if (variableUsageMap != null && variableUsageMap.exists(v.id)) {
			variableUsageMap.get(v.id);
		} else {
			true;
		};
		var isEnumParameterExtraction = false;
		if (init != null) {
			switch (init.expr) {
				case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d*$/.match(tempVar.name)):
					isEnumParameterExtraction = true;				
				case _:
			};
		};
		var finalVarName = if (!isActuallyUsed && !isEnumParameterExtraction) {
			"_" + baseName;
		} else {
			baseName;
		};
		var matchNode = if (init != null) {
			var initValue = switch (init.expr) {
				case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var initAst = buildFromTypedExpr(tmpInit, variableUsageMap);
					var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					ifExpr;				
				case _:
					var builtInit = buildFromTypedExpr(init, variableUsageMap);
					builtInit;				
			};
			var result = makeAST(EMatch(PVar(finalVarName), initValue));
			result;
		} else {
			makeAST(EMatch(PVar(finalVarName), makeAST(ENil)));
		};
		matchNode.def;	
	case TBinop(op, e1, e2):
		var isNilComparison = switch (op) {
			case OpEq | OpNotEq:
				switch (e2.expr) {
					case TConst(TNull):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};
		var left = switch (e1.expr) {
			case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
				makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));			
			case TField(target, FAnon(cf)) if (isNilComparison):
				var targetAst = buildFromTypedExpr(target, variableUsageMap);
				var fieldName = toSnakeCase(cf.get().name);
				makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [targetAst, makeAST(EAtom(fieldName))]));			
			case _:
				buildFromTypedExpr(e1, variableUsageMap);			
		};
		var right = switch (e2.expr) {
			case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
				makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));			
			case _:
				buildFromTypedExpr(e2, variableUsageMap);			
		};
		switch (op) {
			case OpAdd:
				var isStringConcat = switch (e1.t) {
					case TInst(_.get() => { name : "String" }, _):
						true;					
					case TAbstract(_.get() => { name : "String" }, _):
						true;					
					default:
						false;					
				};
				if (isStringConcat) {
					var rightStr = switch (e2.t) {
						case TInst(_.get() => { name : "String" }, _):
							right;						
						case TAbstract(_.get() => { name : "String" }, _):
							right;						
						default:
							makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [right]));						
					};
					EBinary(StringConcat, left, rightStr);
				} else {
					EBinary(Add, left, right);
				};			
			case OpSub:
				EBinary(Subtract, left, right);			
			case OpMult:
				EBinary(Multiply, left, right);			
			case OpDiv:
				EBinary(Divide, left, right);			
			case OpMod:
				EBinary(Remainder, left, right);			
			case OpEq:
				EBinary(Equal, left, right);			
			case OpNotEq:
				EBinary(NotEqual, left, right);			
			case OpLt:
				EBinary(Less, left, right);			
			case OpLte:
				EBinary(LessEqual, left, right);			
			case OpGt:
				EBinary(Greater, left, right);			
			case OpGte:
				EBinary(GreaterEqual, left, right);			
			case OpBoolAnd:
				EBinary(AndAlso, left, right);			
			case OpBoolOr:
				EBinary(OrElse, left, right);			
			case OpAssign:
				EMatch(extractPattern(e1), right);			
			case OpAssignOp(op2):
				var innerOp = if (op2 == OpAdd) {
					var isStringConcat = switch (e1.t) {
						case TInst(_.get() => { name : "String" }, _):
							true;						
						case TAbstract(_.get() => { name : "String" }, _):
							true;						
						default:
							false;						
					};
					isStringConcat ? StringConcat : Add;
				} else {
					convertAssignOp(op2);
				};
				EMatch(extractPattern(e1), makeAST(EBinary(innerOp, left, right)));			
			case OpAnd:
				EBinary(BitwiseAnd, left, right);			
			case OpOr:
				EBinary(BitwiseOr, left, right);			
			case OpXor:
				EBinary(BitwiseXor, left, right);			
			case OpShl:
				EBinary(ShiftLeft, left, right);			
			case OpShr:
				EBinary(ShiftRight, left, right);			
			case OpUShr:
				EBinary(ShiftRight, left, right);			
			case OpInterval:
				ERange(left, makeAST(EBinary(Subtract, right, makeAST(EInteger(1)))), false);			
			case OpArrow:
				EFn([{ args : [PVar("_arrow")], body : right }]);			
			case OpIn:
				EBinary(In, left, right);			
			case OpNullCoal:
				var isSimple = switch (left.def) {
					case EVar(_):
						true;					
					case ENil:
						true;					
					case EBoolean(_):
						true;					
					case EInteger(_):
						true;					
					case EString(_):
						true;					
					case _:
						false;					
				};
				if (isSimple) {
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, left, makeAST(ENil))), left, right));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					ifExpr.def;
				} else {
					var tmpVar = makeAST(EVar("tmp"));
					var assignment = makeAST(EMatch(PVar("tmp"), left));
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, assignment, makeAST(ENil))), tmpVar, right));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					ifExpr.def;
				};			
		};	
	case TUnop(op, postFix, e):
		switch (op) {
			case OpNot:
				switch (e.expr) {
					case TBlock([]):
						EUnary(Not, makeAST(ENil));					
					case TBlock(exprs) if (exprs.length == 1):
						EUnary(Not, buildFromTypedExpr(exprs[0], variableUsageMap));					
					case TBlock(exprs):
						var statements = [];
						for (i  in  0 ... exprs.length - 1) {
							statements.push(buildFromTypedExpr(exprs[i], variableUsageMap));
						};
						var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], variableUsageMap);
						statements.push(makeAST(EUnary(Not, lastExpr)));
						EBlock(statements);					
					default:
						var expr = buildFromTypedExpr(e, variableUsageMap).def;
						EUnary(Not, makeAST(expr));					
				};			
			case OpNeg:
				var expr = buildFromTypedExpr(e, variableUsageMap).def;
				EUnary(Negate, makeAST(expr));			
			case OpNegBits:
				var expr = buildFromTypedExpr(e, variableUsageMap).def;
				EUnary(BitwiseNot, makeAST(expr));			
			case OpIncrement, OpDecrement:
				var one = makeAST(EInteger(1));
				var builtExpr = buildFromTypedExpr(e, variableUsageMap);
				var operation = if (op == OpIncrement) {
					makeAST(EBinary(Add, builtExpr, one));
				} else {
					makeAST(EBinary(Subtract, builtExpr, one));
				};
				switch (e.expr) {
					case TLocal(v):
						EBinary(Match, builtExpr, operation);					
					default:
						operation.def;					
				};			
			case OpSpread:
				var builtExpr = buildFromTypedExpr(e, variableUsageMap);
				EUnquoteSplicing(builtExpr);			
		};	
	case TCall(e, el):
		if (e != null && isEnumConstructor(e)) {
			var tag = extractEnumTag(e);
			if (hasIdiomaticMetadata(e)) {
				tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
			};
			var args = [for (arg  in  el) buildFromTypedExpr(arg, variableUsageMap)];
			var tupleDef = ETuple([makeAST(EAtom(tag))].concat(args));
			if (hasIdiomaticMetadata(e)) {
				trace("[AST Builder] Building idiomatic enum tuple: ${tag} with ${args.length} args");
				trace("[AST Builder] Enum type: ${getEnumTypeName(e)}");
			};
			tupleDef;
		} else {
			var args = [];
			for (arg  in  el) {
				var isFunctionRef = false;
				switch (arg.expr) {
					case TField(_, FStatic(classRef, cf)):
						switch (cf.get().type) {
							case TFun(funcArgs, _):
								isFunctionRef = true;
								var target = buildFromTypedExpr(arg, variableUsageMap);
								switch (target.def) {
									case EField(module, funcName):
										var arity = funcArgs.length;
										args.push(makeAST(ECapture(target, arity)));									
									default:
										args.push(target);									
								};							
							default:
								args.push(buildFromTypedExpr(arg, variableUsageMap));							
						};					
					default:
						args.push(buildFromTypedExpr(arg, variableUsageMap));					
				};
			};
			if (e != null) {
				switch (e.expr) {
					case TField(_, FStatic(classRef, cf)):
						var classType = classRef.get();
						var methodName = cf.get().name;
						if (currentModule != null && classType.name == currentModule) {
							var elixirMethodName = toSnakeCase(methodName);
							return ECall(null, elixirMethodName, args);
						};
						if (classType.name == "Reflect") {
							switch (methodName) {
								case "hasField":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										trackDependency("Map");
										return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
									};								
								case "field":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										trackDependency("Map");
										return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
									};								
								case "setField":
									if (args.length == 3) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var value = args[2];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
									};								
								case "fields":
									if (args.length == 1) {
										return ERemoteCall(makeAST(EVar("Map")), "keys", args);
									};								
								case "isObject":
									if (args.length == 1) {
										return ECall(null, "is_map", args);
									};								
								case "deleteField":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
									};								
								case "copy":
									if (args.length == 1) {
										return args[0].def;
									};								
								case "compare":
									if (args.length == 2) {
										var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
										var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
										var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
										var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
										var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
										return ECond([ltClause, gtClause, trueClause]);
									};								
								case "isEnumValue":
									if (args.length == 1) {
										var isTuple = ECall(null, "is_tuple", args);
										var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
										var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
										return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
									};								
								case "callMethod":
									if (args.length == 3) {
										return ECall(null, "apply", [args[1], args[2]]);
									};								
								default:
							};
						};
						if (classType.meta.has(":native")) {
							var nativeModuleName = "";
							var nativeMeta = classType.meta.extract(":native");
							if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
								switch (nativeMeta[0].params[0].expr) {
									case EConst(CString(s, _)):
										nativeModuleName = s;									
									default:
								};
							};
							if (nativeModuleName != "") {
								var elixirMethodName = toSnakeCase(methodName);
								trackDependency(nativeModuleName);
								return ERemoteCall(makeAST(EVar(nativeModuleName)), elixirMethodName, args);
							};
						} else {
							var moduleName = classType.name;
							trackDependency(moduleName);
							if (compiler != null && classType.pack.length > 0) {
								compiler.modulePackages.set(moduleName, classType.pack);
							};
						};					
					default:
				};
			};
			var target = e != null ? buildFromTypedExpr(e, variableUsageMap) : null;
			switch (e.expr) {
				case TIdent("__elixir__"):
					if (args.length > 0) {
						switch (args[0].def) {
							case EString(code):
								var processedCode = code;
								if (args.length > 1) {
									for (i  in  1 ... args.length) {
										var paramStr = ElixirASTPrinter.printAST(args[i]);
										var placeholder = "{${i-1}}";
										processedCode = StringTools.replace(processedCode, placeholder, paramStr);
									};
								};
								ERaw(processedCode);							
							default:
								ECall(target, "call", args);							
						};
					} else {
						ECall(target, "call", args);
					};				
				case TField(obj, fa):
					var fieldName = extractFieldName(fa);
					fieldName = toSnakeCase(fieldName);
					var objAst = buildFromTypedExpr(obj, variableUsageMap);
					var typeModule = getExternNativeModuleNameFromType(obj.t);
					if (typeModule != null) {
						trackDependency(typeModule);
						return ERemoteCall(makeAST(EVar(typeModule)), fieldName, [objAst].concat(args));
					};
					switch (fa) {
						case FInstance(cRef, _, cfRef):
							var cls = cRef.get();
							if (cls.isExtern && cls.meta.has(":native")) {
								var nativeMeta = cls.meta.extract(":native");
								var moduleName:Null<String> = null;
								if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
									switch (nativeMeta[0].params[0].expr) {
										case EConst(CString(s, _)):
											moduleName = s;										
										default:
									};
								};
								if (moduleName != null) {
									var methodName = fieldName;
									var cf = cfRef.get();
									if (cf.meta.has(":native")) {
										var mMeta = cf.meta.extract(":native");
										if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
											switch (mMeta[0].params[0].expr) {
												case EConst(CString(ns, _)):
													methodName = toSnakeCase(ns);												
												default:
											};
										};
									};
									trackDependency(moduleName);
									return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
								};
							};						
						default:
					};
					if (fieldName == "elem" && args.length == 1) {
						return ECall(null, "elem", [objAst, args[0]]);
					};
					if (isAssertClass(obj)) {
						var assertAst = reflaxe.elixir.ast.builders.ExUnitCompiler.compileAssertion(fieldName, args);
						return assertAst.def;
					} else if (fieldName == "hxx" && isHXXModule(obj)) {
						if (args.length == 1) {
							var templateContent = collectTemplateContent(args[0]);
							ESigil("H", templateContent, "");
						} else {
							ECall(objAst, fieldName, args);
						};
					} else if (isModuleCall(obj)) {
						var hasNativeMetadata = false;
						var nativeName:String = null;
						switch (fa) {
							case FStatic(_, cf):
								var classField = cf.get();
								if (classField.meta.has(":native")) {
									var nativeMeta = classField.meta.extract(":native");
									if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
										switch (nativeMeta[0].params[0].expr) {
											case EConst(CString(s, _)):
												hasNativeMetadata = true;
												nativeName = s;											
											default:
										};
									};
								};							
							default:
						};
						if (hasNativeMetadata && nativeName != null) {
							var parts = nativeName.split(".");
							if (parts.length > 1) {
								var module = parts.slice(0, parts.length - 1).join(".");
								var funcName = parts[parts.length - 1];
								trackDependency(module);
								ERemoteCall(makeAST(EVar(module)), funcName, args);
							} else {
								ERemoteCall(objAst, nativeName, args);
							};
						} else {
							var elixirFuncName = toSnakeCase(fieldName);
							ERemoteCall(objAst, elixirFuncName, args);
						};
					} else {
						var methodHasElixirInjection = false;
						var expandedElixir:ElixirAST = null;
						switch (fa) {
							case FInstance(_, _, cf):
								var classField = cf.get();
								var methodExpr = classField.expr();
								trace("[AST Builder] Checking method ${fieldName}, has expr: ${methodExpr != null}");
								if (methodExpr != null) {
									expandedElixir = tryExpandElixirInjection(methodExpr, obj, el);
									methodHasElixirInjection = (expandedElixir != null);
									trace("[AST Builder] Method ${fieldName} has __elixir__: $methodHasElixirInjection");
								};							
							default:
						};
						if (methodHasElixirInjection && expandedElixir != null) {
							return expandedElixir.def;
						} else if (isArrayType(obj.t)) {
							switch (fieldName) {
								case "filter" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);								
								case "map" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);								
								case "push" if (args.length == 1):
									EBinary(Concat, objAst, makeAST(EList([args[0]])));								
								default:
									ECall(objAst, fieldName, args);								
							};
						} else if (isMapType(obj.t)) {
							switch (fieldName) {
								case "set" if (args.length == 2):
									ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args));								
								case "get" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));								
								case "remove" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));								
								case "exists" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));								
								case "keys" if (args.length == 0):
									ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);								
								case "values" if (args.length == 0):
									ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);								
								default:
									ECall(objAst, fieldName, args);								
							};
						} else {
							ECall(objAst, fieldName, args);
						};
					};				
				case TLocal(v):
					var isFunctionVar = switch (v.t) {
						case TFun(_, _):
							true;						
						case TAbstract(t, params):
							var abs = t.get();
							if (abs.name == "Function" || abs.name == "Fn") {
								true;
							} else if (abs.name == "Null" && params.length == 1) {
								switch (params[0]) {
									case TFun(_, _):
										true;									
									default:
										false;									
								};
							} else {
								false;
							};						
						default:
							false;						
					};
					if (isFunctionVar) {
						ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
					} else {
						ECall(null, toElixirVarName(v.name), args);
					};				
				default:
					if (target != null) {
						ECall(target, "call", args);
					} else {
						ECall(null, "unknown_call", args);
					};				
			};
		};	
	case TField(e, fa):
		switch (fa) {
			case FEnum(enumType, ef):
				var enumT = enumType.get();
				if (enumT.meta.has(":elixirIdiomatic")) {
					var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
					EAtom(atomName);
				} else {
					var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
					ETuple([makeAST(EAtom(atomName))]);
				};			
			case FStatic(classRef, cf):
				var className = classRef.get().name;
				var fieldName = extractFieldName(fa);
				fieldName = toSnakeCase(fieldName);
				if (false) {
					EVar(fieldName);
				} else {
					var target = buildFromTypedExpr(e, variableUsageMap);
					EField(target, fieldName);
				};			
			case FAnon(cf):
				var fieldName = cf.get().name;
				var target = buildFromTypedExpr(e, variableUsageMap);
				if (~/^_\d+$/.match(fieldName)) {
					var index = Std.parseInt(fieldName.substr(1)) - 1;
					ECall(null, "elem", [target, makeAST(EInteger(index))]);
				} else {
					fieldName = toSnakeCase(fieldName);
					EField(target, fieldName);
				};			
			default:
				var target = buildFromTypedExpr(e, variableUsageMap);
				var fieldName = extractFieldName(fa);
				var originalFieldName = fieldName;
				fieldName = toSnakeCase(fieldName);
				if (fieldName == "elem") {
					EField(target, fieldName);
				} else if (isMapAccess(e.t)) {
					EAccess(target, makeAST(EAtom(fieldName)));
				} else {
					EField(target, fieldName);
				};			
		};	
	case TArrayDecl(el):
		trace("[AST Builder] TArrayDecl with ${el.length} elements");
		if (el.length > 0) {
			trace("[AST Builder] First element type: ${Type.enumConstructor(el[0].expr)}");
		};
		if (el.length == 1 && el[0].expr.match(TFor(_))) {
			trace("[AST Builder] Detected array comprehension, treating as EFor instead of EList");
			buildFromTypedExpr(el[0], variableUsageMap).def;
		} else if (el.length == 1) {
			switch (el[0].expr) {
				case TBlock(stmts):
					var comprehension = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
					if (comprehension != null) {
						switch (comprehension.def) {
							case EFor(_, _, _, _, _):
								trace("[AST Builder] Detected desugared comprehension in single-element array, treating as EFor");
								comprehension.def;							
							default:
								EList([buildFromTypedExpr(el[0], variableUsageMap)]);							
						};
					} else {
						EList([buildFromTypedExpr(el[0], variableUsageMap)]);
					};				
				default:
					EList([buildFromTypedExpr(el[0], variableUsageMap)]);				
			};
		} else {
			var hasIdiomaticEnums = false;
			for (e  in  el) {
				switch (e.expr) {
					case TCall(callTarget, _) if (callTarget != null && isEnumConstructor(callTarget) && hasIdiomaticMetadata(callTarget)):
						hasIdiomaticEnums = true;
						break;					
					case TCall(_, _):
						switch (e.t) {
							case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
								hasIdiomaticEnums = true;
								break;							
							default:
						};					
					default:
				};
			};
			if (hasIdiomaticEnums) {
				trace("[AST Builder] Building array with idiomatic enum elements");
			};
			var elements = [];
			for (e  in  el) {
				switch (e.expr) {
					case TBlock(stmts):
						var comprehension = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
						if (comprehension != null) {
							elements.push(comprehension);
						} else if (looksLikeListBuildingBlock(stmts)) {
							trace("[AST Builder] Found list-building block in array element, converting to nested list");
							var nestedElements = extractListElements(stmts);
							if (nestedElements != null && nestedElements.length > 0) {
								var nestedList = [for (ne  in  nestedElements) buildFromTypedExpr(ne, variableUsageMap)];
								elements.push(makeAST(EList(nestedList)));
							} else {
								trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function");
								var blockAst = buildFromTypedExpr(e, variableUsageMap);
								var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
								var anonymousFn = makeAST(EFn([fnClause]));
								var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
								elements.push(wrappedBlock);
							};
						} else {
							trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function");
							var blockAst = buildFromTypedExpr(e, variableUsageMap);
							var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
							var anonymousFn = makeAST(EFn([fnClause]));
							var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
							elements.push(wrappedBlock);
						};					
					default:
						elements.push(buildFromTypedExpr(e, variableUsageMap));					
				};
			};
			EList(elements);
		};	
	case TArray(e, index):
		var target = buildFromTypedExpr(e, variableUsageMap);
		var key = buildFromTypedExpr(index, variableUsageMap);
		EAccess(target, key);	
	case TIf(econd, eif, eelse):
		var condition = switch (econd.expr) {
			case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
				makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));			
			case _:
				buildFromTypedExpr(econd, variableUsageMap);			
		};
		var thenBranch = buildFromTypedExpr(eif, variableUsageMap);
		var elseBranch = eelse != null ? buildFromTypedExpr(eelse, variableUsageMap) : null;
		EIf(condition, thenBranch, elseBranch);	
	case TBlock(el):
		var comprehension = tryBuildArrayComprehensionFromBlock(el, variableUsageMap);
		if (comprehension != null) {
			trace("[AST Builder] Successfully reconstructed array comprehension from imperative block");
			comprehension.def;
		};
		if (el.length >= 5) {
			var hasEmptyArray = false;
			var hasZeroInit = false;
			var hasSourceAssign = false;
			var hasWhileLoop = false;
			var returnsResult = false;
			var sourceArray:TypedExpr = null;
			var whileBody:TypedExpr = null;
			var resultVarName:String = null;
			for (i  in  0 ... el.length) {
				switch (el[i].expr) {
					case TVar(v, init) if (init != null && v.name.startsWith("_g")):
						switch (init.expr) {
							case TArrayDecl([]):
								hasEmptyArray = true;
								resultVarName = v.name;							
							case TConst(TInt(i)) if (i == 0):
								hasZeroInit = true;							
							case TLocal(_):
								hasSourceAssign = true;
								sourceArray = init;							
							case _:
						};					
					case TWhile(_, body, _):
						hasWhileLoop = true;
						whileBody = body;					
					case TLocal(v) if (v.name == resultVarName && i == el.length - 1):
						returnsResult = true;					
					case _:
				};
			};
			var isArrayPattern = hasEmptyArray && hasZeroInit && hasSourceAssign && hasWhileLoop && returnsResult;
			if (isArrayPattern && sourceArray != null && whileBody != null) {
				var operation = ElixirASTPatterns.detectArrayOperationPattern(whileBody);
				if (operation != null) {
					return generateIdiomaticEnumCall(sourceArray, operation, whileBody);
				};
			};
		};
		if (el.length == 2) {
			switch ([el[0].expr, el[1].expr]) {
				case [TVar(tmpVar, init), TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr)] if (v.id == tmpVar.id && init != null):
					var initAst = buildFromTypedExpr(init, variableUsageMap);
					var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					return ifExpr.def;				
				case _:
			};
		};
		if (ElixirASTPatterns.isInlineExpansionBlock(el)) {
			return ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name));
		};
		trace("[AST Builder] Checking if block with ${el.length} statements is list-building");
		if (looksLikeListBuildingBlock(el)) {
			trace("[AST Builder] Detected list-building block, converting to EList");
			var listElements = extractListElements(el);
			if (listElements != null && listElements.length > 0) {
				var elements = [for (e  in  listElements) buildFromTypedExpr(e, variableUsageMap)];
				return EList(elements);
			};
		} else {
			if (el.length > 0 && el.length < 10) {
				trace("[AST Builder] Not a list-building block. First stmt: ${el[0].expr}");
				if (el.length > 1) trace("[AST Builder] Second stmt: ${el[1].expr}");
			};
		};
		if (el.length == 2) {
			switch ([el[0].expr, el[1].expr]) {
				case [TVar(v, init), expr] if (init != null):
					var isUsed = if (variableUsageMap != null && variableUsageMap.exists(v.id)) {
						variableUsageMap.get(v.id);
					} else {
						true;
					};
					var baseName = toElixirVarName(v.name);
					var varName = if (!isUsed) {
						"_" + baseName;
					} else {
						baseName;
					};
					var initExpr = buildFromTypedExpr(init, variableUsageMap);
					var bodyExpr = buildFromTypedExpr(el[1], variableUsageMap);
					var isInCaseClause = currentClauseContext != null;
					if (!isInCaseClause) {
						var usageCount = countVarOccurrencesInAST(bodyExpr, varName);
						if (usageCount == 1) {
							var inlined = replaceVarInAST(bodyExpr, varName, initExpr);
							return inlined.def;
						};
					};
					return EBlock([makeAST(EMatch(PVar(varName), initExpr)), bodyExpr]);				
				default:
			};
		};
		var expressions = [for (e  in  el) buildFromTypedExpr(e, variableUsageMap)];
		var needsCombining = false;
		for (i  in  0 ... expressions.length - 1) {
			var current = expressions[i];
			var next = expressions[i + 1];
			switch ([current.def, next.def]) {
				case [EMatch(_, _), ECall(_, _, _)]:
					needsCombining = true;
					break;				
				case _:
			};
		};
		if (needsCombining) {
			var combinedBlock = makeAST(EBlock(expressions));
			var transformed = reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass(combinedBlock);
			transformed.def;
		} else {
			EBlock(expressions);
		};	
	case TReturn(e):
		if (e != null) {
			buildFromTypedExpr(e, variableUsageMap).def;
		} else {
			ENil;
		};	
	case TBreak:
		EThrow(makeAST(EAtom(ElixirAtom.raw("break"))));	
	case TContinue:
		EThrow(makeAST(EAtom(ElixirAtom.raw("continue"))));	
	case TSwitch(e, cases, edef):
		function extractEnumTypeFromSwitch(expr:TypedExpr):Null<EnumType> {
			return switch (expr.expr) {
				case TParenthesis(innerExpr):
					extractEnumTypeFromSwitch(innerExpr);				
				case TMeta(_, innerExpr):
					extractEnumTypeFromSwitch(innerExpr);				
				case TEnumIndex(enumExpr):
					switch (enumExpr.t) {
						case TEnum(enumRef, _):
							enumRef.get();						
						default:
							null;						
					};				
				default:
					switch (expr.t) {
						case TEnum(enumRef, _):
							enumRef.get();						
						default:
							null;						
					};				
			};
		};
		var enumType = extractEnumTypeFromSwitch(e);
		var isIdiomaticEnum = enumType != null;
		var expr = buildFromTypedExpr(e, variableUsageMap).def;
		var clauses = [];
		var needsTempVar = false;
		var tempVarName = "temp_result";
		var isReturnContext = false;
		for (c  in  cases) {
			var extractedParams = analyzeEnumParameterExtraction(c.expr);
			var varMapping = createVariableMappingsForCase(c.expr, extractedParams, enumType, c.values);
			var patterns = if (isIdiomaticEnum && enumType != null) {
				[for (v  in  c.values) convertIdiomaticEnumPatternWithExtraction(v, enumType, extractedParams)];
			} else {
				[for (v  in  c.values) convertPattern(v)];
			};
			var savedClauseContext = currentClauseContext;
			currentClauseContext = new ClauseContext(null, varMapping);
			var body = buildFromTypedExpr(c.expr, variableUsageMap);
			if (body.metadata == null) body.metadata = { };
			body.metadata.varIdToName = varMapping;
			currentClauseContext = savedClauseContext;
			for (pattern  in  patterns) {
				clauses.push({ pattern : pattern, guard : null, body : body });
			};
		};
		if (edef != null) {
			clauses.push({ pattern : PWildcard, guard : null, body : buildFromTypedExpr(edef, variableUsageMap) });
		};
		var caseASTDef = ECase(makeAST(expr), clauses);
		if (isReturnContext && needsTempVar) {
			EBlock([makeAST(EMatch(PVar(tempVarName), makeAST(caseASTDef))), makeAST(EVar(tempVarName))]);
		} else {
			caseASTDef;
		};	
	case TTry(e, catches):
		var body = buildFromTypedExpr(e);
		var rescueClauses = [];
		for (c  in  catches) {
			var pattern = PVar(toElixirVarName(c.v.name));
			var catchBody = buildFromTypedExpr(c.expr);
			rescueClauses.push({ pattern : pattern, body : catchBody });
		};
		ETry(body, rescueClauses, [], null, null);	
	case TFunction(f):
		var fluentPattern = detectFluentAPIPattern(f);
		var args = [];
		var paramRenaming = new Map<String,String>();
		var oldTempVarRenameMap = tempVarRenameMap;
		tempVarRenameMap = new Map();
		for (key  in  oldTempVarRenameMap.keys()) {
			tempVarRenameMap.set(key, oldTempVarRenameMap.get(key));
		};
		var isFirstParam = true;
		for (arg  in  f.args) {
			var originalName = arg.v.name;
			var idKey = Std.string(arg.v.id);
			var isActuallyUnused = if (f.expr != null) {
				reflaxe.elixir.helpers.UsageDetector.isParameterUnused(arg.v, f.expr);
			} else {
				false;
			};
			var baseName = ElixirASTHelpers.toElixirVarName(originalName);
			var finalName = if (isActuallyUnused && !baseName.startsWith("_")) {
				"_" + baseName;
			} else {
				baseName;
			};
			if (!tempVarRenameMap.exists(idKey)) {
				tempVarRenameMap.set(idKey, finalName);
			};
			if (originalName != finalName) {
				paramRenaming.set(originalName, finalName);
			};
			if (originalName == "this1") {
				paramRenaming.set("this", finalName);
			};
			if (isFirstParam && isInClassMethodContext) {
				currentReceiverParamName = finalName;
				isFirstParam = false;
			};
			args.push(PVar(finalName));
			functionParameterIds.set(idKey, true);
		};
		var functionUsageMap = if (f.expr != null) {
			reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(f.expr);
		} else {
			null;
		};
		var body = buildFromTypedExpr(f.expr, functionUsageMap);
		tempVarRenameMap = oldTempVarRenameMap;
		for (arg  in  f.args) {
			functionParameterIds.remove(Std.string(arg.v.id));
		};
		if (paramRenaming.keys().hasNext()) {
			body = applyParameterRenaming(body, paramRenaming);
		};
		var fnAst = makeAST(EFn([{ args : args, guard : null, body : body }]));
		if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
			fnAst.metadata.isFluentMethod = true;
			fnAst.metadata.returnsThis = fluentPattern.returnsThis;
			if (fluentPattern.fieldMutations.length > 0) {
				fnAst.metadata.mutatesFields = [];
				fnAst.metadata.fieldMutations = [];
				for (mutation  in  fluentPattern.fieldMutations) {
					fnAst.metadata.mutatesFields.push(mutation.field);
					fnAst.metadata.fieldMutations.push({ field : mutation.field, expr : buildFromTypedExpr(mutation.expr, functionUsageMap) });
				};
			};
		};
		fnAst.def;	
	case TObjectDecl(fields):
		var isTuplePattern = true;
		var maxTupleIndex = 0;
		for (field  in  fields) {
			if (!~/^_\d+$/.match(field.name)) {
				isTuplePattern = false;
				break;
			};
			var index = Std.parseInt(field.name.substr(1));
			if (index > maxTupleIndex) {
				maxTupleIndex = index;
			};
		};
		if (isTuplePattern && fields.length > 0) {
			var sortedFields = fields.copy();
			sortedFields.sort(function(a, b) {
				var aIndex = Std.parseInt(a.name.substr(1));
				var bIndex = Std.parseInt(b.name.substr(1));
				return aIndex - bIndex;
			});
			var tupleElements = [];
			for (field  in  sortedFields) {
				tupleElements.push(buildFromTypedExpr(field.expr));
			};
			return ETuple(tupleElements);
		};
		var hasStrategy = false;
		var hasMaxRestarts = false;
		var hasMaxSeconds = false;
		var hasId = false;
		var hasStart = false;
		var hasType = false;
		for (field  in  fields) {
			switch (field.name) {
				case "strategy":
					hasStrategy = true;				
				case "max_restarts":
					hasMaxRestarts = true;				
				case "max_seconds":
					hasMaxSeconds = true;				
				case "id":
					hasId = true;				
				case "start":
					hasStart = true;				
				case "type":
					hasType = true;				
				case _:
			};
		};
		if (hasStrategy && (hasMaxRestarts || hasMaxSeconds)) {
			var keywordPairs:Array<EKeywordPair> = [];
			for (field  in  fields) {
				var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
				var fieldValue = buildFromTypedExpr(field.expr);
				keywordPairs.push({ key : atomName, value : fieldValue });
			};
			EKeywordList(keywordPairs);
		} else if (hasId && hasStart) {
			var pairs = [];
			for (field  in  fields) {
				var atomName = toSnakeCase(field.name);
				var key = makeAST(EAtom(atomName));
				var fieldValue = if (field.name == "start") {
					switch (field.expr.expr) {
						case TObjectDecl(startFields):
							var moduleField = null;
							var funcField = null;
							var argsField = null;
							for (sf  in  startFields) {
								switch (sf.name) {
									case "module":
										moduleField = sf;									
									case "func":
										funcField = sf;									
									case "args":
										argsField = sf;									
									case _:
								};
							};
							if (moduleField != null && funcField != null && argsField != null) {
								var moduleAst = switch (moduleField.expr.expr) {
									case TConst(TString(s)):
										makeAST(EVar(s));									
									case _:
										buildFromTypedExpr(moduleField.expr);									
								};
								var funcAst = switch (funcField.expr.expr) {
									case TConst(TString(s)):
										makeAST(EAtom(s));									
									case _:
										buildFromTypedExpr(funcField.expr);									
								};
								var argsAst = buildFromTypedExpr(argsField.expr);
								makeAST(ETuple([moduleAst, funcAst, argsAst]));
							} else {
								buildFromTypedExpr(field.expr);
							};						
						case _:
							buildFromTypedExpr(field.expr);						
					};
				} else if (field.name == "type" || field.name == "restart" || field.name == "shutdown") {
					switch (field.expr.expr) {
						case TConst(TString(s)):
							makeAST(EAtom(s));						
						case _:
							buildFromTypedExpr(field.expr);						
					};
				} else {
					buildFromTypedExpr(field.expr);
				};
				pairs.push({ key : key, value : fieldValue });
			};
			EMap(pairs);
		} else {
			var pairs = [];
			for (field  in  fields) {
				var atomName = toSnakeCase(field.name);
				var key = makeAST(EAtom(atomName));
				var fieldValue = switch (field.expr.expr) {
					case TBlock([{ expr : TVar(tmpVar, init) }, { expr : TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) }]) if (v.id == tmpVar.id && init != null):
						var initAst = buildFromTypedExpr(init, variableUsageMap);
						var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
						var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
						var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
						if (ifExpr.metadata == null) ifExpr.metadata = { };
						ifExpr.metadata.keepInlineInAssignment = true;
						ifExpr;					
					case _:
						buildFromTypedExpr(field.expr);					
				};
				pairs.push({ key : key, value : fieldValue });
			};
			EMap(pairs);
		};	
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		var isNativeModule = switch (m) {
			case TClassDecl(c):
				var cl = c.get();
				if (cl.isExtern && cl.meta.has(":native")) {
					var nativeMeta = cl.meta.extract(":native");
					if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
						switch (nativeMeta[0].params[0].expr) {
							case EConst(CString(s, _)):
								moduleName = s;
								true;							
							default:
								false;							
						};
					} else {
						false;
					};
				} else {
					false;
				};			
			default:
				false;			
		};
		EVar(moduleName);	
	case TCast(e, m):
		buildFromTypedExpr(e).def;	
	case TParenthesis(e):
		EParen(buildFromTypedExpr(e));	
	case TMeta(m, e):
		if (m.name == ":mergeBlock") {
			switch (e.expr) {
				case TBlock([{ expr : TVar(tmpVar, init) }, secondExpr]) if (init != null):
					switch (secondExpr.expr) {
						case TIf(condition, thenBranch, elseBranch):
							var isNullCheck = switch (condition.expr) {
								case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
									v.id == tmpVar.id;								
								default:
									false;								
							};
							if (isNullCheck) {
								var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
								var initAst = buildFromTypedExpr(init, variableUsageMap);
								var elseAst = buildFromTypedExpr(elseBranch);
								var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
								if (ifExpr.metadata == null) ifExpr.metadata = { };
								ifExpr.metadata.keepInlineInAssignment = true;
								return ifExpr.def;
							};						
						default:
					};				
				default:
			};
		};
		buildFromTypedExpr(e).def;	
	case TNew(c, _, el):
		var classType = c.get();
		var className = classType.name;
		var args = [for (e  in  el) buildFromTypedExpr(e)];
		if (className == "StringMap" || className == "Map" || className.endsWith("Map")) {
			EMap([]);
		} else {
			var hasInstanceMethods = false;
			for (field  in  classType.fields.get()) {
				if (field.kind.match(FMethod(_))) {
					var isStatic = false;
					for (staticField  in  classType.statics.get()) {
						if (staticField.name == field.name) {
							isStatic = true;
							break;
						};
					};
					if (!isStatic) {
						hasInstanceMethods = true;
						break;
					};
				};
			};
			var hasConstructor = classType.constructor != null;
			if (hasInstanceMethods || hasConstructor) {
				var moduleRef = makeAST(EVar(className));
				ECall(moduleRef, "new", args);
			} else {
				EStruct(className, []);
			};
		};	
	case TFor(v, e1, e2):
		var elixirVarName = toElixirVarName(v.name);
		var idKey = Std.string(v.id);
		var oldMapping = tempVarRenameMap.get(idKey);
		if (v.name != elixirVarName) {
			tempVarRenameMap.set(idKey, elixirVarName);
		};
		var pattern = PVar(elixirVarName);
		var expr = buildFromTypedExpr(e1);
		var body = buildFromTypedExpr(e2);
		if (oldMapping != null) {
			tempVarRenameMap.set(idKey, oldMapping);
		} else {
			tempVarRenameMap.remove(idKey);
		};
		EFor([{ pattern : pattern, expr : expr }], [], body, null, false);	
	case TWhile(econd, e, normalWhile):
		var isArrayLoop = false;
		var arrayRef:TypedExpr = null;
		switch (econd.expr) {
			case TBinop(OpLt, { expr : TLocal(indexVar) }, { expr : TField(arr, FInstance(_, _, cf)) }) if (indexVar.name.startsWith("_g") && cf.get().name == "length"):
				isArrayLoop = true;
				arrayRef = arr;			
			case _:
		};
		if (isArrayLoop && arrayRef != null) {
			var pattern = ElixirASTPatterns.detectArrayOperationPattern(e);
			if (pattern != null) {
				return generateIdiomaticEnumCall(arrayRef, pattern, e);
			};
		};
		var condition = buildFromTypedExpr(econd);
		var body = buildFromTypedExpr(e);
		var loopName = "loop_" + (whileLoopCounter++);
		var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(e);
		var conditionVars = new Map<Int,TVar>();
		function findConditionVars(expr:TypedExpr):Void {
			if (expr == null) return;
			switch (expr.expr) {
				case TLocal(v):
					conditionVars.set(v.id, v);				
				default:
					haxe.macro.TypedExprTools.iter(expr, findConditionVars);				
			};
		};
		findConditionVars(econd);
		for (v  in  conditionVars) {
			if (!mutatedVars.exists(v.id)) {
				mutatedVars.set(v.id, v);
			};
		};
		if (Lambda.count(mutatedVars) > 0) {
			var accVarList:Array<{ var name : String; var tvar : TVar}> = [];
			for (v  in  mutatedVars) {
				accVarList.push({ name : toElixirVarName(v.name), tvar : v });
			};
			accVarList.sort(function(a, b) ->  @:implicitReturn return a.tvar.id - b.tvar.id);
			var initialAccValues:Array<ElixirAST> = [];
			var accPattern:Array<EPattern> = [];
			var accVarNames:Array<String> = [];
			for (v  in  accVarList) {
				var varName = v.name;
				initialAccValues.push(makeAST(EVar(varName)));
				accPattern.push(PVar("acc_" + varName));
				accVarNames.push(varName);
			};
			initialAccValues.push(makeAST(EAtom(ElixirAtom.ok())));
			accPattern.push(PVar("acc_state"));
			var initialAccumulator = makeAST(ETuple(initialAccValues));
			var accPatternTuple = PTuple(accPattern);
			var contAccValues:Array<ElixirAST> = [];
			for (varName  in  accVarNames) {
				contAccValues.push(makeAST(EVar(varName)));
			};
			contAccValues.push(makeAST(EVar("acc_state")));
			var contAccumulator = makeAST(ETuple(contAccValues));
			var varMapping = new Map<String,String>();
			for (varName  in  accVarNames) {
				varMapping.set(varName, "acc_" + varName);
			};
			var transformedCondition = transformVariableReferences(condition, varMapping);
			var transformedBody = transformVariableReferences(body, varMapping);
			var bodyHasReturn = checkForEarlyReturns(transformedBody);
			var updatedContAccValues:Array<ElixirAST> = [];
			for (varName  in  accVarNames) {
				updatedContAccValues.push(makeAST(EVar("acc_" + varName)));
			};
			updatedContAccValues.push(makeAST(EVar("acc_state")));
			var updatedContAccumulator = makeAST(ETuple(updatedContAccValues));
			var wrappedBody = if (bodyHasReturn) {
				transformReturnsToHalts(transformedBody, updatedContAccumulator);
			} else {
				makeAST(EBlock([transformedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]))]));
			};
			var completeBody = makeAST(EIf(transformedCondition, wrappedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), updatedContAccumulator]))));
			var usedAccVars = new Map<String,Bool>();
			for (varName  in  accVarNames) {
				var accVarName = "acc_" + varName;
				usedAccVars.set(varName, isVariableUsedInAST(accVarName, completeBody));
			};
			var isAccStateUsed = isVariableUsedInAST("acc_state", completeBody);
			var finalAccPattern:Array<EPattern> = [];
			for (i  in  0 ... accVarNames.length) {
				var varName = accVarNames[i];
				var accVarName = "acc_" + varName;
				if (usedAccVars.get(varName)) {
					finalAccPattern.push(PVar(accVarName));
				} else {
					finalAccPattern.push(PVar("_" + accVarName));
				};
			};
			if (isAccStateUsed) {
				finalAccPattern.push(PVar("acc_state"));
			} else {
				finalAccPattern.push(PVar("_acc_state"));
			};
			var finalAccPatternTuple = PTuple(finalAccPattern);
			var reduceResult = ERemoteCall(makeAST(EVar("Enum")), "reduce_while", [makeAST(ERemoteCall(makeAST(EVar("Stream")), "iterate", [makeAST(EInteger(0)), makeAST(EFn([{ args : [PVar("n")], guard : null, body : makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1)))) }]))])), initialAccumulator, {
				var isEmptyBody = switch (transformedBody.def) {
					case ENil:
						true;					
					case _:
						false;					
				};
				var accPatternToUse = if (isEmptyBody && Lambda.count(mutatedVars) > 0) {
					var wildcardPatterns:Array<EPattern> = [];
					for (i  in  0 ... (accVarNames.length + 1)) {
						wildcardPatterns.push(PWildcard);
					};
					PTuple(wildcardPatterns);
				} else {
					finalAccPatternTuple;
				};
				makeAST(EFn([{ args : [PWildcard, accPatternToUse], guard : null, body : {
					var updatedContAccValues:Array<ElixirAST> = [];
					for (varName  in  accVarNames) {
						updatedContAccValues.push(makeAST(EVar("acc_" + varName)));
					};
					updatedContAccValues.push(makeAST(EVar("acc_state")));
					var updatedContAccumulator = makeAST(ETuple(updatedContAccValues));
					var wrappedBody = if (bodyHasReturn) {
						transformReturnsToHalts(transformedBody, updatedContAccumulator);
					} else if (isEmptyBody) {
						makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]));
					} else {
						makeAST(EBlock([transformedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]))]));
					};
					makeAST(EIf(transformedCondition, wrappedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), if (isEmptyBody) makeAST(EAtom(ElixirAtom.ok())) else updatedContAccumulator]))));
				} }]));
			}]);
			reduceResult;
		} else {
			ERemoteCall(makeAST(EVar("Enum")), "reduce_while", [makeAST(ERemoteCall(makeAST(EVar("Stream")), "iterate", [makeAST(EInteger(0)), makeAST(EFn([{ args : [PVar("n")], guard : null, body : makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1)))) }]))])), makeAST(EAtom(ElixirAtom.ok())), makeAST(EFn([{ args : [PWildcard, PVar("acc")], guard : null, body : makeAST(EIf(condition, makeAST(EBlock([body, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), makeAST(EVar("acc"))]))])), makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), makeAST(EVar("acc"))])))) }]))]);
		};	
	case TThrow(e):
		EThrow(buildFromTypedExpr(e));	
	case TEnumParameter(e, ef, index):
		var exprAST = buildFromTypedExpr(e);
		var field = ef.name;
		ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]);	
	case TEnumIndex(e):
		buildFromTypedExpr(e, variableUsageMap).def;	
	case TIdent(s):
		EVar(toElixirVarName(s));	
}) {
			var ` = expr.expr;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					switch (@:exhaustive enumIndex `) {
						case 0: {
							var ` = `[0];
							{
								var i = `;
								{
									reflaxe.elixir.ast.ElixirASTDef.EInteger(i);
								};
							};
						};
						case 1: {
							var ` = `[0];
							{
								var f = `;
								{
									reflaxe.elixir.ast.ElixirASTDef.EFloat(Std.parseFloat(f));
								};
							};
						};
						case 2: {
							var ` = `[0];
							{
								var s = `;
								{
									reflaxe.elixir.ast.ElixirASTDef.EString(s);
								};
							};
						};
						case 3: {
							var ` = `[0];
							{
								var b = `;
								{
									reflaxe.elixir.ast.ElixirASTDef.EBoolean(b);
								};
							};
						};
						case 4: {
							{
								reflaxe.elixir.ast.ElixirASTDef.ENil;
							};
						};
						case 5: {
							{
								var receiverName = if (reflaxe.elixir.ast.ElixirASTBuilder.currentReceiverParamName != null) {
									reflaxe.elixir.ast.ElixirASTBuilder.currentReceiverParamName;
								} else {
									"struct";
								};
								reflaxe.elixir.ast.ElixirASTDef.EVar(receiverName);
							};
						};
						case 6: {
							{
								reflaxe.elixir.ast.ElixirASTDef.ENil;
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							var varName = v.name;
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext.localToName;
								var key = v.id;
								cast this.exists(key);
							}) {
								varName = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext.localToName;
									var key = v.id;
									cast this.get(key);
								};
								haxe.Log.trace("[AST Builder] TLocal: Using mapped name from ClauseContext: " + v.name + " (id=" + v.id + ") -> " + varName, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 369, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							} else {
								if (reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext != null && v.name == "error") {
									haxe.Log.trace("[AST Builder] TLocal: No mapping for " + v.name + " (id=" + v.id + "). Available mappings: " + {
										var ` = [];
										for (k in {
											var this = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext.localToName;
											cast this.keys();
										}) {
											`.push(k + "->" + {
												var this = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext.localToName;
												cast this.get(k);
											});
										};
										`;
									}.join(", "), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 372, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								};
							};
							var idKey = Std.string(v.id);
							var wasMapped = false;
							if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								varName = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									cast this.get(idKey);
								};
								wasMapped = true;
							} else {
								if (varName.charAt(0) == "_" && varName.charAt(1) != "g" && varName.length > 1) {
									varName = varName.substr(1, null);
								};
							};
							var finalName = if (wasMapped) {
								varName;
							} else {
								var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap != null) {
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
										var key = v.id;
										cast this.exists(key);
									} && {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
										var key = v.id;
										cast this.get(key);
									};
								} else {
									true;
								};
								var preserveUnderscore = false;
								reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(varName, preserveUnderscore);
							};
							var varNode = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(finalName), metadata : {}, pos : pos};
							};
							if (varNode.metadata == null) {
								varNode.metadata = {};
							};
							varNode.metadata.sourceVarId = v.id;
							varNode.def;
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var index = `;
						{
							var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
							var key = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(index, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
							reflaxe.elixir.ast.ElixirASTDef.EAccess(target, key);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var e1 = `;
						var e2 = `;
						{
							var isNilComparison = @:ast(switch (op) {
	case OpEq | OpNotEq:
		switch (e2.expr) {
			case TConst(TNull):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) switch (enumIndex op) {
								case 5, 6: {
									{
										@:ast(switch (e2.expr) {
	case TConst(TNull):
		true;	
	default:
		false;	
}) {
											var ` = e2.expr;
											if (enumIndex ` == 0) {
												var ` = `[0];
												if (enumIndex ` == 4) {
													{
														true;
													};
												} else {
													false;
												};
											} else {
												false;
											};
										};
									};
								};
								default: {
									false;
								}
							};
							var left = @:ast(switch (e1.expr) {
	case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
		makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));	
	case TField(target, FAnon(cf)) if (isNilComparison):
		var targetAst = buildFromTypedExpr(target, variableUsageMap);
		var fieldName = toSnakeCase(cf.get().name);
		makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [targetAst, makeAST(EAtom(fieldName))]));	
	case _:
		buildFromTypedExpr(e1, variableUsageMap);	
}) {
								var ` = e1.expr;
								switch (enumIndex `) {
									case 4: {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 2) {
											var ` = `[0];
											{
												var cf = `;
												var target = `;
												if (isNilComparison) {
													var targetAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(target, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
													var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(cf.get().name);
													{
														var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
														}, "get", [targetAst, {
															var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																var this;
																this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																cast this;
															});
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}]);
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													};
												} else {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										};
									};
									case 14: {
										var ` = `[0];
										{
											var el = `;
											if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
												{
													var def = reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) {
														return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
													}, function(name:String) {
														return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null);
													});
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												};
											} else {
												reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
											};
										};
									};
									default: {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
									}
								};
							};
							var right = @:ast(switch (e2.expr) {
	case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
		makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));	
	case _:
		buildFromTypedExpr(e2, variableUsageMap);	
}) {
								var ` = e2.expr;
								if (enumIndex ` == 14) {
									var ` = `[0];
									{
										var el = `;
										if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
											{
												var def = reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) {
													return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												}, function(name:String) {
													return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null);
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										};
									};
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
								};
							};
							@:ast(switch (op) {
	case OpAdd:
		var isStringConcat = switch (e1.t) {
			case TInst(_.get() => { name : "String" }, _):
				true;			
			case TAbstract(_.get() => { name : "String" }, _):
				true;			
			default:
				false;			
		};
		if (isStringConcat) {
			var rightStr = switch (e2.t) {
				case TInst(_.get() => { name : "String" }, _):
					right;				
				case TAbstract(_.get() => { name : "String" }, _):
					right;				
				default:
					makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [right]));				
			};
			EBinary(StringConcat, left, rightStr);
		} else {
			EBinary(Add, left, right);
		};	
	case OpSub:
		EBinary(Subtract, left, right);	
	case OpMult:
		EBinary(Multiply, left, right);	
	case OpDiv:
		EBinary(Divide, left, right);	
	case OpMod:
		EBinary(Remainder, left, right);	
	case OpEq:
		EBinary(Equal, left, right);	
	case OpNotEq:
		EBinary(NotEqual, left, right);	
	case OpLt:
		EBinary(Less, left, right);	
	case OpLte:
		EBinary(LessEqual, left, right);	
	case OpGt:
		EBinary(Greater, left, right);	
	case OpGte:
		EBinary(GreaterEqual, left, right);	
	case OpBoolAnd:
		EBinary(AndAlso, left, right);	
	case OpBoolOr:
		EBinary(OrElse, left, right);	
	case OpAssign:
		EMatch(extractPattern(e1), right);	
	case OpAssignOp(op2):
		var innerOp = if (op2 == OpAdd) {
			var isStringConcat = switch (e1.t) {
				case TInst(_.get() => { name : "String" }, _):
					true;				
				case TAbstract(_.get() => { name : "String" }, _):
					true;				
				default:
					false;				
			};
			isStringConcat ? StringConcat : Add;
		} else {
			convertAssignOp(op2);
		};
		EMatch(extractPattern(e1), makeAST(EBinary(innerOp, left, right)));	
	case OpAnd:
		EBinary(BitwiseAnd, left, right);	
	case OpOr:
		EBinary(BitwiseOr, left, right);	
	case OpXor:
		EBinary(BitwiseXor, left, right);	
	case OpShl:
		EBinary(ShiftLeft, left, right);	
	case OpShr:
		EBinary(ShiftRight, left, right);	
	case OpUShr:
		EBinary(ShiftRight, left, right);	
	case OpInterval:
		ERange(left, makeAST(EBinary(Subtract, right, makeAST(EInteger(1)))), false);	
	case OpArrow:
		EFn([{ args : [PVar("_arrow")], body : right }]);	
	case OpIn:
		EBinary(In, left, right);	
	case OpNullCoal:
		var isSimple = switch (left.def) {
			case EVar(_):
				true;			
			case ENil:
				true;			
			case EBoolean(_):
				true;			
			case EInteger(_):
				true;			
			case EString(_):
				true;			
			case _:
				false;			
		};
		if (isSimple) {
			var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, left, makeAST(ENil))), left, right));
			if (ifExpr.metadata == null) ifExpr.metadata = { };
			ifExpr.metadata.keepInlineInAssignment = true;
			ifExpr.def;
		} else {
			var tmpVar = makeAST(EVar("tmp"));
			var assignment = makeAST(EMatch(PVar("tmp"), left));
			var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, assignment, makeAST(ENil))), tmpVar, right));
			if (ifExpr.metadata == null) ifExpr.metadata = { };
			ifExpr.metadata.keepInlineInAssignment = true;
			ifExpr.def;
		};	
}) switch (@:exhaustive enumIndex op) {
								case 0: {
									{
										var isStringConcat = @:ast(switch (e1.t) {
	case TInst(_.get() => { name : "String" }, _):
		true;	
	case TAbstract(_.get() => { name : "String" }, _):
		true;	
	default:
		false;	
}) {
											var ` = e1.t;
											switch (enumIndex `) {
												case 2: {
													var ` = `[0];
													var ` = `[1];
													{
														var _hx_tmp;
														{
															var ` = (_hx_tmp = `.get()).constructor;
															var ` = _hx_tmp.doc;
															var ` = _hx_tmp.fields;
															var ` = _hx_tmp.init;
															var ` = _hx_tmp.interfaces;
															var ` = _hx_tmp.isAbstract;
															var ` = _hx_tmp.isExtern;
															var ` = _hx_tmp.isFinal;
															var ` = _hx_tmp.isInterface;
															var ` = _hx_tmp.isPrivate;
															var ` = _hx_tmp.kind;
															var ` = _hx_tmp.meta;
															var ` = _hx_tmp.module;
															var ` = _hx_tmp.name;
															var ` = _hx_tmp.overrides;
															var ` = _hx_tmp.pack;
															var ` = _hx_tmp.params;
															var ` = _hx_tmp.pos;
															var ` = _hx_tmp.statics;
															var ` = _hx_tmp.superClass;
															if (` == "String") {
																{
																	true;
																};
															} else {
																false;
															};
														};
													};
												};
												case 8: {
													var ` = `[0];
													var ` = `[1];
													{
														var _hx_tmp;
														{
															var ` = (_hx_tmp = `.get()).array;
															var ` = _hx_tmp.binops;
															var ` = _hx_tmp.doc;
															var ` = _hx_tmp.from;
															var ` = _hx_tmp.impl;
															var ` = _hx_tmp.isExtern;
															var ` = _hx_tmp.isPrivate;
															var ` = _hx_tmp.meta;
															var ` = _hx_tmp.module;
															var ` = _hx_tmp.name;
															var ` = _hx_tmp.pack;
															var ` = _hx_tmp.params;
															var ` = _hx_tmp.pos;
															var ` = _hx_tmp.resolve;
															var ` = _hx_tmp.resolveWrite;
															var ` = _hx_tmp.to;
															var ` = _hx_tmp.type;
															var ` = _hx_tmp.unops;
															if (` == "String") {
																{
																	true;
																};
															} else {
																false;
															};
														};
													};
												};
												default: {
													false;
												}
											};
										};
										if (isStringConcat) {
											var rightStr = @:ast(switch (e2.t) {
	case TInst(_.get() => { name : "String" }, _):
		right;	
	case TAbstract(_.get() => { name : "String" }, _):
		right;	
	default:
		makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [right]));	
}) {
												var ` = e2.t;
												switch (enumIndex `) {
													case 2: {
														var ` = `[0];
														var ` = `[1];
														{
															var _hx_tmp;
															{
																var ` = (_hx_tmp = `.get()).constructor;
																var ` = _hx_tmp.doc;
																var ` = _hx_tmp.fields;
																var ` = _hx_tmp.init;
																var ` = _hx_tmp.interfaces;
																var ` = _hx_tmp.isAbstract;
																var ` = _hx_tmp.isExtern;
																var ` = _hx_tmp.isFinal;
																var ` = _hx_tmp.isInterface;
																var ` = _hx_tmp.isPrivate;
																var ` = _hx_tmp.kind;
																var ` = _hx_tmp.meta;
																var ` = _hx_tmp.module;
																var ` = _hx_tmp.name;
																var ` = _hx_tmp.overrides;
																var ` = _hx_tmp.pack;
																var ` = _hx_tmp.params;
																var ` = _hx_tmp.pos;
																var ` = _hx_tmp.statics;
																var ` = _hx_tmp.superClass;
																if (` == "String") {
																	{
																		right;
																	};
																} else {
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																		}, "to_string", [right]), metadata : {}, pos : pos};
																	};
																};
															};
														};
													};
													case 8: {
														var ` = `[0];
														var ` = `[1];
														{
															var _hx_tmp;
															{
																var ` = (_hx_tmp = `.get()).array;
																var ` = _hx_tmp.binops;
																var ` = _hx_tmp.doc;
																var ` = _hx_tmp.from;
																var ` = _hx_tmp.impl;
																var ` = _hx_tmp.isExtern;
																var ` = _hx_tmp.isPrivate;
																var ` = _hx_tmp.meta;
																var ` = _hx_tmp.module;
																var ` = _hx_tmp.name;
																var ` = _hx_tmp.pack;
																var ` = _hx_tmp.params;
																var ` = _hx_tmp.pos;
																var ` = _hx_tmp.resolve;
																var ` = _hx_tmp.resolveWrite;
																var ` = _hx_tmp.to;
																var ` = _hx_tmp.type;
																var ` = _hx_tmp.unops;
																if (` == "String") {
																	{
																		right;
																	};
																} else {
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																		}, "to_string", [right]), metadata : {}, pos : pos};
																	};
																};
															};
														};
													};
													default: {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
															}, "to_string", [right]), metadata : {}, pos : pos};
														};
													}
												};
											};
											reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.StringConcat, left, rightStr);
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, left, right);
										};
									};
								};
								case 1: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Multiply, left, right);
									};
								};
								case 2: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Divide, left, right);
									};
								};
								case 3: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, left, right);
									};
								};
								case 4: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.ElixirASTBuilder.extractPattern(e1), right);
									};
								};
								case 5: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, left, right);
									};
								};
								case 6: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, left, right);
									};
								};
								case 7: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Greater, left, right);
									};
								};
								case 8: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.GreaterEqual, left, right);
									};
								};
								case 9: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Less, left, right);
									};
								};
								case 10: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.LessEqual, left, right);
									};
								};
								case 11: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.BitwiseAnd, left, right);
									};
								};
								case 12: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.BitwiseOr, left, right);
									};
								};
								case 13: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.BitwiseXor, left, right);
									};
								};
								case 14: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.AndAlso, left, right);
									};
								};
								case 15: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.OrElse, left, right);
									};
								};
								case 16: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.ShiftLeft, left, right);
									};
								};
								case 17: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.ShiftRight, left, right);
									};
								};
								case 18: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.ShiftRight, left, right);
									};
								};
								case 19: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Remainder, left, right);
									};
								};
								case 20: {
									var ` = op[0];
									{
										var op2 = `;
										{
											var innerOp = if (op2 == haxe.macro.Binop.OpAdd) {
												var isStringConcat = @:ast(switch (e1.t) {
	case TInst(_.get() => { name : "String" }, _):
		true;	
	case TAbstract(_.get() => { name : "String" }, _):
		true;	
	default:
		false;	
}) {
													var ` = e1.t;
													switch (enumIndex `) {
														case 2: {
															var ` = `[0];
															var ` = `[1];
															{
																var _hx_tmp;
																{
																	var ` = (_hx_tmp = `.get()).constructor;
																	var ` = _hx_tmp.doc;
																	var ` = _hx_tmp.fields;
																	var ` = _hx_tmp.init;
																	var ` = _hx_tmp.interfaces;
																	var ` = _hx_tmp.isAbstract;
																	var ` = _hx_tmp.isExtern;
																	var ` = _hx_tmp.isFinal;
																	var ` = _hx_tmp.isInterface;
																	var ` = _hx_tmp.isPrivate;
																	var ` = _hx_tmp.kind;
																	var ` = _hx_tmp.meta;
																	var ` = _hx_tmp.module;
																	var ` = _hx_tmp.name;
																	var ` = _hx_tmp.overrides;
																	var ` = _hx_tmp.pack;
																	var ` = _hx_tmp.params;
																	var ` = _hx_tmp.pos;
																	var ` = _hx_tmp.statics;
																	var ` = _hx_tmp.superClass;
																	if (` == "String") {
																		{
																			true;
																		};
																	} else {
																		false;
																	};
																};
															};
														};
														case 8: {
															var ` = `[0];
															var ` = `[1];
															{
																var _hx_tmp;
																{
																	var ` = (_hx_tmp = `.get()).array;
																	var ` = _hx_tmp.binops;
																	var ` = _hx_tmp.doc;
																	var ` = _hx_tmp.from;
																	var ` = _hx_tmp.impl;
																	var ` = _hx_tmp.isExtern;
																	var ` = _hx_tmp.isPrivate;
																	var ` = _hx_tmp.meta;
																	var ` = _hx_tmp.module;
																	var ` = _hx_tmp.name;
																	var ` = _hx_tmp.pack;
																	var ` = _hx_tmp.params;
																	var ` = _hx_tmp.pos;
																	var ` = _hx_tmp.resolve;
																	var ` = _hx_tmp.resolveWrite;
																	var ` = _hx_tmp.to;
																	var ` = _hx_tmp.type;
																	var ` = _hx_tmp.unops;
																	if (` == "String") {
																		{
																			true;
																		};
																	} else {
																		false;
																	};
																};
															};
														};
														default: {
															false;
														}
													};
												};
												if (isStringConcat) {
													reflaxe.elixir.ast.EBinaryOp.StringConcat;
												} else {
													reflaxe.elixir.ast.EBinaryOp.Add;
												};
											} else {
												reflaxe.elixir.ast.ElixirASTBuilder.convertAssignOp(op2);
											};
											reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.ElixirASTBuilder.extractPattern(e1), {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(innerOp, left, right), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 21: {
									{
										reflaxe.elixir.ast.ElixirASTDef.ERange(left, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, right, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										}, false);
									};
								};
								case 22: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("_arrow")], body : right}]);
									};
								};
								case 23: {
									{
										reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.In, left, right);
									};
								};
								case 24: {
									{
										var isSimple = @:ast(switch (left.def) {
	case EVar(_):
		true;	
	case ENil:
		true;	
	case EBoolean(_):
		true;	
	case EInteger(_):
		true;	
	case EString(_):
		true;	
	case _:
		false;	
}) {
											var ` = left.def;
											switch (enumIndex `) {
												case 32: {
													var ` = `[0];
													{
														true;
													};
												};
												case 33: {
													var ` = `[0];
													{
														true;
													};
												};
												case 35: {
													var ` = `[0];
													{
														true;
													};
												};
												case 36: {
													{
														true;
													};
												};
												case 38: {
													var ` = `[0];
													{
														true;
													};
												};
												default: {
													false;
												}
											};
										};
										if (isSimple) {
											var ifExpr = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, left, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
													}), metadata : {}, pos : pos};
												}, left, right), metadata : {}, pos : pos};
											};
											if (ifExpr.metadata == null) {
												ifExpr.metadata = {};
											};
											ifExpr.metadata.keepInlineInAssignment = true;
											ifExpr.def;
										} else {
											var tmpVar = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("tmp"), metadata : {}, pos : pos};
											};
											var assignment = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("tmp"), left), metadata : {}, pos : pos};
											};
											var ifExpr = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, assignment, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
													}), metadata : {}, pos : pos};
												}, tmpVar, right), metadata : {}, pos : pos};
											};
											if (ifExpr.metadata == null) {
												ifExpr.metadata = {};
											};
											ifExpr.metadata.keepInlineInAssignment = true;
											ifExpr.def;
										};
									};
								};
							};
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var fa = `;
						{
							@:ast(switch (fa) {
	case FEnum(enumType, ef):
		var enumT = enumType.get();
		if (enumT.meta.has(":elixirIdiomatic")) {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			EAtom(atomName);
		} else {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			ETuple([makeAST(EAtom(atomName))]);
		};	
	case FStatic(classRef, cf):
		var className = classRef.get().name;
		var fieldName = extractFieldName(fa);
		fieldName = toSnakeCase(fieldName);
		if (false) {
			EVar(fieldName);
		} else {
			var target = buildFromTypedExpr(e, variableUsageMap);
			EField(target, fieldName);
		};	
	case FAnon(cf):
		var fieldName = cf.get().name;
		var target = buildFromTypedExpr(e, variableUsageMap);
		if (~/^_\d+$/.match(fieldName)) {
			var index = Std.parseInt(fieldName.substr(1)) - 1;
			ECall(null, "elem", [target, makeAST(EInteger(index))]);
		} else {
			fieldName = toSnakeCase(fieldName);
			EField(target, fieldName);
		};	
	default:
		var target = buildFromTypedExpr(e, variableUsageMap);
		var fieldName = extractFieldName(fa);
		var originalFieldName = fieldName;
		fieldName = toSnakeCase(fieldName);
		if (fieldName == "elem") {
			EField(target, fieldName);
		} else if (isMapAccess(e.t)) {
			EAccess(target, makeAST(EAtom(fieldName)));
		} else {
			EField(target, fieldName);
		};	
}) switch (enumIndex fa) {
								case 1: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var classRef = `;
										var cf = `;
										{
											var className = classRef.get().name;
											var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
											fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
											if (false) {
												reflaxe.elixir.ast.ElixirASTDef.EVar(fieldName);
											} else {
												var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
											};
										};
									};
								};
								case 2: {
									var ` = fa[0];
									{
										var cf = `;
										{
											var fieldName = cf.get().name;
											var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
											if (new EReg("^_\\d+$", "").match(fieldName)) {
												var index = Std.parseInt(fieldName.substr(1, null)) - 1;
												reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index), metadata : {}, pos : pos};
												}]);
											} else {
												fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
												reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
											};
										};
									};
								};
								case 5: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var enumType = `;
										var ef = `;
										{
											var enumT = enumType.get();
											if (enumT.meta.has(":elixirIdiomatic")) {
												var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
												reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast cast this;
												});
											} else {
												var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
												reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
														var this;
														this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
														cast this;
													});
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												}]);
											};
										};
									};
								};
								default: {
									var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
									var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
									var originalFieldName = fieldName;
									fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
									if (fieldName == "elem") {
										reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
									} else {
										if (reflaxe.elixir.ast.ElixirASTBuilder.isMapAccess(e.t)) {
											reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											});
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
										};
									};
								}
							};
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						var m = `;
						{
							var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
							var isNativeModule = @:ast(switch (m) {
	case TClassDecl(c):
		var cl = c.get();
		if (cl.isExtern && cl.meta.has(":native")) {
			var nativeMeta = cl.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						moduleName = s;
						true;					
					default:
						false;					
				};
			} else {
				false;
			};
		} else {
			false;
		};	
	default:
		false;	
}) if (enumIndex m == 0) {
								var ` = m[0];
								{
									var c = `;
									{
										var cl = c.get();
										if (cl.isExtern && cl.meta.has(":native")) {
											var nativeMeta = cl.meta.extract(":native");
											if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
												@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		moduleName = s;
		true;	
	default:
		false;	
}) {
													var ` = nativeMeta[0].params[0].expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															var ` = `[1];
															{
																var s = `;
																{
																	moduleName = s;
																	true;
																};
															};
														} else {
															false;
														};
													} else {
														false;
													};
												};
											} else {
												false;
											};
										} else {
											false;
										};
									};
								};
							} else {
								false;
							};
							reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName);
						};
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null));
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							var isTuplePattern = true;
							var maxTupleIndex = 0;
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									if (! new EReg("^_\\d+$", "").match(field.name)) {
										isTuplePattern = false;
										break;
									};
									var index = Std.parseInt(field.name.substr(1, null));
									if (index > maxTupleIndex) {
										maxTupleIndex = index;
									};
								};
							};
							if (isTuplePattern && fields.length > 0) {
								var sortedFields = fields.copy();
								sortedFields.sort(function(a:{ name : String, expr : haxe.macro.TypedExpr }, b:{ name : String, expr : haxe.macro.TypedExpr }) {
									var aIndex = Std.parseInt(a.name.substr(1, null));
									var bIndex = Std.parseInt(b.name.substr(1, null));
									return aIndex - bIndex;
								});
								var tupleElements = [];
								{
									var ` = 0;
									while (` < sortedFields.length) {
										var field = sortedFields[`];
										++ `;
										tupleElements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null));
									};
								};
								return reflaxe.elixir.ast.ElixirASTDef.ETuple(tupleElements);
							};
							var hasStrategy = false;
							var hasMaxRestarts = false;
							var hasMaxSeconds = false;
							var hasId = false;
							var hasStart = false;
							var hasType = false;
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									@:ast(switch (field.name) {
	case "strategy":
		hasStrategy = true;	
	case "max_restarts":
		hasMaxRestarts = true;	
	case "max_seconds":
		hasMaxSeconds = true;	
	case "id":
		hasId = true;	
	case "start":
		hasStart = true;	
	case "type":
		hasType = true;	
	case _:
}) {
										var ` = field.name;
										switch (`) {
											case "id": {
												{
													hasId = true;
												};
											};
											case "max_restarts": {
												{
													hasMaxRestarts = true;
												};
											};
											case "max_seconds": {
												{
													hasMaxSeconds = true;
												};
											};
											case "start": {
												{
													hasStart = true;
												};
											};
											case "strategy": {
												{
													hasStrategy = true;
												};
											};
											case "type": {
												{
													hasType = true;
												};
											};
											default: {}
										};
									};
								};
							};
							if (hasStrategy && (hasMaxRestarts || hasMaxSeconds)) {
								var keywordPairs = [];
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
										var fieldValue = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
										keywordPairs.push({key : atomName, value : fieldValue});
									};
								};
								reflaxe.elixir.ast.ElixirASTDef.EKeywordList(keywordPairs);
							} else {
								if (hasId && hasStart) {
									var pairs = [];
									{
										var ` = 0;
										while (` < fields.length) {
											var field = fields[`];
											++ `;
											var atomName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(field.name);
											var key = {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
											var fieldValue = if (field.name == "start") {
												@:ast(switch (field.expr.expr) {
	case TObjectDecl(startFields):
		var moduleField = null;
		var funcField = null;
		var argsField = null;
		for (sf  in  startFields) {
			switch (sf.name) {
				case "module":
					moduleField = sf;				
				case "func":
					funcField = sf;				
				case "args":
					argsField = sf;				
				case _:
			};
		};
		if (moduleField != null && funcField != null && argsField != null) {
			var moduleAst = switch (moduleField.expr.expr) {
				case TConst(TString(s)):
					makeAST(EVar(s));				
				case _:
					buildFromTypedExpr(moduleField.expr);				
			};
			var funcAst = switch (funcField.expr.expr) {
				case TConst(TString(s)):
					makeAST(EAtom(s));				
				case _:
					buildFromTypedExpr(funcField.expr);				
			};
			var argsAst = buildFromTypedExpr(argsField.expr);
			makeAST(ETuple([moduleAst, funcAst, argsAst]));
		} else {
			buildFromTypedExpr(field.expr);
		};	
	case _:
		buildFromTypedExpr(field.expr);	
}) {
													var ` = field.expr.expr;
													if (enumIndex ` == 7) {
														var ` = `[0];
														{
															var startFields = `;
															{
																var moduleField = null;
																var funcField = null;
																var argsField = null;
																{
																	var ` = 0;
																	while (` < startFields.length) {
																		var sf = startFields[`];
																		++ `;
																		@:ast(switch (sf.name) {
	case "module":
		moduleField = sf;	
	case "func":
		funcField = sf;	
	case "args":
		argsField = sf;	
	case _:
}) {
																			var ` = sf.name;
																			switch (`) {
																				case "args": {
																					{
																						argsField = sf;
																					};
																				};
																				case "func": {
																					{
																						funcField = sf;
																					};
																				};
																				case "module": {
																					{
																						moduleField = sf;
																					};
																				};
																				default: {}
																			};
																		};
																	};
																};
																if (moduleField != null && funcField != null && argsField != null) {
																	var moduleAst = @:ast(switch (moduleField.expr.expr) {
	case TConst(TString(s)):
		makeAST(EVar(s));	
	case _:
		buildFromTypedExpr(moduleField.expr);	
}) {
																		var ` = moduleField.expr.expr;
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			if (enumIndex ` == 2) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(s), metadata : {}, pos : pos};
																						};
																					};
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(moduleField.expr, null);
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(moduleField.expr, null);
																		};
																	};
																	var funcAst = @:ast(switch (funcField.expr.expr) {
	case TConst(TString(s)):
		makeAST(EAtom(s));	
	case _:
		buildFromTypedExpr(funcField.expr);	
}) {
																		var ` = funcField.expr.expr;
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			if (enumIndex ` == 2) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						{
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						};
																					};
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(funcField.expr, null);
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(funcField.expr, null);
																		};
																	};
																	var argsAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(argsField.expr, null);
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([moduleAst, funcAst, argsAst]), metadata : {}, pos : pos};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
																};
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
													};
												};
											} else {
												if (field.name == "type" || field.name == "restart" || field.name == "shutdown") {
													@:ast(switch (field.expr.expr) {
	case TConst(TString(s)):
		makeAST(EAtom(s));	
	case _:
		buildFromTypedExpr(field.expr);	
}) {
														var ` = field.expr.expr;
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (enumIndex ` == 2) {
																var ` = `[0];
																{
																	var s = `;
																	{
																		{
																			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																				var this;
																				this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																				cast this;
																			});
																			var pos = null;
																			{def : def, metadata : {}, pos : pos};
																		};
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
														};
													};
												} else {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
												};
											};
											pairs.push({key : key, value : fieldValue});
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EMap(pairs);
								} else {
									var pairs = [];
									{
										var ` = 0;
										while (` < fields.length) {
											var field = fields[`];
											++ `;
											var atomName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(field.name);
											var key = {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
											var fieldValue = @:ast(switch (field.expr.expr) {
	case TBlock([{ expr : TVar(tmpVar, init) }, { expr : TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) }]) if (v.id == tmpVar.id && init != null):
		var initAst = buildFromTypedExpr(init, variableUsageMap);
		var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		ifExpr;	
	case _:
		buildFromTypedExpr(field.expr);	
}) {
												var ` = field.expr.expr;
												if (enumIndex ` == 14) {
													var ` = `[0];
													if (`.length == 2) {
														var ` = `[0];
														var ` = `[1];
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 13) {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 3) {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		if (enumIndex ` == 24) {
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var v = `;
																						var defaultExpr = `;
																						var init = `;
																						var tmpVar = `;
																						if (v.id == tmpVar.id && init != null) {
																							var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																							var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																							var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																								tmpVar.name.substr(1, null);
																							} else {
																								tmpVar.name;
																							}, null);
																							var ifExpr = {
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																									}, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																									}), metadata : {}, pos : pos};
																								}, {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																								}, defaultAst), metadata : {}, pos : pos};
																							};
																							if (ifExpr.metadata == null) {
																								ifExpr.metadata = {};
																							};
																							ifExpr.metadata.keepInlineInAssignment = true;
																							ifExpr;
																						} else {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
																						};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
																				};
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
													};
												} else {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, null);
												};
											};
											pairs.push({key : key, value : fieldValue});
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EMap(pairs);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							haxe.Log.trace("[AST Builder] TArrayDecl with " + el.length + " elements", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1644, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							if (el.length > 0) {
								haxe.Log.trace("[AST Builder] First element type: " + Type.enumConstructor(el[0].expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1646, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							};
							if (el.length == 1 && {
								var ` = el[0].expr;
								if (enumIndex ` == 15) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									true;
								} else false;
							}) {
								haxe.Log.trace("[AST Builder] Detected array comprehension, treating as EFor instead of EList", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1655, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
							} else {
								if (el.length == 1) {
									@:ast(switch (el[0].expr) {
	case TBlock(stmts):
		var comprehension = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
		if (comprehension != null) {
			switch (comprehension.def) {
				case EFor(_, _, _, _, _):
					trace("[AST Builder] Detected desugared comprehension in single-element array, treating as EFor");
					comprehension.def;				
				default:
					EList([buildFromTypedExpr(el[0], variableUsageMap)]);				
			};
		} else {
			EList([buildFromTypedExpr(el[0], variableUsageMap)]);
		};	
	default:
		EList([buildFromTypedExpr(el[0], variableUsageMap)]);	
}) {
										var ` = el[0].expr;
										if (enumIndex ` == 14) {
											var ` = `[0];
											{
												var stmts = `;
												{
													var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
													if (comprehension != null) {
														@:ast(switch (comprehension.def) {
	case EFor(_, _, _, _, _):
		trace("[AST Builder] Detected desugared comprehension in single-element array, treating as EFor");
		comprehension.def;	
	default:
		EList([buildFromTypedExpr(el[0], variableUsageMap)]);	
}) {
															var ` = comprehension.def;
															if (enumIndex ` == 41) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																var ` = `[3];
																var ` = `[4];
																{
																	haxe.Log.trace("[AST Builder] Detected desugared comprehension in single-element array, treating as EFor", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1669, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																	comprehension.def;
																};
															} else {
																reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap)]);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap)]);
													};
												};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap)]);
										};
									};
								} else {
									var hasIdiomaticEnums = false;
									{
										var ` = 0;
										while (` < el.length) {
											var e = el[`];
											++ `;
											@:ast(switch (e.expr) {
	case TCall(callTarget, _) if (callTarget != null && isEnumConstructor(callTarget) && hasIdiomaticMetadata(callTarget)):
		hasIdiomaticEnums = true;
		break;	
	case TCall(_, _):
		switch (e.t) {
			case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
				hasIdiomaticEnums = true;
				break;			
			default:
		};	
	default:
}) {
												var ` = e.expr;
												if (enumIndex ` == 9) {
													var ` = `[0];
													var ` = `[1];
													{
														var callTarget = `;
														if (callTarget != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(callTarget) && reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(callTarget)) {
															hasIdiomaticEnums = true;
															break;
														} else {
															@:ast(switch (e.t) {
	case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
		hasIdiomaticEnums = true;
		break;	
	default:
}) {
																var ` = e.t;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var enumRef = `;
																		if (enumRef.get().meta.has(":elixirIdiomatic")) {
																			hasIdiomaticEnums = true;
																			break;
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
										};
									};
									if (hasIdiomaticEnums) {
										haxe.Log.trace("[AST Builder] Building array with idiomatic enum elements", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1707, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
									};
									var elements = [];
									{
										var ` = 0;
										while (` < el.length) {
											var e = el[`];
											++ `;
											@:ast(switch (e.expr) {
	case TBlock(stmts):
		var comprehension = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
		if (comprehension != null) {
			elements.push(comprehension);
		} else if (looksLikeListBuildingBlock(stmts)) {
			trace("[AST Builder] Found list-building block in array element, converting to nested list");
			var nestedElements = extractListElements(stmts);
			if (nestedElements != null && nestedElements.length > 0) {
				var nestedList = [for (ne  in  nestedElements) buildFromTypedExpr(ne, variableUsageMap)];
				elements.push(makeAST(EList(nestedList)));
			} else {
				trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function");
				var blockAst = buildFromTypedExpr(e, variableUsageMap);
				var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
				var anonymousFn = makeAST(EFn([fnClause]));
				var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
				elements.push(wrappedBlock);
			};
		} else {
			trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function");
			var blockAst = buildFromTypedExpr(e, variableUsageMap);
			var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
			var anonymousFn = makeAST(EFn([fnClause]));
			var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
			elements.push(wrappedBlock);
		};	
	default:
		elements.push(buildFromTypedExpr(e, variableUsageMap));	
}) {
												var ` = e.expr;
												if (enumIndex ` == 14) {
													var ` = `[0];
													{
														var stmts = `;
														{
															var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
															if (comprehension != null) {
																elements.push(comprehension);
															} else {
																if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(stmts)) {
																	haxe.Log.trace("[AST Builder] Found list-building block in array element, converting to nested list", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1724, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																	var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(stmts);
																	if (nestedElements != null && nestedElements.length > 0) {
																		var nestedList = {
																			var ` = [];
																			{
																				var ` = 0;
																				while (` < nestedElements.length) {
																					var ne = nestedElements[`];
																					++ `;
																					`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(ne, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
																				};
																			};
																			`;
																		};
																		elements.push({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EList(nestedList), metadata : {}, pos : pos};
																		});
																	} else {
																		haxe.Log.trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1735, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																		var blockAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																		var fnClause = {args : [], guard : null, body : blockAst};
																		var anonymousFn = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([fnClause]), metadata : {}, pos : pos};
																		};
																		var wrappedBlock = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EParen(anonymousFn), metadata : {}, pos : pos};
																			}, "", []), metadata : {}, pos : pos};
																		};
																		elements.push(wrappedBlock);
																	};
																} else {
																	haxe.Log.trace("[AST Builder] Wrapping TBlock in array element as immediately-invoked function", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1752, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																	var blockAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																	var fnClause = {args : [], guard : null, body : blockAst};
																	var anonymousFn = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EFn([fnClause]), metadata : {}, pos : pos};
																	};
																	var wrappedBlock = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EParen(anonymousFn), metadata : {}, pos : pos};
																		}, "", []), metadata : {}, pos : pos};
																	};
																	elements.push(wrappedBlock);
																};
															};
														};
													};
												} else {
													elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
												};
											};
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EList(elements);
								};
							};
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						{
							if (e != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e)) {
								var tag = reflaxe.elixir.ast.ElixirASTBuilder.extractEnumTag(e);
								if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
									tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
								};
								var args = {
									var ` = [];
									{
										var ` = 0;
										while (` < el.length) {
											var arg = el[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
										};
									};
									`;
								};
								var tupleDef = reflaxe.elixir.ast.ElixirASTDef.ETuple([{
									var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
										var this;
										this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
										cast this;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								}].concat(args));
								if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
									haxe.Log.trace("[AST Builder] Building idiomatic enum tuple: " + tag + " with " + args.length + " args", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 982, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
									haxe.Log.trace("[AST Builder] Enum type: " + reflaxe.elixir.ast.ElixirASTBuilder.getEnumTypeName(e), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 983, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								};
								tupleDef;
							} else {
								var args = [];
								{
									var ` = 0;
									while (` < el.length) {
										var arg = el[`];
										++ `;
										var isFunctionRef = false;
										@:ast(switch (arg.expr) {
	case TField(_, FStatic(classRef, cf)):
		switch (cf.get().type) {
			case TFun(funcArgs, _):
				isFunctionRef = true;
				var target = buildFromTypedExpr(arg, variableUsageMap);
				switch (target.def) {
					case EField(module, funcName):
						var arity = funcArgs.length;
						args.push(makeAST(ECapture(target, arity)));					
					default:
						args.push(target);					
				};			
			default:
				args.push(buildFromTypedExpr(arg, variableUsageMap));			
		};	
	default:
		args.push(buildFromTypedExpr(arg, variableUsageMap));	
}) {
											var ` = arg.expr;
											if (enumIndex ` == 4) {
												var ` = `[0];
												var ` = `[1];
												if (enumIndex ` == 1) {
													var ` = `[0];
													var ` = `[1];
													{
														var classRef = `;
														var cf = `;
														{
															@:ast(switch (cf.get().type) {
	case TFun(funcArgs, _):
		isFunctionRef = true;
		var target = buildFromTypedExpr(arg, variableUsageMap);
		switch (target.def) {
			case EField(module, funcName):
				var arity = funcArgs.length;
				args.push(makeAST(ECapture(target, arity)));			
			default:
				args.push(target);			
		};	
	default:
		args.push(buildFromTypedExpr(arg, variableUsageMap));	
}) {
																var ` = cf.get().type;
																if (enumIndex ` == 4) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var funcArgs = `;
																		{
																			isFunctionRef = true;
																			var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																			@:ast(switch (target.def) {
	case EField(module, funcName):
		var arity = funcArgs.length;
		args.push(makeAST(ECapture(target, arity)));	
	default:
		args.push(target);	
}) {
																				var ` = target.def;
																				if (enumIndex ` == 28) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var module = `;
																						var funcName = `;
																						{
																							var arity = funcArgs.length;
																							args.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.ECapture(target, arity), metadata : {}, pos : pos};
																							});
																						};
																					};
																				} else {
																					args.push(target);
																				};
																			};
																		};
																	};
																} else {
																	args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
																};
															};
														};
													};
												} else {
													args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
												};
											} else {
												args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
											};
										};
									};
								};
								if (e != null) {
									@:ast(switch (e.expr) {
	case TField(_, FStatic(classRef, cf)):
		var classType = classRef.get();
		var methodName = cf.get().name;
		if (currentModule != null && classType.name == currentModule) {
			var elixirMethodName = toSnakeCase(methodName);
			return ECall(null, elixirMethodName, args);
		};
		if (classType.name == "Reflect") {
			switch (methodName) {
				case "hasField":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						trackDependency("Map");
						return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
					};				
				case "field":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						trackDependency("Map");
						return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
					};				
				case "setField":
					if (args.length == 3) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var value = args[2];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
					};				
				case "fields":
					if (args.length == 1) {
						return ERemoteCall(makeAST(EVar("Map")), "keys", args);
					};				
				case "isObject":
					if (args.length == 1) {
						return ECall(null, "is_map", args);
					};				
				case "deleteField":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
					};				
				case "copy":
					if (args.length == 1) {
						return args[0].def;
					};				
				case "compare":
					if (args.length == 2) {
						var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
						var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
						var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
						var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
						var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
						return ECond([ltClause, gtClause, trueClause]);
					};				
				case "isEnumValue":
					if (args.length == 1) {
						var isTuple = ECall(null, "is_tuple", args);
						var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
						var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
						return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
					};				
				case "callMethod":
					if (args.length == 3) {
						return ECall(null, "apply", [args[1], args[2]]);
					};				
				default:
			};
		};
		if (classType.meta.has(":native")) {
			var nativeModuleName = "";
			var nativeMeta = classType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						nativeModuleName = s;					
					default:
				};
			};
			if (nativeModuleName != "") {
				var elixirMethodName = toSnakeCase(methodName);
				trackDependency(nativeModuleName);
				return ERemoteCall(makeAST(EVar(nativeModuleName)), elixirMethodName, args);
			};
		} else {
			var moduleName = classType.name;
			trackDependency(moduleName);
			if (compiler != null && classType.pack.length > 0) {
				compiler.modulePackages.set(moduleName, classType.pack);
			};
		};	
	default:
}) {
										var ` = e.expr;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 1) {
												var ` = `[0];
												var ` = `[1];
												{
													var classRef = `;
													var cf = `;
													{
														var classType = classRef.get();
														var methodName = cf.get().name;
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentModule != null && classType.name == reflaxe.elixir.ast.ElixirASTBuilder.currentModule) {
															var elixirMethodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(methodName);
															return reflaxe.elixir.ast.ElixirASTDef.ECall(null, elixirMethodName, args);
														};
														if (classType.name == "Reflect") {
															@:ast(switch (methodName) {
	case "hasField":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			trackDependency("Map");
			return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
		};	
	case "field":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			trackDependency("Map");
			return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
		};	
	case "setField":
		if (args.length == 3) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var value = args[2];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
		};	
	case "fields":
		if (args.length == 1) {
			return ERemoteCall(makeAST(EVar("Map")), "keys", args);
		};	
	case "isObject":
		if (args.length == 1) {
			return ECall(null, "is_map", args);
		};	
	case "deleteField":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
		};	
	case "copy":
		if (args.length == 1) {
			return args[0].def;
		};	
	case "compare":
		if (args.length == 2) {
			var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
			var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
			var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
			var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
			var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
			return ECond([ltClause, gtClause, trueClause]);
		};	
	case "isEnumValue":
		if (args.length == 1) {
			var isTuple = ECall(null, "is_tuple", args);
			var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
			var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
			return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
		};	
	case "callMethod":
		if (args.length == 3) {
			return ECall(null, "apply", [args[1], args[2]]);
		};	
	default:
}) switch (methodName) {
																case "callMethod": {
																	{
																		if (args.length == 3) {
																			return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "apply", [args[1], args[2]]);
																		};
																	};
																};
																case "compare": {
																	{
																		if (args.length == 2) {
																			var lt = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Less, args[0], args[1]);
																			var gt = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Greater, args[0], args[1]);
																			var ltClause = {condition : {
																				var pos = null;
																				{def : lt, metadata : {}, pos : pos};
																			}, body : {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
																			}};
																			var gtClause = {condition : {
																				var pos = null;
																				{def : gt, metadata : {}, pos : pos};
																			}, body : {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																			}};
																			var trueClause = {condition : {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), metadata : {}, pos : pos};
																			}, body : {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
																			}};
																			return reflaxe.elixir.ast.ElixirASTDef.ECond([ltClause, gtClause, trueClause]);
																		};
																	};
																};
																case "copy": {
																	{
																		if (args.length == 1) {
																			return args[0].def;
																		};
																	};
																};
																case "deleteField": {
																	{
																		if (args.length == 2) {
																			var obj = args[0];
																			var fieldNameExpr = args[1];
																			var atomField = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																				}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																			};
																			return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																			}, "delete", [obj, atomField]);
																		};
																	};
																};
																case "field": {
																	{
																		if (args.length == 2) {
																			var obj = args[0];
																			var fieldNameExpr = args[1];
																			var atomField = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																				}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																			};
																			reflaxe.elixir.ast.ElixirASTBuilder.trackDependency("Map");
																			return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																			}, "get", [obj, atomField]);
																		};
																	};
																};
																case "fields": {
																	{
																		if (args.length == 1) {
																			return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																			}, "keys", args);
																		};
																	};
																};
																case "hasField": {
																	{
																		if (args.length == 2) {
																			var obj = args[0];
																			var fieldNameExpr = args[1];
																			var atomField = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																				}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																			};
																			reflaxe.elixir.ast.ElixirASTBuilder.trackDependency("Map");
																			return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																			}, "has_key?", [obj, atomField]);
																		};
																	};
																};
																case "isEnumValue": {
																	{
																		if (args.length == 1) {
																			var isTuple = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_tuple", args);
																			var elem0 = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [args[0], {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
																			}]);
																			var isAtom = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_atom", [{
																				var pos = null;
																				{def : elem0, metadata : {}, pos : pos};
																			}]);
																			return reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.And, {
																				var pos = null;
																				{def : isTuple, metadata : {}, pos : pos};
																			}, {
																				var pos = null;
																				{def : isAtom, metadata : {}, pos : pos};
																			});
																		};
																	};
																};
																case "isObject": {
																	{
																		if (args.length == 1) {
																			return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_map", args);
																		};
																	};
																};
																case "setField": {
																	{
																		if (args.length == 3) {
																			var obj = args[0];
																			var fieldNameExpr = args[1];
																			var value = args[2];
																			var atomField = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																				}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																			};
																			return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																			}, "put", [obj, atomField, value]);
																		};
																	};
																};
																default: {}
															};
														};
														if (classType.meta.has(":native")) {
															var nativeModuleName = "";
															var nativeMeta = classType.meta.extract(":native");
															if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		nativeModuleName = s;	
	default:
}) {
																	var ` = nativeMeta[0].params[0].expr;
																	if (enumIndex ` == 0) {
																		var ` = `[0];
																		if (enumIndex ` == 2) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var s = `;
																				{
																					nativeModuleName = s;
																				};
																			};
																		} else {};
																	} else {};
																};
															};
															if (nativeModuleName != "") {
																var elixirMethodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(methodName);
																reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(nativeModuleName);
																return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar(nativeModuleName), metadata : {}, pos : pos};
																}, elixirMethodName, args);
															};
														} else {
															var moduleName = classType.name;
															reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(moduleName);
															if (reflaxe.elixir.ast.ElixirASTBuilder.compiler != null && classType.pack.length > 0) {
																{
																	var this = reflaxe.elixir.ast.ElixirASTBuilder.compiler.modulePackages;
																	var value = classType.pack;
																	cast this.set(moduleName, value);
																};
															};
														};
													};
												};
											} else {};
										} else {};
									};
								};
								var target = if (e != null) {
									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
								} else {
									null;
								};
								@:ast(switch (e.expr) {
	case TIdent("__elixir__"):
		if (args.length > 0) {
			switch (args[0].def) {
				case EString(code):
					var processedCode = code;
					if (args.length > 1) {
						for (i  in  1 ... args.length) {
							var paramStr = ElixirASTPrinter.printAST(args[i]);
							var placeholder = "{${i-1}}";
							processedCode = StringTools.replace(processedCode, placeholder, paramStr);
						};
					};
					ERaw(processedCode);				
				default:
					ECall(target, "call", args);				
			};
		} else {
			ECall(target, "call", args);
		};	
	case TField(obj, fa):
		var fieldName = extractFieldName(fa);
		fieldName = toSnakeCase(fieldName);
		var objAst = buildFromTypedExpr(obj, variableUsageMap);
		var typeModule = getExternNativeModuleNameFromType(obj.t);
		if (typeModule != null) {
			trackDependency(typeModule);
			return ERemoteCall(makeAST(EVar(typeModule)), fieldName, [objAst].concat(args));
		};
		switch (fa) {
			case FInstance(cRef, _, cfRef):
				var cls = cRef.get();
				if (cls.isExtern && cls.meta.has(":native")) {
					var nativeMeta = cls.meta.extract(":native");
					var moduleName:Null<String> = null;
					if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
						switch (nativeMeta[0].params[0].expr) {
							case EConst(CString(s, _)):
								moduleName = s;							
							default:
						};
					};
					if (moduleName != null) {
						var methodName = fieldName;
						var cf = cfRef.get();
						if (cf.meta.has(":native")) {
							var mMeta = cf.meta.extract(":native");
							if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
								switch (mMeta[0].params[0].expr) {
									case EConst(CString(ns, _)):
										methodName = toSnakeCase(ns);									
									default:
								};
							};
						};
						trackDependency(moduleName);
						return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
					};
				};			
			default:
		};
		if (fieldName == "elem" && args.length == 1) {
			return ECall(null, "elem", [objAst, args[0]]);
		};
		if (isAssertClass(obj)) {
			var assertAst = reflaxe.elixir.ast.builders.ExUnitCompiler.compileAssertion(fieldName, args);
			return assertAst.def;
		} else if (fieldName == "hxx" && isHXXModule(obj)) {
			if (args.length == 1) {
				var templateContent = collectTemplateContent(args[0]);
				ESigil("H", templateContent, "");
			} else {
				ECall(objAst, fieldName, args);
			};
		} else if (isModuleCall(obj)) {
			var hasNativeMetadata = false;
			var nativeName:String = null;
			switch (fa) {
				case FStatic(_, cf):
					var classField = cf.get();
					if (classField.meta.has(":native")) {
						var nativeMeta = classField.meta.extract(":native");
						if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
							switch (nativeMeta[0].params[0].expr) {
								case EConst(CString(s, _)):
									hasNativeMetadata = true;
									nativeName = s;								
								default:
							};
						};
					};				
				default:
			};
			if (hasNativeMetadata && nativeName != null) {
				var parts = nativeName.split(".");
				if (parts.length > 1) {
					var module = parts.slice(0, parts.length - 1).join(".");
					var funcName = parts[parts.length - 1];
					trackDependency(module);
					ERemoteCall(makeAST(EVar(module)), funcName, args);
				} else {
					ERemoteCall(objAst, nativeName, args);
				};
			} else {
				var elixirFuncName = toSnakeCase(fieldName);
				ERemoteCall(objAst, elixirFuncName, args);
			};
		} else {
			var methodHasElixirInjection = false;
			var expandedElixir:ElixirAST = null;
			switch (fa) {
				case FInstance(_, _, cf):
					var classField = cf.get();
					var methodExpr = classField.expr();
					trace("[AST Builder] Checking method ${fieldName}, has expr: ${methodExpr != null}");
					if (methodExpr != null) {
						expandedElixir = tryExpandElixirInjection(methodExpr, obj, el);
						methodHasElixirInjection = (expandedElixir != null);
						trace("[AST Builder] Method ${fieldName} has __elixir__: $methodHasElixirInjection");
					};				
				default:
			};
			if (methodHasElixirInjection && expandedElixir != null) {
				return expandedElixir.def;
			} else if (isArrayType(obj.t)) {
				switch (fieldName) {
					case "filter" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);					
					case "map" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);					
					case "push" if (args.length == 1):
						EBinary(Concat, objAst, makeAST(EList([args[0]])));					
					default:
						ECall(objAst, fieldName, args);					
				};
			} else if (isMapType(obj.t)) {
				switch (fieldName) {
					case "set" if (args.length == 2):
						ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args));					
					case "get" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));					
					case "remove" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));					
					case "exists" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));					
					case "keys" if (args.length == 0):
						ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);					
					case "values" if (args.length == 0):
						ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);					
					default:
						ECall(objAst, fieldName, args);					
				};
			} else {
				ECall(objAst, fieldName, args);
			};
		};	
	case TLocal(v):
		var isFunctionVar = switch (v.t) {
			case TFun(_, _):
				true;			
			case TAbstract(t, params):
				var abs = t.get();
				if (abs.name == "Function" || abs.name == "Fn") {
					true;
				} else if (abs.name == "Null" && params.length == 1) {
					switch (params[0]) {
						case TFun(_, _):
							true;						
						default:
							false;						
					};
				} else {
					false;
				};			
			default:
				false;			
		};
		if (isFunctionVar) {
			ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
		} else {
			ECall(null, toElixirVarName(v.name), args);
		};	
	default:
		if (target != null) {
			ECall(target, "call", args);
		} else {
			ECall(null, "unknown_call", args);
		};	
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var v = `;
												{
													var isFunctionVar = @:ast(switch (v.t) {
	case TFun(_, _):
		true;	
	case TAbstract(t, params):
		var abs = t.get();
		if (abs.name == "Function" || abs.name == "Fn") {
			true;
		} else if (abs.name == "Null" && params.length == 1) {
			switch (params[0]) {
				case TFun(_, _):
					true;				
				default:
					false;				
			};
		} else {
			false;
		};	
	default:
		false;	
}) {
														var ` = v.t;
														switch (enumIndex `) {
															case 4: {
																var ` = `[0];
																var ` = `[1];
																{
																	true;
																};
															};
															case 8: {
																var ` = `[0];
																var ` = `[1];
																{
																	var t = `;
																	var params = `;
																	{
																		var abs = t.get();
																		if (abs.name == "Function" || abs.name == "Fn") {
																			true;
																		} else {
																			if (abs.name == "Null" && params.length == 1) {
																				@:ast(switch (params[0]) {
	case TFun(_, _):
		true;	
	default:
		false;	
}) {
																					var ` = params[0];
																					if (enumIndex ` == 4) {
																						var ` = `[0];
																						var ` = `[1];
																						{
																							true;
																						};
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		};
																	};
																};
															};
															default: {
																false;
															}
														};
													};
													if (isFunctionVar) {
														reflaxe.elixir.ast.ElixirASTDef.ECall({
															var def = reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}, "", args);
													} else {
														reflaxe.elixir.ast.ElixirASTDef.ECall(null, reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null), args);
													};
												};
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												var obj = `;
												var fa = `;
												{
													var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
													fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
													var objAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(obj, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
													var typeModule = reflaxe.elixir.ast.ElixirASTBuilder.getExternNativeModuleNameFromType(obj.t);
													if (typeModule != null) {
														reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(typeModule);
														return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(typeModule), metadata : {}, pos : pos};
														}, fieldName, [objAst].concat(args));
													};
													@:ast(switch (fa) {
	case FInstance(cRef, _, cfRef):
		var cls = cRef.get();
		if (cls.isExtern && cls.meta.has(":native")) {
			var nativeMeta = cls.meta.extract(":native");
			var moduleName:Null<String> = null;
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						moduleName = s;					
					default:
				};
			};
			if (moduleName != null) {
				var methodName = fieldName;
				var cf = cfRef.get();
				if (cf.meta.has(":native")) {
					var mMeta = cf.meta.extract(":native");
					if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
						switch (mMeta[0].params[0].expr) {
							case EConst(CString(ns, _)):
								methodName = toSnakeCase(ns);							
							default:
						};
					};
				};
				trackDependency(moduleName);
				return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
			};
		};	
	default:
}) if (enumIndex fa == 0) {
														var ` = fa[0];
														var ` = fa[1];
														var ` = fa[2];
														{
															var cRef = `;
															var cfRef = `;
															{
																var cls = cRef.get();
																if (cls.isExtern && cls.meta.has(":native")) {
																	var nativeMeta = cls.meta.extract(":native");
																	var moduleName = null;
																	if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																		@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		moduleName = s;	
	default:
}) {
																			var ` = nativeMeta[0].params[0].expr;
																			if (enumIndex ` == 0) {
																				var ` = `[0];
																				if (enumIndex ` == 2) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var s = `;
																						{
																							moduleName = s;
																						};
																					};
																				} else {};
																			} else {};
																		};
																	};
																	if (moduleName != null) {
																		var methodName = fieldName;
																		var cf = cfRef.get();
																		if (cf.meta.has(":native")) {
																			var mMeta = cf.meta.extract(":native");
																			if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
																				@:ast(switch (mMeta[0].params[0].expr) {
	case EConst(CString(ns, _)):
		methodName = toSnakeCase(ns);	
	default:
}) {
																					var ` = mMeta[0].params[0].expr;
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						if (enumIndex ` == 2) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var ns = `;
																								{
																									methodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(ns);
																								};
																							};
																						} else {};
																					} else {};
																				};
																			};
																		};
																		reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(moduleName);
																		return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
																		}, methodName, [objAst].concat(args));
																	};
																};
															};
														};
													} else {};
													if (fieldName == "elem" && args.length == 1) {
														return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [objAst, args[0]]);
													};
													if (reflaxe.elixir.ast.ElixirASTBuilder.isAssertClass(obj)) {
														var assertAst = reflaxe.elixir.ast.builders.ExUnitCompiler.compileAssertion(fieldName, args);
														return assertAst.def;
													} else {
														if (fieldName == "hxx" && reflaxe.elixir.ast.ElixirASTBuilder.isHXXModule(obj)) {
															if (args.length == 1) {
																var templateContent = reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(args[0]);
																reflaxe.elixir.ast.ElixirASTDef.ESigil("H", templateContent, "");
															} else {
																reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
															};
														} else {
															if (reflaxe.elixir.ast.ElixirASTBuilder.isModuleCall(obj)) {
																var hasNativeMetadata = false;
																var nativeName = null;
																@:ast(switch (fa) {
	case FStatic(_, cf):
		var classField = cf.get();
		if (classField.meta.has(":native")) {
			var nativeMeta = classField.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						hasNativeMetadata = true;
						nativeName = s;					
					default:
				};
			};
		};	
	default:
}) if (enumIndex fa == 1) {
																	var ` = fa[0];
																	var ` = fa[1];
																	{
																		var cf = `;
																		{
																			var classField = cf.get();
																			if (classField.meta.has(":native")) {
																				var nativeMeta = classField.meta.extract(":native");
																				if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																					@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		hasNativeMetadata = true;
		nativeName = s;	
	default:
}) {
																						var ` = nativeMeta[0].params[0].expr;
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							if (enumIndex ` == 2) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var s = `;
																									{
																										hasNativeMetadata = true;
																										nativeName = s;
																									};
																								};
																							} else {};
																						} else {};
																					};
																				};
																			};
																		};
																	};
																} else {};
																if (hasNativeMetadata && nativeName != null) {
																	var parts = nativeName.split(".");
																	if (parts.length > 1) {
																		var module = parts.slice(0, parts.length - 1).join(".");
																		var funcName = parts[parts.length - 1];
																		reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(module);
																		reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(module), metadata : {}, pos : pos};
																		}, funcName, args);
																	} else {
																		reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(objAst, nativeName, args);
																	};
																} else {
																	var elixirFuncName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
																	reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(objAst, elixirFuncName, args);
																};
															} else {
																var methodHasElixirInjection = false;
																var expandedElixir = null;
																@:ast(switch (fa) {
	case FInstance(_, _, cf):
		var classField = cf.get();
		var methodExpr = classField.expr();
		trace("[AST Builder] Checking method ${fieldName}, has expr: ${methodExpr != null}");
		if (methodExpr != null) {
			expandedElixir = tryExpandElixirInjection(methodExpr, obj, el);
			methodHasElixirInjection = (expandedElixir != null);
			trace("[AST Builder] Method ${fieldName} has __elixir__: $methodHasElixirInjection");
		};	
	default:
}) if (enumIndex fa == 0) {
																	var ` = fa[0];
																	var ` = fa[1];
																	var ` = fa[2];
																	{
																		var cf = `;
																		{
																			var classField = cf.get();
																			var methodExpr = classField.expr();
																			haxe.Log.trace("[AST Builder] Checking method " + fieldName + ", has expr: " + Std.string(methodExpr != null), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1403, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																			if (methodExpr != null) {
																				expandedElixir = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirInjection(methodExpr, obj, el);
																				methodHasElixirInjection = (expandedElixir != null);
																				haxe.Log.trace("[AST Builder] Method " + fieldName + " has __elixir__: " + Std.string(methodHasElixirInjection), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1410, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
																			};
																		};
																	};
																} else {};
																if (methodHasElixirInjection && expandedElixir != null) {
																	return expandedElixir.def;
																} else {
																	if (reflaxe.elixir.ast.ElixirASTBuilder.isArrayType(obj.t)) {
																		@:ast(switch (fieldName) {
	case "filter" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);	
	case "map" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);	
	case "push" if (args.length == 1):
		EBinary(Concat, objAst, makeAST(EList([args[0]])));	
	default:
		ECall(objAst, fieldName, args);	
}) switch (fieldName) {
																			case "filter": {
																				if (args.length == 1) {
																					reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																					}, "filter", [objAst, args[0]]);
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			case "map": {
																				if (args.length == 1) {
																					reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																					}, "map", [objAst, args[0]]);
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			case "push": {
																				if (args.length == 1) {
																					reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, objAst, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EList([args[0]]), metadata : {}, pos : pos};
																					});
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			default: {
																				reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																			}
																		};
																	} else {
																		if (reflaxe.elixir.ast.ElixirASTBuilder.isMapType(obj.t)) {
																			@:ast(switch (fieldName) {
	case "set" if (args.length == 2):
		ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args));	
	case "get" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));	
	case "remove" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));	
	case "exists" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));	
	case "keys" if (args.length == 0):
		ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);	
	case "values" if (args.length == 0):
		ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);	
	default:
		ECall(objAst, fieldName, args);	
}) switch (fieldName) {
																				case "exists": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "has_key?", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "get": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "get", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "keys": {
																					if (args.length == 0) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "keys", [objAst]);
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "remove": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "delete", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "set": {
																					if (args.length == 2) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "put", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "values": {
																					if (args.length == 0) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "values", [objAst]);
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				default: {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				}
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																		};
																	};
																};
															};
														};
													};
												};
											};
										};
										case 28: {
											var ` = `[0];
											if (` == "__elixir__") {
												{
													if (args.length > 0) {
														@:ast(switch (args[0].def) {
	case EString(code):
		var processedCode = code;
		if (args.length > 1) {
			for (i  in  1 ... args.length) {
				var paramStr = ElixirASTPrinter.printAST(args[i]);
				var placeholder = "{${i-1}}";
				processedCode = StringTools.replace(processedCode, placeholder, paramStr);
			};
		};
		ERaw(processedCode);	
	default:
		ECall(target, "call", args);	
}) {
															var ` = args[0].def;
															if (enumIndex ` == 32) {
																var ` = `[0];
																{
																	var code = `;
																	{
																		var processedCode = code;
																		if (args.length > 1) {
																			{
																				var ` = 1;
																				var ` = args.length;
																				while (` < `) {
																					var i = ` ++;
																					var paramStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(args[i]);
																					var placeholder = "{" + i - 1 + "}";
																					processedCode = StringTools.replace(processedCode, placeholder, paramStr);
																				};
																			};
																		};
																		reflaxe.elixir.ast.ElixirASTDef.ERaw(processedCode);
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
													};
												};
											} else {
												if (target != null) {
													reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
												} else {
													reflaxe.elixir.ast.ElixirASTDef.ECall(null, "unknown_call", args);
												};
											};
										};
										default: {
											if (target != null) {
												reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
											} else {
												reflaxe.elixir.ast.ElixirASTDef.ECall(null, "unknown_call", args);
											};
										}
									};
								};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var el = `;
						{
							var classType = c.get();
							var className = classType.name;
							var args = {
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var e = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null));
									};
								};
								`;
							};
							if (className == "StringMap" || className == "Map" || StringTools.endsWith(className, "Map")) {
								reflaxe.elixir.ast.ElixirASTDef.EMap([]);
							} else {
								var hasInstanceMethods = false;
								{
									var ` = 0;
									var ` = classType.fields.get();
									while (` < `.length) {
										var field = `[`];
										++ `;
										if ({
											var ` = field.kind;
											if (enumIndex ` == 1) {
												var ` = `[0];
												true;
											} else false;
										}) {
											var isStatic = false;
											{
												var ` = 0;
												var ` = classType.statics.get();
												while (` < `.length) {
													var staticField = `[`];
													++ `;
													if (staticField.name == field.name) {
														isStatic = true;
														break;
													};
												};
											};
											if (! isStatic) {
												hasInstanceMethods = true;
												break;
											};
										};
									};
								};
								var hasConstructor = classType.constructor != null;
								if (hasInstanceMethods || hasConstructor) {
									var moduleRef = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
									};
									reflaxe.elixir.ast.ElixirASTDef.ECall(moduleRef, "new", args);
								} else {
									reflaxe.elixir.ast.ElixirASTDef.EStruct(className, []);
								};
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var postFix = `;
						var e = `;
						{
							@:ast(switch (op) {
	case OpNot:
		switch (e.expr) {
			case TBlock([]):
				EUnary(Not, makeAST(ENil));			
			case TBlock(exprs) if (exprs.length == 1):
				EUnary(Not, buildFromTypedExpr(exprs[0], variableUsageMap));			
			case TBlock(exprs):
				var statements = [];
				for (i  in  0 ... exprs.length - 1) {
					statements.push(buildFromTypedExpr(exprs[i], variableUsageMap));
				};
				var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], variableUsageMap);
				statements.push(makeAST(EUnary(Not, lastExpr)));
				EBlock(statements);			
			default:
				var expr = buildFromTypedExpr(e, variableUsageMap).def;
				EUnary(Not, makeAST(expr));			
		};	
	case OpNeg:
		var expr = buildFromTypedExpr(e, variableUsageMap).def;
		EUnary(Negate, makeAST(expr));	
	case OpNegBits:
		var expr = buildFromTypedExpr(e, variableUsageMap).def;
		EUnary(BitwiseNot, makeAST(expr));	
	case OpIncrement, OpDecrement:
		var one = makeAST(EInteger(1));
		var builtExpr = buildFromTypedExpr(e, variableUsageMap);
		var operation = if (op == OpIncrement) {
			makeAST(EBinary(Add, builtExpr, one));
		} else {
			makeAST(EBinary(Subtract, builtExpr, one));
		};
		switch (e.expr) {
			case TLocal(v):
				EBinary(Match, builtExpr, operation);			
			default:
				operation.def;			
		};	
	case OpSpread:
		var builtExpr = buildFromTypedExpr(e, variableUsageMap);
		EUnquoteSplicing(builtExpr);	
}) switch (@:exhaustive enumIndex op) {
								case 0, 1: {
									{
										var one = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
										};
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										var operation = if (op == haxe.macro.Unop.OpIncrement) {
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, builtExpr, one), metadata : {}, pos : pos};
											};
										} else {
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, builtExpr, one), metadata : {}, pos : pos};
											};
										};
										@:ast(switch (e.expr) {
	case TLocal(v):
		EBinary(Match, builtExpr, operation);	
	default:
		operation.def;	
}) {
											var ` = e.expr;
											if (enumIndex ` == 1) {
												var ` = `[0];
												{
													var v = `;
													{
														reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, builtExpr, operation);
													};
												};
											} else {
												operation.def;
											};
										};
									};
								};
								case 2: {
									{
										@:ast(switch (e.expr) {
	case TBlock([]):
		EUnary(Not, makeAST(ENil));	
	case TBlock(exprs) if (exprs.length == 1):
		EUnary(Not, buildFromTypedExpr(exprs[0], variableUsageMap));	
	case TBlock(exprs):
		var statements = [];
		for (i  in  0 ... exprs.length - 1) {
			statements.push(buildFromTypedExpr(exprs[i], variableUsageMap));
		};
		var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], variableUsageMap);
		statements.push(makeAST(EUnary(Not, lastExpr)));
		EBlock(statements);	
	default:
		var expr = buildFromTypedExpr(e, variableUsageMap).def;
		EUnary(Not, makeAST(expr));	
}) {
											var ` = e.expr;
											if (enumIndex ` == 14) {
												var ` = `[0];
												if (`.length == 0) {
													{
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
														});
													};
												} else {
													var exprs = `;
													if (exprs.length == 1) {
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[0], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
													} else {
														var exprs = `;
														{
															var statements = [];
															{
																var ` = 0;
																var ` = exprs.length - 1;
																while (` < `) {
																	var i = ` ++;
																	statements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[i], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
																};
															};
															var lastExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[exprs.length - 1], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
															statements.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, lastExpr), metadata : {}, pos : pos};
															});
															reflaxe.elixir.ast.ElixirASTDef.EBlock(statements);
														};
													};
												};
											} else {
												var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
												reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
													var pos = null;
													{def : expr, metadata : {}, pos : pos};
												});
											};
										};
									};
								};
								case 3: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Negate, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 4: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.BitwiseNot, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 5: {
									{
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										reflaxe.elixir.ast.ElixirASTDef.EUnquoteSplicing(builtExpr);
									};
								};
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var f = `;
						{
							var fluentPattern = reflaxe.elixir.ast.ElixirASTBuilder.detectFluentAPIPattern(f);
							var args = [];
							var paramRenaming = {
								{};
								new haxe.ds.StringMap();
							};
							var oldTempVarRenameMap = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
							reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap = {
								{};
								new haxe.ds.StringMap();
							};
							for (key in oldTempVarRenameMap.keys()) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									var value = oldTempVarRenameMap.get(key);
									cast this.set(key, value);
								};
							};
							var isFirstParam = true;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									var originalName = arg.v.name;
									var idKey = Std.string(arg.v.id);
									var isActuallyUnused = if (f.expr != null) {
										reflaxe.elixir.helpers.UsageDetector.isParameterUnused(arg.v, f.expr);
									} else {
										false;
									};
									var baseName = reflaxe.elixir.ast.ElixirASTHelpers.toElixirVarName(originalName);
									var finalName = if (isActuallyUnused && ! StringTools.startsWith(baseName, "_")) {
										"_" + baseName;
									} else {
										baseName;
									};
									if (! {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
										cast this.exists(idKey);
									}) {
										{
											var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
											cast this.set(idKey, finalName);
										};
									};
									if (originalName != finalName) {
										{
											paramRenaming.set(originalName, finalName);
										};
									};
									if (originalName == "this1") {
										{
											paramRenaming.set("this", finalName);
										};
									};
									if (isFirstParam && reflaxe.elixir.ast.ElixirASTBuilder.isInClassMethodContext) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentReceiverParamName = finalName;
										isFirstParam = false;
									};
									args.push(reflaxe.elixir.ast.EPattern.PVar(finalName));
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.functionParameterIds;
										cast this.set(idKey, true);
									};
								};
							};
							var functionUsageMap = if (f.expr != null) {
								reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(f.expr);
							} else {
								null;
							};
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(f.expr, functionUsageMap);
							reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap = oldTempVarRenameMap;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.functionParameterIds;
										var key = Std.string(arg.v.id);
										cast this.remove(key);
									};
								};
							};
							if (paramRenaming.keys().hasNext()) {
								body = reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(body, paramRenaming);
							};
							var fnAst = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : args, guard : null, body : body}]), metadata : {}, pos : pos};
							};
							if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
								fnAst.metadata.isFluentMethod = true;
								fnAst.metadata.returnsThis = fluentPattern.returnsThis;
								if (fluentPattern.fieldMutations.length > 0) {
									fnAst.metadata.mutatesFields = [];
									fnAst.metadata.fieldMutations = [];
									{
										var ` = 0;
										var ` = fluentPattern.fieldMutations;
										while (` < `.length) {
											var mutation = `[`];
											++ `;
											fnAst.metadata.mutatesFields.push(mutation.field);
											fnAst.metadata.fieldMutations.push({field : mutation.field, expr : reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(mutation.expr, functionUsageMap)});
										};
									};
								};
							};
							fnAst.def;
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						{
							var isEnumExtraction = false;
							var extractedFromTemp = "";
							if (init != null) {
								@:ast(switch (init.expr) {
	case TEnumParameter(_, _, _):
		isEnumExtraction = true;	
	case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)):
		extractedFromTemp = tempVar.name;	
	case _:
}) {
									var ` = init.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var tempVar = `;
												if (StringTools.startsWith(tempVar.name, "_g") || tempVar.name == "g" || new EReg("^g\\d+$", "").match(tempVar.name)) {
													extractedFromTemp = tempVar.name;
												} else {};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												isEnumExtraction = true;
											};
										};
										default: {}
									};
								};
							};
							var varName = v.name;
							var idKey = Std.string(v.id);
							var isUnused = false;
							var baseName = if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									cast this.get(idKey);
								};
							} else {
								var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap != null) {
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
										var key = v.id;
										cast this.exists(key);
									} && {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
										var key = v.id;
										cast this.get(key);
									};
								} else {
									true;
								};
								if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
									reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(varName, false);
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(varName, false);
								};
							};
							var isActuallyUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
								var key = v.id;
								cast this.exists(key);
							}) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
									var key = v.id;
									cast this.get(key);
								};
							} else {
								true;
							};
							var isEnumParameterExtraction = false;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d*$/.match(tempVar.name)):
		isEnumParameterExtraction = true;	
	case _:
}) {
									var ` = init.expr;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var tempVar = `;
											if (StringTools.startsWith(tempVar.name, "_g") || tempVar.name == "g" || new EReg("^g\\d*$", "").match(tempVar.name)) {
												isEnumParameterExtraction = true;
											} else {};
										};
									} else {};
								};
							};
							var finalVarName = if (! isActuallyUsed && ! isEnumParameterExtraction) {
								"_" + baseName;
							} else {
								baseName;
							};
							var matchNode = if (init != null) {
								var initValue = @:ast(switch (init.expr) {
	case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var initAst = buildFromTypedExpr(tmpInit, variableUsageMap);
		var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		ifExpr;	
	case _:
		var builtInit = buildFromTypedExpr(init, variableUsageMap);
		builtInit;	
}) {
									var ` = init.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 13) {
													var ` = `[0];
													var ` = `[1];
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 24) {
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var localVar = `;
																			var defaultExpr = `;
																			var tmpInit = `;
																			var tmpVar = `;
																			if (localVar.id == tmpVar.id && tmpInit != null) {
																				var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																					tmpVar.name.substr(1, null);
																				} else {
																					tmpVar.name;
																				}, null);
																				var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tmpInit, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																				var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																				var ifExpr = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																						}, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					}, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																					}, defaultAst), metadata : {}, pos : pos};
																				};
																				if (ifExpr.metadata == null) {
																					ifExpr.metadata = {};
																				};
																				ifExpr.metadata.keepInlineInAssignment = true;
																				ifExpr;
																			} else {
																				var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																				builtInit;
																			};
																		};
																	} else {
																		var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																		builtInit;
																	};
																};
															} else {
																var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																builtInit;
															};
														} else {
															var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
															builtInit;
														};
													};
												} else {
													var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
													builtInit;
												};
											};
										} else {
											var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
											builtInit;
										};
									} else {
										var builtInit = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										builtInit;
									};
								};
								var result = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), initValue), metadata : {}, pos : pos};
								};
								result;
							} else {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
							};
							matchNode.def;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(el, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
							if (comprehension != null) {
								haxe.Log.trace("[AST Builder] Successfully reconstructed array comprehension from imperative block", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1809, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								comprehension.def;
							};
							if (el.length >= 5) {
								var hasEmptyArray = false;
								var hasZeroInit = false;
								var hasSourceAssign = false;
								var hasWhileLoop = false;
								var returnsResult = false;
								var sourceArray = null;
								var whileBody = null;
								var resultVarName = null;
								{
									var ` = 0;
									var ` = el.length;
									while (` < `) {
										var i = ` ++;
										@:ast(switch (el[i].expr) {
	case TVar(v, init) if (init != null && v.name.startsWith("_g")):
		switch (init.expr) {
			case TArrayDecl([]):
				hasEmptyArray = true;
				resultVarName = v.name;			
			case TConst(TInt(i)) if (i == 0):
				hasZeroInit = true;			
			case TLocal(_):
				hasSourceAssign = true;
				sourceArray = init;			
			case _:
		};	
	case TWhile(_, body, _):
		hasWhileLoop = true;
		whileBody = body;	
	case TLocal(v) if (v.name == resultVarName && i == el.length - 1):
		returnsResult = true;	
	case _:
}) {
											var ` = el[i].expr;
											switch (enumIndex `) {
												case 1: {
													var ` = `[0];
													{
														var v = `;
														if (v.name == resultVarName && i == el.length - 1) {
															returnsResult = true;
														} else {};
													};
												};
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null && StringTools.startsWith(v.name, "_g")) {
															@:ast(switch (init.expr) {
	case TArrayDecl([]):
		hasEmptyArray = true;
		resultVarName = v.name;	
	case TConst(TInt(i)) if (i == 0):
		hasZeroInit = true;	
	case TLocal(_):
		hasSourceAssign = true;
		sourceArray = init;	
	case _:
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 0: {
																		var ` = `[0];
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			{
																				var i = `;
																				if (i == 0) {
																					hasZeroInit = true;
																				} else {};
																			};
																		} else {};
																	};
																	case 1: {
																		var ` = `[0];
																		{
																			hasSourceAssign = true;
																			sourceArray = init;
																		};
																	};
																	case 8: {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				hasEmptyArray = true;
																				resultVarName = v.name;
																			};
																		} else {};
																	};
																	default: {}
																};
															};
														} else {};
													};
												};
												case 17: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var body = `;
														{
															hasWhileLoop = true;
															whileBody = body;
														};
													};
												};
												default: {}
											};
										};
									};
								};
								var isArrayPattern = hasEmptyArray && hasZeroInit && hasSourceAssign && hasWhileLoop && returnsResult;
								if (isArrayPattern && sourceArray != null && whileBody != null) {
									var operation = reflaxe.elixir.ast.ElixirASTPatterns.detectArrayOperationPattern(whileBody);
									if (operation != null) {
										return reflaxe.elixir.ast.ElixirASTBuilder.generateIdiomaticEnumCall(sourceArray, operation, whileBody);
									};
								};
							};
							if (el.length == 2) {
								@:ast(switch ([el[0].expr, el[1].expr]) {
	case [TVar(tmpVar, init), TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr)] if (v.id == tmpVar.id && init != null):
		var initAst = buildFromTypedExpr(init, variableUsageMap);
		var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		return ifExpr.def;	
	case _:
}) {
									var ` = el[0].expr;
									var ` = el[1].expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 3) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 24) {
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 1) {
														var ` = `[0];
														{
															var v = `;
															var defaultExpr = `;
															var init = `;
															var tmpVar = `;
															if (v.id == tmpVar.id && init != null) {
																var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																	tmpVar.name.substr(1, null);
																} else {
																	tmpVar.name;
																}, null);
																var ifExpr = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																		}, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	}, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																	}, defaultAst), metadata : {}, pos : pos};
																};
																if (ifExpr.metadata == null) {
																	ifExpr.metadata = {};
																};
																ifExpr.metadata.keepInlineInAssignment = true;
																return ifExpr.def;
															} else {};
														};
													} else {};
												};
											} else {};
										} else {};
									} else {};
								};
							};
							if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
								return reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap), function(name:String) return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null));
							};
							haxe.Log.trace("[AST Builder] Checking if block with " + el.length + " statements is list-building", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1912, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(el)) {
								haxe.Log.trace("[AST Builder] Detected list-building block, converting to EList", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1916, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								var listElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(el);
								if (listElements != null && listElements.length > 0) {
									var elements = {
										var ` = [];
										{
											var ` = 0;
											while (` < listElements.length) {
												var e = listElements[`];
												++ `;
												`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
											};
										};
										`;
									};
									return reflaxe.elixir.ast.ElixirASTDef.EList(elements);
								};
							} else {
								if (el.length > 0 && el.length < 10) {
									haxe.Log.trace("[AST Builder] Not a list-building block. First stmt: " + Std.string(el[0].expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1926, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
									if (el.length > 1) {
										haxe.Log.trace("[AST Builder] Second stmt: " + Std.string(el[1].expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 1927, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
									};
								};
							};
							if (el.length == 2) {
								@:ast(switch ([el[0].expr, el[1].expr]) {
	case [TVar(v, init), expr] if (init != null):
		var isUsed = if (variableUsageMap != null && variableUsageMap.exists(v.id)) {
			variableUsageMap.get(v.id);
		} else {
			true;
		};
		var baseName = toElixirVarName(v.name);
		var varName = if (!isUsed) {
			"_" + baseName;
		} else {
			baseName;
		};
		var initExpr = buildFromTypedExpr(init, variableUsageMap);
		var bodyExpr = buildFromTypedExpr(el[1], variableUsageMap);
		var isInCaseClause = currentClauseContext != null;
		if (!isInCaseClause) {
			var usageCount = countVarOccurrencesInAST(bodyExpr, varName);
			if (usageCount == 1) {
				var inlined = replaceVarInAST(bodyExpr, varName, initExpr);
				return inlined.def;
			};
		};
		return EBlock([makeAST(EMatch(PVar(varName), initExpr)), bodyExpr]);	
	default:
}) {
									var ` = el[0].expr;
									var ` = el[1].expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											var expr = `;
											if (init != null) {
												var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap != null && {
													var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
													var key = v.id;
													cast this.exists(key);
												}) {
													{
														var this = reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap;
														var key = v.id;
														cast this.get(key);
													};
												} else {
													true;
												};
												var baseName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
												var varName = if (! isUsed) {
													"_" + baseName;
												} else {
													baseName;
												};
												var initExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												var bodyExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[1], reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												var isInCaseClause = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext != null;
												if (! isInCaseClause) {
													var usageCount = reflaxe.elixir.ast.ElixirASTBuilder.countVarOccurrencesInAST(bodyExpr, varName);
													if (usageCount == 1) {
														var inlined = reflaxe.elixir.ast.ElixirASTBuilder.replaceVarInAST(bodyExpr, varName, initExpr);
														return inlined.def;
													};
												};
												return reflaxe.elixir.ast.ElixirASTDef.EBlock([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), initExpr), metadata : {}, pos : pos};
												}, bodyExpr]);
											} else {};
										};
									} else {};
								};
							};
							var expressions = {
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var e = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap));
									};
								};
								`;
							};
							var needsCombining = false;
							{
								var ` = 0;
								var ` = expressions.length - 1;
								while (` < `) {
									var i = ` ++;
									var current = expressions[i];
									var next = expressions[i + 1];
									@:ast(switch ([current.def, next.def]) {
	case [EMatch(_, _), ECall(_, _, _)]:
		needsCombining = true;
		break;	
	case _:
}) {
										var ` = current.def;
										var ` = next.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 22) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													needsCombining = true;
													break;
												};
											} else {};
										} else {};
									};
								};
							};
							if (needsCombining) {
								var combinedBlock = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(expressions), metadata : {}, pos : pos};
								};
								var transformed = reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass(combinedBlock);
								transformed.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.EBlock(expressions);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var v = `;
						var e1 = `;
						var e2 = `;
						{
							var elixirVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
							var idKey = Std.string(v.id);
							var oldMapping = {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
								cast this.get(idKey);
							};
							if (v.name != elixirVarName) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									cast this.set(idKey, elixirVarName);
								};
							};
							var pattern = reflaxe.elixir.ast.EPattern.PVar(elixirVarName);
							var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, null);
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, null);
							if (oldMapping != null) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									cast this.set(idKey, oldMapping);
								};
							} else {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.tempVarRenameMap;
									cast this.remove(idKey);
								};
							};
							reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : expr}], [], body, null, false);
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							var condition = @:ast(switch (econd.expr) {
	case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
		makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));	
	case _:
		buildFromTypedExpr(econd, variableUsageMap);	
}) {
								var ` = econd.expr;
								if (enumIndex ` == 14) {
									var ` = `[0];
									{
										var el = `;
										if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
											{
												var def = reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) {
													return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
												}, function(name:String) {
													return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null);
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
										};
									};
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
								};
							};
							var thenBranch = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(eif, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
							var elseBranch = if (eelse != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(eelse, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
							} else {
								null;
							};
							reflaxe.elixir.ast.ElixirASTDef.EIf(condition, thenBranch, elseBranch);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var e = `;
						var normalWhile = `;
						{
							var isArrayLoop = false;
							var arrayRef = null;
							@:ast(switch (econd.expr) {
	case TBinop(OpLt, { expr : TLocal(indexVar) }, { expr : TField(arr, FInstance(_, _, cf)) }) if (indexVar.name.startsWith("_g") && cf.get().name == "length"):
		isArrayLoop = true;
		arrayRef = arr;	
	case _:
}) {
								var ` = econd.expr;
								if (enumIndex ` == 3) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (enumIndex ` == 9) {
										{
											var ` = `.expr;
											var ` = `.pos;
											var ` = `.t;
											if (enumIndex ` == 1) {
												var ` = `[0];
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 4) {
														var ` = `[0];
														var ` = `[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var cf = `;
																var arr = `;
																var indexVar = `;
																if (StringTools.startsWith(indexVar.name, "_g") && cf.get().name == "length") {
																	isArrayLoop = true;
																	arrayRef = arr;
																} else {};
															};
														} else {};
													} else {};
												};
											} else {};
										};
									} else {};
								} else {};
							};
							if (isArrayLoop && arrayRef != null) {
								var pattern = reflaxe.elixir.ast.ElixirASTPatterns.detectArrayOperationPattern(e);
								if (pattern != null) {
									return reflaxe.elixir.ast.ElixirASTBuilder.generateIdiomaticEnumCall(arrayRef, pattern, e);
								};
							};
							var condition = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, null);
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null);
							var loopName = "loop_" + (reflaxe.elixir.ast.ElixirASTBuilder.whileLoopCounter ++);
							var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(e);
							var conditionVars = {
								{};
								new haxe.ds.IntMap();
							};
							var findConditionVars = [null];
							findConditionVars[0] = function(expr:haxe.macro.TypedExpr) {
								if (expr == null) {
									return;
								};
								@:ast(switch (expr.expr) {
	case TLocal(v):
		conditionVars.set(v.id, v);	
	default:
		haxe.macro.TypedExprTools.iter(expr, findConditionVars);	
}) {
									var ` = expr.expr;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var v = `;
											{
												{
													var key = v.id;
													conditionVars.set(key, v);
												};
											};
										};
									} else {
										haxe.macro.TypedExprTools.iter(expr, findConditionVars[0]);
									};
								};
							};
							findConditionVars[0](econd);
							for (v in conditionVars.iterator()) {
								if (! {
									var key = v.id;
									mutatedVars.exists(key);
								}) {
									{
										var key = v.id;
										mutatedVars.set(key, v);
									};
								};
							};
							if (Lambda.count(cast mutatedVars, null) > 0) {
								var accVarList = [];
								for (v in mutatedVars.iterator()) {
									accVarList.push({name : reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null), tvar : v});
								};
								accVarList.sort(function(a:{ tvar : haxe.macro.TVar, name : String }, b:{ tvar : haxe.macro.TVar, name : String }) return a.tvar.id - b.tvar.id);
								var initialAccValues = [];
								var accPattern = [];
								var accVarNames = [];
								{
									var ` = 0;
									while (` < accVarList.length) {
										var v = accVarList[`];
										++ `;
										var varName = v.name;
										initialAccValues.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
										});
										accPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_" + varName));
										accVarNames.push(varName);
									};
								};
								initialAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
								});
								accPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_state"));
								var initialAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(initialAccValues), metadata : {}, pos : pos};
								};
								var accPatternTuple = reflaxe.elixir.ast.EPattern.PTuple(accPattern);
								var contAccValues = [];
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										contAccValues.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
										});
									};
								};
								contAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
								});
								var contAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(contAccValues), metadata : {}, pos : pos};
								};
								var varMapping = {
									{};
									new haxe.ds.StringMap();
								};
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										{
											varMapping.set(varName, "acc_" + varName);
										};
									};
								};
								var transformedCondition = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(condition, varMapping);
								var transformedBody = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(body, varMapping);
								var bodyHasReturn = reflaxe.elixir.ast.ElixirASTBuilder.checkForEarlyReturns(transformedBody);
								var updatedContAccValues = [];
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										updatedContAccValues.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_" + varName), metadata : {}, pos : pos};
										});
									};
								};
								updatedContAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
								});
								var updatedContAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(updatedContAccValues), metadata : {}, pos : pos};
								};
								var wrappedBody = if (bodyHasReturn) {
									reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(transformedBody, updatedContAccumulator);
								} else {
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
											}, updatedContAccumulator]), metadata : {}, pos : pos};
										}]), metadata : {}, pos : pos};
									};
								};
								var completeBody = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, wrappedBody, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
										}, updatedContAccumulator]), metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
								var usedAccVars = {
									{};
									new haxe.ds.StringMap();
								};
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										var accVarName = "acc_" + varName;
										{
											var value = reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(accVarName, completeBody);
											usedAccVars.set(varName, value);
										};
									};
								};
								var isAccStateUsed = reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST("acc_state", completeBody);
								var finalAccPattern = [];
								{
									var ` = 0;
									var ` = accVarNames.length;
									while (` < `) {
										var i = ` ++;
										var varName = accVarNames[i];
										var accVarName = "acc_" + varName;
										if (cast usedAccVars.get(varName)) {
											finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar(accVarName));
										} else {
											finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar("_" + accVarName));
										};
									};
								};
								if (isAccStateUsed) {
									finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_state"));
								} else {
									finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar("_acc_state"));
								};
								var finalAccPatternTuple = reflaxe.elixir.ast.EPattern.PTuple(finalAccPattern);
								var reduceResult = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "reduce_while", [{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Stream"), metadata : {}, pos : pos};
									}, "iterate", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("n")], guard : null, body : {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("n"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										}}]), metadata : {}, pos : pos};
									}]), metadata : {}, pos : pos};
								}, initialAccumulator, {
									var isEmptyBody = @:ast(switch (transformedBody.def) {
	case ENil:
		true;	
	case _:
		false;	
}) {
										var ` = transformedBody.def;
										if (enumIndex ` == 36) {
											{
												true;
											};
										} else {
											false;
										};
									};
									var accPatternToUse = if (isEmptyBody && Lambda.count(cast mutatedVars, null) > 0) {
										var wildcardPatterns = [];
										{
											var ` = 0;
											var ` = (accVarNames.length + 1);
											while (` < `) {
												var i = ` ++;
												wildcardPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
										reflaxe.elixir.ast.EPattern.PTuple(wildcardPatterns);
									} else {
										finalAccPatternTuple;
									};
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PWildcard, accPatternToUse], guard : null, body : {
											var updatedContAccValues = [];
											{
												var ` = 0;
												while ((` < accVarNames.length)) {
													var varName = accVarNames[`];
													++ `;
													updatedContAccValues.push({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_" + varName), metadata : {}, pos : pos};
													});
												};
											};
											updatedContAccValues.push({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
											});
											var updatedContAccumulator = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(updatedContAccValues), metadata : {}, pos : pos};
											};
											var wrappedBody = if ((bodyHasReturn)) reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(transformedBody, updatedContAccumulator) else if ((isEmptyBody)) {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
												}, updatedContAccumulator]), metadata : {}, pos : pos};
											} else {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
													}, updatedContAccumulator]), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, wrappedBody, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
													}, if ((isEmptyBody)) {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
													} else updatedContAccumulator]), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											};
										}}]);
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									};
								}]);
								reduceResult;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "reduce_while", [{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Stream"), metadata : {}, pos : pos};
									}, "iterate", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("n")], guard : null, body : {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("n"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										}}]), metadata : {}, pos : pos};
									}]), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PWildcard, reflaxe.elixir.ast.EPattern.PVar("acc")], guard : null, body : {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condition, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([body, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
												}, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											}]), metadata : {}, pos : pos};
										}, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
											}]), metadata : {}, pos : pos};
										}), metadata : {}, pos : pos};
									}}]), metadata : {}, pos : pos};
								}]);
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var cases = `;
						var edef = `;
						{
							var extractEnumTypeFromSwitch = [null];
							extractEnumTypeFromSwitch[0] = function(expr:haxe.macro.TypedExpr) {
								return @:ast(switch (expr.expr) {
	case TParenthesis(innerExpr):
		extractEnumTypeFromSwitch(innerExpr);	
	case TMeta(_, innerExpr):
		extractEnumTypeFromSwitch(innerExpr);	
	case TEnumIndex(enumExpr):
		switch (enumExpr.t) {
			case TEnum(enumRef, _):
				enumRef.get();			
			default:
				null;			
		};	
	default:
		switch (expr.t) {
			case TEnum(enumRef, _):
				enumRef.get();			
			default:
				null;			
		};	
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 6: {
											var ` = `[0];
											{
												var innerExpr = `;
												{
													extractEnumTypeFromSwitch[0](innerExpr);
												};
											};
										};
										case 25: {
											var ` = `[0];
											var ` = `[1];
											{
												var innerExpr = `;
												{
													extractEnumTypeFromSwitch[0](innerExpr);
												};
											};
										};
										case 27: {
											var ` = `[0];
											{
												var enumExpr = `;
												{
													@:ast(switch (enumExpr.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		null;	
}) {
														var ` = enumExpr.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															var ` = `[1];
															{
																var enumRef = `;
																{
																	enumRef.get();
																};
															};
														} else {
															null;
														};
													};
												};
											};
										};
										default: {
											@:ast(switch (expr.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		null;	
}) {
												var ` = expr.t;
												if (enumIndex ` == 1) {
													var ` = `[0];
													var ` = `[1];
													{
														var enumRef = `;
														{
															enumRef.get();
														};
													};
												} else {
													null;
												};
											};
										}
									};
								};
							};
							var enumType = extractEnumTypeFromSwitch[0](e);
							var isIdiomaticEnum = enumType != null;
							var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
							var clauses = [];
							var needsTempVar = false;
							var tempVarName = "temp_result";
							var isReturnContext = false;
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									var extractedParams = reflaxe.elixir.ast.ElixirASTBuilder.analyzeEnumParameterExtraction(c.expr);
									var varMapping = reflaxe.elixir.ast.ElixirASTBuilder.createVariableMappingsForCase(c.expr, extractedParams, enumType, c.values);
									var patterns = if (isIdiomaticEnum && enumType != null) {
										{
											var ` = [];
											{
												var ` = 0;
												var ` = c.values;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithExtraction(v, enumType, extractedParams));
												};
											};
											`;
										};
									} else {
										{
											var ` = [];
											{
												var ` = 0;
												var ` = c.values;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(v));
												};
											};
											`;
										};
									};
									var savedClauseContext = reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext;
									reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext = new reflaxe.elixir.ast.ClauseContext(null, varMapping);
									var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(c.expr, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
									if (body.metadata == null) {
										body.metadata = {};
									};
									body.metadata.varIdToName = varMapping;
									reflaxe.elixir.ast.ElixirASTBuilder.currentClauseContext = savedClauseContext;
									{
										var ` = 0;
										while (` < patterns.length) {
											var pattern = patterns[`];
											++ `;
											clauses.push({pattern : pattern, guard : null, body : body});
										};
									};
								};
							};
							if (edef != null) {
								clauses.push({pattern : reflaxe.elixir.ast.EPattern.PWildcard, guard : null, body : reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(edef, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap)});
							};
							var caseASTDef = reflaxe.elixir.ast.ElixirASTDef.ECase({
								var pos = null;
								{def : expr, metadata : {}, pos : pos};
							}, clauses);
							if (isReturnContext && needsTempVar) {
								reflaxe.elixir.ast.ElixirASTDef.EBlock([{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tempVarName), {
										var pos = null;
										{def : caseASTDef, metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVarName), metadata : {}, pos : pos};
								}]);
							} else {
								caseASTDef;
							};
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null);
							var rescueClauses = [];
							{
								var ` = 0;
								while (` < catches.length) {
									var c = catches[`];
									++ `;
									var pattern = reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(c.v.name, null));
									var catchBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(c.expr, null);
									rescueClauses.push({pattern : pattern, body : catchBody});
								};
							};
							reflaxe.elixir.ast.ElixirASTDef.ETry(body, rescueClauses, [], null, null);
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var e = `;
						{
							if (e != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.ENil;
							};
						};
					};
				};
				case 21: {
					{
						reflaxe.elixir.ast.ElixirASTDef.EThrow({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "break"), metadata : {}, pos : pos};
						});
					};
				};
				case 22: {
					{
						reflaxe.elixir.ast.ElixirASTDef.EThrow({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "continue"), metadata : {}, pos : pos};
						});
					};
				};
				case 23: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EThrow(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null));
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var m = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null).def;
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var m = `;
						var e = `;
						{
							if (m.name == ":mergeBlock") {
								@:ast(switch (e.expr) {
	case TBlock([{ expr : TVar(tmpVar, init) }, secondExpr]) if (init != null):
		switch (secondExpr.expr) {
			case TIf(condition, thenBranch, elseBranch):
				var isNullCheck = switch (condition.expr) {
					case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
						v.id == tmpVar.id;					
					default:
						false;					
				};
				if (isNullCheck) {
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var initAst = buildFromTypedExpr(init, variableUsageMap);
					var elseAst = buildFromTypedExpr(elseBranch);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					return ifExpr.def;
				};			
			default:
		};	
	default:
}) {
									var ` = e.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 13) {
													var ` = `[0];
													var ` = `[1];
													{
														var tmpVar = `;
														var init = `;
														var secondExpr = `;
														if (init != null) {
															@:ast(switch (secondExpr.expr) {
	case TIf(condition, thenBranch, elseBranch):
		var isNullCheck = switch (condition.expr) {
			case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
				v.id == tmpVar.id;			
			default:
				false;			
		};
		if (isNullCheck) {
			var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
			var initAst = buildFromTypedExpr(init, variableUsageMap);
			var elseAst = buildFromTypedExpr(elseBranch);
			var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
			if (ifExpr.metadata == null) ifExpr.metadata = { };
			ifExpr.metadata.keepInlineInAssignment = true;
			return ifExpr.def;
		};	
	default:
}) {
																var ` = secondExpr.expr;
																if (enumIndex ` == 16) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var condition = `;
																		var thenBranch = `;
																		var elseBranch = `;
																		{
																			var isNullCheck = @:ast(switch (condition.expr) {
	case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
		v.id == tmpVar.id;	
	default:
		false;	
}) {
																				var ` = condition.expr;
																				if (enumIndex ` == 6) {
																					var ` = `[0];
																					{
																						var ` = `.expr;
																						var ` = `.pos;
																						var ` = `.t;
																						if (enumIndex ` == 3) {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							if (enumIndex ` == 6) {
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 0) {
																												var ` = `[0];
																												if (enumIndex ` == 4) {
																													{
																														var v = `;
																														{
																															v.id == tmpVar.id;
																														};
																													};
																												} else {
																													false;
																												};
																											} else {
																												false;
																											};
																										};
																									} else {
																										false;
																									};
																								};
																							} else {
																								false;
																							};
																						} else {
																							false;
																						};
																					};
																				} else {
																					false;
																				};
																			};
																			if (isNullCheck) {
																				var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																					tmpVar.name.substr(1, null);
																				} else {
																					tmpVar.name;
																				}, null);
																				var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap);
																				var elseAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(elseBranch, null);
																				var ifExpr = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EParen({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																							}), metadata : {}, pos : pos};
																						}, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					}, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																					}, elseAst), metadata : {}, pos : pos};
																				};
																				if (ifExpr.metadata == null) {
																					ifExpr.metadata = {};
																				};
																				ifExpr.metadata.keepInlineInAssignment = true;
																				return ifExpr.def;
																			};
																		};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									} else {};
								};
							};
							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null).def;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var ef = `;
						var index = `;
						{
							var exprAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, null);
							var field = ef.name;
							reflaxe.elixir.ast.ElixirASTDef.ECall(exprAST, "elem", [{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index + 1), metadata : {}, pos : pos};
							}]);
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.variableUsageMap).def;
						};
					};
				};
				case 28: {
					var ` = `[0];
					{
						var s = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(s, null));
						};
					};
				};
			};
		};
	}

	static function tryOptimizeArrayPattern(econd:haxe.macro.TypedExpr, ebody:haxe.macro.TypedExpr) {
		var isArrayPattern = false;
		var arrayVarName = "";
		var indexVarName = "";
		@:ast(switch (econd.expr) {
	case TBinop(OpLt, e1, e2):
		switch (e1.expr) {
			case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
				switch (e2.expr) {
					case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
						switch (arrayRef.expr) {
							case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
								isArrayPattern = true;
								indexVarName = indexVar.name;
								arrayVarName = arrayVar.name;							
							case _:
								isArrayPattern = true;
								indexVarName = indexVar.name;							
						};					
					case _:
				};			
			case _:
		};	
	case _:
}) {
			var ` = econd.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 9) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e1.expr) {
	case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
		switch (e2.expr) {
			case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
				switch (arrayRef.expr) {
					case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
						isArrayPattern = true;
						indexVarName = indexVar.name;
						arrayVarName = arrayVar.name;					
					case _:
						isArrayPattern = true;
						indexVarName = indexVar.name;					
				};			
			case _:
		};	
	case _:
}) {
								var ` = e1.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var indexVar = `;
										if (StringTools.startsWith(indexVar.name, "_g")) {
											@:ast(switch (e2.expr) {
	case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
		switch (arrayRef.expr) {
			case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
				isArrayPattern = true;
				indexVarName = indexVar.name;
				arrayVarName = arrayVar.name;			
			case _:
				isArrayPattern = true;
				indexVarName = indexVar.name;			
		};	
	case _:
}) {
												var ` = e2.expr;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var arrayRef = `;
															if (cf.get().name == "length") {
																@:ast(switch (arrayRef.expr) {
	case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
		isArrayPattern = true;
		indexVarName = indexVar.name;
		arrayVarName = arrayVar.name;	
	case _:
		isArrayPattern = true;
		indexVarName = indexVar.name;	
}) {
																	var ` = arrayRef.expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var arrayVar = `;
																			if (StringTools.startsWith(arrayVar.name, "_g")) {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																				arrayVarName = arrayVar.name;
																			} else {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																			};
																		};
																	} else {
																		isArrayPattern = true;
																		indexVarName = indexVar.name;
																	};
																};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								} else {};
							};
						};
					};
				} else {};
			} else {};
		};
		if (! isArrayPattern) {
			return null;
		};
		var bodyAnalysis = reflaxe.elixir.ast.ElixirASTBuilder.analyzeLoopBody(ebody);
		var arrayExpr = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if ((arrayVarName.length > 0)) arrayVarName else "_g2", null));
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		if (bodyAnalysis.hasMapPattern) {
			return reflaxe.elixir.ast.ElixirASTBuilder.generateEnumMapSimple(arrayExpr, bodyAnalysis, ebody);
		} else {
			if (bodyAnalysis.hasFilterPattern) {
				return reflaxe.elixir.ast.ElixirASTBuilder.generateEnumFilterSimple(arrayExpr, bodyAnalysis, ebody);
			} else {
				if (bodyAnalysis.hasReducePattern) {
					return null;
				};
			};
		};
		return null;
	}

	static function detectArrayIterationPattern(econd:haxe.macro.TypedExpr) {
		return @:ast(switch (econd.expr) {
	case TBinop(OpLt, e1, e2):
		switch (e2.expr) {
			case TField(arrayExpr, FInstance(_, _, cf)):
				if (cf.get().name == "length") {
					switch (arrayExpr.expr) {
						case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
							switch (e1.expr) {
								case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
									return { arrayExpr : arrayExpr, indexVar : indexVar.name };								
								case _:
									null;								
							};						
						case _:
							switch (e1.expr) {
								case TLocal(v) if (v.name.startsWith("_g")):
									return { arrayExpr : arrayExpr, indexVar : v.name };								
								case _:
									null;								
							};						
					};
				};
				null;			
			case _:
				null;			
		};
		null;	
	case _:
		null;	
}) {
			var ` = econd.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 9) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e2.expr) {
	case TField(arrayExpr, FInstance(_, _, cf)):
		if (cf.get().name == "length") {
			switch (arrayExpr.expr) {
				case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
					switch (e1.expr) {
						case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
							return { arrayExpr : arrayExpr, indexVar : indexVar.name };						
						case _:
							null;						
					};				
				case _:
					switch (e1.expr) {
						case TLocal(v) if (v.name.startsWith("_g")):
							return { arrayExpr : arrayExpr, indexVar : v.name };						
						case _:
							null;						
					};				
			};
		};
		null;	
	case _:
		null;	
}) {
								var ` = e2.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cf = `;
											var arrayExpr = `;
											{
												if (cf.get().name == "length") {
													@:ast(switch (arrayExpr.expr) {
	case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
		switch (e1.expr) {
			case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
				return { arrayExpr : arrayExpr, indexVar : indexVar.name };			
			case _:
				null;			
		};	
	case _:
		switch (e1.expr) {
			case TLocal(v) if (v.name.startsWith("_g")):
				return { arrayExpr : arrayExpr, indexVar : v.name };			
			case _:
				null;			
		};	
}) {
														var ` = arrayExpr.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var arrayVar = `;
																if (StringTools.startsWith(arrayVar.name, "_g")) {
																	@:ast(switch (e1.expr) {
	case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : indexVar.name };	
	case _:
		null;	
}) {
																		var ` = e1.expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var indexVar = `;
																				if (StringTools.startsWith(indexVar.name, "_g")) {
																					return {arrayExpr : arrayExpr, indexVar : indexVar.name};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	@:ast(switch (e1.expr) {
	case TLocal(v) if (v.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : v.name };	
	case _:
		null;	
}) {
																		var ` = e1.expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (StringTools.startsWith(v.name, "_g")) {
																					return {arrayExpr : arrayExpr, indexVar : v.name};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																};
															};
														} else {
															@:ast(switch (e1.expr) {
	case TLocal(v) if (v.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : v.name };	
	case _:
		null;	
}) {
																var ` = e1.expr;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	{
																		var v = `;
																		if (StringTools.startsWith(v.name, "_g")) {
																			return {arrayExpr : arrayExpr, indexVar : v.name};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
														};
													};
												};
												null;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
							null;
						};
					};
				} else {
					null;
				};
			} else {
				null;
			};
		};
		return null;
	}

	static function analyzeLoopBody(ebody:haxe.macro.TypedExpr) {
		var result = {hasMapPattern : false, hasFilterPattern : false, hasReducePattern : false, loopVar : null, pushTarget : null};
		var analyze = [null];
		analyze[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) analyze(e);	
	case TVar(v, init):
		if (init != null) {
			switch (init.expr) {
				case TArray(_, _):
					result.loopVar = v;				
				case _:
			};
		};	
	case TCall(e, args):
		switch (e.expr) {
			case TField(target, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					result.hasMapPattern = true;
					switch (target.expr) {
						case TLocal(v):
							result.pushTarget = v.name;						
						case _:
					};
				};			
			case _:
		};	
	case TIf(cond, thenExpr, elseExpr):
		analyze(thenExpr);
		if (elseExpr != null) analyze(elseExpr);
		if (result.hasMapPattern) {
			result.hasFilterPattern = true;
			result.hasMapPattern = false;
		};	
	case TBinop(OpAssignOp(OpAdd), _, _):
		result.hasReducePattern = true;	
	case _:
		haxe.macro.TypedExprTools.iter(expr, analyze);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 20) {
							var ` = `[0];
							if (enumIndex ` == 0) {
								{
									result.hasReducePattern = true;
								};
							} else {
								haxe.macro.TypedExprTools.iter(expr, analyze[0]);
							};
						} else {
							haxe.macro.TypedExprTools.iter(expr, analyze[0]);
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								@:ast(switch (e.expr) {
	case TField(target, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			result.hasMapPattern = true;
			switch (target.expr) {
				case TLocal(v):
					result.pushTarget = v.name;				
				case _:
			};
		};	
	case _:
}) {
									var ` = e.expr;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var target = `;
												{
													if (cf.get().name == "push") {
														result.hasMapPattern = true;
														@:ast(switch (target.expr) {
	case TLocal(v):
		result.pushTarget = v.name;	
	case _:
}) {
															var ` = target.expr;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var v = `;
																	{
																		result.pushTarget = v.name;
																	};
																};
															} else {};
														};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							{
								if (init != null) {
									@:ast(switch (init.expr) {
	case TArray(_, _):
		result.loopVar = v;	
	case _:
}) {
										var ` = init.expr;
										if (enumIndex ` == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												result.loopVar = v;
											};
										} else {};
									};
								};
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										analyze[0](e);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenExpr = `;
							var elseExpr = `;
							{
								analyze[0](thenExpr);
								if (elseExpr != null) {
									analyze[0](elseExpr);
								};
								if (result.hasMapPattern) {
									result.hasFilterPattern = true;
									result.hasMapPattern = false;
								};
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, analyze[0]);
					}
				};
			};
		};
		analyze[0](ebody);
		return result;
	}

	static function generateEnumMapSimple(arrayExpr:reflaxe.elixir.ast.ElixirAST, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var transformation = reflaxe.elixir.ast.ElixirASTBuilder.extractMapTransformation(ebody, analysis.loopVar);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : transformation}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.map", [arrayExpr, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumFilterSimple(arrayExpr:reflaxe.elixir.ast.ElixirAST, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var condition = reflaxe.elixir.ast.ElixirASTBuilder.extractFilterCondition(ebody);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : condition}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.filter", [arrayExpr, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumMap(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayExpr, null);
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var transformation = reflaxe.elixir.ast.ElixirASTBuilder.extractMapTransformation(ebody, analysis.loopVar);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : transformation}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.map", [arrayAST, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumFilter(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayExpr, null);
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var condition = reflaxe.elixir.ast.ElixirASTBuilder.extractFilterCondition(ebody);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : condition}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.filter", [arrayAST, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumReduce(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		return null;
	}

	static function extractMapTransformation(ebody:haxe.macro.TypedExpr, loopVar:Null<haxe.macro.TVar>) {
		var findPushArg = [null];
		findPushArg[0] = function(expr:haxe.macro.TypedExpr) {
			return @:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = findPushArg(e);
			if (result != null) return result;
		};
		null;	
	case TCall(e, [arg]):
		switch (e.expr) {
			case TField(_, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					return arg;
				};
				null;			
			case _:
				null;			
		};
		null;	
	case _:
		null;	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 9: {
						var ` = `[0];
						var ` = `[1];
						if (`.length == 1) {
							var ` = `[0];
							{
								var arg = `;
								var e = `;
								{
									@:ast(switch (e.expr) {
	case TField(_, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			return arg;
		};
		null;	
	case _:
		null;	
}) {
										var ` = e.expr;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cf = `;
													{
														if (cf.get().name == "push") {
															return arg;
														};
														null;
													};
												};
											} else {
												null;
											};
										} else {
											null;
										};
									};
									null;
								};
							};
						} else {
							null;
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										var result = findPushArg[0](e);
										if (result != null) {
											return result;
										};
									};
								};
								null;
							};
						};
					};
					default: {
						null;
					}
				};
			};
		};
		var pushArg = findPushArg[0](ebody);
		if (pushArg != null) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithSubstitution(pushArg, loopVar);
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("item"), metadata : {}, pos : pos};
		};
	}

	static function extractFilterCondition(ebody:haxe.macro.TypedExpr) {
		var findIfCondition = [null];
		findIfCondition[0] = function(expr:haxe.macro.TypedExpr) {
			return @:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = findIfCondition(e);
			if (result != null) return result;
		};
		null;	
	case TIf(cond, thenExpr, _):
		if (containsPush(thenExpr)) {
			return cond;
		};
		null;	
	case _:
		null;	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										var result = findIfCondition[0](e);
										if (result != null) {
											return result;
										};
									};
								};
								null;
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenExpr = `;
							{
								if (reflaxe.elixir.ast.ElixirASTBuilder.containsPush(thenExpr)) {
									return cond;
								};
								null;
							};
						};
					};
					default: {
						null;
					}
				};
			};
		};
		var cond = findIfCondition[0](ebody);
		if (cond != null) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, null);
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), metadata : {}, pos : pos};
		};
	}

	static function containsPush(expr:haxe.macro.TypedExpr) {
		var hasPush = [false];
		var check = [null];
		check[0] = function(e:haxe.macro.TypedExpr) {
			@:ast(switch (e.expr) {
	case TCall(target, _):
		switch (target.expr) {
			case TField(_, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					hasPush = true;
				};			
			case _:
		};	
	case _:
		if (!hasPush) {
			haxe.macro.TypedExprTools.iter(e, check);
		};	
}) {
				var ` = e.expr;
				if (enumIndex ` == 9) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						{
							@:ast(switch (target.expr) {
	case TField(_, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			hasPush = true;
		};	
	case _:
}) {
								var ` = target.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cf = `;
											{
												if (cf.get().name == "push") {
													hasPush[0] = true;
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				} else {
					if (! hasPush[0]) {
						haxe.macro.TypedExprTools.iter(e, check[0]);
					};
				};
			};
		};
		check[0](expr);
		return hasPush[0];
	}

	static function processEnumCaseBody(caseExpr:haxe.macro.TypedExpr, builtBody:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (caseExpr.expr) {
	case TBlock(exprs):
		var modifiedExprs = [];
		var unusedVars = new Map<String,Bool>();
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TEnumParameter(_, _, _):
							var isUsed = false;
							for (i  in  (exprs.indexOf(expr) + 1) ... exprs.length) {
								if (reflaxe.elixir.helpers.UsageDetector.isVariableUsed(v.id, exprs[i])) {
									isUsed = true;
									break;
								};
							};
							if (!isUsed) {
								unusedVars.set(v.name, true);
							};						
						default:
					};				
				default:
			};
		};
		if (Lambda.count(unusedVars) > 0) {
			return prefixUnusedVariablesInAST(builtBody, unusedVars);
		};	
	default:
}) {
			var ` = caseExpr.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var modifiedExprs = [];
						var unusedVars = {
							{};
							new haxe.ds.StringMap();
						};
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, _):
				var isUsed = false;
				for (i  in  (exprs.indexOf(expr) + 1) ... exprs.length) {
					if (reflaxe.elixir.helpers.UsageDetector.isVariableUsed(v.id, exprs[i])) {
						isUsed = true;
						break;
					};
				};
				if (!isUsed) {
					unusedVars.set(v.name, true);
				};			
			default:
		};	
	default:
}) {
									var ` = expr.expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											if (init != null) {
												@:ast(switch (init.expr) {
	case TEnumParameter(_, _, _):
		var isUsed = false;
		for (i  in  (exprs.indexOf(expr) + 1) ... exprs.length) {
			if (reflaxe.elixir.helpers.UsageDetector.isVariableUsed(v.id, exprs[i])) {
				isUsed = true;
				break;
			};
		};
		if (!isUsed) {
			unusedVars.set(v.name, true);
		};	
	default:
}) {
													var ` = init.expr;
													if (enumIndex ` == 26) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var isUsed = false;
															{
																var ` = (exprs.indexOf(expr, null) + 1);
																var ` = exprs.length;
																while (` < `) {
																	var i = ` ++;
																	if (reflaxe.elixir.helpers.UsageDetector.isVariableUsed(v.id, exprs[i])) {
																		isUsed = true;
																		break;
																	};
																};
															};
															if (! isUsed) {
																{
																	var key = v.name;
																	unusedVars.set(key, true);
																};
															};
														};
													} else {};
												};
											} else {};
										};
									} else {};
								};
							};
						};
						if (Lambda.count(cast unusedVars, null) > 0) {
							return reflaxe.elixir.ast.ElixirASTBuilder.prefixUnusedVariablesInAST(builtBody, unusedVars);
						};
					};
				};
			} else {};
		};
		return builtBody;
	}

	static function prefixUnusedVariablesInAST(ast:reflaxe.elixir.ast.ElixirAST, unusedVars:Map<String, Bool>) {
		return ast;
	}

	static function buildFromTypedExprWithSubstitution(expr:haxe.macro.TypedExpr, loopVar:Null<haxe.macro.TVar>) {
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, null);
	}

	static function createMetadata(expr:haxe.macro.TypedExpr) {
		return {sourceExpr : expr, sourceLine : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).min;
		} else {
			0;
		}, sourceFile : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).file;
		} else {
			null;
		}, type : expr.t, elixirType : reflaxe.elixir.ast.ElixirASTBuilder.typeToElixir(expr.t), purity : cast reflaxe.elixir.ast.ElixirASTBuilder.isPure(expr), tailPosition : cast false, async : cast false, requiresReturn : cast false, requiresTempVar : cast false, inPipeline : cast false, inComprehension : cast false, inGuard : cast false, canInline : cast reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(expr), isConstant : cast reflaxe.elixir.ast.ElixirASTBuilder.isConstant(expr), sideEffects : cast reflaxe.elixir.ast.ElixirASTBuilder.hasSideEffects(expr)};
	}

	static function convertPattern(value:haxe.macro.TypedExpr) {
		return @:ast(switch (value.expr) {
	case TConst(TInt(i)):
		PLiteral(makeAST(EInteger(i)));	
	case TConst(TFloat(f)):
		PLiteral(makeAST(EFloat(Std.parseFloat(f))));	
	case TConst(TString(s)):
		PLiteral(makeAST(EString(s)));	
	case TConst(TBool(b)):
		PLiteral(makeAST(EBoolean(b)));	
	case TConst(TNull):
		PLiteral(makeAST(ENil));	
	case TLocal(v):
		PVar(toElixirVarName(v.name));	
	case TEnumParameter(e, ef, index):
		PVar("_enum_param_" + index);	
	case TEnumIndex(e):
		PLiteral(makeAST(EInteger(0)));	
	case TArrayDecl(el):
		PList([for (e  in  el) convertPattern(e)]);	
	case TCall(e, el) if (isEnumConstructor(e)):
		var tag = extractEnumTag(e);
		if (hasIdiomaticMetadata(e)) {
			tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
		};
		var args = [for (arg  in  el) convertPattern(arg)];
		PTuple([PLiteral(makeAST(EAtom(tag)))].concat(args));	
	case TField(e, FEnum(enumRef, ef)):
		var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
		var isIdiomatic = enumRef.get().meta.has(":elixirIdiomatic") || true;
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount == 0) {
			PLiteral(makeAST(EAtom(atomName)));
		} else {
			var wildcards = [for (i  in  0 ... paramCount) PWildcard];
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(wildcards));
		};	
	default:
		PWildcard;	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					switch (enumIndex `) {
						case 0: {
							var ` = `[0];
							{
								var i = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(i), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 1: {
							var ` = `[0];
							{
								var f = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EFloat(Std.parseFloat(f));
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								};
							};
						};
						case 2: {
							var ` = `[0];
							{
								var s = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EString(s), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 3: {
							var ` = `[0];
							{
								var b = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(b), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 4: {
							{
								reflaxe.elixir.ast.EPattern.PLiteral({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
								});
							};
						};
						default: {
							reflaxe.elixir.ast.EPattern.PWildcard;
						}
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							var ef = `;
							var e = `;
							{
								var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
								var isIdiomatic = enumRef.get().meta.has(":elixirIdiomatic") || true;
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount == 0) {
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								} else {
									var wildcards = {
										var ` = [];
										{
											var ` = 0;
											var ` = paramCount;
											while (` < `) {
												var i = ` ++;
												`.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
										`;
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									})].concat(wildcards));
								};
							};
						};
					} else {
						reflaxe.elixir.ast.EPattern.PWildcard;
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							reflaxe.elixir.ast.EPattern.PList({
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var e = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(e));
									};
								};
								`;
							});
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						if (reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e)) {
							var tag = reflaxe.elixir.ast.ElixirASTBuilder.extractEnumTag(e);
							if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
								tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
							};
							var args = {
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var arg = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(arg));
									};
								};
								`;
							};
							reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
								var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
									var this;
									this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
									cast this;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							})].concat(args));
						} else {
							reflaxe.elixir.ast.EPattern.PWildcard;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var ef = `;
						var index = `;
						{
							reflaxe.elixir.ast.EPattern.PVar("_enum_param_" + index);
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.EPattern.PLiteral({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
							});
						};
					};
				};
				default: {
					reflaxe.elixir.ast.EPattern.PWildcard;
				}
			};
		};
	}

	static function analyzeEnumParameterExtraction(caseExpr:haxe.macro.TypedExpr) {
		var extractedParams = [];
		var tempVarMapping = {
			{};
			new haxe.ds.StringMap();
		};
		var tempVarToIndex = {
			{};
			new haxe.ds.StringMap();
		};
		@:ast(switch (caseExpr.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TEnumParameter(_, ef, index):
							var tempName = toElixirVarName(v.name);
							if (tempName.startsWith("_")) {
								tempName = tempName.substr(1);
							};
							tempVarMapping.set(tempName, { name : tempName, index : index });
							tempVarToIndex.set(v.name, index);
							while (extractedParams.length <= index) {
								extractedParams.push(null);
							};
							extractedParams[index] = tempName;
							trace("[DEBUG ENUM] Found TEnumParameter extraction: temp var \"$tempName\" at index $index");						
						default:
					};				
				default:
			};
		};
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TLocal(localVar):
							var tempName = toElixirVarName(localVar.name);
							if (tempName.startsWith("_")) {
								tempName = tempName.substr(1);
							};
							if (tempVarMapping.exists(tempName)) {
								var patternName = toElixirVarName(v.name);
								var info = tempVarMapping.get(tempName);
								extractedParams[info.index] = patternName;
								trace("[DEBUG ENUM] Mapped temp var \"$tempName\" to pattern var \"$patternName\" at index ${info.index}");
							};						
						default:
					};				
				default:
			};
		};
		var usedVariables = new Map<String,Bool>();
		function scanForUsedVariables(expr:TypedExpr):Void {
			switch (expr.expr) {
				case TLocal(v):
					var name = toElixirVarName(v.name);
					usedVariables.set(name, true);
					if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
						for (i  in  0 ... extractedParams.length) {
							if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
								extractedParams[i] = name;
								trace("[DEBUG ENUM] Replaced temp var \"${extractedParams[i]}\" with used variable \"$name\" at index $i");
								break;
							};
						};
					};				
				case TBlock(subExprs):
					for (e  in  subExprs) scanForUsedVariables(e);				
				case TBinop(_, e1, e2):
					scanForUsedVariables(e1);
					scanForUsedVariables(e2);				
				case TCall(e, args):
					scanForUsedVariables(e);
					for (arg  in  args) scanForUsedVariables(arg);				
				case TField(e, _):
					scanForUsedVariables(e);				
				case TIf(cond, ifExpr, elseExpr):
					scanForUsedVariables(cond);
					scanForUsedVariables(ifExpr);
					if (elseExpr != null) scanForUsedVariables(elseExpr);				
				case TThrow(e):
					scanForUsedVariables(e);				
				case TReturn(e):
					if (e != null) scanForUsedVariables(e);				
				case _:
			};
		};
		for (i  in  0 ... exprs.length) {
			scanForUsedVariables(exprs[i]);
		};	
	default:
}) {
			var ` = caseExpr.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, ef, index):
				var tempName = toElixirVarName(v.name);
				if (tempName.startsWith("_")) {
					tempName = tempName.substr(1);
				};
				tempVarMapping.set(tempName, { name : tempName, index : index });
				tempVarToIndex.set(v.name, index);
				while (extractedParams.length <= index) {
					extractedParams.push(null);
				};
				extractedParams[index] = tempName;
				trace("[DEBUG ENUM] Found TEnumParameter extraction: temp var \"$tempName\" at index $index");			
			default:
		};	
	default:
}) {
									var ` = expr.expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											if (init != null) {
												@:ast(switch (init.expr) {
	case TEnumParameter(_, ef, index):
		var tempName = toElixirVarName(v.name);
		if (tempName.startsWith("_")) {
			tempName = tempName.substr(1);
		};
		tempVarMapping.set(tempName, { name : tempName, index : index });
		tempVarToIndex.set(v.name, index);
		while (extractedParams.length <= index) {
			extractedParams.push(null);
		};
		extractedParams[index] = tempName;
		trace("[DEBUG ENUM] Found TEnumParameter extraction: temp var \"$tempName\" at index $index");	
	default:
}) {
													var ` = init.expr;
													if (enumIndex ` == 26) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var ef = `;
															var index = `;
															{
																var tempName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																if (StringTools.startsWith(tempName, "_")) {
																	tempName = tempName.substr(1, null);
																};
																{
																	tempVarMapping.set(tempName, {name : tempName, index : index});
																};
																{
																	var key = v.name;
																	tempVarToIndex.set(key, index);
																};
																while (extractedParams.length <= index) {
																	extractedParams.push(null);
																};
																extractedParams[index] = tempName;
																haxe.Log.trace("[DEBUG ENUM] Found TEnumParameter extraction: temp var \"" + tempName + "\" at index " + index, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 3800, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "analyzeEnumParameterExtraction"});
															};
														};
													} else {};
												};
											} else {};
										};
									} else {};
								};
							};
						};
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TLocal(localVar):
				var tempName = toElixirVarName(localVar.name);
				if (tempName.startsWith("_")) {
					tempName = tempName.substr(1);
				};
				if (tempVarMapping.exists(tempName)) {
					var patternName = toElixirVarName(v.name);
					var info = tempVarMapping.get(tempName);
					extractedParams[info.index] = patternName;
					trace("[DEBUG ENUM] Mapped temp var \"$tempName\" to pattern var \"$patternName\" at index ${info.index}");
				};			
			default:
		};	
	default:
}) {
									var ` = expr.expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											if (init != null) {
												@:ast(switch (init.expr) {
	case TLocal(localVar):
		var tempName = toElixirVarName(localVar.name);
		if (tempName.startsWith("_")) {
			tempName = tempName.substr(1);
		};
		if (tempVarMapping.exists(tempName)) {
			var patternName = toElixirVarName(v.name);
			var info = tempVarMapping.get(tempName);
			extractedParams[info.index] = patternName;
			trace("[DEBUG ENUM] Mapped temp var \"$tempName\" to pattern var \"$patternName\" at index ${info.index}");
		};	
	default:
}) {
													var ` = init.expr;
													if (enumIndex ` == 1) {
														var ` = `[0];
														{
															var localVar = `;
															{
																var tempName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(localVar.name, null);
																if (StringTools.startsWith(tempName, "_")) {
																	tempName = tempName.substr(1, null);
																};
																if (tempVarMapping.exists(tempName)) {
																	var patternName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																	var info = cast tempVarMapping.get(tempName);
																	extractedParams[info.index] = patternName;
																	haxe.Log.trace("[DEBUG ENUM] Mapped temp var \"" + tempName + "\" to pattern var \"" + patternName + "\" at index " + info.index, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 3828, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "analyzeEnumParameterExtraction"});
																};
															};
														};
													} else {};
												};
											} else {};
										};
									} else {};
								};
							};
						};
						var usedVariables = {
							{};
							new haxe.ds.StringMap();
						};
						var scanForUsedVariables = [null];
						scanForUsedVariables[0] = function(expr:haxe.macro.TypedExpr) {
							@:ast(switch (expr.expr) {
	case TLocal(v):
		var name = toElixirVarName(v.name);
		usedVariables.set(name, true);
		if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
			for (i  in  0 ... extractedParams.length) {
				if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
					extractedParams[i] = name;
					trace("[DEBUG ENUM] Replaced temp var \"${extractedParams[i]}\" with used variable \"$name\" at index $i");
					break;
				};
			};
		};	
	case TBlock(subExprs):
		for (e  in  subExprs) scanForUsedVariables(e);	
	case TBinop(_, e1, e2):
		scanForUsedVariables(e1);
		scanForUsedVariables(e2);	
	case TCall(e, args):
		scanForUsedVariables(e);
		for (arg  in  args) scanForUsedVariables(arg);	
	case TField(e, _):
		scanForUsedVariables(e);	
	case TIf(cond, ifExpr, elseExpr):
		scanForUsedVariables(cond);
		scanForUsedVariables(ifExpr);
		if (elseExpr != null) scanForUsedVariables(elseExpr);	
	case TThrow(e):
		scanForUsedVariables(e);	
	case TReturn(e):
		if (e != null) scanForUsedVariables(e);	
	case _:
}) {
								var ` = expr.expr;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										{
											var v = `;
											{
												var name = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
												{
													usedVariables.set(name, true);
												};
												if (! StringTools.startsWith(name, "_g") && ! StringTools.startsWith(name, "g") && name != "g") {
													{
														var ` = 0;
														var ` = extractedParams.length;
														while (` < `) {
															var i = ` ++;
															if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && StringTools.startsWith(extractedParams[i], "g"))) {
																extractedParams[i] = name;
																haxe.Log.trace("[DEBUG ENUM] Replaced temp var \"" + extractedParams[i] + "\" with used variable \"" + name + "\" at index " + i, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 3859, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "analyzeEnumParameterExtraction"});
																break;
															};
														};
													};
												};
											};
										};
									};
									case 3: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var e1 = `;
											var e2 = `;
											{
												scanForUsedVariables[0](e1);
												scanForUsedVariables[0](e2);
											};
										};
									};
									case 4: {
										var ` = `[0];
										var ` = `[1];
										{
											var e = `;
											{
												scanForUsedVariables[0](e);
											};
										};
									};
									case 9: {
										var ` = `[0];
										var ` = `[1];
										{
											var e = `;
											var args = `;
											{
												scanForUsedVariables[0](e);
												{
													var ` = 0;
													while (` < args.length) {
														var arg = args[`];
														++ `;
														scanForUsedVariables[0](arg);
													};
												};
											};
										};
									};
									case 14: {
										var ` = `[0];
										{
											var subExprs = `;
											{
												{
													var ` = 0;
													while (` < subExprs.length) {
														var e = subExprs[`];
														++ `;
														scanForUsedVariables[0](e);
													};
												};
											};
										};
									};
									case 16: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cond = `;
											var ifExpr = `;
											var elseExpr = `;
											{
												scanForUsedVariables[0](cond);
												scanForUsedVariables[0](ifExpr);
												if (elseExpr != null) {
													scanForUsedVariables[0](elseExpr);
												};
											};
										};
									};
									case 20: {
										var ` = `[0];
										{
											var e = `;
											{
												if (e != null) {
													scanForUsedVariables[0](e);
												};
											};
										};
									};
									case 23: {
										var ` = `[0];
										{
											var e = `;
											{
												scanForUsedVariables[0](e);
											};
										};
									};
									default: {}
								};
							};
						};
						{
							var ` = 0;
							var ` = exprs.length;
							while (` < `) {
								var i = ` ++;
								scanForUsedVariables[0](exprs[i]);
							};
						};
					};
				};
			} else {};
		};
		haxe.Log.trace("[DEBUG ENUM] Final extracted params: " + Std.string(extractedParams), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 3897, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "analyzeEnumParameterExtraction"});
		return extractedParams;
	}

	static function convertIdiomaticEnumPatternWithExtraction(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType, extractedParams:Array<String>) {
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, extractedParams);
	}

	static function convertIdiomaticEnumPatternWithType(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType) {
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, null);
	}

	static function convertIdiomaticEnumPatternWithTypeImpl(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType, extractedParams:Null<Array<String>>) {
		return @:ast(switch (value.expr) {
	case TConst(TInt(index)):
		var constructors = enumType.constructs;
		var constructorArray = [];
		for (name  in  constructors.keys()) {
			var constructor = constructors.get(name);
			constructorArray[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
			var constructor = constructorArray[index];
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(constructor.name);
			var paramCount = 0;
			switch (constructor.type) {
				case TFun(args, _):
					paramCount = args.length;				
				default:
			};
			if (paramCount > 0) {
				var canonicalNames = switch (constructor.type) {
					case TFun(args, _):
						[for (arg  in  args) arg.name];					
					default:
						[];					
				};
				var paramPatterns = [];
				for (i  in  0 ... paramCount) {
					var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
					if (isUsed && i < canonicalNames.length) {
						paramPatterns.push(PVar(canonicalNames[i]));
					} else {
						paramPatterns.push(PWildcard);
					};
				};
				PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
			} else {
				PTuple([PLiteral(makeAST(EAtom(atomName)))]);
			};
		} else {
			PWildcard;
		};	
	case TField(_, FEnum(_, ef)):
		var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount == 0) {
			PLiteral(makeAST(EAtom(atomName)));
		} else {
			var canonicalNames = switch (ef.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			var paramPatterns = [];
			for (i  in  0 ... paramCount) {
				var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
				if (isUsed && i < canonicalNames.length) {
					paramPatterns.push(PVar(canonicalNames[i]));
				} else {
					paramPatterns.push(PWildcard);
				};
			};
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
		};	
	default:
		convertPattern(value);	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = enumType.constructs;
								var constructorArray = [];
								for (name in constructors.keys()) {
									var constructor = cast constructors.get(name);
									constructorArray[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
									var constructor = constructorArray[index];
									var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(constructor.name);
									var paramCount = 0;
									@:ast(switch (constructor.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													paramCount = args.length;
												};
											};
										} else {};
									};
									if (paramCount > 0) {
										var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
											var ` = constructor.type;
											if (enumIndex ` == 4) {
												var ` = `[0];
												var ` = `[1];
												{
													var args = `;
													{
														{
															var ` = [];
															{
																var ` = 0;
																while (` < args.length) {
																	var arg = args[`];
																	++ `;
																	`.push(arg.name);
																};
															};
															`;
														};
													};
												};
											} else {
												[];
											};
										};
										var paramPatterns = [];
										{
											var ` = 0;
											var ` = paramCount;
											while (` < `) {
												var i = ` ++;
												var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
												if (isUsed && i < canonicalNames.length) {
													paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(canonicalNames[i]));
												} else {
													paramPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
												};
											};
										};
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										})].concat(paramPatterns));
									} else {
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										})]);
									};
								} else {
									reflaxe.elixir.ast.EPattern.PWildcard;
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount == 0) {
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								} else {
									var canonicalNames = @:ast(switch (ef.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = ef.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var paramPatterns = [];
									{
										var ` = 0;
										var ` = paramCount;
										while (` < `) {
											var i = ` ++;
											var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
											if (isUsed && i < canonicalNames.length) {
												paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(canonicalNames[i]));
											} else {
												paramPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									})].concat(paramPatterns));
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
				}
			};
		};
	}

	static function convertIdiomaticEnumPattern(value:haxe.macro.TypedExpr, switchTarget:haxe.macro.TypedExpr) {
		haxe.Log.trace("[DEBUG ENUM] convertIdiomaticEnumPattern called with value: " + Std.string(value.expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4076, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertIdiomaticEnumPattern"});
		var enumType = @:ast(switch (switchTarget.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		return convertPattern(value);	
}) {
			var ` = switchTarget.t;
			if (enumIndex ` == 1) {
				var ` = `[0];
				var ` = `[1];
				{
					var enumRef = `;
					{
						enumRef.get();
					};
				};
			} else {
				return reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
			};
		};
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, null);
	}

	static function isEnumConstructor(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(_, _)):
		true;	
	case TTypeExpr(TEnumDecl(_)):
		true;	
	case TField(_, FStatic(_, _)):
		false;	
	case TConst(TString(s)) if (s.charAt(0) >= "A" && s.charAt(0) <= "Z"):
		true;	
	default:
		switch (expr.t) {
			case TEnum(_, _):
				true;			
			case TFun(_, _):
				false;			
			default:
				false;			
		};	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 2) {
						var ` = `[0];
						{
							var s = `;
							if (s.charAt(0) >= "A" && s.charAt(0) <= "Z") {
								true;
							} else {
								@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
									var ` = expr.t;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											var ` = `[1];
											{
												true;
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												false;
											};
										};
										default: {
											false;
										}
									};
								};
							};
						};
					} else {
						@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
							var ` = expr.t;
							switch (enumIndex `) {
								case 1: {
									var ` = `[0];
									var ` = `[1];
									{
										true;
									};
								};
								case 4: {
									var ` = `[0];
									var ` = `[1];
									{
										false;
									};
								};
								default: {
									false;
								}
							};
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					switch (enumIndex `) {
						case 1: {
							var ` = `[0];
							var ` = `[1];
							{
								false;
							};
						};
						case 5: {
							var ` = `[0];
							var ` = `[1];
							{
								true;
							};
						};
						default: {
							@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
								var ` = expr.t;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										var ` = `[1];
										{
											true;
										};
									};
									case 4: {
										var ` = `[0];
										var ` = `[1];
										{
											false;
										};
									};
									default: {
										false;
									}
								};
							};
						}
					};
				};
				case 5: {
					var ` = `[0];
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							true;
						};
					} else {
						@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
							var ` = expr.t;
							switch (enumIndex `) {
								case 1: {
									var ` = `[0];
									var ` = `[1];
									{
										true;
									};
								};
								case 4: {
									var ` = `[0];
									var ` = `[1];
									{
										false;
									};
								};
								default: {
									false;
								}
							};
						};
					};
				};
				default: {
					@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
						var ` = expr.t;
						switch (enumIndex `) {
							case 1: {
								var ` = `[0];
								var ` = `[1];
								{
									true;
								};
							};
							case 4: {
								var ` = `[0];
								var ` = `[1];
								{
									false;
								};
							};
							default: {
								false;
							}
						};
					};
				}
			};
		};
	}

	static function hasIdiomaticMetadata(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		trace("[AST Builder] Checking @:elixirIdiomatic for ${enumType.name}: $hasIt");
		return hasIt;	
	case TTypeExpr(TEnumDecl(enumRef)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		trace("[AST Builder] Checking @:elixirIdiomatic for enum type expr: $hasIt");
		return hasIt;	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								haxe.Log.trace("[AST Builder] Checking @:elixirIdiomatic for " + enumType.name + ": " + Std.string(hasIt), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4130, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "hasIdiomaticMetadata"});
								return hasIt;
							};
						};
					} else {};
				};
				case 5: {
					var ` = `[0];
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								haxe.Log.trace("[AST Builder] Checking @:elixirIdiomatic for enum type expr: " + Std.string(hasIt), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4137, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "hasIdiomaticMetadata"});
								return hasIt;
							};
						};
					} else {};
				};
				default: {}
			};
		};
		@:ast(switch (expr.t) {
	case TFun(_, ret):
		switch (ret) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				var hasIt = enumType.meta.has(":elixirIdiomatic");
				trace("[AST Builder] Checking @:elixirIdiomatic via return type: $hasIt");
				return hasIt;			
			default:
		};	
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		trace("[AST Builder] Checking @:elixirIdiomatic via direct enum type: $hasIt");
		return hasIt;	
	default:
}) {
			var ` = expr.t;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							var hasIt = enumType.meta.has(":elixirIdiomatic");
							haxe.Log.trace("[AST Builder] Checking @:elixirIdiomatic via direct enum type: " + Std.string(hasIt), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4160, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "hasIdiomaticMetadata"});
							return hasIt;
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var ret = `;
						{
							@:ast(switch (ret) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		trace("[AST Builder] Checking @:elixirIdiomatic via return type: $hasIt");
		return hasIt;	
	default:
}) if (enumIndex ret == 1) {
								var ` = ret[0];
								var ` = ret[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										var hasIt = enumType.meta.has(":elixirIdiomatic");
										haxe.Log.trace("[AST Builder] Checking @:elixirIdiomatic via return type: " + Std.string(hasIt), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4151, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "hasIdiomaticMetadata"});
										return hasIt;
									};
								};
							} else {};
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	static function getEnumTypeName(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		enumType.name;	
	default:
		"";	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 5) {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							enumType.name;
						};
					};
				} else {
					"";
				};
			} else {
				"";
			};
		};
	}

	static function toElixirAtomName(name:String) {
		var result = [];
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var c = name.charAt(i);
				if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
					result.push("_");
					result.push(c.toLowerCase());
				} else {
					result.push(c.toLowerCase());
				};
			};
		};
		return result.join("");
	}

	static function isArrayType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		var cl = c.get();
		cl.name == "Array";	
	case TAbstract(a, _):
		var abs = a.get();
		abs.name == "Array";	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						var cl = c.get();
						cl.name == "Array";
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					{
						var abs = a.get();
						abs.name == "Array";
					};
				};
			};
			default: {
				false;
			}
		};
	}

	static function tryExpandElixirInjection(methodExpr:haxe.macro.TypedExpr, thisExpr:haxe.macro.TypedExpr, args:Array<haxe.macro.TypedExpr>) {
		haxe.Log.trace("[AST Builder] tryExpandElixirInjection examining: " + Type.enumConstructor(methodExpr.expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 4237, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryExpandElixirInjection"});
		@:ast(switch (methodExpr.expr) {
	case TFunction(tfunc):
		if (tfunc.expr != null) {
			return tryExpandElixirInjection(tfunc.expr, thisExpr, args);
		};	
	default:
}) {
			var ` = methodExpr.expr;
			if (enumIndex ` == 12) {
				var ` = `[0];
				{
					var tfunc = `;
					{
						if (tfunc.expr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirInjection(tfunc.expr, thisExpr, args);
						};
					};
				};
			} else {};
		};
		@:ast(switch (methodExpr.expr) {
	case TReturn(retOpt):
		if (retOpt != null) {
			return tryExpandElixirCall(retOpt, thisExpr, args);
		};	
	case TBlock(exprs):
		if (exprs.length > 0) {
			var lastExpr = exprs[exprs.length - 1];
			return tryExpandElixirCall(lastExpr, thisExpr, args);
		};	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, args);
		if (ifResult != null) {
			var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, args) : null;
			if (elseResult != null) {
				var condAst = buildFromTypedExpr(cond);
				return makeAST(EIf(condAst, ifResult, elseResult));
			};
			return ifResult;
		};	
	case TCall(_):
		return tryExpandElixirCall(methodExpr, thisExpr, args);	
	default:
}) {
			var ` = methodExpr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(methodExpr, thisExpr, args);
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							if (exprs.length > 0) {
								var lastExpr = exprs[exprs.length - 1];
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(lastExpr, thisExpr, args);
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, args);
							if (ifResult != null) {
								var elseResult = if (elseExpr != null) {
									reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, args);
								} else {
									null;
								};
								if (elseResult != null) {
									var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, null);
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
									};
								};
								return ifResult;
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retOpt = `;
						{
							if (retOpt != null) {
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retOpt, thisExpr, args);
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function detectFluentAPIPattern(func:haxe.macro.TFunc) {
		var result = {returnsThis : false, fieldMutations : []};
		if (func.expr == null) {
			return result;
		};
		var checkReturnsThis = [null];
		checkReturnsThis[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TReturn(e) if (e != null):
		switch (e.expr) {
			case TConst(TThis):
				return true;			
			case TLocal(v) if (v.name == "this"):
				return true;			
			default:
		};	
	case TConst(TThis):
		return true;	
	case TLocal(v) if (v.name == "this"):
		return true;	
	case TBlock(exprs) if (exprs.length > 0):
		return checkReturnsThis(exprs[exprs.length - 1]);	
	default:
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						if (enumIndex ` == 5) {
							{
								return true;
							};
						} else {};
					};
					case 1: {
						var ` = `[0];
						{
							var v = `;
							if (v.name == "this") {
								return true;
							} else {};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							if (exprs.length > 0) {
								return checkReturnsThis[0](exprs[exprs.length - 1]);
							} else {};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								@:ast(switch (e.expr) {
	case TConst(TThis):
		return true;	
	case TLocal(v) if (v.name == "this"):
		return true;	
	default:
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											if (enumIndex ` == 5) {
												{
													return true;
												};
											} else {};
										};
										case 1: {
											var ` = `[0];
											{
												var v = `;
												if (v.name == "this") {
													return true;
												} else {};
											};
										};
										default: {}
									};
								};
							} else {};
						};
					};
					default: {}
				};
			};
			return false;
		};
		var detectMutations = [null];
		detectMutations[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TCall(e, args):
		switch (e.expr) {
			case TField(target, FInstance(_, _, cf)):
				var methodName = cf.get().name;
				if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
					switch (target.expr) {
						case TField(obj, FInstance(_, _, fieldRef)):
							switch (obj.expr) {
								case TConst(TThis):
									result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });								
								default:
							};						
						default:
					};
				};			
			default:
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			detectMutations(e);
		};	
	case TIf(_, thenExpr, elseExpr):
		detectMutations(thenExpr);
		if (elseExpr != null) detectMutations(elseExpr);	
	case TWhile(_, body, _):
		detectMutations(body);	
	case TFor(_, _, body):
		detectMutations(body);	
	case TSwitch(_, cases, edef):
		for (c  in  cases) {
			detectMutations(c.expr);
		};
		if (edef != null) detectMutations(edef);	
	case TReturn(e) if (e != null):
		detectMutations(e);	
	case TTry(e, catches):
		detectMutations(e);
		for (c  in  catches) {
			detectMutations(c.expr);
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, detectMutations);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								@:ast(switch (e.expr) {
	case TField(target, FInstance(_, _, cf)):
		var methodName = cf.get().name;
		if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
			switch (target.expr) {
				case TField(obj, FInstance(_, _, fieldRef)):
					switch (obj.expr) {
						case TConst(TThis):
							result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });						
						default:
					};				
				default:
			};
		};	
	default:
}) {
									var ` = e.expr;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var target = `;
												{
													var methodName = cf.get().name;
													if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
														@:ast(switch (target.expr) {
	case TField(obj, FInstance(_, _, fieldRef)):
		switch (obj.expr) {
			case TConst(TThis):
				result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });			
			default:
		};	
	default:
}) {
															var ` = target.expr;
															if (enumIndex ` == 4) {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var fieldRef = `;
																		var obj = `;
																		{
																			@:ast(switch (obj.expr) {
	case TConst(TThis):
		result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });	
	default:
}) {
																				var ` = obj.expr;
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					if (enumIndex ` == 5) {
																						{
																							result.fieldMutations.push({field : fieldRef.get().name, expr : expr});
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																} else {};
															} else {};
														};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										detectMutations[0](e);
									};
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var body = `;
							{
								detectMutations[0](body);
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var thenExpr = `;
							var elseExpr = `;
							{
								detectMutations[0](thenExpr);
								if (elseExpr != null) {
									detectMutations[0](elseExpr);
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var body = `;
							{
								detectMutations[0](body);
							};
						};
					};
					case 18: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cases = `;
							var edef = `;
							{
								{
									var ` = 0;
									while (` < cases.length) {
										var c = cases[`];
										++ `;
										detectMutations[0](c.expr);
									};
								};
								if (edef != null) {
									detectMutations[0](edef);
								};
							};
						};
					};
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var catches = `;
							{
								detectMutations[0](e);
								{
									var ` = 0;
									while (` < catches.length) {
										var c = catches[`];
										++ `;
										detectMutations[0](c.expr);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								detectMutations[0](e);
							} else {
								haxe.macro.TypedExprTools.iter(expr, detectMutations[0]);
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, detectMutations[0]);
					}
				};
			};
		};
		result.returnsThis = checkReturnsThis[0](func.expr);
		detectMutations[0](func.expr);
		return result;
	}

	static function tryExpandElixirCall(expr:haxe.macro.TypedExpr, thisExpr:haxe.macro.TypedExpr, methodArgs:Array<haxe.macro.TypedExpr>) {
		@:ast(switch (expr.expr) {
	case TReturn(retExpr) if (retExpr != null):
		return tryExpandElixirCall(retExpr, thisExpr, methodArgs);	
	case TMeta({ name : ":untyped" }, untypedExpr):
		return tryExpandElixirCall(untypedExpr, thisExpr, methodArgs);	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, methodArgs);
		var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, methodArgs) : null;
		if (ifResult != null && elseResult != null) {
			var condAst = buildFromTypedExpr(cond);
			return makeAST(EIf(condAst, ifResult, elseResult));
		} else if (ifResult != null) {
			return ifResult;
		} else if (elseResult != null) {
			return elseResult;
		};	
	case TCall(e, callArgs):
		switch (e.expr) {
			case TIdent("__elixir__"):
				if (callArgs.length > 0) {
					switch (callArgs[0].expr) {
						case TConst(TString(code)):
							var processedCode = code;
							var thisAst = buildFromTypedExpr(thisExpr);
							var thisStr = ElixirASTPrinter.printAST(thisAst);
							processedCode = StringTools.replace(processedCode, "{0}", thisStr);
							for (i  in  1 ... callArgs.length) {
								if (i - 1 < methodArgs.length) {
									var argAst = buildFromTypedExpr(methodArgs[i - 1]);
									var argStr = ElixirASTPrinter.printAST(argAst);
									var placeholder = "{$i}";
									processedCode = StringTools.replace(processedCode, placeholder, argStr);
								};
							};
							return makeAST(ERaw(processedCode));						
						default:
					};
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var callArgs = `;
						{
							@:ast(switch (e.expr) {
	case TIdent("__elixir__"):
		if (callArgs.length > 0) {
			switch (callArgs[0].expr) {
				case TConst(TString(code)):
					var processedCode = code;
					var thisAst = buildFromTypedExpr(thisExpr);
					var thisStr = ElixirASTPrinter.printAST(thisAst);
					processedCode = StringTools.replace(processedCode, "{0}", thisStr);
					for (i  in  1 ... callArgs.length) {
						if (i - 1 < methodArgs.length) {
							var argAst = buildFromTypedExpr(methodArgs[i - 1]);
							var argStr = ElixirASTPrinter.printAST(argAst);
							var placeholder = "{$i}";
							processedCode = StringTools.replace(processedCode, placeholder, argStr);
						};
					};
					return makeAST(ERaw(processedCode));				
				default:
			};
		};	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 28) {
									var ` = `[0];
									if (` == "__elixir__") {
										{
											if (callArgs.length > 0) {
												@:ast(switch (callArgs[0].expr) {
	case TConst(TString(code)):
		var processedCode = code;
		var thisAst = buildFromTypedExpr(thisExpr);
		var thisStr = ElixirASTPrinter.printAST(thisAst);
		processedCode = StringTools.replace(processedCode, "{0}", thisStr);
		for (i  in  1 ... callArgs.length) {
			if (i - 1 < methodArgs.length) {
				var argAst = buildFromTypedExpr(methodArgs[i - 1]);
				var argStr = ElixirASTPrinter.printAST(argAst);
				var placeholder = "{$i}";
				processedCode = StringTools.replace(processedCode, placeholder, argStr);
			};
		};
		return makeAST(ERaw(processedCode));	
	default:
}) {
													var ` = callArgs[0].expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															{
																var code = `;
																{
																	var processedCode = code;
																	var thisAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(thisExpr, null);
																	var thisStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(thisAst);
																	processedCode = StringTools.replace(processedCode, "{0}", thisStr);
																	{
																		var ` = 1;
																		var ` = callArgs.length;
																		while (` < `) {
																			var i = ` ++;
																			if (i - 1 < methodArgs.length) {
																				var argAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(methodArgs[i - 1], null);
																				var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst);
																				var placeholder = "{" + i + "}";
																				processedCode = StringTools.replace(processedCode, placeholder, argStr);
																			};
																		};
																	};
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(processedCode), metadata : {}, pos : pos};
																	};
																};
															};
														} else {};
													} else {};
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, methodArgs);
							var elseResult = if (elseExpr != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, methodArgs);
							} else {
								null;
							};
							if (ifResult != null && elseResult != null) {
								var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, null);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
								};
							} else {
								if (ifResult != null) {
									return ifResult;
								} else {
									if (elseResult != null) {
										return elseResult;
									};
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retExpr = `;
						if (retExpr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retExpr, thisExpr, methodArgs);
						} else {};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.name;
						var ` = `.params;
						var ` = `.pos;
						if (` == ":untyped") {
							{
								var untypedExpr = `;
								{
									return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(untypedExpr, thisExpr, methodArgs);
								};
							};
						} else {};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function isMapType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		var cl = c.get();
		cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || cl.name == "Map" || cl.name.endsWith("Map");	
	case TAbstract(a, params):
		var abs = a.get();
		abs.name == "Map" || abs.name.endsWith("Map");	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						var cl = c.get();
						cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || cl.name == "Map" || StringTools.endsWith(cl.name, "Map");
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					var params = `;
					{
						var abs = a.get();
						abs.name == "Map" || StringTools.endsWith(abs.name, "Map");
					};
				};
			};
			default: {
				false;
			}
		};
	}

	static function extractEnumTag(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(_, ef)):
		ef.name;	
	case TField(_, FStatic(_, cf)):
		var methodName = cf.get().name;
		methodName.charAt(0).toUpperCase() + methodName.substr(1);	
	default:
		"ModuleRef";	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var cf = `;
							{
								var methodName = cf.get().name;
								methodName.charAt(0).toUpperCase() + methodName.substr(1, null);
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								ef.name;
							};
						};
					};
					default: {
						"ModuleRef";
					}
				};
			} else {
				"ModuleRef";
			};
		};
	}

	static function extractPattern(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TLocal(v):
		PVar(toElixirVarName(v.name));	
	case TField(e, fa):
		PVar(extractFieldName(fa));	
	default:
		PWildcard;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var fa = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa));
						};
					};
				};
				default: {
					reflaxe.elixir.ast.EPattern.PWildcard;
				}
			};
		};
	}

	static function convertAssignOp(op:haxe.macro.Binop) {
		return @:ast(switch (op) {
	case OpAdd:
		Add;	
	case OpSub:
		Subtract;	
	case OpMult:
		Multiply;	
	case OpDiv:
		Divide;	
	case OpMod:
		Remainder;	
	case OpAnd:
		BitwiseAnd;	
	case OpOr:
		BitwiseOr;	
	case OpXor:
		BitwiseXor;	
	case OpShl:
		ShiftLeft;	
	case OpShr:
		ShiftRight;	
	default:
		Add;	
}) switch (enumIndex op) {
			case 0: {
				{
					reflaxe.elixir.ast.EBinaryOp.Add;
				};
			};
			case 1: {
				{
					reflaxe.elixir.ast.EBinaryOp.Multiply;
				};
			};
			case 2: {
				{
					reflaxe.elixir.ast.EBinaryOp.Divide;
				};
			};
			case 3: {
				{
					reflaxe.elixir.ast.EBinaryOp.Subtract;
				};
			};
			case 11: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseAnd;
				};
			};
			case 12: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseOr;
				};
			};
			case 13: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseXor;
				};
			};
			case 16: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftLeft;
				};
			};
			case 17: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftRight;
				};
			};
			case 19: {
				{
					reflaxe.elixir.ast.EBinaryOp.Remainder;
				};
			};
			default: {
				reflaxe.elixir.ast.EBinaryOp.Add;
			}
		};
	}

	static function applyParameterRenaming(ast:reflaxe.elixir.ast.ElixirAST, renaming:Map<String, String>) {
		return @:ast(switch (ast.def) {
	case EVar(name):
		if (renaming.exists(name)) {
			makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EBlock(exprs):
		makeASTWithMeta(EBlock(exprs.map(function(e) ->  @:implicitReturn return applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);	
	case ECall(target, func, args):
		makeASTWithMeta(ECall(target != null ? applyParameterRenaming(target, renaming) : null, func, args.map(function(a) ->  @:implicitReturn return applyParameterRenaming(a, renaming))), ast.metadata, ast.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)), ast.metadata, ast.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);	
	case EIf(cond, then, else_):
		makeASTWithMeta(EIf(applyParameterRenaming(cond, renaming), applyParameterRenaming(then, renaming), else_ != null ? applyParameterRenaming(else_, renaming) : null), ast.metadata, ast.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(applyParameterRenaming(expr, renaming), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? applyParameterRenaming(c.guard, renaming) : null, body : applyParameterRenaming(c.body, renaming) })), ast.metadata, ast.pos);	
	default:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.guard, renaming) else null, body : reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.body, renaming)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var then = `;
						var else_ = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(cond, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(then, renaming), if ((else_ != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(else_, renaming) else null);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var func = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(target, renaming) else null, func, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(left, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(right, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							if (renaming.exists(name)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renaming.get(name));
									var meta = ast.metadata;
									var pos = ast.pos;
									{def : def, metadata : meta, pos : pos};
								};
							} else {
								ast;
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = exprs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					ast;
				}
			};
		};
	}

	static function isCamelCaseParameter(name:String) {
		if (name.length < 2) {
			return false;
		};
		var firstChar = name.charAt(0);
		if (firstChar != firstChar.toLowerCase()) {
			return false;
		};
		{
			var ` = 1;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
					return true;
				};
			};
		};
		return false;
	}

	@:value({ preserveUnderscore : false })
	static function toElixirVarName(name:String, preserveUnderscore:Null<Bool> = false) {
		var specialConstants = ["__MODULE__", "__FILE__", "__ENV__", "__DIR__", "__CALLER__"];
		if (specialConstants.indexOf(name, null) >= 0) {
			return name;
		};
		if (name == "_") {
			return "item";
		};
		if (name.charAt(0) == "_" && name.charAt(1) == "g" && ! preserveUnderscore) {
			return name.substr(1, null);
		};
		if (name.charAt(0) == "_" && name.length > 1) {
			var baseName = name.substr(1, null);
			var converted = "";
			{
				var ` = 0;
				var ` = baseName.length;
				while (` < `) {
					var i = ` ++;
					var char = baseName.charAt(i);
					var isUpperLetter = char == char.toUpperCase() && char != char.toLowerCase() && char != "_";
					if (i > 0 && isUpperLetter) {
						converted += "_" + char.toLowerCase();
					} else {
						converted += char.toLowerCase();
					};
				};
			};
			return "_" + converted;
		};
		var result = "";
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				var isUpperLetter = char == char.toUpperCase() && char != char.toLowerCase() && char != "_";
				if (i > 0 && isUpperLetter) {
					result += "_" + char.toLowerCase();
				} else {
					result += char.toLowerCase();
				};
			};
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.isElixirReservedKeyword(result)) {
			result = result + "_param";
		};
		return result;
	}

	public static function isElixirReservedKeyword(name:String) {
		var reservedKeywords = ["true", "false", "nil", "and", "or", "not", "in", "when", "fn", "do", "end", "catch", "rescue", "after", "else", "__MODULE__", "__FILE__", "__DIR__", "__ENV__", "__CALLER__", "alias", "case", "cond", "def", "defp", "defmodule", "defmacro", "defmacrop", "defprotocol", "defimpl", "defstruct", "defexception", "defoverridable", "defdelegate", "for", "if", "import", "quote", "unquote", "unquote_splicing", "receive", "require", "super", "throw", "try", "unless", "use", "with"];
		return reservedKeywords.indexOf(name, null) >= 0;
	}

	public static function extractFieldName(fa:haxe.macro.FieldAccess) {
		return @:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
		cf.get().name;	
	case FDynamic(s):
		s;	
	case FEnum(_, ef):
		ef.name;	
}) switch (@:exhaustive enumIndex fa) {
			case 0: {
				var ` = fa[0];
				var ` = fa[1];
				var ` = fa[2];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 1: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 2: {
				var ` = fa[0];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 3: {
				var ` = fa[0];
				{
					var s = `;
					{
						s;
					};
				};
			};
			case 4: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 5: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var ef = `;
					{
						ef.name;
					};
				};
			};
		};
	}

	static function createVariableMappingsForCase(caseExpr:haxe.macro.TypedExpr, extractedParams:Array<String>, enumType:Null<haxe.macro.EnumType>, values:Array<haxe.macro.TypedExpr>) {
		var mapping = {
			{};
			new haxe.ds.IntMap();
		};
		if (enumType == null || ! enumType.meta.has(":elixirIdiomatic")) {
			return mapping;
		};
		if (values.length > 0) {
			@:ast(switch (values[0].expr) {
	case TConst(TInt(index)):
		var constructors = [];
		for (name  in  enumType.constructs.keys()) {
			var constructor = enumType.constructs.get(name);
			constructors[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructors.length && constructors[index] != null) {
			var constructor = constructors[index];
			var canonicalNames = switch (constructor.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			function scanForTVars(expr:TypedExpr):Void {
				switch (expr.expr) {
					case TBlock(exprs):
						for (e  in  exprs) scanForTVars(e);					
					case TVar(v, init) if (init != null):
						switch (init.expr) {
							case TEnumParameter(_, _, paramIndex):
								if (paramIndex < canonicalNames.length) {
									mapping.set(v.id, canonicalNames[paramIndex]);
								};							
							case TLocal(tempVar):
								if (mapping.exists(tempVar.id)) {
									var canonicalName = mapping.get(tempVar.id);
									mapping.set(v.id, canonicalName);
								};							
							default:
						};					
					default:
						haxe.macro.TypedExprTools.iter(expr, scanForTVars);					
				};
			};
			scanForTVars(caseExpr);
		};	
	default:
}) {
				var ` = values[0].expr;
				if (enumIndex ` == 0) {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = [];
								for (name in {
									var this = enumType.constructs;
									cast this.keys();
								}) {
									var constructor = {
										var this = enumType.constructs;
										cast this.get(name);
									};
									constructors[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructors.length && constructors[index] != null) {
									var constructor = constructors[index];
									var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var scanForTVars = [null];
									scanForTVars[0] = function(expr:haxe.macro.TypedExpr) {
										@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) scanForTVars(e);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, paramIndex):
				if (paramIndex < canonicalNames.length) {
					mapping.set(v.id, canonicalNames[paramIndex]);
				};			
			case TLocal(tempVar):
				if (mapping.exists(tempVar.id)) {
					var canonicalName = mapping.get(tempVar.id);
					mapping.set(v.id, canonicalName);
				};			
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, scanForTVars);	
}) {
											var ` = expr.expr;
											switch (enumIndex `) {
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null) {
															@:ast(switch (init.expr) {
	case TEnumParameter(_, _, paramIndex):
		if (paramIndex < canonicalNames.length) {
			mapping.set(v.id, canonicalNames[paramIndex]);
		};	
	case TLocal(tempVar):
		if (mapping.exists(tempVar.id)) {
			var canonicalName = mapping.get(tempVar.id);
			mapping.set(v.id, canonicalName);
		};	
	default:
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 1: {
																		var ` = `[0];
																		{
																			var tempVar = `;
																			{
																				if ({
																					var key = tempVar.id;
																					mapping.exists(key);
																				}) {
																					var canonicalName = {
																						var key = tempVar.id;
																						mapping.get(key);
																					};
																					{
																						var key = v.id;
																						mapping.set(key, canonicalName);
																					};
																				};
																			};
																		};
																	};
																	case 26: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var paramIndex = `;
																			{
																				if (paramIndex < canonicalNames.length) {
																					{
																						var key = v.id;
																						mapping.set(key, canonicalNames[paramIndex]);
																					};
																				};
																			};
																		};
																	};
																	default: {}
																};
															};
														} else {
															haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
														};
													};
												};
												case 14: {
													var ` = `[0];
													{
														var exprs = `;
														{
															{
																var ` = 0;
																while (` < exprs.length) {
																	var e = exprs[`];
																	++ `;
																	scanForTVars[0](e);
																};
															};
														};
													};
												};
												default: {
													haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
												}
											};
										};
									};
									scanForTVars[0](caseExpr);
								};
							};
						};
					} else {};
				} else {};
			};
		};
		return mapping;
	}

	static function toSnakeCase(s:String) {
		if (s.length == 0) {
			return s;
		};
		var result = new StringBuf();
		{
			var ` = 0;
			var ` = s.length;
			while (` < `) {
				var i = ` ++;
				var char = s.charAt(i);
				if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
					result.add("_");
					result.add(char.toLowerCase());
				} else {
					result.add(char.toLowerCase());
				};
			};
		};
		return result.toString();
	}

	static function collectTemplateContent(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		s;	
	case EBinary(StringConcat, left, right):
		collectTemplateContent(left) + collectTemplateContent(right);	
	case EVar(name):
		"<%= " + name + " %>";	
	case ECall(module, func, args):
		var callStr = if (module != null) {
			switch (module.def) {
				case EVar(m):
					m + "." + func;				
				default:
					func;				
			};
		} else {
			func;
		};
		if (args.length > 0) {
			var argStrs = [];
			for (arg  in  args) {
				argStrs.push(collectTemplateArgument(arg));
			};
			callStr += "(" + argStrs.join(", ") + ")";
		} else {
			callStr += "()";
		};
		"<%= " + callStr + " %>";	
	default:
		"<%= [unhandled expression] %>";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var callStr = if (module != null) {
								@:ast(switch (module.def) {
	case EVar(m):
		m + "." + func;	
	default:
		func;	
}) {
									var ` = module.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var m = `;
											{
												m + "." + func;
											};
										};
									} else {
										func;
									};
								};
							} else {
								func;
							};
							if (args.length > 0) {
								var argStrs = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										argStrs.push(reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateArgument(arg));
									};
								};
								callStr += "(" + argStrs.join(", ") + ")";
							} else {
								callStr += "()";
							};
							"<%= " + callStr + " %>";
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(left) + reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(right);
							};
						};
					} else {
						"<%= [unhandled expression] %>";
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							s;
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							"<%= " + name + " %>";
						};
					};
				};
				default: {
					"<%= [unhandled expression] %>";
				}
			};
		};
	}

	static function collectTemplateArgument(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		"\"" + s + "\"";	
	case EVar(name):
		name;	
	case EAtom(a):
		":" + a;	
	case EInteger(i):
		Std.string(i);	
	case EFloat(f):
		Std.string(f);	
	case EBoolean(b):
		b ? "true" : "false";	
	case ENil:
		"nil";	
	case EField(obj, field):
		switch (obj.def) {
			case EVar(v):
				v + "." + field;			
			default:
				"[complex]." + field;			
		};	
	default:
		"[complex arg]";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						var field = `;
						{
							@:ast(switch (obj.def) {
	case EVar(v):
		v + "." + field;	
	default:
		"[complex]." + field;	
}) {
								var ` = obj.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										{
											v + "." + field;
										};
									};
								} else {
									"[complex]." + field;
								};
							};
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							":" + a;
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							"\"" + s + "\"";
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var i = `;
						{
							Std.string(i);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Std.string(f);
						};
					};
				};
				case 35: {
					var ` = `[0];
					{
						var b = `;
						{
							if (b) {
								"true";
							} else {
								"false";
							};
						};
					};
				};
				case 36: {
					{
						"nil";
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name;
						};
					};
				};
				default: {
					"[complex arg]";
				}
			};
		};
	}

	static function isHXXModule(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		moduleName == "HXX";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var m = `;
					{
						var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
						moduleName == "HXX";
					};
				};
			} else {
				false;
			};
		};
	}

	static function isAssertClass(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(TClassDecl(classRef)):
		var classType = classRef.get();
		var pack = classType.pack.join(".");
		var name = classType.name;
		pack == "haxe.test" && name == "Assert";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				if (enumIndex ` == 0) {
					var ` = `[0];
					{
						var classRef = `;
						{
							var classType = classRef.get();
							var pack = classType.pack.join(".");
							var name = classType.name;
							pack == "haxe.test" && name == "Assert";
						};
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	static function isModuleCall(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function isMapAccess(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAnonymous(_):
		true;	
	case TInst(_.get() => ct, _):
		ct.isInterface || ct.name.endsWith("Map");	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ct = (_hx_tmp = `.get());
						{
							ct.isInterface || StringTools.endsWith(ct.name, "Map");
						};
					};
				};
			};
			case 5: {
				var ` = t[0];
				{
					true;
				};
			};
			default: {
				false;
			}
		};
	}

	static function getExternNativeModuleNameFromType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(cRef, _):
		var c = cRef.get();
		if (c.isExtern && c.meta.has(":native")) {
			var meta = c.meta.extract(":native");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				switch (meta[0].params[0].expr) {
					case EConst(CString(s, _)):
						s;					
					default:
						null;					
				};
			} else null;
		} else null;	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var cRef = `;
				{
					var c = cRef.get();
					if (c.isExtern && c.meta.has(":native")) {
						var meta = c.meta.extract(":native");
						if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
							@:ast(switch (meta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		null;	
}) {
								var ` = meta[0].params[0].expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (enumIndex ` == 2) {
										var ` = `[0];
										var ` = `[1];
										{
											var s = `;
											{
												s;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					} else {
						null;
					};
				};
			};
		} else {
			null;
		};
	}

	static function moduleTypeToString(m:haxe.macro.ModuleType) {
		var name = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().name;	
	case TEnumDecl(e):
		e.get().name;	
	case TTypeDecl(t):
		t.get().name;	
	case TAbstract(a):
		a.get().name;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().name;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().name;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().name;
					};
				};
			};
		};
		var isExtern = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().isExtern;	
	default:
		false;	
}) if (enumIndex m == 0) {
			var ` = m[0];
			{
				var c = `;
				{
					c.get().isExtern;
				};
			};
		} else {
			false;
		};
		var pack = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().pack;	
	case TEnumDecl(e):
		e.get().pack;	
	case TTypeDecl(t):
		t.get().pack;	
	case TAbstract(a):
		a.get().pack;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().pack;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().pack;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().pack;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().pack;
					};
				};
			};
		};
		if (pack.length > 0) {
			if (StringTools.endsWith(name, "_Impl_") || name.indexOf("_Impl_", null) != -1) {
				return name;
			};
			if (! isExtern) {
				return name;
			};
			@:ast(switch (pack[0]) {
	case "ecto":
		return "Ecto." + name;	
	case "phoenix":
		return "Phoenix." + name;	
	case "plug":
		return "Plug." + name;	
	default:
}) {
				var ` = pack[0];
				switch (`) {
					case "ecto": {
						{
							return "Ecto." + name;
						};
					};
					case "phoenix": {
						{
							return "Phoenix." + name;
						};
					};
					case "plug": {
						{
							return "Plug." + name;
						};
					};
					default: {}
				};
			};
		};
		return name;
	}

	static function countVarOccurrencesInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String) {
		var count = [0];
		var _ = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar(v) if (v == name):
		count++;
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == name) {
							count[0] ++;
							return node;
						} else {
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
		return count[0];
	}

	static function replaceVarInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String, replacement:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar(v) if (v == name):
		return makeAST(EParen(replacement));	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == name) {
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EParen(replacement), metadata : {}, pos : pos};
							};
						} else {
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function typeToElixir(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(_.get() => { name : "String" }, _):
		"binary";	
	case TInst(_.get() => { name : "Array" }, _):
		"list";	
	case TAbstract(_.get() => { name : "Int" }, _):
		"integer";	
	case TAbstract(_.get() => { name : "Float" }, _):
		"float";	
	case TAbstract(_.get() => { name : "Bool" }, _):
		"boolean";	
	case TDynamic(_):
		"any";	
	default:
		"term";	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).constructor;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.fields;
						var ` = _hx_tmp.init;
						var ` = _hx_tmp.interfaces;
						var ` = _hx_tmp.isAbstract;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isFinal;
						var ` = _hx_tmp.isInterface;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.kind;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.overrides;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.statics;
						var ` = _hx_tmp.superClass;
						switch (`) {
							case "Array": {
								{
									"list";
								};
							};
							case "String": {
								{
									"binary";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			case 6: {
				var ` = t[0];
				{
					"any";
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).array;
						var ` = _hx_tmp.binops;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.from;
						var ` = _hx_tmp.impl;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.resolve;
						var ` = _hx_tmp.resolveWrite;
						var ` = _hx_tmp.to;
						var ` = _hx_tmp.type;
						var ` = _hx_tmp.unops;
						switch (`) {
							case "Bool": {
								{
									"boolean";
								};
							};
							case "Float": {
								{
									"float";
								};
							};
							case "Int": {
								{
									"integer";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			default: {
				"term";
			}
		};
	}

	static function isPure(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_) | TTypeExpr(_):
		true;	
	case TBinop(_, e1, e2):
		isPure(e1) && isPure(e2);	
	case TUnop(_, _, e):
		isPure(e);	
	case TField(e, _):
		isPure(e);	
	case TParenthesis(e):
		isPure(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e1) && reflaxe.elixir.ast.ElixirASTBuilder.isPure(e2);
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						true;
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function canBeInlined(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_):
		true;	
	case TBinop(_, e1, e2):
		canBeInlined(e1) && canBeInlined(e2);	
	case TUnop(_, _, e):
		canBeInlined(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e1) && reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e2);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isConstant(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 0) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function hasSideEffects(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TCall(_, _) | TNew(_, _, _) | TVar(_, _):
		true;	
	case TBinop(OpAssign | OpAssignOp(_), _, _):
		true;	
	case TUnop(OpIncrement | OpDecrement, _, _):
		true;	
	case TThrow(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								true;
							};
						};
						case 20: {
							var ` = `[0];
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 23: {
					var ` = `[0];
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isVariableUsedInAST(varName:String, ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		name == varName;	
	case EBlock(exprs):
		for (e  in  exprs) {
			if (isVariableUsedInAST(varName, e)) return true;
		};
		false;	
	case EIf(cond, thenBranch, elseBranch):
		isVariableUsedInAST(varName, cond) || isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && isVariableUsedInAST(varName, elseBranch));	
	case ETuple(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EList(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EBinary(_, left, right):
		isVariableUsedInAST(varName, left) || isVariableUsedInAST(varName, right);	
	case ECall(target, funcName, args):
		if (target != null && isVariableUsedInAST(varName, target)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case ERemoteCall(module, func, args):
		if (isVariableUsedInAST(varName, module)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case EFn(clauses):
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case ECase(expr, clauses):
		if (isVariableUsedInAST(varName, expr)) return true;
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case EAssign(name):
		name == varName;	
	case _:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, expr)) {
								return true;
							};
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, cond) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, elseBranch));
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							if (target != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, target)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, module)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, left) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, right);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, e)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 63: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function detectArrayOperationPattern(body:haxe.macro.TypedExpr) {
		@:ast(switch (body.expr) {
	case TBlock(exprs) if (exprs.length >= 3):
		var hasArrayAccess = false;
		var hasIncrement = false;
		var hasPush = false;
		var isFilter = false;
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, init):
					if (init != null) {
						switch (init.expr) {
							case TArray(_, _):
								hasArrayAccess = true;							
							case _:
						};
					};				
				case TUnop(OpIncrement, _, _) | TUnop(OpDecrement, _, _):
					hasIncrement = true;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
					hasPush = true;				
				case TIf(_, thenExpr, _):
					switch (thenExpr.expr) {
						case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case _:
					};				
				case _:
			};
		};
		if (hasArrayAccess && hasIncrement && hasPush) {
			return isFilter ? "filter" : "map";
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length >= 3) {
						var hasArrayAccess = false;
						var hasIncrement = false;
						var hasPush = false;
						var isFilter = false;
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, init):
		if (init != null) {
			switch (init.expr) {
				case TArray(_, _):
					hasArrayAccess = true;				
				case _:
			};
		};	
	case TUnop(OpIncrement, _, _) | TUnop(OpDecrement, _, _):
		hasIncrement = true;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
		hasPush = true;	
	case TIf(_, thenExpr, _):
		switch (thenExpr.expr) {
			case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case _:
		};	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var args = `;
															if (cf.get().name == "push") {
																hasPush = true;
															} else {};
														};
													} else {};
												} else {};
											};
										};
										case 11: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											switch (enumIndex `) {
												case 0, 1: {
													{
														hasIncrement = true;
													};
												};
												default: {}
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												var init = `;
												{
													if (init != null) {
														@:ast(switch (init.expr) {
	case TArray(_, _):
		hasArrayAccess = true;	
	case _:
}) {
															var ` = init.expr;
															if (enumIndex ` == 2) {
																var ` = `[0];
																var ` = `[1];
																{
																	hasArrayAccess = true;
																};
															} else {};
														};
													};
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var thenExpr = `;
												{
													@:ast(switch (thenExpr.expr) {
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case _:
}) {
														var ` = thenExpr.expr;
														switch (enumIndex `) {
															case 9: {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 4) {
																		var ` = `[0];
																		var ` = `[1];
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			{
																				var cf = `;
																				if (cf.get().name == "push") {
																					hasPush = true;
																					isFilter = true;
																				} else {};
																			};
																		} else {};
																	} else {};
																};
															};
															case 14: {
																var ` = `[0];
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 9) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 4) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var cf = `;
																							if (cf.get().name == "push") {
																								hasPush = true;
																								isFilter = true;
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
															default: {}
														};
													};
												};
											};
										};
										default: {}
									};
								};
							};
						};
						if (hasArrayAccess && hasIncrement && hasPush) {
							return if (isFilter) {
								"filter";
							} else {
								"map";
							};
						};
					} else {};
				};
			} else {};
		};
		return null;
	}

	static function generateIdiomaticEnumCall(arrayRef:haxe.macro.TypedExpr, operation:String, body:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayRef, null);
		var lambdaBody = null;
		var itemVar = "v";
		@:ast(switch (body.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, _):
					itemVar = tvar.name;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
					lambdaBody = buildFromTypedExpr(arg);				
				case TIf(cond, thenExpr, _) if (operation == "filter"):
					lambdaBody = buildFromTypedExpr(cond);				
				case _:
			};
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, _):
		itemVar = tvar.name;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
		lambdaBody = buildFromTypedExpr(arg);	
	case TIf(cond, thenExpr, _) if (operation == "filter"):
		lambdaBody = buildFromTypedExpr(cond);	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (`.length == 1) {
															var ` = `[0];
															{
																var arg = `;
																var cf = `;
																if (cf.get().name == "push") {
																	lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, null);
																} else {};
															};
														} else {};
													} else {};
												} else {};
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												{
													itemVar = tvar.name;
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cond = `;
												var thenExpr = `;
												if (operation == "filter") {
													lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, null);
												} else {};
											};
										};
										default: {}
									};
								};
							};
						};
					};
				};
			} else {};
		};
		if (lambdaBody == null) {
			lambdaBody = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(itemVar), metadata : {}, pos : pos};
			};
		};
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(itemVar)], guard : null, body : lambdaBody}]), metadata : {}, pos : pos};
		};
		@:ast(switch (operation) {
	case "map":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
	case "filter":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "filter", [arrayAST, lambda]);	
	default:
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
}) switch (operation) {
			case "filter": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "filter", [arrayAST, lambda]);
				};
			};
			case "map": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "map", [arrayAST, lambda]);
				};
			};
			default: {
				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
				}, "map", [arrayAST, lambda]);
			}
		};
	}

	static function usesVariable(nodes:Array<reflaxe.elixir.ast.ElixirAST>, varName:String) {
		{
			var ` = 0;
			while (` < nodes.length) {
				var node = nodes[`];
				++ `;
				if (reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(node, varName)) {
					return true;
				};
			};
		};
		return false;
	}

	static function usesVariableInNode(node:reflaxe.elixir.ast.ElixirAST, varName:String) {
		return @:ast(switch (node.def) {
	case EVar(name):
		name == varName;	
	case ECall(target, _, args):
		(target != null && usesVariableInNode(target, varName)) || usesVariable(args, varName);	
	case EMatch(_, expr):
		usesVariableInNode(expr, varName);	
	case EBinary(_, left, right):
		usesVariableInNode(left, varName) || usesVariableInNode(right, varName);	
	case _:
		false;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(expr, varName);
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var args = `;
						{
							(target != null && reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(target, varName)) || reflaxe.elixir.ast.ElixirASTBuilder.usesVariable(args, varName);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(left, varName) || reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(right, varName);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function transformVariableReferences(ast:reflaxe.elixir.ast.ElixirAST, varMapping:Map<String, String>) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		if (varMapping.exists(name)) {
			makeAST(EVar(varMapping.get(name)));
		} else {
			ast;
		};	
	case EMatch(pattern, value):
		var transformedValue = transformVariableReferences(value, varMapping);
		var transformedPattern = switch (pattern) {
			case PVar(name) if (varMapping.exists(name)):
				PVar(varMapping.get(name));			
			case _:
				pattern;			
		};
		makeAST(EMatch(transformedPattern, transformedValue));	
	case EBlock(exprs):
		makeAST(EBlock([for (expr  in  exprs) transformVariableReferences(expr, varMapping)]));	
	case EIf(cond, thenExpr, elseExpr):
		makeAST(EIf(transformVariableReferences(cond, varMapping), transformVariableReferences(thenExpr, varMapping), elseExpr != null ? transformVariableReferences(elseExpr, varMapping) : null));	
	case ECall(fn, name, args):
		makeAST(ECall(fn != null ? transformVariableReferences(fn, varMapping) : null, name, [for (arg  in  args) transformVariableReferences(arg, varMapping)]));	
	case ERemoteCall(module, fn, args):
		makeAST(ERemoteCall(transformVariableReferences(module, varMapping), fn, [for (arg  in  args) transformVariableReferences(arg, varMapping)]));	
	case EField(expr, field):
		makeAST(EField(transformVariableReferences(expr, varMapping), field));	
	case ETuple(items):
		makeAST(ETuple([for (item  in  items) transformVariableReferences(item, varMapping)]));	
	case EList(items):
		makeAST(EList([for (item  in  items) transformVariableReferences(item, varMapping)]));	
	case EMap(items):
		makeAST(EMap([for (item  in  items) { key : transformVariableReferences(item.key, varMapping), value : transformVariableReferences(item.value, varMapping) }]));	
	case EBinary(op, left, right):
		makeAST(EBinary(op, transformVariableReferences(left, varMapping), transformVariableReferences(right, varMapping)));	
	case EUnary(op, expr):
		makeAST(EUnary(op, transformVariableReferences(expr, varMapping)));	
	case EParen(expr):
		makeAST(EParen(transformVariableReferences(expr, varMapping)));	
	case ECase(expr, clauses):
		makeAST(ECase(transformVariableReferences(expr, varMapping), [for (clause  in  clauses) { pattern : clause.pattern, guard : clause.guard != null ? transformVariableReferences(clause.guard, varMapping) : null, body : transformVariableReferences(clause.body, varMapping) }]));	
	case _:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping), {
									var ` = [];
									{
										var ` = 0;
										while ((` < clauses.length)) {
											var clause = clauses[`];
											++ `;
											`.push({pattern : clause.pattern, guard : if ((clause.guard != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(clause.guard, varMapping) else null, body : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(clause.body, varMapping)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var value = `;
						{
							var transformedValue = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(value, varMapping);
							var transformedPattern = @:ast(switch (pattern) {
	case PVar(name) if (varMapping.exists(name)):
		PVar(varMapping.get(name));	
	case _:
		pattern;	
}) if (enumIndex pattern == 0) {
								var ` = pattern[0];
								{
									var name = `;
									if (varMapping.exists(name)) {
										reflaxe.elixir.ast.EPattern.PVar(cast varMapping.get(name));
									} else {
										pattern;
									};
								};
							} else {
								pattern;
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(transformedPattern, transformedValue), metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenExpr = `;
						var elseExpr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(cond, varMapping), reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(thenExpr, varMapping), if ((elseExpr != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(elseExpr, varMapping) else null);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push({key : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item.key, varMapping), value : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item.value, varMapping)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var fn = `;
						var name = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((fn != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(fn, varMapping) else null, name, {
									var ` = [];
									{
										var ` = 0;
										while ((` < args.length)) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(arg, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var fn = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(module, varMapping), fn, {
									var ` = [];
									{
										var ` = 0;
										while ((` < args.length)) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(arg, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(left, varMapping), reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(right, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var field = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EField(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping), field);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							if (varMapping.exists(name)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(varMapping.get(name));
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							} else {
								ast;
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										while ((` < exprs.length)) {
											var expr = exprs[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					ast;
				}
			};
		};
	}

	static function checkForEarlyReturns(ast:reflaxe.elixir.ast.ElixirAST) {
		return false;
	}

	static function transformReturnsToHalts(body:reflaxe.elixir.ast.ElixirAST, accumulator:reflaxe.elixir.ast.ElixirAST) {
		if (body == null) {
			return null;
		};
		return @:ast(switch (body.def) {
	case EIf(cond, thenBranch, elseBranch):
		makeAST(EIf(cond, wrapWithHaltIfNeeded(thenBranch, accumulator), wrapWithHaltIfNeeded(elseBranch, accumulator)));	
	case EBlock(exprs):
		var transformedExprs = [];
		for (i  in  0 ... exprs.length) {
			if (i == exprs.length - 1) {
				transformedExprs.push(wrapWithHaltIfNeeded(exprs[i], accumulator));
			} else {
				transformedExprs.push(transformReturnsToHalts(exprs[i], accumulator));
			};
		};
		makeAST(EBlock(transformedExprs));	
	case ECase(expr, clauses):
		makeAST(ECase(expr, [for (clause  in  clauses) { pattern : clause.pattern, guard : clause.guard, body : wrapWithHaltIfNeeded(clause.body, accumulator) }]));	
	case _:
		wrapWithHaltIfNeeded(body, accumulator);	
}) {
			var ` = body.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(expr, {
									var ` = [];
									{
										var ` = 0;
										while ((` < clauses.length)) {
											var clause = clauses[`];
											++ `;
											`.push({pattern : clause.pattern, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(clause.body, accumulator)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(cond, reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(thenBranch, accumulator), reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(elseBranch, accumulator));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							var transformedExprs = [];
							{
								var ` = 0;
								var ` = exprs.length;
								while (` < `) {
									var i = ` ++;
									if (i == exprs.length - 1) {
										transformedExprs.push(reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(exprs[i], accumulator));
									} else {
										transformedExprs.push(reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(exprs[i], accumulator));
									};
								};
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedExprs), metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(body, accumulator);
				}
			};
		};
	}

	static function wrapWithHaltIfNeeded(expr:reflaxe.elixir.ast.ElixirAST, accumulator:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null) {
			return null;
		};
		return @:ast(switch (expr.def) {
	case ETuple([atom, _]):
		switch (atom.def) {
			case EAtom(atomVal) if (atomVal == "cont" || atomVal == "halt"):
				expr;			
			case _:
				makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));			
		};	
	case EBlock([]):
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), accumulator]));	
	case _:
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 16: {
					var ` = `[0];
					if (`.length == 2) {
						var ` = `[0];
						var ` = `[1];
						{
							var atom = `;
							{
								@:ast(switch (atom.def) {
	case EAtom(atomVal) if (atomVal == "cont" || atomVal == "halt"):
		expr;	
	case _:
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));	
}) {
									var ` = atom.def;
									if (enumIndex ` == 31) {
										var ` = `[0];
										{
											var atomVal = `;
											if (atomVal == "cont" || atomVal == "halt") {
												expr;
											} else {
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
													}, expr]), metadata : {}, pos : pos};
												};
											};
										};
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
											}, expr]), metadata : {}, pos : pos};
										};
									};
								};
							};
						};
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
							}, expr]), metadata : {}, pos : pos};
						};
					};
				};
				case 53: {
					var ` = `[0];
					if (`.length == 0) {
						{
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
								}, accumulator]), metadata : {}, pos : pos};
							};
						};
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
							}, expr]), metadata : {}, pos : pos};
						};
					};
				};
				default: {
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
						}, expr]), metadata : {}, pos : pos};
					};
				}
			};
		};
	}

	static function unwrapMetaParens(e:haxe.macro.TypedExpr) {
		if (e == null) {
			return null;
		};
		return @:ast(switch (e.expr) {
	case TMeta(_, expr):
		unwrapMetaParens(expr);	
	case TParenthesis(expr):
		unwrapMetaParens(expr);	
	case _:
		e;	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				default: {
					e;
				}
			};
		};
	}

	static function tryBuildArrayComprehensionFromBlock(statements:Array<haxe.macro.TypedExpr>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		if (statements.length < 2) {
			return null;
		};
		var tempVarName = null;
		var tempVarId = -1;
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[0]);
		@:ast(switch (firstStmt.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;
				tempVarId = v.id;			
			default:
				return null;			
		};	
	case TBinop(OpAssign, { expr : TLocal(v) }, init):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;
				tempVarId = v.id;			
			default:
				return null;			
		};	
	default:
		return null;	
}) {
			var ` = firstStmt.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 4) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var init = `;
									{
										@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;
		tempVarId = v.id;	
	default:
		return null;	
}) {
											var ` = init.expr;
											if (enumIndex ` == 8) {
												var ` = `[0];
												if (`.length == 0) {
													{
														tempVarName = v.name;
														tempVarId = v.id;
													};
												} else {
													return null;
												};
											} else {
												return null;
											};
										};
									};
								};
							} else {
								return null;
							};
						};
					} else {
						return null;
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;
		tempVarId = v.id;	
	default:
		return null;	
}) {
								var ` = init.expr;
								if (enumIndex ` == 8) {
									var ` = `[0];
									if (`.length == 0) {
										{
											tempVarName = v.name;
											tempVarId = v.id;
										};
									} else {
										return null;
									};
								} else {
									return null;
								};
							};
						} else {
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
		var lastStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[statements.length - 1]);
		var returnsTempVar = false;
		@:ast(switch (lastStmt.expr) {
	case TLocal(v) if (v.name == tempVarName):
		returnsTempVar = true;	
	default:
}) {
			var ` = lastStmt.expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var v = `;
					if (v.name == tempVarName) {
						returnsTempVar = true;
					} else {};
				};
			} else {};
		};
		if (! returnsTempVar) {
			return null;
		};
		var hasLoop = false;
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TFor(_, _, _):
		hasLoop = true;
		break;	
	default:
}) {
					var ` = statements[i].expr;
					if (enumIndex ` == 15) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							hasLoop = true;
							break;
						};
					} else {};
				};
			};
		};
		if (hasLoop) {
			{
				var ` = 1;
				var ` = statements.length - 1;
				while (` < `) {
					var i = ` ++;
					@:ast(switch (statements[i].expr) {
	case TFor(v, iterExpr, body):
		var yieldExpr = extractYieldExpression(body, tempVarName, variableUsageMap);
		if (yieldExpr != null) {
			var pattern = PVar(toElixirVarName(v.name));
			var generator = buildFromTypedExpr(iterExpr, variableUsageMap);
			var bodyAst = switch (yieldExpr.expr) {
				case TBlock(stmts):
					var nestedComp = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
					if (nestedComp != null) {
						nestedComp;
					} else {
						buildFromTypedExpr(yieldExpr, variableUsageMap);
					};				
				default:
					buildFromTypedExpr(yieldExpr, variableUsageMap);				
			};
			return makeAST(EFor([{ pattern : pattern, expr : generator }], [], bodyAst, null, false));
		};	
	default:
}) {
						var ` = statements[i].expr;
						if (enumIndex ` == 15) {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var v = `;
								var iterExpr = `;
								var body = `;
								{
									var yieldExpr = reflaxe.elixir.ast.ElixirASTBuilder.extractYieldExpression(body, tempVarName, variableUsageMap);
									if (yieldExpr != null) {
										var pattern = reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
										var generator = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(iterExpr, variableUsageMap);
										var bodyAst = @:ast(switch (yieldExpr.expr) {
	case TBlock(stmts):
		var nestedComp = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
		if (nestedComp != null) {
			nestedComp;
		} else {
			buildFromTypedExpr(yieldExpr, variableUsageMap);
		};	
	default:
		buildFromTypedExpr(yieldExpr, variableUsageMap);	
}) {
											var ` = yieldExpr.expr;
											if (enumIndex ` == 14) {
												var ` = `[0];
												{
													var stmts = `;
													{
														var nestedComp = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
														if (nestedComp != null) {
															nestedComp;
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(yieldExpr, variableUsageMap);
														};
													};
												};
											} else {
												reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(yieldExpr, variableUsageMap);
											};
										};
										return {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : generator}], [], bodyAst, null, false), metadata : {}, pos : pos};
										};
									};
								};
							};
						} else {};
					};
				};
			};
		} else {
			var values = [];
			var isUnrolledPattern = true;
			{
				var ` = 1;
				var ` = statements.length - 1;
				while (` < `) {
					var i = ` ++;
					@:ast(switch (statements[i].expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
				values.push(value);			
			default:
				isUnrolledPattern = false;
				break;			
		};	
	default:
		isUnrolledPattern = false;
		break;	
}) {
						var ` = statements[i].expr;
						if (enumIndex ` == 3) {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 4) {
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var v = `;
											var rhs = `;
											if (v.name == tempVarName) {
												@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
		values.push(value);	
	default:
		isUnrolledPattern = false;
		break;	
}) {
													var ` = rhs.expr;
													if (enumIndex ` == 3) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (enumIndex ` == 0) {
															{
																var ` = `.expr;
																var ` = `.pos;
																var ` = `.t;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 8) {
																			var ` = `[0];
																			if (`.length == 1) {
																				var ` = `[0];
																				{
																					var value = `;
																					var v2 = `;
																					if (v2.name == tempVarName) {
																						values.push(value);
																					} else {
																						isUnrolledPattern = false;
																						break;
																					};
																				};
																			} else {
																				isUnrolledPattern = false;
																				break;
																			};
																		} else {
																			isUnrolledPattern = false;
																			break;
																		};
																	};
																} else {
																	isUnrolledPattern = false;
																	break;
																};
															};
														} else {
															isUnrolledPattern = false;
															break;
														};
													} else {
														isUnrolledPattern = false;
														break;
													};
												};
											} else {
												isUnrolledPattern = false;
												break;
											};
										};
									} else {
										isUnrolledPattern = false;
										break;
									};
								};
							} else {
								isUnrolledPattern = false;
								break;
							};
						} else {
							isUnrolledPattern = false;
							break;
						};
					};
				};
			};
			if (isUnrolledPattern && values.length > 0) {
				var elements = [];
				{
					var ` = 0;
					while (` < values.length) {
						var value = values[`];
						++ `;
						@:ast(switch (value.expr) {
	case TBlock(stmts):
		trace("[DEBUG] Found TBlock in unrolled comprehension with ${stmts.length} statements");
		for (i  in  0 ... stmts.length) {
			trace("[DEBUG]   stmt[$i]: ${stmts[i].expr}");
		};
		var nestedComp = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
		if (nestedComp != null) {
			trace("[DEBUG] Detected as nested comprehension");
			elements.push(nestedComp);
		} else if (looksLikeListBuildingBlock(stmts)) {
			trace("[DEBUG] Detected as list-building block");
			var listElements = extractListElements(stmts);
			if (listElements != null && listElements.length > 0) {
				var innerElements = [for (e  in  listElements) buildFromTypedExpr(e, variableUsageMap)];
				elements.push(makeAST(EList(innerElements)));
			} else {
				elements.push(buildFromTypedExpr(value, variableUsageMap));
			};
		} else {
			trace("[DEBUG] Not recognized, building as-is");
			elements.push(buildFromTypedExpr(value, variableUsageMap));
		};	
	default:
		elements.push(buildFromTypedExpr(value, variableUsageMap));	
}) {
							var ` = value.expr;
							if (enumIndex ` == 14) {
								var ` = `[0];
								{
									var stmts = `;
									{
										haxe.Log.trace("[DEBUG] Found TBlock in unrolled comprehension with " + stmts.length + " statements", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5832, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryBuildArrayComprehensionFromBlock"});
										{
											var ` = 0;
											var ` = stmts.length;
											while (` < `) {
												var i = ` ++;
												haxe.Log.trace("[DEBUG]   stmt[" + i + "]: " + Std.string(stmts[i].expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5834, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryBuildArrayComprehensionFromBlock"});
											};
										};
										var nestedComp = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
										if (nestedComp != null) {
											haxe.Log.trace("[DEBUG] Detected as nested comprehension", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5842, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryBuildArrayComprehensionFromBlock"});
											elements.push(nestedComp);
										} else {
											if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(stmts)) {
												haxe.Log.trace("[DEBUG] Detected as list-building block", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5847, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryBuildArrayComprehensionFromBlock"});
												var listElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(stmts);
												if (listElements != null && listElements.length > 0) {
													var innerElements = {
														var ` = [];
														{
															var ` = 0;
															while (` < listElements.length) {
																var e = listElements[`];
																++ `;
																`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, variableUsageMap));
															};
														};
														`;
													};
													elements.push({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EList(innerElements), metadata : {}, pos : pos};
													});
												} else {
													elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, variableUsageMap));
												};
											} else {
												haxe.Log.trace("[DEBUG] Not recognized, building as-is", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5859, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "tryBuildArrayComprehensionFromBlock"});
												elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, variableUsageMap));
											};
										};
									};
								};
							} else {
								elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, variableUsageMap));
							};
						};
					};
				};
				return {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EList(elements), metadata : {}, pos : pos};
				};
			};
		};
		return null;
	}

	static function looksLikeListBuildingBlock(stmts:Array<haxe.macro.TypedExpr>) {
		haxe.Log.trace("[DEBUG looksLikeListBuildingBlock] Checking block with " + stmts.length + " statements", {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5881, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "looksLikeListBuildingBlock"});
		if (stmts.length > 0) {
			haxe.Log.trace("[DEBUG looksLikeListBuildingBlock] First stmt: " + Std.string(stmts[0].expr), {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 5883, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "looksLikeListBuildingBlock"});
		};
		if (stmts.length < 2) {
			return false;
		};
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[0]);
		var tempVarName = null;
		@:ast(switch (firstStmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TArrayDecl([]) }):
		tempVarName = v.name;	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
		};	
	default:
		return false;	
}) {
			var ` = firstStmt.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 4) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 8) {
										var ` = `[0];
										if (`.length == 0) {
											{
												var v = `;
												{
													tempVarName = v.name;
												};
											};
										} else {
											return false;
										};
									} else {
										return false;
									};
								};
							} else {
								return false;
							};
						};
					} else {
						return false;
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
}) {
								var ` = init.expr;
								if (enumIndex ` == 8) {
									var ` = `[0];
									if (`.length == 0) {
										{
											tempVarName = v.name;
										};
									} else {};
								} else {};
							};
						} else {
							return false;
						};
					};
				};
				default: {
					return false;
				}
			};
		};
		{
			var ` = 1;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				var stmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[i]);
				if (i == stmts.length - 1) {
					@:ast(switch (stmt.expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		return false;	
}) {
						var ` = stmt.expr;
						if (enumIndex ` == 1) {
							var ` = `[0];
							{
								var v = `;
								if (v.name == tempVarName) {} else {
									return false;
								};
							};
						} else {
							return false;
						};
					};
				} else {
					@:ast(switch (stmt.expr) {
	case TBinop(OpAdd, { expr : TLocal(v) }, { expr : TArrayDecl(_) }) if (v.name == tempVarName):
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl(_) }) if (v2.name == tempVarName):
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TBlock(_) }) if (v2.name == tempVarName):
			default:
				return false;			
		};	
	default:
		return false;	
}) {
						var ` = stmt.expr;
						if (enumIndex ` == 3) {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							switch (enumIndex `) {
								case 0: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 8) {
													var ` = `[0];
													{
														var v = `;
														if (v.name == tempVarName) {} else {
															return false;
														};
													};
												} else {
													return false;
												};
											};
										} else {
											return false;
										};
									};
								};
								case 4: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												var rhs = `;
												if (v.name == tempVarName) {
													@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl(_) }) if (v2.name == tempVarName):
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TBlock(_) }) if (v2.name == tempVarName):
	default:
		return false;	
}) {
														var ` = rhs.expr;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 0) {
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var ` = `.expr;
																			var ` = `.pos;
																			var ` = `.t;
																			switch (enumIndex `) {
																				case 8: {
																					var ` = `[0];
																					{
																						var v2 = `;
																						if (v2.name == tempVarName) {} else {
																							return false;
																						};
																					};
																				};
																				case 14: {
																					var ` = `[0];
																					{
																						var v2 = `;
																						if (v2.name == tempVarName) {} else {
																							return false;
																						};
																					};
																				};
																				default: {
																					return false;
																				}
																			};
																		};
																	} else {
																		return false;
																	};
																};
															} else {
																return false;
															};
														} else {
															return false;
														};
													};
												} else {
													return false;
												};
											};
										} else {
											return false;
										};
									};
								};
								default: {
									return false;
								}
							};
						} else {
							return false;
						};
					};
				};
			};
		};
		return true;
	}

	static function extractListElements(stmts:Array<haxe.macro.TypedExpr>) {
		if (! reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(stmts)) {
			return null;
		};
		var elements = [];
		{
			var ` = 1;
			var ` = stmts.length - 1;
			while (` < `) {
				var i = ` ++;
				var stmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[i]);
				@:ast(switch (stmt.expr) {
	case TBinop(OpAdd, _, { expr : TArrayDecl([value]) }):
		switch (value.expr) {
			case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
				var nestedElements = extractListElements(innerStmts);
				if (nestedElements != null && nestedElements.length > 0) {
					var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
					elements.push(listExpr);
				} else {
					elements.push(value);
				};			
			default:
				elements.push(value);			
		};	
	case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
		if (looksLikeListBuildingBlock(blockStmts)) {
			var nestedElements = extractListElements(blockStmts);
			if (nestedElements != null && nestedElements.length > 0) {
				var listExpr = { expr : TArrayDecl(nestedElements), pos : stmt.pos, t : stmt.t };
				elements.push(listExpr);
			} else {
				elements.push({ expr : TBlock(blockStmts), pos : stmt.pos, t : stmt.t });
			};
		} else {
			elements.push({ expr : TBlock(blockStmts), pos : stmt.pos, t : stmt.t });
		};	
	case TBinop(OpAssign, _, rhs):
		switch (rhs.expr) {
			case TBinop(OpAdd, _, { expr : TArrayDecl([value]) }):
				switch (value.expr) {
					case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
						var nestedElements = extractListElements(innerStmts);
						if (nestedElements != null && nestedElements.length > 0) {
							var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
							elements.push(listExpr);
						} else {
							elements.push(value);
						};					
					default:
						elements.push(value);					
				};			
			case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
				if (looksLikeListBuildingBlock(blockStmts)) {
					var nestedElements = extractListElements(blockStmts);
					if (nestedElements != null && nestedElements.length > 0) {
						var listExpr = { expr : TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t };
						elements.push(listExpr);
					} else {
						elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
					};
				} else {
					elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
				};			
			default:
		};	
	default:
}) {
					var ` = stmt.expr;
					if (enumIndex ` == 3) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						switch (enumIndex `) {
							case 0: {
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									switch (enumIndex `) {
										case 8: {
											var ` = `[0];
											if (`.length == 1) {
												var ` = `[0];
												{
													var value = `;
													{
														@:ast(switch (value.expr) {
	case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
		var nestedElements = extractListElements(innerStmts);
		if (nestedElements != null && nestedElements.length > 0) {
			var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
			elements.push(listExpr);
		} else {
			elements.push(value);
		};	
	default:
		elements.push(value);	
}) {
															var ` = value.expr;
															if (enumIndex ` == 14) {
																var ` = `[0];
																{
																	var innerStmts = `;
																	if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(innerStmts)) {
																		var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(innerStmts);
																		if (nestedElements != null && nestedElements.length > 0) {
																			var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : value.pos, t : value.t};
																			elements.push(listExpr);
																		} else {
																			elements.push(value);
																		};
																	} else {
																		elements.push(value);
																	};
																};
															} else {
																elements.push(value);
															};
														};
													};
												};
											} else {};
										};
										case 14: {
											var ` = `[0];
											{
												var blockStmts = `;
												{
													if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(blockStmts)) {
														var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(blockStmts);
														if (nestedElements != null && nestedElements.length > 0) {
															var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : stmt.pos, t : stmt.t};
															elements.push(listExpr);
														} else {
															elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
														};
													} else {
														elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
													};
												};
											};
										};
										default: {}
									};
								};
							};
							case 4: {
								{
									var rhs = `;
									{
										@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, _, { expr : TArrayDecl([value]) }):
		switch (value.expr) {
			case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
				var nestedElements = extractListElements(innerStmts);
				if (nestedElements != null && nestedElements.length > 0) {
					var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
					elements.push(listExpr);
				} else {
					elements.push(value);
				};			
			default:
				elements.push(value);			
		};	
	case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
		if (looksLikeListBuildingBlock(blockStmts)) {
			var nestedElements = extractListElements(blockStmts);
			if (nestedElements != null && nestedElements.length > 0) {
				var listExpr = { expr : TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t };
				elements.push(listExpr);
			} else {
				elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
			};
		} else {
			elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
		};	
	default:
}) {
											var ` = rhs.expr;
											if (enumIndex ` == 3) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 0) {
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														switch (enumIndex `) {
															case 8: {
																var ` = `[0];
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var value = `;
																		{
																			@:ast(switch (value.expr) {
	case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
		var nestedElements = extractListElements(innerStmts);
		if (nestedElements != null && nestedElements.length > 0) {
			var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
			elements.push(listExpr);
		} else {
			elements.push(value);
		};	
	default:
		elements.push(value);	
}) {
																				var ` = value.expr;
																				if (enumIndex ` == 14) {
																					var ` = `[0];
																					{
																						var innerStmts = `;
																						if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(innerStmts)) {
																							var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(innerStmts);
																							if (nestedElements != null && nestedElements.length > 0) {
																								var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : value.pos, t : value.t};
																								elements.push(listExpr);
																							} else {
																								elements.push(value);
																							};
																						} else {
																							elements.push(value);
																						};
																					};
																				} else {
																					elements.push(value);
																				};
																			};
																		};
																	};
																} else {};
															};
															case 14: {
																var ` = `[0];
																{
																	var blockStmts = `;
																	{
																		if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(blockStmts)) {
																			var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(blockStmts);
																			if (nestedElements != null && nestedElements.length > 0) {
																				var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t};
																				elements.push(listExpr);
																			} else {
																				elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : rhs.pos, t : rhs.t});
																			};
																		} else {
																			elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : rhs.pos, t : rhs.t});
																		};
																	};
																};
															};
															default: {}
														};
													};
												} else {};
											} else {};
										};
									};
								};
							};
							default: {}
						};
					} else {};
				};
			};
		};
		return elements;
	}

	static function extractYieldExpression(body:haxe.macro.TypedExpr, tempVarName:String, variableUsageMap:Null<Map<Int, Bool>> = null) {
		@:ast(switch (body.expr) {
	case TBlock(stmts):
		for (stmt  in  stmts) {
			switch (stmt.expr) {
				case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
					return arg;				
				case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
					switch (rhs.expr) {
						case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
							return expr;						
						default:
					};				
				default:
			};
		};	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		return arg;	
	default:
}) {
			var ` = body.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.expr;
						var ` = `.pos;
						var ` = `.t;
						if (enumIndex ` == 4) {
							var ` = `[0];
							var ` = `[1];
							{
								var ` = `.expr;
								var ` = `.pos;
								var ` = `.t;
								if (enumIndex ` == 1) {
									var ` = `[0];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (`.length == 1) {
											var ` = `[0];
											{
												var arg = `;
												var v = `;
												var cf = `;
												if (v.name == tempVarName && cf.get().name == "push") {
													return arg;
												} else {};
											};
										} else {};
									} else {};
								} else {};
							};
						} else {};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var stmts = `;
						{
							{
								var ` = 0;
								while (` < stmts.length) {
									var stmt = stmts[`];
									++ `;
									@:ast(switch (stmt.expr) {
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		return arg;	
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
				return expr;			
			default:
		};	
	default:
}) {
										var ` = stmt.expr;
										switch (enumIndex `) {
											case 3: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 4) {
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var v = `;
																var rhs = `;
																if (v.name == tempVarName) {
																	@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
		return expr;	
	default:
}) {
																		var ` = rhs.expr;
																		if (enumIndex ` == 3) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			if (enumIndex ` == 0) {
																				{
																					var ` = `.expr;
																					var ` = `.pos;
																					var ` = `.t;
																					if (enumIndex ` == 8) {
																						var ` = `[0];
																						if (`.length == 1) {
																							var ` = `[0];
																							{
																								var expr = `;
																								{
																									return expr;
																								};
																							};
																						} else {};
																					} else {};
																				};
																			} else {};
																		} else {};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											};
											case 9: {
												var ` = `[0];
												var ` = `[1];
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 4) {
														var ` = `[0];
														var ` = `[1];
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 1) {
																var ` = `[0];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	if (`.length == 1) {
																		var ` = `[0];
																		{
																			var arg = `;
																			var v = `;
																			var cf = `;
																			if (v.name == tempVarName && cf.get().name == "push") {
																				return arg;
																			} else {};
																		};
																	} else {};
																} else {};
															} else {};
														};
													} else {};
												};
											};
											default: {}
										};
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}
}