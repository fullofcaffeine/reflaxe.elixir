class reflaxe.elixir.ast.SupervisorOptionsTransformPass {

	public static function transform(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorCalls(ast);
	}

	static function transformSupervisorCalls(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall(module, "start_link", args) if (args.length == 2):
		var isSupervisor = switch (module.def) {
			case EVar("Supervisor"):
				true;			
			case _:
				false;			
		};
		if (isSupervisor) {
			var children = args[0];
			var opts = transformSupervisorOptions(args[1]);
			return makeASTWithMeta(ERemoteCall(module, "start_link", [children, opts]), node.metadata, node.pos);
		};	
	case EMatch(pattern, expr):
		var varName = switch (pattern) {
			case PVar(name):
				name;			
			case _:
				null;			
		};
		if (varName != null && (varName == "opts" || varName.indexOf("option") != -1 || varName.indexOf("config") != -1)) {
			var transformedExpr = transformSupervisorOptions(expr);
			if (transformedExpr != expr) {
				return makeASTWithMeta(EMatch(pattern, transformedExpr), node.metadata, node.pos);
			};
		};	
	case _:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								var varName = @:ast(switch (pattern) {
	case PVar(name):
		name;	
	case _:
		null;	
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var name = `;
										{
											name;
										};
									};
								} else {
									null;
								};
								if (varName != null && (varName == "opts" || varName.indexOf("option", null) != -1 || varName.indexOf("config", null) != -1)) {
									var transformedExpr = reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorOptions(expr);
									if (transformedExpr != expr) {
										return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformedExpr), node.metadata, node.pos);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == "start_link") {
							{
								var module = `;
								var args = `;
								if (args.length == 2) {
									var isSupervisor = @:ast(switch (module.def) {
	case EVar("Supervisor"):
		true;	
	case _:
		false;	
}) {
										var ` = module.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											if (` == "Supervisor") {
												{
													true;
												};
											} else {
												false;
											};
										} else {
											false;
										};
									};
									if (isSupervisor) {
										var children = args[0];
										var opts = reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorOptions(args[1]);
										return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, "start_link", [children, opts]), node.metadata, node.pos);
									};
								} else {};
							};
						} else {};
					};
					default: {}
				};
			};
			return node;
		});
	}

	static function transformSupervisorOptions(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EMap(pairs):
		var hasStrategy = false;
		var hasMaxRestarts = false;
		var hasMaxSeconds = false;
		var hasName = false;
		for (pair  in  pairs) {
			var keyName:Null<String> = switch (pair.key.def) {
				case EAtom(atom):
					atom;				
				case _:
					null;				
			};
			if (keyName != null) {
				switch (keyName.toLowerCase()) {
					case "strategy":
						hasStrategy = true;					
					case "max_restarts" | "maxrestarts":
						hasMaxRestarts = true;					
					case "max_seconds" | "maxseconds":
						hasMaxSeconds = true;					
					case "name":
						hasName = true;					
				};
			};
		};
		if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
			var keywordPairs:Array<EKeywordPair> = [];
			for (pair  in  pairs) {
				var key = switch (pair.key.def) {
					case EAtom(name):
						name;					
					case _:
						continue;					
				};
				keywordPairs.push({ key : key, value : pair.value });
			};
			return makeASTWithMeta(EKeywordList(keywordPairs), expr.metadata, expr.pos);
		};
		expr;	
	case _:
		expr;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 17) {
				var ` = `[0];
				{
					var pairs = `;
					{
						var hasStrategy = false;
						var hasMaxRestarts = false;
						var hasMaxSeconds = false;
						var hasName = false;
						{
							var ` = 0;
							while (` < pairs.length) {
								var pair = pairs[`];
								++ `;
								var keyName = @:ast(switch (pair.key.def) {
	case EAtom(atom):
		atom;	
	case _:
		null;	
}) {
									var ` = pair.key.def;
									if (enumIndex ` == 31) {
										var ` = `[0];
										{
											var atom = `;
											{
												atom;
											};
										};
									} else {
										null;
									};
								};
								if (keyName != null) {
									@:ast(switch (keyName.toLowerCase()) {
	case "strategy":
		hasStrategy = true;	
	case "max_restarts" | "maxrestarts":
		hasMaxRestarts = true;	
	case "max_seconds" | "maxseconds":
		hasMaxSeconds = true;	
	case "name":
		hasName = true;	
}) {
										var ` = keyName.toLowerCase();
										switch (`) {
											case "max_restarts", "maxrestarts": {
												{
													hasMaxRestarts = true;
												};
											};
											case "max_seconds", "maxseconds": {
												{
													hasMaxSeconds = true;
												};
											};
											case "name": {
												{
													hasName = true;
												};
											};
											case "strategy": {
												{
													hasStrategy = true;
												};
											};
										};
									};
								};
							};
						};
						if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
							var keywordPairs = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									var key = @:ast(switch (pair.key.def) {
	case EAtom(name):
		name;	
	case _:
		continue;	
}) {
										var ` = pair.key.def;
										if (enumIndex ` == 31) {
											var ` = `[0];
											{
												var name = `;
												{
													name;
												};
											};
										} else {
											continue;
										};
									};
									keywordPairs.push({key : cast key, value : pair.value});
								};
							};
							return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.EKeywordList(keywordPairs), expr.metadata, expr.pos);
						};
						expr;
					};
				};
			} else {
				expr;
			};
		};
	}

	static function makeASTWithMeta(def:reflaxe.elixir.ast.ElixirASTDef, metadata:Null<reflaxe.elixir.ast.ElixirMetadata> = null, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : if (metadata != null) {
			metadata;
		} else {}, pos : pos};
	}
}