class reflaxe.ReflectCompiler {

	@:noCompletion
	public static var Start_called:Bool = false;

	@:value([])
	public static var Compilers:Array<reflaxe.BaseCompiler> = [];

	public static function Start() {
		if (! reflaxe.ReflectCompiler.Start_called) {
			if (! haxe.macro.Context.defined("display")) {
				haxe.macro.Context.onAfterTyping(reflaxe.ReflectCompiler.onAfterTyping);
				haxe.macro.Context.onAfterGenerate(reflaxe.ReflectCompiler.onAfterGenerate);
				reflaxe.ReflectCompiler.checkServerCache();
			};
			reflaxe.ReflectCompiler.Start_called = true;
		} else {
			throw "reflaxe.ReflectCompiler.Start() called multiple times.";
		};
	}

	@:value({ options : null })
	public static function AddCompiler(compiler:reflaxe.BaseCompiler, options:Null<reflaxe.BaseCompilerOptions> = null) {
		if (! reflaxe.ReflectCompiler.Compilers.contains(compiler)) {
			reflaxe.ReflectCompiler.Compilers.push(compiler);
		};
		if (options != null) {
			compiler.setOptions(options);
		};
	}

	@:value({ compileFunc : null, targets : null, paramTypes : null, disallowMultiple : false })
	public static function MetaTemplate(name:String, doc:String, disallowMultiple:Bool = false, paramTypes:Null<Array<reflaxe.MetaArgumentType>> = null, targets:Null<Array<haxe.display.MetadataTarget>> = null, compileFunc:Null<(haxe.macro.MetadataEntry, Array<String>) -> Null<String>> = null) {
		var params = if (paramTypes != null && paramTypes.length > 0) {
			{
				var ` = [];
				{
					var ` = 0;
					var ` = paramTypes;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(p:reflaxe.MetaArgumentType) {
							return p;
						}(v));
					};
				};
				`;
			};
		} else {
			[];
		};
		var metaDesc = {metadata : name, doc : doc, params : params, platforms : [haxe.macro._Compiler.Compiler_Fields_.Cross], targets : targets};
		haxe.macro.Compiler.registerCustomMetadata(metaDesc, null);
		return {meta : metaDesc, disallowMultiple : disallowMultiple, paramTypes : paramTypes, compileFunc : compileFunc};
	}

	@:value(false)
	public static var isCachedRebuild:Bool = false;

	@:value(null)
	static var rebuiltClasses:Null<Array<haxe.macro.ClassType>> = null;

	@:value(false) @:persistent
	static var isCachedRun:Bool = false;

	public static function checkServerCache() {
		if (! haxe.macro.Context.defined("display")) {
			if (! reflaxe.ReflectCompiler.isCachedRun) {
				reflaxe.ReflectCompiler.isCachedRun = true;
			} else {
				reflaxe.ReflectCompiler.rebuiltClasses = [];
				haxe.macro.Compiler.addGlobalMetadata("", "@:build(reflaxe.ReflectCompiler.addToBuildCache())", null);
			};
		};
	}

	static function addToBuildCache() {
		var cls = haxe.macro.Context.getLocalClass();
		if (cls != null && reflaxe.ReflectCompiler.rebuiltClasses != null) {
			reflaxe.ReflectCompiler.rebuiltClasses.push(cls.get());
		};
		return null;
	}

	@:value(null)
	static var initCallbacks:Null<Array<Dynamic>> = null;

	public static function onCompileBegin<T:reflaxe.BaseCompiler>(callback:onCompileBegin.T -> Void) {
		if (reflaxe.ReflectCompiler.initCallbacks == null) {
			reflaxe.ReflectCompiler.initCallbacks = [];
		};
		reflaxe.ReflectCompiler.initCallbacks.push(callback);
	}

	static function callInitCallbacks<T:reflaxe.BaseCompiler>(compiler:callInitCallbacks.T) {
		if (reflaxe.ReflectCompiler.initCallbacks != null) {
			{
				var ` = 0;
				var ` = reflaxe.ReflectCompiler.initCallbacks;
				while (` < `.length) {
					var c = `[`];
					++ `;
					Reflect.callMethod({}, c, [compiler]);
				};
			};
		};
	}

	static var haxeProvidedModuleTypes:Null<Array<haxe.macro.ModuleType>>;

	static function onAfterTyping(moduleTypes:Array<haxe.macro.ModuleType>) {
		reflaxe.ReflectCompiler.haxeProvidedModuleTypes = moduleTypes;
	}

	static function onAfterGenerate() {
		reflaxe.ReflectCompiler.checkCompilers();
	}

	static function checkCompilers() {
		if (reflaxe.ReflectCompiler.Compilers.length <= 0) {
			return;
		};
		var validCompilers = reflaxe.ReflectCompiler.findEnabledCompilers();
		if (validCompilers.length == 1) {
			if (! haxe.macro.Context.defined("display")) {
				reflaxe.ReflectCompiler.startCompiler(validCompilers[0]);
			};
		} else {
			if (validCompilers.length > 1) {
				reflaxe.ReflectCompiler.tooManyCompilersError(validCompilers);
			};
		};
	}

	static function findEnabledCompilers() {
		var validCompilers = [];
		{
			var ` = 0;
			var ` = reflaxe.ReflectCompiler.Compilers;
			while (` < `.length) {
				var compiler = `[`];
				++ `;
				var outputDirDef = compiler.options.outputDirDefineName;
				var outputDir = haxe.macro.Context.definedValue(outputDirDef);
				if (haxe.macro.Context.defined(outputDirDef) && outputDir.length > 0) {
					compiler.setOutputDir(outputDir);
					validCompilers.push(compiler);
				} else {
					var compilerName = Type.getClassName(Type.getClass(compiler));
					var pos = haxe.macro.Context.currentPos();
					var msg = "The " + compilerName + " compiler is enabled; however, the output directory (-D " + outputDirDef + ") is not defined.";
					haxe.macro.Context.error(msg, pos, null);
				};
			};
		};
		return validCompilers;
	}

	static function tooManyCompilersError(compilers:Array<reflaxe.BaseCompiler>) {
		var compilerList = {
			var ` = [];
			{
				var ` = 0;
				var ` = compilers;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(c:reflaxe.BaseCompiler) {
						return Type.getClassName(Type.getClass(c));
					}(v));
				};
			};
			`;
		}.join(" | ");
		var pos = haxe.macro.Context.currentPos();
		var msg = "Multiple compilers have been enabled, only one may be active per build: " + compilerList;
		haxe.macro.Context.error(msg, pos, null);
	}

	static function startCompiler(compiler:reflaxe.BaseCompiler) {
		reflaxe.ReflectCompiler.useCompiler(compiler);
	}

	static function useCompiler(compiler:reflaxe.BaseCompiler) {
		var moduleTypes = compiler.filterTypes(if (reflaxe.ReflectCompiler.haxeProvidedModuleTypes != null) {
			reflaxe.ReflectCompiler.haxeProvidedModuleTypes.copy();
		} else {
			[];
		});
		if (compiler.options.trackClassHierarchy) {
			reflaxe.input.ClassHierarchyTracker.processAllClasses(moduleTypes);
		};
		var moduleTypes = reflaxe.ReflectCompiler.applyModuleFilters(moduleTypes);
		reflaxe.ReflectCompiler.callInitCallbacks(compiler);
		compiler.onCompileStart();
		reflaxe.ReflectCompiler.addClassesToCompiler(compiler, moduleTypes);
		compiler.onCompileEnd();
		{
			var ` = 0;
			var ` = compiler.compileEndCallbacks;
			while (` < `.length) {
				var callback = `[`];
				++ `;
				callback();
			};
		};
		if (reflaxe.ReflectCompiler.isManualDCE(compiler)) {
			reflaxe.ReflectCompiler.dynamicallyAddModulesToCompiler(compiler);
		};
		reflaxe.ReflectCompiler.generateFiles(compiler);
		compiler.onOutputComplete();
	}

	static function applyModuleFilters(moduleTypes:Array<haxe.macro.ModuleType>) {
		var moduleTypes = reflaxe.ReflectCompiler.applyDefineFilters(moduleTypes);
		var moduleTypes = reflaxe.ReflectCompiler.applyBuildCacheCheckFilter(moduleTypes);
		return moduleTypes;
	}

	static function applyDefineFilters(moduleTypes:Array<haxe.macro.ModuleType>) {
		return moduleTypes;
	}

	static function applyBuildCacheCheckFilter(moduleTypes:Array<haxe.macro.ModuleType>) {
		if (reflaxe.ReflectCompiler.rebuiltClasses != null) {
			var result = {
				var ` = [];
				{
					var ` = 0;
					var ` = moduleTypes;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(mt:haxe.macro.ModuleType) {
							return {
								@:ast(switch (mt) {
	case TClassDecl(_.get() => c):
		{
			for (cls  in  rebuiltClasses) {
				if (cls.name == c.name && cls.module == c.module && cls.pack.equals(c.pack)) {
					return true;
				};
			};
		};	
	case _:
		return true;	
}) if ((enumIndex mt == 0)) {
									var ` = mt[0];
									{
										var _hx_tmp;
										{
											var c = (_hx_tmp = `.get());
											{
												var ` = 0;
												var ` = reflaxe.ReflectCompiler.rebuiltClasses;
												while ((` < `.length)) {
													var cls = `[`];
													++ `;
													if ((cls.name == c.name && cls.module == c.module && reflaxe.helpers.ArrayHelper.equals(cls.pack, c.pack))) return true;
												};
											};
										};
									};
								} else return true;
								return false;
							};
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			};
			if (result.length != moduleTypes.length) {
				reflaxe.ReflectCompiler.isCachedRebuild = true;
			};
			return result;
		};
		return moduleTypes;
	}

	static function getAllModulesTypesForCompiler(compiler:reflaxe.BaseCompiler, moduleTypes:haxe.ds.ReadOnlyArray<haxe.macro.ModuleType>) {
		return if (compiler.options.ignoreTypes.length > 0) {
			var ignoreTypes = compiler.options.ignoreTypes;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = cast moduleTypes;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(moduleType:haxe.macro.ModuleType) {
							return ! ignoreTypes.contains(reflaxe.helpers.ModuleTypeHelper.getPath(moduleType));
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			};
		} else {
			moduleTypes;
		};
	}

	static function getAllKeepTypes(compiler:reflaxe.BaseCompiler, moduleTypes:haxe.ds.ReadOnlyArray<haxe.macro.ModuleType>) {
		var tracker = new reflaxe.input.ModuleUsageTracker(moduleTypes, compiler);
		return {
			var _this = tracker.nonStdTypes(null);
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(m:haxe.macro.ModuleType) {
							return reflaxe.helpers.ModuleTypeHelper.getCommonData(m).meta.has(":keep");
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			};
		};
	}

	@:value(["--no-output", "--interp", "--run", "-v", "--verbose", "--debug", "-debug", "--prompt", "-prompt", "--no-traces", "--display", "--times", "--no-inline", "--no-opt", "--flash-strict", "--version", "-version", "-h", "--help", "-help", "--help-defines", "--help-user-defines", "--help-metas", "--help-user-metas", "--haxelib-global"])
	static var noValueHaxeCompilerArguments:Array<String> = ["--no-output", "--interp", "--run", "-v", "--verbose", "--debug", "-debug", "--prompt", "-prompt", "--no-traces", "--display", "--times", "--no-inline", "--no-opt", "--flash-strict", "--version", "-version", "-h", "--help", "-help", "--help-defines", "--help-user-defines", "--help-metas", "--help-user-metas", "--haxelib-global"];

	static function getAllIncludedTypes(compiler:reflaxe.BaseCompiler, moduleTypes:haxe.ds.ReadOnlyArray<haxe.macro.ModuleType>) {
		var compilerArguments = haxe.macro.Compiler.getConfiguration().args;
		var i = 0;
		var includedPaths = [];
		while (i < compilerArguments.length) {
			var arg = compilerArguments[i];
			if (StringTools.startsWith(arg, "-")) {
				if (reflaxe.ReflectCompiler.noValueHaxeCompilerArguments.contains(arg)) {
					i ++;
				} else {
					i += 2;
				};
			} else {
				includedPaths.push(arg);
				i ++;
			};
		};
		var tracker = new reflaxe.input.ModuleUsageTracker(moduleTypes, compiler);
		return {
			var _this = tracker.nonStdTypes(null);
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(m:haxe.macro.ModuleType) {
							return {
								{
									var ` = 0;
									while ((` < includedPaths.length)) {
										var path = includedPaths[`];
										++ `;
										if ((reflaxe.helpers.BaseTypeHelper.startsWithDotPath(reflaxe.helpers.ModuleTypeHelper.getCommonData(m), path))) return true;
									};
								};
								return false;
							};
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			};
		};
	}

	static function addClassesToCompiler(compiler:reflaxe.BaseCompiler, moduleTypes:Array<haxe.macro.ModuleType>) {
		if (reflaxe.ReflectCompiler.isManualDCE(compiler)) {
			{
				var ` = 0;
				var ` = cast reflaxe.ReflectCompiler.getAllKeepTypes(compiler, moduleTypes);
				while (` < `.length) {
					var m = `[`];
					++ `;
					compiler.addModuleTypeForCompilation(m);
				};
			};
			{
				var ` = 0;
				var ` = cast reflaxe.ReflectCompiler.getAllIncludedTypes(compiler, moduleTypes);
				while (` < `.length) {
					var m = `[`];
					++ `;
					compiler.addModuleTypeForCompilation(m);
				};
			};
			reflaxe.ReflectCompiler.dynamicallyAddModulesToCompiler(compiler);
		} else {
			reflaxe.ReflectCompiler.addModulesToCompiler(compiler, reflaxe.ReflectCompiler.getAllModulesTypesForCompiler(compiler, moduleTypes));
		};
	}

	static function dynamicallyAddModulesToCompiler(compiler:reflaxe.BaseCompiler) {
		while (compiler.dynamicTypeStack.length > 0) {
			var temp = compiler.dynamicTypeStack;
			compiler.dynamicTypeStack = [];
			reflaxe.ReflectCompiler.addModulesToCompiler(compiler, temp);
		};
	}

	static function addModulesToCompiler(compiler:reflaxe.BaseCompiler, modules:haxe.ds.ReadOnlyArray<haxe.macro.ModuleType>) {
		var classDecls = [];
		var enumDecls = [];
		var defDecls = [];
		var abstractDecls = [];
		{
			var ` = 0;
			var ` = cast modules;
			while (` < `.length) {
				var moduleType = `[`];
				++ `;
				@:ast(switch (moduleType) {
	case TClassDecl(clsTypeRef):
		{
			classDecls.push(clsTypeRef);
		};	
	case TEnumDecl(enumTypeRef):
		{
			enumDecls.push(enumTypeRef);
		};	
	case TTypeDecl(defTypeRef):
		{
			defDecls.push(defTypeRef);
		};	
	case TAbstract(abstractRef):
		{
			abstractDecls.push(abstractRef);
		};	
}) switch (@:exhaustive enumIndex moduleType) {
					case 0: {
						var ` = moduleType[0];
						{
							var clsTypeRef = `;
							{
								{
									classDecls.push(clsTypeRef);
								};
							};
						};
					};
					case 1: {
						var ` = moduleType[0];
						{
							var enumTypeRef = `;
							{
								{
									enumDecls.push(enumTypeRef);
								};
							};
						};
					};
					case 2: {
						var ` = moduleType[0];
						{
							var defTypeRef = `;
							{
								{
									defDecls.push(defTypeRef);
								};
							};
						};
					};
					case 3: {
						var ` = moduleType[0];
						{
							var abstractRef = `;
							{
								{
									abstractDecls.push(abstractRef);
								};
							};
						};
					};
				};
			};
		};
		{
			var ` = 0;
			while (` < classDecls.length) {
				var clsRef = classDecls[`];
				++ `;
				var cls = clsRef.get();
				if (compiler.options.enforceNullTyping) {
					reflaxe.compiler.NullTypeEnforcer.checkClass(cls);
				};
				compiler.setupModule(haxe.macro.ModuleType.TClassDecl(clsRef));
				if (compiler.shouldGenerateClass(cls)) {
					reflaxe.ReflectCompiler.transpileClass(cls, compiler);
				};
			};
		};
		{
			var ` = 0;
			while (` < enumDecls.length) {
				var enumRef = enumDecls[`];
				++ `;
				var enm = enumRef.get();
				compiler.setupModule(haxe.macro.ModuleType.TEnumDecl(enumRef));
				if (compiler.shouldGenerateEnum(enm)) {
					reflaxe.ReflectCompiler.transpileEnum(enm, compiler);
				};
			};
		};
		{
			var ` = 0;
			while (` < defDecls.length) {
				var defRef = defDecls[`];
				++ `;
				var def = defRef.get();
				compiler.setupModule(haxe.macro.ModuleType.TTypeDecl(defRef));
				compiler.compileTypedef(def);
			};
		};
		{
			var ` = 0;
			while (` < abstractDecls.length) {
				var abstractRef = abstractDecls[`];
				++ `;
				var ab = abstractRef.get();
				compiler.setupModule(haxe.macro.ModuleType.TAbstract(abstractRef));
				compiler.compileAbstract(ab);
			};
		};
		compiler.setupModule(null);
	}

	static function generateFiles(compiler:reflaxe.BaseCompiler) {
		compiler.generateFiles();
	}

	static function isDceOn() {
		return (haxe.macro.Context.definedValue("dce")) != "no";
	}

	static function isManualDCE(compiler:reflaxe.BaseCompiler) {
		return reflaxe.ReflectCompiler.isDceOn() && compiler.options.manualDCE;
	}

	static function transpileClass(cls:haxe.macro.ClassType, compiler:reflaxe.BaseCompiler) {
		var varFields = [];
		var funcFields = [];
		var ignoreExterns = compiler.options.ignoreExterns;
		var addField = function(field:haxe.macro.ClassField, isStatic:Bool) {
			if (ignoreExterns && field.isExtern) {
				return;
			};
			@:ast(switch (field.kind) {
	case FVar(readVarAccess, writeVarAccess):
		{
			if (shouldGenerateVar(field, compiler, isStatic, readVarAccess, writeVarAccess)) {
				var data = field.findVarData(cls, isStatic);
				if (data != null) {
					varFields.push(data);
				} else {
					throw "Variable information not found.";
				};
			};
		};	
	case FMethod(methodKind):
		{
			if (shouldGenerateFunc(field, compiler, isStatic, methodKind)) {
				var data = field.findFuncData(cls, isStatic);
				if (data != null) {
					funcFields.push(preprocessFunction(compiler, field, data));
				} else {
					if (!compiler.options.ignoreBodilessFunctions) {
						Context.warning("Function information not found.", field.pos);
					};
				};
			};
		};	
}) {
				var ` = field.kind;
				switch (@:exhaustive enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						{
							var readVarAccess = `;
							var writeVarAccess = `;
							{
								{
									if (reflaxe.ReflectCompiler.shouldGenerateVar(field, compiler, isStatic, readVarAccess, writeVarAccess)) {
										var data = reflaxe.helpers.ClassFieldHelper.findVarData(field, cls, isStatic);
										if (data != null) {
											varFields.push(data);
										} else {
											throw "Variable information not found.";
										};
									};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						{
							var methodKind = `;
							{
								{
									if (reflaxe.ReflectCompiler.shouldGenerateFunc(field, compiler, isStatic, methodKind)) {
										var data = reflaxe.helpers.ClassFieldHelper.findFuncData(field, cls, isStatic);
										if (data != null) {
											funcFields.push(reflaxe.ReflectCompiler.preprocessFunction(compiler, field, data));
										} else {
											if (! compiler.options.ignoreBodilessFunctions) {
												haxe.macro.Context.warning("Function information not found.", field.pos, null);
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
		if (cls.constructor != null) {
			var field = cls.constructor.get();
			addField(field, false);
		};
		{
			var ` = 0;
			var ` = cls.fields.get();
			while (` < `.length) {
				var field = `[`];
				++ `;
				addField(field, false);
			};
		};
		{
			var ` = 0;
			var ` = cls.statics.get();
			while (` < `.length) {
				var field = `[`];
				++ `;
				addField(field, true);
			};
		};
		compiler.compileClass(cls, varFields, funcFields);
	}

	static function preprocessFunction(compiler:reflaxe.BaseCompiler, field:haxe.macro.ClassField, data:reflaxe.data.ClassFuncData) {
		if (data.expr == null) {
			return data;
		};
		if (compiler.options.enforceNullTyping) {
			reflaxe.compiler.NullTypeEnforcer.modifyExpression(data.expr);
		};
		{
			var ` = 0;
			var ` = compiler.expressionPreprocessors;
			while (` < `.length) {
				var preprocessor = `[`];
				++ `;
				reflaxe.preprocessors.ExpressionPreprocessorHelper.process(preprocessor, data, compiler);
			};
		};
		return data;
	}

	static function transpileEnum(enm:haxe.macro.EnumType, compiler:reflaxe.BaseCompiler) {
		var options = [];
		{
			var ` = 0;
			var ` = enm.names;
			while (` < `.length) {
				var name = `[`];
				++ `;
				var field = {
					var this = enm.constructs;
					cast this.get(name);
				};
				if (field == null) {
					continue;
				};
				var args = @:ast(switch (field.type) {
	case TFun(args, ret):
		args;	
	case _:
		[];	
}) {
					var ` = field.type;
					if (enumIndex ` == 4) {
						var ` = `[0];
						var ` = `[1];
						{
							var args = `;
							var ret = `;
							{
								args;
							};
						};
					} else {
						[];
					};
				};
				var option = new reflaxe.data.EnumOptionData(enm, field, name);
				{
					var ` = 0;
					while (` < args.length) {
						var a = args[`];
						++ `;
						var arg = new reflaxe.data.EnumOptionArg(option, a.t, a.opt, a.name);
						option.addArg(arg);
					};
				};
				options.push(option);
			};
		};
		compiler.compileEnum(enm, options);
	}

	static function shouldGenerateVar(field:haxe.macro.ClassField, compiler:reflaxe.BaseCompiler, isStatic:Bool, read:haxe.macro.VarAccess, write:haxe.macro.VarAccess) {
		if (! compiler.shouldGenerateClassField(field)) {
			return false;
		};
		return if (reflaxe.helpers.NullableMetaAccessHelper.maybeHas(field.meta, ":isVar")) {
			true;
		} else {
			@:ast(switch ([read, write]) {
	case [AccNormal | AccNo | AccCtor, _]:
		true;	
	case [_, AccNormal | AccNo | AccCtor]:
		true;	
	case _:
		!compiler.options.ignoreNonPhysicalFields;	
}) switch (enumIndex read) {
				case 0, 1, 7: {
					{
						true;
					};
				};
				default: switch (enumIndex write) {
					case 0, 1, 7: {
						{
							true;
						};
					};
					default: {
						! compiler.options.ignoreNonPhysicalFields;
					}
				}
			};
		};
	}

	static function shouldGenerateFunc(field:haxe.macro.ClassField, compiler:reflaxe.BaseCompiler, isStatic:Bool, kind:haxe.macro.MethodKind) {
		return compiler.shouldGenerateClassField(field);
	}
}