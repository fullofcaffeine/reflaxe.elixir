class reflaxe.helpers.ClassFieldHelper {

	public static function isVarKind(field:haxe.macro.ClassField) {
		return @:ast(switch (field.kind) {
	case FVar(_, _):
		true;	
	case _:
		false;	
}) {
			var ` = field.kind;
			if (enumIndex ` == 0) {
				var ` = `[0];
				var ` = `[1];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	public static function isMethodKind(field:haxe.macro.ClassField) {
		return @:ast(switch (field.kind) {
	case FMethod(_):
		true;	
	case _:
		false;	
}) {
			var ` = field.kind;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	public static function equals(field:haxe.macro.ClassField, other:haxe.macro.ClassField) {
		return Std.string(field) == Std.string(other);
	}

	@:value([])
	static var findVarData_cache:Map<String, reflaxe.data.ClassVarData> = {
		{};
		new haxe.ds.StringMap();
	};

	@:value([])
	static var findFuncData_cache:Map<String, reflaxe.data.ClassFuncData> = {
		{};
		new haxe.ds.StringMap();
	};

	static function generateId(isVar:Bool, field:haxe.macro.ClassField, clsType:haxe.macro.ClassType) {
		return if (isVar) {
			"" + clsType.pack.join(".") + " " + clsType.name + " " + field.name;
		} else {
			var id = "" + clsType.pack.join(".") + " " + clsType.name + " " + field.name;
			if (field.overloads.get().length != 0) {
				id += @:ast(switch (field.type) {
	case TFun(args, ret):
		args.map(function(a) ->  @:implicitReturn return a.name + " " + Std.string(a.t)) + ":" + Std.string(ret);	
	case _:
		"";	
}) {
					var ` = field.type;
					if (enumIndex ` == 4) {
						var ` = `[0];
						var ` = `[1];
						{
							var args = `;
							var ret = `;
							{
								Std.string({
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(a:{ t : haxe.macro.Type, opt : Bool, name : String }) {
												return a.name + " " + Std.string(a.t);
											}(v));
										};
									};
									`;
								}) + ":" + Std.string(ret);
							};
						};
					} else {
						"";
					};
				};
			};
			id;
		};
	}

	@:value({ isStatic : null })
	public static function findVarData(field:haxe.macro.ClassField, clsType:haxe.macro.ClassType, isStatic:Null<Bool> = null) {
		var id = reflaxe.helpers.ClassFieldHelper.generateId(true, field, clsType);
		if ({
			var this = reflaxe.helpers.ClassFieldHelper.findVarData_cache;
			cast this.exists(id);
		}) {
			return {
				var this = reflaxe.helpers.ClassFieldHelper.findVarData_cache;
				cast this.get(id);
			};
		};
		if (isStatic == null) {
			isStatic = {
				var _this = clsType.statics.get();
				{
					var ` = [];
					{
						var ` = 0;
						var ` = _this;
						while (` < `.length) {
							var v = `[`];
							++ `;
							if (function(f:haxe.macro.ClassField) {
								return f.name == field.name;
							}(v)) {
								`.push(v);
							};
						};
					};
					`;
				};
			}.length > 0;
		};
		return @:ast(switch (field.kind) {
	case FVar(read, write):
		{
			var result = new ClassVarData(clsType, field, isStatic, read, write);
			findVarData_cache.set(id, result);
			result;
		};	
	case _:
		{
			throw "Not a variable.";
		};	
}) {
			var ` = field.kind;
			if (enumIndex ` == 0) {
				var ` = `[0];
				var ` = `[1];
				{
					var read = `;
					var write = `;
					{
						{
							var result = new reflaxe.data.ClassVarData(clsType, field, isStatic, read, write);
							{
								var this = reflaxe.helpers.ClassFieldHelper.findVarData_cache;
								cast this.set(id, result);
							};
							result;
						};
					};
				};
			} else {
				{
					throw "Not a variable.";
				};
			};
		};
	}

	@:value({ isStatic : null })
	public static function findFuncData(field:haxe.macro.ClassField, clsType:haxe.macro.ClassType, isStatic:Null<Bool> = null) {
		var id = reflaxe.helpers.ClassFieldHelper.generateId(false, field, clsType);
		if ({
			var this = reflaxe.helpers.ClassFieldHelper.findFuncData_cache;
			cast this.exists(id);
		}) {
			return {
				var this = reflaxe.helpers.ClassFieldHelper.findFuncData_cache;
				cast this.get(id);
			};
		};
		if (isStatic == null) {
			isStatic = false;
			{
				var ` = 0;
				var ` = clsType.statics.get();
				while (` < `.length) {
					var s = `[`];
					++ `;
					if (reflaxe.helpers.ClassFieldHelper.equals(s, field)) {
						isStatic = true;
						break;
					};
				};
			};
		};
		var e = field.expr();
		var tfunc = if (e != null) {
			@:ast(switch (e.expr) {
	case TFunction(tfunc):
		tfunc;	
	case _:
		null;	
}) {
				var ` = e.expr;
				if (enumIndex ` == 12) {
					var ` = `[0];
					{
						var tfunc = `;
						{
							tfunc;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
		return @:ast(switch (field.type) {
	case TFun(args, ret):
		{
			var index = 0;
			var dataArgs:Array<ClassFuncArg> = if (tfunc != null) {
				tfunc.args.map(function(a) ->  @:implicitReturn return new ClassFuncArg(index++, a.v.t, a.value != null, a.v.name, a.v.meta, a.value, a.v));
			} else {
				args.map(function(a) ->  @:implicitReturn return new ClassFuncArg(index++, a.t, a.opt, a.name));
			};
			var kind = switch (field.kind) {
				case FMethod(kind):
					kind;				
				case _:
					throw "Not a method.";				
			};
			var result = new ClassFuncData(id, clsType, field, isStatic, kind, ret, dataArgs, tfunc, tfunc != null ? tfunc.expr : null);
			for (a  in  dataArgs) a.setFuncData(result);
			findFuncData_cache.set(id, result);
			result;
		};	
	case _:
		null;	
}) {
			var ` = field.type;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				{
					var args = `;
					var ret = `;
					{
						{
							var index = [0];
							var dataArgs = if (tfunc != null) {
								{
									var _this = tfunc.args;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = _this;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(function(a:{ value : Null<haxe.macro.TypedExpr>, v : haxe.macro.TVar }) {
													return new reflaxe.data.ClassFuncArg(index[0] ++, a.v.t, a.value != null, a.v.name, a.v.meta, a.value, a.v);
												}(v));
											};
										};
										`;
									};
								};
							} else {
								{
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(a:{ t : haxe.macro.Type, opt : Bool, name : String }) {
												return new reflaxe.data.ClassFuncArg(index[0] ++, a.t, a.opt, a.name, null, null, null);
											}(v));
										};
									};
									`;
								};
							};
							var kind = @:ast(switch (field.kind) {
	case FMethod(kind):
		kind;	
	case _:
		throw "Not a method.";	
}) {
								var ` = field.kind;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var kind = `;
										{
											kind;
										};
									};
								} else {
									throw "Not a method.";
								};
							};
							var result = new reflaxe.data.ClassFuncData(id, clsType, field, isStatic, kind, ret, dataArgs, tfunc, if (tfunc != null) {
								tfunc.expr;
							} else {
								null;
							}, null, null);
							{
								var ` = 0;
								while (` < dataArgs.length) {
									var a = dataArgs[`];
									++ `;
									a.setFuncData(result);
								};
							};
							{
								var this = reflaxe.helpers.ClassFieldHelper.findFuncData_cache;
								cast this.set(id, result);
							};
							result;
						};
					};
				};
			} else {
				null;
			};
		};
	}

	public static function findFuncDataFromType(field:haxe.macro.ClassField, type:haxe.macro.Type) {
		return @:ast(switch (type) {
	case TInst(clsRef, _):
		findFuncData(field, clsRef.get());	
	case _:
		null;	
}) if (enumIndex type == 2) {
			var ` = type[0];
			var ` = type[1];
			{
				var clsRef = `;
				{
					reflaxe.helpers.ClassFieldHelper.findFuncData(field, clsRef.get(), null);
				};
			};
		} else {
			null;
		};
	}

	public static function getAllVariableNames(data:reflaxe.data.ClassFuncData, compiler:reflaxe.BaseCompiler) {
		var fields = data.classType.fields.get();
		var fieldNames = [];
		{
			var ` = 0;
			while (` < fields.length) {
				var f = fields[`];
				++ `;
				@:ast(switch (f.kind) {
	case FVar(_, _):
		fieldNames.push(compiler.compileVarName(f.name, null, f));	
	case _:
		{ };	
}) {
					var ` = f.kind;
					if (enumIndex ` == 0) {
						var ` = `[0];
						var ` = `[1];
						{
							fieldNames.push(compiler.compileVarName(f.name, null, f));
						};
					} else {
						{};
					};
				};
			};
		};
		return fieldNames;
	}

	public static function hasDefaultValue(field:haxe.macro.ClassField) {
		return reflaxe.helpers.NameMetaHelper.hasMeta(field, ":value");
	}

	public static function getHaxeName(field:haxe.macro.ClassField) {
		return if (reflaxe.helpers.NameMetaHelper.hasMeta(field, ":realPath")) {
			var tmp = {
				reflaxe.helpers.NullableMetaAccessHelper.extractStringFromFirstMeta(field.meta, ":realPath", null);
			};
			if (tmp != null) tmp else {
				field.name;
			};
		} else {
			field.name;
		};
	}
}