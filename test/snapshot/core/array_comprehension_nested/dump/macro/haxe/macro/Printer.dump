class haxe.macro.Printer {

	@:value({ tabString : "\t" })
	public function new(tabString:Null<String> = "\t") {
		this.tabs = "";
		this.tabString = tabString;
	}

	var tabs:String;

	var tabString:String;

	public function printUnop(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpIncrement:
		"++";	
	case OpDecrement:
		"--";	
	case OpNot:
		"!";	
	case OpNeg:
		"-";	
	case OpNegBits:
		"~";	
	case OpSpread:
		"...";	
}) switch (@:exhaustive enumIndex op) {
		case 0: {
			{
				"++";
			};
		};
		case 1: {
			{
				"--";
			};
		};
		case 2: {
			{
				"!";
			};
		};
		case 3: {
			{
				"-";
			};
		};
		case 4: {
			{
				"~";
			};
		};
		case 5: {
			{
				"...";
			};
		};
	}

	public function printBinop(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpAdd:
		"+";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpSub:
		"-";	
	case OpAssign:
		"=";	
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpAnd:
		"&";	
	case OpOr:
		"|";	
	case OpXor:
		"^";	
	case OpBoolAnd:
		"&&";	
	case OpBoolOr:
		"||";	
	case OpShl:
		"<<";	
	case OpShr:
		">>";	
	case OpUShr:
		">>>";	
	case OpMod:
		"%";	
	case OpInterval:
		"...";	
	case OpArrow:
		"=>";	
	case OpIn:
		"in";	
	case OpNullCoal:
		"??";	
	case OpAssignOp(op):
		printBinop(op) + "=";	
}) switch (@:exhaustive enumIndex op) {
		case 0: {
			{
				"+";
			};
		};
		case 1: {
			{
				"*";
			};
		};
		case 2: {
			{
				"/";
			};
		};
		case 3: {
			{
				"-";
			};
		};
		case 4: {
			{
				"=";
			};
		};
		case 5: {
			{
				"==";
			};
		};
		case 6: {
			{
				"!=";
			};
		};
		case 7: {
			{
				">";
			};
		};
		case 8: {
			{
				">=";
			};
		};
		case 9: {
			{
				"<";
			};
		};
		case 10: {
			{
				"<=";
			};
		};
		case 11: {
			{
				"&";
			};
		};
		case 12: {
			{
				"|";
			};
		};
		case 13: {
			{
				"^";
			};
		};
		case 14: {
			{
				"&&";
			};
		};
		case 15: {
			{
				"||";
			};
		};
		case 16: {
			{
				"<<";
			};
		};
		case 17: {
			{
				">>";
			};
		};
		case 18: {
			{
				">>>";
			};
		};
		case 19: {
			{
				"%";
			};
		};
		case 20: {
			var ` = op[0];
			{
				var op = `;
				{
					this.printBinop(op) + "=";
				};
			};
		};
		case 21: {
			{
				"...";
			};
		};
		case 22: {
			{
				"=>";
			};
		};
		case 23: {
			{
				"in";
			};
		};
		case 24: {
			{
				"??";
			};
		};
	}

	function escapeString(s:String, delim:String) {
		return delim + StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(s, "\\", "\\\\"), "\n", "\\n"), "\t", "\\t"), "\r", "\\r"), "'", "\\'"), "\"", "\\\""), "\x00", "\\x00") + delim;
	}

	public function printFormatString(s:String) {
		return this.escapeString(s, "'");
	}

	public function printString(s:String) {
		return this.escapeString(s, "\"");
	}

	public function printConstant(c:haxe.macro.Constant) return @:ast(switch (c) {
	case CString(s, SingleQuotes):
		printFormatString(s);	
	case CString(s, _):
		printString(s);	
	case CIdent(s), CInt(s, null), CFloat(s, null):
		s;	
	case CInt(s, suffix), CFloat(s, suffix):
		s + suffix;	
	case CRegexp(s, opt):
		"~/$s/$opt";	
}) switch (@:exhaustive enumIndex c) {
		case 0: {
			var ` = c[0];
			var ` = c[1];
			if (` == null) {
				var s = `;
				{
					s;
				};
			} else {
				var suffix = `;
				var s = `;
				{
					s + suffix;
				};
			};
		};
		case 1: {
			var ` = c[0];
			var ` = c[1];
			if (` == null) {
				var s = `;
				{
					s;
				};
			} else {
				var suffix = `;
				var s = `;
				{
					s + suffix;
				};
			};
		};
		case 2: {
			var ` = c[0];
			var ` = c[1];
			if (` == null) {
				var s = `;
				{
					this.printString(s);
				};
			} else if (enumIndex ` == 1) {
				{
					var s = `;
					{
						this.printFormatString(s);
					};
				};
			} else {
				var s = `;
				{
					this.printString(s);
				};
			};
		};
		case 3: {
			var ` = c[0];
			{
				var s = `;
				{
					s;
				};
			};
		};
		case 4: {
			var ` = c[0];
			var ` = c[1];
			{
				var s = `;
				var opt = `;
				{
					"~/" + s + "/" + opt;
				};
			};
		};
	}

	public function printTypeParam(param:haxe.macro.TypeParam) return @:ast(switch (param) {
	case TPType(ct):
		printComplexType(ct);	
	case TPExpr(e):
		printExpr(e);	
}) switch (@:exhaustive enumIndex param) {
		case 0: {
			var ` = param[0];
			{
				var ct = `;
				{
					this.printComplexType(ct);
				};
			};
		};
		case 1: {
			var ` = param[0];
			{
				var e = `;
				{
					this.printExpr(e);
				};
			};
		};
	}

	public function printTypePath(tp:haxe.macro.TypePath) return (if (tp.pack.length > 0) {
		tp.pack.join(".") + ".";
	} else {
		"";
	}) + tp.name + (if (tp.sub != null) {
		"." + tp.sub;
	} else {
		"";
	}) + (if (tp.params == null) {
		"";
	} else {
		if (tp.params.length > 0) {
			"<" + {
				var _this = tp.params;
				var f = this.printTypeParam;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = _this;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(f(v));
						};
					};
					`;
				};
			}.join(", ") + ">";
		} else {
			"";
		};
	})

	public function printComplexType(ct:haxe.macro.ComplexType) return @:ast(switch (ct) {
	case TPath(tp):
		printTypePath(tp);	
	case TFunction(args, ret):
		var wrapArgumentsInParentheses = switch args {
			case [TParent(t)]:
				false;			
			case [TPath(_) | TOptional(TPath(_))]:
				false;			
			default:
				true;			
		};
		var argStr = args.map(printComplexType).join(", ");
		(wrapArgumentsInParentheses ? "($argStr)" : argStr) + " -> " + (switch ret {
			case TFunction(_):
				"(${printComplexType(ret)})";			
			default:
				((printComplexType(ret) : String));			
		});	
	case TAnonymous(fields):
		"{ " + [for (f  in  fields) printField(f) + "; "].join("") + "}";	
	case TParent(ct):
		"(" + printComplexType(ct) + ")";	
	case TOptional(ct):
		"?" + printComplexType(ct);	
	case TNamed(n, ct):
		n + ":" + printComplexType(ct);	
	case TExtend(tpl, fields):
		var types = [for (t  in  tpl) "> " + printTypePath(t) + ", "].join("");
		var fields = [for (f  in  fields) printField(f) + "; "].join("");
		"{${types}${fields}}";	
	case TIntersection(tl):
		tl.map(printComplexType).join(" & ");	
}) switch (@:exhaustive enumIndex ct) {
		case 0: {
			var ` = ct[0];
			{
				var tp = `;
				{
					this.printTypePath(tp);
				};
			};
		};
		case 1: {
			var ` = ct[0];
			var ` = ct[1];
			{
				var args = `;
				var ret = `;
				{
					var wrapArgumentsInParentheses = @:ast(switch args {
	case [TParent(t)]:
		false;	
	case [TPath(_) | TOptional(TPath(_))]:
		false;	
	default:
		true;	
}) if (args.length == 1) {
						var ` = args[0];
						switch (enumIndex `) {
							case 0: {
								var ` = `[0];
								{
									false;
								};
							};
							case 3: {
								var ` = `[0];
								{
									var t = `;
									{
										false;
									};
								};
							};
							case 5: {
								var ` = `[0];
								if (enumIndex ` == 0) {
									var ` = `[0];
									{
										false;
									};
								} else {
									true;
								};
							};
							default: {
								true;
							}
						};
					} else {
						true;
					};
					var argStr = {
						var f = this.printComplexType;
						{
							var ` = [];
							{
								var ` = 0;
								var ` = args;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(f(v));
								};
							};
							`;
						};
					}.join(", ");
					(if (wrapArgumentsInParentheses) {
						"(" + argStr + ")";
					} else {
						argStr;
					}) + " -> " + (@:ast(switch ret {
	case TFunction(_):
		"(${printComplexType(ret)})";	
	default:
		((printComplexType(ret) : String));	
}) if (enumIndex ret == 1) {
						var ` = ret[0];
						var ` = ret[1];
						{
							"(" + this.printComplexType(ret) + ")";
						};
					} else {
						(cast this.printComplexType(ret));
					});
				};
			};
		};
		case 2: {
			var ` = ct[0];
			{
				var fields = `;
				{
					"{ " + {
						var ` = [];
						{
							var ` = 0;
							while (` < fields.length) {
								var f = fields[`];
								++ `;
								`.push(this.printField(f) + "; ");
							};
						};
						`;
					}.join("") + "}";
				};
			};
		};
		case 3: {
			var ` = ct[0];
			{
				var ct = `;
				{
					"(" + this.printComplexType(ct) + ")";
				};
			};
		};
		case 4: {
			var ` = ct[0];
			var ` = ct[1];
			{
				var tpl = `;
				var fields = `;
				{
					var types = {
						var ` = [];
						{
							var ` = 0;
							while (` < tpl.length) {
								var t = tpl[`];
								++ `;
								`.push("> " + this.printTypePath(t) + ", ");
							};
						};
						`;
					}.join("");
					var fields = {
						var ` = [];
						{
							var ` = 0;
							while (` < fields.length) {
								var f = fields[`];
								++ `;
								`.push(this.printField(f) + "; ");
							};
						};
						`;
					}.join("");
					"{" + types + fields + "}";
				};
			};
		};
		case 5: {
			var ` = ct[0];
			{
				var ct = `;
				{
					"?" + this.printComplexType(ct);
				};
			};
		};
		case 6: {
			var ` = ct[0];
			var ` = ct[1];
			{
				var n = `;
				var ct = `;
				{
					n + ":" + this.printComplexType(ct);
				};
			};
		};
		case 7: {
			var ` = ct[0];
			{
				var tl = `;
				{
					{
						var f = this.printComplexType;
						{
							var ` = [];
							{
								var ` = 0;
								var ` = tl;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(f(v));
								};
							};
							`;
						};
					}.join(" & ");
				};
			};
		};
	}

	public function printMetadata(meta:haxe.macro.MetadataEntry) return "@" + meta.name + (if ((meta.params != null && meta.params.length > 0)) {
		"(" + this.printExprs(meta.params, ", ") + ")";
	} else {
		"";
	})

	public function printAccess(access:haxe.macro.Access) return @:ast(switch (access) {
	case AStatic:
		"static";	
	case APublic:
		"public";	
	case APrivate:
		"private";	
	case AOverride:
		"override";	
	case AInline:
		"inline";	
	case ADynamic:
		"dynamic";	
	case AMacro:
		"macro";	
	case AFinal:
		"final";	
	case AExtern:
		"extern";	
	case AAbstract:
		"abstract";	
	case AOverload:
		"overload";	
}) switch (@:exhaustive enumIndex access) {
		case 0: {
			{
				"public";
			};
		};
		case 1: {
			{
				"private";
			};
		};
		case 2: {
			{
				"static";
			};
		};
		case 3: {
			{
				"override";
			};
		};
		case 4: {
			{
				"dynamic";
			};
		};
		case 5: {
			{
				"inline";
			};
		};
		case 6: {
			{
				"macro";
			};
		};
		case 7: {
			{
				"final";
			};
		};
		case 8: {
			{
				"extern";
			};
		};
		case 9: {
			{
				"abstract";
			};
		};
		case 10: {
			{
				"overload";
			};
		};
	}

	public function printField(field:haxe.macro.Field) {
		{};
		return (if (field.doc != null && field.doc != "") {
			"/**\n" + this.tabs + this.tabString + StringTools.replace(field.doc, "\n", "\n" + this.tabs + this.tabString) + "\n" + this.tabs + "**/\n" + this.tabs;
		} else {
			"";
		}) + (if (field.meta != null && field.meta.length > 0) {
			{
				var _this = field.meta;
				var f = this.printMetadata;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = _this;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(f(v));
						};
					};
					`;
				};
			}.join("\n" + this.tabs) + "\n" + this.tabs;
		} else {
			"";
		}) + (if (field.access != null && field.access.length > 0) {
			{
				var _this = {
					var access = field.access;
					if (Lambda.has(access, haxe.macro.Access.AFinal)) {
						{
							var ` = [];
							{
								var ` = 0;
								var ` = access;
								while (` < `.length) {
									var v = `[`];
									++ `;
									if (function(a:haxe.macro.Access) {
										return ! (if ((enumIndex a == 7)) true else false);
									}(v)) {
										`.push(v);
									};
								};
							};
							`;
						}.concat([haxe.macro.Access.AFinal]);
					} else {
						access;
					};
				};
				var f = this.printAccess;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = _this;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(f(v));
						};
					};
					`;
				};
			}.join(" ") + " ";
		} else {
			"";
		}) + @:ast(switch (field.kind) {
	case FVar(t, eo):
		((field.access != null && field.access.has(AFinal)) ? "" : "var ") + "${field.name}" + opt(t, printComplexType, " : ") + opt(eo, printExpr, " = ");	
	case FProp(get, set, t, eo):
		"var ${field.name}($get, $set)" + opt(t, printComplexType, " : ") + opt(eo, printExpr, " = ");	
	case FFun(func):
		"function ${field.name}" + printFunction(func);	
}) {
			var ` = field.kind;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					{
						var t = `;
						var eo = `;
						{
							(if ((field.access != null && Lambda.has(field.access, haxe.macro.Access.AFinal))) {
								"";
							} else {
								"var ";
							}) + "" + field.name + this.opt(t, this.printComplexType, " : ") + this.opt(eo, this.printExpr, " = ");
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						var func = `;
						{
							"function " + field.name + this.printFunction(func, null);
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var get = `;
						var set = `;
						var t = `;
						var eo = `;
						{
							"var " + field.name + "(" + get + ", " + set + ")" + this.opt(t, this.printComplexType, " : ") + this.opt(eo, this.printExpr, " = ");
						};
					};
				};
			};
		};
	}

	public function printTypeParamDecl(tpd:haxe.macro.TypeParamDecl) return (if (tpd.meta != null && tpd.meta.length > 0) {
		{
			var _this = tpd.meta;
			var f = this.printMetadata;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(" ") + " ";
	} else {
		"";
	}) + tpd.name + (if (tpd.params != null && tpd.params.length > 0) {
		"<" + {
			var _this = tpd.params;
			var f = this.printTypeParamDecl;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(", ") + ">";
	} else {
		"";
	}) + (if (tpd.constraints != null && tpd.constraints.length > 0) {
		":(" + {
			var _this = tpd.constraints;
			var f = this.printComplexType;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(", ") + ")";
	} else {
		"";
	}) + (if (tpd.defaultType != null) {
		"=" + this.printComplexType(tpd.defaultType);
	} else {
		"";
	})

	public function printFunctionArg(arg:haxe.macro.FunctionArg) return (if (arg.opt) {
		"?";
	} else {
		"";
	}) + arg.name + this.opt(arg.type, this.printComplexType, ":") + this.opt(arg.value, this.printExpr, " = ")

	public function printFunction(func:haxe.macro.Function, kind:Null<haxe.macro.FunctionKind> = null) {
		var skipParentheses = @:ast(switch func.args {
	case [{ type : null }]:
		kind == FArrow;	
	case _:
		false;	
}) {
			var ` = func.args;
			if (`.length == 1) {
				var ` = `[0];
				{
					var ` = `.meta;
					var ` = `.name;
					var ` = `.opt;
					var ` = `.type;
					var ` = `.value;
					if (` == null) {
						kind == haxe.macro.FunctionKind.FArrow;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
		return (if (func.params == null) {
			"";
		} else {
			if (func.params.length > 0) {
				"<" + {
					var _this = func.params;
					var f = this.printTypeParamDecl;
					{
						var ` = [];
						{
							var ` = 0;
							var ` = _this;
							while (` < `.length) {
								var v = `[`];
								++ `;
								`.push(f(v));
							};
						};
						`;
					};
				}.join(", ") + ">";
			} else {
				"";
			};
		}) + (if (skipParentheses) {
			"";
		} else {
			"(";
		}) + {
			var _this = func.args;
			var f = this.printFunctionArg;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(", ") + (if (skipParentheses) {
			"";
		} else {
			")";
		}) + (if (kind == haxe.macro.FunctionKind.FArrow) {
			" ->";
		} else {
			"";
		}) + this.opt(func.ret, this.printComplexType, ":") + this.opt(func.expr, this.printExpr, " ");
	}

	public function printVar(v:haxe.macro.Var) {
		var s = v.name + this.opt(v.type, this.printComplexType, ":") + this.opt(v.expr, this.printExpr, " = ");
		return @:ast(switch v.meta {
	case null | []:
		s;	
	case meta:
		meta.map(printMetadata).join(" ") + " " + s;	
}) {
			var ` = v.meta;
			if (` == null) {
				s;
			} else if (`.length == 0) {
				{
					s;
				};
			} else {
				var meta = `;
				{
					{
						var f = this.printMetadata;
						{
							var ` = [];
							{
								var ` = 0;
								var ` = meta;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(f(v));
								};
							};
							`;
						};
					}.join(" ") + " " + s;
				};
			};
		};
	}

	public function printObjectFieldKey(of:haxe.macro.ObjectField) {
		return @:ast(switch (of.quotes) {
	case null | Unquoted:
		of.field;	
	case Quoted:
		"\"${of.field}\"";	
}) {
			var ` = of.quotes;
			if (` == null) {
				of.field;
			} else switch (@:exhaustive enumIndex `) {
				case 0: {
					{
						of.field;
					};
				};
				case 1: {
					{
						"\"" + of.field + "\"";
					};
				};
			};
		};
	}

	public function printObjectField(of:haxe.macro.ObjectField) {
		return "" + this.printObjectFieldKey(of) + " : " + this.printExpr(of.expr);
	}

	public function printExpr(e:haxe.macro.Expr) {
		var `this = this;
		return if (e == null) {
			"#NULL";
		} else {
			@:ast(switch (e.expr) {
	case EConst(c):
		printConstant(c);	
	case EArray(e1, e2):
		"${printExpr(e1)}[${printExpr(e2)}]";	
	case EBinop(op, e1, e2):
		"${printExpr(e1)} ${printBinop(op)} ${printExpr(e2)}";	
	case EField(e1, n, kind):
		kind == Safe ? "${printExpr(e1)}?.$n" : "${printExpr(e1)}.$n";	
	case EParenthesis(e1):
		"(${printExpr(e1)})";	
	case EObjectDecl(fl):
		"{ " + fl.map(function(fld) return printObjectField(fld)).join(", ") + " }";	
	case EArrayDecl(el):
		"[${printExprs(el, \", \")}]";	
	case ECall(e1, el):
		"${printExpr(e1)}(${printExprs(el, \", \")})";	
	case ENew(tp, el):
		"new ${printTypePath(tp)}(${printExprs(el, \", \")})";	
	case EUnop(op, true, e1):
		printExpr(e1) + printUnop(op);	
	case EUnop(op, false, e1):
		printUnop(op) + printExpr(e1);	
	case EFunction(FNamed(no, inlined), func):
		(inlined ? "inline " : "") + "function $no" + printFunction(func);	
	case EFunction(kind, func):
		(kind != FArrow ? "function" : "") + printFunction(func, kind);	
	case EVars([]):
		"var ";	
	case EVars(vl):
		((vl[0].isStatic) ? "static " : "") + ((vl[0].isFinal) ? "final " : "var ") + vl.map(printVar).join(", ");	
	case EBlock([]):
		"{ }";	
	case EBlock(el):
		var old = tabs;
		tabs += tabString;
		var s = "{\n$tabs" + printExprs(el, ";\n$tabs");
		tabs = old;
		s + ";\n$tabs}";	
	case EFor(e1, e2):
		"for (${printExpr(e1)}) ${printExpr(e2)}";	
	case EIf(econd, eif, null):
		"if (${printExpr(econd)}) ${printExpr(eif)}";	
	case EIf(econd, eif, eelse):
		"if (${printExpr(econd)}) ${printExpr(eif)} else ${printExpr(eelse)}";	
	case EWhile(econd, e1, true):
		"while (${printExpr(econd)}) ${printExpr(e1)}";	
	case EWhile(econd, e1, false):
		"do ${printExpr(e1)} while (${printExpr(econd)})";	
	case ESwitch(e1, cl, edef):
		var old = tabs;
		tabs += tabString;
		var s = "switch ${printExpr(e1)} {\n$tabs" + cl.map(function(c) return "case ${printExprs(c.values, \", \")}" + (c.guard != null ? " if (${printExpr(c.guard)}):" : ":") + (c.expr != null ? (opt(c.expr, printExpr)) + ";" : "")).join("\n$tabs");
		if (edef != null) s += "\n${tabs}default:" + (edef.expr == null ? "" : printExpr(edef) + ";");
		tabs = old;
		s + "\n$tabs}";	
	case ETry(e1, cl):
		"try ${printExpr(e1)}" + cl.map(function(c) return " catch(${c.name}${c.type == null ? '' : (':' + printComplexType(c.type))}) ${printExpr(c.expr)}").join("");	
	case EReturn(eo):
		"return" + opt(eo, printExpr, " ");	
	case EBreak:
		"break";	
	case EContinue:
		"continue";	
	case EUntyped(e1):
		"untyped " + printExpr(e1);	
	case EThrow(e1):
		"throw " + printExpr(e1);	
	case ECast(e1, cto) if (cto != null):
		"cast(${printExpr(e1)}, ${printComplexType(cto)})";	
	case ECast(e1, _):
		"cast " + printExpr(e1);	
	case EIs(e1, ct):
		"${printExpr(e1)} is ${printComplexType(ct)}";	
	case EDisplay(e1, _):
		"#DISPLAY(${printExpr(e1)})";	
	case ETernary(econd, eif, eelse):
		"${printExpr(econd)} ? ${printExpr(eif)} : ${printExpr(eelse)}";	
	case ECheckType(e1, ct):
		"(${printExpr(e1)} : ${printComplexType(ct)})";	
	case EMeta({ name : ":implicitReturn" }, { expr : EReturn(e1) }):
		printExpr(e1);	
	case EMeta(meta, e1):
		printMetadata(meta) + " " + printExpr(e1);	
}) {
				var ` = e.expr;
				switch (@:exhaustive enumIndex `) {
					case 0: {
						var ` = `[0];
						{
							var c = `;
							{
								this.printConstant(c);
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var e2 = `;
							{
								"" + this.printExpr(e1) + "[" + this.printExpr(e2) + "]";
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var e1 = `;
							var e2 = `;
							{
								"" + this.printExpr(e1) + " " + this.printBinop(op) + " " + this.printExpr(e2);
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e1 = `;
							var n = `;
							var kind = `;
							{
								if (kind == haxe.macro.EFieldKind.Safe) {
									"" + this.printExpr(e1) + "?." + n;
								} else {
									"" + this.printExpr(e1) + "." + n;
								};
							};
						};
					};
					case 4: {
						var ` = `[0];
						{
							var e1 = `;
							{
								"(" + this.printExpr(e1) + ")";
							};
						};
					};
					case 5: {
						var ` = `[0];
						{
							var fl = `;
							{
								"{ " + {
									var ` = [];
									{
										var ` = 0;
										var ` = fl;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(fld:haxe.macro.ObjectField) {
												return `this.printObjectField(fld);
											}(v));
										};
									};
									`;
								}.join(", ") + " }";
							};
						};
					};
					case 6: {
						var ` = `[0];
						{
							var el = `;
							{
								"[" + this.printExprs(el, ", ") + "]";
							};
						};
					};
					case 7: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var el = `;
							{
								"" + this.printExpr(e1) + "(" + this.printExprs(el, ", ") + ")";
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var tp = `;
							var el = `;
							{
								"new " + this.printTypePath(tp) + "(" + this.printExprs(el, ", ") + ")";
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (`) {
							{
								var op = `;
								var e1 = `;
								{
									this.printExpr(e1) + this.printUnop(op);
								};
							};
						} else {
							{
								var op = `;
								var e1 = `;
								{
									this.printUnop(op) + this.printExpr(e1);
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						if (`.length == 0) {
							{
								"var ";
							};
						} else {
							var vl = `;
							{
								(if ((vl[0].isStatic)) {
									"static ";
								} else {
									"";
								}) + (if ((vl[0].isFinal)) {
									"final ";
								} else {
									"var ";
								}) + {
									var f = this.printVar;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = vl;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								}.join(", ");
							};
						};
					};
					case 11: {
						var ` = `[0];
						var ` = `[1];
						if (` == null) {
							var kind = `;
							var func = `;
							{
								(if (kind != haxe.macro.FunctionKind.FArrow) {
									"function";
								} else {
									"";
								}) + this.printFunction(func, kind);
							};
						} else if (enumIndex ` == 1) {
							var ` = `[0];
							var ` = `[1];
							{
								var no = `;
								var inlined = `;
								var func = `;
								{
									(if (inlined) {
										"inline ";
									} else {
										"";
									}) + "function " + no + this.printFunction(func, null);
								};
							};
						} else {
							var kind = `;
							var func = `;
							{
								(if (kind != haxe.macro.FunctionKind.FArrow) {
									"function";
								} else {
									"";
								}) + this.printFunction(func, kind);
							};
						};
					};
					case 12: {
						var ` = `[0];
						if (`.length == 0) {
							{
								"{ }";
							};
						} else {
							var el = `;
							{
								var old = this.tabs;
								this.tabs += this.tabString;
								var s = "{\n" + this.tabs + this.printExprs(el, ";\n" + this.tabs);
								this.tabs = old;
								s + ";\n" + this.tabs + "}";
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var e2 = `;
							{
								"for (" + this.printExpr(e1) + ") " + this.printExpr(e2);
							};
						};
					};
					case 14: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) {
							var eif = `;
							var econd = `;
							{
								"if (" + this.printExpr(econd) + ") " + this.printExpr(eif);
							};
						} else {
							var eelse = `;
							var eif = `;
							var econd = `;
							{
								"if (" + this.printExpr(econd) + ") " + this.printExpr(eif) + " else " + this.printExpr(eelse);
							};
						};
					};
					case 15: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (`) {
							{
								var e1 = `;
								var econd = `;
								{
									"while (" + this.printExpr(econd) + ") " + this.printExpr(e1);
								};
							};
						} else {
							{
								var e1 = `;
								var econd = `;
								{
									"do " + this.printExpr(e1) + " while (" + this.printExpr(econd) + ")";
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e1 = `;
							var cl = `;
							var edef = `;
							{
								var old = this.tabs;
								this.tabs += this.tabString;
								var s = "switch " + this.printExpr(e1) + " {\n" + this.tabs + {
									var ` = [];
									{
										var ` = 0;
										var ` = cl;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(c:haxe.macro.Case) {
												return "case " + `this.printExprs(c.values, ", ") + (if ((c.guard != null)) " if (" + `this.printExpr(c.guard) + "):" else ":") + (if ((c.expr != null)) `this.opt(c.expr, `this.printExpr, null) + ";" else "");
											}(v));
										};
									};
									`;
								}.join("\n" + this.tabs);
								if (edef != null) {
									s += "\n" + this.tabs + "default:" + (if (edef.expr == null) {
										"";
									} else {
										this.printExpr(edef) + ";";
									});
								};
								this.tabs = old;
								s + "\n" + this.tabs + "}";
							};
						};
					};
					case 17: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var cl = `;
							{
								"try " + this.printExpr(e1) + {
									var ` = [];
									{
										var ` = 0;
										var ` = cl;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(c:haxe.macro.Catch) {
												return " catch(" + c.name + (if ((c.type == null)) "" else ":" + `this.printComplexType(c.type)) + ") " + `this.printExpr(c.expr);
											}(v));
										};
									};
									`;
								}.join("");
							};
						};
					};
					case 18: {
						var ` = `[0];
						{
							var eo = `;
							{
								"return" + this.opt(eo, this.printExpr, " ");
							};
						};
					};
					case 19: {
						{
							"break";
						};
					};
					case 20: {
						{
							"continue";
						};
					};
					case 21: {
						var ` = `[0];
						{
							var e1 = `;
							{
								"untyped " + this.printExpr(e1);
							};
						};
					};
					case 22: {
						var ` = `[0];
						{
							var e1 = `;
							{
								"throw " + this.printExpr(e1);
							};
						};
					};
					case 23: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var cto = `;
							if (cto != null) {
								"cast(" + this.printExpr(e1) + ", " + this.printComplexType(cto) + ")";
							} else {
								var e1 = `;
								{
									"cast " + this.printExpr(e1);
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							{
								"#DISPLAY(" + this.printExpr(e1) + ")";
							};
						};
					};
					case 25: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var econd = `;
							var eif = `;
							var eelse = `;
							{
								"" + this.printExpr(econd) + " ? " + this.printExpr(eif) + " : " + this.printExpr(eelse);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var ct = `;
							{
								"(" + this.printExpr(e1) + " : " + this.printComplexType(ct) + ")";
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var ` = `.name;
							var ` = `.params;
							var ` = `.pos;
							if (` == ":implicitReturn") {
								{
									var ` = `.expr;
									var ` = `.pos;
									if (enumIndex ` == 18) {
										var ` = `[0];
										{
											var e1 = `;
											{
												this.printExpr(e1);
											};
										};
									} else {
										var meta = `;
										var e1 = `;
										{
											this.printMetadata(meta) + " " + this.printExpr(e1);
										};
									};
								};
							} else {
								var meta = `;
								var e1 = `;
								{
									this.printMetadata(meta) + " " + this.printExpr(e1);
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var ct = `;
							{
								"" + this.printExpr(e1) + " is " + this.printComplexType(ct);
							};
						};
					};
				};
			};
		};
	}

	public function printExprs(el:Array<haxe.macro.Expr>, sep:String) {
		return {
			var f = this.printExpr;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = el;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(sep);
	}

	function printExtension(tpl:Array<haxe.macro.TypePath>, fields:Array<haxe.macro.Field>) {
		return "{\n" + this.tabs + ">" + {
			var f = this.printTypePath;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = tpl;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		}.join(",\n" + this.tabs + ">") + "," + (if (fields.length > 0) {
			("\n" + this.tabs + {
				var f = this.printField;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = fields;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(f(v));
						};
					};
					`;
				};
			}.join(";\n" + this.tabs) + ";\n}");
		} else {
			("\n}");
		});
	}

	function printStructure(fields:Array<haxe.macro.Field>) {
		return if (fields.length == 0) {
			"{ }";
		} else {
			"{\n" + this.tabs + {
				var f = this.printField;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = fields;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(f(v));
						};
					};
					`;
				};
			}.join(";\n" + this.tabs) + ";\n}";
		};
	}

	@:value({ printPackage : true })
	public function printTypeDefinition(t:haxe.macro.TypeDefinition, printPackage:Bool = true) {
		var old = this.tabs;
		this.tabs = this.tabString;
		var str = if (t == null) {
			"#NULL";
		} else {
			(if (printPackage && t.pack.length > 0 && t.pack[0] != "") {
				"package " + t.pack.join(".") + ";\n";
			} else {
				"";
			}) + (if (t.doc != null && t.doc != "") {
				"/**\n" + this.tabString + StringTools.replace(t.doc, "\n", "\n" + this.tabString) + "\n**/\n";
			} else {
				"";
			}) + (if (t.meta != null && t.meta.length > 0) {
				{
					var _this = t.meta;
					var f = this.printMetadata;
					{
						var ` = [];
						{
							var ` = 0;
							var ` = _this;
							while (` < `.length) {
								var v = `[`];
								++ `;
								`.push(f(v));
							};
						};
						`;
					};
				}.join(" ") + " ";
			} else {
				"";
			}) + (if (t.isExtern) {
				"extern ";
			} else {
				"";
			}) + @:ast(switch (t.kind) {
	case TDEnum:
		"enum " + t.name + ((t.params != null && t.params.length > 0) ? "<" + t.params.map(printTypeParamDecl).join(", ") + ">" : "") + " {\n" + [for (field  in  t.fields) tabs + (field.doc != null && field.doc != "" ? "/**\n" + tabs + tabString + StringTools.replace(field.doc, "\n", "\n" + tabs + tabString) + "\n" + tabs + "**/\n" + tabs : "") + (field.meta != null && field.meta.length > 0 ? field.meta.map(printMetadata).join(" ") + " " : "") + (switch (field.kind) {
			case FVar(t, _):
				field.name + opt(t, printComplexType, ":");			
			case FProp(_, _, _, _):
				throw "FProp is invalid for TDEnum.";			
			case FFun(func):
				field.name + printFunction(func);			
		}) + ";"].join("\n") + "\n}";	
	case TDStructure:
		"typedef " + t.name + ((t.params != null && t.params.length > 0) ? "<" + t.params.map(printTypeParamDecl).join(", ") + ">" : "") + " = {\n" + [for (f  in  t.fields) {
			tabs + printField(f) + ";";
		}].join("\n") + "\n}";	
	case TDClass(superClass, interfaces, isInterface, isFinal, isAbstract):
		(isFinal ? "final " : "") + (isAbstract ? "abstract " : "") + (isInterface ? "interface " : "class ") + t.name + (t.params != null && t.params.length > 0 ? "<" + t.params.map(printTypeParamDecl).join(", ") + ">" : "") + (superClass != null ? " extends " + printTypePath(superClass) : "") + (interfaces != null ? (isInterface ? [for (tp  in  interfaces) " extends " + printTypePath(tp)] : [for (tp  in  interfaces) " implements " + printTypePath(tp)]).join("") : "") + " {\n" + [for (f  in  t.fields) {
			tabs + printFieldWithDelimiter(f);
		}].join("\n") + "\n}";	
	case TDAlias(ct):
		"typedef " + t.name + ((t.params != null && t.params.length > 0) ? "<" + t.params.map(printTypeParamDecl).join(", ") + ">" : "") + " = " + (switch (ct) {
			case TExtend(tpl, fields):
				printExtension(tpl, fields);			
			case TAnonymous(fields):
				printStructure(fields);			
			case _:
				printComplexType(ct);			
		}) + ";";	
	case TDAbstract(tthis, tflags, from, to):
		var from = from == null ? [] : from.copy();
		var to = to == null ? [] : to.copy();
		var isEnum = false;
		if (tflags != null) {
			for (flag  in  tflags) {
				switch (flag) {
					case AbEnum:
						isEnum = true;					
					case AbFrom(ct):
						from.push(ct);					
					case AbTo(ct):
						to.push(ct);					
				};
			};
		};
		(isEnum ? "enum " : "") + "abstract " + t.name + ((t.params != null && t.params.length > 0) ? "<" + t.params.map(printTypeParamDecl).join(", ") + ">" : "") + (tthis == null ? "" : "(" + printComplexType(tthis) + ")") + [for (f  in  from) " from " + printComplexType(f)].join("") + [for (f  in  to) " to " + printComplexType(f)].join("") + " {\n" + [for (f  in  t.fields) {
			tabs + printFieldWithDelimiter(f);
		}].join("\n") + "\n}";	
	case TDField(kind, access):
		tabs = old;
		(access != null && access.length > 0 ? access.map(printAccess).join(" ") + " " : "") + switch (kind) {
			case FVar(type, eo):
				((access != null && access.has(AFinal)) ? "" : "var ") + "${t.name}" + opt(type, printComplexType, " : ") + opt(eo, printExpr, " = ") + ";";			
			case FProp(get, set, type, eo):
				"var ${t.name}($get, $set)" + opt(type, printComplexType, " : ") + opt(eo, printExpr, " = ") + ";";			
			case FFun(func):
				"function ${t.name}" + printFunction(func) + switch func.expr {
					case { expr : EBlock(_) }:
						"";					
					case _:
						";";					
				};			
		};	
}) {
				var ` = t.kind;
				switch (@:exhaustive enumIndex `) {
					case 0: {
						{
							"enum " + t.name + (if ((t.params != null && t.params.length > 0)) {
								"<" + {
									var _this = t.params;
									var f = this.printTypeParamDecl;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = _this;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								}.join(", ") + ">";
							} else {
								"";
							}) + " {\n" + {
								var ` = [];
								{
									var ` = 0;
									var ` = t.fields;
									while (` < `.length) {
										var field = `[`];
										++ `;
										`.push(this.tabs + (if (field.doc != null && field.doc != "") {
											"/**\n" + this.tabs + this.tabString + StringTools.replace(field.doc, "\n", "\n" + this.tabs + this.tabString) + "\n" + this.tabs + "**/\n" + this.tabs;
										} else {
											"";
										}) + (if (field.meta != null && field.meta.length > 0) {
											{
												var _this = field.meta;
												var f = this.printMetadata;
												{
													var ` = [];
													{
														var ` = 0;
														var ` = _this;
														while (` < `.length) {
															var v = `[`];
															++ `;
															`.push(f(v));
														};
													};
													`;
												};
											}.join(" ") + " ";
										} else {
											"";
										}) + (@:ast(switch (field.kind) {
	case FVar(t, _):
		field.name + opt(t, printComplexType, ":");	
	case FProp(_, _, _, _):
		throw "FProp is invalid for TDEnum.";	
	case FFun(func):
		field.name + printFunction(func);	
}) {
											var ` = field.kind;
											switch (@:exhaustive enumIndex `) {
												case 0: {
													var ` = `[0];
													var ` = `[1];
													{
														var t = `;
														{
															field.name + this.opt(t, this.printComplexType, ":");
														};
													};
												};
												case 1: {
													var ` = `[0];
													{
														var func = `;
														{
															field.name + this.printFunction(func, null);
														};
													};
												};
												case 2: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													var ` = `[3];
													{
														throw "FProp is invalid for TDEnum.";
													};
												};
											};
										}) + ";");
									};
								};
								`;
							}.join("\n") + "\n}";
						};
					};
					case 1: {
						{
							"typedef " + t.name + (if ((t.params != null && t.params.length > 0)) {
								"<" + {
									var _this = t.params;
									var f = this.printTypeParamDecl;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = _this;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								}.join(", ") + ">";
							} else {
								"";
							}) + " = {\n" + {
								var ` = [];
								{
									var ` = 0;
									var ` = t.fields;
									while (` < `.length) {
										var f = `[`];
										++ `;
										`.push(this.tabs + this.printField(f) + ";");
									};
								};
								`;
							}.join("\n") + "\n}";
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						var ` = `[4];
						{
							var superClass = `;
							var interfaces = `;
							var isInterface = `;
							var isFinal = `;
							var isAbstract = `;
							{
								(if (isFinal) {
									"final ";
								} else {
									"";
								}) + (if (isAbstract) {
									"abstract ";
								} else {
									"";
								}) + (if (isInterface) {
									"interface ";
								} else {
									"class ";
								}) + t.name + (if (t.params != null && t.params.length > 0) {
									"<" + {
										var _this = t.params;
										var f = this.printTypeParamDecl;
										{
											var ` = [];
											{
												var ` = 0;
												var ` = _this;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									}.join(", ") + ">";
								} else {
									"";
								}) + (if (superClass != null) {
									" extends " + this.printTypePath(superClass);
								} else {
									"";
								}) + (if (interfaces != null) {
									(if (isInterface) {
										{
											var ` = [];
											{
												var ` = 0;
												while (` < interfaces.length) {
													var tp = interfaces[`];
													++ `;
													`.push(" extends " + this.printTypePath(tp));
												};
											};
											`;
										};
									} else {
										{
											var ` = [];
											{
												var ` = 0;
												while (` < interfaces.length) {
													var tp = interfaces[`];
													++ `;
													`.push(" implements " + this.printTypePath(tp));
												};
											};
											`;
										};
									}).join("");
								} else {
									"";
								}) + " {\n" + {
									var ` = [];
									{
										var ` = 0;
										var ` = t.fields;
										while (` < `.length) {
											var f = `[`];
											++ `;
											`.push(this.tabs + this.printFieldWithDelimiter(f));
										};
									};
									`;
								}.join("\n") + "\n}";
							};
						};
					};
					case 3: {
						var ` = `[0];
						{
							var ct = `;
							{
								"typedef " + t.name + (if ((t.params != null && t.params.length > 0)) {
									"<" + {
										var _this = t.params;
										var f = this.printTypeParamDecl;
										{
											var ` = [];
											{
												var ` = 0;
												var ` = _this;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									}.join(", ") + ">";
								} else {
									"";
								}) + " = " + (@:ast(switch (ct) {
	case TExtend(tpl, fields):
		printExtension(tpl, fields);	
	case TAnonymous(fields):
		printStructure(fields);	
	case _:
		printComplexType(ct);	
}) switch (enumIndex ct) {
									case 2: {
										var ` = ct[0];
										{
											var fields = `;
											{
												this.printStructure(fields);
											};
										};
									};
									case 4: {
										var ` = ct[0];
										var ` = ct[1];
										{
											var tpl = `;
											var fields = `;
											{
												this.printExtension(tpl, fields);
											};
										};
									};
									default: {
										this.printComplexType(ct);
									}
								}) + ";";
							};
						};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var tthis = `;
							var tflags = `;
							var from = `;
							var to = `;
							{
								var from = if (from == null) {
									[];
								} else {
									from.copy();
								};
								var to = if (to == null) {
									[];
								} else {
									to.copy();
								};
								var isEnum = false;
								if (tflags != null) {
									{
										var ` = 0;
										while (` < tflags.length) {
											var flag = tflags[`];
											++ `;
											@:ast(switch (flag) {
	case AbEnum:
		isEnum = true;	
	case AbFrom(ct):
		from.push(ct);	
	case AbTo(ct):
		to.push(ct);	
}) switch (@:exhaustive enumIndex flag) {
												case 0: {
													{
														isEnum = true;
													};
												};
												case 1: {
													var ` = flag[0];
													{
														var ct = `;
														{
															from.push(ct);
														};
													};
												};
												case 2: {
													var ` = flag[0];
													{
														var ct = `;
														{
															to.push(ct);
														};
													};
												};
											};
										};
									};
								};
								(if (isEnum) {
									"enum ";
								} else {
									"";
								}) + "abstract " + t.name + (if ((t.params != null && t.params.length > 0)) {
									"<" + {
										var _this = t.params;
										var f = this.printTypeParamDecl;
										{
											var ` = [];
											{
												var ` = 0;
												var ` = _this;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									}.join(", ") + ">";
								} else {
									"";
								}) + (if (tthis == null) {
									"";
								} else {
									"(" + this.printComplexType(tthis) + ")";
								}) + {
									var ` = [];
									{
										var ` = 0;
										while (` < from.length) {
											var f = from[`];
											++ `;
											`.push(" from " + this.printComplexType(f));
										};
									};
									`;
								}.join("") + {
									var ` = [];
									{
										var ` = 0;
										while (` < to.length) {
											var f = to[`];
											++ `;
											`.push(" to " + this.printComplexType(f));
										};
									};
									`;
								}.join("") + " {\n" + {
									var ` = [];
									{
										var ` = 0;
										var ` = t.fields;
										while (` < `.length) {
											var f = `[`];
											++ `;
											`.push(this.tabs + this.printFieldWithDelimiter(f));
										};
									};
									`;
								}.join("\n") + "\n}";
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						{
							var kind = `;
							var access = `;
							{
								this.tabs = old;
								(if (access != null && access.length > 0) {
									{
										var f = this.printAccess;
										{
											var ` = [];
											{
												var ` = 0;
												var ` = access;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									}.join(" ") + " ";
								} else {
									"";
								}) + @:ast(switch (kind) {
	case FVar(type, eo):
		((access != null && access.has(AFinal)) ? "" : "var ") + "${t.name}" + opt(type, printComplexType, " : ") + opt(eo, printExpr, " = ") + ";";	
	case FProp(get, set, type, eo):
		"var ${t.name}($get, $set)" + opt(type, printComplexType, " : ") + opt(eo, printExpr, " = ") + ";";	
	case FFun(func):
		"function ${t.name}" + printFunction(func) + switch func.expr {
			case { expr : EBlock(_) }:
				"";			
			case _:
				";";			
		};	
}) switch (@:exhaustive enumIndex kind) {
									case 0: {
										var ` = kind[0];
										var ` = kind[1];
										{
											var type = `;
											var eo = `;
											{
												(if ((access != null && Lambda.has(access, haxe.macro.Access.AFinal))) {
													"";
												} else {
													"var ";
												}) + "" + t.name + this.opt(type, this.printComplexType, " : ") + this.opt(eo, this.printExpr, " = ") + ";";
											};
										};
									};
									case 1: {
										var ` = kind[0];
										{
											var func = `;
											{
												"function " + t.name + this.printFunction(func, null) + @:ast(switch func.expr {
	case { expr : EBlock(_) }:
		"";	
	case _:
		";";	
}) {
													var ` = func.expr;
													if (` == null) {
														";";
													} else {
														var ` = `.expr;
														var ` = `.pos;
														if (enumIndex ` == 12) {
															var ` = `[0];
															{
																"";
															};
														} else {
															";";
														};
													};
												};
											};
										};
									};
									case 2: {
										var ` = kind[0];
										var ` = kind[1];
										var ` = kind[2];
										var ` = kind[3];
										{
											var get = `;
											var set = `;
											var type = `;
											var eo = `;
											{
												"var " + t.name + "(" + get + ", " + set + ")" + this.opt(type, this.printComplexType, " : ") + this.opt(eo, this.printExpr, " = ") + ";";
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
		this.tabs = old;
		return str;
	}

	function printFieldWithDelimiter(f:haxe.macro.Field) {
		return this.printField(f) + @:ast(switch (f.kind) {
	case FVar(_, _), FProp(_, _, _, _):
		";";	
	case FFun({ expr : null }):
		";";	
	case FFun({ expr : { expr : EBlock(_) } }):
		"";	
	case FFun(_):
		";";	
	case _:
		"";	
}) {
			var ` = f.kind;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					{
						";";
					};
				};
				case 1: {
					var ` = `[0];
					{
						var ` = `.args;
						var ` = `.expr;
						var ` = `.params;
						var ` = `.ret;
						if (` == null) {
							";";
						} else {
							var ` = `.expr;
							var ` = `.pos;
							if (enumIndex ` == 12) {
								var ` = `[0];
								{
									"";
								};
							} else {
								";";
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						";";
					};
				};
			};
		};
	}

	@:value({ prefix : "" })
	function opt<T>(v:opt.T, f:opt.T -> String, prefix:String = "") return if (v == null) {
		"";
	} else {
		(prefix + f(v));
	}

	public function printExprWithPositions(e:haxe.macro.Expr) {
		var `this = this;
		var buffer = new StringBuf();
		var format4 = function(i:Int) {
			return StringTools.lpad(Std.string(i), " ", 4);
		};
		var loop = [null];
		loop[0] = function(tabs:String, e:haxe.macro.Expr) {
			var add = function(s:String, p:Null<haxe.macro.Position> = null) {
				if (p == null) {
					p = e.pos;
				};
				var p = haxe.macro.Context.getPosInfos(p);
				buffer.add("" + format4(p.min) + "-" + format4(p.max) + " " + tabs + s + "\n");
			};
			var loopI = function(e:haxe.macro.Expr) loop[0](tabs + `this.tabString, e);
			@:ast(switch (e.expr) {
	case EConst(c):
		add(printConstant(c));	
	case EArray(e1, e2):
		add("EArray");
		loopI(e1);
		loopI(e2);	
	case EBinop(op, e1, e2):
		add("EBinop " + printBinop(op));
		loopI(e1);
		loopI(e2);	
	case EField(e, field, kind):
		if (kind == null) kind = Normal;
		add("EField $field (${kind.getName()})");
		loopI(e);	
	case EParenthesis(e):
		add("EParenthesis");
		loopI(e);	
	case EObjectDecl(fields):
		add("EObjectDecl");
		for (field  in  fields) {
			add(field.field);
			loopI(field.expr);
		};	
	case EArrayDecl(values):
		add("EArrayDecl");
		values.iter(loopI);	
	case ECall(e, params):
		add("ECall");
		loopI(e);
		params.iter(loopI);	
	case ENew(tp, params):
		add("ENew " + printTypePath(tp));
		params.iter(loopI);	
	case EUnop(op, postFix, e):
		add("EUnop " + printUnop(op));
		loopI(e);	
	case EVars(vars):
		add("EVars");
		for (v  in  vars) {
			if (v.expr != null) {
				add(v.name);
				loopI(v.expr);
			};
		};	
	case EFunction(_, f):
		add("EFunction");
		if (f.expr != null) {
			loopI(f.expr);
		};	
	case EBlock(exprs):
		add("EBlock");
		exprs.iter(loopI);	
	case EFor(it, expr):
		add("EFor");
		loopI(it);
		loopI(expr);	
	case EIf(econd, eif, eelse):
		add("EIf");
		loopI(econd);
		loopI(eif);
		if (eelse != null) {
			loopI(eelse);
		};	
	case EWhile(econd, e, normalWhile):
		add("EWhile");
		loopI(econd);
		loopI(e);	
	case ESwitch(e, cases, edef):
		add("ESwitch");
		loopI(e);
		for (c  in  cases) {
			for (pat  in  c.values) {
				loop(tabs + tabString + tabString, pat);
			};
			if (c.expr != null) {
				loop(tabs + tabString + tabString + tabString, c.expr);
			};
		};
		if (edef != null) {
			loop(tabs + tabString + tabString + tabString, edef);
		};	
	case ETry(e, catches):
		add("ETry");
		loopI(e);
		for (c  in  catches) {
			loop(tabs + tabString + tabString, c.expr);
		};	
	case EReturn(e):
		add("EReturn");
		if (e != null) {
			loopI(e);
		};	
	case EBreak:
		add("EBreak");	
	case EContinue:
		add("EContinue");	
	case EUntyped(e):
		add("EUntyped");
		loopI(e);	
	case EThrow(e):
		add("EThrow");
		loopI(e);	
	case ECast(e, t):
		add("ECast");
		loopI(e);	
	case EIs(e, t):
		add("EIs");
		loopI(e);	
	case EDisplay(e, displayKind):
		add("EDisplay");
		loopI(e);	
	case ETernary(econd, eif, eelse):
		add("ETernary");
		loopI(econd);
		loopI(eif);
		loopI(eelse);	
	case ECheckType(e, t):
		add("ECheckType");
		loopI(e);	
	case EMeta(s, e):
		add("EMeta " + printMetadata(s));
		loopI(e);	
}) {
				var ` = e.expr;
				switch (@:exhaustive enumIndex `) {
					case 0: {
						var ` = `[0];
						{
							var c = `;
							{
								add(`this.printConstant(c), null);
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							var e2 = `;
							{
								add("EArray", null);
								loopI(e1);
								loopI(e2);
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var e1 = `;
							var e2 = `;
							{
								add("EBinop " + `this.printBinop(op), null);
								loopI(e1);
								loopI(e2);
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							var field = `;
							var kind = `;
							{
								if (kind == null) {
									kind = haxe.macro.EFieldKind.Normal;
								};
								add("EField " + field + " (" + Type.enumConstructor(kind) + ")", null);
								loopI(e);
							};
						};
					};
					case 4: {
						var ` = `[0];
						{
							var e = `;
							{
								add("EParenthesis", null);
								loopI(e);
							};
						};
					};
					case 5: {
						var ` = `[0];
						{
							var fields = `;
							{
								add("EObjectDecl", null);
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										add(field.field, null);
										loopI(field.expr);
									};
								};
							};
						};
					};
					case 6: {
						var ` = `[0];
						{
							var values = `;
							{
								add("EArrayDecl", null);
								Lambda.iter(values, loopI);
							};
						};
					};
					case 7: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var params = `;
							{
								add("ECall", null);
								loopI(e);
								Lambda.iter(params, loopI);
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var tp = `;
							var params = `;
							{
								add("ENew " + `this.printTypePath(tp), null);
								Lambda.iter(params, loopI);
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var postFix = `;
							var e = `;
							{
								add("EUnop " + `this.printUnop(op), null);
								loopI(e);
							};
						};
					};
					case 10: {
						var ` = `[0];
						{
							var vars = `;
							{
								add("EVars", null);
								{
									var ` = 0;
									while (` < vars.length) {
										var v = vars[`];
										++ `;
										if (v.expr != null) {
											add(v.name, null);
											loopI(v.expr);
										};
									};
								};
							};
						};
					};
					case 11: {
						var ` = `[0];
						var ` = `[1];
						{
							var f = `;
							{
								add("EFunction", null);
								if (f.expr != null) {
									loopI(f.expr);
								};
							};
						};
					};
					case 12: {
						var ` = `[0];
						{
							var exprs = `;
							{
								add("EBlock", null);
								Lambda.iter(exprs, loopI);
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var it = `;
							var expr = `;
							{
								add("EFor", null);
								loopI(it);
								loopI(expr);
							};
						};
					};
					case 14: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var econd = `;
							var eif = `;
							var eelse = `;
							{
								add("EIf", null);
								loopI(econd);
								loopI(eif);
								if (eelse != null) {
									loopI(eelse);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var econd = `;
							var e = `;
							var normalWhile = `;
							{
								add("EWhile", null);
								loopI(econd);
								loopI(e);
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							var cases = `;
							var edef = `;
							{
								add("ESwitch", null);
								loopI(e);
								{
									var ` = 0;
									while (` < cases.length) {
										var c = cases[`];
										++ `;
										{
											var ` = 0;
											var ` = c.values;
											while (` < `.length) {
												var pat = `[`];
												++ `;
												loop[0](tabs + `this.tabString + `this.tabString, pat);
											};
										};
										if (c.expr != null) {
											loop[0](tabs + `this.tabString + `this.tabString + `this.tabString, c.expr);
										};
									};
								};
								if (edef != null) {
									loop[0](tabs + `this.tabString + `this.tabString + `this.tabString, edef);
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var catches = `;
							{
								add("ETry", null);
								loopI(e);
								{
									var ` = 0;
									while (` < catches.length) {
										var c = catches[`];
										++ `;
										loop[0](tabs + `this.tabString + `this.tabString, c.expr);
									};
								};
							};
						};
					};
					case 18: {
						var ` = `[0];
						{
							var e = `;
							{
								add("EReturn", null);
								if (e != null) {
									loopI(e);
								};
							};
						};
					};
					case 19: {
						{
							add("EBreak", null);
						};
					};
					case 20: {
						{
							add("EContinue", null);
						};
					};
					case 21: {
						var ` = `[0];
						{
							var e = `;
							{
								add("EUntyped", null);
								loopI(e);
							};
						};
					};
					case 22: {
						var ` = `[0];
						{
							var e = `;
							{
								add("EThrow", null);
								loopI(e);
							};
						};
					};
					case 23: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var t = `;
							{
								add("ECast", null);
								loopI(e);
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var displayKind = `;
							{
								add("EDisplay", null);
								loopI(e);
							};
						};
					};
					case 25: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var econd = `;
							var eif = `;
							var eelse = `;
							{
								add("ETernary", null);
								loopI(econd);
								loopI(eif);
								loopI(eelse);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var t = `;
							{
								add("ECheckType", null);
								loopI(e);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var s = `;
							var e = `;
							{
								add("EMeta " + `this.printMetadata(s), null);
								loopI(e);
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var t = `;
							{
								add("EIs", null);
								loopI(e);
							};
						};
					};
				};
			};
		};
		loop[0]("", e);
		return buffer.toString();
	}
}