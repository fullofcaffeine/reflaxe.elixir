@:used
class StringTools {

	@:value(0xD800)
	public static inline var MIN_SURROGATE_CODE_POINT:Int = 55296;

	@:value(0xDFFF)
	public static inline var MAX_SURROGATE_CODE_POINT:Int = 57343;

	@:value(0xD800)
	public static inline var MIN_HIGH_SURROGATE_CODE_POINT:Int = 55296;

	@:value(0xDBFF)
	public static inline var MAX_HIGH_SURROGATE_CODE_POINT:Int = 56319;

	@:value(0xDC00)
	public static inline var MIN_LOW_SURROGATE_CODE_POINT:Int = 56320;

	@:value(0xDFFF)
	public static inline var MAX_LOW_SURROGATE_CODE_POINT:Int = 57343;

	public static function urlEncode(s:String) {
		var result = "";
		{
			var _g = 0;
			var _g1 = s.length;
			while ((_g < _g1)) {
				var i = _g ++;
				var c = {
					var result = __elixir__(":binary.at({0}, {1})", s, i);
					__elixir__("if {0} == nil, do: nil, else: {0}", result);
				};
				if ((c >= 65 && c <= 90 || c >= 97 && c <= 122 || c >= 48 && c <= 57 || c == 45 || c == 95 || c == 46 || c == 126)) result += @:pure {
					var code = c;
					__elixir__("<<{0}::utf8>>", code);
				} else result += "%" + {
					var _this = StringTools.hex(c, 2);
					__elixir__("String.upcase({0})", _this);
				};
			};
		};
		return result;
	}

	public static function urlDecode(s:String) {
		var result = "";
		var i = 0;
		while ((i < s.length)) {
			var c = __elixir__("String.at({0}, {1}) || \"\"", s, i);
			if ((c == "%")) {
				if ((i + 2 < s.length)) {
					var hex = {
						var pos = i + 1;
						__elixir__("String.slice({0}, {1}, {2})", s, pos, 2);
					};
					var code = StringTools.parseInt("0x" + hex);
					if ((code != null)) {
						result += @:pure {
							var code = code;
							__elixir__("<<{0}::utf8>>", code);
						};
						i += 3;
						continue;
					};
				};
			};
			result += c;
			i ++;
		};
		return result;
	}

	public static function htmlEscape(s:String, quotes:Null<Bool> = null) {
		s = StringTools.replace(s, "&", "&amp;");
		s = StringTools.replace(s, "<", "&lt;");
		s = StringTools.replace(s, ">", "&gt;");
		if ((quotes)) {
			s = StringTools.replace(s, "\"", "&quot;");
			s = StringTools.replace(s, "'", "&#039;");
		};
		return s;
	}

	public static function htmlUnescape(s:String) {
		s = StringTools.replace(s, "&gt;", ">");
		s = StringTools.replace(s, "&lt;", "<");
		s = StringTools.replace(s, "&quot;", "\"");
		s = StringTools.replace(s, "&#039;", "'");
		s = StringTools.replace(s, "&amp;", "&");
		return s;
	}

	public static function startsWith(s:String, start:String) {
		return s.length >= start.length && {
			var len = start.length;
			if ((len == null)) __elixir__("String.slice({0}, {1}..-1)", s, 0) else __elixir__("String.slice({0}, {1}, {2})", s, 0, len);
		} == start;
	}

	public static function endsWith(s:String, end:String) {
		var elen = end.length;
		var slen = s.length;
		return slen >= elen && {
			var pos = slen - elen;
			if ((elen == null)) __elixir__("String.slice({0}, {1}..-1)", s, pos) else __elixir__("String.slice({0}, {1}, {2})", s, pos, elen);
		} == end;
	}

	public static function isSpace(s:String, pos:Int) {
		var c = {
			var result = __elixir__(":binary.at({0}, {1})", s, pos);
			__elixir__("if {0} == nil, do: nil, else: {0}", result);
		};
		return c > 8 && c < 14 || c == 32;
	}

	public static function ltrim(s:String) {
		var l = s.length;
		var r = 0;
		while ((r < l && StringTools.isSpace(s, r))) r ++;
		if ((r > 0)) return {
			var len = l - r;
			if ((len == null)) __elixir__("String.slice({0}, {1}..-1)", s, r) else __elixir__("String.slice({0}, {1}, {2})", s, r, len);
		} else return s;
	}

	public static function rtrim(s:String) {
		var l = s.length;
		var r = 0;
		while ((r < l && StringTools.isSpace(s, l - r - 1))) r ++;
		if ((r > 0)) return {
			var len = l - r;
			if ((len == null)) __elixir__("String.slice({0}, {1}..-1)", s, 0) else __elixir__("String.slice({0}, {1}, {2})", s, 0, len);
		} else return s;
	}

	public static inline function trim(s:String) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}

	public static function lpad(s:String, c:String, l:Int) {
		if ((c.length <= 0)) return s;
		var buf = "";
		while ((buf.length + s.length < l)) buf += c;
		return buf + s;
	}

	public static function rpad(s:String, c:String, l:Int) {
		if ((c.length <= 0)) return s;
		var buf = s;
		while ((buf.length < l)) buf += c;
		return buf;
	}

	public static function replace(s:String, sub:String, by:String) {
		return __elixir__("String.split({0}, {1})", s, sub).join(by);
	}

	public static function hex(n:Int, digits:Null<Int> = null) {
		var s = "";
		var hexChars = "0123456789ABCDEF";
		do ({
			s = __elixir__("String.at({0}, {1}) || \"\"", hexChars, n & 15) + s;
			n >>>= 4;
		}) while((n > 0));
		if ((digits != null)) while ((s.length < digits)) s = "0" + s;
		return s;
	}

	public static inline function fastCodeAt(s:String, index:Int) {
		return {
			var result = __elixir__(":binary.at({0}, {1})", s, index);
			__elixir__("if {0} == nil, do: nil, else: {0}", result);
		};
	}

	public static function contains(s:String, value:String) {
		return __elixir__("case :binary.match({0}, {1}) do\n                {pos, _} -> pos\n                nil -> -1\n            end", s, value) != -1;
	}

	public static inline function isEof(c:Int) {
		return c < 0;
	}

	public static function utf16CodePointAt(s:String, index:Int) {
		return {
			var result = __elixir__(":binary.at({0}, {1})", s, index);
			__elixir__("if {0} == nil, do: nil, else: {0}", result);
		};
	}

	public static inline function isHighSurrogate(code:Int) {
		return code >= 55296 && code <= 56319;
	}

	public static inline function isLowSurrogate(code:Int) {
		return code >= 56320 && code <= 57343;
	}

	public static function quoteRegexpMeta(s:String) {
		var specialChars = ["\\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]", "{", "}"];
		{
			var _g = 0;
			while ((_g < specialChars.length)) {
				var char = specialChars[_g];
				++ _g;
				s = StringTools.replace(s, char, "\\" + char);
			};
		};
		return s;
	}

	public static function parseInt(str:String) {
		if ((__elixir__("String.slice({0}, {1}, {2})", str, 0, 2) == "0x")) {
			var hex = {
				var len = null;
				if ((len == null)) __elixir__("String.slice({0}, {1}..-1)", str, 2) else __elixir__("String.slice({0}, {1}, {2})", str, 2, len);
			};
			var result = 0;
			{
				var _g = 0;
				var _g1 = hex.length;
				while ((_g < _g1)) {
					var i = _g ++;
					var c = {
						var result = __elixir__(":binary.at({0}, {1})", hex, i);
						__elixir__("if {0} == nil, do: nil, else: {0}", result);
					};
					result *= 16;
					if ((c >= 48 && c <= 57)) result += c - 48 else if ((c >= 65 && c <= 70)) result += c - 65 + 10 else if ((c >= 97 && c <= 102)) result += c - 97 + 10 else return null;
				};
			};
			return result;
		};
		var result = 0;
		var negative = false;
		var start = 0;
		if ((__elixir__("String.at({0}, {1}) || \"\"", str, 0) == "-")) {
			negative = true;
			start = 1;
		} else if ((__elixir__("String.at({0}, {1}) || \"\"", str, 0) == "+")) start = 1;
		{
			var _g = start;
			var _g1 = str.length;
			while ((_g < _g1)) {
				var i = _g ++;
				var c = {
					var result = __elixir__(":binary.at({0}, {1})", str, i);
					__elixir__("if {0} == nil, do: nil, else: {0}", result);
				};
				if ((c >= 48 && c <= 57)) result = result * 10 + (c - 48) else return null;
			};
		};
		return if ((negative)) - result else result;
	}

	public static function parseFloat(str:String) {
		return Std.parseFloat(str);
	}
}