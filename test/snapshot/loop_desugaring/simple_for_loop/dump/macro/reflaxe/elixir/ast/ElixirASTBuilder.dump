class reflaxe.elixir.ast.ElixirASTBuilder {

	@:value(null)
	public static var currentModule:String = null;

	@:value(false)
	public static var currentModuleHasPresence:Bool = false;

	@:value(0)
	public static var switchNestingLevel:Int = 0;

	@:value(null) @:allow(reflaxe.elixir.ElixirCompiler) @:allow(reflaxe.elixir.ast.builders.ModuleBuilder)
	public static var compiler:reflaxe.elixir.ElixirCompiler = null;

	@:value(null)
	public static var behaviorTransformer:reflaxe.elixir.behaviors.BehaviorTransformer = null;

	static function trackDependency(moduleName:String) {
		var builtins = ["Map", "Enum", "String", "Kernel", "List", "IO", "Process", "GenServer", "Supervisor", "Agent", "File", "Path", "System", "Code", "Module", "Application", "Integer", "Float", "Regex", "Date", "DateTime", "NaiveDateTime"];
		if (builtins.indexOf(moduleName, null) >= 0) {
			return;
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule != null) {
			var deps = {
				var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.moduleDependencies;
				var key = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule;
				cast this.get(key);
			};
			if (deps != null && moduleName != reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule) {
				{
					deps.set(moduleName, true);
				};
			};
		};
	}

	static function getVariableInitValue(varName:String, context:reflaxe.elixir.CompilationContext) {
		if (context.infrastructureVarInitValues != null && {
			var this = context.infrastructureVarInitValues;
			cast this.exists(varName);
		}) {
			return {
				var this = context.infrastructureVarInitValues;
				cast this.get(varName);
			};
		} else {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
			};
		};
	}

	static function replaceNullCoalVar(expr:haxe.macro.TypedExpr, varId:Int, initExpr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) if (v.id == varId):
		{ expr : TBinop(OpNullCoal, initExpr, defaultExpr), pos : expr.pos, t : expr.t };	
	case TVar(v, init) if (init != null):
		{ expr : TVar(v, replaceNullCoalVar(init, varId, initExpr)), pos : expr.pos, t : expr.t };	
	case TObjectDecl(fields):
		var newFields = [for (field  in  fields) { name : field.name, expr : replaceNullCoalVar(field.expr, varId, initExpr) }];
		{ expr : TObjectDecl(newFields), pos : expr.pos, t : expr.t };	
	case _:
		expr;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 24) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var defaultExpr = `;
									if (v.id == varId) {
										{expr : haxe.macro.TypedExprDef.TBinop(haxe.macro.Binop.OpNullCoal, initExpr, defaultExpr), pos : expr.pos, t : expr.t};
									} else {
										expr;
									};
								};
							} else {
								expr;
							};
						};
					} else {
						expr;
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							var newFields = {
								var ` = [];
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										`.push({name : field.name, expr : reflaxe.elixir.ast.ElixirASTBuilder.replaceNullCoalVar(field.expr, varId, initExpr)});
									};
								};
								`;
							};
							{expr : haxe.macro.TypedExprDef.TObjectDecl(newFields), pos : expr.pos, t : expr.t};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							{expr : haxe.macro.TypedExprDef.TVar(v, reflaxe.elixir.ast.ElixirASTBuilder.replaceNullCoalVar(init, varId, initExpr)), pos : expr.pos, t : expr.t};
						} else {
							expr;
						};
					};
				};
				default: {
					expr;
				}
			};
		};
	}

	@:value(null)
	static var currentContext:reflaxe.elixir.CompilationContext = null;

	public static function buildFromTypedExpr(expr:haxe.macro.TypedExpr, context:reflaxe.elixir.CompilationContext) {
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, context);
	}

	static function buildFromTypedExprHelper(expr:haxe.macro.TypedExpr, usageMapOrContext:Dynamic) {
		if (Std.isOfType(usageMapOrContext, reflaxe.elixir.CompilationContext)) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, cast usageMapOrContext);
		} else {
			if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null) {
				if (usageMapOrContext != null) {
					reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap = cast usageMapOrContext;
				};
				return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
			} else {
				var ctx = new reflaxe.elixir.CompilationContext();
				ctx.variableUsageMap = cast usageMapOrContext;
				return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, ctx);
			};
		};
	}

	static function buildFromTypedExprWithContext(expr:haxe.macro.TypedExpr, context:reflaxe.elixir.CompilationContext) {
		var previousContext = reflaxe.elixir.ast.ElixirASTBuilder.currentContext;
		reflaxe.elixir.ast.ElixirASTBuilder.currentContext = context;
		if (context.variableUsageMap != null) {} else {
			context.variableUsageMap = {
				{};
				new haxe.ds.IntMap();
			};
		};
		reflaxe.elixir.ast.ElixirASTBuilder.compiler = context.compiler;
		reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer = context.behaviorTransformer;
		reflaxe.elixir.ast.ElixirASTBuilder.currentModule = context.currentModule;
		reflaxe.elixir.ast.ElixirASTBuilder.currentModuleHasPresence = context.currentModuleHasPresence;
		var metadata = reflaxe.elixir.ast.ElixirASTBuilder.createMetadata(expr);
		var astDef = reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(expr);
		if (astDef == null) {
			reflaxe.elixir.ast.ElixirASTBuilder.currentContext = previousContext;
			return null;
		};
		@:ast(switch (expr.expr) {
	case TCall(e, _) if (e != null && isEnumConstructor(e) && hasIdiomaticMetadata(e)):
		metadata.requiresIdiomaticTransform = true;
		metadata.idiomaticEnumType = getEnumTypeName(e);	
	case TCall(_, _):
		switch (expr.t) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				if (enumType.meta.has(":elixirIdiomatic")) {
					metadata.requiresIdiomaticTransform = true;
					metadata.idiomaticEnumType = enumType.name;
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					if (e != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e) && reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
						metadata.requiresIdiomaticTransform = true;
						metadata.idiomaticEnumType = reflaxe.elixir.ast.ElixirASTBuilder.getEnumTypeName(e);
					} else {
						@:ast(switch (expr.t) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		if (enumType.meta.has(":elixirIdiomatic")) {
			metadata.requiresIdiomaticTransform = true;
			metadata.idiomaticEnumType = enumType.name;
		};	
	default:
}) {
							var ` = expr.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								var ` = `[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										if (enumType.meta.has(":elixirIdiomatic")) {
											metadata.requiresIdiomaticTransform = true;
											metadata.idiomaticEnumType = enumType.name;
										};
									};
								};
							} else {};
						};
					};
				};
			} else {};
		};
		var result = {def : astDef, metadata : metadata, pos : expr.pos};
		reflaxe.elixir.ast.ElixirASTBuilder.currentContext = previousContext;
		return result;
	}

	static function convertExpression(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(c):
		switch (c) {
			case TString(s):
				var isAtom = false;
				switch (expr.t) {
					case TAbstract(ref, _):
						var abstractType = ref.get();
						if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
							isAtom = true;
						};					
					case _:
				};
				if (isAtom) {
					EAtom(s);
				} else {
					EString(s);
				};			
			case TThis:
				if (currentContext.isInClassMethodContext && currentContext.currentReceiverParamName != null) {
					EVar(currentContext.currentReceiverParamName);
				} else {
					EVar("self");
				};			
			default:
				var ast = CoreExprBuilder.buildConst(c);
				ast.def;			
		};	
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			EVar(mappedName);
		} else if (currentContext.currentClauseContext != null) {
			var mappedName = currentContext.currentClauseContext.lookupVariable(v.id);
			if (mappedName != null) {
				EVar(mappedName);
			} else {
				var ast = CoreExprBuilder.buildLocal(v);
				ast.def;
			};
		} else {
			var ast = CoreExprBuilder.buildLocal(v);
			ast.def;
		};	
	case TVar(v, init):
		if (init != null) {
			switch (init.expr) {
				case TBlock(blockStmts) if (blockStmts.length >= 3):
					var mapLiteral = tryBuildMapLiteralFromBlock(blockStmts, currentContext);
					if (mapLiteral != null) {
						return EMatch(PVar(toElixirVarName(v.name)), mapLiteral);
					};
					var isConditionalComp = false;
					var tempVarName = "";
					switch (blockStmts[0].expr) {
						case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
							switch (tempInit.expr) {
								case TArrayDecl([]):
									tempVarName = tempVar.name;
									if (blockStmts.length >= 3) {
										switch (blockStmts[1].expr) {
											case TBlock(ifStmts):
												var allIfs = true;
												for (stmt  in  ifStmts) {
													switch (stmt.expr) {
														case TIf(_, _, null):
															continue;														
														default:
															allIfs = false;
															break;														
													};
												};
												if (allIfs && blockStmts.length > 2) {
													switch (blockStmts[blockStmts.length - 1].expr) {
														case TLocal(retVar) if (retVar.name == tempVarName):
															isConditionalComp = true;														
														default:
													};
												};											
											default:
										};
									};								
								default:
							};						
						default:
					};
					if (isConditionalComp) {
						var reconstructed = tryReconstructConditionalComprehension(blockStmts, tempVarName, currentContext.variableUsageMap);
						if (reconstructed != null) {
							return EMatch(PVar(toElixirVarName(v.name)), reconstructed);
						};
					};				
				default:
			};
		};
		var isEnumExtraction = false;
		var extractedFromTemp = "";
		var shouldSkipRedundantExtraction = false;
		var varOrigin:VarOrigin = UserDefined;
		var tempToBinderMap:Map<Int,Int> = null;
		if (init != null) {
			switch (init.expr) {
				case TEnumParameter(e, _, index):
					isEnumExtraction = true;
					varOrigin = ExtractionTemp;
					var tempVarName = toElixirVarName(v.name);
					if (currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
						currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : tempVarName }]);
					};
					if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
						var plan = currentContext.currentClauseContext.enumBindingPlan;
						if (plan.exists(index)) {
							shouldSkipRedundantExtraction = true;
							return null;
						};
					};
					if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
						shouldSkipRedundantExtraction = true;
					};				
				case TLocal(tempVar):
					if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)) {
						extractedFromTemp = tempVar.name;
						varOrigin = PatternBinder;
						if (currentContext.currentClauseContext != null) {
							var userVarName = toElixirVarName(v.name);
							currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : userVarName }]);
						};
						if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
							return null;
						};
						if (tempToBinderMap == null) {
							tempToBinderMap = new Map<Int,Int>();
						};
						tempToBinderMap.set(tempVar.id, v.id);
					} else {
						varOrigin = UserDefined;
					};				
				case TSwitch(switchExpr, cases, edef):
					varOrigin = UserDefined;				
				case _:
					varOrigin = UserDefined;				
			};
		};
		var varName = v.name;
		var idKey = Std.string(v.id);
		var isUnused = false;
		var baseName = if (currentContext.tempVarRenameMap.exists(idKey)) {
			currentContext.tempVarRenameMap.get(idKey);
		} else {
			var isUsed = if (currentContext.variableUsageMap != null) {
				currentContext.variableUsageMap.exists(v.id) && currentContext.variableUsageMap.get(v.id);
			} else {
				true;
			};
			if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
				toElixirVarName(varName, false);
			} else {
				toElixirVarName(varName, false);
			};
		};
		var isActuallyUsed = if (currentContext.variableUsageMap != null && currentContext.variableUsageMap.exists(v.id)) {
			currentContext.variableUsageMap.get(v.id);
		} else {
			true;
		};
		var isEnumParameterExtraction = false;
		if (init != null) {
			switch (init.expr) {
				case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d*$/.match(tempVar.name)):
					isEnumParameterExtraction = true;				
				case _:
			};
		};
		var finalVarName = if (!isActuallyUsed && !isEnumParameterExtraction) {
			var underscoreName = "_" + baseName;
			currentContext.tempVarRenameMap.set(Std.string(v.id), underscoreName);
			underscoreName;
		} else {
			currentContext.tempVarRenameMap.set(Std.string(v.id), baseName);
			baseName;
		};
		var matchNode = if (init != null) {
			var initValue = switch (init.expr) {
				case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var initAst = buildFromTypedExpr(tmpInit, currentContext);
					var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					ifExpr;				
				case _:
					var initExpr = switch (init.expr) {
						case TBlock(stmts) if (stmts.length > 2):
							var isUnrolled = false;
							var tempVarName = "";
							var values = [];
							if (stmts.length > 0) {
								switch (stmts[0].expr) {
									case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
										switch (initExpr.expr) {
											case TArrayDecl([]):
												isUnrolled = true;
												tempVarName = v.name;											
											default:
										};									
									default:
								};
							};
							if (isUnrolled && stmts.length > 1) {
								var concatStatements = [];
								switch (stmts[1].expr) {
									case TBlock(innerStmts):
										concatStatements = innerStmts;									
									default:
										concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];									
								};
								for (stmt  in  concatStatements) {
									switch (stmt.expr) {
										case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
											values.push(elem);										
										case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
											values.push(arg);										
										default:
									};
								};
								if (values.length == 0) {
									isUnrolled = false;
								};
							};
							if (isUnrolled && stmts.length > 0) {
								switch (stmts[stmts.length - 1].expr) {
									case TLocal(v) if (v.name == tempVarName):
									default:
										isUnrolled = false;									
								};
							};
							if (isUnrolled && values.length > 0) {
								var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
								makeAST(EList(valueASTs));
							} else {
								buildFromTypedExpr(init, currentContext);
							};						
						case TSwitch(_, _, _):
							var switchAST = buildFromTypedExpr(init, currentContext);
							switchAST;						
						default:
							buildFromTypedExpr(init, currentContext);						
					};
					initExpr;				
			};
			var shouldSkipAssignment = false;
			if (init != null && currentContext.currentClauseContext != null && currentContext.currentClauseContext.isVarIdSatisfiedByPattern(v.id)) {
				shouldSkipAssignment = true;
			} else if (init != null) {
				switch (init.expr) {
					case TEnumParameter(e, ef, index):
						if (currentContext.currentClauseContext != null) {
							var hasPlan = currentContext.currentClauseContext.enumBindingPlan.exists(index);
							if (hasPlan) {
								var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
								if (info.finalName == finalVarName) {
									shouldSkipAssignment = true;
								} else { };
								if (!shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
									var planIsTemp = isTempPatternVarName(info.finalName);
									var lhsIsTemp = isTempPatternVarName(finalVarName);
									if (lhsIsTemp && !planIsTemp) {
										shouldSkipAssignment = true;
									};
								};
							};
						};
						if (!shouldSkipAssignment && initValue != null) {
							switch (initValue.def) {
								case EVar(varName):
									if (varName == finalVarName) {
										shouldSkipAssignment = true;
									};								
								case _:
							};
						} else if (!shouldSkipAssignment) {
							shouldSkipAssignment = true;
						};					
					default:
				};
				if (!shouldSkipAssignment && init != null) {
					switch (init.expr) {
						case TLocal(tempVar):
							var tempVarName = tempVar.name;
							var isTempVar = false;
							if (tempVarName == "g" || tempVarName == "_g") {
								isTempVar = true;
							} else if (tempVarName.length > 1) {
								if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
									isTempVar = true;
								} else if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
									isTempVar = true;
								};
							};
							if (isTempVar) {
								var elixirTempName = toElixirVarName(tempVarName);
								if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
									shouldSkipAssignment = true;
								};
								if (finalVarName == tempVarName) {
									shouldSkipAssignment = true;
								};
							} else {
								if (finalVarName == tempVarName) {
									shouldSkipAssignment = true;
								};
							};						
						case _:
					};
				};
			};
			var result = if (shouldSkipAssignment) {
				null;
			} else if (initValue == null) {
				if (extractedFromTemp != null) { };
				null;
			} else {
				var shouldSkipSelfAssignment = false;
				switch (initValue.def) {
					case EVar(varName):
						if (varName == finalVarName) {
							shouldSkipSelfAssignment = true;
						};					
					case _:
				};
				if (shouldSkipSelfAssignment) {
					null;
				} else {
					var matchNode = makeAST(EMatch(PVar(finalVarName), initValue));
					if (matchNode.metadata == null) matchNode.metadata = { };
					matchNode.metadata.varOrigin = varOrigin;
					matchNode.metadata.varId = v.id;
					if (tempToBinderMap != null) {
						matchNode.metadata.tempToBinderMap = tempToBinderMap;
					};
					matchNode;
				};
			};
			result;
		} else {
			makeAST(EMatch(PVar(finalVarName), makeAST(ENil)));
		};
		if (matchNode != null) {
			matchNode.def;
		} else {
			EMatch(PVar(finalVarName), makeAST(ENil));
		};	
	case TBinop(op, e1, e2):
		var result = switch (op) {
			case OpAssign:
				var pattern = extractPattern(e1);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var shouldSkipAssign = false;
				switch (pattern) {
					case PVar(name):
						var valueName = switch (rightAST != null ? rightAST.def : null) {
							case EVar(varName):
								varName;							
							default:
								null;							
						};
						if (isTempPatternVarName(name)) {
							shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
								case EVar(varName) if (varName == name || isTempPatternVarName(varName)):
									true;								
								default:
									false;								
							};
						} else if (valueName != null) {
							if (valueName == name) {
								shouldSkipAssign = true;
							} else if (isTempPatternVarName(valueName)) {
								shouldSkipAssign = true;
							};
						};					
					default:
				};
				if (shouldSkipAssign) {
					null;
				} else {
					EMatch(pattern, rightAST);
				};			
			case OpAssignOp(innerOp):
				var pattern = extractPattern(e1);
				var leftAST = buildFromTypedExpr(e1, currentContext);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var innerBinop = BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s) return toSnakeCase(s));
				EMatch(pattern, innerBinop);			
			default:
				var leftAST = buildFromTypedExpr(e1, currentContext);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var ast = BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s) return toSnakeCase(s));
				ast.def;			
		};
		result;	
	case TUnop(op, postFix, e):
		switch (op) {
			case OpNot:
				switch (e.expr) {
					case TBlock([]):
						EUnary(Not, makeAST(ENil));					
					case TBlock(exprs) if (exprs.length == 1):
						EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));					
					case TBlock(exprs):
						var statements = [];
						for (i  in  0 ... exprs.length - 1) {
							statements.push(buildFromTypedExpr(exprs[i], currentContext));
						};
						var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
						statements.push(makeAST(EUnary(Not, lastExpr)));
						EBlock(statements);					
					default:
						var expr = buildFromTypedExpr(e, currentContext).def;
						EUnary(Not, makeAST(expr));					
				};			
			case OpNeg:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(Negate, makeAST(expr));			
			case OpNegBits:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(BitwiseNot, makeAST(expr));			
			case OpIncrement, OpDecrement:
				var one = makeAST(EInteger(1));
				var builtExpr = buildFromTypedExpr(e, currentContext);
				var operation = if (op == OpIncrement) {
					makeAST(EBinary(Add, builtExpr, one));
				} else {
					makeAST(EBinary(Subtract, builtExpr, one));
				};
				switch (e.expr) {
					case TLocal(v):
						EBinary(Match, builtExpr, operation);					
					default:
						operation.def;					
				};			
			case OpSpread:
				var builtExpr = buildFromTypedExpr(e, currentContext);
				EUnquoteSplicing(builtExpr);			
		};	
	case TCall(e, el):
		var presenceHandled = false;
		if (e != null && isEnumConstructor(e)) {
			var tag = extractEnumTag(e);
			if (hasIdiomaticMetadata(e)) {
				tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
			};
			var args = [for (arg  in  el) buildFromTypedExpr(arg, currentContext)];
			var tupleDef = ETuple([makeAST(EAtom(tag))].concat(args));
			tupleDef;
		} else {
			var args = [];
			for (arg  in  el) {
				var isFunctionRef = false;
				switch (arg.expr) {
					case TField(_, FStatic(classRef, cf)):
						switch (cf.get().type) {
							case TFun(funcArgs, _):
								isFunctionRef = true;
								var target = buildFromTypedExpr(arg, currentContext);
								switch (target.def) {
									case EField(module, funcName):
										var arity = funcArgs.length;
										args.push(makeAST(ECapture(target, arity)));									
									default:
										args.push(target);									
								};							
							default:
								var field = cf.get();
								var isAtomField = false;
								var classType = classRef.get();
								switch (classType.kind) {
									case KAbstractImpl(abstractRef):
										var abstractType = abstractRef.get();
										switch (abstractType.type) {
											case TAbstract(underlyingRef, _):
												var underlyingType = underlyingRef.get();
												if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
													isAtomField = true;
												};											
											case _:
										};									
									case _:
								};
								if (isAtomField && field.expr() != null) {
									switch (field.expr().expr) {
										case TConst(TString(s)):
											args.push(makeAST(EAtom(s)));										
										case _:
											args.push(buildFromTypedExpr(arg, currentContext));										
									};
								} else {
									args.push(buildFromTypedExpr(arg, currentContext));
								};							
						};					
					default:
						var isAtomType = false;
						switch (arg.t) {
							case TAbstract(abstractRef, _):
								var abstractType = abstractRef.get();
								if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
									isAtomType = true;
								};							
							case _:
						};
						if (isAtomType) {
							switch (arg.expr) {
								case TConst(TString(s)):
									args.push(makeAST(EAtom(s)));								
								case TField(_, FStatic(classRef, cf)):
									var field = cf.get();
									if (field.expr() != null) {
										switch (field.expr().expr) {
											case TConst(TString(s)):
												args.push(makeAST(EAtom(s)));											
											default:
												args.push(buildFromTypedExpr(arg, currentContext));											
										};
									} else {
										args.push(buildFromTypedExpr(arg, currentContext));
									};								
								default:
									var builtArg = buildFromTypedExpr(arg, currentContext);
									switch (builtArg.def) {
										case EString(s):
											args.push(makeAST(EAtom(s)));										
										default:
											args.push(builtArg);										
									};								
							};
						} else {
							args.push(buildFromTypedExpr(arg, currentContext));
						};					
				};
			};
			if (e != null) {
				switch (e.expr) {
					case TField(_, FStatic(classRef, cf)):
						var classType = classRef.get();
						var field = cf.get();
						var methodName = field.name;
						if (field.meta.has(":native")) {
							var nativeMeta = field.meta.extract(":native");
							if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
								switch (nativeMeta[0].params[0].expr) {
									case EConst(CString(s, _)):
										methodName = s;									
									default:
								};
							};
						};
						var isSameModuleCall = false;
						if (currentContext.currentModule != null && classType.name == currentContext.currentModule) {
							if (classType.isExtern) {
								isSameModuleCall = false;
							} else if (currentContext.currentModuleHasPresence && currentContext.behaviorTransformer != null) {
								isSameModuleCall = false;
							} else {
								isSameModuleCall = true;
							};
						};
						if (isSameModuleCall) {
							var elixirMethodName = toSnakeCase(methodName);
							return ECall(null, elixirMethodName, args);
						};
						if (currentContext.behaviorTransformer != null && currentContext.currentModuleHasPresence) {
							var transformedCall = currentContext.behaviorTransformer.transformMethodCall(classType.name, methodName, args, true);
							if (transformedCall != null) {
								return transformedCall.def;
							};
						} else if (classType.name == "Reflect") {
							switch (methodName) {
								case "hasField":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										trackDependency("Map");
										return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
									};								
								case "field":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										trackDependency("Map");
										return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
									};								
								case "setField":
									if (args.length == 3) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var value = args[2];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
									};								
								case "fields":
									if (args.length == 1) {
										return ERemoteCall(makeAST(EVar("Map")), "keys", args);
									};								
								case "isObject":
									if (args.length == 1) {
										return ECall(null, "is_map", args);
									};								
								case "deleteField":
									if (args.length == 2) {
										var obj = args[0];
										var fieldNameExpr = args[1];
										var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
										return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
									};								
								case "copy":
									if (args.length == 1) {
										return args[0].def;
									};								
								case "compare":
									if (args.length == 2) {
										var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
										var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
										var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
										var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
										var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
										return ECond([ltClause, gtClause, trueClause]);
									};								
								case "isEnumValue":
									if (args.length == 1) {
										var isTuple = ECall(null, "is_tuple", args);
										var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
										var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
										return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
									};								
								case "callMethod":
									if (args.length == 3) {
										return ECall(null, "apply", [args[1], args[2]]);
									};								
								default:
							};
						} else if (classType.meta.has(":native")) {
							var nativeModuleName = "";
							var nativeMeta = classType.meta.extract(":native");
							if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
								switch (nativeMeta[0].params[0].expr) {
									case EConst(CString(s, _)):
										nativeModuleName = s;									
									default:
								};
							};
							if (nativeModuleName != "") {
								if (classType.name == "Presence" && nativeModuleName == "Phoenix.Presence") {
									presenceHandled = true;
								};
								var elixirMethodName = toSnakeCase(methodName);
								trackDependency(nativeModuleName);
								return ERemoteCall(makeAST(EVar(nativeModuleName)), elixirMethodName, args);
							};
						} else {
							var moduleName = classType.name;
							trackDependency(moduleName);
							if (currentContext.compiler != null && classType.pack.length > 0) {
								currentContext.compiler.modulePackages.set(moduleName, classType.pack);
							};
						};					
					default:
				};
			};
			var target = if (presenceHandled) {
				null;
			} else {
				e != null ? buildFromTypedExpr(e, currentContext) : null;
			};
			switch (e.expr) {
				case TIdent("__elixir__"):
					if (args.length > 0) {
						switch (args[0].def) {
							case EString(code):
								var processedCode = code;
								if (args.length > 1) {
									for (i  in  1 ... args.length) {
										var paramStr = ElixirASTPrinter.printAST(args[i]);
										var placeholder = "{${i-1}}";
										processedCode = StringTools.replace(processedCode, placeholder, paramStr);
									};
								};
								ERaw(processedCode);							
							default:
								ECall(target, "call", args);							
						};
					} else {
						ECall(target, "call", args);
					};				
				case TField(obj, fa):
					var fieldName = extractFieldName(fa);
					fieldName = toSnakeCase(fieldName);
					var objAst = switch (obj.expr) {
						case TLocal(v):
							var varName = v.name;
							if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
								var mappedName = currentContext.currentClauseContext.localToName.get(v.id);
								makeAST(EVar(mappedName));
							} else {
								buildFromTypedExpr(obj, currentContext);
							};						
						default:
							buildFromTypedExpr(obj, currentContext);						
					};
					var typeModule = getExternNativeModuleNameFromType(obj.t);
					if (typeModule != null) {
						trackDependency(typeModule);
						return ERemoteCall(makeAST(EVar(typeModule)), fieldName, [objAst].concat(args));
					};
					switch (fa) {
						case FInstance(cRef, _, cfRef):
							var cls = cRef.get();
							if (cls.isExtern && cls.meta.has(":native")) {
								var nativeMeta = cls.meta.extract(":native");
								var moduleName:Null<String> = null;
								if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
									switch (nativeMeta[0].params[0].expr) {
										case EConst(CString(s, _)):
											moduleName = s;										
										default:
									};
								};
								if (moduleName != null) {
									var methodName = fieldName;
									var cf = cfRef.get();
									if (cf.meta.has(":native")) {
										var mMeta = cf.meta.extract(":native");
										if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
											switch (mMeta[0].params[0].expr) {
												case EConst(CString(ns, _)):
													methodName = toSnakeCase(ns);												
												default:
											};
										};
									};
									trackDependency(moduleName);
									return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
								};
							};						
						default:
					};
					if (fieldName == "elem" && args.length == 1) {
						return ECall(null, "elem", [objAst, args[0]]);
					};
					if (isAssertClass(obj)) {
						var assertFunc = switch (fieldName) {
							case "equals":
								"assert";							
							case "notEquals":
								"refute";							
							case "isTrue":
								"assert";							
							case "isFalse":
								"refute";							
							case "isNull":
								"assert";							
							case "isNotNull":
								"refute";							
							case "fail":
								"flunk";							
							default:
								"assert";							
						};
						var assertArgs = switch (fieldName) {
							case "equals" if (args.length >= 2):
								[makeAST(EBinary(Equal, args[0], args[1]))];							
							case "notEquals" if (args.length >= 2):
								[makeAST(EBinary(Equal, args[0], args[1]))];							
							case "isNull" if (args.length >= 1):
								[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];							
							case "isNotNull" if (args.length >= 1):
								[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];							
							default:
								args;							
						};
						return ECall(null, assertFunc, assertArgs);
					} else if (fieldName == "hxx" && isHXXModule(obj)) {
						if (args.length == 1) {
							var templateContent = collectTemplateContent(args[0]);
							ESigil("H", templateContent, "");
						} else {
							ECall(objAst, fieldName, args);
						};
					} else if (isModuleCall(obj)) {
						var hasNativeMetadata = false;
						var nativeName:String = null;
						switch (fa) {
							case FStatic(_, cf):
								var classField = cf.get();
								if (classField.meta.has(":native")) {
									var nativeMeta = classField.meta.extract(":native");
									if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
										switch (nativeMeta[0].params[0].expr) {
											case EConst(CString(s, _)):
												hasNativeMetadata = true;
												nativeName = s;											
											default:
										};
									};
								};							
							default:
						};
						if (hasNativeMetadata && nativeName != null) {
							var parts = nativeName.split(".");
							if (parts.length > 1) {
								var module = parts.slice(0, parts.length - 1).join(".");
								var funcName = parts[parts.length - 1];
								trackDependency(module);
								return ERemoteCall(makeAST(EVar(module)), funcName, args);
							} else {
								return ERemoteCall(objAst, nativeName, args);
							};
						} else {
							var elixirFuncName = toSnakeCase(fieldName);
							return ERemoteCall(objAst, elixirFuncName, args);
						};
					} else {
						var methodHasElixirInjection = false;
						var expandedElixir:ElixirAST = null;
						switch (fa) {
							case FInstance(_, _, cf):
								var classField = cf.get();
								var methodExpr = classField.expr();
								if (methodExpr != null) {
									expandedElixir = tryExpandElixirInjection(methodExpr, obj, el, currentContext);
									methodHasElixirInjection = (expandedElixir != null);
								};							
							default:
						};
						if (methodHasElixirInjection && expandedElixir != null) {
							return expandedElixir.def;
						} else if (isArrayType(obj.t)) {
							switch (fieldName) {
								case "filter" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);								
								case "map" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);								
								case "push" if (args.length == 1):
									var concat = makeAST(EBinary(Concat, objAst, makeAST(EList([args[0]]))));
									switch (objAst.def) {
										case EVar(name):
											EBinary(Match, objAst, concat);										
										default:
											concat.def;										
									};								
								default:
									ECall(objAst, fieldName, args);								
							};
						} else if (isMapType(obj.t)) {
							switch (fieldName) {
								case "set" if (args.length == 2):
									var callAst = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args)));
									switch (objAst.def) {
										case EVar(_):
											EBinary(Match, objAst, callAst);										
										default:
											callAst.def;										
									};								
								case "get" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));								
								case "remove" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));								
								case "exists" if (args.length == 1):
									ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));								
								case "keys" if (args.length == 0):
									ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);								
								case "values" if (args.length == 0):
									ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);								
								default:
									ECall(objAst, fieldName, args);								
							};
						} else {
							ECall(objAst, fieldName, args);
						};
					};				
				case TLocal(v):
					var isFunctionVar = switch (v.t) {
						case TFun(_, _):
							true;						
						case TAbstract(t, params):
							var abs = t.get();
							if (abs.name == "Function" || abs.name == "Fn") {
								true;
							} else if (abs.name == "Null" && params.length == 1) {
								switch (params[0]) {
									case TFun(_, _):
										true;									
									default:
										false;									
								};
							} else {
								false;
							};						
						default:
							false;						
					};
					if (isFunctionVar) {
						ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
					} else {
						ECall(null, toElixirVarName(v.name), args);
					};				
				default:
					if (target != null) {
						switch (target.def) {
							case EField(module, funcName):
								ERemoteCall(module, funcName, args);							
							default:
								ECall(target, "call", args);							
						};
					} else {
						ECall(null, "unknown_call", args);
					};				
			};
		};	
	case TField(e, fa):
		switch (fa) {
			case FEnum(enumType, ef):
				var enumT = enumType.get();
				if (enumT.meta.has(":elixirIdiomatic")) {
					var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
					EAtom(atomName);
				} else {
					var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
					ETuple([makeAST(EAtom(atomName))]);
				};			
			case FStatic(classRef, cf):
				var className = classRef.get().name;
				var fieldName = extractFieldName(fa);
				var field = cf.get();
				var isAtomField = false;
				switch (field.type) {
					case TAbstract(abstractRef, _):
						var abstractType = abstractRef.get();
						if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
							isAtomField = true;
						};					
					case _:
				};
				if (!isAtomField) {
					var classType = classRef.get();
					switch (classType.kind) {
						case KAbstractImpl(abstractRef):
							var abstractType = abstractRef.get();
							switch (abstractType.type) {
								case TAbstract(underlyingRef, _):
									var underlyingType = underlyingRef.get();
									if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
										isAtomField = true;
									};								
								case _:
							};						
						case _:
					};
				};
				if (isAtomField && field.expr() != null) {
					switch (field.expr().expr) {
						case TConst(TString(s)):
							EAtom(s);						
						case _:
							fieldName = toSnakeCase(fieldName);
							var target = buildFromTypedExpr(e, currentContext);
							EField(target, fieldName);						
					};
				} else {
					fieldName = toSnakeCase(fieldName);
					if (false) {
						EVar(fieldName);
					} else {
						var target = buildFromTypedExpr(e, currentContext);
						EField(target, fieldName);
					};
				};			
			case FAnon(cf):
				var fieldName = cf.get().name;
				var target = buildFromTypedExpr(e, currentContext);
				if (~/^_\d+$/.match(fieldName)) {
					var index = Std.parseInt(fieldName.substr(1)) - 1;
					ECall(null, "elem", [target, makeAST(EInteger(index))]);
				} else {
					fieldName = toSnakeCase(fieldName);
					EField(target, fieldName);
				};			
			default:
				var target = buildFromTypedExpr(e, currentContext);
				var fieldName = extractFieldName(fa);
				var originalFieldName = fieldName;
				fieldName = toSnakeCase(fieldName);
				if (fieldName == "elem") {
					EField(target, fieldName);
				} else if (isMapAccess(e.t)) {
					EAccess(target, makeAST(EAtom(fieldName)));
				} else {
					EField(target, fieldName);
				};			
		};	
	case TArrayDecl(el):
		if (el.length == 1 && el[0].expr.match(TFor(_))) {
			buildFromTypedExpr(el[0], currentContext).def;
		} else if (el.length == 1) {
			switch (el[0].expr) {
				case TBlock(stmts):
					var comprehension = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
					if (comprehension != null) {
						switch (comprehension.def) {
							case EFor(_, _, _, _, _):
								comprehension.def;							
							default:
								EList([buildFromTypedExpr(el[0], currentContext)]);							
						};
					} else {
						EList([buildFromTypedExpr(el[0], currentContext)]);
					};				
				default:
					EList([buildFromTypedExpr(el[0], currentContext)]);				
			};
		} else {
			var hasIdiomaticEnums = false;
			for (e  in  el) {
				switch (e.expr) {
					case TCall(callTarget, _) if (callTarget != null && isEnumConstructor(callTarget) && hasIdiomaticMetadata(callTarget)):
						hasIdiomaticEnums = true;
						break;					
					case TCall(_, _):
						switch (e.t) {
							case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
								hasIdiomaticEnums = true;
								break;							
							default:
						};					
					default:
				};
			};
			var elements = [];
			for (e  in  el) {
				switch (e.expr) {
					case TBlock(stmts):
						var comprehension = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
						if (comprehension != null) {
							elements.push(comprehension);
						} else if (looksLikeListBuildingBlock(stmts)) {
							var extractedElements = extractListElements(stmts);
							if (extractedElements != null && extractedElements.length > 0) {
								var valueASTs = [for (elem  in  extractedElements) buildFromTypedExpr(elem, currentContext)];
								elements.push(makeAST(EList(valueASTs)));
							} else {
								var blockStmts = [for (s  in  stmts) buildFromTypedExpr(s, currentContext)];
								var blockAST = makeAST(EBlock(blockStmts));
								if (blockAST.metadata == null) blockAST.metadata = { };
								blockAST.metadata.isUnrolledComprehension = true;
								var fnClause:EFnClause = { args : [], guard : null, body : blockAST };
								var anonymousFn = makeAST(EFn([fnClause]));
								var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
								elements.push(wrappedBlock);
							};
						} else {
							var blockAst = buildFromTypedExpr(e, currentContext);
							var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
							var anonymousFn = makeAST(EFn([fnClause]));
							var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
							elements.push(wrappedBlock);
						};					
					default:
						elements.push(buildFromTypedExpr(e, currentContext));					
				};
			};
			EList(elements);
		};	
	case TArray(e, index):
		var target = buildFromTypedExpr(e, currentContext);
		var key = buildFromTypedExpr(index, currentContext);
		EAccess(target, key);	
	case TIf(econd, eif, eelse):
		var condition = switch (econd.expr) {
			case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
				makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, currentContext), function(name) return toElixirVarName(name)));			
			case _:
				buildFromTypedExpr(econd, currentContext);			
		};
		var thenBranch = buildFromTypedExpr(eif, currentContext);
		var elseBranch = eelse != null ? buildFromTypedExpr(eelse, currentContext) : null;
		EIf(condition, thenBranch, elseBranch);	
	case TBlock(el):
		for (expr  in  el) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					if (v.name == "g" || v.name.startsWith("_g") || v.name.indexOf("g") >= 0) {
						var initAST = buildFromTypedExpr(init, currentContext);
						currentContext.infrastructureVarInitValues.set(v.name, initAST);
					};				
				case _:
			};
		};
		var comprehension = tryBuildArrayComprehensionFromBlock(el, currentContext.variableUsageMap);
		if (comprehension != null) {
			comprehension.def;
		};
		if (el.length >= 5) {
			var hasEmptyArray = false;
			var hasZeroInit = false;
			var hasSourceAssign = false;
			var hasWhileLoop = false;
			var returnsResult = false;
			var sourceArray:TypedExpr = null;
			var whileBody:TypedExpr = null;
			var resultVarName:String = null;
			for (i  in  0 ... el.length) {
				switch (el[i].expr) {
					case TVar(v, init) if (init != null && v.name.startsWith("_g")):
						switch (init.expr) {
							case TArrayDecl([]):
								hasEmptyArray = true;
								resultVarName = v.name;							
							case TConst(TInt(i)) if (i == 0):
								hasZeroInit = true;							
							case TLocal(_):
								hasSourceAssign = true;
								sourceArray = init;							
							case _:
						};					
					case TWhile(_, body, _):
						hasWhileLoop = true;
						whileBody = body;					
					case TLocal(v) if (v.name == resultVarName && i == el.length - 1):
						returnsResult = true;					
					case _:
				};
			};
			var isArrayPattern = hasEmptyArray && hasZeroInit && hasSourceAssign && hasWhileLoop && returnsResult;
			if (isArrayPattern && sourceArray != null && whileBody != null) {
				var operation = ElixirASTPatterns.detectArrayOperationPattern(whileBody);
				if (operation != null) {
					return generateIdiomaticEnumCall(sourceArray, operation, whileBody);
				};
			};
		};
		if (el.length == 2) {
			switch ([el[0].expr, el[1].expr]) {
				case [TVar(tmpVar, init), TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr)] if (v.id == tmpVar.id && init != null):
					var initAst = buildFromTypedExpr(init, currentContext);
					var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					return ifExpr.def;				
				case _:
			};
		};
		if (ElixirASTPatterns.isInlineExpansionBlock(el)) {
			return ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, currentContext), function(name) return toElixirVarName(name));
		};
		if (el.length >= 2) {
			var isConditionalComprehension = false;
			var tempVarName = "";
			switch (el[0].expr) {
				case TVar(v, init) if (init != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (init.expr) {
						case TArrayDecl([]):
							tempVarName = v.name;
							if (el.length >= 3) {
								switch (el[1].expr) {
									case TBlock(innerStmts):
										var allIfs = true;
										for (stmt  in  innerStmts) {
											switch (stmt.expr) {
												case TIf(_, thenExpr, null):
													switch (thenExpr.expr) {
														case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
															switch (rhs.expr) {
																case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
																default:
																	allIfs = false;																
															};														
														default:
															allIfs = false;														
													};												
												default:
													allIfs = false;												
											};
										};
										if (allIfs && el.length > 2) {
											switch (el[el.length - 1].expr) {
												case TLocal(v) if (v.name == tempVarName):
													isConditionalComprehension = true;												
												default:
											};
										};									
									default:
								};
							};						
						default:
					};				
				default:
			};
			if (isConditionalComprehension) {
				var reconstructed = tryReconstructConditionalComprehension(el, tempVarName, currentContext.variableUsageMap);
				if (reconstructed != null) {
					return reconstructed.def;
				};
			};
		};
		if (looksLikeListBuildingBlock(el)) {
			var listElements = extractListElements(el);
			if (listElements != null && listElements.length > 0) {
				var blockStmts = [for (e  in  el) buildFromTypedExpr(e, currentContext)];
				var blockAST = makeAST(EBlock(blockStmts));
				if (blockAST.metadata == null) blockAST.metadata = { };
				blockAST.metadata.isUnrolledComprehension = true;
				blockAST.metadata.comprehensionElements = listElements.length;
				return blockAST.def;
			};
		} else { };
		var isInLoopContext = false;
		if (el.length == 2 && !isInLoopContext) {
			switch ([el[0].expr, el[1].expr]) {
				case [TVar(v, init), expr] if (init != null):
					var isUsed = if (currentContext.variableUsageMap != null && currentContext.variableUsageMap.exists(v.id)) {
						currentContext.variableUsageMap.get(v.id);
					} else {
						true;
					};
					var baseName = toElixirVarName(v.name);
					var varName = if (!isUsed) {
						baseName;
					} else {
						baseName;
					};
					var initExpr = buildFromTypedExpr(init, currentContext);
					var bodyExpr = buildFromTypedExpr(el[1], currentContext);
					var isInCaseClause = currentContext.currentClauseContext != null;
					var containsNestedIf = containsIfStatement(el[1]);
					var shouldPreserveDeclaration = isInCaseClause || containsNestedIf;
					if (!shouldPreserveDeclaration) {
						var usageCount = countVarOccurrencesInAST(bodyExpr, varName);
						if (usageCount == 1) {
							var inlined = replaceVarInAST(bodyExpr, varName, initExpr);
							return inlined.def;
						};
					};
					return EBlock([makeAST(EMatch(PVar(varName), initExpr)), bodyExpr]);				
				default:
			};
		};
		var expressions = [];
		var isInCaseClause = currentContext.currentClauseContext != null;
		for (e  in  el) {
			var shouldSkip = false;
			if (!isInCaseClause) {
				switch (e.expr) {
					case TVar(v, init) if (init != null):
						switch (init.expr) {
							case TEnumParameter(_, _, _):
								var originalName = v.name;
								var tempVarName = toElixirVarName(v.name);
								if (originalName == "_g" || originalName == "g" || (originalName.startsWith("_g") && originalName.length > 2) || (originalName.startsWith("g") && originalName.length > 1 && originalName.charAt(1) >= "0" && originalName.charAt(1) <= "9")) {
									shouldSkip = true;
								} else { };							
							case _:
						};					
					case TBinop(OpAssign, { expr : TLocal(lhs) }, { expr : TLocal(rhs) }):
						var lhsName = toElixirVarName(lhs.name);
						var rhsName = toElixirVarName(rhs.name);
						if (isTempPatternVarName(lhsName) || lhsName == rhsName || isTempPatternVarName(rhsName)) {
							shouldSkip = true;
						};					
					case _:
				};
			};
			if (!shouldSkip) {
				switch (e.expr) {
					case TBinop(OpAssign, { expr : TLocal(lhs) }, { expr : TLocal(rhs) }):
						var lhsName = toElixirVarName(lhs.name);
						var rhsName = toElixirVarName(rhs.name);
						if (isTempPatternVarName(lhsName) || lhsName == rhsName || isTempPatternVarName(rhsName)) {
							shouldSkip = true;
						};					
					case _:
				};
			};
			if (!shouldSkip) {
				var builtExpr = buildFromTypedExpr(e, currentContext);
				if (builtExpr != null) {
					expressions.push(builtExpr);
				} else { };
			} else { };
		};
		var needsCombining = false;
		for (i  in  0 ... expressions.length - 1) {
			var current = expressions[i];
			var next = expressions[i + 1];
			if (current == null || next == null || current.def == null || next.def == null) {
				continue;
			};
			switch ([current.def, next.def]) {
				case [EMatch(_, _), ECall(_, _, _)]:
					needsCombining = true;
					break;				
				case _:
			};
		};
		if (needsCombining) {
			var combinedBlock = makeAST(EBlock(expressions));
			var transformed = reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass(combinedBlock);
			transformed.def;
		} else {
			EBlock(expressions);
		};	
	case TReturn(e):
		if (e != null) {
			var returnExpr = buildFromTypedExpr(e, currentContext);
			returnExpr.def;
		} else {
			ENil;
		};	
	case TBreak:
		EThrow(makeAST(EAtom(ElixirAtom.raw("break"))));	
	case TContinue:
		EThrow(makeAST(EAtom(ElixirAtom.raw("continue"))));	
	case TSwitch(e, cases, edef):
		switchNestingLevel++;
		if (currentContext != null && currentContext.builderFacade != null && currentContext.isFeatureEnabled("use_new_pattern_builder")) {
			try {
				var facadeCases = cases.map(function(c) {
					return { values : c.values, expr : c.expr, guard : null };
				});
				var switchAST = currentContext.builderFacade.routeSwitch(e, facadeCases, edef);
				return switchAST.def;
			} catch(err:Dynamic) { };
		};
		function extractEnumTypeFromSwitch(expr:TypedExpr):Null<EnumType> {
			return switch (expr.expr) {
				case TParenthesis(innerExpr):
					extractEnumTypeFromSwitch(innerExpr);				
				case TMeta(_, innerExpr):
					extractEnumTypeFromSwitch(innerExpr);				
				case TEnumIndex(enumExpr):
					switch (enumExpr.t) {
						case TEnum(enumRef, _):
							enumRef.get();						
						default:
							null;						
					};				
				default:
					switch (expr.t) {
						case TEnum(enumRef, _):
							enumRef.get();						
						default:
							null;						
					};				
			};
		};
		var enumType = extractEnumTypeFromSwitch(e);
		var hasEnumType = enumType != null;
		var isIdiomaticEnum = enumType != null && enumType.meta.has(":elixirIdiomatic");
		var expr = buildFromTypedExpr(e, currentContext).def;
		var clauses = [];
		var needsTempVar = false;
		var tempVarName = "temp_result";
		var isReturnContext = false;
		var hasAnyEnumBindingPlan = false;
		var bindingPlanId = if (enumType != null) {
			var idComponents = [];
			var timestamp = Std.int(haxe.Timer.stamp() * 1000000);
			var random = Std.random(10000);
			idComponents.push("${timestamp}_${random}");
			if (e.pos != null) {
				var posInfo = haxe.macro.PositionTools.toLocation(e.pos);
				var fileStr = Std.string(posInfo.file);
				var fileParts = fileStr.split("/");
				var fileName = fileParts[fileParts.length - 1];
				idComponents.push("${fileName}_L${posInfo.range.start.line}");
			};
			var targetType = Type.enumConstructor(e.expr);
			idComponents.push(targetType);
			if (enumType != null && enumType.name != null) {
				idComponents.push(enumType.name);
			};
			"enum_${idComponents.join(\"_\")}";
		} else {
			null;
		};
		var switchSavedContext = currentContext.currentClauseContext;
		for (c  in  cases) {
			var extractedParams = analyzeEnumParameterExtraction(c.expr, c.values);
			var bindingResult = createEnumBindingPlan(c.expr, extractedParams, enumType);
			var enumBindingPlan = bindingResult.plan;
			var paramIndexToVarId = bindingResult.paramIndexToVarId;
			if (enumBindingPlan != null && enumBindingPlan.keys().hasNext()) {
				hasAnyEnumBindingPlan = true;
				if (bindingPlanId != null && currentContext != null && currentContext.astContext != null) {
					currentContext.astContext.storeEnumBindingPlan(bindingPlanId, enumBindingPlan);
				};
			};
			for (index  in  enumBindingPlan.keys()) {
				var info = enumBindingPlan.get(index);
				if (index < extractedParams.length) {
					extractedParams[index] = info.finalName;
				};
			};
			var varMapping = createVariableMappingsForCase(c.expr, extractedParams, enumType, c.values, enumBindingPlan);
			var patternParamNames = if (enumBindingPlan != null) {
				var names = [];
				var maxIndex = 0;
				for (index => info  in  enumBindingPlan) {
					if (index > maxIndex) maxIndex = index;
				};
				for (i  in  0 ... (maxIndex + 1)) {
					if (enumBindingPlan.exists(i)) {
						names.push(enumBindingPlan.get(i).finalName);
					} else {
						names.push("_g${i}");
					};
				};
				names;
			} else {
				extractedParams;
			};
			var patterns = if (hasEnumType && enumType != null) {
				if (isIdiomaticEnum) {
					[for (v  in  c.values) convertIdiomaticEnumPatternWithExtraction(v, enumType, patternParamNames, currentContext.variableUsageMap)];
				} else {
					[for (v  in  c.values) convertRegularEnumPatternWithExtraction(v, enumType, patternParamNames, currentContext.variableUsageMap)];
				};
			} else {
				[for (v  in  c.values) convertPatternWithExtraction(v, patternParamNames)];
			};
			var savedClauseContext = currentContext.currentClauseContext;
			currentContext.currentClauseContext = new ClauseContext(savedClauseContext, varMapping, enumBindingPlan);
			if (paramIndexToVarId != null) {
				currentContext.currentClauseContext.markPatternSatisfiedVars(paramIndexToVarId);
			};
			var body = buildFromTypedExpr(c.expr, currentContext);
			if (body.metadata == null) body.metadata = { };
			body.metadata.varIdToName = varMapping;
			for (pattern  in  patterns) {
				var finalPattern = applyUnderscorePrefixToUnusedPatternVars(pattern, currentContext.variableUsageMap, extractedParams);
				var updatedMapping = updateMappingForUnderscorePrefixes(finalPattern, varMapping, extractedParams);
				var finalBody = if (updatedMapping != varMapping) {
					currentContext.currentClauseContext = new ClauseContext(savedClauseContext, updatedMapping, enumBindingPlan);
					if (paramIndexToVarId != null) {
						currentContext.currentClauseContext.markPatternSatisfiedVars(paramIndexToVarId);
					};
					var newBody = buildFromTypedExpr(c.expr, currentContext);
					newBody;
				} else {
					body;
				};
				clauses.push({ pattern : finalPattern, guard : null, body : finalBody });
			};
		};
		if (edef != null) {
			clauses.push({ pattern : PWildcard, guard : null, body : buildFromTypedExpr(edef, currentContext) });
		};
		var caseASTDef = ECase(makeAST(expr), clauses);
		var caseNode = makeAST(caseASTDef);
		if (hasAnyEnumBindingPlan) {
			if (caseNode.metadata == null) caseNode.metadata = { };
			caseNode.metadata.hasEnumBindingPlan = true;
			if (bindingPlanId != null) {
				caseNode.metadata.enumBindingPlanId = bindingPlanId;
			};
		};
		currentContext.currentClauseContext = switchSavedContext;
		switchNestingLevel--;
		if (isReturnContext && needsTempVar) {
			EBlock([makeAST(EMatch(PVar(tempVarName), caseNode)), makeAST(EVar(tempVarName))]);
		} else {
			caseNode.def;
		};	
	case TTry(e, catches):
		var body = buildFromTypedExpr(e, currentContext);
		var rescueClauses = [];
		for (c  in  catches) {
			var pattern = PVar(toElixirVarName(c.v.name));
			var catchBody = buildFromTypedExpr(c.expr, currentContext);
			rescueClauses.push({ pattern : pattern, body : catchBody });
		};
		ETry(body, rescueClauses, [], null, null);	
	case TFunction(f):
		var fluentPattern = detectFluentAPIPattern(f);
		var args = [];
		var paramRenaming = new Map<String,String>();
		var oldTempVarRenameMap = currentContext.tempVarRenameMap;
		currentContext.tempVarRenameMap = new Map();
		for (key  in  oldTempVarRenameMap.keys()) {
			currentContext.tempVarRenameMap.set(key, oldTempVarRenameMap.get(key));
		};
		var isFirstParam = true;
		for (arg  in  f.args) {
			var originalName = arg.v.name;
			var idKey = Std.string(arg.v.id);
			var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
				true;
			} else if (f.expr != null) {
				!reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, f.expr);
			} else {
				false;
			};
			var strippedName = originalName;
			var hasNumericSuffix = false;
			var renamedPattern = ~/^(.+?)(\d+)$/;
			if (renamedPattern.match(originalName)) {
				var baseWithoutSuffix = renamedPattern.matched(1);
				var suffix = renamedPattern.matched(2);
				var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items"];
				if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix) >= 0) {
					strippedName = baseWithoutSuffix;
					hasNumericSuffix = true;
				};
			};
			var baseName = ElixirASTHelpers.toElixirVarName(strippedName);
			var finalName = if (isActuallyUnused && !baseName.startsWith("_")) {
				"_" + baseName;
			} else {
				baseName;
			};
			if (!currentContext.tempVarRenameMap.exists(idKey)) {
				currentContext.tempVarRenameMap.set(idKey, finalName);
			};
			if (originalName != finalName) {
				paramRenaming.set(originalName, finalName);
			};
			if (hasNumericSuffix && currentContext != null && currentContext.astContext != null) {
				currentContext.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);
			};
			if (originalName == "this1") {
				paramRenaming.set("this", finalName);
			};
			if (isFirstParam && currentContext.isInClassMethodContext) {
				currentContext.currentReceiverParamName = finalName;
				isFirstParam = false;
			};
			args.push(PVar(finalName));
			currentContext.functionParameterIds.set(idKey, true);
		};
		var functionUsageMap:Map<Int,Bool> = null;
		if (functionUsageMap != null) {
			currentContext.variableUsageMap = functionUsageMap;
		};
		var body = buildFromTypedExpr(f.expr, currentContext);
		currentContext.tempVarRenameMap = oldTempVarRenameMap;
		for (arg  in  f.args) {
			currentContext.functionParameterIds.remove(Std.string(arg.v.id));
		};
		if (paramRenaming.keys().hasNext()) {
			body = applyParameterRenaming(body, paramRenaming);
		};
		var fnAst = makeAST(EFn([{ args : args, guard : null, body : body }]));
		if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
			fnAst.metadata.isFluentMethod = true;
			fnAst.metadata.returnsThis = fluentPattern.returnsThis;
			if (fluentPattern.fieldMutations.length > 0) {
				fnAst.metadata.mutatesFields = [];
				fnAst.metadata.fieldMutations = [];
				for (mutation  in  fluentPattern.fieldMutations) {
					fnAst.metadata.mutatesFields.push(mutation.field);
					fnAst.metadata.fieldMutations.push({ field : mutation.field, expr : buildFromTypedExpr(mutation.expr, currentContext) });
				};
			};
		};
		fnAst.def;	
	case TObjectDecl(fields):
		var isTuplePattern = true;
		var maxTupleIndex = 0;
		for (field  in  fields) {
			if (!~/^_\d+$/.match(field.name)) {
				isTuplePattern = false;
				break;
			};
			var index = Std.parseInt(field.name.substr(1));
			if (index > maxTupleIndex) {
				maxTupleIndex = index;
			};
		};
		if (isTuplePattern && fields.length > 0) {
			var sortedFields = fields.copy();
			sortedFields.sort(function(a, b) {
				var aIndex = Std.parseInt(a.name.substr(1));
				var bIndex = Std.parseInt(b.name.substr(1));
				return aIndex - bIndex;
			});
			var tupleElements = [];
			for (field  in  sortedFields) {
				tupleElements.push(buildFromTypedExpr(field.expr, currentContext));
			};
			return ETuple(tupleElements);
		};
		var hasStrategy = false;
		var hasMaxRestarts = false;
		var hasMaxSeconds = false;
		var hasId = false;
		var hasStart = false;
		var hasType = false;
		for (field  in  fields) {
			switch (field.name) {
				case "strategy":
					hasStrategy = true;				
				case "max_restarts":
					hasMaxRestarts = true;				
				case "max_seconds":
					hasMaxSeconds = true;				
				case "id":
					hasId = true;				
				case "start":
					hasStart = true;				
				case "type":
					hasType = true;				
				case _:
			};
		};
		if (hasStrategy && (hasMaxRestarts || hasMaxSeconds)) {
			var keywordPairs:Array<EKeywordPair> = [];
			for (field  in  fields) {
				var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
				var fieldValue = buildFromTypedExpr(field.expr, currentContext);
				keywordPairs.push({ key : atomName, value : fieldValue });
			};
			EKeywordList(keywordPairs);
		} else if (hasId && hasStart) {
			var pairs = [];
			for (field  in  fields) {
				var atomName = toSnakeCase(field.name);
				var key = makeAST(EAtom(atomName));
				var fieldValue = if (field.name == "start") {
					switch (field.expr.expr) {
						case TObjectDecl(startFields):
							var moduleField = null;
							var funcField = null;
							var argsField = null;
							for (sf  in  startFields) {
								switch (sf.name) {
									case "module":
										moduleField = sf;									
									case "func":
										funcField = sf;									
									case "args":
										argsField = sf;									
									case _:
								};
							};
							if (moduleField != null && funcField != null && argsField != null) {
								var moduleAst = switch (moduleField.expr.expr) {
									case TConst(TString(s)):
										makeAST(EVar(s));									
									case _:
										buildFromTypedExpr(moduleField.expr, currentContext);									
								};
								var funcAst = switch (funcField.expr.expr) {
									case TConst(TString(s)):
										makeAST(EAtom(s));									
									case _:
										buildFromTypedExpr(funcField.expr, currentContext);									
								};
								var argsAst = buildFromTypedExpr(argsField.expr, currentContext);
								makeAST(ETuple([moduleAst, funcAst, argsAst]));
							} else {
								buildFromTypedExpr(field.expr, currentContext);
							};						
						case _:
							buildFromTypedExpr(field.expr, currentContext);						
					};
				} else if (field.name == "type" || field.name == "restart" || field.name == "shutdown") {
					switch (field.expr.expr) {
						case TConst(TString(s)):
							makeAST(EAtom(s));						
						case _:
							buildFromTypedExpr(field.expr, currentContext);						
					};
				} else {
					buildFromTypedExpr(field.expr, currentContext);
				};
				pairs.push({ key : key, value : fieldValue });
			};
			EMap(pairs);
		} else {
			var pairs = [];
			for (field  in  fields) {
				var atomName = toSnakeCase(field.name);
				var key = makeAST(EAtom(atomName));
				var fieldValue = switch (field.expr.expr) {
					case TBlock([{ expr : TVar(tmpVar, init) }, { expr : TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) }]) if (v.id == tmpVar.id && init != null):
						var initAst = buildFromTypedExpr(init, currentContext);
						var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
						var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
						var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
						if (ifExpr.metadata == null) ifExpr.metadata = { };
						ifExpr.metadata.keepInlineInAssignment = true;
						ifExpr;					
					case _:
						var fieldValue = switch (field.expr.expr) {
							case TLocal(v):
								var idKey = Std.string(v.id);
								if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
									var mappedName = currentContext.tempVarRenameMap.get(idKey);
									makeAST(EVar(mappedName));
								} else {
									buildFromTypedExpr(field.expr, currentContext);
								};							
							default:
								buildFromTypedExpr(field.expr, currentContext);							
						};
						fieldValue;					
				};
				pairs.push({ key : key, value : fieldValue });
			};
			EMap(pairs);
		};	
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		var isNativeModule = switch (m) {
			case TClassDecl(c):
				var cl = c.get();
				if (cl.meta.has(":native")) {
					var nativeMeta = cl.meta.extract(":native");
					if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
						switch (nativeMeta[0].params[0].expr) {
							case EConst(CString(s, _)):
								moduleName = s;
								true;							
							default:
								false;							
						};
					} else {
						false;
					};
				} else {
					false;
				};			
			default:
				false;			
		};
		EVar(moduleName);	
	case TCast(e, m):
		buildFromTypedExpr(e, currentContext).def;	
	case TParenthesis(e):
		EParen(buildFromTypedExpr(e, currentContext));	
	case TMeta(m, e):
		if (m.name == ":mergeBlock") {
			switch (e.expr) {
				case TBlock([{ expr : TVar(tmpVar, init) }, secondExpr]) if (init != null):
					switch (secondExpr.expr) {
						case TIf(condition, thenBranch, elseBranch):
							var isNullCheck = switch (condition.expr) {
								case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
									v.id == tmpVar.id;								
								default:
									false;								
							};
							if (isNullCheck) {
								var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
								var initAst = buildFromTypedExpr(init, currentContext);
								var elseAst = buildFromTypedExpr(elseBranch, currentContext);
								var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
								if (ifExpr.metadata == null) ifExpr.metadata = { };
								ifExpr.metadata.keepInlineInAssignment = true;
								return ifExpr.def;
							};						
						default:
					};				
				default:
			};
		};
		var innerAST = buildFromTypedExpr(e, currentContext);
		innerAST.def;	
	case TNew(c, _, el):
		var classType = c.get();
		var className = classType.name;
		var args = [for (e  in  el) buildFromTypedExpr(e, currentContext)];
		if (classType.meta.has(":schema")) {
			var moduleName = if (classType.meta.has(":native")) {
				var nativeMeta = classType.meta.extract(":native");
				if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
					switch (nativeMeta[0].params[0].expr) {
						case EConst(CString(s, _)):
							s;						
						default:
							className;						
					};
				} else {
					className;
				};
			} else {
				className;
			};
			EStruct(moduleName, []);
		} else if (className == "StringMap" || className == "Map" || className.endsWith("Map")) {
			EMap([]);
		} else {
			var hasInstanceMethods = false;
			for (field  in  classType.fields.get()) {
				if (field.kind.match(FMethod(_))) {
					var isStatic = false;
					for (staticField  in  classType.statics.get()) {
						if (staticField.name == field.name) {
							isStatic = true;
							break;
						};
					};
					if (!isStatic) {
						hasInstanceMethods = true;
						break;
					};
				};
			};
			var hasConstructor = classType.constructor != null;
			if (hasInstanceMethods || hasConstructor) {
				var moduleRef = makeAST(EVar(className));
				ECall(moduleRef, "new", args);
			} else {
				EStruct(className, []);
			};
		};	
	case TFor(v, e1, e2):
		var loopMetadata = createMetadata(expr);
		loopMetadata.loopVariableName = v.name;
		loopMetadata.originalLoopExpression = captureExpressionText(e2, v.name);
		if (currentContext != null && currentContext.isFeatureEnabled("loop_builder_enabled")) {
			var guard = currentContext.reentrancyGuard;
			var forExpr = expr;
			var safeBuilder = function():ElixirAST {
				var transform = LoopBuilder.analyzeFor(v, e1, e2);
				return LoopBuilder.buildFromTransform(transform, function(e) {
					return guard.process(e, function() {
						return buildFromTypedExpr(e, currentContext);
					});
				}, function(name) return toElixirVarName(name));
			};
			var ast = guard.process(forExpr, safeBuilder);
			if (ast != null) {
				makeASTWithMeta(ast.def, loopMetadata, expr.pos).def;
			} else {
				ast.def;
			};
		} else {
			var varName = toElixirVarName(v.name);
			var pattern = PVar(varName);
			var iteratorExpr = buildFromTypedExpr(e1, currentContext);
			var bodyExpr = buildFromTypedExpr(e2, currentContext);
			var forDef = EFor([{ pattern : pattern, expr : iteratorExpr }], [], bodyExpr, null, false);
			makeASTWithMeta(forDef, loopMetadata, expr.pos).def;
		};	
	case TWhile(econd, e, normalWhile):
		var isMapKeysLoop = false;
		var keysCollection:String = null;
		var indexVar:String = null;
		var actualCondition = switch (econd.expr) {
			case TParenthesis(e):
				e;			
			case _:
				econd;			
		};
		switch (actualCondition.expr) {
			case TBinop(OpLt, { expr : TLocal(idx) }, lengthExpr):
				if (idx.name == "g" || idx.name.startsWith("_g") || idx.name.indexOf("g") >= 0) {
					indexVar = idx.name;
					switch (lengthExpr.expr) {
						case TCall(callExpr, args):
							switch (callExpr.expr) {
								case TField(_, FStatic(_, cf)):
									if (cf.get().name == "length" && args.length > 0) {
										switch (args[0].expr) {
											case TLocal(coll):
												keysCollection = coll.name;
												isMapKeysLoop = true;											
											case _:
										};
									};								
								case _:
							};						
						case TField({ expr : TLocal(coll) }, FInstance(_, _, cf)):
							if (cf.get().name == "length") {
								keysCollection = coll.name;
								if (coll.name == "g1" || coll.name.indexOf("g1") >= 0) {
									isMapKeysLoop = true;
								};
							};						
						case _:
					};
				};			
			case TParenthesis(_):
			case _:
		};
		if (false && isMapKeysLoop && keysCollection != null && indexVar != null) {
			var loopVar:String = null;
			var bodyWithoutExtraction:TypedExpr = e;
			switch (e.expr) {
				case TBlock(stmts) if (stmts.length > 0):
					switch (stmts[0].expr) {
						case TVar(v, { expr : TArray({ expr : TLocal(coll) }, { expr : TLocal(idx) }) }) if (coll.name == keysCollection && idx.name == indexVar):
							loopVar = toElixirVarName(v.name);
							var restStmts = stmts.slice(1);
							if (restStmts.length > 0) {
								switch (restStmts[0].expr) {
									case TUnop(OpIncrement, _, { expr : TLocal(idx) }) if (idx.name == indexVar):
										restStmts = restStmts.slice(1);									
									case _:
								};
							};
							if (restStmts.length == 1) {
								bodyWithoutExtraction = restStmts[0];
							} else if (restStmts.length > 0) {
								bodyWithoutExtraction = { expr : TBlock(restStmts), t : e.t, pos : e.pos };
							};						
						case _:
							loopVar = "item";						
					};				
				case _:
					loopVar = "item";				
			};
			var bodyAst = buildFromTypedExpr(bodyWithoutExtraction, currentContext);
			return EFor([{ pattern : PVar(loopVar), expr : makeAST(EVar(keysCollection)) }], [], bodyAst, null, false);
		};
		var isArrayLoop = false;
		var arrayRef:TypedExpr = null;
		switch (econd.expr) {
			case TBinop(OpLt, { expr : TLocal(indexVar) }, { expr : TField(arr, FInstance(_, _, cf)) }) if (indexVar.name.startsWith("_g") && cf.get().name == "length"):
				isArrayLoop = true;
				arrayRef = arr;			
			case _:
		};
		if (isArrayLoop && arrayRef != null) {
			var pattern = ElixirASTPatterns.detectArrayOperationPattern(e);
			if (pattern != null) {
				return generateIdiomaticEnumCall(arrayRef, pattern, e);
			};
		};
		var condition = buildFromTypedExpr(econd, currentContext);
		var body = buildFromTypedExpr(e, currentContext);
		var loopName = "loop_" + (currentContext.whileLoopCounter++);
		var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(e);
		var conditionVars = new Map<Int,TVar>();
		function findConditionVars(expr:TypedExpr):Void {
			if (expr == null) return;
			switch (expr.expr) {
				case TLocal(v):
					conditionVars.set(v.id, v);				
				default:
					haxe.macro.TypedExprTools.iter(expr, findConditionVars);				
			};
		};
		findConditionVars(econd);
		for (v  in  conditionVars) {
			if (!mutatedVars.exists(v.id)) {
				mutatedVars.set(v.id, v);
			};
		};
		if (Lambda.count(mutatedVars) > 0) {
			var accVarList:Array<{ var name : String; var tvar : TVar}> = [];
			for (id => v  in  mutatedVars) {
				accVarList.push({ name : toElixirVarName(v.name), tvar : v });
			};
			accVarList.sort(function(a, b) ->  @:implicitReturn return a.tvar.id - b.tvar.id);
			var initialAccValues:Array<ElixirAST> = [];
			var accPattern:Array<EPattern> = [];
			var accVarNames:Array<String> = [];
			for (v  in  accVarList) {
				var originalName = v.tvar.name;
				var transformedName = v.name;
				var initialValue = getVariableInitValue(originalName, currentContext);
				initialAccValues.push(initialValue);
				accPattern.push(PVar("acc_" + transformedName));
				accVarNames.push(transformedName);
			};
			initialAccValues.push(makeAST(EAtom(ElixirAtom.ok())));
			accPattern.push(PVar("acc_state"));
			var initialAccumulator = makeAST(ETuple(initialAccValues));
			var accPatternTuple = PTuple(accPattern);
			var contAccValues:Array<ElixirAST> = [];
			for (varName  in  accVarNames) {
				contAccValues.push(makeAST(EVar(varName)));
			};
			contAccValues.push(makeAST(EVar("acc_state")));
			var contAccumulator = makeAST(ETuple(contAccValues));
			var varMapping = new Map<String,String>();
			for (varName  in  accVarNames) {
				varMapping.set(varName, "acc_" + varName);
			};
			var transformedCondition = transformVariableReferences(condition, varMapping);
			var transformedBody = transformVariableReferences(body, varMapping);
			var bodyHasReturn = checkForEarlyReturns(transformedBody);
			var updatedContAccValues:Array<ElixirAST> = [];
			for (varName  in  accVarNames) {
				updatedContAccValues.push(makeAST(EVar("acc_" + varName)));
			};
			updatedContAccValues.push(makeAST(EVar("acc_state")));
			var updatedContAccumulator = makeAST(ETuple(updatedContAccValues));
			var wrappedBody = if (bodyHasReturn) {
				transformReturnsToHalts(transformedBody, updatedContAccumulator);
			} else {
				makeAST(EBlock([transformedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]))]));
			};
			var completeBody = makeAST(EIf(transformedCondition, wrappedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), updatedContAccumulator]))));
			var usedAccVars = new Map<String,Bool>();
			for (varName  in  accVarNames) {
				var accVarName = "acc_" + varName;
				usedAccVars.set(varName, isVariableUsedInAST(accVarName, completeBody));
			};
			var isAccStateUsed = isVariableUsedInAST("acc_state", completeBody);
			var finalAccPattern:Array<EPattern> = [];
			for (i  in  0 ... accVarNames.length) {
				var varName = accVarNames[i];
				var accVarName = "acc_" + varName;
				if (usedAccVars.get(varName)) {
					finalAccPattern.push(PVar(accVarName));
				} else {
					finalAccPattern.push(PVar(accVarName));
				};
			};
			if (isAccStateUsed) {
				finalAccPattern.push(PVar("acc_state"));
			} else {
				finalAccPattern.push(PVar("_acc_state"));
			};
			var finalAccPatternTuple = PTuple(finalAccPattern);
			var reduceResult = ERemoteCall(makeAST(EVar("Enum")), "reduce_while", [makeAST(ERemoteCall(makeAST(EVar("Stream")), "iterate", [makeAST(EInteger(0)), makeAST(EFn([{ args : [PVar("n")], guard : null, body : makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1)))) }]))])), initialAccumulator, {
				var isEmptyBody = switch (transformedBody.def) {
					case ENil:
						true;					
					case _:
						false;					
				};
				var accPatternToUse = if (isEmptyBody && Lambda.count(mutatedVars) > 0) {
					var wildcardPatterns:Array<EPattern> = [];
					for (i  in  0 ... (accVarNames.length + 1)) {
						wildcardPatterns.push(PWildcard);
					};
					PTuple(wildcardPatterns);
				} else {
					finalAccPatternTuple;
				};
				makeAST(EFn([{ args : [PWildcard, accPatternToUse], guard : null, body : {
					var updatedContAccValues:Array<ElixirAST> = [];
					for (varName  in  accVarNames) {
						updatedContAccValues.push(makeAST(EVar("acc_" + varName)));
					};
					updatedContAccValues.push(makeAST(EVar("acc_state")));
					var updatedContAccumulator = makeAST(ETuple(updatedContAccValues));
					var wrappedBody = if (bodyHasReturn) {
						transformReturnsToHalts(transformedBody, updatedContAccumulator);
					} else if (isEmptyBody) {
						makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]));
					} else {
						makeAST(EBlock([transformedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), updatedContAccumulator]))]));
					};
					makeAST(EIf(transformedCondition, wrappedBody, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), if (isEmptyBody) makeAST(EAtom(ElixirAtom.ok())) else updatedContAccumulator]))));
				} }]));
			}]);
			reduceResult;
		} else {
			ERemoteCall(makeAST(EVar("Enum")), "reduce_while", [makeAST(ERemoteCall(makeAST(EVar("Stream")), "iterate", [makeAST(EInteger(0)), makeAST(EFn([{ args : [PVar("n")], guard : null, body : makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1)))) }]))])), makeAST(EAtom(ElixirAtom.ok())), makeAST(EFn([{ args : [PWildcard, PVar("acc")], guard : null, body : makeAST(EIf(condition, makeAST(EBlock([body, makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), makeAST(EVar("acc"))]))])), makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), makeAST(EVar("acc"))])))) }]))]);
		};	
	case TThrow(e):
		EThrow(buildFromTypedExpr(e, currentContext));	
	case TEnumParameter(e, ef, index):
		var sourceVarName:String = null;
		switch (e.expr) {
			case TLocal(v):
				sourceVarName = toElixirVarName(v.name);			
			default:
		};
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan.exists(index)) {
			var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
			if (sourceVarName != null && (sourceVarName == "g" || (sourceVarName.startsWith("g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
				if (info.finalName != sourceVarName) {
					return EVar(info.finalName);
				};
			};
			if (info.finalName == sourceVarName && sourceVarName != null) {
				return null;
			} else {
				return EVar(info.finalName);
			};
		} else {
			if (sourceVarName != null && (sourceVarName == "g" || (sourceVarName.startsWith("g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
				return null;
			};
			var skipExtraction = false;
			var extractedVarName:String = null;
			if (!skipExtraction) {
				switch (e.expr) {
					case TLocal(v):
						var varName = toElixirVarName(v.name);
						if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
							extractedVarName = currentContext.currentClauseContext.localToName.get(v.id);
							skipExtraction = true;
						} else {
							var isExtractionTemp = false;
							if (currentContext.tempVarRenameMap.exists(Std.string(v.id))) {
								isExtractionTemp = true;
							} else if (varName == "g" || (varName.startsWith("g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
								isExtractionTemp = false;
							};
							if (isExtractionTemp) {
								extractedVarName = varName;
								skipExtraction = true;
							};
						};					
					case _:
				};
			};
			if (skipExtraction && extractedVarName != null) {
				EVar(extractedVarName);
			} else {
				var exprAST = buildFromTypedExpr(e, currentContext);
				ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]);
			};
		};	
	case TEnumIndex(e):
		buildFromTypedExpr(e, currentContext).def;	
	case TIdent(s):
		EVar(toElixirVarName(s));	
}) {
			var ` = expr.expr;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						var c = `;
						{
							@:ast(switch (c) {
	case TString(s):
		var isAtom = false;
		switch (expr.t) {
			case TAbstract(ref, _):
				var abstractType = ref.get();
				if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
					isAtom = true;
				};			
			case _:
		};
		if (isAtom) {
			EAtom(s);
		} else {
			EString(s);
		};	
	case TThis:
		if (currentContext.isInClassMethodContext && currentContext.currentReceiverParamName != null) {
			EVar(currentContext.currentReceiverParamName);
		} else {
			EVar("self");
		};	
	default:
		var ast = CoreExprBuilder.buildConst(c);
		ast.def;	
}) switch (enumIndex c) {
								case 2: {
									var ` = c[0];
									{
										var s = `;
										{
											var isAtom = false;
											@:ast(switch (expr.t) {
	case TAbstract(ref, _):
		var abstractType = ref.get();
		if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
			isAtom = true;
		};	
	case _:
}) {
												var ` = expr.t;
												if (enumIndex ` == 8) {
													var ` = `[0];
													var ` = `[1];
													{
														var ref = `;
														{
															var abstractType = ref.get();
															if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
																isAtom = true;
															};
														};
													};
												} else {};
											};
											if (isAtom) {
												reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
													cast cast this;
												});
											} else {
												reflaxe.elixir.ast.ElixirASTDef.EString(s);
											};
										};
									};
								};
								case 5: {
									{
										if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInClassMethodContext && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentReceiverParamName != null) {
											reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentReceiverParamName);
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EVar("self");
										};
									};
								};
								default: {
									var ast = reflaxe.elixir.ast.builders.CoreExprBuilder.buildConst(c, null);
									ast.def;
								}
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							var idKey = Std.string(v.id);
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								var mappedName = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.get(idKey);
								};
								reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName);
							} else {
								if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null) {
									var mappedName = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.lookupVariable(v.id);
									if (mappedName != null) {
										reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName);
									} else {
										var ast = reflaxe.elixir.ast.builders.CoreExprBuilder.buildLocal(v, null);
										ast.def;
									};
								} else {
									var ast = reflaxe.elixir.ast.builders.CoreExprBuilder.buildLocal(v, null);
									ast.def;
								};
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var index = `;
						{
							var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var key = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(index, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							reflaxe.elixir.ast.ElixirASTDef.EAccess(target, key);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var e1 = `;
						var e2 = `;
						{
							var result = @:ast(switch (op) {
	case OpAssign:
		var pattern = extractPattern(e1);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var shouldSkipAssign = false;
		switch (pattern) {
			case PVar(name):
				var valueName = switch (rightAST != null ? rightAST.def : null) {
					case EVar(varName):
						varName;					
					default:
						null;					
				};
				if (isTempPatternVarName(name)) {
					shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
						case EVar(varName) if (varName == name || isTempPatternVarName(varName)):
							true;						
						default:
							false;						
					};
				} else if (valueName != null) {
					if (valueName == name) {
						shouldSkipAssign = true;
					} else if (isTempPatternVarName(valueName)) {
						shouldSkipAssign = true;
					};
				};			
			default:
		};
		if (shouldSkipAssign) {
			null;
		} else {
			EMatch(pattern, rightAST);
		};	
	case OpAssignOp(innerOp):
		var pattern = extractPattern(e1);
		var leftAST = buildFromTypedExpr(e1, currentContext);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var innerBinop = BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s) return toSnakeCase(s));
		EMatch(pattern, innerBinop);	
	default:
		var leftAST = buildFromTypedExpr(e1, currentContext);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var ast = BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s) return toSnakeCase(s));
		ast.def;	
}) switch (enumIndex op) {
								case 4: {
									{
										var pattern = reflaxe.elixir.ast.ElixirASTBuilder.extractPattern(e1);
										var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										var shouldSkipAssign = false;
										@:ast(switch (pattern) {
	case PVar(name):
		var valueName = switch (rightAST != null ? rightAST.def : null) {
			case EVar(varName):
				varName;			
			default:
				null;			
		};
		if (isTempPatternVarName(name)) {
			shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
				case EVar(varName) if (varName == name || isTempPatternVarName(varName)):
					true;				
				default:
					false;				
			};
		} else if (valueName != null) {
			if (valueName == name) {
				shouldSkipAssign = true;
			} else if (isTempPatternVarName(valueName)) {
				shouldSkipAssign = true;
			};
		};	
	default:
}) if (enumIndex pattern == 0) {
											var ` = pattern[0];
											{
												var name = `;
												{
													var valueName = @:ast(switch (rightAST != null ? rightAST.def : null) {
	case EVar(varName):
		varName;	
	default:
		null;	
}) {
														var ` = if (rightAST != null) {
															rightAST.def;
														} else {
															null;
														};
														if (` == null) {
															null;
														} else if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var varName = `;
																{
																	varName;
																};
															};
														} else {
															null;
														};
													};
													if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(name)) {
														shouldSkipAssign = @:ast(switch (rightAST != null ? rightAST.def : null) {
	case EVar(varName) if (varName == name || isTempPatternVarName(varName)):
		true;	
	default:
		false;	
}) {
															var ` = if (rightAST != null) {
																rightAST.def;
															} else {
																null;
															};
															if (` == null) {
																false;
															} else if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var varName = `;
																	if (varName == name || reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
																		true;
																	} else {
																		false;
																	};
																};
															} else {
																false;
															};
														};
													} else {
														if (valueName != null) {
															if (valueName == name) {
																shouldSkipAssign = true;
															} else {
																if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(valueName)) {
																	shouldSkipAssign = true;
																};
															};
														};
													};
												};
											};
										} else {};
										if (shouldSkipAssign) {
											null;
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, rightAST);
										};
									};
								};
								case 20: {
									var ` = op[0];
									{
										var innerOp = `;
										{
											var pattern = reflaxe.elixir.ast.ElixirASTBuilder.extractPattern(e1);
											var leftAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											var innerBinop = reflaxe.elixir.ast.builders.BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s:String) return reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(s), null);
											reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, innerBinop);
										};
									};
								};
								default: {
									var leftAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									var ast = reflaxe.elixir.ast.builders.BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s:String) return reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(s), null);
									ast.def;
								}
							};
							result;
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var fa = `;
						{
							@:ast(switch (fa) {
	case FEnum(enumType, ef):
		var enumT = enumType.get();
		if (enumT.meta.has(":elixirIdiomatic")) {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			EAtom(atomName);
		} else {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			ETuple([makeAST(EAtom(atomName))]);
		};	
	case FStatic(classRef, cf):
		var className = classRef.get().name;
		var fieldName = extractFieldName(fa);
		var field = cf.get();
		var isAtomField = false;
		switch (field.type) {
			case TAbstract(abstractRef, _):
				var abstractType = abstractRef.get();
				if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
					isAtomField = true;
				};			
			case _:
		};
		if (!isAtomField) {
			var classType = classRef.get();
			switch (classType.kind) {
				case KAbstractImpl(abstractRef):
					var abstractType = abstractRef.get();
					switch (abstractType.type) {
						case TAbstract(underlyingRef, _):
							var underlyingType = underlyingRef.get();
							if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
								isAtomField = true;
							};						
						case _:
					};				
				case _:
			};
		};
		if (isAtomField && field.expr() != null) {
			switch (field.expr().expr) {
				case TConst(TString(s)):
					EAtom(s);				
				case _:
					fieldName = toSnakeCase(fieldName);
					var target = buildFromTypedExpr(e, currentContext);
					EField(target, fieldName);				
			};
		} else {
			fieldName = toSnakeCase(fieldName);
			if (false) {
				EVar(fieldName);
			} else {
				var target = buildFromTypedExpr(e, currentContext);
				EField(target, fieldName);
			};
		};	
	case FAnon(cf):
		var fieldName = cf.get().name;
		var target = buildFromTypedExpr(e, currentContext);
		if (~/^_\d+$/.match(fieldName)) {
			var index = Std.parseInt(fieldName.substr(1)) - 1;
			ECall(null, "elem", [target, makeAST(EInteger(index))]);
		} else {
			fieldName = toSnakeCase(fieldName);
			EField(target, fieldName);
		};	
	default:
		var target = buildFromTypedExpr(e, currentContext);
		var fieldName = extractFieldName(fa);
		var originalFieldName = fieldName;
		fieldName = toSnakeCase(fieldName);
		if (fieldName == "elem") {
			EField(target, fieldName);
		} else if (isMapAccess(e.t)) {
			EAccess(target, makeAST(EAtom(fieldName)));
		} else {
			EField(target, fieldName);
		};	
}) switch (enumIndex fa) {
								case 1: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var classRef = `;
										var cf = `;
										{
											var className = classRef.get().name;
											var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
											var field = cf.get();
											var isAtomField = false;
											@:ast(switch (field.type) {
	case TAbstract(abstractRef, _):
		var abstractType = abstractRef.get();
		if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
			isAtomField = true;
		};	
	case _:
}) {
												var ` = field.type;
												if (enumIndex ` == 8) {
													var ` = `[0];
													var ` = `[1];
													{
														var abstractRef = `;
														{
															var abstractType = abstractRef.get();
															if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
																isAtomField = true;
															};
														};
													};
												} else {};
											};
											if (! isAtomField) {
												var classType = classRef.get();
												@:ast(switch (classType.kind) {
	case KAbstractImpl(abstractRef):
		var abstractType = abstractRef.get();
		switch (abstractType.type) {
			case TAbstract(underlyingRef, _):
				var underlyingType = underlyingRef.get();
				if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
					isAtomField = true;
				};			
			case _:
		};	
	case _:
}) {
													var ` = classType.kind;
													if (enumIndex ` == 7) {
														var ` = `[0];
														{
															var abstractRef = `;
															{
																var abstractType = abstractRef.get();
																@:ast(switch (abstractType.type) {
	case TAbstract(underlyingRef, _):
		var underlyingType = underlyingRef.get();
		if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
			isAtomField = true;
		};	
	case _:
}) {
																	var ` = abstractType.type;
																	if (enumIndex ` == 8) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var underlyingRef = `;
																			{
																				var underlyingType = underlyingRef.get();
																				if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
																					isAtomField = true;
																				};
																			};
																		};
																	} else {};
																};
															};
														};
													} else {};
												};
											};
											if (isAtomField && field.expr() != null) {
												@:ast(switch (field.expr().expr) {
	case TConst(TString(s)):
		EAtom(s);	
	case _:
		fieldName = toSnakeCase(fieldName);
		var target = buildFromTypedExpr(e, currentContext);
		EField(target, fieldName);	
}) {
													var ` = field.expr().expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															{
																var s = `;
																{
																	reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																		cast cast this;
																	});
																};
															};
														} else {
															fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
															var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
														};
													} else {
														fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
														var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
													};
												};
											} else {
												fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
												if (false) {
													reflaxe.elixir.ast.ElixirASTDef.EVar(fieldName);
												} else {
													var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
												};
											};
										};
									};
								};
								case 2: {
									var ` = fa[0];
									{
										var cf = `;
										{
											var fieldName = cf.get().name;
											var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											if (new EReg("^_\\d+$", "").match(fieldName)) {
												var index = Std.parseInt(fieldName.substr(1, null)) - 1;
												reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index), metadata : {}, pos : pos};
												}]);
											} else {
												fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
												reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
											};
										};
									};
								};
								case 5: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var enumType = `;
										var ef = `;
										{
											var enumT = enumType.get();
											if (enumT.meta.has(":elixirIdiomatic")) {
												var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
												reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast cast this;
												});
											} else {
												var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
												reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
														var this;
														this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
														cast this;
													});
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												}]);
											};
										};
									};
								};
								default: {
									var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
									var originalFieldName = fieldName;
									fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
									if (fieldName == "elem") {
										reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
									} else {
										if (reflaxe.elixir.ast.ElixirASTBuilder.isMapAccess(e.t)) {
											reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											});
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
										};
									};
								}
							};
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						var m = `;
						{
							var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
							var isNativeModule = @:ast(switch (m) {
	case TClassDecl(c):
		var cl = c.get();
		if (cl.meta.has(":native")) {
			var nativeMeta = cl.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						moduleName = s;
						true;					
					default:
						false;					
				};
			} else {
				false;
			};
		} else {
			false;
		};	
	default:
		false;	
}) if (enumIndex m == 0) {
								var ` = m[0];
								{
									var c = `;
									{
										var cl = c.get();
										if (cl.meta.has(":native")) {
											var nativeMeta = cl.meta.extract(":native");
											if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
												@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		moduleName = s;
		true;	
	default:
		false;	
}) {
													var ` = nativeMeta[0].params[0].expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															var ` = `[1];
															{
																var s = `;
																{
																	moduleName = s;
																	true;
																};
															};
														} else {
															false;
														};
													} else {
														false;
													};
												};
											} else {
												false;
											};
										} else {
											false;
										};
									};
								};
							} else {
								false;
							};
							reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName);
						};
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							var isTuplePattern = true;
							var maxTupleIndex = 0;
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									if (! new EReg("^_\\d+$", "").match(field.name)) {
										isTuplePattern = false;
										break;
									};
									var index = Std.parseInt(field.name.substr(1, null));
									if (index > maxTupleIndex) {
										maxTupleIndex = index;
									};
								};
							};
							if (isTuplePattern && fields.length > 0) {
								var sortedFields = fields.copy();
								sortedFields.sort(function(a:{ name : String, expr : haxe.macro.TypedExpr }, b:{ name : String, expr : haxe.macro.TypedExpr }) {
									var aIndex = Std.parseInt(a.name.substr(1, null));
									var bIndex = Std.parseInt(b.name.substr(1, null));
									return aIndex - bIndex;
								});
								var tupleElements = [];
								{
									var ` = 0;
									while (` < sortedFields.length) {
										var field = sortedFields[`];
										++ `;
										tupleElements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
									};
								};
								return reflaxe.elixir.ast.ElixirASTDef.ETuple(tupleElements);
							};
							var hasStrategy = false;
							var hasMaxRestarts = false;
							var hasMaxSeconds = false;
							var hasId = false;
							var hasStart = false;
							var hasType = false;
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									@:ast(switch (field.name) {
	case "strategy":
		hasStrategy = true;	
	case "max_restarts":
		hasMaxRestarts = true;	
	case "max_seconds":
		hasMaxSeconds = true;	
	case "id":
		hasId = true;	
	case "start":
		hasStart = true;	
	case "type":
		hasType = true;	
	case _:
}) {
										var ` = field.name;
										switch (`) {
											case "id": {
												{
													hasId = true;
												};
											};
											case "max_restarts": {
												{
													hasMaxRestarts = true;
												};
											};
											case "max_seconds": {
												{
													hasMaxSeconds = true;
												};
											};
											case "start": {
												{
													hasStart = true;
												};
											};
											case "strategy": {
												{
													hasStrategy = true;
												};
											};
											case "type": {
												{
													hasType = true;
												};
											};
											default: {}
										};
									};
								};
							};
							if (hasStrategy && (hasMaxRestarts || hasMaxSeconds)) {
								var keywordPairs = [];
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
										var fieldValue = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										keywordPairs.push({key : atomName, value : fieldValue});
									};
								};
								reflaxe.elixir.ast.ElixirASTDef.EKeywordList(keywordPairs);
							} else {
								if (hasId && hasStart) {
									var pairs = [];
									{
										var ` = 0;
										while (` < fields.length) {
											var field = fields[`];
											++ `;
											var atomName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(field.name);
											var key = {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
											var fieldValue = if (field.name == "start") {
												@:ast(switch (field.expr.expr) {
	case TObjectDecl(startFields):
		var moduleField = null;
		var funcField = null;
		var argsField = null;
		for (sf  in  startFields) {
			switch (sf.name) {
				case "module":
					moduleField = sf;				
				case "func":
					funcField = sf;				
				case "args":
					argsField = sf;				
				case _:
			};
		};
		if (moduleField != null && funcField != null && argsField != null) {
			var moduleAst = switch (moduleField.expr.expr) {
				case TConst(TString(s)):
					makeAST(EVar(s));				
				case _:
					buildFromTypedExpr(moduleField.expr, currentContext);				
			};
			var funcAst = switch (funcField.expr.expr) {
				case TConst(TString(s)):
					makeAST(EAtom(s));				
				case _:
					buildFromTypedExpr(funcField.expr, currentContext);				
			};
			var argsAst = buildFromTypedExpr(argsField.expr, currentContext);
			makeAST(ETuple([moduleAst, funcAst, argsAst]));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	case _:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
													var ` = field.expr.expr;
													if (enumIndex ` == 7) {
														var ` = `[0];
														{
															var startFields = `;
															{
																var moduleField = null;
																var funcField = null;
																var argsField = null;
																{
																	var ` = 0;
																	while (` < startFields.length) {
																		var sf = startFields[`];
																		++ `;
																		@:ast(switch (sf.name) {
	case "module":
		moduleField = sf;	
	case "func":
		funcField = sf;	
	case "args":
		argsField = sf;	
	case _:
}) {
																			var ` = sf.name;
																			switch (`) {
																				case "args": {
																					{
																						argsField = sf;
																					};
																				};
																				case "func": {
																					{
																						funcField = sf;
																					};
																				};
																				case "module": {
																					{
																						moduleField = sf;
																					};
																				};
																				default: {}
																			};
																		};
																	};
																};
																if (moduleField != null && funcField != null && argsField != null) {
																	var moduleAst = @:ast(switch (moduleField.expr.expr) {
	case TConst(TString(s)):
		makeAST(EVar(s));	
	case _:
		buildFromTypedExpr(moduleField.expr, currentContext);	
}) {
																		var ` = moduleField.expr.expr;
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			if (enumIndex ` == 2) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(s), metadata : {}, pos : pos};
																						};
																					};
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(moduleField.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(moduleField.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		};
																	};
																	var funcAst = @:ast(switch (funcField.expr.expr) {
	case TConst(TString(s)):
		makeAST(EAtom(s));	
	case _:
		buildFromTypedExpr(funcField.expr, currentContext);	
}) {
																		var ` = funcField.expr.expr;
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			if (enumIndex ` == 2) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						{
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						};
																					};
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(funcField.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(funcField.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		};
																	};
																	var argsAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(argsField.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([moduleAst, funcAst, argsAst]), metadata : {}, pos : pos};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																};
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													};
												};
											} else {
												if (field.name == "type" || field.name == "restart" || field.name == "shutdown") {
													@:ast(switch (field.expr.expr) {
	case TConst(TString(s)):
		makeAST(EAtom(s));	
	case _:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
														var ` = field.expr.expr;
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (enumIndex ` == 2) {
																var ` = `[0];
																{
																	var s = `;
																	{
																		{
																			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																				var this;
																				this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																				cast this;
																			});
																			var pos = null;
																			{def : def, metadata : {}, pos : pos};
																		};
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														};
													};
												} else {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												};
											};
											pairs.push({key : key, value : fieldValue});
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EMap(pairs);
								} else {
									var pairs = [];
									{
										var ` = 0;
										while (` < fields.length) {
											var field = fields[`];
											++ `;
											var atomName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(field.name);
											var key = {
												var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
													var this;
													this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
													cast this;
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
											var fieldValue = @:ast(switch (field.expr.expr) {
	case TBlock([{ expr : TVar(tmpVar, init) }, { expr : TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr) }]) if (v.id == tmpVar.id && init != null):
		var initAst = buildFromTypedExpr(init, currentContext);
		var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		ifExpr;	
	case _:
		var fieldValue = switch (field.expr.expr) {
			case TLocal(v):
				var idKey = Std.string(v.id);
				if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
					var mappedName = currentContext.tempVarRenameMap.get(idKey);
					makeAST(EVar(mappedName));
				} else {
					buildFromTypedExpr(field.expr, currentContext);
				};			
			default:
				buildFromTypedExpr(field.expr, currentContext);			
		};
		fieldValue;	
}) {
												var ` = field.expr.expr;
												if (enumIndex ` == 14) {
													var ` = `[0];
													if (`.length == 2) {
														var ` = `[0];
														var ` = `[1];
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 13) {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 3) {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		if (enumIndex ` == 24) {
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var v = `;
																						var defaultExpr = `;
																						var init = `;
																						var tmpVar = `;
																						if (v.id == tmpVar.id && init != null) {
																							var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																							var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																							var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																								tmpVar.name.substr(1, null);
																							} else {
																								tmpVar.name;
																							}, null);
																							var ifExpr = {
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																									}, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																									}), metadata : {}, pos : pos};
																								}, {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																								}, defaultAst), metadata : {}, pos : pos};
																							};
																							if (ifExpr.metadata == null) {
																								ifExpr.metadata = {};
																							};
																							ifExpr.metadata.keepInlineInAssignment = true;
																							ifExpr;
																						} else {
																							var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
																								var ` = field.expr.expr;
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									{
																										var v = `;
																										{
																											var idKey = Std.string(v.id);
																											if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																												var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																												cast this.exists(idKey);
																											}) {
																												var mappedName = {
																													var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																													cast this.get(idKey);
																												};
																												{
																													var pos = null;
																													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																												};
																											} else {
																												reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																											};
																										};
																									};
																								} else {
																									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																								};
																							};
																							fieldValue;
																						};
																					};
																				} else {
																					var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
																						var ` = field.expr.expr;
																						if (enumIndex ` == 1) {
																							var ` = `[0];
																							{
																								var v = `;
																								{
																									var idKey = Std.string(v.id);
																									if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																										cast this.exists(idKey);
																									}) {
																										var mappedName = {
																											var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																											cast this.get(idKey);
																										};
																										{
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																										};
																									} else {
																										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																									};
																								};
																							};
																						} else {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						};
																					};
																					fieldValue;
																				};
																			};
																		} else {
																			var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
																				var ` = field.expr.expr;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var v = `;
																						{
																							var idKey = Std.string(v.id);
																							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																								cast this.exists(idKey);
																							}) {
																								var mappedName = {
																									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																									cast this.get(idKey);
																								};
																								{
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																								};
																							} else {
																								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																							};
																						};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			};
																			fieldValue;
																		};
																	} else {
																		var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
																			var ` = field.expr.expr;
																			if (enumIndex ` == 1) {
																				var ` = `[0];
																				{
																					var v = `;
																					{
																						var idKey = Std.string(v.id);
																						if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																							var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																							cast this.exists(idKey);
																						}) {
																							var mappedName = {
																								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																								cast this.get(idKey);
																							};
																							{
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																							};
																						} else {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						};
																					};
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			};
																		};
																		fieldValue;
																	};
																};
															} else {
																var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
																	var ` = field.expr.expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var v = `;
																			{
																				var idKey = Std.string(v.id);
																				if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																					var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																					cast this.exists(idKey);
																				}) {
																					var mappedName = {
																						var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																						cast this.get(idKey);
																					};
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			};
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	};
																};
																fieldValue;
															};
														};
													} else {
														var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
															var ` = field.expr.expr;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var v = `;
																	{
																		var idKey = Std.string(v.id);
																		if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																			var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																			cast this.exists(idKey);
																		}) {
																			var mappedName = {
																				var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																				cast this.get(idKey);
																			};
																			{
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		};
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														};
														fieldValue;
													};
												} else {
													var fieldValue = @:ast(switch (field.expr.expr) {
	case TLocal(v):
		var idKey = Std.string(v.id);
		if (currentContext != null && currentContext.tempVarRenameMap.exists(idKey)) {
			var mappedName = currentContext.tempVarRenameMap.get(idKey);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(field.expr, currentContext);
		};	
	default:
		buildFromTypedExpr(field.expr, currentContext);	
}) {
														var ` = field.expr.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var v = `;
																{
																	var idKey = Std.string(v.id);
																	if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && {
																		var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																		cast this.exists(idKey);
																	}) {
																		var mappedName = {
																			var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																			cast this.get(idKey);
																		};
																		{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	};
																};
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(field.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														};
													};
													fieldValue;
												};
											};
											pairs.push({key : key, value : fieldValue});
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EMap(pairs);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							if (el.length == 1 && {
								var ` = el[0].expr;
								if (enumIndex ` == 15) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									true;
								} else false;
							}) {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
							} else {
								if (el.length == 1) {
									@:ast(switch (el[0].expr) {
	case TBlock(stmts):
		var comprehension = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
		if (comprehension != null) {
			switch (comprehension.def) {
				case EFor(_, _, _, _, _):
					comprehension.def;				
				default:
					EList([buildFromTypedExpr(el[0], currentContext)]);				
			};
		} else {
			EList([buildFromTypedExpr(el[0], currentContext)]);
		};	
	default:
		EList([buildFromTypedExpr(el[0], currentContext)]);	
}) {
										var ` = el[0].expr;
										if (enumIndex ` == 14) {
											var ` = `[0];
											{
												var stmts = `;
												{
													var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
													if (comprehension != null) {
														@:ast(switch (comprehension.def) {
	case EFor(_, _, _, _, _):
		comprehension.def;	
	default:
		EList([buildFromTypedExpr(el[0], currentContext)]);	
}) {
															var ` = comprehension.def;
															if (enumIndex ` == 41) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																var ` = `[3];
																var ` = `[4];
																{
																	comprehension.def;
																};
															} else {
																reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext)]);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext)]);
													};
												};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext)]);
										};
									};
								} else {
									var hasIdiomaticEnums = false;
									{
										var ` = 0;
										while (` < el.length) {
											var e = el[`];
											++ `;
											@:ast(switch (e.expr) {
	case TCall(callTarget, _) if (callTarget != null && isEnumConstructor(callTarget) && hasIdiomaticMetadata(callTarget)):
		hasIdiomaticEnums = true;
		break;	
	case TCall(_, _):
		switch (e.t) {
			case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
				hasIdiomaticEnums = true;
				break;			
			default:
		};	
	default:
}) {
												var ` = e.expr;
												if (enumIndex ` == 9) {
													var ` = `[0];
													var ` = `[1];
													{
														var callTarget = `;
														if (callTarget != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(callTarget) && reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(callTarget)) {
															hasIdiomaticEnums = true;
															break;
														} else {
															@:ast(switch (e.t) {
	case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
		hasIdiomaticEnums = true;
		break;	
	default:
}) {
																var ` = e.t;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var enumRef = `;
																		if (enumRef.get().meta.has(":elixirIdiomatic")) {
																			hasIdiomaticEnums = true;
																			break;
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
										};
									};
									var elements = [];
									{
										var ` = 0;
										while (` < el.length) {
											var e = el[`];
											++ `;
											@:ast(switch (e.expr) {
	case TBlock(stmts):
		var comprehension = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
		if (comprehension != null) {
			elements.push(comprehension);
		} else if (looksLikeListBuildingBlock(stmts)) {
			var extractedElements = extractListElements(stmts);
			if (extractedElements != null && extractedElements.length > 0) {
				var valueASTs = [for (elem  in  extractedElements) buildFromTypedExpr(elem, currentContext)];
				elements.push(makeAST(EList(valueASTs)));
			} else {
				var blockStmts = [for (s  in  stmts) buildFromTypedExpr(s, currentContext)];
				var blockAST = makeAST(EBlock(blockStmts));
				if (blockAST.metadata == null) blockAST.metadata = { };
				blockAST.metadata.isUnrolledComprehension = true;
				var fnClause:EFnClause = { args : [], guard : null, body : blockAST };
				var anonymousFn = makeAST(EFn([fnClause]));
				var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
				elements.push(wrappedBlock);
			};
		} else {
			var blockAst = buildFromTypedExpr(e, currentContext);
			var fnClause:EFnClause = { args : [], guard : null, body : blockAst };
			var anonymousFn = makeAST(EFn([fnClause]));
			var wrappedBlock = makeAST(ECall(makeAST(EParen(anonymousFn)), "", []));
			elements.push(wrappedBlock);
		};	
	default:
		elements.push(buildFromTypedExpr(e, currentContext));	
}) {
												var ` = e.expr;
												if (enumIndex ` == 14) {
													var ` = `[0];
													{
														var stmts = `;
														{
															var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
															if (comprehension != null) {
																elements.push(comprehension);
															} else {
																if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(stmts)) {
																	var extractedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(stmts);
																	if (extractedElements != null && extractedElements.length > 0) {
																		var valueASTs = {
																			var ` = [];
																			{
																				var ` = 0;
																				while (` < extractedElements.length) {
																					var elem = extractedElements[`];
																					++ `;
																					`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(elem, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																				};
																			};
																			`;
																		};
																		elements.push({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																		});
																	} else {
																		var blockStmts = {
																			var ` = [];
																			{
																				var ` = 0;
																				while (` < stmts.length) {
																					var s = stmts[`];
																					++ `;
																					`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(s, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																				};
																			};
																			`;
																		};
																		var blockAST = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(blockStmts), metadata : {}, pos : pos};
																		};
																		if (blockAST.metadata == null) {
																			blockAST.metadata = {};
																		};
																		blockAST.metadata.isUnrolledComprehension = true;
																		var fnClause = {args : [], guard : null, body : blockAST};
																		var anonymousFn = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([fnClause]), metadata : {}, pos : pos};
																		};
																		var wrappedBlock = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EParen(anonymousFn), metadata : {}, pos : pos};
																			}, "", []), metadata : {}, pos : pos};
																		};
																		elements.push(wrappedBlock);
																	};
																} else {
																	var blockAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	var fnClause = {args : [], guard : null, body : blockAst};
																	var anonymousFn = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EFn([fnClause]), metadata : {}, pos : pos};
																	};
																	var wrappedBlock = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EParen(anonymousFn), metadata : {}, pos : pos};
																		}, "", []), metadata : {}, pos : pos};
																	};
																	elements.push(wrappedBlock);
																};
															};
														};
													};
												} else {
													elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
												};
											};
										};
									};
									reflaxe.elixir.ast.ElixirASTDef.EList(elements);
								};
							};
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						{
							var presenceHandled = false;
							if (e != null && reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e)) {
								var tag = reflaxe.elixir.ast.ElixirASTBuilder.extractEnumTag(e);
								if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
									tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
								};
								var args = {
									var ` = [];
									{
										var ` = 0;
										while (` < el.length) {
											var arg = el[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
										};
									};
									`;
								};
								var tupleDef = reflaxe.elixir.ast.ElixirASTDef.ETuple([{
									var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
										var this;
										this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
										cast this;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								}].concat(args));
								tupleDef;
							} else {
								var args = [];
								{
									var ` = 0;
									while (` < el.length) {
										var arg = el[`];
										++ `;
										var isFunctionRef = false;
										@:ast(switch (arg.expr) {
	case TField(_, FStatic(classRef, cf)):
		switch (cf.get().type) {
			case TFun(funcArgs, _):
				isFunctionRef = true;
				var target = buildFromTypedExpr(arg, currentContext);
				switch (target.def) {
					case EField(module, funcName):
						var arity = funcArgs.length;
						args.push(makeAST(ECapture(target, arity)));					
					default:
						args.push(target);					
				};			
			default:
				var field = cf.get();
				var isAtomField = false;
				var classType = classRef.get();
				switch (classType.kind) {
					case KAbstractImpl(abstractRef):
						var abstractType = abstractRef.get();
						switch (abstractType.type) {
							case TAbstract(underlyingRef, _):
								var underlyingType = underlyingRef.get();
								if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
									isAtomField = true;
								};							
							case _:
						};					
					case _:
				};
				if (isAtomField && field.expr() != null) {
					switch (field.expr().expr) {
						case TConst(TString(s)):
							args.push(makeAST(EAtom(s)));						
						case _:
							args.push(buildFromTypedExpr(arg, currentContext));						
					};
				} else {
					args.push(buildFromTypedExpr(arg, currentContext));
				};			
		};	
	default:
		var isAtomType = false;
		switch (arg.t) {
			case TAbstract(abstractRef, _):
				var abstractType = abstractRef.get();
				if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
					isAtomType = true;
				};			
			case _:
		};
		if (isAtomType) {
			switch (arg.expr) {
				case TConst(TString(s)):
					args.push(makeAST(EAtom(s)));				
				case TField(_, FStatic(classRef, cf)):
					var field = cf.get();
					if (field.expr() != null) {
						switch (field.expr().expr) {
							case TConst(TString(s)):
								args.push(makeAST(EAtom(s)));							
							default:
								args.push(buildFromTypedExpr(arg, currentContext));							
						};
					} else {
						args.push(buildFromTypedExpr(arg, currentContext));
					};				
				default:
					var builtArg = buildFromTypedExpr(arg, currentContext);
					switch (builtArg.def) {
						case EString(s):
							args.push(makeAST(EAtom(s)));						
						default:
							args.push(builtArg);						
					};				
			};
		} else {
			args.push(buildFromTypedExpr(arg, currentContext));
		};	
}) {
											var ` = arg.expr;
											if (enumIndex ` == 4) {
												var ` = `[0];
												var ` = `[1];
												if (enumIndex ` == 1) {
													var ` = `[0];
													var ` = `[1];
													{
														var classRef = `;
														var cf = `;
														{
															@:ast(switch (cf.get().type) {
	case TFun(funcArgs, _):
		isFunctionRef = true;
		var target = buildFromTypedExpr(arg, currentContext);
		switch (target.def) {
			case EField(module, funcName):
				var arity = funcArgs.length;
				args.push(makeAST(ECapture(target, arity)));			
			default:
				args.push(target);			
		};	
	default:
		var field = cf.get();
		var isAtomField = false;
		var classType = classRef.get();
		switch (classType.kind) {
			case KAbstractImpl(abstractRef):
				var abstractType = abstractRef.get();
				switch (abstractType.type) {
					case TAbstract(underlyingRef, _):
						var underlyingType = underlyingRef.get();
						if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
							isAtomField = true;
						};					
					case _:
				};			
			case _:
		};
		if (isAtomField && field.expr() != null) {
			switch (field.expr().expr) {
				case TConst(TString(s)):
					args.push(makeAST(EAtom(s)));				
				case _:
					args.push(buildFromTypedExpr(arg, currentContext));				
			};
		} else {
			args.push(buildFromTypedExpr(arg, currentContext));
		};	
}) {
																var ` = cf.get().type;
																if (enumIndex ` == 4) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var funcArgs = `;
																		{
																			isFunctionRef = true;
																			var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			@:ast(switch (target.def) {
	case EField(module, funcName):
		var arity = funcArgs.length;
		args.push(makeAST(ECapture(target, arity)));	
	default:
		args.push(target);	
}) {
																				var ` = target.def;
																				if (enumIndex ` == 28) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var module = `;
																						var funcName = `;
																						{
																							var arity = funcArgs.length;
																							args.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.ECapture(target, arity), metadata : {}, pos : pos};
																							});
																						};
																					};
																				} else {
																					args.push(target);
																				};
																			};
																		};
																	};
																} else {
																	var field = cf.get();
																	var isAtomField = false;
																	var classType = classRef.get();
																	@:ast(switch (classType.kind) {
	case KAbstractImpl(abstractRef):
		var abstractType = abstractRef.get();
		switch (abstractType.type) {
			case TAbstract(underlyingRef, _):
				var underlyingType = underlyingRef.get();
				if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
					isAtomField = true;
				};			
			case _:
		};	
	case _:
}) {
																		var ` = classType.kind;
																		if (enumIndex ` == 7) {
																			var ` = `[0];
																			{
																				var abstractRef = `;
																				{
																					var abstractType = abstractRef.get();
																					@:ast(switch (abstractType.type) {
	case TAbstract(underlyingRef, _):
		var underlyingType = underlyingRef.get();
		if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
			isAtomField = true;
		};	
	case _:
}) {
																						var ` = abstractType.type;
																						if (enumIndex ` == 8) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var underlyingRef = `;
																								{
																									var underlyingType = underlyingRef.get();
																									if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
																										isAtomField = true;
																									};
																								};
																							};
																						} else {};
																					};
																				};
																			};
																		} else {};
																	};
																	if (isAtomField && field.expr() != null) {
																		@:ast(switch (field.expr().expr) {
	case TConst(TString(s)):
		args.push(makeAST(EAtom(s)));	
	case _:
		args.push(buildFromTypedExpr(arg, currentContext));	
}) {
																			var ` = field.expr().expr;
																			if (enumIndex ` == 0) {
																				var ` = `[0];
																				if (enumIndex ` == 2) {
																					var ` = `[0];
																					{
																						var s = `;
																						{
																							args.push({
																								var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																									var this;
																									this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																									cast this;
																								});
																								var pos = null;
																								{def : def, metadata : {}, pos : pos};
																							});
																						};
																					};
																				} else {
																					args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																				};
																			} else {
																				args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																			};
																		};
																	} else {
																		args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																	};
																};
															};
														};
													};
												} else {
													var isAtomType = false;
													@:ast(switch (arg.t) {
	case TAbstract(abstractRef, _):
		var abstractType = abstractRef.get();
		if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
			isAtomType = true;
		};	
	case _:
}) {
														var ` = arg.t;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															{
																var abstractRef = `;
																{
																	var abstractType = abstractRef.get();
																	if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
																		isAtomType = true;
																	};
																};
															};
														} else {};
													};
													if (isAtomType) {
														@:ast(switch (arg.expr) {
	case TConst(TString(s)):
		args.push(makeAST(EAtom(s)));	
	case TField(_, FStatic(classRef, cf)):
		var field = cf.get();
		if (field.expr() != null) {
			switch (field.expr().expr) {
				case TConst(TString(s)):
					args.push(makeAST(EAtom(s)));				
				default:
					args.push(buildFromTypedExpr(arg, currentContext));				
			};
		} else {
			args.push(buildFromTypedExpr(arg, currentContext));
		};	
	default:
		var builtArg = buildFromTypedExpr(arg, currentContext);
		switch (builtArg.def) {
			case EString(s):
				args.push(makeAST(EAtom(s)));			
			default:
				args.push(builtArg);			
		};	
}) {
															var ` = arg.expr;
															switch (enumIndex `) {
																case 0: {
																	var ` = `[0];
																	if (enumIndex ` == 2) {
																		var ` = `[0];
																		{
																			var s = `;
																			{
																				args.push({
																					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																						var this;
																						this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																						cast this;
																					});
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				});
																			};
																		};
																	} else {
																		var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																			var ` = builtArg.def;
																			if (enumIndex ` == 32) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						args.push({
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						});
																					};
																				};
																			} else {
																				args.push(builtArg);
																			};
																		};
																	};
																};
																case 4: {
																	var ` = `[0];
																	var ` = `[1];
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var classRef = `;
																			var cf = `;
																			{
																				var field = cf.get();
																				if (field.expr() != null) {
																					@:ast(switch (field.expr().expr) {
	case TConst(TString(s)):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(buildFromTypedExpr(arg, currentContext));	
}) {
																						var ` = field.expr().expr;
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							if (enumIndex ` == 2) {
																								var ` = `[0];
																								{
																									var s = `;
																									{
																										args.push({
																											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																												var this;
																												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																												cast this;
																											});
																											var pos = null;
																											{def : def, metadata : {}, pos : pos};
																										});
																									};
																								};
																							} else {
																								args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																							};
																						} else {
																							args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																						};
																					};
																				} else {
																					args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																				};
																			};
																		};
																	} else {
																		var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																			var ` = builtArg.def;
																			if (enumIndex ` == 32) {
																				var ` = `[0];
																				{
																					var s = `;
																					{
																						args.push({
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						});
																					};
																				};
																			} else {
																				args.push(builtArg);
																			};
																		};
																	};
																};
																default: {
																	var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																		var ` = builtArg.def;
																		if (enumIndex ` == 32) {
																			var ` = `[0];
																			{
																				var s = `;
																				{
																					args.push({
																						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																							var this;
																							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																							cast this;
																						});
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					});
																				};
																			};
																		} else {
																			args.push(builtArg);
																		};
																	};
																}
															};
														};
													} else {
														args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
													};
												};
											} else {
												var isAtomType = false;
												@:ast(switch (arg.t) {
	case TAbstract(abstractRef, _):
		var abstractType = abstractRef.get();
		if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
			isAtomType = true;
		};	
	case _:
}) {
													var ` = arg.t;
													if (enumIndex ` == 8) {
														var ` = `[0];
														var ` = `[1];
														{
															var abstractRef = `;
															{
																var abstractType = abstractRef.get();
																if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
																	isAtomType = true;
																};
															};
														};
													} else {};
												};
												if (isAtomType) {
													@:ast(switch (arg.expr) {
	case TConst(TString(s)):
		args.push(makeAST(EAtom(s)));	
	case TField(_, FStatic(classRef, cf)):
		var field = cf.get();
		if (field.expr() != null) {
			switch (field.expr().expr) {
				case TConst(TString(s)):
					args.push(makeAST(EAtom(s)));				
				default:
					args.push(buildFromTypedExpr(arg, currentContext));				
			};
		} else {
			args.push(buildFromTypedExpr(arg, currentContext));
		};	
	default:
		var builtArg = buildFromTypedExpr(arg, currentContext);
		switch (builtArg.def) {
			case EString(s):
				args.push(makeAST(EAtom(s)));			
			default:
				args.push(builtArg);			
		};	
}) {
														var ` = arg.expr;
														switch (enumIndex `) {
															case 0: {
																var ` = `[0];
																if (enumIndex ` == 2) {
																	var ` = `[0];
																	{
																		var s = `;
																		{
																			args.push({
																				var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																					var this;
																					this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																					cast this;
																				});
																				var pos = null;
																				{def : def, metadata : {}, pos : pos};
																			});
																		};
																	};
																} else {
																	var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																		var ` = builtArg.def;
																		if (enumIndex ` == 32) {
																			var ` = `[0];
																			{
																				var s = `;
																				{
																					args.push({
																						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																							var this;
																							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																							cast this;
																						});
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					});
																				};
																			};
																		} else {
																			args.push(builtArg);
																		};
																	};
																};
															};
															case 4: {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var classRef = `;
																		var cf = `;
																		{
																			var field = cf.get();
																			if (field.expr() != null) {
																				@:ast(switch (field.expr().expr) {
	case TConst(TString(s)):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(buildFromTypedExpr(arg, currentContext));	
}) {
																					var ` = field.expr().expr;
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						if (enumIndex ` == 2) {
																							var ` = `[0];
																							{
																								var s = `;
																								{
																									args.push({
																										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																											var this;
																											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																											cast this;
																										});
																										var pos = null;
																										{def : def, metadata : {}, pos : pos};
																									});
																								};
																							};
																						} else {
																							args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																						};
																					} else {
																						args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																					};
																				};
																			} else {
																				args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																			};
																		};
																	};
																} else {
																	var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																		var ` = builtArg.def;
																		if (enumIndex ` == 32) {
																			var ` = `[0];
																			{
																				var s = `;
																				{
																					args.push({
																						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																							var this;
																							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																							cast this;
																						});
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					});
																				};
																			};
																		} else {
																			args.push(builtArg);
																		};
																	};
																};
															};
															default: {
																var builtArg = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																@:ast(switch (builtArg.def) {
	case EString(s):
		args.push(makeAST(EAtom(s)));	
	default:
		args.push(builtArg);	
}) {
																	var ` = builtArg.def;
																	if (enumIndex ` == 32) {
																		var ` = `[0];
																		{
																			var s = `;
																			{
																				args.push({
																					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																						var this;
																						this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																						cast this;
																					});
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				});
																			};
																		};
																	} else {
																		args.push(builtArg);
																	};
																};
															}
														};
													};
												} else {
													args.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
												};
											};
										};
									};
								};
								if (e != null) {
									@:ast(switch (e.expr) {
	case TField(_, FStatic(classRef, cf)):
		var classType = classRef.get();
		var field = cf.get();
		var methodName = field.name;
		if (field.meta.has(":native")) {
			var nativeMeta = field.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						methodName = s;					
					default:
				};
			};
		};
		var isSameModuleCall = false;
		if (currentContext.currentModule != null && classType.name == currentContext.currentModule) {
			if (classType.isExtern) {
				isSameModuleCall = false;
			} else if (currentContext.currentModuleHasPresence && currentContext.behaviorTransformer != null) {
				isSameModuleCall = false;
			} else {
				isSameModuleCall = true;
			};
		};
		if (isSameModuleCall) {
			var elixirMethodName = toSnakeCase(methodName);
			return ECall(null, elixirMethodName, args);
		};
		if (currentContext.behaviorTransformer != null && currentContext.currentModuleHasPresence) {
			var transformedCall = currentContext.behaviorTransformer.transformMethodCall(classType.name, methodName, args, true);
			if (transformedCall != null) {
				return transformedCall.def;
			};
		} else if (classType.name == "Reflect") {
			switch (methodName) {
				case "hasField":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						trackDependency("Map");
						return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
					};				
				case "field":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						trackDependency("Map");
						return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
					};				
				case "setField":
					if (args.length == 3) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var value = args[2];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
					};				
				case "fields":
					if (args.length == 1) {
						return ERemoteCall(makeAST(EVar("Map")), "keys", args);
					};				
				case "isObject":
					if (args.length == 1) {
						return ECall(null, "is_map", args);
					};				
				case "deleteField":
					if (args.length == 2) {
						var obj = args[0];
						var fieldNameExpr = args[1];
						var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
						return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
					};				
				case "copy":
					if (args.length == 1) {
						return args[0].def;
					};				
				case "compare":
					if (args.length == 2) {
						var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
						var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
						var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
						var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
						var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
						return ECond([ltClause, gtClause, trueClause]);
					};				
				case "isEnumValue":
					if (args.length == 1) {
						var isTuple = ECall(null, "is_tuple", args);
						var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
						var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
						return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
					};				
				case "callMethod":
					if (args.length == 3) {
						return ECall(null, "apply", [args[1], args[2]]);
					};				
				default:
			};
		} else if (classType.meta.has(":native")) {
			var nativeModuleName = "";
			var nativeMeta = classType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						nativeModuleName = s;					
					default:
				};
			};
			if (nativeModuleName != "") {
				if (classType.name == "Presence" && nativeModuleName == "Phoenix.Presence") {
					presenceHandled = true;
				};
				var elixirMethodName = toSnakeCase(methodName);
				trackDependency(nativeModuleName);
				return ERemoteCall(makeAST(EVar(nativeModuleName)), elixirMethodName, args);
			};
		} else {
			var moduleName = classType.name;
			trackDependency(moduleName);
			if (currentContext.compiler != null && classType.pack.length > 0) {
				currentContext.compiler.modulePackages.set(moduleName, classType.pack);
			};
		};	
	default:
}) {
										var ` = e.expr;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 1) {
												var ` = `[0];
												var ` = `[1];
												{
													var classRef = `;
													var cf = `;
													{
														var classType = classRef.get();
														var field = cf.get();
														var methodName = field.name;
														if (field.meta.has(":native")) {
															var nativeMeta = field.meta.extract(":native");
															if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		methodName = s;	
	default:
}) {
																	var ` = nativeMeta[0].params[0].expr;
																	if (enumIndex ` == 0) {
																		var ` = `[0];
																		if (enumIndex ` == 2) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var s = `;
																				{
																					methodName = s;
																				};
																			};
																		} else {};
																	} else {};
																};
															};
														};
														var isSameModuleCall = false;
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentModule != null && classType.name == reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentModule) {
															if (classType.isExtern) {
																isSameModuleCall = false;
															} else {
																if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentModuleHasPresence && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.behaviorTransformer != null) {
																	isSameModuleCall = false;
																} else {
																	isSameModuleCall = true;
																};
															};
														};
														if (isSameModuleCall) {
															var elixirMethodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(methodName);
															return reflaxe.elixir.ast.ElixirASTDef.ECall(null, elixirMethodName, args);
														};
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.behaviorTransformer != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentModuleHasPresence) {
															var transformedCall = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.behaviorTransformer.transformMethodCall(classType.name, methodName, args, true);
															if (transformedCall != null) {
																return transformedCall.def;
															};
														} else {
															if (classType.name == "Reflect") {
																@:ast(switch (methodName) {
	case "hasField":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			trackDependency("Map");
			return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, atomField]);
		};	
	case "field":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			trackDependency("Map");
			return ERemoteCall(makeAST(EVar("Map")), "get", [obj, atomField]);
		};	
	case "setField":
		if (args.length == 3) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var value = args[2];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			return ERemoteCall(makeAST(EVar("Map")), "put", [obj, atomField, value]);
		};	
	case "fields":
		if (args.length == 1) {
			return ERemoteCall(makeAST(EVar("Map")), "keys", args);
		};	
	case "isObject":
		if (args.length == 1) {
			return ECall(null, "is_map", args);
		};	
	case "deleteField":
		if (args.length == 2) {
			var obj = args[0];
			var fieldNameExpr = args[1];
			var atomField = makeAST(ERemoteCall(makeAST(EVar("String")), "to_atom", [fieldNameExpr]));
			return ERemoteCall(makeAST(EVar("Map")), "delete", [obj, atomField]);
		};	
	case "copy":
		if (args.length == 1) {
			return args[0].def;
		};	
	case "compare":
		if (args.length == 2) {
			var lt = EBinary(EBinaryOp.Less, args[0], args[1]);
			var gt = EBinary(EBinaryOp.Greater, args[0], args[1]);
			var ltClause:ECondClause = { condition : makeAST(lt), body : makeAST(EInteger(-1)) };
			var gtClause:ECondClause = { condition : makeAST(gt), body : makeAST(EInteger(1)) };
			var trueClause:ECondClause = { condition : makeAST(EBoolean(true)), body : makeAST(EInteger(0)) };
			return ECond([ltClause, gtClause, trueClause]);
		};	
	case "isEnumValue":
		if (args.length == 1) {
			var isTuple = ECall(null, "is_tuple", args);
			var elem0 = ECall(null, "elem", [args[0], makeAST(EInteger(0))]);
			var isAtom = ECall(null, "is_atom", [makeAST(elem0)]);
			return EBinary(EBinaryOp.And, makeAST(isTuple), makeAST(isAtom));
		};	
	case "callMethod":
		if (args.length == 3) {
			return ECall(null, "apply", [args[1], args[2]]);
		};	
	default:
}) switch (methodName) {
																	case "callMethod": {
																		{
																			if (args.length == 3) {
																				return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "apply", [args[1], args[2]]);
																			};
																		};
																	};
																	case "compare": {
																		{
																			if (args.length == 2) {
																				var lt = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Less, args[0], args[1]);
																				var gt = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Greater, args[0], args[1]);
																				var ltClause = {condition : {
																					var pos = null;
																					{def : lt, metadata : {}, pos : pos};
																				}, body : {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
																				}};
																				var gtClause = {condition : {
																					var pos = null;
																					{def : gt, metadata : {}, pos : pos};
																				}, body : {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																				}};
																				var trueClause = {condition : {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), metadata : {}, pos : pos};
																				}, body : {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
																				}};
																				return reflaxe.elixir.ast.ElixirASTDef.ECond([ltClause, gtClause, trueClause]);
																			};
																		};
																	};
																	case "copy": {
																		{
																			if (args.length == 1) {
																				return args[0].def;
																			};
																		};
																	};
																	case "deleteField": {
																		{
																			if (args.length == 2) {
																				var obj = args[0];
																				var fieldNameExpr = args[1];
																				var atomField = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																					}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																				};
																				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "delete", [obj, atomField]);
																			};
																		};
																	};
																	case "field": {
																		{
																			if (args.length == 2) {
																				var obj = args[0];
																				var fieldNameExpr = args[1];
																				var atomField = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																					}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																				};
																				reflaxe.elixir.ast.ElixirASTBuilder.trackDependency("Map");
																				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "get", [obj, atomField]);
																			};
																		};
																	};
																	case "fields": {
																		{
																			if (args.length == 1) {
																				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "keys", args);
																			};
																		};
																	};
																	case "hasField": {
																		{
																			if (args.length == 2) {
																				var obj = args[0];
																				var fieldNameExpr = args[1];
																				var atomField = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																					}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																				};
																				reflaxe.elixir.ast.ElixirASTBuilder.trackDependency("Map");
																				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "has_key?", [obj, atomField]);
																			};
																		};
																	};
																	case "isEnumValue": {
																		{
																			if (args.length == 1) {
																				var isTuple = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_tuple", args);
																				var elem0 = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [args[0], {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
																				}]);
																				var isAtom = reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_atom", [{
																					var pos = null;
																					{def : elem0, metadata : {}, pos : pos};
																				}]);
																				return reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.And, {
																					var pos = null;
																					{def : isTuple, metadata : {}, pos : pos};
																				}, {
																					var pos = null;
																					{def : isAtom, metadata : {}, pos : pos};
																				});
																			};
																		};
																	};
																	case "isObject": {
																		{
																			if (args.length == 1) {
																				return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "is_map", args);
																			};
																		};
																	};
																	case "setField": {
																		{
																			if (args.length == 3) {
																				var obj = args[0];
																				var fieldNameExpr = args[1];
																				var value = args[2];
																				var atomField = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																					}, "to_atom", [fieldNameExpr]), metadata : {}, pos : pos};
																				};
																				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "put", [obj, atomField, value]);
																			};
																		};
																	};
																	default: {}
																};
															} else {
																if (classType.meta.has(":native")) {
																	var nativeModuleName = "";
																	var nativeMeta = classType.meta.extract(":native");
																	if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																		@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		nativeModuleName = s;	
	default:
}) {
																			var ` = nativeMeta[0].params[0].expr;
																			if (enumIndex ` == 0) {
																				var ` = `[0];
																				if (enumIndex ` == 2) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var s = `;
																						{
																							nativeModuleName = s;
																						};
																					};
																				} else {};
																			} else {};
																		};
																	};
																	if (nativeModuleName != "") {
																		if (classType.name == "Presence" && nativeModuleName == "Phoenix.Presence") {
																			presenceHandled = true;
																		};
																		var elixirMethodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(methodName);
																		reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(nativeModuleName);
																		return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(nativeModuleName), metadata : {}, pos : pos};
																		}, elixirMethodName, args);
																	};
																} else {
																	var moduleName = classType.name;
																	reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(moduleName);
																	if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler != null && classType.pack.length > 0) {
																		{
																			var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.modulePackages;
																			var value = classType.pack;
																			cast this.set(moduleName, value);
																		};
																	};
																};
															};
														};
													};
												};
											} else {};
										} else {};
									};
								};
								var target = if (presenceHandled) {
									null;
								} else {
									if (e != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									} else {
										null;
									};
								};
								@:ast(switch (e.expr) {
	case TIdent("__elixir__"):
		if (args.length > 0) {
			switch (args[0].def) {
				case EString(code):
					var processedCode = code;
					if (args.length > 1) {
						for (i  in  1 ... args.length) {
							var paramStr = ElixirASTPrinter.printAST(args[i]);
							var placeholder = "{${i-1}}";
							processedCode = StringTools.replace(processedCode, placeholder, paramStr);
						};
					};
					ERaw(processedCode);				
				default:
					ECall(target, "call", args);				
			};
		} else {
			ECall(target, "call", args);
		};	
	case TField(obj, fa):
		var fieldName = extractFieldName(fa);
		fieldName = toSnakeCase(fieldName);
		var objAst = switch (obj.expr) {
			case TLocal(v):
				var varName = v.name;
				if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
					var mappedName = currentContext.currentClauseContext.localToName.get(v.id);
					makeAST(EVar(mappedName));
				} else {
					buildFromTypedExpr(obj, currentContext);
				};			
			default:
				buildFromTypedExpr(obj, currentContext);			
		};
		var typeModule = getExternNativeModuleNameFromType(obj.t);
		if (typeModule != null) {
			trackDependency(typeModule);
			return ERemoteCall(makeAST(EVar(typeModule)), fieldName, [objAst].concat(args));
		};
		switch (fa) {
			case FInstance(cRef, _, cfRef):
				var cls = cRef.get();
				if (cls.isExtern && cls.meta.has(":native")) {
					var nativeMeta = cls.meta.extract(":native");
					var moduleName:Null<String> = null;
					if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
						switch (nativeMeta[0].params[0].expr) {
							case EConst(CString(s, _)):
								moduleName = s;							
							default:
						};
					};
					if (moduleName != null) {
						var methodName = fieldName;
						var cf = cfRef.get();
						if (cf.meta.has(":native")) {
							var mMeta = cf.meta.extract(":native");
							if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
								switch (mMeta[0].params[0].expr) {
									case EConst(CString(ns, _)):
										methodName = toSnakeCase(ns);									
									default:
								};
							};
						};
						trackDependency(moduleName);
						return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
					};
				};			
			default:
		};
		if (fieldName == "elem" && args.length == 1) {
			return ECall(null, "elem", [objAst, args[0]]);
		};
		if (isAssertClass(obj)) {
			var assertFunc = switch (fieldName) {
				case "equals":
					"assert";				
				case "notEquals":
					"refute";				
				case "isTrue":
					"assert";				
				case "isFalse":
					"refute";				
				case "isNull":
					"assert";				
				case "isNotNull":
					"refute";				
				case "fail":
					"flunk";				
				default:
					"assert";				
			};
			var assertArgs = switch (fieldName) {
				case "equals" if (args.length >= 2):
					[makeAST(EBinary(Equal, args[0], args[1]))];				
				case "notEquals" if (args.length >= 2):
					[makeAST(EBinary(Equal, args[0], args[1]))];				
				case "isNull" if (args.length >= 1):
					[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];				
				case "isNotNull" if (args.length >= 1):
					[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];				
				default:
					args;				
			};
			return ECall(null, assertFunc, assertArgs);
		} else if (fieldName == "hxx" && isHXXModule(obj)) {
			if (args.length == 1) {
				var templateContent = collectTemplateContent(args[0]);
				ESigil("H", templateContent, "");
			} else {
				ECall(objAst, fieldName, args);
			};
		} else if (isModuleCall(obj)) {
			var hasNativeMetadata = false;
			var nativeName:String = null;
			switch (fa) {
				case FStatic(_, cf):
					var classField = cf.get();
					if (classField.meta.has(":native")) {
						var nativeMeta = classField.meta.extract(":native");
						if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
							switch (nativeMeta[0].params[0].expr) {
								case EConst(CString(s, _)):
									hasNativeMetadata = true;
									nativeName = s;								
								default:
							};
						};
					};				
				default:
			};
			if (hasNativeMetadata && nativeName != null) {
				var parts = nativeName.split(".");
				if (parts.length > 1) {
					var module = parts.slice(0, parts.length - 1).join(".");
					var funcName = parts[parts.length - 1];
					trackDependency(module);
					return ERemoteCall(makeAST(EVar(module)), funcName, args);
				} else {
					return ERemoteCall(objAst, nativeName, args);
				};
			} else {
				var elixirFuncName = toSnakeCase(fieldName);
				return ERemoteCall(objAst, elixirFuncName, args);
			};
		} else {
			var methodHasElixirInjection = false;
			var expandedElixir:ElixirAST = null;
			switch (fa) {
				case FInstance(_, _, cf):
					var classField = cf.get();
					var methodExpr = classField.expr();
					if (methodExpr != null) {
						expandedElixir = tryExpandElixirInjection(methodExpr, obj, el, currentContext);
						methodHasElixirInjection = (expandedElixir != null);
					};				
				default:
			};
			if (methodHasElixirInjection && expandedElixir != null) {
				return expandedElixir.def;
			} else if (isArrayType(obj.t)) {
				switch (fieldName) {
					case "filter" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);					
					case "map" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);					
					case "push" if (args.length == 1):
						var concat = makeAST(EBinary(Concat, objAst, makeAST(EList([args[0]]))));
						switch (objAst.def) {
							case EVar(name):
								EBinary(Match, objAst, concat);							
							default:
								concat.def;							
						};					
					default:
						ECall(objAst, fieldName, args);					
				};
			} else if (isMapType(obj.t)) {
				switch (fieldName) {
					case "set" if (args.length == 2):
						var callAst = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args)));
						switch (objAst.def) {
							case EVar(_):
								EBinary(Match, objAst, callAst);							
							default:
								callAst.def;							
						};					
					case "get" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));					
					case "remove" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));					
					case "exists" if (args.length == 1):
						ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));					
					case "keys" if (args.length == 0):
						ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);					
					case "values" if (args.length == 0):
						ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);					
					default:
						ECall(objAst, fieldName, args);					
				};
			} else {
				ECall(objAst, fieldName, args);
			};
		};	
	case TLocal(v):
		var isFunctionVar = switch (v.t) {
			case TFun(_, _):
				true;			
			case TAbstract(t, params):
				var abs = t.get();
				if (abs.name == "Function" || abs.name == "Fn") {
					true;
				} else if (abs.name == "Null" && params.length == 1) {
					switch (params[0]) {
						case TFun(_, _):
							true;						
						default:
							false;						
					};
				} else {
					false;
				};			
			default:
				false;			
		};
		if (isFunctionVar) {
			ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
		} else {
			ECall(null, toElixirVarName(v.name), args);
		};	
	default:
		if (target != null) {
			switch (target.def) {
				case EField(module, funcName):
					ERemoteCall(module, funcName, args);				
				default:
					ECall(target, "call", args);				
			};
		} else {
			ECall(null, "unknown_call", args);
		};	
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var v = `;
												{
													var isFunctionVar = @:ast(switch (v.t) {
	case TFun(_, _):
		true;	
	case TAbstract(t, params):
		var abs = t.get();
		if (abs.name == "Function" || abs.name == "Fn") {
			true;
		} else if (abs.name == "Null" && params.length == 1) {
			switch (params[0]) {
				case TFun(_, _):
					true;				
				default:
					false;				
			};
		} else {
			false;
		};	
	default:
		false;	
}) {
														var ` = v.t;
														switch (enumIndex `) {
															case 4: {
																var ` = `[0];
																var ` = `[1];
																{
																	true;
																};
															};
															case 8: {
																var ` = `[0];
																var ` = `[1];
																{
																	var t = `;
																	var params = `;
																	{
																		var abs = t.get();
																		if (abs.name == "Function" || abs.name == "Fn") {
																			true;
																		} else {
																			if (abs.name == "Null" && params.length == 1) {
																				@:ast(switch (params[0]) {
	case TFun(_, _):
		true;	
	default:
		false;	
}) {
																					var ` = params[0];
																					if (enumIndex ` == 4) {
																						var ` = `[0];
																						var ` = `[1];
																						{
																							true;
																						};
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		};
																	};
																};
															};
															default: {
																false;
															}
														};
													};
													if (isFunctionVar) {
														reflaxe.elixir.ast.ElixirASTDef.ECall({
															var def = reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}, "", args);
													} else {
														reflaxe.elixir.ast.ElixirASTDef.ECall(null, reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null), args);
													};
												};
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												var obj = `;
												var fa = `;
												{
													var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
													fieldName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
													var objAst = @:ast(switch (obj.expr) {
	case TLocal(v):
		var varName = v.name;
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
			var mappedName = currentContext.currentClauseContext.localToName.get(v.id);
			makeAST(EVar(mappedName));
		} else {
			buildFromTypedExpr(obj, currentContext);
		};	
	default:
		buildFromTypedExpr(obj, currentContext);	
}) {
														var ` = obj.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var v = `;
																{
																	var varName = v.name;
																	if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && {
																		var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
																		var key = v.id;
																		cast this.exists(key);
																	}) {
																		var mappedName = {
																			var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
																			var key = v.id;
																			cast this.get(key);
																		};
																		{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mappedName), metadata : {}, pos : pos};
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(obj, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	};
																};
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(obj, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														};
													};
													var typeModule = reflaxe.elixir.ast.ElixirASTBuilder.getExternNativeModuleNameFromType(obj.t);
													if (typeModule != null) {
														reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(typeModule);
														return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(typeModule), metadata : {}, pos : pos};
														}, fieldName, [objAst].concat(args));
													};
													@:ast(switch (fa) {
	case FInstance(cRef, _, cfRef):
		var cls = cRef.get();
		if (cls.isExtern && cls.meta.has(":native")) {
			var nativeMeta = cls.meta.extract(":native");
			var moduleName:Null<String> = null;
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						moduleName = s;					
					default:
				};
			};
			if (moduleName != null) {
				var methodName = fieldName;
				var cf = cfRef.get();
				if (cf.meta.has(":native")) {
					var mMeta = cf.meta.extract(":native");
					if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
						switch (mMeta[0].params[0].expr) {
							case EConst(CString(ns, _)):
								methodName = toSnakeCase(ns);							
							default:
						};
					};
				};
				trackDependency(moduleName);
				return ERemoteCall(makeAST(EVar(moduleName)), methodName, [objAst].concat(args));
			};
		};	
	default:
}) if (enumIndex fa == 0) {
														var ` = fa[0];
														var ` = fa[1];
														var ` = fa[2];
														{
															var cRef = `;
															var cfRef = `;
															{
																var cls = cRef.get();
																if (cls.isExtern && cls.meta.has(":native")) {
																	var nativeMeta = cls.meta.extract(":native");
																	var moduleName = null;
																	if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																		@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		moduleName = s;	
	default:
}) {
																			var ` = nativeMeta[0].params[0].expr;
																			if (enumIndex ` == 0) {
																				var ` = `[0];
																				if (enumIndex ` == 2) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var s = `;
																						{
																							moduleName = s;
																						};
																					};
																				} else {};
																			} else {};
																		};
																	};
																	if (moduleName != null) {
																		var methodName = fieldName;
																		var cf = cfRef.get();
																		if (cf.meta.has(":native")) {
																			var mMeta = cf.meta.extract(":native");
																			if (mMeta.length > 0 && mMeta[0].params != null && mMeta[0].params.length > 0) {
																				@:ast(switch (mMeta[0].params[0].expr) {
	case EConst(CString(ns, _)):
		methodName = toSnakeCase(ns);	
	default:
}) {
																					var ` = mMeta[0].params[0].expr;
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						if (enumIndex ` == 2) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var ns = `;
																								{
																									methodName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(ns);
																								};
																							};
																						} else {};
																					} else {};
																				};
																			};
																		};
																		reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(moduleName);
																		return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
																		}, methodName, [objAst].concat(args));
																	};
																};
															};
														};
													} else {};
													if (fieldName == "elem" && args.length == 1) {
														return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [objAst, args[0]]);
													};
													if (reflaxe.elixir.ast.ElixirASTBuilder.isAssertClass(obj)) {
														var assertFunc = @:ast(switch (fieldName) {
	case "equals":
		"assert";	
	case "notEquals":
		"refute";	
	case "isTrue":
		"assert";	
	case "isFalse":
		"refute";	
	case "isNull":
		"assert";	
	case "isNotNull":
		"refute";	
	case "fail":
		"flunk";	
	default:
		"assert";	
}) switch (fieldName) {
															case "equals": {
																{
																	"assert";
																};
															};
															case "fail": {
																{
																	"flunk";
																};
															};
															case "isFalse": {
																{
																	"refute";
																};
															};
															case "isNotNull": {
																{
																	"refute";
																};
															};
															case "isNull": {
																{
																	"assert";
																};
															};
															case "isTrue": {
																{
																	"assert";
																};
															};
															case "notEquals": {
																{
																	"refute";
																};
															};
															default: {
																"assert";
															}
														};
														var assertArgs = @:ast(switch (fieldName) {
	case "equals" if (args.length >= 2):
		[makeAST(EBinary(Equal, args[0], args[1]))];	
	case "notEquals" if (args.length >= 2):
		[makeAST(EBinary(Equal, args[0], args[1]))];	
	case "isNull" if (args.length >= 1):
		[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];	
	case "isNotNull" if (args.length >= 1):
		[makeAST(EBinary(Equal, args[0], makeAST(ENil)))];	
	default:
		args;	
}) switch (fieldName) {
															case "equals": {
																if (args.length >= 2) {
																	[{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, args[0], args[1]), metadata : {}, pos : pos};
																	}];
																} else {
																	args;
																};
															};
															case "isNotNull": {
																if (args.length >= 1) {
																	[{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, args[0], {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	}];
																} else {
																	args;
																};
															};
															case "isNull": {
																if (args.length >= 1) {
																	[{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, args[0], {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	}];
																} else {
																	args;
																};
															};
															case "notEquals": {
																if (args.length >= 2) {
																	[{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, args[0], args[1]), metadata : {}, pos : pos};
																	}];
																} else {
																	args;
																};
															};
															default: {
																args;
															}
														};
														return reflaxe.elixir.ast.ElixirASTDef.ECall(null, assertFunc, assertArgs);
													} else {
														if (fieldName == "hxx" && reflaxe.elixir.ast.ElixirASTBuilder.isHXXModule(obj)) {
															if (args.length == 1) {
																var templateContent = reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(args[0]);
																reflaxe.elixir.ast.ElixirASTDef.ESigil("H", templateContent, "");
															} else {
																reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
															};
														} else {
															if (reflaxe.elixir.ast.ElixirASTBuilder.isModuleCall(obj)) {
																var hasNativeMetadata = false;
																var nativeName = null;
																@:ast(switch (fa) {
	case FStatic(_, cf):
		var classField = cf.get();
		if (classField.meta.has(":native")) {
			var nativeMeta = classField.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				switch (nativeMeta[0].params[0].expr) {
					case EConst(CString(s, _)):
						hasNativeMetadata = true;
						nativeName = s;					
					default:
				};
			};
		};	
	default:
}) if (enumIndex fa == 1) {
																	var ` = fa[0];
																	var ` = fa[1];
																	{
																		var cf = `;
																		{
																			var classField = cf.get();
																			if (classField.meta.has(":native")) {
																				var nativeMeta = classField.meta.extract(":native");
																				if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
																					@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		hasNativeMetadata = true;
		nativeName = s;	
	default:
}) {
																						var ` = nativeMeta[0].params[0].expr;
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							if (enumIndex ` == 2) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var s = `;
																									{
																										hasNativeMetadata = true;
																										nativeName = s;
																									};
																								};
																							} else {};
																						} else {};
																					};
																				};
																			};
																		};
																	};
																} else {};
																if (hasNativeMetadata && nativeName != null) {
																	var parts = nativeName.split(".");
																	if (parts.length > 1) {
																		var module = parts.slice(0, parts.length - 1).join(".");
																		var funcName = parts[parts.length - 1];
																		reflaxe.elixir.ast.ElixirASTBuilder.trackDependency(module);
																		return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(module), metadata : {}, pos : pos};
																		}, funcName, args);
																	} else {
																		return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(objAst, nativeName, args);
																	};
																} else {
																	var elixirFuncName = reflaxe.elixir.ast.ElixirASTBuilder.toSnakeCase(fieldName);
																	return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(objAst, elixirFuncName, args);
																};
															} else {
																var methodHasElixirInjection = false;
																var expandedElixir = null;
																@:ast(switch (fa) {
	case FInstance(_, _, cf):
		var classField = cf.get();
		var methodExpr = classField.expr();
		if (methodExpr != null) {
			expandedElixir = tryExpandElixirInjection(methodExpr, obj, el, currentContext);
			methodHasElixirInjection = (expandedElixir != null);
		};	
	default:
}) if (enumIndex fa == 0) {
																	var ` = fa[0];
																	var ` = fa[1];
																	var ` = fa[2];
																	{
																		var cf = `;
																		{
																			var classField = cf.get();
																			var methodExpr = classField.expr();
																			if (methodExpr != null) {
																				expandedElixir = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirInjection(methodExpr, obj, el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				methodHasElixirInjection = (expandedElixir != null);
																			};
																		};
																	};
																} else {};
																if (methodHasElixirInjection && expandedElixir != null) {
																	return expandedElixir.def;
																} else {
																	if (reflaxe.elixir.ast.ElixirASTBuilder.isArrayType(obj.t)) {
																		@:ast(switch (fieldName) {
	case "filter" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);	
	case "map" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);	
	case "push" if (args.length == 1):
		var concat = makeAST(EBinary(Concat, objAst, makeAST(EList([args[0]]))));
		switch (objAst.def) {
			case EVar(name):
				EBinary(Match, objAst, concat);			
			default:
				concat.def;			
		};	
	default:
		ECall(objAst, fieldName, args);	
}) switch (fieldName) {
																			case "filter": {
																				if (args.length == 1) {
																					reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																					}, "filter", [objAst, args[0]]);
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			case "map": {
																				if (args.length == 1) {
																					reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																					}, "map", [objAst, args[0]]);
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			case "push": {
																				if (args.length == 1) {
																					var concat = {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, objAst, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EList([args[0]]), metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					};
																					@:ast(switch (objAst.def) {
	case EVar(name):
		EBinary(Match, objAst, concat);	
	default:
		concat.def;	
}) {
																						var ` = objAst.def;
																						if (enumIndex ` == 38) {
																							var ` = `[0];
																							{
																								var name = `;
																								{
																									reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, objAst, concat);
																								};
																							};
																						} else {
																							concat.def;
																						};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				};
																			};
																			default: {
																				reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																			}
																		};
																	} else {
																		if (reflaxe.elixir.ast.ElixirASTBuilder.isMapType(obj.t)) {
																			@:ast(switch (fieldName) {
	case "set" if (args.length == 2):
		var callAst = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args)));
		switch (objAst.def) {
			case EVar(_):
				EBinary(Match, objAst, callAst);			
			default:
				callAst.def;			
		};	
	case "get" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));	
	case "remove" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));	
	case "exists" if (args.length == 1):
		ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));	
	case "keys" if (args.length == 0):
		ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);	
	case "values" if (args.length == 0):
		ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);	
	default:
		ECall(objAst, fieldName, args);	
}) switch (fieldName) {
																				case "exists": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "has_key?", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "get": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "get", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "keys": {
																					if (args.length == 0) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "keys", [objAst]);
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "remove": {
																					if (args.length == 1) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "delete", [objAst].concat(args));
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "set": {
																					if (args.length == 2) {
																						var callAst = {
																							var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																							}, "put", [objAst].concat(args));
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						};
																						@:ast(switch (objAst.def) {
	case EVar(_):
		EBinary(Match, objAst, callAst);	
	default:
		callAst.def;	
}) {
																							var ` = objAst.def;
																							if (enumIndex ` == 38) {
																								var ` = `[0];
																								{
																									reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, objAst, callAst);
																								};
																							} else {
																								callAst.def;
																							};
																						};
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				case "values": {
																					if (args.length == 0) {
																						reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "values", [objAst]);
																					} else {
																						reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																					};
																				};
																				default: {
																					reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																				}
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTDef.ECall(objAst, fieldName, args);
																		};
																	};
																};
															};
														};
													};
												};
											};
										};
										case 28: {
											var ` = `[0];
											if (` == "__elixir__") {
												{
													if (args.length > 0) {
														@:ast(switch (args[0].def) {
	case EString(code):
		var processedCode = code;
		if (args.length > 1) {
			for (i  in  1 ... args.length) {
				var paramStr = ElixirASTPrinter.printAST(args[i]);
				var placeholder = "{${i-1}}";
				processedCode = StringTools.replace(processedCode, placeholder, paramStr);
			};
		};
		ERaw(processedCode);	
	default:
		ECall(target, "call", args);	
}) {
															var ` = args[0].def;
															if (enumIndex ` == 32) {
																var ` = `[0];
																{
																	var code = `;
																	{
																		var processedCode = code;
																		if (args.length > 1) {
																			{
																				var ` = 1;
																				var ` = args.length;
																				while (` < `) {
																					var i = ` ++;
																					var paramStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(args[i], null);
																					var placeholder = "{" + i - 1 + "}";
																					processedCode = StringTools.replace(processedCode, placeholder, paramStr);
																				};
																			};
																		};
																		reflaxe.elixir.ast.ElixirASTDef.ERaw(processedCode);
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
													};
												};
											} else {
												if (target != null) {
													@:ast(switch (target.def) {
	case EField(module, funcName):
		ERemoteCall(module, funcName, args);	
	default:
		ECall(target, "call", args);	
}) {
														var ` = target.def;
														if (enumIndex ` == 28) {
															var ` = `[0];
															var ` = `[1];
															{
																var module = `;
																var funcName = `;
																{
																	reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, funcName, args);
																};
															};
														} else {
															reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
														};
													};
												} else {
													reflaxe.elixir.ast.ElixirASTDef.ECall(null, "unknown_call", args);
												};
											};
										};
										default: {
											if (target != null) {
												@:ast(switch (target.def) {
	case EField(module, funcName):
		ERemoteCall(module, funcName, args);	
	default:
		ECall(target, "call", args);	
}) {
													var ` = target.def;
													if (enumIndex ` == 28) {
														var ` = `[0];
														var ` = `[1];
														{
															var module = `;
															var funcName = `;
															{
																reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, funcName, args);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTDef.ECall(target, "call", args);
													};
												};
											} else {
												reflaxe.elixir.ast.ElixirASTDef.ECall(null, "unknown_call", args);
											};
										}
									};
								};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var el = `;
						{
							var classType = c.get();
							var className = classType.name;
							var args = {
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var e = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
									};
								};
								`;
							};
							if (classType.meta.has(":schema")) {
								var moduleName = if (classType.meta.has(":native")) {
									var nativeMeta = classType.meta.extract(":native");
									if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
										@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		className;	
}) {
											var ` = nativeMeta[0].params[0].expr;
											if (enumIndex ` == 0) {
												var ` = `[0];
												if (enumIndex ` == 2) {
													var ` = `[0];
													var ` = `[1];
													{
														var s = `;
														{
															s;
														};
													};
												} else {
													className;
												};
											} else {
												className;
											};
										};
									} else {
										className;
									};
								} else {
									className;
								};
								reflaxe.elixir.ast.ElixirASTDef.EStruct(moduleName, []);
							} else {
								if (className == "StringMap" || className == "Map" || StringTools.endsWith(className, "Map")) {
									reflaxe.elixir.ast.ElixirASTDef.EMap([]);
								} else {
									var hasInstanceMethods = false;
									{
										var ` = 0;
										var ` = classType.fields.get();
										while (` < `.length) {
											var field = `[`];
											++ `;
											if ({
												var ` = field.kind;
												if (enumIndex ` == 1) {
													var ` = `[0];
													true;
												} else false;
											}) {
												var isStatic = false;
												{
													var ` = 0;
													var ` = classType.statics.get();
													while (` < `.length) {
														var staticField = `[`];
														++ `;
														if (staticField.name == field.name) {
															isStatic = true;
															break;
														};
													};
												};
												if (! isStatic) {
													hasInstanceMethods = true;
													break;
												};
											};
										};
									};
									var hasConstructor = classType.constructor != null;
									if (hasInstanceMethods || hasConstructor) {
										var moduleRef = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
										};
										reflaxe.elixir.ast.ElixirASTDef.ECall(moduleRef, "new", args);
									} else {
										reflaxe.elixir.ast.ElixirASTDef.EStruct(className, []);
									};
								};
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var postFix = `;
						var e = `;
						{
							@:ast(switch (op) {
	case OpNot:
		switch (e.expr) {
			case TBlock([]):
				EUnary(Not, makeAST(ENil));			
			case TBlock(exprs) if (exprs.length == 1):
				EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));			
			case TBlock(exprs):
				var statements = [];
				for (i  in  0 ... exprs.length - 1) {
					statements.push(buildFromTypedExpr(exprs[i], currentContext));
				};
				var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
				statements.push(makeAST(EUnary(Not, lastExpr)));
				EBlock(statements);			
			default:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(Not, makeAST(expr));			
		};	
	case OpNeg:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(Negate, makeAST(expr));	
	case OpNegBits:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(BitwiseNot, makeAST(expr));	
	case OpIncrement, OpDecrement:
		var one = makeAST(EInteger(1));
		var builtExpr = buildFromTypedExpr(e, currentContext);
		var operation = if (op == OpIncrement) {
			makeAST(EBinary(Add, builtExpr, one));
		} else {
			makeAST(EBinary(Subtract, builtExpr, one));
		};
		switch (e.expr) {
			case TLocal(v):
				EBinary(Match, builtExpr, operation);			
			default:
				operation.def;			
		};	
	case OpSpread:
		var builtExpr = buildFromTypedExpr(e, currentContext);
		EUnquoteSplicing(builtExpr);	
}) switch (@:exhaustive enumIndex op) {
								case 0, 1: {
									{
										var one = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
										};
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										var operation = if (op == haxe.macro.Unop.OpIncrement) {
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, builtExpr, one), metadata : {}, pos : pos};
											};
										} else {
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, builtExpr, one), metadata : {}, pos : pos};
											};
										};
										@:ast(switch (e.expr) {
	case TLocal(v):
		EBinary(Match, builtExpr, operation);	
	default:
		operation.def;	
}) {
											var ` = e.expr;
											if (enumIndex ` == 1) {
												var ` = `[0];
												{
													var v = `;
													{
														reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, builtExpr, operation);
													};
												};
											} else {
												operation.def;
											};
										};
									};
								};
								case 2: {
									{
										@:ast(switch (e.expr) {
	case TBlock([]):
		EUnary(Not, makeAST(ENil));	
	case TBlock(exprs) if (exprs.length == 1):
		EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));	
	case TBlock(exprs):
		var statements = [];
		for (i  in  0 ... exprs.length - 1) {
			statements.push(buildFromTypedExpr(exprs[i], currentContext));
		};
		var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
		statements.push(makeAST(EUnary(Not, lastExpr)));
		EBlock(statements);	
	default:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(Not, makeAST(expr));	
}) {
											var ` = e.expr;
											if (enumIndex ` == 14) {
												var ` = `[0];
												if (`.length == 0) {
													{
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
														});
													};
												} else {
													var exprs = `;
													if (exprs.length == 1) {
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
													} else {
														var exprs = `;
														{
															var statements = [];
															{
																var ` = 0;
																var ` = exprs.length - 1;
																while (` < `) {
																	var i = ` ++;
																	statements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[i], reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																};
															};
															var lastExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[exprs.length - 1], reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															statements.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, lastExpr), metadata : {}, pos : pos};
															});
															reflaxe.elixir.ast.ElixirASTDef.EBlock(statements);
														};
													};
												};
											} else {
												var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
												reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
													var pos = null;
													{def : expr, metadata : {}, pos : pos};
												});
											};
										};
									};
								};
								case 3: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Negate, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 4: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.BitwiseNot, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 5: {
									{
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										reflaxe.elixir.ast.ElixirASTDef.EUnquoteSplicing(builtExpr);
									};
								};
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var f = `;
						{
							var fluentPattern = reflaxe.elixir.ast.ElixirASTBuilder.detectFluentAPIPattern(f);
							var args = [];
							var paramRenaming = {
								{};
								new haxe.ds.StringMap();
							};
							var oldTempVarRenameMap = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
							reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap = {
								{};
								new haxe.ds.StringMap();
							};
							for (key in oldTempVarRenameMap.keys()) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									var value = oldTempVarRenameMap.get(key);
									cast this.set(key, value);
								};
							};
							var isFirstParam = true;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									var originalName = arg.v.name;
									var idKey = Std.string(arg.v.id);
									var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
										true;
									} else {
										if (f.expr != null) {
											! reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, f.expr);
										} else {
											false;
										};
									};
									var strippedName = originalName;
									var hasNumericSuffix = false;
									var renamedPattern = new EReg("^(.+?)(\\d+)$", "");
									if (renamedPattern.match(originalName)) {
										var baseWithoutSuffix = renamedPattern.matched(1);
										var suffix = renamedPattern.matched(2);
										var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items"];
										if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix, null) >= 0) {
											strippedName = baseWithoutSuffix;
											hasNumericSuffix = true;
										};
									};
									var baseName = reflaxe.elixir.ast.ElixirASTHelpers.toElixirVarName(strippedName);
									var finalName = if (isActuallyUnused && ! StringTools.startsWith(baseName, "_")) {
										"_" + baseName;
									} else {
										baseName;
									};
									if (! {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
										cast this.exists(idKey);
									}) {
										{
											var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
											cast this.set(idKey, finalName);
										};
									};
									if (originalName != finalName) {
										{
											paramRenaming.set(originalName, finalName);
										};
									};
									if (hasNumericSuffix && reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);
									};
									if (originalName == "this1") {
										{
											paramRenaming.set("this", finalName);
										};
									};
									if (isFirstParam && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInClassMethodContext) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentReceiverParamName = finalName;
										isFirstParam = false;
									};
									args.push(reflaxe.elixir.ast.EPattern.PVar(finalName));
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.functionParameterIds;
										cast this.set(idKey, true);
									};
								};
							};
							var functionUsageMap = null;
							if (functionUsageMap != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap = functionUsageMap;
							};
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(f.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap = oldTempVarRenameMap;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.functionParameterIds;
										var key = Std.string(arg.v.id);
										cast this.remove(key);
									};
								};
							};
							if (paramRenaming.keys().hasNext()) {
								body = reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(body, paramRenaming);
							};
							var fnAst = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : args, guard : null, body : body}]), metadata : {}, pos : pos};
							};
							if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
								fnAst.metadata.isFluentMethod = true;
								fnAst.metadata.returnsThis = fluentPattern.returnsThis;
								if (fluentPattern.fieldMutations.length > 0) {
									fnAst.metadata.mutatesFields = [];
									fnAst.metadata.fieldMutations = [];
									{
										var ` = 0;
										var ` = fluentPattern.fieldMutations;
										while (` < `.length) {
											var mutation = `[`];
											++ `;
											fnAst.metadata.mutatesFields.push(mutation.field);
											fnAst.metadata.fieldMutations.push({field : mutation.field, expr : reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(mutation.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext)});
										};
									};
								};
							};
							fnAst.def;
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						{
							if (init != null) {
								@:ast(switch (init.expr) {
	case TBlock(blockStmts) if (blockStmts.length >= 3):
		var mapLiteral = tryBuildMapLiteralFromBlock(blockStmts, currentContext);
		if (mapLiteral != null) {
			return EMatch(PVar(toElixirVarName(v.name)), mapLiteral);
		};
		var isConditionalComp = false;
		var tempVarName = "";
		switch (blockStmts[0].expr) {
			case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
				switch (tempInit.expr) {
					case TArrayDecl([]):
						tempVarName = tempVar.name;
						if (blockStmts.length >= 3) {
							switch (blockStmts[1].expr) {
								case TBlock(ifStmts):
									var allIfs = true;
									for (stmt  in  ifStmts) {
										switch (stmt.expr) {
											case TIf(_, _, null):
												continue;											
											default:
												allIfs = false;
												break;											
										};
									};
									if (allIfs && blockStmts.length > 2) {
										switch (blockStmts[blockStmts.length - 1].expr) {
											case TLocal(retVar) if (retVar.name == tempVarName):
												isConditionalComp = true;											
											default:
										};
									};								
								default:
							};
						};					
					default:
				};			
			default:
		};
		if (isConditionalComp) {
			var reconstructed = tryReconstructConditionalComprehension(blockStmts, tempVarName, currentContext.variableUsageMap);
			if (reconstructed != null) {
				return EMatch(PVar(toElixirVarName(v.name)), reconstructed);
			};
		};	
	default:
}) {
									var ` = init.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										{
											var blockStmts = `;
											if (blockStmts.length >= 3) {
												var mapLiteral = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildMapLiteralFromBlock(blockStmts, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												if (mapLiteral != null) {
													return reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null)), mapLiteral);
												};
												var isConditionalComp = false;
												var tempVarName = "";
												@:ast(switch (blockStmts[0].expr) {
	case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
		switch (tempInit.expr) {
			case TArrayDecl([]):
				tempVarName = tempVar.name;
				if (blockStmts.length >= 3) {
					switch (blockStmts[1].expr) {
						case TBlock(ifStmts):
							var allIfs = true;
							for (stmt  in  ifStmts) {
								switch (stmt.expr) {
									case TIf(_, _, null):
										continue;									
									default:
										allIfs = false;
										break;									
								};
							};
							if (allIfs && blockStmts.length > 2) {
								switch (blockStmts[blockStmts.length - 1].expr) {
									case TLocal(retVar) if (retVar.name == tempVarName):
										isConditionalComp = true;									
									default:
								};
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
													var ` = blockStmts[0].expr;
													if (enumIndex ` == 13) {
														var ` = `[0];
														var ` = `[1];
														{
															var tempVar = `;
															var tempInit = `;
															if (tempInit != null && (StringTools.startsWith(tempVar.name, "g") || StringTools.startsWith(tempVar.name, "_g"))) {
																@:ast(switch (tempInit.expr) {
	case TArrayDecl([]):
		tempVarName = tempVar.name;
		if (blockStmts.length >= 3) {
			switch (blockStmts[1].expr) {
				case TBlock(ifStmts):
					var allIfs = true;
					for (stmt  in  ifStmts) {
						switch (stmt.expr) {
							case TIf(_, _, null):
								continue;							
							default:
								allIfs = false;
								break;							
						};
					};
					if (allIfs && blockStmts.length > 2) {
						switch (blockStmts[blockStmts.length - 1].expr) {
							case TLocal(retVar) if (retVar.name == tempVarName):
								isConditionalComp = true;							
							default:
						};
					};				
				default:
			};
		};	
	default:
}) {
																	var ` = tempInit.expr;
																	if (enumIndex ` == 8) {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				tempVarName = tempVar.name;
																				if (blockStmts.length >= 3) {
																					@:ast(switch (blockStmts[1].expr) {
	case TBlock(ifStmts):
		var allIfs = true;
		for (stmt  in  ifStmts) {
			switch (stmt.expr) {
				case TIf(_, _, null):
					continue;				
				default:
					allIfs = false;
					break;				
			};
		};
		if (allIfs && blockStmts.length > 2) {
			switch (blockStmts[blockStmts.length - 1].expr) {
				case TLocal(retVar) if (retVar.name == tempVarName):
					isConditionalComp = true;				
				default:
			};
		};	
	default:
}) {
																						var ` = blockStmts[1].expr;
																						if (enumIndex ` == 14) {
																							var ` = `[0];
																							{
																								var ifStmts = `;
																								{
																									var allIfs = true;
																									{
																										var ` = 0;
																										while (` < ifStmts.length) {
																											var stmt = ifStmts[`];
																											++ `;
																											@:ast(switch (stmt.expr) {
	case TIf(_, _, null):
		continue;	
	default:
		allIfs = false;
		break;	
}) {
																												var ` = stmt.expr;
																												if (enumIndex ` == 16) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (` == null) {
																														continue;
																													} else {
																														allIfs = false;
																														break;
																													};
																												} else {
																													allIfs = false;
																													break;
																												};
																											};
																										};
																									};
																									if (allIfs && blockStmts.length > 2) {
																										@:ast(switch (blockStmts[blockStmts.length - 1].expr) {
	case TLocal(retVar) if (retVar.name == tempVarName):
		isConditionalComp = true;	
	default:
}) {
																											var ` = blockStmts[blockStmts.length - 1].expr;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												{
																													var retVar = `;
																													if (retVar.name == tempVarName) {
																														isConditionalComp = true;
																													} else {};
																												};
																											} else {};
																										};
																									};
																								};
																							};
																						} else {};
																					};
																				};
																			};
																		} else {};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
												if (isConditionalComp) {
													var reconstructed = reflaxe.elixir.ast.ElixirASTBuilder.tryReconstructConditionalComprehension(blockStmts, tempVarName, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
													if (reconstructed != null) {
														return reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null)), reconstructed);
													};
												};
											} else {};
										};
									} else {};
								};
							};
							var isEnumExtraction = false;
							var extractedFromTemp = "";
							var shouldSkipRedundantExtraction = false;
							var varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
							var tempToBinderMap = null;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TEnumParameter(e, _, index):
		isEnumExtraction = true;
		varOrigin = ExtractionTemp;
		var tempVarName = toElixirVarName(v.name);
		if (currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
			currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : tempVarName }]);
		};
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
			var plan = currentContext.currentClauseContext.enumBindingPlan;
			if (plan.exists(index)) {
				shouldSkipRedundantExtraction = true;
				return null;
			};
		};
		if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
			shouldSkipRedundantExtraction = true;
		};	
	case TLocal(tempVar):
		if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)) {
			extractedFromTemp = tempVar.name;
			varOrigin = PatternBinder;
			if (currentContext.currentClauseContext != null) {
				var userVarName = toElixirVarName(v.name);
				currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : userVarName }]);
			};
			if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
				return null;
			};
			if (tempToBinderMap == null) {
				tempToBinderMap = new Map<Int,Int>();
			};
			tempToBinderMap.set(tempVar.id, v.id);
		} else {
			varOrigin = UserDefined;
		};	
	case TSwitch(switchExpr, cases, edef):
		varOrigin = UserDefined;	
	case _:
		varOrigin = UserDefined;	
}) {
									var ` = init.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var tempVar = `;
												{
													if (StringTools.startsWith(tempVar.name, "_g") || tempVar.name == "g" || new EReg("^g\\d+$", "").match(tempVar.name)) {
														extractedFromTemp = tempVar.name;
														varOrigin = reflaxe.elixir.ast.VarOrigin.PatternBinder;
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null) {
															var userVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
															reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.pushPatternBindings([{varId : v.id, binderName : userVarName}]);
														};
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan != null) {
															return null;
														};
														if (tempToBinderMap == null) {
															tempToBinderMap = {
																{};
																new haxe.ds.IntMap();
															};
														};
														{
															var key = tempVar.id;
															var value = v.id;
															tempToBinderMap.set(key, value);
														};
													} else {
														varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
													};
												};
											};
										};
										case 18: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var switchExpr = `;
												var cases = `;
												var edef = `;
												{
													varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
												};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var e = `;
												var index = `;
												{
													isEnumExtraction = true;
													varOrigin = reflaxe.elixir.ast.VarOrigin.ExtractionTemp;
													var tempVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
														reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.pushPatternBindings([{varId : v.id, binderName : tempVarName}]);
													};
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan != null) {
														var plan = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
														if (plan.exists(index)) {
															shouldSkipRedundantExtraction = true;
															return null;
														};
													};
													if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
														shouldSkipRedundantExtraction = true;
													};
												};
											};
										};
										default: {
											varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
										}
									};
								};
							};
							var varName = v.name;
							var idKey = Std.string(v.id);
							var isUnused = false;
							var baseName = if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.get(idKey);
								};
							} else {
								var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap != null) {
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
										var key = v.id;
										cast this.exists(key);
									} && {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
										var key = v.id;
										cast this.get(key);
									};
								} else {
									true;
								};
								if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
									reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(varName, false);
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(varName, false);
								};
							};
							var isActuallyUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
								var key = v.id;
								cast this.exists(key);
							}) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
									var key = v.id;
									cast this.get(key);
								};
							} else {
								true;
							};
							var isEnumParameterExtraction = false;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d*$/.match(tempVar.name)):
		isEnumParameterExtraction = true;	
	case _:
}) {
									var ` = init.expr;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var tempVar = `;
											if (StringTools.startsWith(tempVar.name, "_g") || tempVar.name == "g" || new EReg("^g\\d*$", "").match(tempVar.name)) {
												isEnumParameterExtraction = true;
											} else {};
										};
									} else {};
								};
							};
							var finalVarName = if (! isActuallyUsed && ! isEnumParameterExtraction) {
								var underscoreName = "_" + baseName;
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									var key = Std.string(v.id);
									cast this.set(key, underscoreName);
								};
								underscoreName;
							} else {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									var key = Std.string(v.id);
									cast this.set(key, baseName);
								};
								baseName;
							};
							var matchNode = if (init != null) {
								var initValue = @:ast(switch (init.expr) {
	case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var initAst = buildFromTypedExpr(tmpInit, currentContext);
		var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		ifExpr;	
	case _:
		var initExpr = switch (init.expr) {
			case TBlock(stmts) if (stmts.length > 2):
				var isUnrolled = false;
				var tempVarName = "";
				var values = [];
				if (stmts.length > 0) {
					switch (stmts[0].expr) {
						case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
							switch (initExpr.expr) {
								case TArrayDecl([]):
									isUnrolled = true;
									tempVarName = v.name;								
								default:
							};						
						default:
					};
				};
				if (isUnrolled && stmts.length > 1) {
					var concatStatements = [];
					switch (stmts[1].expr) {
						case TBlock(innerStmts):
							concatStatements = innerStmts;						
						default:
							concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];						
					};
					for (stmt  in  concatStatements) {
						switch (stmt.expr) {
							case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
								values.push(elem);							
							case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
								values.push(arg);							
							default:
						};
					};
					if (values.length == 0) {
						isUnrolled = false;
					};
				};
				if (isUnrolled && stmts.length > 0) {
					switch (stmts[stmts.length - 1].expr) {
						case TLocal(v) if (v.name == tempVarName):
						default:
							isUnrolled = false;						
					};
				};
				if (isUnrolled && values.length > 0) {
					var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
					makeAST(EList(valueASTs));
				} else {
					buildFromTypedExpr(init, currentContext);
				};			
			case TSwitch(_, _, _):
				var switchAST = buildFromTypedExpr(init, currentContext);
				switchAST;			
			default:
				buildFromTypedExpr(init, currentContext);			
		};
		initExpr;	
}) {
									var ` = init.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 13) {
													var ` = `[0];
													var ` = `[1];
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 24) {
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var localVar = `;
																			var defaultExpr = `;
																			var tmpInit = `;
																			var tmpVar = `;
																			if (localVar.id == tmpVar.id && tmpInit != null) {
																				var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																					tmpVar.name.substr(1, null);
																				} else {
																					tmpVar.name;
																				}, null);
																				var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tmpInit, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var ifExpr = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																						}, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					}, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																					}, defaultAst), metadata : {}, pos : pos};
																				};
																				if (ifExpr.metadata == null) {
																					ifExpr.metadata = {};
																				};
																				ifExpr.metadata.keepInlineInAssignment = true;
																				ifExpr;
																			} else {
																				var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																					var ` = init.expr;
																					switch (enumIndex `) {
																						case 14: {
																							var ` = `[0];
																							{
																								var stmts = `;
																								if (stmts.length > 2) {
																									var isUnrolled = false;
																									var tempVarName = "";
																									var values = [];
																									if (stmts.length > 0) {
																										@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																											var ` = stmts[0].expr;
																											if (enumIndex ` == 13) {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var v = `;
																													var initExpr = `;
																													if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																														@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																															var ` = initExpr.expr;
																															if (enumIndex ` == 8) {
																																var ` = `[0];
																																if (`.length == 0) {
																																	{
																																		isUnrolled = true;
																																		tempVarName = v.name;
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									if (isUnrolled && stmts.length > 1) {
																										var concatStatements = [];
																										@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																											var ` = stmts[1].expr;
																											if (enumIndex ` == 14) {
																												var ` = `[0];
																												{
																													var innerStmts = `;
																													{
																														concatStatements = innerStmts;
																													};
																												};
																											} else {
																												concatStatements = {
																													var ` = [];
																													{
																														var ` = 1;
																														var ` = stmts.length - 1;
																														while (` < `) {
																															var i = ` ++;
																															`.push(stmts[i]);
																														};
																													};
																													`;
																												};
																											};
																										};
																										{
																											var ` = 0;
																											while (` < concatStatements.length) {
																												var stmt = concatStatements[`];
																												++ `;
																												@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																													var ` = stmt.expr;
																													switch (enumIndex `) {
																														case 3: {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (enumIndex ` == 4) {
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 1) {
																																		var ` = `[0];
																																		{
																																			var ` = `.expr;
																																			var ` = `.pos;
																																			var ` = `.t;
																																			if (enumIndex ` == 3) {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				if (enumIndex ` == 0) {
																																					{
																																						var ` = `.expr;
																																						var ` = `.pos;
																																						var ` = `.t;
																																						if (enumIndex ` == 1) {
																																							var ` = `[0];
																																							{
																																								var ` = `.expr;
																																								var ` = `.pos;
																																								var ` = `.t;
																																								if (enumIndex ` == 8) {
																																									var ` = `[0];
																																									if (`.length == 1) {
																																										var ` = `[0];
																																										{
																																											var elem = `;
																																											var v2 = `;
																																											var v = `;
																																											if (v.name == tempVarName && v2.name == tempVarName) {
																																												values.push(elem);
																																											} else {};
																																										};
																																									} else {};
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		};
																																	} else {};
																																};
																															} else {};
																														};
																														case 9: {
																															var ` = `[0];
																															var ` = `[1];
																															{
																																var ` = `.expr;
																																var ` = `.pos;
																																var ` = `.t;
																																if (enumIndex ` == 4) {
																																	var ` = `[0];
																																	var ` = `[1];
																																	{
																																		var ` = `.expr;
																																		var ` = `.pos;
																																		var ` = `.t;
																																		if (enumIndex ` == 1) {
																																			var ` = `[0];
																																			if (enumIndex ` == 0) {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				if (`.length == 1) {
																																					var ` = `[0];
																																					{
																																						var arg = `;
																																						var v = `;
																																						var cf = `;
																																						if (v.name == tempVarName && cf.get().name == "push") {
																																							values.push(arg);
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		} else {};
																																	};
																																} else {};
																															};
																														};
																														default: {}
																													};
																												};
																											};
																										};
																										if (values.length == 0) {
																											isUnrolled = false;
																										};
																									};
																									if (isUnrolled && stmts.length > 0) {
																										@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																											var ` = stmts[stmts.length - 1].expr;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												{
																													var v = `;
																													if (v.name == tempVarName) {} else {
																														isUnrolled = false;
																													};
																												};
																											} else {
																												isUnrolled = false;
																											};
																										};
																									};
																									if (isUnrolled && values.length > 0) {
																										var valueASTs = {
																											var ` = [];
																											{
																												var ` = 0;
																												while (` < values.length) {
																													var v = values[`];
																													++ `;
																													`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																												};
																											};
																											`;
																										};
																										{
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																										};
																									} else {
																										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																									};
																								} else {
																									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																								};
																							};
																						};
																						case 18: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																								switchAST;
																							};
																						};
																						default: {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						}
																					};
																				};
																				initExpr;
																			};
																		};
																	} else {
																		var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																			var ` = init.expr;
																			switch (enumIndex `) {
																				case 14: {
																					var ` = `[0];
																					{
																						var stmts = `;
																						if (stmts.length > 2) {
																							var isUnrolled = false;
																							var tempVarName = "";
																							var values = [];
																							if (stmts.length > 0) {
																								@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																									var ` = stmts[0].expr;
																									if (enumIndex ` == 13) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var v = `;
																											var initExpr = `;
																											if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																												@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																													var ` = initExpr.expr;
																													if (enumIndex ` == 8) {
																														var ` = `[0];
																														if (`.length == 0) {
																															{
																																isUnrolled = true;
																																tempVarName = v.name;
																															};
																														} else {};
																													} else {};
																												};
																											} else {};
																										};
																									} else {};
																								};
																							};
																							if (isUnrolled && stmts.length > 1) {
																								var concatStatements = [];
																								@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																									var ` = stmts[1].expr;
																									if (enumIndex ` == 14) {
																										var ` = `[0];
																										{
																											var innerStmts = `;
																											{
																												concatStatements = innerStmts;
																											};
																										};
																									} else {
																										concatStatements = {
																											var ` = [];
																											{
																												var ` = 1;
																												var ` = stmts.length - 1;
																												while (` < `) {
																													var i = ` ++;
																													`.push(stmts[i]);
																												};
																											};
																											`;
																										};
																									};
																								};
																								{
																									var ` = 0;
																									while (` < concatStatements.length) {
																										var stmt = concatStatements[`];
																										++ `;
																										@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																											var ` = stmt.expr;
																											switch (enumIndex `) {
																												case 3: {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 4) {
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 3) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		var ` = `[2];
																																		if (enumIndex ` == 0) {
																																			{
																																				var ` = `.expr;
																																				var ` = `.pos;
																																				var ` = `.t;
																																				if (enumIndex ` == 1) {
																																					var ` = `[0];
																																					{
																																						var ` = `.expr;
																																						var ` = `.pos;
																																						var ` = `.t;
																																						if (enumIndex ` == 8) {
																																							var ` = `[0];
																																							if (`.length == 1) {
																																								var ` = `[0];
																																								{
																																									var elem = `;
																																									var v2 = `;
																																									var v = `;
																																									if (v.name == tempVarName && v2.name == tempVarName) {
																																										values.push(elem);
																																									} else {};
																																								};
																																							} else {};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															} else {};
																														};
																													} else {};
																												};
																												case 9: {
																													var ` = `[0];
																													var ` = `[1];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 4) {
																															var ` = `[0];
																															var ` = `[1];
																															{
																																var ` = `.expr;
																																var ` = `.pos;
																																var ` = `.t;
																																if (enumIndex ` == 1) {
																																	var ` = `[0];
																																	if (enumIndex ` == 0) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		var ` = `[2];
																																		if (`.length == 1) {
																																			var ` = `[0];
																																			{
																																				var arg = `;
																																				var v = `;
																																				var cf = `;
																																				if (v.name == tempVarName && cf.get().name == "push") {
																																					values.push(arg);
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																} else {};
																															};
																														} else {};
																													};
																												};
																												default: {}
																											};
																										};
																									};
																								};
																								if (values.length == 0) {
																									isUnrolled = false;
																								};
																							};
																							if (isUnrolled && stmts.length > 0) {
																								@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																									var ` = stmts[stmts.length - 1].expr;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										{
																											var v = `;
																											if (v.name == tempVarName) {} else {
																												isUnrolled = false;
																											};
																										};
																									} else {
																										isUnrolled = false;
																									};
																								};
																							};
																							if (isUnrolled && values.length > 0) {
																								var valueASTs = {
																									var ` = [];
																									{
																										var ` = 0;
																										while (` < values.length) {
																											var v = values[`];
																											++ `;
																											`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																										};
																									};
																									`;
																								};
																								{
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																								};
																							} else {
																								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																							};
																						} else {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						};
																					};
																				};
																				case 18: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						switchAST;
																					};
																				};
																				default: {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				}
																			};
																		};
																		initExpr;
																	};
																};
															} else {
																var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																	var ` = init.expr;
																	switch (enumIndex `) {
																		case 14: {
																			var ` = `[0];
																			{
																				var stmts = `;
																				if (stmts.length > 2) {
																					var isUnrolled = false;
																					var tempVarName = "";
																					var values = [];
																					if (stmts.length > 0) {
																						@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																							var ` = stmts[0].expr;
																							if (enumIndex ` == 13) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var v = `;
																									var initExpr = `;
																									if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																										@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																											var ` = initExpr.expr;
																											if (enumIndex ` == 8) {
																												var ` = `[0];
																												if (`.length == 0) {
																													{
																														isUnrolled = true;
																														tempVarName = v.name;
																													};
																												} else {};
																											} else {};
																										};
																									} else {};
																								};
																							} else {};
																						};
																					};
																					if (isUnrolled && stmts.length > 1) {
																						var concatStatements = [];
																						@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																							var ` = stmts[1].expr;
																							if (enumIndex ` == 14) {
																								var ` = `[0];
																								{
																									var innerStmts = `;
																									{
																										concatStatements = innerStmts;
																									};
																								};
																							} else {
																								concatStatements = {
																									var ` = [];
																									{
																										var ` = 1;
																										var ` = stmts.length - 1;
																										while (` < `) {
																											var i = ` ++;
																											`.push(stmts[i]);
																										};
																									};
																									`;
																								};
																							};
																						};
																						{
																							var ` = 0;
																							while (` < concatStatements.length) {
																								var stmt = concatStatements[`];
																								++ `;
																								@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																									var ` = stmt.expr;
																									switch (enumIndex `) {
																										case 3: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (enumIndex ` == 4) {
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 3) {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (enumIndex ` == 0) {
																																	{
																																		var ` = `.expr;
																																		var ` = `.pos;
																																		var ` = `.t;
																																		if (enumIndex ` == 1) {
																																			var ` = `[0];
																																			{
																																				var ` = `.expr;
																																				var ` = `.pos;
																																				var ` = `.t;
																																				if (enumIndex ` == 8) {
																																					var ` = `[0];
																																					if (`.length == 1) {
																																						var ` = `[0];
																																						{
																																							var elem = `;
																																							var v2 = `;
																																							var v = `;
																																							if (v.name == tempVarName && v2.name == tempVarName) {
																																								values.push(elem);
																																							} else {};
																																						};
																																					} else {};
																																				} else {};
																																			};
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										};
																										case 9: {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 4) {
																													var ` = `[0];
																													var ` = `[1];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 1) {
																															var ` = `[0];
																															if (enumIndex ` == 0) {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (`.length == 1) {
																																	var ` = `[0];
																																	{
																																		var arg = `;
																																		var v = `;
																																		var cf = `;
																																		if (v.name == tempVarName && cf.get().name == "push") {
																																			values.push(arg);
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										};
																										default: {}
																									};
																								};
																							};
																						};
																						if (values.length == 0) {
																							isUnrolled = false;
																						};
																					};
																					if (isUnrolled && stmts.length > 0) {
																						@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																							var ` = stmts[stmts.length - 1].expr;
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								{
																									var v = `;
																									if (v.name == tempVarName) {} else {
																										isUnrolled = false;
																									};
																								};
																							} else {
																								isUnrolled = false;
																							};
																						};
																					};
																					if (isUnrolled && values.length > 0) {
																						var valueASTs = {
																							var ` = [];
																							{
																								var ` = 0;
																								while (` < values.length) {
																									var v = values[`];
																									++ `;
																									`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																								};
																							};
																							`;
																						};
																						{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																						};
																					} else {
																						reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			};
																		};
																		case 18: {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			{
																				var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				switchAST;
																			};
																		};
																		default: {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		}
																	};
																};
																initExpr;
															};
														} else {
															var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 14: {
																		var ` = `[0];
																		{
																			var stmts = `;
																			if (stmts.length > 2) {
																				var isUnrolled = false;
																				var tempVarName = "";
																				var values = [];
																				if (stmts.length > 0) {
																					@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																						var ` = stmts[0].expr;
																						if (enumIndex ` == 13) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var v = `;
																								var initExpr = `;
																								if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																									@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																										var ` = initExpr.expr;
																										if (enumIndex ` == 8) {
																											var ` = `[0];
																											if (`.length == 0) {
																												{
																													isUnrolled = true;
																													tempVarName = v.name;
																												};
																											} else {};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																				};
																				if (isUnrolled && stmts.length > 1) {
																					var concatStatements = [];
																					@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																						var ` = stmts[1].expr;
																						if (enumIndex ` == 14) {
																							var ` = `[0];
																							{
																								var innerStmts = `;
																								{
																									concatStatements = innerStmts;
																								};
																							};
																						} else {
																							concatStatements = {
																								var ` = [];
																								{
																									var ` = 1;
																									var ` = stmts.length - 1;
																									while (` < `) {
																										var i = ` ++;
																										`.push(stmts[i]);
																									};
																								};
																								`;
																							};
																						};
																					};
																					{
																						var ` = 0;
																						while (` < concatStatements.length) {
																							var stmt = concatStatements[`];
																							++ `;
																							@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																								var ` = stmt.expr;
																								switch (enumIndex `) {
																									case 3: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (enumIndex ` == 4) {
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 3) {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (enumIndex ` == 0) {
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 1) {
																																		var ` = `[0];
																																		{
																																			var ` = `.expr;
																																			var ` = `.pos;
																																			var ` = `.t;
																																			if (enumIndex ` == 8) {
																																				var ` = `[0];
																																				if (`.length == 1) {
																																					var ` = `[0];
																																					{
																																						var elem = `;
																																						var v2 = `;
																																						var v = `;
																																						if (v.name == tempVarName && v2.name == tempVarName) {
																																							values.push(elem);
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		};
																																	} else {};
																																};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										} else {};
																									};
																									case 9: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 4) {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														if (enumIndex ` == 0) {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (`.length == 1) {
																																var ` = `[0];
																																{
																																	var arg = `;
																																	var v = `;
																																	var cf = `;
																																	if (v.name == tempVarName && cf.get().name == "push") {
																																		values.push(arg);
																																	} else {};
																																};
																															} else {};
																														} else {};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									default: {}
																								};
																							};
																						};
																					};
																					if (values.length == 0) {
																						isUnrolled = false;
																					};
																				};
																				if (isUnrolled && stmts.length > 0) {
																					@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																						var ` = stmts[stmts.length - 1].expr;
																						if (enumIndex ` == 1) {
																							var ` = `[0];
																							{
																								var v = `;
																								if (v.name == tempVarName) {} else {
																									isUnrolled = false;
																								};
																							};
																						} else {
																							isUnrolled = false;
																						};
																					};
																				};
																				if (isUnrolled && values.length > 0) {
																					var valueASTs = {
																						var ` = [];
																						{
																							var ` = 0;
																							while (` < values.length) {
																								var v = values[`];
																								++ `;
																								`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																							};
																						};
																						`;
																					};
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			};
																		};
																	};
																	case 18: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			switchAST;
																		};
																	};
																	default: {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	}
																};
															};
															initExpr;
														};
													};
												} else {
													var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
														var ` = init.expr;
														switch (enumIndex `) {
															case 14: {
																var ` = `[0];
																{
																	var stmts = `;
																	if (stmts.length > 2) {
																		var isUnrolled = false;
																		var tempVarName = "";
																		var values = [];
																		if (stmts.length > 0) {
																			@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																				var ` = stmts[0].expr;
																				if (enumIndex ` == 13) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var v = `;
																						var initExpr = `;
																						if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																							@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																								var ` = initExpr.expr;
																								if (enumIndex ` == 8) {
																									var ` = `[0];
																									if (`.length == 0) {
																										{
																											isUnrolled = true;
																											tempVarName = v.name;
																										};
																									} else {};
																								} else {};
																							};
																						} else {};
																					};
																				} else {};
																			};
																		};
																		if (isUnrolled && stmts.length > 1) {
																			var concatStatements = [];
																			@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																				var ` = stmts[1].expr;
																				if (enumIndex ` == 14) {
																					var ` = `[0];
																					{
																						var innerStmts = `;
																						{
																							concatStatements = innerStmts;
																						};
																					};
																				} else {
																					concatStatements = {
																						var ` = [];
																						{
																							var ` = 1;
																							var ` = stmts.length - 1;
																							while (` < `) {
																								var i = ` ++;
																								`.push(stmts[i]);
																							};
																						};
																						`;
																					};
																				};
																			};
																			{
																				var ` = 0;
																				while (` < concatStatements.length) {
																					var stmt = concatStatements[`];
																					++ `;
																					@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																						var ` = stmt.expr;
																						switch (enumIndex `) {
																							case 3: {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 4) {
																									{
																										var ` = `.expr;
																										var ` = `.pos;
																										var ` = `.t;
																										if (enumIndex ` == 1) {
																											var ` = `[0];
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 3) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 0) {
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 8) {
																																		var ` = `[0];
																																		if (`.length == 1) {
																																			var ` = `[0];
																																			{
																																				var elem = `;
																																				var v2 = `;
																																				var v = `;
																																				if (v.name == tempVarName && v2.name == tempVarName) {
																																					values.push(elem);
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															} else {};
																														};
																													} else {};
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							};
																							case 9: {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 4) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												if (enumIndex ` == 0) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (`.length == 1) {
																														var ` = `[0];
																														{
																															var arg = `;
																															var v = `;
																															var cf = `;
																															if (v.name == tempVarName && cf.get().name == "push") {
																																values.push(arg);
																															} else {};
																														};
																													} else {};
																												} else {};
																											} else {};
																										};
																									} else {};
																								};
																							};
																							default: {}
																						};
																					};
																				};
																			};
																			if (values.length == 0) {
																				isUnrolled = false;
																			};
																		};
																		if (isUnrolled && stmts.length > 0) {
																			@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																				var ` = stmts[stmts.length - 1].expr;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var v = `;
																						if (v.name == tempVarName) {} else {
																							isUnrolled = false;
																						};
																					};
																				} else {
																					isUnrolled = false;
																				};
																			};
																		};
																		if (isUnrolled && values.length > 0) {
																			var valueASTs = {
																				var ` = [];
																				{
																					var ` = 0;
																					while (` < values.length) {
																						var v = values[`];
																						++ `;
																						`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																					};
																				};
																				`;
																			};
																			{
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	};
																};
															};
															case 18: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	switchAST;
																};
															};
															default: {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															}
														};
													};
													initExpr;
												};
											};
										} else {
											var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
												var ` = init.expr;
												switch (enumIndex `) {
													case 14: {
														var ` = `[0];
														{
															var stmts = `;
															if (stmts.length > 2) {
																var isUnrolled = false;
																var tempVarName = "";
																var values = [];
																if (stmts.length > 0) {
																	@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																		var ` = stmts[0].expr;
																		if (enumIndex ` == 13) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var v = `;
																				var initExpr = `;
																				if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																					@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																						var ` = initExpr.expr;
																						if (enumIndex ` == 8) {
																							var ` = `[0];
																							if (`.length == 0) {
																								{
																									isUnrolled = true;
																									tempVarName = v.name;
																								};
																							} else {};
																						} else {};
																					};
																				} else {};
																			};
																		} else {};
																	};
																};
																if (isUnrolled && stmts.length > 1) {
																	var concatStatements = [];
																	@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																		var ` = stmts[1].expr;
																		if (enumIndex ` == 14) {
																			var ` = `[0];
																			{
																				var innerStmts = `;
																				{
																					concatStatements = innerStmts;
																				};
																			};
																		} else {
																			concatStatements = {
																				var ` = [];
																				{
																					var ` = 1;
																					var ` = stmts.length - 1;
																					while (` < `) {
																						var i = ` ++;
																						`.push(stmts[i]);
																					};
																				};
																				`;
																			};
																		};
																	};
																	{
																		var ` = 0;
																		while (` < concatStatements.length) {
																			var stmt = concatStatements[`];
																			++ `;
																			@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																				var ` = stmt.expr;
																				switch (enumIndex `) {
																					case 3: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						if (enumIndex ` == 4) {
																							{
																								var ` = `.expr;
																								var ` = `.pos;
																								var ` = `.t;
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									{
																										var ` = `.expr;
																										var ` = `.pos;
																										var ` = `.t;
																										if (enumIndex ` == 3) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (enumIndex ` == 0) {
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 8) {
																																var ` = `[0];
																																if (`.length == 1) {
																																	var ` = `[0];
																																	{
																																		var elem = `;
																																		var v2 = `;
																																		var v = `;
																																		if (v.name == tempVarName && v2.name == tempVarName) {
																																			values.push(elem);
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					case 9: {
																						var ` = `[0];
																						var ` = `[1];
																						{
																							var ` = `.expr;
																							var ` = `.pos;
																							var ` = `.t;
																							if (enumIndex ` == 4) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										if (enumIndex ` == 0) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (`.length == 1) {
																												var ` = `[0];
																												{
																													var arg = `;
																													var v = `;
																													var cf = `;
																													if (v.name == tempVarName && cf.get().name == "push") {
																														values.push(arg);
																													} else {};
																												};
																											} else {};
																										} else {};
																									} else {};
																								};
																							} else {};
																						};
																					};
																					default: {}
																				};
																			};
																		};
																	};
																	if (values.length == 0) {
																		isUnrolled = false;
																	};
																};
																if (isUnrolled && stmts.length > 0) {
																	@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																		var ` = stmts[stmts.length - 1].expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (v.name == tempVarName) {} else {
																					isUnrolled = false;
																				};
																			};
																		} else {
																			isUnrolled = false;
																		};
																	};
																};
																if (isUnrolled && values.length > 0) {
																	var valueASTs = {
																		var ` = [];
																		{
																			var ` = 0;
																			while (` < values.length) {
																				var v = values[`];
																				++ `;
																				`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																			};
																		};
																		`;
																	};
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														};
													};
													case 18: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															switchAST;
														};
													};
													default: {
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													}
												};
											};
											initExpr;
										};
									} else {
										var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
											var ` = init.expr;
											switch (enumIndex `) {
												case 14: {
													var ` = `[0];
													{
														var stmts = `;
														if (stmts.length > 2) {
															var isUnrolled = false;
															var tempVarName = "";
															var values = [];
															if (stmts.length > 0) {
																@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																	var ` = stmts[0].expr;
																	if (enumIndex ` == 13) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var v = `;
																			var initExpr = `;
																			if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																				@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																					var ` = initExpr.expr;
																					if (enumIndex ` == 8) {
																						var ` = `[0];
																						if (`.length == 0) {
																							{
																								isUnrolled = true;
																								tempVarName = v.name;
																							};
																						} else {};
																					} else {};
																				};
																			} else {};
																		};
																	} else {};
																};
															};
															if (isUnrolled && stmts.length > 1) {
																var concatStatements = [];
																@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																	var ` = stmts[1].expr;
																	if (enumIndex ` == 14) {
																		var ` = `[0];
																		{
																			var innerStmts = `;
																			{
																				concatStatements = innerStmts;
																			};
																		};
																	} else {
																		concatStatements = {
																			var ` = [];
																			{
																				var ` = 1;
																				var ` = stmts.length - 1;
																				while (` < `) {
																					var i = ` ++;
																					`.push(stmts[i]);
																				};
																			};
																			`;
																		};
																	};
																};
																{
																	var ` = 0;
																	while (` < concatStatements.length) {
																		var stmt = concatStatements[`];
																		++ `;
																		@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																			var ` = stmt.expr;
																			switch (enumIndex `) {
																				case 3: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					if (enumIndex ` == 4) {
																						{
																							var ` = `.expr;
																							var ` = `.pos;
																							var ` = `.t;
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 3) {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (enumIndex ` == 0) {
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 8) {
																															var ` = `[0];
																															if (`.length == 1) {
																																var ` = `[0];
																																{
																																	var elem = `;
																																	var v2 = `;
																																	var v = `;
																																	if (v.name == tempVarName && v2.name == tempVarName) {
																																		values.push(elem);
																																	} else {};
																																};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										} else {};
																									} else {};
																								};
																							} else {};
																						};
																					} else {};
																				};
																				case 9: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var ` = `.expr;
																						var ` = `.pos;
																						var ` = `.t;
																						if (enumIndex ` == 4) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var ` = `.expr;
																								var ` = `.pos;
																								var ` = `.t;
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									if (enumIndex ` == 0) {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (`.length == 1) {
																											var ` = `[0];
																											{
																												var arg = `;
																												var v = `;
																												var cf = `;
																												if (v.name == tempVarName && cf.get().name == "push") {
																													values.push(arg);
																												} else {};
																											};
																										} else {};
																									} else {};
																								} else {};
																							};
																						} else {};
																					};
																				};
																				default: {}
																			};
																		};
																	};
																};
																if (values.length == 0) {
																	isUnrolled = false;
																};
															};
															if (isUnrolled && stmts.length > 0) {
																@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																	var ` = stmts[stmts.length - 1].expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var v = `;
																			if (v.name == tempVarName) {} else {
																				isUnrolled = false;
																			};
																		};
																	} else {
																		isUnrolled = false;
																	};
																};
															};
															if (isUnrolled && values.length > 0) {
																var valueASTs = {
																	var ` = [];
																	{
																		var ` = 0;
																		while (` < values.length) {
																			var v = values[`];
																			++ `;
																			`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																		};
																	};
																	`;
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														};
													};
												};
												case 18: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														switchAST;
													};
												};
												default: {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												}
											};
										};
										initExpr;
									};
								};
								var shouldSkipAssignment = false;
								if (init != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.isVarIdSatisfiedByPattern(v.id)) {
									shouldSkipAssignment = true;
								} else {
									if (init != null) {
										@:ast(switch (init.expr) {
	case TEnumParameter(e, ef, index):
		if (currentContext.currentClauseContext != null) {
			var hasPlan = currentContext.currentClauseContext.enumBindingPlan.exists(index);
			if (hasPlan) {
				var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
				if (info.finalName == finalVarName) {
					shouldSkipAssignment = true;
				} else { };
				if (!shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
					var planIsTemp = isTempPatternVarName(info.finalName);
					var lhsIsTemp = isTempPatternVarName(finalVarName);
					if (lhsIsTemp && !planIsTemp) {
						shouldSkipAssignment = true;
					};
				};
			};
		};
		if (!shouldSkipAssignment && initValue != null) {
			switch (initValue.def) {
				case EVar(varName):
					if (varName == finalVarName) {
						shouldSkipAssignment = true;
					};				
				case _:
			};
		} else if (!shouldSkipAssignment) {
			shouldSkipAssignment = true;
		};	
	default:
}) {
											var ` = init.expr;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var e = `;
													var ef = `;
													var index = `;
													{
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null) {
															var hasPlan = {
																var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
																cast this.exists(index);
															};
															if (hasPlan) {
																var info = {
																	var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
																	cast this.get(index);
																};
																if (info.finalName == finalVarName) {
																	shouldSkipAssignment = true;
																} else {};
																if (! shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
																	var planIsTemp = reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(info.finalName);
																	var lhsIsTemp = reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(finalVarName);
																	if (lhsIsTemp && ! planIsTemp) {
																		shouldSkipAssignment = true;
																	};
																};
															};
														};
														if (! shouldSkipAssignment && initValue != null) {
															@:ast(switch (initValue.def) {
	case EVar(varName):
		if (varName == finalVarName) {
			shouldSkipAssignment = true;
		};	
	case _:
}) {
																var ` = initValue.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var varName = `;
																		{
																			if (varName == finalVarName) {
																				shouldSkipAssignment = true;
																			};
																		};
																	};
																} else {};
															};
														} else {
															if (! shouldSkipAssignment) {
																shouldSkipAssignment = true;
															};
														};
													};
												};
											} else {};
										};
										if (! shouldSkipAssignment && init != null) {
											@:ast(switch (init.expr) {
	case TLocal(tempVar):
		var tempVarName = tempVar.name;
		var isTempVar = false;
		if (tempVarName == "g" || tempVarName == "_g") {
			isTempVar = true;
		} else if (tempVarName.length > 1) {
			if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
				isTempVar = true;
			} else if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
				isTempVar = true;
			};
		};
		if (isTempVar) {
			var elixirTempName = toElixirVarName(tempVarName);
			if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
				shouldSkipAssignment = true;
			};
			if (finalVarName == tempVarName) {
				shouldSkipAssignment = true;
			};
		} else {
			if (finalVarName == tempVarName) {
				shouldSkipAssignment = true;
			};
		};	
	case _:
}) {
												var ` = init.expr;
												if (enumIndex ` == 1) {
													var ` = `[0];
													{
														var tempVar = `;
														{
															var tempVarName = tempVar.name;
															var isTempVar = false;
															if (tempVarName == "g" || tempVarName == "_g") {
																isTempVar = true;
															} else {
																if (tempVarName.length > 1) {
																	if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
																		isTempVar = true;
																	} else {
																		if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
																			isTempVar = true;
																		};
																	};
																};
															};
															if (isTempVar) {
																var elixirTempName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(tempVarName, null);
																if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
																	shouldSkipAssignment = true;
																};
																if (finalVarName == tempVarName) {
																	shouldSkipAssignment = true;
																};
															} else {
																if (finalVarName == tempVarName) {
																	shouldSkipAssignment = true;
																};
															};
														};
													};
												} else {};
											};
										};
									};
								};
								var result = if (shouldSkipAssignment) {
									null;
								} else {
									if (initValue == null) {
										if (extractedFromTemp != null) {};
										null;
									} else {
										var shouldSkipSelfAssignment = false;
										@:ast(switch (initValue.def) {
	case EVar(varName):
		if (varName == finalVarName) {
			shouldSkipSelfAssignment = true;
		};	
	case _:
}) {
											var ` = initValue.def;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var varName = `;
													{
														if (varName == finalVarName) {
															shouldSkipSelfAssignment = true;
														};
													};
												};
											} else {};
										};
										if (shouldSkipSelfAssignment) {
											null;
										} else {
											var matchNode = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), initValue), metadata : {}, pos : pos};
											};
											if (matchNode.metadata == null) {
												matchNode.metadata = {};
											};
											matchNode.metadata.varOrigin = varOrigin;
											matchNode.metadata.varId = v.id;
											if (tempToBinderMap != null) {
												matchNode.metadata.tempToBinderMap = tempToBinderMap;
											};
											matchNode;
										};
									};
								};
								result;
							} else {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
							};
							if (matchNode != null) {
								matchNode.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
								});
							};
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var expr = el[`];
									++ `;
									@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		if (v.name == "g" || v.name.startsWith("_g") || v.name.indexOf("g") >= 0) {
			var initAST = buildFromTypedExpr(init, currentContext);
			currentContext.infrastructureVarInitValues.set(v.name, initAST);
		};	
	case _:
}) {
										var ` = expr.expr;
										if (enumIndex ` == 13) {
											var ` = `[0];
											var ` = `[1];
											{
												var v = `;
												var init = `;
												if (init != null) {
													if (v.name == "g" || StringTools.startsWith(v.name, "_g") || v.name.indexOf("g", null) >= 0) {
														var initAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														{
															var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.infrastructureVarInitValues;
															var key = v.name;
															cast this.set(key, initAST);
														};
													};
												} else {};
											};
										} else {};
									};
								};
							};
							var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
							if (comprehension != null) {
								comprehension.def;
							};
							if (el.length >= 5) {
								var hasEmptyArray = false;
								var hasZeroInit = false;
								var hasSourceAssign = false;
								var hasWhileLoop = false;
								var returnsResult = false;
								var sourceArray = null;
								var whileBody = null;
								var resultVarName = null;
								{
									var ` = 0;
									var ` = el.length;
									while (` < `) {
										var i = ` ++;
										@:ast(switch (el[i].expr) {
	case TVar(v, init) if (init != null && v.name.startsWith("_g")):
		switch (init.expr) {
			case TArrayDecl([]):
				hasEmptyArray = true;
				resultVarName = v.name;			
			case TConst(TInt(i)) if (i == 0):
				hasZeroInit = true;			
			case TLocal(_):
				hasSourceAssign = true;
				sourceArray = init;			
			case _:
		};	
	case TWhile(_, body, _):
		hasWhileLoop = true;
		whileBody = body;	
	case TLocal(v) if (v.name == resultVarName && i == el.length - 1):
		returnsResult = true;	
	case _:
}) {
											var ` = el[i].expr;
											switch (enumIndex `) {
												case 1: {
													var ` = `[0];
													{
														var v = `;
														if (v.name == resultVarName && i == el.length - 1) {
															returnsResult = true;
														} else {};
													};
												};
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null && StringTools.startsWith(v.name, "_g")) {
															@:ast(switch (init.expr) {
	case TArrayDecl([]):
		hasEmptyArray = true;
		resultVarName = v.name;	
	case TConst(TInt(i)) if (i == 0):
		hasZeroInit = true;	
	case TLocal(_):
		hasSourceAssign = true;
		sourceArray = init;	
	case _:
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 0: {
																		var ` = `[0];
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			{
																				var i = `;
																				if (i == 0) {
																					hasZeroInit = true;
																				} else {};
																			};
																		} else {};
																	};
																	case 1: {
																		var ` = `[0];
																		{
																			hasSourceAssign = true;
																			sourceArray = init;
																		};
																	};
																	case 8: {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				hasEmptyArray = true;
																				resultVarName = v.name;
																			};
																		} else {};
																	};
																	default: {}
																};
															};
														} else {};
													};
												};
												case 17: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var body = `;
														{
															hasWhileLoop = true;
															whileBody = body;
														};
													};
												};
												default: {}
											};
										};
									};
								};
								var isArrayPattern = hasEmptyArray && hasZeroInit && hasSourceAssign && hasWhileLoop && returnsResult;
								if (isArrayPattern && sourceArray != null && whileBody != null) {
									var operation = reflaxe.elixir.ast.ElixirASTPatterns.detectArrayOperationPattern(whileBody);
									if (operation != null) {
										return reflaxe.elixir.ast.ElixirASTBuilder.generateIdiomaticEnumCall(sourceArray, operation, whileBody);
									};
								};
							};
							if (el.length == 2) {
								@:ast(switch ([el[0].expr, el[1].expr]) {
	case [TVar(tmpVar, init), TBinop(OpNullCoal, { expr : TLocal(v) }, defaultExpr)] if (v.id == tmpVar.id && init != null):
		var initAst = buildFromTypedExpr(init, currentContext);
		var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
		var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		return ifExpr.def;	
	case _:
}) {
									var ` = el[0].expr;
									var ` = el[1].expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 3) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 24) {
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 1) {
														var ` = `[0];
														{
															var v = `;
															var defaultExpr = `;
															var init = `;
															var tmpVar = `;
															if (v.id == tmpVar.id && init != null) {
																var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																	tmpVar.name.substr(1, null);
																} else {
																	tmpVar.name;
																}, null);
																var ifExpr = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																		}, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	}, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																	}, defaultAst), metadata : {}, pos : pos};
																};
																if (ifExpr.metadata == null) {
																	ifExpr.metadata = {};
																};
																ifExpr.metadata.keepInlineInAssignment = true;
																return ifExpr.def;
															} else {};
														};
													} else {};
												};
											} else {};
										} else {};
									} else {};
								};
							};
							if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
								return reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext), function(name:String) return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null));
							};
							if (el.length >= 2) {
								var isConditionalComprehension = false;
								var tempVarName = "";
								@:ast(switch (el[0].expr) {
	case TVar(v, init) if (init != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;
				if (el.length >= 3) {
					switch (el[1].expr) {
						case TBlock(innerStmts):
							var allIfs = true;
							for (stmt  in  innerStmts) {
								switch (stmt.expr) {
									case TIf(_, thenExpr, null):
										switch (thenExpr.expr) {
											case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
												switch (rhs.expr) {
													case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
													default:
														allIfs = false;													
												};											
											default:
												allIfs = false;											
										};									
									default:
										allIfs = false;									
								};
							};
							if (allIfs && el.length > 2) {
								switch (el[el.length - 1].expr) {
									case TLocal(v) if (v.name == tempVarName):
										isConditionalComprehension = true;									
									default:
								};
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
									var ` = el[0].expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											if (init != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
												@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;
		if (el.length >= 3) {
			switch (el[1].expr) {
				case TBlock(innerStmts):
					var allIfs = true;
					for (stmt  in  innerStmts) {
						switch (stmt.expr) {
							case TIf(_, thenExpr, null):
								switch (thenExpr.expr) {
									case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
										switch (rhs.expr) {
											case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
											default:
												allIfs = false;											
										};									
									default:
										allIfs = false;									
								};							
							default:
								allIfs = false;							
						};
					};
					if (allIfs && el.length > 2) {
						switch (el[el.length - 1].expr) {
							case TLocal(v) if (v.name == tempVarName):
								isConditionalComprehension = true;							
							default:
						};
					};				
				default:
			};
		};	
	default:
}) {
													var ` = init.expr;
													if (enumIndex ` == 8) {
														var ` = `[0];
														if (`.length == 0) {
															{
																tempVarName = v.name;
																if (el.length >= 3) {
																	@:ast(switch (el[1].expr) {
	case TBlock(innerStmts):
		var allIfs = true;
		for (stmt  in  innerStmts) {
			switch (stmt.expr) {
				case TIf(_, thenExpr, null):
					switch (thenExpr.expr) {
						case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
							switch (rhs.expr) {
								case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
								default:
									allIfs = false;								
							};						
						default:
							allIfs = false;						
					};				
				default:
					allIfs = false;				
			};
		};
		if (allIfs && el.length > 2) {
			switch (el[el.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
					isConditionalComprehension = true;				
				default:
			};
		};	
	default:
}) {
																		var ` = el[1].expr;
																		if (enumIndex ` == 14) {
																			var ` = `[0];
																			{
																				var innerStmts = `;
																				{
																					var allIfs = true;
																					{
																						var ` = 0;
																						while (` < innerStmts.length) {
																							var stmt = innerStmts[`];
																							++ `;
																							@:ast(switch (stmt.expr) {
	case TIf(_, thenExpr, null):
		switch (thenExpr.expr) {
			case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
				switch (rhs.expr) {
					case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
					default:
						allIfs = false;					
				};			
			default:
				allIfs = false;			
		};	
	default:
		allIfs = false;	
}) {
																								var ` = stmt.expr;
																								if (enumIndex ` == 16) {
																									var ` = `[0];
																									var ` = `[1];
																									var ` = `[2];
																									if (` == null) {
																										var thenExpr = `;
																										{
																											@:ast(switch (thenExpr.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
			default:
				allIfs = false;			
		};	
	default:
		allIfs = false;	
}) {
																												var ` = thenExpr.expr;
																												if (enumIndex ` == 3) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 4) {
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var v = `;
																																	var rhs = `;
																																	if (v.name == tempVarName) {
																																		@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) if (v2.name == tempVarName):
	default:
		allIfs = false;	
}) {
																																			var ` = rhs.expr;
																																			if (enumIndex ` == 3) {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				if (enumIndex ` == 0) {
																																					{
																																						var ` = `.expr;
																																						var ` = `.pos;
																																						var ` = `.t;
																																						if (enumIndex ` == 1) {
																																							var ` = `[0];
																																							{
																																								var ` = `.expr;
																																								var ` = `.pos;
																																								var ` = `.t;
																																								if (enumIndex ` == 8) {
																																									var ` = `[0];
																																									if (`.length == 1) {
																																										var ` = `[0];
																																										{
																																											var v2 = `;
																																											if (v2.name == tempVarName) {} else {
																																												allIfs = false;
																																											};
																																										};
																																									} else {
																																										allIfs = false;
																																									};
																																								} else {
																																									allIfs = false;
																																								};
																																							};
																																						} else {
																																							allIfs = false;
																																						};
																																					};
																																				} else {
																																					allIfs = false;
																																				};
																																			} else {
																																				allIfs = false;
																																			};
																																		};
																																	} else {
																																		allIfs = false;
																																	};
																																};
																															} else {
																																allIfs = false;
																															};
																														};
																													} else {
																														allIfs = false;
																													};
																												} else {
																													allIfs = false;
																												};
																											};
																										};
																									} else {
																										allIfs = false;
																									};
																								} else {
																									allIfs = false;
																								};
																							};
																						};
																					};
																					if (allIfs && el.length > 2) {
																						@:ast(switch (el[el.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
		isConditionalComprehension = true;	
	default:
}) {
																							var ` = el[el.length - 1].expr;
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								{
																									var v = `;
																									if (v.name == tempVarName) {
																										isConditionalComprehension = true;
																									} else {};
																								};
																							} else {};
																						};
																					};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													} else {};
												};
											} else {};
										};
									} else {};
								};
								if (isConditionalComprehension) {
									var reconstructed = reflaxe.elixir.ast.ElixirASTBuilder.tryReconstructConditionalComprehension(el, tempVarName, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
									if (reconstructed != null) {
										return reconstructed.def;
									};
								};
							};
							if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(el)) {
								var listElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(el);
								if (listElements != null && listElements.length > 0) {
									var blockStmts = {
										var ` = [];
										{
											var ` = 0;
											while (` < el.length) {
												var e = el[`];
												++ `;
												`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
											};
										};
										`;
									};
									var blockAST = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(blockStmts), metadata : {}, pos : pos};
									};
									if (blockAST.metadata == null) {
										blockAST.metadata = {};
									};
									blockAST.metadata.isUnrolledComprehension = true;
									blockAST.metadata.comprehensionElements = listElements.length;
									return blockAST.def;
								};
							} else {};
							var isInLoopContext = false;
							if (el.length == 2 && ! isInLoopContext) {
								@:ast(switch ([el[0].expr, el[1].expr]) {
	case [TVar(v, init), expr] if (init != null):
		var isUsed = if (currentContext.variableUsageMap != null && currentContext.variableUsageMap.exists(v.id)) {
			currentContext.variableUsageMap.get(v.id);
		} else {
			true;
		};
		var baseName = toElixirVarName(v.name);
		var varName = if (!isUsed) {
			baseName;
		} else {
			baseName;
		};
		var initExpr = buildFromTypedExpr(init, currentContext);
		var bodyExpr = buildFromTypedExpr(el[1], currentContext);
		var isInCaseClause = currentContext.currentClauseContext != null;
		var containsNestedIf = containsIfStatement(el[1]);
		var shouldPreserveDeclaration = isInCaseClause || containsNestedIf;
		if (!shouldPreserveDeclaration) {
			var usageCount = countVarOccurrencesInAST(bodyExpr, varName);
			if (usageCount == 1) {
				var inlined = replaceVarInAST(bodyExpr, varName, initExpr);
				return inlined.def;
			};
		};
		return EBlock([makeAST(EMatch(PVar(varName), initExpr)), bodyExpr]);	
	default:
}) {
									var ` = el[0].expr;
									var ` = el[1].expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											var expr = `;
											if (init != null) {
												var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap != null && {
													var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
													var key = v.id;
													cast this.exists(key);
												}) {
													{
														var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
														var key = v.id;
														cast this.get(key);
													};
												} else {
													true;
												};
												var baseName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
												var varName = if (! isUsed) {
													baseName;
												} else {
													baseName;
												};
												var initExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												var bodyExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(el[1], reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												var isInCaseClause = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null;
												var containsNestedIf = reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(el[1]);
												var shouldPreserveDeclaration = isInCaseClause || containsNestedIf;
												if (! shouldPreserveDeclaration) {
													var usageCount = reflaxe.elixir.ast.ElixirASTBuilder.countVarOccurrencesInAST(bodyExpr, varName);
													if (usageCount == 1) {
														var inlined = reflaxe.elixir.ast.ElixirASTBuilder.replaceVarInAST(bodyExpr, varName, initExpr);
														return inlined.def;
													};
												};
												return reflaxe.elixir.ast.ElixirASTDef.EBlock([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), initExpr), metadata : {}, pos : pos};
												}, bodyExpr]);
											} else {};
										};
									} else {};
								};
							};
							var expressions = [];
							var isInCaseClause = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null;
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									var shouldSkip = false;
									if (! isInCaseClause) {
										@:ast(switch (e.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, _):
				var originalName = v.name;
				var tempVarName = toElixirVarName(v.name);
				if (originalName == "_g" || originalName == "g" || (originalName.startsWith("_g") && originalName.length > 2) || (originalName.startsWith("g") && originalName.length > 1 && originalName.charAt(1) >= "0" && originalName.charAt(1) <= "9")) {
					shouldSkip = true;
				} else { };			
			case _:
		};	
	case TBinop(OpAssign, { expr : TLocal(lhs) }, { expr : TLocal(rhs) }):
		var lhsName = toElixirVarName(lhs.name);
		var rhsName = toElixirVarName(rhs.name);
		if (isTempPatternVarName(lhsName) || lhsName == rhsName || isTempPatternVarName(rhsName)) {
			shouldSkip = true;
		};	
	case _:
}) {
											var ` = e.expr;
											switch (enumIndex `) {
												case 3: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													if (enumIndex ` == 4) {
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var rhs = `;
																			var lhs = `;
																			{
																				var lhsName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(lhs.name, null);
																				var rhsName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(rhs.name, null);
																				if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(lhsName) || lhsName == rhsName || reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(rhsName)) {
																					shouldSkip = true;
																				};
																			};
																		};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null) {
															@:ast(switch (init.expr) {
	case TEnumParameter(_, _, _):
		var originalName = v.name;
		var tempVarName = toElixirVarName(v.name);
		if (originalName == "_g" || originalName == "g" || (originalName.startsWith("_g") && originalName.length > 2) || (originalName.startsWith("g") && originalName.length > 1 && originalName.charAt(1) >= "0" && originalName.charAt(1) <= "9")) {
			shouldSkip = true;
		} else { };	
	case _:
}) {
																var ` = init.expr;
																if (enumIndex ` == 26) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var originalName = v.name;
																		var tempVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																		if (originalName == "_g" || originalName == "g" || (StringTools.startsWith(originalName, "_g") && originalName.length > 2) || (StringTools.startsWith(originalName, "g") && originalName.length > 1 && originalName.charAt(1) >= "0" && originalName.charAt(1) <= "9")) {
																			shouldSkip = true;
																		} else {};
																	};
																} else {};
															};
														} else {};
													};
												};
												default: {}
											};
										};
									};
									if (! shouldSkip) {
										@:ast(switch (e.expr) {
	case TBinop(OpAssign, { expr : TLocal(lhs) }, { expr : TLocal(rhs) }):
		var lhsName = toElixirVarName(lhs.name);
		var rhsName = toElixirVarName(rhs.name);
		if (isTempPatternVarName(lhsName) || lhsName == rhsName || isTempPatternVarName(rhsName)) {
			shouldSkip = true;
		};	
	case _:
}) {
											var ` = e.expr;
											if (enumIndex ` == 3) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 4) {
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var ` = `.expr;
																var ` = `.pos;
																var ` = `.t;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	{
																		var rhs = `;
																		var lhs = `;
																		{
																			var lhsName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(lhs.name, null);
																			var rhsName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(rhs.name, null);
																			if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(lhsName) || lhsName == rhsName || reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(rhsName)) {
																				shouldSkip = true;
																			};
																		};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											} else {};
										};
									};
									if (! shouldSkip) {
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										if (builtExpr != null) {
											expressions.push(builtExpr);
										} else {};
									} else {};
								};
							};
							var needsCombining = false;
							{
								var ` = 0;
								var ` = expressions.length - 1;
								while (` < `) {
									var i = ` ++;
									var current = expressions[i];
									var next = expressions[i + 1];
									if (current == null || next == null || current.def == null || next.def == null) {
										continue;
									};
									@:ast(switch ([current.def, next.def]) {
	case [EMatch(_, _), ECall(_, _, _)]:
		needsCombining = true;
		break;	
	case _:
}) {
										var ` = current.def;
										var ` = next.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 22) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													needsCombining = true;
													break;
												};
											} else {};
										} else {};
									};
								};
							};
							if (needsCombining) {
								var combinedBlock = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(expressions), metadata : {}, pos : pos};
								};
								var transformed = reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass(combinedBlock);
								transformed.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.EBlock(expressions);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var v = `;
						var e1 = `;
						var e2 = `;
						{
							var loopMetadata = reflaxe.elixir.ast.ElixirASTBuilder.createMetadata(expr);
							loopMetadata.loopVariableName = v.name;
							loopMetadata.originalLoopExpression = reflaxe.elixir.ast.ElixirASTBuilder.captureExpressionText(e2, v.name);
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isFeatureEnabled("loop_builder_enabled")) {
								var guard = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.reentrancyGuard;
								var forExpr = expr;
								var safeBuilder = function() {
									var transform = reflaxe.elixir.ast.builders.LoopBuilder.analyzeFor(v, e1, e2);
									return reflaxe.elixir.ast.builders.LoopBuilder.buildFromTransform(transform, function(e:haxe.macro.TypedExpr) {
										return guard.process(e, function() {
											return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										});
									}, function(name:String) return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null));
								};
								var ast = guard.process(forExpr, safeBuilder);
								if (ast != null) {
									{def : ast.def, metadata : loopMetadata, pos : expr.pos}.def;
								} else {
									ast.def;
								};
							} else {
								var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
								var pattern = reflaxe.elixir.ast.EPattern.PVar(varName);
								var iteratorExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								var bodyExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								var forDef = reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : iteratorExpr}], [], bodyExpr, null, false);
								{def : forDef, metadata : loopMetadata, pos : expr.pos}.def;
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							var condition = @:ast(switch (econd.expr) {
	case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
		makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, currentContext), function(name) return toElixirVarName(name)));	
	case _:
		buildFromTypedExpr(econd, currentContext);	
}) {
								var ` = econd.expr;
								if (enumIndex ` == 14) {
									var ` = `[0];
									{
										var el = `;
										if (reflaxe.elixir.ast.ElixirASTPatterns.isInlineExpansionBlock(el)) {
											{
												var def = reflaxe.elixir.ast.ElixirASTPatterns.transformInlineExpansion(el, function(e:haxe.macro.TypedExpr) {
													return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												}, function(name:String) {
													return reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null);
												});
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										};
									};
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								};
							};
							var thenBranch = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(eif, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var elseBranch = if (eelse != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(eelse, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							} else {
								null;
							};
							reflaxe.elixir.ast.ElixirASTDef.EIf(condition, thenBranch, elseBranch);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var e = `;
						var normalWhile = `;
						{
							var isMapKeysLoop = false;
							var keysCollection = null;
							var indexVar = null;
							var actualCondition = @:ast(switch (econd.expr) {
	case TParenthesis(e):
		e;	
	case _:
		econd;	
}) {
								var ` = econd.expr;
								if (enumIndex ` == 6) {
									var ` = `[0];
									{
										var e = `;
										{
											e;
										};
									};
								} else {
									econd;
								};
							};
							@:ast(switch (actualCondition.expr) {
	case TBinop(OpLt, { expr : TLocal(idx) }, lengthExpr):
		if (idx.name == "g" || idx.name.startsWith("_g") || idx.name.indexOf("g") >= 0) {
			indexVar = idx.name;
			switch (lengthExpr.expr) {
				case TCall(callExpr, args):
					switch (callExpr.expr) {
						case TField(_, FStatic(_, cf)):
							if (cf.get().name == "length" && args.length > 0) {
								switch (args[0].expr) {
									case TLocal(coll):
										keysCollection = coll.name;
										isMapKeysLoop = true;									
									case _:
								};
							};						
						case _:
					};				
				case TField({ expr : TLocal(coll) }, FInstance(_, _, cf)):
					if (cf.get().name == "length") {
						keysCollection = coll.name;
						if (coll.name == "g1" || coll.name.indexOf("g1") >= 0) {
							isMapKeysLoop = true;
						};
					};				
				case _:
			};
		};	
	case TParenthesis(_):
	case _:
}) {
								var ` = actualCondition.expr;
								switch (enumIndex `) {
									case 3: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 9) {
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 1) {
													var ` = `[0];
													{
														var idx = `;
														var lengthExpr = `;
														{
															if (idx.name == "g" || StringTools.startsWith(idx.name, "_g") || idx.name.indexOf("g", null) >= 0) {
																indexVar = idx.name;
																@:ast(switch (lengthExpr.expr) {
	case TCall(callExpr, args):
		switch (callExpr.expr) {
			case TField(_, FStatic(_, cf)):
				if (cf.get().name == "length" && args.length > 0) {
					switch (args[0].expr) {
						case TLocal(coll):
							keysCollection = coll.name;
							isMapKeysLoop = true;						
						case _:
					};
				};			
			case _:
		};	
	case TField({ expr : TLocal(coll) }, FInstance(_, _, cf)):
		if (cf.get().name == "length") {
			keysCollection = coll.name;
			if (coll.name == "g1" || coll.name.indexOf("g1") >= 0) {
				isMapKeysLoop = true;
			};
		};	
	case _:
}) {
																	var ` = lengthExpr.expr;
																	switch (enumIndex `) {
																		case 4: {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var cf = `;
																							var coll = `;
																							{
																								if (cf.get().name == "length") {
																									keysCollection = coll.name;
																									if (coll.name == "g1" || coll.name.indexOf("g1", null) >= 0) {
																										isMapKeysLoop = true;
																									};
																								};
																							};
																						};
																					} else {};
																				} else {};
																			};
																		};
																		case 9: {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var callExpr = `;
																				var args = `;
																				{
																					@:ast(switch (callExpr.expr) {
	case TField(_, FStatic(_, cf)):
		if (cf.get().name == "length" && args.length > 0) {
			switch (args[0].expr) {
				case TLocal(coll):
					keysCollection = coll.name;
					isMapKeysLoop = true;				
				case _:
			};
		};	
	case _:
}) {
																						var ` = callExpr.expr;
																						if (enumIndex ` == 4) {
																							var ` = `[0];
																							var ` = `[1];
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var cf = `;
																									{
																										if (cf.get().name == "length" && args.length > 0) {
																											@:ast(switch (args[0].expr) {
	case TLocal(coll):
		keysCollection = coll.name;
		isMapKeysLoop = true;	
	case _:
}) {
																												var ` = args[0].expr;
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var coll = `;
																														{
																															keysCollection = coll.name;
																															isMapKeysLoop = true;
																														};
																													};
																												} else {};
																											};
																										};
																									};
																								};
																							} else {};
																						} else {};
																					};
																				};
																			};
																		};
																		default: {}
																	};
																};
															};
														};
													};
												} else {};
											};
										} else {};
									};
									case 6: {
										var ` = `[0];
										{};
									};
									default: {}
								};
							};
							if (false && isMapKeysLoop && keysCollection != null && indexVar != null) {
								var loopVar = null;
								var bodyWithoutExtraction = e;
								@:ast(switch (e.expr) {
	case TBlock(stmts) if (stmts.length > 0):
		switch (stmts[0].expr) {
			case TVar(v, { expr : TArray({ expr : TLocal(coll) }, { expr : TLocal(idx) }) }) if (coll.name == keysCollection && idx.name == indexVar):
				loopVar = toElixirVarName(v.name);
				var restStmts = stmts.slice(1);
				if (restStmts.length > 0) {
					switch (restStmts[0].expr) {
						case TUnop(OpIncrement, _, { expr : TLocal(idx) }) if (idx.name == indexVar):
							restStmts = restStmts.slice(1);						
						case _:
					};
				};
				if (restStmts.length == 1) {
					bodyWithoutExtraction = restStmts[0];
				} else if (restStmts.length > 0) {
					bodyWithoutExtraction = { expr : TBlock(restStmts), t : e.t, pos : e.pos };
				};			
			case _:
				loopVar = "item";			
		};	
	case _:
		loopVar = "item";	
}) {
									var ` = e.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										{
											var stmts = `;
											if (stmts.length > 0) {
												@:ast(switch (stmts[0].expr) {
	case TVar(v, { expr : TArray({ expr : TLocal(coll) }, { expr : TLocal(idx) }) }) if (coll.name == keysCollection && idx.name == indexVar):
		loopVar = toElixirVarName(v.name);
		var restStmts = stmts.slice(1);
		if (restStmts.length > 0) {
			switch (restStmts[0].expr) {
				case TUnop(OpIncrement, _, { expr : TLocal(idx) }) if (idx.name == indexVar):
					restStmts = restStmts.slice(1);				
				case _:
			};
		};
		if (restStmts.length == 1) {
			bodyWithoutExtraction = restStmts[0];
		} else if (restStmts.length > 0) {
			bodyWithoutExtraction = { expr : TBlock(restStmts), t : e.t, pos : e.pos };
		};	
	case _:
		loopVar = "item";	
}) {
													var ` = stmts[0].expr;
													if (enumIndex ` == 13) {
														var ` = `[0];
														var ` = `[1];
														if (` == null) {
															loopVar = "item";
														} else {
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 2) {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var ` = `.expr;
																			var ` = `.pos;
																			var ` = `.t;
																			if (enumIndex ` == 1) {
																				var ` = `[0];
																				{
																					var idx = `;
																					var coll = `;
																					var v = `;
																					if (coll.name == keysCollection && idx.name == indexVar) {
																						loopVar = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																						var restStmts = stmts.slice(1, null);
																						if (restStmts.length > 0) {
																							@:ast(switch (restStmts[0].expr) {
	case TUnop(OpIncrement, _, { expr : TLocal(idx) }) if (idx.name == indexVar):
		restStmts = restStmts.slice(1);	
	case _:
}) {
																								var ` = restStmts[0].expr;
																								if (enumIndex ` == 11) {
																									var ` = `[0];
																									var ` = `[1];
																									var ` = `[2];
																									if (enumIndex ` == 0) {
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												{
																													var idx = `;
																													if (idx.name == indexVar) {
																														restStmts = restStmts.slice(1, null);
																													} else {};
																												};
																											} else {};
																										};
																									} else {};
																								} else {};
																							};
																						};
																						if (restStmts.length == 1) {
																							bodyWithoutExtraction = restStmts[0];
																						} else {
																							if (restStmts.length > 0) {
																								bodyWithoutExtraction = {expr : haxe.macro.TypedExprDef.TBlock(restStmts), t : e.t, pos : e.pos};
																							};
																						};
																					} else {
																						loopVar = "item";
																					};
																				};
																			} else {
																				loopVar = "item";
																			};
																		};
																	} else {
																		loopVar = "item";
																	};
																};
															} else {
																loopVar = "item";
															};
														};
													} else {
														loopVar = "item";
													};
												};
											} else {
												loopVar = "item";
											};
										};
									} else {
										loopVar = "item";
									};
								};
								var bodyAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(bodyWithoutExtraction, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								return reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : reflaxe.elixir.ast.EPattern.PVar(loopVar), expr : {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(keysCollection), metadata : {}, pos : pos};
								}}], [], bodyAst, null, false);
							};
							var isArrayLoop = false;
							var arrayRef = null;
							@:ast(switch (econd.expr) {
	case TBinop(OpLt, { expr : TLocal(indexVar) }, { expr : TField(arr, FInstance(_, _, cf)) }) if (indexVar.name.startsWith("_g") && cf.get().name == "length"):
		isArrayLoop = true;
		arrayRef = arr;	
	case _:
}) {
								var ` = econd.expr;
								if (enumIndex ` == 3) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (enumIndex ` == 9) {
										{
											var ` = `.expr;
											var ` = `.pos;
											var ` = `.t;
											if (enumIndex ` == 1) {
												var ` = `[0];
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 4) {
														var ` = `[0];
														var ` = `[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var cf = `;
																var arr = `;
																var indexVar = `;
																if (StringTools.startsWith(indexVar.name, "_g") && cf.get().name == "length") {
																	isArrayLoop = true;
																	arrayRef = arr;
																} else {};
															};
														} else {};
													} else {};
												};
											} else {};
										};
									} else {};
								} else {};
							};
							if (isArrayLoop && arrayRef != null) {
								var pattern = reflaxe.elixir.ast.ElixirASTPatterns.detectArrayOperationPattern(e);
								if (pattern != null) {
									return reflaxe.elixir.ast.ElixirASTBuilder.generateIdiomaticEnumCall(arrayRef, pattern, e);
								};
							};
							var condition = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(econd, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var loopName = "loop_" + (@:mergeBlock {
								var fh = reflaxe.elixir.ast.ElixirASTBuilder.currentContext;
								fh.whileLoopCounter ++;
							});
							var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(e);
							var conditionVars = {
								{};
								new haxe.ds.IntMap();
							};
							var findConditionVars = [null];
							findConditionVars[0] = function(expr:haxe.macro.TypedExpr) {
								if (expr == null) {
									return;
								};
								@:ast(switch (expr.expr) {
	case TLocal(v):
		conditionVars.set(v.id, v);	
	default:
		haxe.macro.TypedExprTools.iter(expr, findConditionVars);	
}) {
									var ` = expr.expr;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var v = `;
											{
												{
													var key = v.id;
													conditionVars.set(key, v);
												};
											};
										};
									} else {
										haxe.macro.TypedExprTools.iter(expr, findConditionVars[0]);
									};
								};
							};
							findConditionVars[0](econd);
							for (v in conditionVars.iterator()) {
								if (! {
									var key = v.id;
									mutatedVars.exists(key);
								}) {
									{
										var key = v.id;
										mutatedVars.set(key, v);
									};
								};
							};
							if (Lambda.count(cast mutatedVars, null) > 0) {
								var accVarList = [];
								{
									var ` = cast new haxe.iterators.MapKeyValueIterator(mutatedVars);
									while (`.hasNext()) {
										var ` = `.next();
										var id = `.key;
										var v = `.value;
										{
											accVarList.push({name : reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null), tvar : v});
										};
									};
								};
								accVarList.sort(function(a:{ tvar : haxe.macro.TVar, name : String }, b:{ tvar : haxe.macro.TVar, name : String }) return a.tvar.id - b.tvar.id);
								var initialAccValues = [];
								var accPattern = [];
								var accVarNames = [];
								{
									var ` = 0;
									while (` < accVarList.length) {
										var v = accVarList[`];
										++ `;
										var originalName = v.tvar.name;
										var transformedName = v.name;
										var initialValue = reflaxe.elixir.ast.ElixirASTBuilder.getVariableInitValue(originalName, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										initialAccValues.push(initialValue);
										accPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_" + transformedName));
										accVarNames.push(transformedName);
									};
								};
								initialAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
								});
								accPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_state"));
								var initialAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(initialAccValues), metadata : {}, pos : pos};
								};
								var accPatternTuple = reflaxe.elixir.ast.EPattern.PTuple(accPattern);
								var contAccValues = [];
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										contAccValues.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
										});
									};
								};
								contAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
								});
								var contAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(contAccValues), metadata : {}, pos : pos};
								};
								var varMapping = {
									{};
									new haxe.ds.StringMap();
								};
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										{
											varMapping.set(varName, "acc_" + varName);
										};
									};
								};
								var transformedCondition = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(condition, varMapping);
								var transformedBody = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(body, varMapping);
								var bodyHasReturn = reflaxe.elixir.ast.ElixirASTBuilder.checkForEarlyReturns(transformedBody);
								var updatedContAccValues = [];
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										updatedContAccValues.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_" + varName), metadata : {}, pos : pos};
										});
									};
								};
								updatedContAccValues.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
								});
								var updatedContAccumulator = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(updatedContAccValues), metadata : {}, pos : pos};
								};
								var wrappedBody = if (bodyHasReturn) {
									reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(transformedBody, updatedContAccumulator);
								} else {
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
											}, updatedContAccumulator]), metadata : {}, pos : pos};
										}]), metadata : {}, pos : pos};
									};
								};
								var completeBody = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, wrappedBody, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
										}, updatedContAccumulator]), metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
								var usedAccVars = {
									{};
									new haxe.ds.StringMap();
								};
								{
									var ` = 0;
									while (` < accVarNames.length) {
										var varName = accVarNames[`];
										++ `;
										var accVarName = "acc_" + varName;
										{
											var value = reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(accVarName, completeBody);
											usedAccVars.set(varName, value);
										};
									};
								};
								var isAccStateUsed = reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST("acc_state", completeBody);
								var finalAccPattern = [];
								{
									var ` = 0;
									var ` = accVarNames.length;
									while (` < `) {
										var i = ` ++;
										var varName = accVarNames[i];
										var accVarName = "acc_" + varName;
										if (cast usedAccVars.get(varName)) {
											finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar(accVarName));
										} else {
											finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar(accVarName));
										};
									};
								};
								if (isAccStateUsed) {
									finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar("acc_state"));
								} else {
									finalAccPattern.push(reflaxe.elixir.ast.EPattern.PVar("_acc_state"));
								};
								var finalAccPatternTuple = reflaxe.elixir.ast.EPattern.PTuple(finalAccPattern);
								var reduceResult = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "reduce_while", [{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Stream"), metadata : {}, pos : pos};
									}, "iterate", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("n")], guard : null, body : {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("n"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										}}]), metadata : {}, pos : pos};
									}]), metadata : {}, pos : pos};
								}, initialAccumulator, {
									var isEmptyBody = @:ast(switch (transformedBody.def) {
	case ENil:
		true;	
	case _:
		false;	
}) {
										var ` = transformedBody.def;
										if (enumIndex ` == 36) {
											{
												true;
											};
										} else {
											false;
										};
									};
									var accPatternToUse = if (isEmptyBody && Lambda.count(cast mutatedVars, null) > 0) {
										var wildcardPatterns = [];
										{
											var ` = 0;
											var ` = (accVarNames.length + 1);
											while (` < `) {
												var i = ` ++;
												wildcardPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
										reflaxe.elixir.ast.EPattern.PTuple(wildcardPatterns);
									} else {
										finalAccPatternTuple;
									};
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PWildcard, accPatternToUse], guard : null, body : {
											var updatedContAccValues = [];
											{
												var ` = 0;
												while ((` < accVarNames.length)) {
													var varName = accVarNames[`];
													++ `;
													updatedContAccValues.push({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_" + varName), metadata : {}, pos : pos};
													});
												};
											};
											updatedContAccValues.push({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc_state"), metadata : {}, pos : pos};
											});
											var updatedContAccumulator = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(updatedContAccValues), metadata : {}, pos : pos};
											};
											var wrappedBody = if ((bodyHasReturn)) reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(transformedBody, updatedContAccumulator) else if ((isEmptyBody)) {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
												}, updatedContAccumulator]), metadata : {}, pos : pos};
											} else {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
													}, updatedContAccumulator]), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, wrappedBody, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
													}, if ((isEmptyBody)) {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
													} else updatedContAccumulator]), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											};
										}}]);
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									};
								}]);
								reduceResult;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "reduce_while", [{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Stream"), metadata : {}, pos : pos};
									}, "iterate", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("n")], guard : null, body : {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("n"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										}}]), metadata : {}, pos : pos};
									}]), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PWildcard, reflaxe.elixir.ast.EPattern.PVar("acc")], guard : null, body : {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condition, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([body, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
												}, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											}]), metadata : {}, pos : pos};
										}, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
											}, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
											}]), metadata : {}, pos : pos};
										}), metadata : {}, pos : pos};
									}}]), metadata : {}, pos : pos};
								}]);
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var cases = `;
						var edef = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.switchNestingLevel ++;
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.builderFacade != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isFeatureEnabled("use_new_pattern_builder")) {
								try {
									var facadeCases = {
										var ` = [];
										{
											var ` = 0;
											var ` = cases;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(function(c:{ values : Array<haxe.macro.TypedExpr>, expr : haxe.macro.TypedExpr }) {
													return {values : c.values, expr : c.expr, guard : null};
												}(v));
											};
										};
										`;
									};
									var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.builderFacade.routeSwitch(e, facadeCases, edef);
									return switchAST.def;
								} catch (`:Dynamic) {
									{};
									{};
									if (true) {
										{};
										{};
									} else throw `;
								};
							};
							var extractEnumTypeFromSwitch = [null];
							extractEnumTypeFromSwitch[0] = function(expr:haxe.macro.TypedExpr) {
								return @:ast(switch (expr.expr) {
	case TParenthesis(innerExpr):
		extractEnumTypeFromSwitch(innerExpr);	
	case TMeta(_, innerExpr):
		extractEnumTypeFromSwitch(innerExpr);	
	case TEnumIndex(enumExpr):
		switch (enumExpr.t) {
			case TEnum(enumRef, _):
				enumRef.get();			
			default:
				null;			
		};	
	default:
		switch (expr.t) {
			case TEnum(enumRef, _):
				enumRef.get();			
			default:
				null;			
		};	
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 6: {
											var ` = `[0];
											{
												var innerExpr = `;
												{
													extractEnumTypeFromSwitch[0](innerExpr);
												};
											};
										};
										case 25: {
											var ` = `[0];
											var ` = `[1];
											{
												var innerExpr = `;
												{
													extractEnumTypeFromSwitch[0](innerExpr);
												};
											};
										};
										case 27: {
											var ` = `[0];
											{
												var enumExpr = `;
												{
													@:ast(switch (enumExpr.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		null;	
}) {
														var ` = enumExpr.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															var ` = `[1];
															{
																var enumRef = `;
																{
																	enumRef.get();
																};
															};
														} else {
															null;
														};
													};
												};
											};
										};
										default: {
											@:ast(switch (expr.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		null;	
}) {
												var ` = expr.t;
												if (enumIndex ` == 1) {
													var ` = `[0];
													var ` = `[1];
													{
														var enumRef = `;
														{
															enumRef.get();
														};
													};
												} else {
													null;
												};
											};
										}
									};
								};
							};
							var enumType = extractEnumTypeFromSwitch[0](e);
							var hasEnumType = enumType != null;
							var isIdiomaticEnum = enumType != null && enumType.meta.has(":elixirIdiomatic");
							var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
							var clauses = [];
							var needsTempVar = false;
							var tempVarName = "temp_result";
							var isReturnContext = false;
							var hasAnyEnumBindingPlan = false;
							var bindingPlanId = if (enumType != null) {
								var idComponents = [];
								var timestamp = Std.int(Sys.time() * 1000000);
								var random = Std.random(10000);
								idComponents.push("" + timestamp + "_" + random);
								if (e.pos != null) {
									var posInfo = haxe.macro.PositionTools.toLocation(e.pos);
									var fileStr = if (posInfo.file == null) "null" else cast posInfo.file;
									var fileParts = fileStr.split("/");
									var fileName = fileParts[fileParts.length - 1];
									idComponents.push("" + fileName + "_L" + posInfo.range.start.line);
								};
								var targetType = Type.enumConstructor(e.expr);
								idComponents.push(targetType);
								if (enumType != null && enumType.name != null) {
									idComponents.push(enumType.name);
								};
								"enum_" + idComponents.join("_");
							} else {
								null;
							};
							var switchSavedContext = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext;
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									var extractedParams = reflaxe.elixir.ast.ElixirASTBuilder.analyzeEnumParameterExtraction(c.expr, c.values);
									var bindingResult = reflaxe.elixir.ast.ElixirASTBuilder.createEnumBindingPlan(c.expr, extractedParams, enumType);
									var enumBindingPlan = bindingResult.plan;
									var paramIndexToVarId = bindingResult.paramIndexToVarId;
									if (enumBindingPlan != null && enumBindingPlan.keys().hasNext()) {
										hasAnyEnumBindingPlan = true;
										if (bindingPlanId != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext != null) {
											reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext.storeEnumBindingPlan(bindingPlanId, enumBindingPlan);
										};
									};
									for (index in enumBindingPlan.keys()) {
										var info = cast enumBindingPlan.get(index);
										if (index < extractedParams.length) {
											extractedParams[index] = info.finalName;
										};
									};
									var varMapping = reflaxe.elixir.ast.ElixirASTBuilder.createVariableMappingsForCase(c.expr, extractedParams, enumType, c.values, enumBindingPlan);
									var patternParamNames = if (enumBindingPlan != null) {
										var names = [];
										var maxIndex = 0;
										{
											var ` = cast new haxe.iterators.MapKeyValueIterator(enumBindingPlan);
											while (`.hasNext()) {
												var ` = `.next();
												var index = `.key;
												var info = `.value;
												{
													if (index > maxIndex) {
														maxIndex = index;
													};
												};
											};
										};
										{
											var ` = 0;
											var ` = (maxIndex + 1);
											while (` < `) {
												var i = ` ++;
												if (enumBindingPlan.exists(i)) {
													names.push(cast enumBindingPlan.get(i).finalName);
												} else {
													names.push("_g" + i);
												};
											};
										};
										names;
									} else {
										extractedParams;
									};
									var patterns = if (hasEnumType && enumType != null) {
										if (isIdiomaticEnum) {
											{
												var ` = [];
												{
													var ` = 0;
													var ` = c.values;
													while (` < `.length) {
														var v = `[`];
														++ `;
														`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithExtraction(v, enumType, patternParamNames, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap));
													};
												};
												`;
											};
										} else {
											{
												var ` = [];
												{
													var ` = 0;
													var ` = c.values;
													while (` < `.length) {
														var v = `[`];
														++ `;
														`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertRegularEnumPatternWithExtraction(v, enumType, patternParamNames, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap));
													};
												};
												`;
											};
										};
									} else {
										{
											var ` = [];
											{
												var ` = 0;
												var ` = c.values;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPatternWithExtraction(v, patternParamNames));
												};
											};
											`;
										};
									};
									var savedClauseContext = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext;
									reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext = new reflaxe.elixir.ast.context.ClauseContext(savedClauseContext, varMapping, enumBindingPlan);
									if (paramIndexToVarId != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.markPatternSatisfiedVars(paramIndexToVarId);
									};
									var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(c.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									if (body.metadata == null) {
										body.metadata = {};
									};
									body.metadata.varIdToName = varMapping;
									{
										var ` = 0;
										while (` < patterns.length) {
											var pattern = patterns[`];
											++ `;
											var finalPattern = reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(pattern, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap, extractedParams);
											var updatedMapping = reflaxe.elixir.ast.ElixirASTBuilder.updateMappingForUnderscorePrefixes(finalPattern, varMapping, extractedParams);
											var finalBody = if (updatedMapping != varMapping) {
												reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext = new reflaxe.elixir.ast.context.ClauseContext(savedClauseContext, updatedMapping, enumBindingPlan);
												if (paramIndexToVarId != null) {
													reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.markPatternSatisfiedVars(paramIndexToVarId);
												};
												var newBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(c.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												newBody;
											} else {
												body;
											};
											clauses.push({pattern : finalPattern, guard : null, body : finalBody});
										};
									};
								};
							};
							if (edef != null) {
								clauses.push({pattern : reflaxe.elixir.ast.EPattern.PWildcard, guard : null, body : reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(edef, reflaxe.elixir.ast.ElixirASTBuilder.currentContext)});
							};
							var caseASTDef = reflaxe.elixir.ast.ElixirASTDef.ECase({
								var pos = null;
								{def : expr, metadata : {}, pos : pos};
							}, clauses);
							var caseNode = {
								var pos = null;
								{def : caseASTDef, metadata : {}, pos : pos};
							};
							if (hasAnyEnumBindingPlan) {
								if (caseNode.metadata == null) {
									caseNode.metadata = {};
								};
								caseNode.metadata.hasEnumBindingPlan = true;
								if (bindingPlanId != null) {
									caseNode.metadata.enumBindingPlanId = bindingPlanId;
								};
							};
							reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext = switchSavedContext;
							reflaxe.elixir.ast.ElixirASTBuilder.switchNestingLevel --;
							if (isReturnContext && needsTempVar) {
								reflaxe.elixir.ast.ElixirASTDef.EBlock([{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tempVarName), caseNode), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVarName), metadata : {}, pos : pos};
								}]);
							} else {
								caseNode.def;
							};
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var rescueClauses = [];
							{
								var ` = 0;
								while (` < catches.length) {
									var c = catches[`];
									++ `;
									var pattern = reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(c.v.name, null));
									var catchBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(c.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									rescueClauses.push({pattern : pattern, body : catchBody});
								};
							};
							reflaxe.elixir.ast.ElixirASTDef.ETry(body, rescueClauses, [], null, null);
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var e = `;
						{
							if (e != null) {
								var returnExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								returnExpr.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.ENil;
							};
						};
					};
				};
				case 21: {
					{
						reflaxe.elixir.ast.ElixirASTDef.EThrow({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "break"), metadata : {}, pos : pos};
						});
					};
				};
				case 22: {
					{
						reflaxe.elixir.ast.ElixirASTDef.EThrow({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "continue"), metadata : {}, pos : pos};
						});
					};
				};
				case 23: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EThrow(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var m = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var m = `;
						var e = `;
						{
							if (m.name == ":mergeBlock") {
								@:ast(switch (e.expr) {
	case TBlock([{ expr : TVar(tmpVar, init) }, secondExpr]) if (init != null):
		switch (secondExpr.expr) {
			case TIf(condition, thenBranch, elseBranch):
				var isNullCheck = switch (condition.expr) {
					case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
						v.id == tmpVar.id;					
					default:
						false;					
				};
				if (isNullCheck) {
					var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var initAst = buildFromTypedExpr(init, currentContext);
					var elseAst = buildFromTypedExpr(elseBranch, currentContext);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					return ifExpr.def;
				};			
			default:
		};	
	default:
}) {
									var ` = e.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 13) {
													var ` = `[0];
													var ` = `[1];
													{
														var tmpVar = `;
														var init = `;
														var secondExpr = `;
														if (init != null) {
															@:ast(switch (secondExpr.expr) {
	case TIf(condition, thenBranch, elseBranch):
		var isNullCheck = switch (condition.expr) {
			case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
				v.id == tmpVar.id;			
			default:
				false;			
		};
		if (isNullCheck) {
			var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
			var initAst = buildFromTypedExpr(init, currentContext);
			var elseAst = buildFromTypedExpr(elseBranch, currentContext);
			var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))), makeAST(ENil))), makeAST(EVar(tmpVarName)), elseAst));
			if (ifExpr.metadata == null) ifExpr.metadata = { };
			ifExpr.metadata.keepInlineInAssignment = true;
			return ifExpr.def;
		};	
	default:
}) {
																var ` = secondExpr.expr;
																if (enumIndex ` == 16) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var condition = `;
																		var thenBranch = `;
																		var elseBranch = `;
																		{
																			var isNullCheck = @:ast(switch (condition.expr) {
	case TParenthesis({ expr : TBinop(OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }) }):
		v.id == tmpVar.id;	
	default:
		false;	
}) {
																				var ` = condition.expr;
																				if (enumIndex ` == 6) {
																					var ` = `[0];
																					{
																						var ` = `.expr;
																						var ` = `.pos;
																						var ` = `.t;
																						if (enumIndex ` == 3) {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							if (enumIndex ` == 6) {
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 0) {
																												var ` = `[0];
																												if (enumIndex ` == 4) {
																													{
																														var v = `;
																														{
																															v.id == tmpVar.id;
																														};
																													};
																												} else {
																													false;
																												};
																											} else {
																												false;
																											};
																										};
																									} else {
																										false;
																									};
																								};
																							} else {
																								false;
																							};
																						} else {
																							false;
																						};
																					};
																				} else {
																					false;
																				};
																			};
																			if (isNullCheck) {
																				var tmpVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																					tmpVar.name.substr(1, null);
																				} else {
																					tmpVar.name;
																				}, null);
																				var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var elseAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(elseBranch, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var ifExpr = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EParen({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																							}), metadata : {}, pos : pos};
																						}, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					}, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																					}, elseAst), metadata : {}, pos : pos};
																				};
																				if (ifExpr.metadata == null) {
																					ifExpr.metadata = {};
																				};
																				ifExpr.metadata.keepInlineInAssignment = true;
																				return ifExpr.def;
																			};
																		};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									} else {};
								};
							};
							var innerAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							innerAST.def;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var ef = `;
						var index = `;
						{
							var sourceVarName = null;
							@:ast(switch (e.expr) {
	case TLocal(v):
		sourceVarName = toElixirVarName(v.name);	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var v = `;
										{
											sourceVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
										};
									};
								} else {};
							};
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
								cast this.exists(index);
							}) {
								var info = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
									cast this.get(index);
								};
								if (sourceVarName != null && (sourceVarName == "g" || (StringTools.startsWith(sourceVarName, "g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
									if (info.finalName != sourceVarName) {
										return reflaxe.elixir.ast.ElixirASTDef.EVar(info.finalName);
									};
								};
								if (info.finalName == sourceVarName && sourceVarName != null) {
									return null;
								} else {
									return reflaxe.elixir.ast.ElixirASTDef.EVar(info.finalName);
								};
							} else {
								if (sourceVarName != null && (sourceVarName == "g" || (StringTools.startsWith(sourceVarName, "g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
									return null;
								};
								var skipExtraction = false;
								var extractedVarName = null;
								if (! skipExtraction) {
									@:ast(switch (e.expr) {
	case TLocal(v):
		var varName = toElixirVarName(v.name);
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
			extractedVarName = currentContext.currentClauseContext.localToName.get(v.id);
			skipExtraction = true;
		} else {
			var isExtractionTemp = false;
			if (currentContext.tempVarRenameMap.exists(Std.string(v.id))) {
				isExtractionTemp = true;
			} else if (varName == "g" || (varName.startsWith("g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
				isExtractionTemp = false;
			};
			if (isExtractionTemp) {
				extractedVarName = varName;
				skipExtraction = true;
			};
		};	
	case _:
}) {
										var ` = e.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && {
														var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
														var key = v.id;
														cast this.exists(key);
													}) {
														extractedVarName = {
															var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
															var key = v.id;
															cast this.get(key);
														};
														skipExtraction = true;
													} else {
														var isExtractionTemp = false;
														if ({
															var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
															var key = Std.string(v.id);
															cast this.exists(key);
														}) {
															isExtractionTemp = true;
														} else {
															if (varName == "g" || (StringTools.startsWith(varName, "g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
																isExtractionTemp = false;
															};
														};
														if (isExtractionTemp) {
															extractedVarName = varName;
															skipExtraction = true;
														};
													};
												};
											};
										} else {};
									};
								};
								if (skipExtraction && extractedVarName != null) {
									reflaxe.elixir.ast.ElixirASTDef.EVar(extractedVarName);
								} else {
									var exprAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									reflaxe.elixir.ast.ElixirASTDef.ECall(exprAST, "elem", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index + 1), metadata : {}, pos : pos};
									}]);
								};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
						};
					};
				};
				case 28: {
					var ` = `[0];
					{
						var s = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(s, null));
						};
					};
				};
			};
		};
	}

	static function tryOptimizeArrayPattern(econd:haxe.macro.TypedExpr, ebody:haxe.macro.TypedExpr) {
		var isArrayPattern = false;
		var arrayVarName = "";
		var indexVarName = "";
		@:ast(switch (econd.expr) {
	case TBinop(OpLt, e1, e2):
		switch (e1.expr) {
			case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
				switch (e2.expr) {
					case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
						switch (arrayRef.expr) {
							case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
								isArrayPattern = true;
								indexVarName = indexVar.name;
								arrayVarName = arrayVar.name;							
							case _:
								isArrayPattern = true;
								indexVarName = indexVar.name;							
						};					
					case _:
				};			
			case _:
		};	
	case _:
}) {
			var ` = econd.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 9) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e1.expr) {
	case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
		switch (e2.expr) {
			case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
				switch (arrayRef.expr) {
					case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
						isArrayPattern = true;
						indexVarName = indexVar.name;
						arrayVarName = arrayVar.name;					
					case _:
						isArrayPattern = true;
						indexVarName = indexVar.name;					
				};			
			case _:
		};	
	case _:
}) {
								var ` = e1.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var indexVar = `;
										if (StringTools.startsWith(indexVar.name, "_g")) {
											@:ast(switch (e2.expr) {
	case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
		switch (arrayRef.expr) {
			case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
				isArrayPattern = true;
				indexVarName = indexVar.name;
				arrayVarName = arrayVar.name;			
			case _:
				isArrayPattern = true;
				indexVarName = indexVar.name;			
		};	
	case _:
}) {
												var ` = e2.expr;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var arrayRef = `;
															if (cf.get().name == "length") {
																@:ast(switch (arrayRef.expr) {
	case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
		isArrayPattern = true;
		indexVarName = indexVar.name;
		arrayVarName = arrayVar.name;	
	case _:
		isArrayPattern = true;
		indexVarName = indexVar.name;	
}) {
																	var ` = arrayRef.expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var arrayVar = `;
																			if (StringTools.startsWith(arrayVar.name, "_g")) {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																				arrayVarName = arrayVar.name;
																			} else {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																			};
																		};
																	} else {
																		isArrayPattern = true;
																		indexVarName = indexVar.name;
																	};
																};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								} else {};
							};
						};
					};
				} else {};
			} else {};
		};
		if (! isArrayPattern) {
			return null;
		};
		var bodyAnalysis = reflaxe.elixir.ast.ElixirASTBuilder.analyzeLoopBody(ebody);
		var arrayExpr = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(if ((arrayVarName.length > 0)) arrayVarName else "_g2", null));
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		if (bodyAnalysis.hasMapPattern) {
			return reflaxe.elixir.ast.ElixirASTBuilder.generateEnumMapSimple(arrayExpr, bodyAnalysis, ebody);
		} else {
			if (bodyAnalysis.hasFilterPattern) {
				return reflaxe.elixir.ast.ElixirASTBuilder.generateEnumFilterSimple(arrayExpr, bodyAnalysis, ebody);
			} else {
				if (bodyAnalysis.hasReducePattern) {
					return null;
				};
			};
		};
		return null;
	}

	static function detectArrayIterationPattern(econd:haxe.macro.TypedExpr) {
		return @:ast(switch (econd.expr) {
	case TBinop(OpLt, e1, e2):
		switch (e2.expr) {
			case TField(arrayExpr, FInstance(_, _, cf)):
				if (cf.get().name == "length") {
					switch (arrayExpr.expr) {
						case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
							switch (e1.expr) {
								case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
									return { arrayExpr : arrayExpr, indexVar : indexVar.name };								
								case _:
									null;								
							};						
						case _:
							switch (e1.expr) {
								case TLocal(v) if (v.name.startsWith("_g")):
									return { arrayExpr : arrayExpr, indexVar : v.name };								
								case _:
									null;								
							};						
					};
				};
				null;			
			case _:
				null;			
		};
		null;	
	case _:
		null;	
}) {
			var ` = econd.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 9) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e2.expr) {
	case TField(arrayExpr, FInstance(_, _, cf)):
		if (cf.get().name == "length") {
			switch (arrayExpr.expr) {
				case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
					switch (e1.expr) {
						case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
							return { arrayExpr : arrayExpr, indexVar : indexVar.name };						
						case _:
							null;						
					};				
				case _:
					switch (e1.expr) {
						case TLocal(v) if (v.name.startsWith("_g")):
							return { arrayExpr : arrayExpr, indexVar : v.name };						
						case _:
							null;						
					};				
			};
		};
		null;	
	case _:
		null;	
}) {
								var ` = e2.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cf = `;
											var arrayExpr = `;
											{
												if (cf.get().name == "length") {
													@:ast(switch (arrayExpr.expr) {
	case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
		switch (e1.expr) {
			case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
				return { arrayExpr : arrayExpr, indexVar : indexVar.name };			
			case _:
				null;			
		};	
	case _:
		switch (e1.expr) {
			case TLocal(v) if (v.name.startsWith("_g")):
				return { arrayExpr : arrayExpr, indexVar : v.name };			
			case _:
				null;			
		};	
}) {
														var ` = arrayExpr.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var arrayVar = `;
																if (StringTools.startsWith(arrayVar.name, "_g")) {
																	@:ast(switch (e1.expr) {
	case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : indexVar.name };	
	case _:
		null;	
}) {
																		var ` = e1.expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var indexVar = `;
																				if (StringTools.startsWith(indexVar.name, "_g")) {
																					return {arrayExpr : arrayExpr, indexVar : indexVar.name};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	@:ast(switch (e1.expr) {
	case TLocal(v) if (v.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : v.name };	
	case _:
		null;	
}) {
																		var ` = e1.expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (StringTools.startsWith(v.name, "_g")) {
																					return {arrayExpr : arrayExpr, indexVar : v.name};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																};
															};
														} else {
															@:ast(switch (e1.expr) {
	case TLocal(v) if (v.name.startsWith("_g")):
		return { arrayExpr : arrayExpr, indexVar : v.name };	
	case _:
		null;	
}) {
																var ` = e1.expr;
																if (enumIndex ` == 1) {
																	var ` = `[0];
																	{
																		var v = `;
																		if (StringTools.startsWith(v.name, "_g")) {
																			return {arrayExpr : arrayExpr, indexVar : v.name};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
														};
													};
												};
												null;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
							null;
						};
					};
				} else {
					null;
				};
			} else {
				null;
			};
		};
		return null;
	}

	static function analyzeLoopBody(ebody:haxe.macro.TypedExpr) {
		var result = {hasMapPattern : false, hasFilterPattern : false, hasReducePattern : false, loopVar : null, pushTarget : null};
		var analyze = [null];
		analyze[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) analyze(e);	
	case TVar(v, init):
		if (init != null) {
			switch (init.expr) {
				case TArray(_, _):
					result.loopVar = v;				
				case _:
			};
		};	
	case TCall(e, args):
		switch (e.expr) {
			case TField(target, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					result.hasMapPattern = true;
					switch (target.expr) {
						case TLocal(v):
							result.pushTarget = v.name;						
						case _:
					};
				};			
			case _:
		};	
	case TIf(cond, thenExpr, elseExpr):
		analyze(thenExpr);
		if (elseExpr != null) analyze(elseExpr);
		if (result.hasMapPattern) {
			result.hasFilterPattern = true;
			result.hasMapPattern = false;
		};	
	case TBinop(OpAssignOp(OpAdd), _, _):
		result.hasReducePattern = true;	
	case _:
		haxe.macro.TypedExprTools.iter(expr, analyze);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 20) {
							var ` = `[0];
							if (enumIndex ` == 0) {
								{
									result.hasReducePattern = true;
								};
							} else {
								haxe.macro.TypedExprTools.iter(expr, analyze[0]);
							};
						} else {
							haxe.macro.TypedExprTools.iter(expr, analyze[0]);
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								@:ast(switch (e.expr) {
	case TField(target, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			result.hasMapPattern = true;
			switch (target.expr) {
				case TLocal(v):
					result.pushTarget = v.name;				
				case _:
			};
		};	
	case _:
}) {
									var ` = e.expr;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var target = `;
												{
													if (cf.get().name == "push") {
														result.hasMapPattern = true;
														@:ast(switch (target.expr) {
	case TLocal(v):
		result.pushTarget = v.name;	
	case _:
}) {
															var ` = target.expr;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var v = `;
																	{
																		result.pushTarget = v.name;
																	};
																};
															} else {};
														};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							{
								if (init != null) {
									@:ast(switch (init.expr) {
	case TArray(_, _):
		result.loopVar = v;	
	case _:
}) {
										var ` = init.expr;
										if (enumIndex ` == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												result.loopVar = v;
											};
										} else {};
									};
								};
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										analyze[0](e);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenExpr = `;
							var elseExpr = `;
							{
								analyze[0](thenExpr);
								if (elseExpr != null) {
									analyze[0](elseExpr);
								};
								if (result.hasMapPattern) {
									result.hasFilterPattern = true;
									result.hasMapPattern = false;
								};
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, analyze[0]);
					}
				};
			};
		};
		analyze[0](ebody);
		return result;
	}

	static function generateEnumMapSimple(arrayExpr:reflaxe.elixir.ast.ElixirAST, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var transformation = reflaxe.elixir.ast.ElixirASTBuilder.extractMapTransformation(ebody, analysis.loopVar);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : transformation}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.map", [arrayExpr, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumFilterSimple(arrayExpr:reflaxe.elixir.ast.ElixirAST, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var condition = reflaxe.elixir.ast.ElixirASTBuilder.extractFilterCondition(ebody);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : condition}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.filter", [arrayExpr, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumMap(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var transformation = reflaxe.elixir.ast.ElixirASTBuilder.extractMapTransformation(ebody, analysis.loopVar);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : transformation}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.map", [arrayAST, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumFilter(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		var loopVar = if (analysis.loopVar != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(analysis.loopVar.name, null);
		} else {
			"item";
		};
		var condition = reflaxe.elixir.ast.ElixirASTBuilder.extractFilterCondition(ebody);
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], guard : null, body : condition}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "Enum.filter", [arrayAST, lambda]), metadata : {}, pos : pos};
		};
	}

	static function generateEnumReduce(arrayExpr:haxe.macro.TypedExpr, analysis:Dynamic, ebody:haxe.macro.TypedExpr) {
		return null;
	}

	static function extractMapTransformation(ebody:haxe.macro.TypedExpr, loopVar:Null<haxe.macro.TVar>) {
		var findPushArg = [null];
		findPushArg[0] = function(expr:haxe.macro.TypedExpr) {
			return @:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = findPushArg(e);
			if (result != null) return result;
		};
		null;	
	case TCall(e, [arg]):
		switch (e.expr) {
			case TField(_, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					return arg;
				};
				null;			
			case _:
				null;			
		};
		null;	
	case _:
		null;	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 9: {
						var ` = `[0];
						var ` = `[1];
						if (`.length == 1) {
							var ` = `[0];
							{
								var arg = `;
								var e = `;
								{
									@:ast(switch (e.expr) {
	case TField(_, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			return arg;
		};
		null;	
	case _:
		null;	
}) {
										var ` = e.expr;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cf = `;
													{
														if (cf.get().name == "push") {
															return arg;
														};
														null;
													};
												};
											} else {
												null;
											};
										} else {
											null;
										};
									};
									null;
								};
							};
						} else {
							null;
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										var result = findPushArg[0](e);
										if (result != null) {
											return result;
										};
									};
								};
								null;
							};
						};
					};
					default: {
						null;
					}
				};
			};
		};
		var pushArg = findPushArg[0](ebody);
		if (pushArg != null) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithSubstitution(pushArg, loopVar);
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("item"), metadata : {}, pos : pos};
		};
	}

	static function extractFilterCondition(ebody:haxe.macro.TypedExpr) {
		var findIfCondition = [null];
		findIfCondition[0] = function(expr:haxe.macro.TypedExpr) {
			return @:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = findIfCondition(e);
			if (result != null) return result;
		};
		null;	
	case TIf(cond, thenExpr, _):
		if (containsPush(thenExpr)) {
			return cond;
		};
		null;	
	case _:
		null;	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										var result = findIfCondition[0](e);
										if (result != null) {
											return result;
										};
									};
								};
								null;
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenExpr = `;
							{
								if (reflaxe.elixir.ast.ElixirASTBuilder.containsPush(thenExpr)) {
									return cond;
								};
								null;
							};
						};
					};
					default: {
						null;
					}
				};
			};
		};
		var cond = findIfCondition[0](ebody);
		if (cond != null) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), metadata : {}, pos : pos};
		};
	}

	static function containsPush(expr:haxe.macro.TypedExpr) {
		var hasPush = [false];
		var check = [null];
		check[0] = function(e:haxe.macro.TypedExpr) {
			@:ast(switch (e.expr) {
	case TCall(target, _):
		switch (target.expr) {
			case TField(_, FInstance(_, _, cf)):
				if (cf.get().name == "push") {
					hasPush = true;
				};			
			case _:
		};	
	case _:
		if (!hasPush) {
			haxe.macro.TypedExprTools.iter(e, check);
		};	
}) {
				var ` = e.expr;
				if (enumIndex ` == 9) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						{
							@:ast(switch (target.expr) {
	case TField(_, FInstance(_, _, cf)):
		if (cf.get().name == "push") {
			hasPush = true;
		};	
	case _:
}) {
								var ` = target.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cf = `;
											{
												if (cf.get().name == "push") {
													hasPush[0] = true;
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				} else {
					if (! hasPush[0]) {
						haxe.macro.TypedExprTools.iter(e, check[0]);
					};
				};
			};
		};
		check[0](expr);
		return hasPush[0];
	}

	static function processEnumCaseBody(caseExpr:haxe.macro.TypedExpr, builtBody:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (caseExpr.expr) {
	case TBlock(exprs):
		var modifiedExprs = [];
		var unusedVars = new Map<String,Bool>();
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TEnumParameter(_, _, _):
							var isUsed = false;
							isUsed = true;
							if (!isUsed) {
								unusedVars.set(v.name, true);
							};						
						default:
					};				
				default:
			};
		};
		if (Lambda.count(unusedVars) > 0) {
			return prefixUnusedVariablesInAST(builtBody, unusedVars);
		};	
	default:
}) {
			var ` = caseExpr.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var modifiedExprs = [];
						var unusedVars = {
							{};
							new haxe.ds.StringMap();
						};
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, _):
				var isUsed = false;
				isUsed = true;
				if (!isUsed) {
					unusedVars.set(v.name, true);
				};			
			default:
		};	
	default:
}) {
									var ` = expr.expr;
									if (enumIndex ` == 13) {
										var ` = `[0];
										var ` = `[1];
										{
											var v = `;
											var init = `;
											if (init != null) {
												@:ast(switch (init.expr) {
	case TEnumParameter(_, _, _):
		var isUsed = false;
		isUsed = true;
		if (!isUsed) {
			unusedVars.set(v.name, true);
		};	
	default:
}) {
													var ` = init.expr;
													if (enumIndex ` == 26) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var isUsed = false;
															isUsed = true;
															if (! isUsed) {
																{
																	var key = v.name;
																	unusedVars.set(key, true);
																};
															};
														};
													} else {};
												};
											} else {};
										};
									} else {};
								};
							};
						};
						if (Lambda.count(cast unusedVars, null) > 0) {
							return reflaxe.elixir.ast.ElixirASTBuilder.prefixUnusedVariablesInAST(builtBody, unusedVars);
						};
					};
				};
			} else {};
		};
		return builtBody;
	}

	static function prefixUnusedVariablesInAST(ast:reflaxe.elixir.ast.ElixirAST, unusedVars:Map<String, Bool>) {
		return ast;
	}

	static function buildFromTypedExprWithSubstitution(expr:haxe.macro.TypedExpr, loopVar:Null<haxe.macro.TVar>) {
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
	}

	static function createMetadata(expr:haxe.macro.TypedExpr) {
		return {sourceExpr : expr, sourceLine : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).min;
		} else {
			0;
		}, sourceFile : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).file;
		} else {
			null;
		}, type : expr.t, elixirType : reflaxe.elixir.ast.ElixirASTBuilder.typeToElixir(expr.t), purity : cast reflaxe.elixir.ast.ElixirASTBuilder.isPure(expr), tailPosition : cast false, async : cast false, requiresReturn : cast false, requiresTempVar : cast false, inPipeline : cast false, inComprehension : cast false, inGuard : cast false, canInline : cast reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(expr), isConstant : cast reflaxe.elixir.ast.ElixirASTBuilder.isConstant(expr), sideEffects : cast reflaxe.elixir.ast.ElixirASTBuilder.hasSideEffects(expr)};
	}

	static function convertPattern(value:haxe.macro.TypedExpr) {
		return @:ast(switch (value.expr) {
	case TConst(TInt(i)):
		PLiteral(makeAST(EInteger(i)));	
	case TConst(TFloat(f)):
		PLiteral(makeAST(EFloat(Std.parseFloat(f))));	
	case TConst(TString(s)):
		PLiteral(makeAST(EString(s)));	
	case TConst(TBool(b)):
		PLiteral(makeAST(EBoolean(b)));	
	case TConst(TNull):
		PLiteral(makeAST(ENil));	
	case TLocal(v):
		PVar(toElixirVarName(v.name));	
	case TEnumParameter(e, ef, index):
		PVar("_enum_param_" + index);	
	case TEnumIndex(e):
		PLiteral(makeAST(EInteger(0)));	
	case TArrayDecl(el):
		PList([for (e  in  el) convertPattern(e)]);	
	case TCall(e, el) if (isEnumConstructor(e)):
		var tag = extractEnumTag(e);
		if (hasIdiomaticMetadata(e)) {
			tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
		};
		var args = [for (arg  in  el) convertPattern(arg)];
		PTuple([PLiteral(makeAST(EAtom(tag)))].concat(args));	
	case TField(e, FEnum(enumRef, ef)):
		var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
		var isIdiomatic = enumRef.get().meta.has(":elixirIdiomatic") || true;
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount == 0) {
			PLiteral(makeAST(EAtom(atomName)));
		} else {
			var wildcards = [for (i  in  0 ... paramCount) PWildcard];
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(wildcards));
		};	
	default:
		PWildcard;	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					switch (enumIndex `) {
						case 0: {
							var ` = `[0];
							{
								var i = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(i), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 1: {
							var ` = `[0];
							{
								var f = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EFloat(Std.parseFloat(f));
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								};
							};
						};
						case 2: {
							var ` = `[0];
							{
								var s = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EString(s), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 3: {
							var ` = `[0];
							{
								var b = `;
								{
									reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(b), metadata : {}, pos : pos};
									});
								};
							};
						};
						case 4: {
							{
								reflaxe.elixir.ast.EPattern.PLiteral({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
								});
							};
						};
						default: {
							reflaxe.elixir.ast.EPattern.PWildcard;
						}
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							var ef = `;
							var e = `;
							{
								var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
								var isIdiomatic = enumRef.get().meta.has(":elixirIdiomatic") || true;
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount == 0) {
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								} else {
									var wildcards = {
										var ` = [];
										{
											var ` = 0;
											var ` = paramCount;
											while (` < `) {
												var i = ` ++;
												`.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
										`;
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									})].concat(wildcards));
								};
							};
						};
					} else {
						reflaxe.elixir.ast.EPattern.PWildcard;
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							reflaxe.elixir.ast.EPattern.PList({
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var e = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(e));
									};
								};
								`;
							});
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						if (reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e)) {
							var tag = reflaxe.elixir.ast.ElixirASTBuilder.extractEnumTag(e);
							if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
								tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
							};
							var args = {
								var ` = [];
								{
									var ` = 0;
									while (` < el.length) {
										var arg = el[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(arg));
									};
								};
								`;
							};
							reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
								var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
									var this;
									this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
									cast this;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							})].concat(args));
						} else {
							reflaxe.elixir.ast.EPattern.PWildcard;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var ef = `;
						var index = `;
						{
							reflaxe.elixir.ast.EPattern.PVar("_enum_param_" + index);
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.EPattern.PLiteral({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
							});
						};
					};
				};
				default: {
					reflaxe.elixir.ast.EPattern.PWildcard;
				}
			};
		};
	}

	static function convertPatternWithExtraction(value:haxe.macro.TypedExpr, extractedParams:Array<String>) {
		return @:ast(switch (value.expr) {
	case TConst(_) | TLocal(_) | TArrayDecl(_) | TEnumIndex(_):
		convertPattern(value);	
	case TCall(e, el) if (isEnumConstructor(e)):
		var tag = extractEnumTag(e);
		if (hasIdiomaticMetadata(e)) {
			tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
		};
		var args = [];
		for (i  in  0 ... el.length) {
			if (i < extractedParams.length && extractedParams[i] != null) {
				args.push(PVar(extractedParams[i]));
			} else {
				args.push(PWildcard);
			};
		};
		PTuple([PLiteral(makeAST(EAtom(tag)))].concat(args));	
	case TField(e, FEnum(enumRef, ef)):
		var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount == 0) {
			PLiteral(makeAST(EAtom(atomName)));
		} else {
			var patterns = [];
			for (i  in  0 ... paramCount) {
				if (i < extractedParams.length && extractedParams[i] != null) {
					patterns.push(PVar(extractedParams[i]));
				} else {
					patterns.push(PWildcard);
				};
			};
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(patterns));
		};	
	default:
		convertPattern(value);	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 1: {
					var ` = `[0];
					{
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							var ef = `;
							var e = `;
							{
								var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount == 0) {
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								} else {
									var patterns = [];
									{
										var ` = 0;
										var ` = paramCount;
										while (` < `) {
											var i = ` ++;
											if (i < extractedParams.length && extractedParams[i] != null) {
												patterns.push(reflaxe.elixir.ast.EPattern.PVar(extractedParams[i]));
											} else {
												patterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
											};
										};
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									})].concat(patterns));
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 8: {
					var ` = `[0];
					{
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						if (reflaxe.elixir.ast.ElixirASTBuilder.isEnumConstructor(e)) {
							var tag = reflaxe.elixir.ast.ElixirASTBuilder.extractEnumTag(e);
							if (reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
								tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
							};
							var args = [];
							{
								var ` = 0;
								var ` = el.length;
								while (` < `) {
									var i = ` ++;
									if (i < extractedParams.length && extractedParams[i] != null) {
										args.push(reflaxe.elixir.ast.EPattern.PVar(extractedParams[i]));
									} else {
										args.push(reflaxe.elixir.ast.EPattern.PWildcard);
									};
								};
							};
							reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
								var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
									var this;
									this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
									cast this;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							})].concat(args));
						} else {
							reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
				}
			};
		};
	}

	static function extractPatternVariableNamesFromValues(values:Array<haxe.macro.TypedExpr>) {
		var patternVars = [];
		{
			var ` = 0;
			while (` < values.length) {
				var value = values[`];
				++ `;
				@:ast(switch (value.expr) {
	case TCall(e, args):
		for (i  in  0 ... args.length) {
			var arg = args[i];
			switch (arg.expr) {
				case TLocal(v):
					var varName = toElixirVarName(v.name);
					while (patternVars.length <= i) {
						patternVars.push(null);
					};
					patternVars[i] = varName;				
				default:
			};
		};	
	default:
}) {
					var ` = value.expr;
					if (enumIndex ` == 9) {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								{
									var ` = 0;
									var ` = args.length;
									while (` < `) {
										var i = ` ++;
										var arg = args[i];
										@:ast(switch (arg.expr) {
	case TLocal(v):
		var varName = toElixirVarName(v.name);
		while (patternVars.length <= i) {
			patternVars.push(null);
		};
		patternVars[i] = varName;	
	default:
}) {
											var ` = arg.expr;
											if (enumIndex ` == 1) {
												var ` = `[0];
												{
													var v = `;
													{
														var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
														while (patternVars.length <= i) {
															patternVars.push(null);
														};
														patternVars[i] = varName;
													};
												};
											} else {};
										};
									};
								};
							};
						};
					} else {};
				};
			};
		};
		return patternVars;
	}

	@:value({ caseValues : null })
	static function analyzeEnumParameterExtraction(caseExpr:haxe.macro.TypedExpr, caseValues:Null<Array<haxe.macro.TypedExpr>> = null) {
		if (caseValues != null) {
			var patternVars = reflaxe.elixir.ast.ElixirASTBuilder.extractPatternVariableNamesFromValues(caseValues);
			if (patternVars.length > 0 && {
				var ` = [];
				{
					var ` = 0;
					var ` = patternVars;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(v:String) {
							return v != null;
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			}.length > 0) {
				return patternVars;
			};
		};
		var extractedParams = [[]];
		var tempVarMapping = {
			{};
			new haxe.ds.StringMap();
		};
		var tempVarToIndex = {
			{};
			new haxe.ds.StringMap();
		};
		@:ast(switch (caseExpr.expr) {
	case TBlock(exprs):
		if (exprs.length == 1) {
			switch (exprs[0].expr) {
				case TCall(e, params):
					for (i  in  0 ... params.length) {
						var param = params[i];
						switch (param.expr) {
							case TLocal(v):
								var varName = toElixirVarName(v.name);
								while (extractedParams.length <= i) {
									extractedParams.push(null);
								};
								extractedParams[i] = varName;							
							case _:
						};
					};
					if (extractedParams.length > 0) { };				
				case _:
			};
		};
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TEnumParameter(_, ef, index):
							var tempName = toElixirVarName(v.name);
							if (tempName.startsWith("_")) {
								tempName = tempName.substr(1);
							};
							tempVarMapping.set(tempName, { name : tempName, index : index });
							tempVarToIndex.set(v.name, index);
							while (extractedParams.length <= index) {
								extractedParams.push(null);
							};
							extractedParams[index] = tempName;						
						default:
					};				
				default:
			};
		};
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TLocal(localVar):
							var tempName = toElixirVarName(localVar.name);
							if (tempName.startsWith("_")) {
								tempName = tempName.substr(1);
							};
							if (tempVarMapping.exists(tempName)) {
								var patternName = toElixirVarName(v.name);
								var info = tempVarMapping.get(tempName);
								extractedParams[info.index] = patternName;
							} else { };						
						default:
					};				
				default:
			};
		};
		var usedVariables = new Map<String,Bool>();
		var firstUsedVariables = [];
		function scanForUsedVariables(expr:TypedExpr):Void {
			switch (expr.expr) {
				case TLocal(v):
					var name = toElixirVarName(v.name);
					usedVariables.set(name, true);				
				case TVar(v, init) if (init != null):
					switch (init.expr) {
						case TEnumParameter(_, _, index):
							var varName = toElixirVarName(v.name);
							while (firstUsedVariables.length <= index) {
								firstUsedVariables.push(null);
							};
							if (!varName.startsWith("_") && !varName.startsWith("g")) {
								firstUsedVariables[index] = varName;
							};						
						default:
					};
					if (init != null) scanForUsedVariables(init);				
				case TCall(target, el):
					switch (target.expr) {
						case TField(obj, _):
							switch (obj.expr) {
								case TLocal(v):
									var name = toElixirVarName(v.name);
									if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
										for (i  in  0 ... extractedParams.length) {
											if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
												extractedParams[i] = name;
												break;
											};
										};
									};								
								default:
							};						
						default:
					};
					for (arg  in  el) scanForUsedVariables(arg);				
				case TBlock(subExprs):
					for (e  in  subExprs) scanForUsedVariables(e);				
				case TBinop(_, e1, e2):
					scanForUsedVariables(e1);
					scanForUsedVariables(e2);				
				case TField(e, _):
					scanForUsedVariables(e);				
				case TIf(cond, ifExpr, elseExpr):
					scanForUsedVariables(cond);
					scanForUsedVariables(ifExpr);
					if (elseExpr != null) scanForUsedVariables(elseExpr);				
				case TThrow(e):
					scanForUsedVariables(e);				
				case TReturn(e):
					if (e != null) scanForUsedVariables(e);				
				case _:
			};
		};
		for (i  in  0 ... exprs.length) {
			scanForUsedVariables(exprs[i]);
		};	
	case TCall(e, params):
		for (i  in  0 ... params.length) {
			var param = params[i];
			switch (param.expr) {
				case TLocal(v):
					var varName = toElixirVarName(v.name);
					while (extractedParams.length <= i) {
						extractedParams.push(null);
					};
					extractedParams[i] = varName;				
				case _:
			};
		};	
	case TIf(cond, thenExpr, elseExpr):
		var thenParams = analyzeEnumParameterExtraction(thenExpr, caseValues);
		var elseParams = [];
		if (elseExpr != null) {
			elseParams = analyzeEnumParameterExtraction(elseExpr, caseValues);
		};
		if (thenParams.length > 0) {
			extractedParams = thenParams;
		} else if (elseParams.length > 0) {
			extractedParams = elseParams;
		} else if (thenParams.length > 0 && elseParams.length > 0) {
			var thenHasMeaningful = false;
			for (name  in  thenParams) {
				if (name != null && name != "g" && !name.startsWith("g")) {
					thenHasMeaningful = true;
					break;
				};
			};
			extractedParams = thenHasMeaningful ? thenParams : elseParams;
		};	
	default:
}) {
			var ` = caseExpr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var params = `;
						{
							{
								var ` = 0;
								var ` = params.length;
								while (` < `) {
									var i = ` ++;
									var param = params[i];
									@:ast(switch (param.expr) {
	case TLocal(v):
		var varName = toElixirVarName(v.name);
		while (extractedParams.length <= i) {
			extractedParams.push(null);
		};
		extractedParams[i] = varName;	
	case _:
}) {
										var ` = param.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
													while (extractedParams[0].length <= i) {
														extractedParams[0].push(null);
													};
													extractedParams[0][i] = varName;
												};
											};
										} else {};
									};
								};
							};
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							if (exprs.length == 1) {
								@:ast(switch (exprs[0].expr) {
	case TCall(e, params):
		for (i  in  0 ... params.length) {
			var param = params[i];
			switch (param.expr) {
				case TLocal(v):
					var varName = toElixirVarName(v.name);
					while (extractedParams.length <= i) {
						extractedParams.push(null);
					};
					extractedParams[i] = varName;				
				case _:
			};
		};
		if (extractedParams.length > 0) { };	
	case _:
}) {
									var ` = exprs[0].expr;
									if (enumIndex ` == 9) {
										var ` = `[0];
										var ` = `[1];
										{
											var e = `;
											var params = `;
											{
												{
													var ` = 0;
													var ` = params.length;
													while (` < `) {
														var i = ` ++;
														var param = params[i];
														@:ast(switch (param.expr) {
	case TLocal(v):
		var varName = toElixirVarName(v.name);
		while (extractedParams.length <= i) {
			extractedParams.push(null);
		};
		extractedParams[i] = varName;	
	case _:
}) {
															var ` = param.expr;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var v = `;
																	{
																		var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																		while (extractedParams[0].length <= i) {
																			extractedParams[0].push(null);
																		};
																		extractedParams[0][i] = varName;
																	};
																};
															} else {};
														};
													};
												};
												if (extractedParams[0].length > 0) {};
											};
										};
									} else {};
								};
							};
							{
								var ` = 0;
								while (` < exprs.length) {
									var expr = exprs[`];
									++ `;
									@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, ef, index):
				var tempName = toElixirVarName(v.name);
				if (tempName.startsWith("_")) {
					tempName = tempName.substr(1);
				};
				tempVarMapping.set(tempName, { name : tempName, index : index });
				tempVarToIndex.set(v.name, index);
				while (extractedParams.length <= index) {
					extractedParams.push(null);
				};
				extractedParams[index] = tempName;			
			default:
		};	
	default:
}) {
										var ` = expr.expr;
										if (enumIndex ` == 13) {
											var ` = `[0];
											var ` = `[1];
											{
												var v = `;
												var init = `;
												if (init != null) {
													@:ast(switch (init.expr) {
	case TEnumParameter(_, ef, index):
		var tempName = toElixirVarName(v.name);
		if (tempName.startsWith("_")) {
			tempName = tempName.substr(1);
		};
		tempVarMapping.set(tempName, { name : tempName, index : index });
		tempVarToIndex.set(v.name, index);
		while (extractedParams.length <= index) {
			extractedParams.push(null);
		};
		extractedParams[index] = tempName;	
	default:
}) {
														var ` = init.expr;
														if (enumIndex ` == 26) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var ef = `;
																var index = `;
																{
																	var tempName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																	if (StringTools.startsWith(tempName, "_")) {
																		tempName = tempName.substr(1, null);
																	};
																	{
																		tempVarMapping.set(tempName, {name : tempName, index : index});
																	};
																	{
																		var key = v.name;
																		tempVarToIndex.set(key, index);
																	};
																	while (extractedParams[0].length <= index) {
																		extractedParams[0].push(null);
																	};
																	extractedParams[0][index] = tempName;
																};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									};
								};
							};
							{
								var ` = 0;
								while (` < exprs.length) {
									var expr = exprs[`];
									++ `;
									@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TLocal(localVar):
				var tempName = toElixirVarName(localVar.name);
				if (tempName.startsWith("_")) {
					tempName = tempName.substr(1);
				};
				if (tempVarMapping.exists(tempName)) {
					var patternName = toElixirVarName(v.name);
					var info = tempVarMapping.get(tempName);
					extractedParams[info.index] = patternName;
				} else { };			
			default:
		};	
	default:
}) {
										var ` = expr.expr;
										if (enumIndex ` == 13) {
											var ` = `[0];
											var ` = `[1];
											{
												var v = `;
												var init = `;
												if (init != null) {
													@:ast(switch (init.expr) {
	case TLocal(localVar):
		var tempName = toElixirVarName(localVar.name);
		if (tempName.startsWith("_")) {
			tempName = tempName.substr(1);
		};
		if (tempVarMapping.exists(tempName)) {
			var patternName = toElixirVarName(v.name);
			var info = tempVarMapping.get(tempName);
			extractedParams[info.index] = patternName;
		} else { };	
	default:
}) {
														var ` = init.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var localVar = `;
																{
																	var tempName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(localVar.name, null);
																	if (StringTools.startsWith(tempName, "_")) {
																		tempName = tempName.substr(1, null);
																	};
																	if (tempVarMapping.exists(tempName)) {
																		var patternName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																		var info = cast tempVarMapping.get(tempName);
																		extractedParams[0][info.index] = patternName;
																	} else {};
																};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									};
								};
							};
							var usedVariables = {
								{};
								new haxe.ds.StringMap();
							};
							var firstUsedVariables = [];
							var scanForUsedVariables = [null];
							scanForUsedVariables[0] = function(expr:haxe.macro.TypedExpr) {
								@:ast(switch (expr.expr) {
	case TLocal(v):
		var name = toElixirVarName(v.name);
		usedVariables.set(name, true);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, index):
				var varName = toElixirVarName(v.name);
				while (firstUsedVariables.length <= index) {
					firstUsedVariables.push(null);
				};
				if (!varName.startsWith("_") && !varName.startsWith("g")) {
					firstUsedVariables[index] = varName;
				};			
			default:
		};
		if (init != null) scanForUsedVariables(init);	
	case TCall(target, el):
		switch (target.expr) {
			case TField(obj, _):
				switch (obj.expr) {
					case TLocal(v):
						var name = toElixirVarName(v.name);
						if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
							for (i  in  0 ... extractedParams.length) {
								if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
									extractedParams[i] = name;
									break;
								};
							};
						};					
					default:
				};			
			default:
		};
		for (arg  in  el) scanForUsedVariables(arg);	
	case TBlock(subExprs):
		for (e  in  subExprs) scanForUsedVariables(e);	
	case TBinop(_, e1, e2):
		scanForUsedVariables(e1);
		scanForUsedVariables(e2);	
	case TField(e, _):
		scanForUsedVariables(e);	
	case TIf(cond, ifExpr, elseExpr):
		scanForUsedVariables(cond);
		scanForUsedVariables(ifExpr);
		if (elseExpr != null) scanForUsedVariables(elseExpr);	
	case TThrow(e):
		scanForUsedVariables(e);	
	case TReturn(e):
		if (e != null) scanForUsedVariables(e);	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var v = `;
												{
													var name = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
													{
														usedVariables.set(name, true);
													};
												};
											};
										};
										case 3: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var e1 = `;
												var e2 = `;
												{
													scanForUsedVariables[0](e1);
													scanForUsedVariables[0](e2);
												};
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												var e = `;
												{
													scanForUsedVariables[0](e);
												};
											};
										};
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var el = `;
												{
													@:ast(switch (target.expr) {
	case TField(obj, _):
		switch (obj.expr) {
			case TLocal(v):
				var name = toElixirVarName(v.name);
				if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
					for (i  in  0 ... extractedParams.length) {
						if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
							extractedParams[i] = name;
							break;
						};
					};
				};			
			default:
		};	
	default:
}) {
														var ` = target.expr;
														if (enumIndex ` == 4) {
															var ` = `[0];
															var ` = `[1];
															{
																var obj = `;
																{
																	@:ast(switch (obj.expr) {
	case TLocal(v):
		var name = toElixirVarName(v.name);
		if (!name.startsWith("_g") && !name.startsWith("g") && name != "g") {
			for (i  in  0 ... extractedParams.length) {
				if (extractedParams[i] == "g" || extractedParams[i] == "_g" || (extractedParams[i] != null && extractedParams[i].startsWith("g"))) {
					extractedParams[i] = name;
					break;
				};
			};
		};	
	default:
}) {
																		var ` = obj.expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				{
																					var name = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																					if (! StringTools.startsWith(name, "_g") && ! StringTools.startsWith(name, "g") && name != "g") {
																						{
																							var ` = 0;
																							var ` = extractedParams[0].length;
																							while (` < `) {
																								var i = ` ++;
																								if (extractedParams[0][i] == "g" || extractedParams[0][i] == "_g" || (extractedParams[0][i] != null && StringTools.startsWith(extractedParams[0][i], "g"))) {
																									extractedParams[0][i] = name;
																									break;
																								};
																							};
																						};
																					};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
													{
														var ` = 0;
														while (` < el.length) {
															var arg = el[`];
															++ `;
															scanForUsedVariables[0](arg);
														};
													};
												};
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var v = `;
												var init = `;
												if (init != null) {
													@:ast(switch (init.expr) {
	case TEnumParameter(_, _, index):
		var varName = toElixirVarName(v.name);
		while (firstUsedVariables.length <= index) {
			firstUsedVariables.push(null);
		};
		if (!varName.startsWith("_") && !varName.startsWith("g")) {
			firstUsedVariables[index] = varName;
		};	
	default:
}) {
														var ` = init.expr;
														if (enumIndex ` == 26) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var index = `;
																{
																	var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																	while (firstUsedVariables.length <= index) {
																		firstUsedVariables.push(null);
																	};
																	if (! StringTools.startsWith(varName, "_") && ! StringTools.startsWith(varName, "g")) {
																		firstUsedVariables[index] = varName;
																	};
																};
															};
														} else {};
													};
													if (init != null) {
														scanForUsedVariables[0](init);
													};
												} else {};
											};
										};
										case 14: {
											var ` = `[0];
											{
												var subExprs = `;
												{
													{
														var ` = 0;
														while (` < subExprs.length) {
															var e = subExprs[`];
															++ `;
															scanForUsedVariables[0](e);
														};
													};
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cond = `;
												var ifExpr = `;
												var elseExpr = `;
												{
													scanForUsedVariables[0](cond);
													scanForUsedVariables[0](ifExpr);
													if (elseExpr != null) {
														scanForUsedVariables[0](elseExpr);
													};
												};
											};
										};
										case 20: {
											var ` = `[0];
											{
												var e = `;
												{
													if (e != null) {
														scanForUsedVariables[0](e);
													};
												};
											};
										};
										case 23: {
											var ` = `[0];
											{
												var e = `;
												{
													scanForUsedVariables[0](e);
												};
											};
										};
										default: {}
									};
								};
							};
							{
								var ` = 0;
								var ` = exprs.length;
								while (` < `) {
									var i = ` ++;
									scanForUsedVariables[0](exprs[i]);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenExpr = `;
						var elseExpr = `;
						{
							var thenParams = reflaxe.elixir.ast.ElixirASTBuilder.analyzeEnumParameterExtraction(thenExpr, caseValues);
							var elseParams = [];
							if (elseExpr != null) {
								elseParams = reflaxe.elixir.ast.ElixirASTBuilder.analyzeEnumParameterExtraction(elseExpr, caseValues);
							};
							if (thenParams.length > 0) {
								extractedParams[0] = thenParams;
							} else {
								if (elseParams.length > 0) {
									extractedParams[0] = elseParams;
								} else {
									if (thenParams.length > 0 && elseParams.length > 0) {
										var thenHasMeaningful = false;
										{
											var ` = 0;
											while (` < thenParams.length) {
												var name = thenParams[`];
												++ `;
												if (name != null && name != "g" && ! StringTools.startsWith(name, "g")) {
													thenHasMeaningful = true;
													break;
												};
											};
										};
										extractedParams[0] = if (thenHasMeaningful) {
											thenParams;
										} else {
											elseParams;
										};
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return extractedParams[0];
	}

	static function createEnumBindingPlan(caseExpr:haxe.macro.TypedExpr, extractedParams:Array<String>, enumType:Null<haxe.macro.EnumType>) {
		var plan = {
			{};
			new haxe.ds.IntMap();
		};
		var maxParamCount = [0];
		if (enumType != null && caseExpr != null) {
			var findConstructorIndex = function(expr:haxe.macro.TypedExpr) {
				var foundIndex = [-1];
				var scan = [null];
				scan[0] = function(e:haxe.macro.TypedExpr) {
					@:ast(switch (e.expr) {
	case TEnumParameter(_, ef, _):
		for (name  in  enumType.constructs.keys()) {
			var construct = enumType.constructs.get(name);
			if (construct.name == ef.name) {
				foundIndex = construct.index;
				switch (construct.type) {
					case TFun(args, _):
						if (args.length > maxParamCount) {
							maxParamCount = args.length;
						};					
					default:
				};
				return;
			};
		};	
	case TBlock(exprs):
		for (e  in  exprs) scan(e);	
	default:
		haxe.macro.TypedExprTools.iter(e, scan);	
}) {
						var ` = e.expr;
						switch (enumIndex `) {
							case 14: {
								var ` = `[0];
								{
									var exprs = `;
									{
										{
											var ` = 0;
											while (` < exprs.length) {
												var e = exprs[`];
												++ `;
												scan[0](e);
											};
										};
									};
								};
							};
							case 26: {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								{
									var ef = `;
									{
										for (name in {
											var this = enumType.constructs;
											cast this.keys();
										}) {
											var construct = {
												var this = enumType.constructs;
												cast this.get(name);
											};
											if (construct.name == ef.name) {
												foundIndex[0] = construct.index;
												@:ast(switch (construct.type) {
	case TFun(args, _):
		if (args.length > maxParamCount) {
			maxParamCount = args.length;
		};	
	default:
}) {
													var ` = construct.type;
													if (enumIndex ` == 4) {
														var ` = `[0];
														var ` = `[1];
														{
															var args = `;
															{
																if (args.length > maxParamCount[0]) {
																	maxParamCount[0] = args.length;
																};
															};
														};
													} else {};
												};
												return;
											};
										};
									};
								};
							};
							default: {
								haxe.macro.TypedExprTools.iter(e, scan[0]);
							}
						};
					};
				};
				scan[0](expr);
				return foundIndex[0];
			};
			var constructorIndex = findConstructorIndex(caseExpr);
			var canonicalNames = [];
			if (constructorIndex >= 0) {
				for (name in {
					var this = enumType.constructs;
					cast this.keys();
				}) {
					var construct = {
						var this = enumType.constructs;
						cast this.get(name);
					};
					if (construct.index == constructorIndex) {
						@:ast(switch (construct.type) {
	case TFun(args, _):
		canonicalNames = [for (arg  in  args) arg.name];
		maxParamCount = args.length;	
	default:
}) {
							var ` = construct.type;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								{
									var args = `;
									{
										canonicalNames = {
											var ` = [];
											{
												var ` = 0;
												while (` < args.length) {
													var arg = args[`];
													++ `;
													`.push(arg.name);
												};
											};
											`;
										};
										maxParamCount[0] = args.length;
									};
								};
							} else {};
						};
						break;
					};
				};
			};
			var ensureExtractedParamsSize = function(index:Int) {
				if (extractedParams == null) {
					return;
				};
				while (extractedParams.length <= index) {
					extractedParams.push(null);
				};
			};
			var recordMeaningfulName = function(index:Int, candidate:String) {
				if (candidate == null || candidate.length == 0 || reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(candidate)) {
					return;
				};
				if (extractedParams != null) {
					ensureExtractedParamsSize(index);
					var existing = extractedParams[index];
					if (existing == null || reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(existing)) {
						var elixirName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(candidate, null);
						extractedParams[index] = elixirName;
					};
				};
			};
			var collectEnumParameterBindings = [null];
			collectEnumParameterBindings[0] = function(expr:haxe.macro.TypedExpr) {
				@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, index):
				var varName = toElixirVarName(v.name);
				recordMeaningfulName(index, varName);			
			default:
		};
		if (init != null) {
			collectEnumParameterBindings(init);
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			collectEnumParameterBindings(e);
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, collectEnumParameterBindings);	
}) {
					var ` = expr.expr;
					switch (enumIndex `) {
						case 13: {
							var ` = `[0];
							var ` = `[1];
							{
								var v = `;
								var init = `;
								if (init != null) {
									@:ast(switch (init.expr) {
	case TEnumParameter(_, _, index):
		var varName = toElixirVarName(v.name);
		recordMeaningfulName(index, varName);	
	default:
}) {
										var ` = init.expr;
										if (enumIndex ` == 26) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var index = `;
												{
													var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
													recordMeaningfulName(index, varName);
												};
											};
										} else {};
									};
									if (init != null) {
										collectEnumParameterBindings[0](init);
									};
								} else {
									haxe.macro.TypedExprTools.iter(expr, collectEnumParameterBindings[0]);
								};
							};
						};
						case 14: {
							var ` = `[0];
							{
								var exprs = `;
								{
									{
										var ` = 0;
										while (` < exprs.length) {
											var e = exprs[`];
											++ `;
											collectEnumParameterBindings[0](e);
										};
									};
								};
							};
						};
						default: {
							haxe.macro.TypedExprTools.iter(expr, collectEnumParameterBindings[0]);
						}
					};
				};
			};
			if (caseExpr != null) {
				collectEnumParameterBindings[0](caseExpr);
			};
			var canonicalVarNames = [];
			{
				var ` = 0;
				while (` < canonicalNames.length) {
					var name = canonicalNames[`];
					++ `;
					if (name != null) {
						canonicalVarNames.push(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(name, null));
					} else {
						canonicalVarNames.push(null);
					};
				};
			};
			{
				var ` = 0;
				var ` = maxParamCount[0];
				while (` < `) {
					var i = ` ++;
					var finalName = null;
					var extractedName = if (extractedParams != null && i < extractedParams.length) {
						extractedParams[i];
					} else {
						null;
					};
					if (extractedName != null && extractedName.length > 0 && ! reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(extractedName)) {
						finalName = extractedName;
					} else {
						var canonicalName = if ((i < canonicalVarNames.length)) {
							canonicalVarNames[i];
						} else {
							null;
						};
						if (canonicalName != null && canonicalName.length > 0 && ! reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(canonicalName)) {
							finalName = canonicalName;
						} else {
							finalName = if (i == 0) {
								"g";
							} else {
								"g" + i;
							};
						};
					};
					if (extractedParams != null) {
						ensureExtractedParamsSize(i);
						extractedParams[i] = finalName;
					};
					{
						plan.set(i, {finalName : finalName, isUsed : true});
					};
				};
			};
		};
		var paramIndexToVarId = {
			{};
			new haxe.ds.IntMap();
		};
		var findParameterAssignments = [null];
		findParameterAssignments[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, index):
				paramIndexToVarId.set(index, v.id);			
			default:
		};	
	case TBlock(exprs):
		for (e  in  exprs) findParameterAssignments(e);	
	default:
		haxe.macro.TypedExprTools.iter(expr, findParameterAssignments);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TEnumParameter(_, _, index):
		paramIndexToVarId.set(index, v.id);	
	default:
}) {
									var ` = init.expr;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var index = `;
											{
												{
													var value = v.id;
													paramIndexToVarId.set(index, value);
												};
											};
										};
									} else {};
								};
							} else {
								haxe.macro.TypedExprTools.iter(expr, findParameterAssignments[0]);
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										findParameterAssignments[0](e);
									};
								};
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, findParameterAssignments[0]);
					}
				};
			};
		};
		if (caseExpr != null) {
			findParameterAssignments[0](caseExpr);
		};
		var scanForEnumParameters = [null];
		scanForEnumParameters[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TEnumParameter(e, ef, index):
		if (plan.exists(index)) {
			var entry = plan.get(index);
			var isUsed = false;
			if (paramIndexToVarId.exists(index)) {
				var varId = paramIndexToVarId.get(index);
				isUsed = isPatternVariableUsedById(varId, caseExpr);
			} else {
				isUsed = isPatternVariableUsed(entry.finalName, caseExpr);
			};
			entry.isUsed = isUsed;
			plan.set(index, entry);
		} else {
			var finalName = if (extractedParams != null && index < extractedParams.length && extractedParams[index] != null) {
				extractedParams[index];
			} else {
				index == 0 ? "g" : "g$index";
			};
			var isUsed = false;
			if (paramIndexToVarId.exists(index)) {
				var varId = paramIndexToVarId.get(index);
				isUsed = isPatternVariableUsedById(varId, caseExpr);
			} else {
				isUsed = isPatternVariableUsed(finalName, caseExpr);
			};
			plan.set(index, { finalName : finalName, isUsed : isUsed });
		};
		scanForEnumParameters(e);	
	case TBlock(exprs):
		for (e  in  exprs) scanForEnumParameters(e);	
	case TIf(cond, thenExpr, elseExpr):
		scanForEnumParameters(cond);
		scanForEnumParameters(thenExpr);
		if (elseExpr != null) scanForEnumParameters(elseExpr);	
	case TSwitch(e, cases, def):
		scanForEnumParameters(e);
		for (c  in  cases) scanForEnumParameters(c.expr);
		if (def != null) scanForEnumParameters(def);	
	case TVar(v, init):
		if (init != null) scanForEnumParameters(init);	
	case TCall(e, args):
		scanForEnumParameters(e);
		for (arg  in  args) scanForEnumParameters(arg);	
	case TField(e, _):
		scanForEnumParameters(e);	
	case TLocal(_):
	case TConst(_):
	case _:
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						{};
					};
					case 1: {
						var ` = `[0];
						{};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							{
								scanForEnumParameters[0](e);
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								scanForEnumParameters[0](e);
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										scanForEnumParameters[0](arg);
									};
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							{
								if (init != null) {
									scanForEnumParameters[0](init);
								};
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										scanForEnumParameters[0](e);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenExpr = `;
							var elseExpr = `;
							{
								scanForEnumParameters[0](cond);
								scanForEnumParameters[0](thenExpr);
								if (elseExpr != null) {
									scanForEnumParameters[0](elseExpr);
								};
							};
						};
					};
					case 18: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							var cases = `;
							var def = `;
							{
								scanForEnumParameters[0](e);
								{
									var ` = 0;
									while (` < cases.length) {
										var c = cases[`];
										++ `;
										scanForEnumParameters[0](c.expr);
									};
								};
								if (def != null) {
									scanForEnumParameters[0](def);
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							var ef = `;
							var index = `;
							{
								if (plan.exists(index)) {
									var entry = cast plan.get(index);
									var isUsed = false;
									if (paramIndexToVarId.exists(index)) {
										var varId = cast paramIndexToVarId.get(index);
										isUsed = reflaxe.elixir.ast.ElixirASTBuilder.isPatternVariableUsedById(varId, caseExpr, null);
									} else {
										isUsed = reflaxe.elixir.ast.ElixirASTBuilder.isPatternVariableUsed(entry.finalName, caseExpr);
									};
									entry.isUsed = isUsed;
									{
										plan.set(index, entry);
									};
								} else {
									var finalName = if (extractedParams != null && index < extractedParams.length && extractedParams[index] != null) {
										extractedParams[index];
									} else {
										if (index == 0) {
											"g";
										} else {
											"g" + index;
										};
									};
									var isUsed = false;
									if (paramIndexToVarId.exists(index)) {
										var varId = cast paramIndexToVarId.get(index);
										isUsed = reflaxe.elixir.ast.ElixirASTBuilder.isPatternVariableUsedById(varId, caseExpr, null);
									} else {
										isUsed = reflaxe.elixir.ast.ElixirASTBuilder.isPatternVariableUsed(finalName, caseExpr);
									};
									{
										plan.set(index, {finalName : finalName, isUsed : isUsed});
									};
								};
								scanForEnumParameters[0](e);
							};
						};
					};
					default: {}
				};
			};
		};
		if (caseExpr != null) {
			scanForEnumParameters[0](caseExpr);
		};
		return {plan : plan, paramIndexToVarId : paramIndexToVarId};
	}

	@:value({ variableUsageMap : null })
	static function convertIdiomaticEnumPatternWithExtraction(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType, extractedParams:Array<String>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, extractedParams, variableUsageMap);
	}

	static function convertIdiomaticEnumPatternWithType(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType) {
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, null, null);
	}

	@:value({ variableUsageMap : null })
	static function convertRegularEnumPatternWithExtraction(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType, extractedParams:Array<String>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		return @:ast(switch (value.expr) {
	case TConst(TInt(index)):
		var constructors = enumType.constructs;
		var constructorArray = [];
		for (name  in  constructors.keys()) {
			var constructor = constructors.get(name);
			constructorArray[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
			var constructor = constructorArray[index];
			var atomName:reflaxe.elixir.ast.naming.ElixirAtom = constructor.name;
			var paramCount = 0;
			switch (constructor.type) {
				case TFun(args, _):
					paramCount = args.length;				
				default:
			};
			if (paramCount > 0) {
				var paramPatterns = [];
				var canonicalNames = switch (constructor.type) {
					case TFun(args, _):
						[for (arg  in  args) arg.name];					
					default:
						[];					
				};
				for (i  in  0 ... paramCount) {
					if (extractedParams != null && i < extractedParams.length && extractedParams[i] != null) {
						paramPatterns.push(PVar(extractedParams[i]));
					} else if (i < canonicalNames.length && canonicalNames[i] != null) {
						paramPatterns.push(PVar(canonicalNames[i]));
					} else {
						paramPatterns.push(PWildcard);
					};
				};
				PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
			} else {
				PTuple([PLiteral(makeAST(EAtom(atomName)))]);
			};
		} else {
			PWildcard;
		};	
	case TField(_, FEnum(_, ef)):
		var atomName:reflaxe.elixir.ast.naming.ElixirAtom = ef;
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount > 0) {
			var canonicalNames = switch (ef.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			var paramPatterns = [];
			for (i  in  0 ... paramCount) {
				if (extractedParams != null && i < extractedParams.length && extractedParams[i] != null && !extractedParams[i].startsWith("g")) {
					paramPatterns.push(PVar(extractedParams[i]));
				} else {
					var tempVarName = i == 0 ? "g" : "g${i}";
					paramPatterns.push(PVar(tempVarName));
				};
			};
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
		} else {
			PTuple([PLiteral(makeAST(EAtom(atomName)))]);
		};	
	default:
		convertPatternWithExtraction(value, extractedParams);	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = enumType.constructs;
								var constructorArray = [];
								for (name in constructors.keys()) {
									var constructor = cast constructors.get(name);
									constructorArray[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
									var constructor = constructorArray[index];
									var atomName = @:implicitCast {
										var s = constructor.name;
										{
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
											cast cast this;
										};
									};
									var paramCount = 0;
									@:ast(switch (constructor.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													paramCount = args.length;
												};
											};
										} else {};
									};
									if (paramCount > 0) {
										var paramPatterns = [];
										var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
											var ` = constructor.type;
											if (enumIndex ` == 4) {
												var ` = `[0];
												var ` = `[1];
												{
													var args = `;
													{
														{
															var ` = [];
															{
																var ` = 0;
																while (` < args.length) {
																	var arg = args[`];
																	++ `;
																	`.push(arg.name);
																};
															};
															`;
														};
													};
												};
											} else {
												[];
											};
										};
										{
											var ` = 0;
											var ` = paramCount;
											while (` < `) {
												var i = ` ++;
												if (extractedParams != null && i < extractedParams.length && extractedParams[i] != null) {
													paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(extractedParams[i]));
												} else {
													if (i < canonicalNames.length && canonicalNames[i] != null) {
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(canonicalNames[i]));
													} else {
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
													};
												};
											};
										};
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(atomName), metadata : {}, pos : pos};
										})].concat(paramPatterns));
									} else {
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(atomName), metadata : {}, pos : pos};
										})]);
									};
								} else {
									reflaxe.elixir.ast.EPattern.PWildcard;
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPatternWithExtraction(value, extractedParams);
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								var atomName = @:implicitCast {
									var s = ef.name;
									var this;
									this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
									cast cast this;
								};
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount > 0) {
									var canonicalNames = @:ast(switch (ef.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = ef.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var paramPatterns = [];
									{
										var ` = 0;
										var ` = paramCount;
										while (` < `) {
											var i = ` ++;
											if (extractedParams != null && i < extractedParams.length && extractedParams[i] != null && ! StringTools.startsWith(extractedParams[i], "g")) {
												paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(extractedParams[i]));
											} else {
												var tempVarName = if (i == 0) {
													"g";
												} else {
													"g" + i;
												};
												paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(tempVarName));
											};
										};
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(atomName), metadata : {}, pos : pos};
									})].concat(paramPatterns));
								} else {
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(atomName), metadata : {}, pos : pos};
									})]);
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPatternWithExtraction(value, extractedParams);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.convertPatternWithExtraction(value, extractedParams);
				}
			};
		};
	}

	@:value({ variableUsageMap : null })
	static function convertIdiomaticEnumPatternWithTypeImpl(value:haxe.macro.TypedExpr, enumType:haxe.macro.EnumType, extractedParams:Null<Array<String>>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		return @:ast(switch (value.expr) {
	case TConst(TInt(index)):
		var constructors = enumType.constructs;
		var constructorArray = [];
		for (name  in  constructors.keys()) {
			var constructor = constructors.get(name);
			constructorArray[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
			var constructor = constructorArray[index];
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(constructor.name);
			var paramCount = 0;
			switch (constructor.type) {
				case TFun(args, _):
					paramCount = args.length;				
				default:
			};
			if (paramCount > 0) {
				var canonicalNames = switch (constructor.type) {
					case TFun(args, _):
						[for (arg  in  args) arg.name];					
					default:
						[];					
				};
				var paramPatterns = [];
				if (extractedParams != null) {
					for (i  in  0 ... extractedParams.length) { };
				};
				for (i  in  0 ... paramCount) {
					var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
					if (isUsed && extractedParams[i] != null) {
						var varName = extractedParams[i];
						if (varName == null || varName == "" || (varName == "g" || varName.startsWith("g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
							var tempVarName = i == 0 ? "g" : "g${i}";
							paramPatterns.push(PVar(tempVarName));
						} else {
							paramPatterns.push(PVar(varName));
						};
					} else if (isUsed && i < canonicalNames.length) {
						var tempVarName = i == 0 ? "g" : "g${i}";
						paramPatterns.push(PVar(tempVarName));
					} else {
						paramPatterns.push(PWildcard);
					};
				};
				PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
			} else {
				PTuple([PLiteral(makeAST(EAtom(atomName)))]);
			};
		} else {
			PWildcard;
		};	
	case TField(_, FEnum(_, ef)):
		var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
		var paramCount = 0;
		switch (ef.type) {
			case TFun(args, _):
				paramCount = args.length;			
			default:
		};
		if (paramCount == 0) {
			PLiteral(makeAST(EAtom(atomName)));
		} else {
			var canonicalNames = switch (ef.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			var paramPatterns = [];
			for (i  in  0 ... paramCount) {
				var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
				if (isUsed && extractedParams[i] != null) {
					paramPatterns.push(PVar(extractedParams[i]));
				} else if (isUsed && i < canonicalNames.length) {
					paramPatterns.push(PVar(canonicalNames[i]));
				} else {
					paramPatterns.push(PWildcard);
				};
			};
			PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(paramPatterns));
		};	
	default:
		convertPattern(value);	
}) {
			var ` = value.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = enumType.constructs;
								var constructorArray = [];
								for (name in constructors.keys()) {
									var constructor = cast constructors.get(name);
									constructorArray[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructorArray.length && constructorArray[index] != null) {
									var constructor = constructorArray[index];
									var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(constructor.name);
									var paramCount = 0;
									@:ast(switch (constructor.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													paramCount = args.length;
												};
											};
										} else {};
									};
									if (paramCount > 0) {
										var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
											var ` = constructor.type;
											if (enumIndex ` == 4) {
												var ` = `[0];
												var ` = `[1];
												{
													var args = `;
													{
														{
															var ` = [];
															{
																var ` = 0;
																while (` < args.length) {
																	var arg = args[`];
																	++ `;
																	`.push(arg.name);
																};
															};
															`;
														};
													};
												};
											} else {
												[];
											};
										};
										var paramPatterns = [];
										if (extractedParams != null) {
											{
												var ` = 0;
												var ` = extractedParams.length;
												while (` < `) {
													var i = ` ++;
												};
											};
										};
										{
											var ` = 0;
											var ` = paramCount;
											while (` < `) {
												var i = ` ++;
												var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
												if (isUsed && extractedParams[i] != null) {
													var varName = extractedParams[i];
													if (varName == null || varName == "" || (varName == "g" || StringTools.startsWith(varName, "g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
														var tempVarName = if (i == 0) {
															"g";
														} else {
															"g" + i;
														};
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(tempVarName));
													} else {
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(varName));
													};
												} else {
													if (isUsed && i < canonicalNames.length) {
														var tempVarName = if (i == 0) {
															"g";
														} else {
															"g" + i;
														};
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(tempVarName));
													} else {
														paramPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
													};
												};
											};
										};
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										})].concat(paramPatterns));
									} else {
										reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										})]);
									};
								} else {
									reflaxe.elixir.ast.EPattern.PWildcard;
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
								var paramCount = 0;
								@:ast(switch (ef.type) {
	case TFun(args, _):
		paramCount = args.length;	
	default:
}) {
									var ` = ef.type;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											{
												paramCount = args.length;
											};
										};
									} else {};
								};
								if (paramCount == 0) {
									reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									});
								} else {
									var canonicalNames = @:ast(switch (ef.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = ef.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var paramPatterns = [];
									{
										var ` = 0;
										var ` = paramCount;
										while (` < `) {
											var i = ` ++;
											var isUsed = extractedParams != null && i < extractedParams.length && extractedParams[i] != null;
											if (isUsed && extractedParams[i] != null) {
												paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(extractedParams[i]));
											} else {
												if (isUsed && i < canonicalNames.length) {
													paramPatterns.push(reflaxe.elixir.ast.EPattern.PVar(canonicalNames[i]));
												} else {
													paramPatterns.push(reflaxe.elixir.ast.EPattern.PWildcard);
												};
											};
										};
									};
									reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									})].concat(paramPatterns));
								};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
				}
			};
		};
	}

	static function convertIdiomaticEnumPattern(value:haxe.macro.TypedExpr, switchTarget:haxe.macro.TypedExpr) {
		var enumType = @:ast(switch (switchTarget.t) {
	case TEnum(enumRef, _):
		enumRef.get();	
	default:
		return convertPattern(value);	
}) {
			var ` = switchTarget.t;
			if (enumIndex ` == 1) {
				var ` = `[0];
				var ` = `[1];
				{
					var enumRef = `;
					{
						enumRef.get();
					};
				};
			} else {
				return reflaxe.elixir.ast.ElixirASTBuilder.convertPattern(value);
			};
		};
		return reflaxe.elixir.ast.ElixirASTBuilder.convertIdiomaticEnumPatternWithTypeImpl(value, enumType, null, null);
	}

	static function isEnumConstructor(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(_, _)):
		true;	
	case TTypeExpr(TEnumDecl(_)):
		true;	
	case TField(_, FStatic(_, _)):
		false;	
	case TConst(TString(s)) if (s.charAt(0) >= "A" && s.charAt(0) <= "Z"):
		true;	
	default:
		switch (expr.t) {
			case TEnum(_, _):
				true;			
			case TFun(_, _):
				false;			
			default:
				false;			
		};	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 2) {
						var ` = `[0];
						{
							var s = `;
							if (s.charAt(0) >= "A" && s.charAt(0) <= "Z") {
								true;
							} else {
								@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
									var ` = expr.t;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											var ` = `[1];
											{
												true;
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												false;
											};
										};
										default: {
											false;
										}
									};
								};
							};
						};
					} else {
						@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
							var ` = expr.t;
							switch (enumIndex `) {
								case 1: {
									var ` = `[0];
									var ` = `[1];
									{
										true;
									};
								};
								case 4: {
									var ` = `[0];
									var ` = `[1];
									{
										false;
									};
								};
								default: {
									false;
								}
							};
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					switch (enumIndex `) {
						case 1: {
							var ` = `[0];
							var ` = `[1];
							{
								false;
							};
						};
						case 5: {
							var ` = `[0];
							var ` = `[1];
							{
								true;
							};
						};
						default: {
							@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
								var ` = expr.t;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										var ` = `[1];
										{
											true;
										};
									};
									case 4: {
										var ` = `[0];
										var ` = `[1];
										{
											false;
										};
									};
									default: {
										false;
									}
								};
							};
						}
					};
				};
				case 5: {
					var ` = `[0];
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							true;
						};
					} else {
						@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
							var ` = expr.t;
							switch (enumIndex `) {
								case 1: {
									var ` = `[0];
									var ` = `[1];
									{
										true;
									};
								};
								case 4: {
									var ` = `[0];
									var ` = `[1];
									{
										false;
									};
								};
								default: {
									false;
								}
							};
						};
					};
				};
				default: {
					@:ast(switch (expr.t) {
	case TEnum(_, _):
		true;	
	case TFun(_, _):
		false;	
	default:
		false;	
}) {
						var ` = expr.t;
						switch (enumIndex `) {
							case 1: {
								var ` = `[0];
								var ` = `[1];
								{
									true;
								};
							};
							case 4: {
								var ` = `[0];
								var ` = `[1];
								{
									false;
								};
							};
							default: {
								false;
							}
						};
					};
				}
			};
		};
	}

	static function hasIdiomaticMetadata(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	case TTypeExpr(TEnumDecl(enumRef)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								return hasIt;
							};
						};
					} else {};
				};
				case 5: {
					var ` = `[0];
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								return hasIt;
							};
						};
					} else {};
				};
				default: {}
			};
		};
		@:ast(switch (expr.t) {
	case TFun(_, ret):
		switch (ret) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				var hasIt = enumType.meta.has(":elixirIdiomatic");
				return hasIt;			
			default:
		};	
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) {
			var ` = expr.t;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							var hasIt = enumType.meta.has(":elixirIdiomatic");
							return hasIt;
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var ret = `;
						{
							@:ast(switch (ret) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) if (enumIndex ret == 1) {
								var ` = ret[0];
								var ` = ret[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										var hasIt = enumType.meta.has(":elixirIdiomatic");
										return hasIt;
									};
								};
							} else {};
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	static function getEnumTypeName(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		enumType.name;	
	default:
		"";	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 5) {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							enumType.name;
						};
					};
				} else {
					"";
				};
			} else {
				"";
			};
		};
	}

	static function toElixirAtomName(name:String) {
		var result = [];
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var c = name.charAt(i);
				if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
					result.push("_");
					result.push(c.toLowerCase());
				} else {
					result.push(c.toLowerCase());
				};
			};
		};
		return result.join("");
	}

	static function containsIfStatement(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TIf(_, _, _):
		true;	
	case TBlock(el):
		for (e  in  el) {
			if (containsIfStatement(e)) return true;
		};
		false;	
	case TWhile(_, body, _):
		containsIfStatement(body);	
	case TFor(_, _, body):
		containsIfStatement(body);	
	case TSwitch(_, cases, _):
		for (c  in  cases) {
			if (containsIfStatement(c.expr)) return true;
		};
		false;	
	case TCall(_, args):
		for (arg  in  args) {
			if (containsIfStatement(arg)) return true;
		};
		false;	
	case TVar(_, init) if (init != null):
		containsIfStatement(init);	
	case TBinop(_, e1, e2):
		containsIfStatement(e1) || containsIfStatement(e2);	
	case TUnop(_, _, e):
		containsIfStatement(e);	
	case TParenthesis(e):
		containsIfStatement(e);	
	case TMeta(_, e):
		containsIfStatement(e);	
	case TCast(e, _):
		containsIfStatement(e);	
	case TTry(e, catches):
		if (containsIfStatement(e)) return true;
		for (c  in  catches) {
			if (containsIfStatement(c.expr)) return true;
		};
		false;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e1) || reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e2);
						};
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var args = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(arg)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var init = `;
						if (init != null) {
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(init);
						} else {
							false;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var body = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(body);
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var body = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(body);
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cases = `;
						{
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(c.expr)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e)) {
								return true;
							};
							{
								var ` = 0;
								while (` < catches.length) {
									var c = catches[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(c.expr)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isArrayType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		var cl = c.get();
		cl.name == "Array";	
	case TAbstract(a, _):
		var abs = a.get();
		abs.name == "Array";	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						var cl = c.get();
						cl.name == "Array";
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					{
						var abs = a.get();
						abs.name == "Array";
					};
				};
			};
			default: {
				false;
			}
		};
	}

	static function tryExpandElixirInjection(methodExpr:haxe.macro.TypedExpr, thisExpr:haxe.macro.TypedExpr, args:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		@:ast(switch (methodExpr.expr) {
	case TFunction(tfunc):
		if (tfunc.expr != null) {
			return tryExpandElixirInjection(tfunc.expr, thisExpr, args, context);
		};	
	default:
}) {
			var ` = methodExpr.expr;
			if (enumIndex ` == 12) {
				var ` = `[0];
				{
					var tfunc = `;
					{
						if (tfunc.expr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirInjection(tfunc.expr, thisExpr, args, context);
						};
					};
				};
			} else {};
		};
		@:ast(switch (methodExpr.expr) {
	case TReturn(retOpt):
		if (retOpt != null) {
			return tryExpandElixirCall(retOpt, thisExpr, args, context);
		};	
	case TBlock(exprs):
		if (exprs.length > 0) {
			var lastExpr = exprs[exprs.length - 1];
			return tryExpandElixirCall(lastExpr, thisExpr, args, context);
		};	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, args, context);
		if (ifResult != null) {
			var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, args, context) : null;
			if (elseResult != null) {
				var condAst = buildFromTypedExpr(cond, context);
				return makeAST(EIf(condAst, ifResult, elseResult));
			};
			return ifResult;
		};	
	case TCall(_):
		return tryExpandElixirCall(methodExpr, thisExpr, args, context);	
	default:
}) {
			var ` = methodExpr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(methodExpr, thisExpr, args, context);
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							if (exprs.length > 0) {
								var lastExpr = exprs[exprs.length - 1];
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(lastExpr, thisExpr, args, context);
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, args, context);
							if (ifResult != null) {
								var elseResult = if (elseExpr != null) {
									reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, args, context);
								} else {
									null;
								};
								if (elseResult != null) {
									var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, context);
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
									};
								};
								return ifResult;
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retOpt = `;
						{
							if (retOpt != null) {
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retOpt, thisExpr, args, context);
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function detectFluentAPIPattern(func:haxe.macro.TFunc) {
		var result = {returnsThis : false, fieldMutations : []};
		if (func.expr == null) {
			return result;
		};
		var checkReturnsThis = [null];
		checkReturnsThis[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TReturn(e) if (e != null):
		switch (e.expr) {
			case TConst(TThis):
				return true;			
			case TLocal(v) if (v.name == "this"):
				return true;			
			default:
		};	
	case TConst(TThis):
		return true;	
	case TLocal(v) if (v.name == "this"):
		return true;	
	case TBlock(exprs) if (exprs.length > 0):
		return checkReturnsThis(exprs[exprs.length - 1]);	
	default:
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						if (enumIndex ` == 5) {
							{
								return true;
							};
						} else {};
					};
					case 1: {
						var ` = `[0];
						{
							var v = `;
							if (v.name == "this") {
								return true;
							} else {};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							if (exprs.length > 0) {
								return checkReturnsThis[0](exprs[exprs.length - 1]);
							} else {};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								@:ast(switch (e.expr) {
	case TConst(TThis):
		return true;	
	case TLocal(v) if (v.name == "this"):
		return true;	
	default:
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											if (enumIndex ` == 5) {
												{
													return true;
												};
											} else {};
										};
										case 1: {
											var ` = `[0];
											{
												var v = `;
												if (v.name == "this") {
													return true;
												} else {};
											};
										};
										default: {}
									};
								};
							} else {};
						};
					};
					default: {}
				};
			};
			return false;
		};
		var detectMutations = [null];
		detectMutations[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TCall(e, args):
		switch (e.expr) {
			case TField(target, FInstance(_, _, cf)):
				var methodName = cf.get().name;
				if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
					switch (target.expr) {
						case TField(obj, FInstance(_, _, fieldRef)):
							switch (obj.expr) {
								case TConst(TThis):
									result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });								
								default:
							};						
						default:
					};
				};			
			default:
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			detectMutations(e);
		};	
	case TIf(_, thenExpr, elseExpr):
		detectMutations(thenExpr);
		if (elseExpr != null) detectMutations(elseExpr);	
	case TWhile(_, body, _):
		detectMutations(body);	
	case TFor(_, _, body):
		detectMutations(body);	
	case TSwitch(_, cases, edef):
		for (c  in  cases) {
			detectMutations(c.expr);
		};
		if (edef != null) detectMutations(edef);	
	case TReturn(e) if (e != null):
		detectMutations(e);	
	case TTry(e, catches):
		detectMutations(e);
		for (c  in  catches) {
			detectMutations(c.expr);
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, detectMutations);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								@:ast(switch (e.expr) {
	case TField(target, FInstance(_, _, cf)):
		var methodName = cf.get().name;
		if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
			switch (target.expr) {
				case TField(obj, FInstance(_, _, fieldRef)):
					switch (obj.expr) {
						case TConst(TThis):
							result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });						
						default:
					};				
				default:
			};
		};	
	default:
}) {
									var ` = e.expr;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var target = `;
												{
													var methodName = cf.get().name;
													if (methodName == "push" || methodName == "pop" || methodName == "shift" || methodName == "unshift" || methodName == "splice" || methodName == "reverse" || methodName == "sort") {
														@:ast(switch (target.expr) {
	case TField(obj, FInstance(_, _, fieldRef)):
		switch (obj.expr) {
			case TConst(TThis):
				result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });			
			default:
		};	
	default:
}) {
															var ` = target.expr;
															if (enumIndex ` == 4) {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var fieldRef = `;
																		var obj = `;
																		{
																			@:ast(switch (obj.expr) {
	case TConst(TThis):
		result.fieldMutations.push({ field : fieldRef.get().name, expr : expr });	
	default:
}) {
																				var ` = obj.expr;
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					if (enumIndex ` == 5) {
																						{
																							result.fieldMutations.push({field : fieldRef.get().name, expr : expr});
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																} else {};
															} else {};
														};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										detectMutations[0](e);
									};
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var body = `;
							{
								detectMutations[0](body);
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var thenExpr = `;
							var elseExpr = `;
							{
								detectMutations[0](thenExpr);
								if (elseExpr != null) {
									detectMutations[0](elseExpr);
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var body = `;
							{
								detectMutations[0](body);
							};
						};
					};
					case 18: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cases = `;
							var edef = `;
							{
								{
									var ` = 0;
									while (` < cases.length) {
										var c = cases[`];
										++ `;
										detectMutations[0](c.expr);
									};
								};
								if (edef != null) {
									detectMutations[0](edef);
								};
							};
						};
					};
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var catches = `;
							{
								detectMutations[0](e);
								{
									var ` = 0;
									while (` < catches.length) {
										var c = catches[`];
										++ `;
										detectMutations[0](c.expr);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								detectMutations[0](e);
							} else {
								haxe.macro.TypedExprTools.iter(expr, detectMutations[0]);
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, detectMutations[0]);
					}
				};
			};
		};
		result.returnsThis = checkReturnsThis[0](func.expr);
		detectMutations[0](func.expr);
		return result;
	}

	static function tryExpandElixirCall(expr:haxe.macro.TypedExpr, thisExpr:haxe.macro.TypedExpr, methodArgs:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		@:ast(switch (expr.expr) {
	case TReturn(retExpr) if (retExpr != null):
		return tryExpandElixirCall(retExpr, thisExpr, methodArgs, context);	
	case TMeta({ name : ":untyped" }, untypedExpr):
		return tryExpandElixirCall(untypedExpr, thisExpr, methodArgs, context);	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, methodArgs, context);
		var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, methodArgs, context) : null;
		if (ifResult != null && elseResult != null) {
			var condAst = buildFromTypedExpr(cond, context);
			return makeAST(EIf(condAst, ifResult, elseResult));
		} else if (ifResult != null) {
			return ifResult;
		} else if (elseResult != null) {
			return elseResult;
		};	
	case TCall(e, callArgs):
		switch (e.expr) {
			case TIdent("__elixir__"):
				if (callArgs.length > 0) {
					switch (callArgs[0].expr) {
						case TConst(TString(code)):
							var processedCode = code;
							var thisAst = buildFromTypedExpr(thisExpr, context);
							var thisStr = ElixirASTPrinter.printAST(thisAst);
							processedCode = StringTools.replace(processedCode, "{0}", thisStr);
							for (i  in  1 ... callArgs.length) {
								if (i - 1 < methodArgs.length) {
									var argAst = buildFromTypedExpr(methodArgs[i - 1], context);
									var argStr = ElixirASTPrinter.printAST(argAst);
									var placeholder = "{$i}";
									processedCode = StringTools.replace(processedCode, placeholder, argStr);
								};
							};
							return makeAST(ERaw(processedCode));						
						default:
					};
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var callArgs = `;
						{
							@:ast(switch (e.expr) {
	case TIdent("__elixir__"):
		if (callArgs.length > 0) {
			switch (callArgs[0].expr) {
				case TConst(TString(code)):
					var processedCode = code;
					var thisAst = buildFromTypedExpr(thisExpr, context);
					var thisStr = ElixirASTPrinter.printAST(thisAst);
					processedCode = StringTools.replace(processedCode, "{0}", thisStr);
					for (i  in  1 ... callArgs.length) {
						if (i - 1 < methodArgs.length) {
							var argAst = buildFromTypedExpr(methodArgs[i - 1], context);
							var argStr = ElixirASTPrinter.printAST(argAst);
							var placeholder = "{$i}";
							processedCode = StringTools.replace(processedCode, placeholder, argStr);
						};
					};
					return makeAST(ERaw(processedCode));				
				default:
			};
		};	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 28) {
									var ` = `[0];
									if (` == "__elixir__") {
										{
											if (callArgs.length > 0) {
												@:ast(switch (callArgs[0].expr) {
	case TConst(TString(code)):
		var processedCode = code;
		var thisAst = buildFromTypedExpr(thisExpr, context);
		var thisStr = ElixirASTPrinter.printAST(thisAst);
		processedCode = StringTools.replace(processedCode, "{0}", thisStr);
		for (i  in  1 ... callArgs.length) {
			if (i - 1 < methodArgs.length) {
				var argAst = buildFromTypedExpr(methodArgs[i - 1], context);
				var argStr = ElixirASTPrinter.printAST(argAst);
				var placeholder = "{$i}";
				processedCode = StringTools.replace(processedCode, placeholder, argStr);
			};
		};
		return makeAST(ERaw(processedCode));	
	default:
}) {
													var ` = callArgs[0].expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															{
																var code = `;
																{
																	var processedCode = code;
																	var thisAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(thisExpr, context);
																	var thisStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(thisAst, null);
																	processedCode = StringTools.replace(processedCode, "{0}", thisStr);
																	{
																		var ` = 1;
																		var ` = callArgs.length;
																		while (` < `) {
																			var i = ` ++;
																			if (i - 1 < methodArgs.length) {
																				var argAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(methodArgs[i - 1], context);
																				var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst, null);
																				var placeholder = "{" + i + "}";
																				processedCode = StringTools.replace(processedCode, placeholder, argStr);
																			};
																		};
																	};
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(processedCode), metadata : {}, pos : pos};
																	};
																};
															};
														} else {};
													} else {};
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, methodArgs, context);
							var elseResult = if (elseExpr != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, methodArgs, context);
							} else {
								null;
							};
							if (ifResult != null && elseResult != null) {
								var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, context);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
								};
							} else {
								if (ifResult != null) {
									return ifResult;
								} else {
									if (elseResult != null) {
										return elseResult;
									};
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retExpr = `;
						if (retExpr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retExpr, thisExpr, methodArgs, context);
						} else {};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.name;
						var ` = `.params;
						var ` = `.pos;
						if (` == ":untyped") {
							{
								var untypedExpr = `;
								{
									return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(untypedExpr, thisExpr, methodArgs, context);
								};
							};
						} else {};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function isMapType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		var cl = c.get();
		cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || cl.name == "Map" || cl.name.endsWith("Map");	
	case TAbstract(a, params):
		var abs = a.get();
		abs.name == "Map" || abs.name.endsWith("Map");	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						var cl = c.get();
						cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || cl.name == "Map" || StringTools.endsWith(cl.name, "Map");
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					var params = `;
					{
						var abs = a.get();
						abs.name == "Map" || StringTools.endsWith(abs.name, "Map");
					};
				};
			};
			default: {
				false;
			}
		};
	}

	static function extractEnumTag(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TField(_, FEnum(_, ef)):
		ef.name;	
	case TField(_, FStatic(_, cf)):
		var methodName = cf.get().name;
		methodName.charAt(0).toUpperCase() + methodName.substr(1);	
	default:
		"ModuleRef";	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var cf = `;
							{
								var methodName = cf.get().name;
								methodName.charAt(0).toUpperCase() + methodName.substr(1, null);
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								ef.name;
							};
						};
					};
					default: {
						"ModuleRef";
					}
				};
			} else {
				"ModuleRef";
			};
		};
	}

	static function extractPattern(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TLocal(v):
		PVar(toElixirVarName(v.name));	
	case TField(e, fa):
		PVar(extractFieldName(fa));	
	default:
		PWildcard;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null));
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var fa = `;
						{
							reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa));
						};
					};
				};
				default: {
					reflaxe.elixir.ast.EPattern.PWildcard;
				}
			};
		};
	}

	static function convertAssignOp(op:haxe.macro.Binop) {
		return @:ast(switch (op) {
	case OpAdd:
		Add;	
	case OpSub:
		Subtract;	
	case OpMult:
		Multiply;	
	case OpDiv:
		Divide;	
	case OpMod:
		Remainder;	
	case OpAnd:
		BitwiseAnd;	
	case OpOr:
		BitwiseOr;	
	case OpXor:
		BitwiseXor;	
	case OpShl:
		ShiftLeft;	
	case OpShr:
		ShiftRight;	
	default:
		Add;	
}) switch (enumIndex op) {
			case 0: {
				{
					reflaxe.elixir.ast.EBinaryOp.Add;
				};
			};
			case 1: {
				{
					reflaxe.elixir.ast.EBinaryOp.Multiply;
				};
			};
			case 2: {
				{
					reflaxe.elixir.ast.EBinaryOp.Divide;
				};
			};
			case 3: {
				{
					reflaxe.elixir.ast.EBinaryOp.Subtract;
				};
			};
			case 11: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseAnd;
				};
			};
			case 12: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseOr;
				};
			};
			case 13: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseXor;
				};
			};
			case 16: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftLeft;
				};
			};
			case 17: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftRight;
				};
			};
			case 19: {
				{
					reflaxe.elixir.ast.EBinaryOp.Remainder;
				};
			};
			default: {
				reflaxe.elixir.ast.EBinaryOp.Add;
			}
		};
	}

	static function applyParameterRenaming(ast:reflaxe.elixir.ast.ElixirAST, renaming:Map<String, String>) {
		return @:ast(switch (ast.def) {
	case EVar(name):
		if (renaming.exists(name)) {
			makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EBlock(exprs):
		makeASTWithMeta(EBlock(exprs.map(function(e) ->  @:implicitReturn return applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);	
	case ECall(target, func, args):
		makeASTWithMeta(ECall(target != null ? applyParameterRenaming(target, renaming) : null, func, args.map(function(a) ->  @:implicitReturn return applyParameterRenaming(a, renaming))), ast.metadata, ast.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)), ast.metadata, ast.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);	
	case EIf(cond, then, else_):
		makeASTWithMeta(EIf(applyParameterRenaming(cond, renaming), applyParameterRenaming(then, renaming), else_ != null ? applyParameterRenaming(else_, renaming) : null), ast.metadata, ast.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(applyParameterRenaming(expr, renaming), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? applyParameterRenaming(c.guard, renaming) : null, body : applyParameterRenaming(c.body, renaming) })), ast.metadata, ast.pos);	
	default:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.guard, renaming) else null, body : reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.body, renaming)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var then = `;
						var else_ = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(cond, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(then, renaming), if ((else_ != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(else_, renaming) else null);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var func = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(target, renaming) else null, func, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(left, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(right, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							if (renaming.exists(name)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renaming.get(name));
									var meta = ast.metadata;
									var pos = ast.pos;
									{def : def, metadata : meta, pos : pos};
								};
							} else {
								ast;
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = exprs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					ast;
				}
			};
		};
	}

	static function isCamelCaseParameter(name:String) {
		if (name.length < 2) {
			return false;
		};
		var firstChar = name.charAt(0);
		if (firstChar != firstChar.toLowerCase()) {
			return false;
		};
		{
			var ` = 1;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
					return true;
				};
			};
		};
		return false;
	}

	@:value({ preserveUnderscore : false })
	static function toElixirVarName(name:String, preserveUnderscore:Null<Bool> = false) {
		if (preserveUnderscore && (name.length == 0 || name.charAt(0) != "_")) {
			return reflaxe.elixir.ast.naming.ElixirNaming.toVarName(name);
		};
		return reflaxe.elixir.ast.naming.ElixirNaming.toVarName(name);
	}

	public static function isTempPatternVarName(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var isDigits = function(str:String) {
			if (str == null || str.length == 0) {
				return false;
			};
			{
				var ` = 0;
				var ` = str.length;
				while (` < `) {
					var i = ` ++;
					var c = str.charAt(i);
					if (c < "0" || c > "9") {
						return false;
					};
				};
			};
			return true;
		};
		var check = function(candidate:String) {
			if (candidate == null || candidate.length == 0) {
				return false;
			};
			if (candidate == "g" || candidate == "_g") {
				return true;
			};
			if (candidate.length > 1 && candidate.charAt(0) == "g" && isDigits(candidate.substr(1, null))) {
				return true;
			};
			if (candidate.length > 2 && candidate.charAt(0) == "_" && candidate.charAt(1) == "g" && isDigits(candidate.substr(2, null))) {
				return true;
			};
			return false;
		};
		if (check(name)) {
			return true;
		};
		var canonical = reflaxe.elixir.ast.naming.ElixirNaming.toVarName(name);
		if (canonical != name && check(canonical)) {
			return true;
		};
		return false;
	}

	public static function extractFieldName(fa:haxe.macro.FieldAccess) {
		return @:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
		cf.get().name;	
	case FDynamic(s):
		s;	
	case FEnum(_, ef):
		ef.name;	
}) switch (@:exhaustive enumIndex fa) {
			case 0: {
				var ` = fa[0];
				var ` = fa[1];
				var ` = fa[2];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 1: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 2: {
				var ` = fa[0];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 3: {
				var ` = fa[0];
				{
					var s = `;
					{
						s;
					};
				};
			};
			case 4: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 5: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var ef = `;
					{
						ef.name;
					};
				};
			};
		};
	}

	@:value({ enumBindingPlan : null })
	static function createVariableMappingsForCase(caseExpr:haxe.macro.TypedExpr, extractedParams:Array<String>, enumType:Null<haxe.macro.EnumType>, values:Array<haxe.macro.TypedExpr>, enumBindingPlan:Null<Map<Int, { isUsed : Bool, finalName : String }>> = null) {
		var mapping = {
			{};
			new haxe.ds.IntMap();
		};
		if (enumType == null) {
			var scanForVariableAssignments = [null];
			scanForVariableAssignments[0] = function(expr:haxe.macro.TypedExpr) {
				@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) scanForVariableAssignments(e);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TLocal(sourceVar):
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments);	
}) {
					var ` = expr.expr;
					switch (enumIndex `) {
						case 13: {
							var ` = `[0];
							var ` = `[1];
							{
								var v = `;
								var init = `;
								if (init != null) {
									@:ast(switch (init.expr) {
	case TLocal(sourceVar):
	default:
}) {
										var ` = init.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var sourceVar = `;
												{};
											};
										} else {};
									};
								} else {
									haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments[0]);
								};
							};
						};
						case 14: {
							var ` = `[0];
							{
								var exprs = `;
								{
									{
										var ` = 0;
										while (` < exprs.length) {
											var e = exprs[`];
											++ `;
											scanForVariableAssignments[0](e);
										};
									};
								};
							};
						};
						default: {
							haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments[0]);
						}
					};
				};
			};
			scanForVariableAssignments[0](caseExpr);
			return mapping;
		};
		if (values.length > 0) {
			@:ast(switch (values[0].expr) {
	case TConst(TInt(index)):
		var constructors = [];
		for (name  in  enumType.constructs.keys()) {
			var constructor = enumType.constructs.get(name);
			constructors[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructors.length && constructors[index] != null) {
			var constructor = constructors[index];
			var canonicalNames = switch (constructor.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			var enumExtractionVars = new Map<Int,Bool>();
			function scanForTVars(expr:TypedExpr):Void {
				switch (expr.expr) {
					case TBlock(exprs):
						for (e  in  exprs) scanForTVars(e);					
					case TVar(v, init) if (init != null):
						switch (init.expr) {
							case TEnumParameter(_, _, paramIndex):
								var finalName:String;
								if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
									finalName = enumBindingPlan.get(paramIndex).finalName;
								} else {
									var varName = toElixirVarName(v.name);
									if (varName.startsWith("_g")) {
										varName = varName.substr(1);
									};
									finalName = varName;
								};
								mapping.set(v.id, finalName);
								enumExtractionVars.set(v.id, true);							
							case TLocal(tempVar):
								var tempVarName = toElixirVarName(tempVar.name);
								var patternVarName = toElixirVarName(v.name);
								if (enumExtractionVars.exists(tempVar.id)) {
									mapping.set(v.id, patternVarName);
								} else if (mapping.exists(tempVar.id)) {
									var canonicalName = mapping.get(tempVar.id);
									mapping.set(v.id, canonicalName);
									if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
										currentContext.patternVariableRegistry.set(v.id, canonicalName);
									};
								} else { };							
							default:
						};					
					default:
						haxe.macro.TypedExprTools.iter(expr, scanForTVars);					
				};
			};
			scanForTVars(caseExpr);
		};	
	default:
}) {
				var ` = values[0].expr;
				if (enumIndex ` == 0) {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = [];
								for (name in {
									var this = enumType.constructs;
									cast this.keys();
								}) {
									var constructor = {
										var this = enumType.constructs;
										cast this.get(name);
									};
									constructors[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructors.length && constructors[index] != null) {
									var constructor = constructors[index];
									var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var enumExtractionVars = {
										{};
										new haxe.ds.IntMap();
									};
									var scanForTVars = [null];
									scanForTVars[0] = function(expr:haxe.macro.TypedExpr) {
										@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) scanForTVars(e);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, paramIndex):
				var finalName:String;
				if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
					finalName = enumBindingPlan.get(paramIndex).finalName;
				} else {
					var varName = toElixirVarName(v.name);
					if (varName.startsWith("_g")) {
						varName = varName.substr(1);
					};
					finalName = varName;
				};
				mapping.set(v.id, finalName);
				enumExtractionVars.set(v.id, true);			
			case TLocal(tempVar):
				var tempVarName = toElixirVarName(tempVar.name);
				var patternVarName = toElixirVarName(v.name);
				if (enumExtractionVars.exists(tempVar.id)) {
					mapping.set(v.id, patternVarName);
				} else if (mapping.exists(tempVar.id)) {
					var canonicalName = mapping.get(tempVar.id);
					mapping.set(v.id, canonicalName);
					if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
						currentContext.patternVariableRegistry.set(v.id, canonicalName);
					};
				} else { };			
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, scanForTVars);	
}) {
											var ` = expr.expr;
											switch (enumIndex `) {
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null) {
															@:ast(switch (init.expr) {
	case TEnumParameter(_, _, paramIndex):
		var finalName:String;
		if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
			finalName = enumBindingPlan.get(paramIndex).finalName;
		} else {
			var varName = toElixirVarName(v.name);
			if (varName.startsWith("_g")) {
				varName = varName.substr(1);
			};
			finalName = varName;
		};
		mapping.set(v.id, finalName);
		enumExtractionVars.set(v.id, true);	
	case TLocal(tempVar):
		var tempVarName = toElixirVarName(tempVar.name);
		var patternVarName = toElixirVarName(v.name);
		if (enumExtractionVars.exists(tempVar.id)) {
			mapping.set(v.id, patternVarName);
		} else if (mapping.exists(tempVar.id)) {
			var canonicalName = mapping.get(tempVar.id);
			mapping.set(v.id, canonicalName);
			if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
				currentContext.patternVariableRegistry.set(v.id, canonicalName);
			};
		} else { };	
	default:
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 1: {
																		var ` = `[0];
																		{
																			var tempVar = `;
																			{
																				var tempVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(tempVar.name, null);
																				var patternVarName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																				if ({
																					var key = tempVar.id;
																					enumExtractionVars.exists(key);
																				}) {
																					{
																						var key = v.id;
																						mapping.set(key, patternVarName);
																					};
																				} else {
																					if ({
																						var key = tempVar.id;
																						mapping.exists(key);
																					}) {
																						var canonicalName = {
																							var key = tempVar.id;
																							mapping.get(key);
																						};
																						{
																							var key = v.id;
																							mapping.set(key, canonicalName);
																						};
																						if ({
																							var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.patternVariableRegistry;
																							var key = tempVar.id;
																							cast this.exists(key);
																						}) {
																							{
																								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.patternVariableRegistry;
																								var key = v.id;
																								cast this.set(key, canonicalName);
																							};
																						};
																					} else {};
																				};
																			};
																		};
																	};
																	case 26: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var paramIndex = `;
																			{
																				var finalName;
																				if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
																					finalName = cast enumBindingPlan.get(paramIndex).finalName;
																				} else {
																					var varName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
																					if (StringTools.startsWith(varName, "_g")) {
																						varName = varName.substr(1, null);
																					};
																					finalName = varName;
																				};
																				{
																					var key = v.id;
																					mapping.set(key, finalName);
																				};
																				{
																					var key = v.id;
																					enumExtractionVars.set(key, true);
																				};
																			};
																		};
																	};
																	default: {}
																};
															};
														} else {
															haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
														};
													};
												};
												case 14: {
													var ` = `[0];
													{
														var exprs = `;
														{
															{
																var ` = 0;
																while (` < exprs.length) {
																	var e = exprs[`];
																	++ `;
																	scanForTVars[0](e);
																};
															};
														};
													};
												};
												default: {
													haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
												}
											};
										};
									};
									scanForTVars[0](caseExpr);
								};
							};
						};
					} else {};
				} else {};
			};
		};
		return mapping;
	}

	static function toSnakeCase(s:String) {
		if (s.length == 0) {
			return s;
		};
		var result = new StringBuf();
		{
			var ` = 0;
			var ` = s.length;
			while (` < `) {
				var i = ` ++;
				var char = s.charAt(i);
				if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
					result.add("_");
					result.add(char.toLowerCase());
				} else {
					result.add(char.toLowerCase());
				};
			};
		};
		return result.toString();
	}

	static function collectTemplateContent(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		s;	
	case EBinary(StringConcat, left, right):
		collectTemplateContent(left) + collectTemplateContent(right);	
	case EVar(name):
		"<%= " + name + " %>";	
	case ECall(module, func, args):
		var callStr = if (module != null) {
			switch (module.def) {
				case EVar(m):
					m + "." + func;				
				default:
					func;				
			};
		} else {
			func;
		};
		if (args.length > 0) {
			var argStrs = [];
			for (arg  in  args) {
				argStrs.push(collectTemplateArgument(arg));
			};
			callStr += "(" + argStrs.join(", ") + ")";
		} else {
			callStr += "()";
		};
		"<%= " + callStr + " %>";	
	default:
		"<%= [unhandled expression] %>";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var callStr = if (module != null) {
								@:ast(switch (module.def) {
	case EVar(m):
		m + "." + func;	
	default:
		func;	
}) {
									var ` = module.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var m = `;
											{
												m + "." + func;
											};
										};
									} else {
										func;
									};
								};
							} else {
								func;
							};
							if (args.length > 0) {
								var argStrs = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										argStrs.push(reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateArgument(arg));
									};
								};
								callStr += "(" + argStrs.join(", ") + ")";
							} else {
								callStr += "()";
							};
							"<%= " + callStr + " %>";
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(left) + reflaxe.elixir.ast.ElixirASTBuilder.collectTemplateContent(right);
							};
						};
					} else {
						"<%= [unhandled expression] %>";
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							s;
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							"<%= " + name + " %>";
						};
					};
				};
				default: {
					"<%= [unhandled expression] %>";
				}
			};
		};
	}

	static function collectTemplateArgument(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		"\"" + s + "\"";	
	case EVar(name):
		name;	
	case EAtom(a):
		":" + a;	
	case EInteger(i):
		Std.string(i);	
	case EFloat(f):
		Std.string(f);	
	case EBoolean(b):
		b ? "true" : "false";	
	case ENil:
		"nil";	
	case EField(obj, field):
		switch (obj.def) {
			case EVar(v):
				v + "." + field;			
			default:
				"[complex]." + field;			
		};	
	default:
		"[complex arg]";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						var field = `;
						{
							@:ast(switch (obj.def) {
	case EVar(v):
		v + "." + field;	
	default:
		"[complex]." + field;	
}) {
								var ` = obj.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										{
											v + "." + field;
										};
									};
								} else {
									"[complex]." + field;
								};
							};
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							":" + a;
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							"\"" + s + "\"";
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var i = `;
						{
							Std.string(i);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Std.string(f);
						};
					};
				};
				case 35: {
					var ` = `[0];
					{
						var b = `;
						{
							if (b) {
								"true";
							} else {
								"false";
							};
						};
					};
				};
				case 36: {
					{
						"nil";
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name;
						};
					};
				};
				default: {
					"[complex arg]";
				}
			};
		};
	}

	static function isHXXModule(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		moduleName == "HXX";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var m = `;
					{
						var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
						moduleName == "HXX";
					};
				};
			} else {
				false;
			};
		};
	}

	static function isAssertClass(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(TClassDecl(classRef)):
		var classType = classRef.get();
		var pack = classType.pack.join(".");
		var name = classType.name;
		pack == "haxe.test" && name == "Assert";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				if (enumIndex ` == 0) {
					var ` = `[0];
					{
						var classRef = `;
						{
							var classType = classRef.get();
							var pack = classType.pack.join(".");
							var name = classType.name;
							pack == "haxe.test" && name == "Assert";
						};
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	static function isModuleCall(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function isMapAccess(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAnonymous(_):
		true;	
	case TInst(_.get() => ct, _):
		ct.isInterface || ct.name.endsWith("Map");	
	default:
		false;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ct = (_hx_tmp = `.get());
						{
							ct.isInterface || StringTools.endsWith(ct.name, "Map");
						};
					};
				};
			};
			case 5: {
				var ` = t[0];
				{
					true;
				};
			};
			default: {
				false;
			}
		};
	}

	static function getExternNativeModuleNameFromType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(cRef, _):
		var c = cRef.get();
		if (c.isExtern && c.meta.has(":native")) {
			var meta = c.meta.extract(":native");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				switch (meta[0].params[0].expr) {
					case EConst(CString(s, _)):
						s;					
					default:
						null;					
				};
			} else null;
		} else null;	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var cRef = `;
				{
					var c = cRef.get();
					if (c.isExtern && c.meta.has(":native")) {
						var meta = c.meta.extract(":native");
						if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
							@:ast(switch (meta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		null;	
}) {
								var ` = meta[0].params[0].expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (enumIndex ` == 2) {
										var ` = `[0];
										var ` = `[1];
										{
											var s = `;
											{
												s;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					} else {
						null;
					};
				};
			};
		} else {
			null;
		};
	}

	static function moduleTypeToString(m:haxe.macro.ModuleType) {
		var name = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().name;	
	case TEnumDecl(e):
		e.get().name;	
	case TTypeDecl(t):
		t.get().name;	
	case TAbstract(a):
		a.get().name;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().name;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().name;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().name;
					};
				};
			};
		};
		var isExtern = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().isExtern;	
	default:
		false;	
}) if (enumIndex m == 0) {
			var ` = m[0];
			{
				var c = `;
				{
					c.get().isExtern;
				};
			};
		} else {
			false;
		};
		var pack = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().pack;	
	case TEnumDecl(e):
		e.get().pack;	
	case TTypeDecl(t):
		t.get().pack;	
	case TAbstract(a):
		a.get().pack;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().pack;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().pack;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().pack;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().pack;
					};
				};
			};
		};
		if (pack.length > 0) {
			if (StringTools.endsWith(name, "_Impl_") || name.indexOf("_Impl_", null) != -1) {
				return name;
			};
			if (! isExtern) {
				return name;
			};
			@:ast(switch (pack[0]) {
	case "ecto":
		return "Ecto." + name;	
	case "phoenix":
		return "Phoenix." + name;	
	case "plug":
		return "Plug." + name;	
	default:
}) {
				var ` = pack[0];
				switch (`) {
					case "ecto": {
						{
							return "Ecto." + name;
						};
					};
					case "phoenix": {
						{
							return "Phoenix." + name;
						};
					};
					case "plug": {
						{
							return "Plug." + name;
						};
					};
					default: {}
				};
			};
		};
		return name;
	}

	static function countVarOccurrencesInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String) {
		var count = [0];
		var _ = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar(v) if (v == name):
		count++;
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == name) {
							count[0] ++;
							return node;
						} else {
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
		return count[0];
	}

	static function replaceVarInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String, replacement:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar(v) if (v == name):
		return makeAST(EParen(replacement));	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == name) {
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EParen(replacement), metadata : {}, pos : pos};
							};
						} else {
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function typeToElixir(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(_.get() => { name : "String" }, _):
		"binary";	
	case TInst(_.get() => { name : "Array" }, _):
		"list";	
	case TAbstract(_.get() => { name : "Int" }, _):
		"integer";	
	case TAbstract(_.get() => { name : "Float" }, _):
		"float";	
	case TAbstract(_.get() => { name : "Bool" }, _):
		"boolean";	
	case TDynamic(_):
		"any";	
	default:
		"term";	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).constructor;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.fields;
						var ` = _hx_tmp.init;
						var ` = _hx_tmp.interfaces;
						var ` = _hx_tmp.isAbstract;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isFinal;
						var ` = _hx_tmp.isInterface;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.kind;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.overrides;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.statics;
						var ` = _hx_tmp.superClass;
						switch (`) {
							case "Array": {
								{
									"list";
								};
							};
							case "String": {
								{
									"binary";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			case 6: {
				var ` = t[0];
				{
					"any";
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).array;
						var ` = _hx_tmp.binops;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.from;
						var ` = _hx_tmp.impl;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.resolve;
						var ` = _hx_tmp.resolveWrite;
						var ` = _hx_tmp.to;
						var ` = _hx_tmp.type;
						var ` = _hx_tmp.unops;
						switch (`) {
							case "Bool": {
								{
									"boolean";
								};
							};
							case "Float": {
								{
									"float";
								};
							};
							case "Int": {
								{
									"integer";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			default: {
				"term";
			}
		};
	}

	static function isPure(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_) | TTypeExpr(_):
		true;	
	case TBinop(_, e1, e2):
		isPure(e1) && isPure(e2);	
	case TUnop(_, _, e):
		isPure(e);	
	case TField(e, _):
		isPure(e);	
	case TParenthesis(e):
		isPure(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e1) && reflaxe.elixir.ast.ElixirASTBuilder.isPure(e2);
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						true;
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function canBeInlined(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_):
		true;	
	case TBinop(_, e1, e2):
		canBeInlined(e1) && canBeInlined(e2);	
	case TUnop(_, _, e):
		canBeInlined(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e1) && reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e2);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isConstant(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 0) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function hasSideEffects(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TCall(_, _) | TNew(_, _, _) | TVar(_, _):
		true;	
	case TBinop(OpAssign | OpAssignOp(_), _, _):
		true;	
	case TUnop(OpIncrement | OpDecrement, _, _):
		true;	
	case TThrow(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								true;
							};
						};
						case 20: {
							var ` = `[0];
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 23: {
					var ` = `[0];
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isVariableUsedInAST(varName:String, ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		name == varName;	
	case EBlock(exprs):
		for (e  in  exprs) {
			if (isVariableUsedInAST(varName, e)) return true;
		};
		false;	
	case EIf(cond, thenBranch, elseBranch):
		isVariableUsedInAST(varName, cond) || isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && isVariableUsedInAST(varName, elseBranch));	
	case ETuple(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EList(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EBinary(_, left, right):
		isVariableUsedInAST(varName, left) || isVariableUsedInAST(varName, right);	
	case ECall(target, funcName, args):
		if (target != null && isVariableUsedInAST(varName, target)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case ERemoteCall(module, func, args):
		if (isVariableUsedInAST(varName, module)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case EFn(clauses):
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case ECase(expr, clauses):
		if (isVariableUsedInAST(varName, expr)) return true;
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case EAssign(name):
		name == varName;	
	case _:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, expr)) {
								return true;
							};
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, cond) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, elseBranch));
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							if (target != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, target)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, module)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, left) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, right);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, e)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 63: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function detectArrayOperationPattern(body:haxe.macro.TypedExpr) {
		@:ast(switch (body.expr) {
	case TBlock(exprs) if (exprs.length >= 3):
		var hasArrayAccess = false;
		var hasIncrement = false;
		var hasPush = false;
		var isFilter = false;
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, init):
					if (init != null) {
						switch (init.expr) {
							case TArray(_, _):
								hasArrayAccess = true;							
							case _:
						};
					};				
				case TUnop(OpIncrement, _, _) | TUnop(OpDecrement, _, _):
					hasIncrement = true;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
					hasPush = true;				
				case TIf(_, thenExpr, _):
					switch (thenExpr.expr) {
						case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case _:
					};				
				case _:
			};
		};
		if (hasArrayAccess && hasIncrement && hasPush) {
			return isFilter ? "filter" : "map";
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length >= 3) {
						var hasArrayAccess = false;
						var hasIncrement = false;
						var hasPush = false;
						var isFilter = false;
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, init):
		if (init != null) {
			switch (init.expr) {
				case TArray(_, _):
					hasArrayAccess = true;				
				case _:
			};
		};	
	case TUnop(OpIncrement, _, _) | TUnop(OpDecrement, _, _):
		hasIncrement = true;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
		hasPush = true;	
	case TIf(_, thenExpr, _):
		switch (thenExpr.expr) {
			case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case _:
		};	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var args = `;
															if (cf.get().name == "push") {
																hasPush = true;
															} else {};
														};
													} else {};
												} else {};
											};
										};
										case 11: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											switch (enumIndex `) {
												case 0, 1: {
													{
														hasIncrement = true;
													};
												};
												default: {}
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												var init = `;
												{
													if (init != null) {
														@:ast(switch (init.expr) {
	case TArray(_, _):
		hasArrayAccess = true;	
	case _:
}) {
															var ` = init.expr;
															if (enumIndex ` == 2) {
																var ` = `[0];
																var ` = `[1];
																{
																	hasArrayAccess = true;
																};
															} else {};
														};
													};
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var thenExpr = `;
												{
													@:ast(switch (thenExpr.expr) {
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case _:
}) {
														var ` = thenExpr.expr;
														switch (enumIndex `) {
															case 9: {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 4) {
																		var ` = `[0];
																		var ` = `[1];
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			{
																				var cf = `;
																				if (cf.get().name == "push") {
																					hasPush = true;
																					isFilter = true;
																				} else {};
																			};
																		} else {};
																	} else {};
																};
															};
															case 14: {
																var ` = `[0];
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 9) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 4) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var cf = `;
																							if (cf.get().name == "push") {
																								hasPush = true;
																								isFilter = true;
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
															default: {}
														};
													};
												};
											};
										};
										default: {}
									};
								};
							};
						};
						if (hasArrayAccess && hasIncrement && hasPush) {
							return if (isFilter) {
								"filter";
							} else {
								"map";
							};
						};
					} else {};
				};
			} else {};
		};
		return null;
	}

	static function generateIdiomaticEnumCall(arrayRef:haxe.macro.TypedExpr, operation:String, body:haxe.macro.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayRef, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		var lambdaBody = null;
		var itemVar = "v";
		@:ast(switch (body.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, _):
					itemVar = tvar.name;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
					lambdaBody = buildFromTypedExpr(arg, currentContext);				
				case TIf(cond, thenExpr, _) if (operation == "filter"):
					lambdaBody = buildFromTypedExpr(cond, currentContext);				
				case _:
			};
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, _):
		itemVar = tvar.name;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
		lambdaBody = buildFromTypedExpr(arg, currentContext);	
	case TIf(cond, thenExpr, _) if (operation == "filter"):
		lambdaBody = buildFromTypedExpr(cond, currentContext);	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (`.length == 1) {
															var ` = `[0];
															{
																var arg = `;
																var cf = `;
																if (cf.get().name == "push") {
																	lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																} else {};
															};
														} else {};
													} else {};
												} else {};
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												{
													itemVar = tvar.name;
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cond = `;
												var thenExpr = `;
												if (operation == "filter") {
													lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												} else {};
											};
										};
										default: {}
									};
								};
							};
						};
					};
				};
			} else {};
		};
		if (lambdaBody == null) {
			lambdaBody = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(itemVar), metadata : {}, pos : pos};
			};
		};
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(itemVar)], guard : null, body : lambdaBody}]), metadata : {}, pos : pos};
		};
		@:ast(switch (operation) {
	case "map":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
	case "filter":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "filter", [arrayAST, lambda]);	
	default:
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
}) switch (operation) {
			case "filter": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "filter", [arrayAST, lambda]);
				};
			};
			case "map": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "map", [arrayAST, lambda]);
				};
			};
			default: {
				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
				}, "map", [arrayAST, lambda]);
			}
		};
	}

	static function usesVariable(nodes:Array<reflaxe.elixir.ast.ElixirAST>, varName:String) {
		{
			var ` = 0;
			while (` < nodes.length) {
				var node = nodes[`];
				++ `;
				if (reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(node, varName)) {
					return true;
				};
			};
		};
		return false;
	}

	static function usesVariableInNode(node:reflaxe.elixir.ast.ElixirAST, varName:String) {
		return @:ast(switch (node.def) {
	case EVar(name):
		name == varName;	
	case ECall(target, _, args):
		(target != null && usesVariableInNode(target, varName)) || usesVariable(args, varName);	
	case EMatch(_, expr):
		usesVariableInNode(expr, varName);	
	case EBinary(_, left, right):
		usesVariableInNode(left, varName) || usesVariableInNode(right, varName);	
	case _:
		false;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(expr, varName);
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var args = `;
						{
							(target != null && reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(target, varName)) || reflaxe.elixir.ast.ElixirASTBuilder.usesVariable(args, varName);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(left, varName) || reflaxe.elixir.ast.ElixirASTBuilder.usesVariableInNode(right, varName);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function transformVariableReferences(ast:reflaxe.elixir.ast.ElixirAST, varMapping:Map<String, String>) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		if (varMapping.exists(name)) {
			makeAST(EVar(varMapping.get(name)));
		} else {
			ast;
		};	
	case EMatch(pattern, value):
		var transformedValue = transformVariableReferences(value, varMapping);
		var transformedPattern = switch (pattern) {
			case PVar(name) if (varMapping.exists(name)):
				PVar(varMapping.get(name));			
			case PVar(name):
				pattern;			
			case _:
				pattern;			
		};
		makeAST(EMatch(transformedPattern, transformedValue));	
	case EBlock(exprs):
		makeAST(EBlock([for (expr  in  exprs) transformVariableReferences(expr, varMapping)]));	
	case EIf(cond, thenExpr, elseExpr):
		makeAST(EIf(transformVariableReferences(cond, varMapping), transformVariableReferences(thenExpr, varMapping), elseExpr != null ? transformVariableReferences(elseExpr, varMapping) : null));	
	case ECall(fn, name, args):
		makeAST(ECall(fn != null ? transformVariableReferences(fn, varMapping) : null, name, [for (arg  in  args) transformVariableReferences(arg, varMapping)]));	
	case ERemoteCall(module, fn, args):
		makeAST(ERemoteCall(transformVariableReferences(module, varMapping), fn, [for (arg  in  args) transformVariableReferences(arg, varMapping)]));	
	case EField(expr, field):
		makeAST(EField(transformVariableReferences(expr, varMapping), field));	
	case ETuple(items):
		makeAST(ETuple([for (item  in  items) transformVariableReferences(item, varMapping)]));	
	case EList(items):
		makeAST(EList([for (item  in  items) transformVariableReferences(item, varMapping)]));	
	case EMap(items):
		makeAST(EMap([for (item  in  items) { key : transformVariableReferences(item.key, varMapping), value : transformVariableReferences(item.value, varMapping) }]));	
	case EBinary(op, left, right):
		makeAST(EBinary(op, transformVariableReferences(left, varMapping), transformVariableReferences(right, varMapping)));	
	case EUnary(op, expr):
		makeAST(EUnary(op, transformVariableReferences(expr, varMapping)));	
	case EParen(expr):
		makeAST(EParen(transformVariableReferences(expr, varMapping)));	
	case EAccess(target, key):
		makeAST(EAccess(transformVariableReferences(target, varMapping), transformVariableReferences(key, varMapping)));	
	case ECase(expr, clauses):
		makeAST(ECase(transformVariableReferences(expr, varMapping), [for (clause  in  clauses) { pattern : clause.pattern, guard : clause.guard != null ? transformVariableReferences(clause.guard, varMapping) : null, body : transformVariableReferences(clause.body, varMapping) }]));	
	case _:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping), {
									var ` = [];
									{
										var ` = 0;
										while ((` < clauses.length)) {
											var clause = clauses[`];
											++ `;
											`.push({pattern : clause.pattern, guard : if ((clause.guard != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(clause.guard, varMapping) else null, body : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(clause.body, varMapping)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var value = `;
						{
							var transformedValue = reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(value, varMapping);
							var transformedPattern = @:ast(switch (pattern) {
	case PVar(name) if (varMapping.exists(name)):
		PVar(varMapping.get(name));	
	case PVar(name):
		pattern;	
	case _:
		pattern;	
}) if (enumIndex pattern == 0) {
								var ` = pattern[0];
								{
									var name = `;
									if (varMapping.exists(name)) {
										reflaxe.elixir.ast.EPattern.PVar(cast varMapping.get(name));
									} else {
										var name = `;
										{
											pattern;
										};
									};
								};
							} else {
								pattern;
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(transformedPattern, transformedValue), metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenExpr = `;
						var elseExpr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(cond, varMapping), reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(thenExpr, varMapping), if ((elseExpr != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(elseExpr, varMapping) else null);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										while ((` < items.length)) {
											var item = items[`];
											++ `;
											`.push({key : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item.key, varMapping), value : reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(item.value, varMapping)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var fn = `;
						var name = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((fn != null)) reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(fn, varMapping) else null, name, {
									var ` = [];
									{
										var ` = 0;
										while ((` < args.length)) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(arg, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var fn = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(module, varMapping), fn, {
									var ` = [];
									{
										var ` = 0;
										while ((` < args.length)) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(arg, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(left, varMapping), reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(right, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var field = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EField(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping), field);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 29: {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var key = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EAccess(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(target, varMapping), reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(key, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							if (varMapping.exists(name)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(varMapping.get(name));
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							} else {
								ast;
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										while ((` < exprs.length)) {
											var expr = exprs[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTBuilder.transformVariableReferences(expr, varMapping));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					ast;
				}
			};
		};
	}

	static function checkForEarlyReturns(ast:reflaxe.elixir.ast.ElixirAST) {
		return false;
	}

	static function transformReturnsToHalts(body:reflaxe.elixir.ast.ElixirAST, accumulator:reflaxe.elixir.ast.ElixirAST) {
		if (body == null) {
			return null;
		};
		return @:ast(switch (body.def) {
	case EIf(cond, thenBranch, elseBranch):
		makeAST(EIf(cond, wrapWithHaltIfNeeded(thenBranch, accumulator), wrapWithHaltIfNeeded(elseBranch, accumulator)));	
	case EBlock(exprs):
		var transformedExprs = [];
		for (i  in  0 ... exprs.length) {
			if (i == exprs.length - 1) {
				transformedExprs.push(wrapWithHaltIfNeeded(exprs[i], accumulator));
			} else {
				transformedExprs.push(transformReturnsToHalts(exprs[i], accumulator));
			};
		};
		makeAST(EBlock(transformedExprs));	
	case ECase(expr, clauses):
		makeAST(ECase(expr, [for (clause  in  clauses) { pattern : clause.pattern, guard : clause.guard, body : wrapWithHaltIfNeeded(clause.body, accumulator) }]));	
	case _:
		wrapWithHaltIfNeeded(body, accumulator);	
}) {
			var ` = body.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(expr, {
									var ` = [];
									{
										var ` = 0;
										while ((` < clauses.length)) {
											var clause = clauses[`];
											++ `;
											`.push({pattern : clause.pattern, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(clause.body, accumulator)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(cond, reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(thenBranch, accumulator), reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(elseBranch, accumulator));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							var transformedExprs = [];
							{
								var ` = 0;
								var ` = exprs.length;
								while (` < `) {
									var i = ` ++;
									if (i == exprs.length - 1) {
										transformedExprs.push(reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(exprs[i], accumulator));
									} else {
										transformedExprs.push(reflaxe.elixir.ast.ElixirASTBuilder.transformReturnsToHalts(exprs[i], accumulator));
									};
								};
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedExprs), metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTBuilder.wrapWithHaltIfNeeded(body, accumulator);
				}
			};
		};
	}

	static function wrapWithHaltIfNeeded(expr:reflaxe.elixir.ast.ElixirAST, accumulator:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null) {
			return null;
		};
		return @:ast(switch (expr.def) {
	case ETuple([atom, _]):
		switch (atom.def) {
			case EAtom(atomVal) if (atomVal == "cont" || atomVal == "halt"):
				expr;			
			case _:
				makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));			
		};	
	case EBlock([]):
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("cont"))), accumulator]));	
	case _:
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 16: {
					var ` = `[0];
					if (`.length == 2) {
						var ` = `[0];
						var ` = `[1];
						{
							var atom = `;
							{
								@:ast(switch (atom.def) {
	case EAtom(atomVal) if (atomVal == "cont" || atomVal == "halt"):
		expr;	
	case _:
		makeAST(ETuple([makeAST(EAtom(ElixirAtom.raw("halt"))), expr]));	
}) {
									var ` = atom.def;
									if (enumIndex ` == 31) {
										var ` = `[0];
										{
											var atomVal = `;
											if (atomVal == "cont" || atomVal == "halt") {
												expr;
											} else {
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
													}, expr]), metadata : {}, pos : pos};
												};
											};
										};
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
											}, expr]), metadata : {}, pos : pos};
										};
									};
								};
							};
						};
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
							}, expr]), metadata : {}, pos : pos};
						};
					};
				};
				case 53: {
					var ` = `[0];
					if (`.length == 0) {
						{
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "cont"), metadata : {}, pos : pos};
								}, accumulator]), metadata : {}, pos : pos};
							};
						};
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
							}, expr]), metadata : {}, pos : pos};
						};
					};
				};
				default: {
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "halt"), metadata : {}, pos : pos};
						}, expr]), metadata : {}, pos : pos};
					};
				}
			};
		};
	}

	static function unwrapMetaParens(e:haxe.macro.TypedExpr) {
		if (e == null) {
			return null;
		};
		return @:ast(switch (e.expr) {
	case TMeta(_, expr):
		unwrapMetaParens(expr);	
	case TParenthesis(expr):
		unwrapMetaParens(expr);	
	case _:
		e;	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				default: {
					e;
				}
			};
		};
	}

	static function isComprehensionPattern(statements:Array<haxe.macro.TypedExpr>) {
		if (statements.length < 3) {
			return false;
		};
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[0]);
		var tempVarName = null;
		@:ast(switch (firstStmt.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
				return false;			
		};	
	default:
		return false;	
}) {
			var ` = firstStmt.expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var v = `;
					var init = `;
					if (init != null) {
						@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
		return false;	
}) {
							var ` = init.expr;
							if (enumIndex ` == 8) {
								var ` = `[0];
								if (`.length == 0) {
									{
										tempVarName = v.name;
									};
								} else {
									return false;
								};
							} else {
								return false;
							};
						};
					} else {
						return false;
					};
				};
			} else {
				return false;
			};
		};
		var hasLoopWithPush = false;
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TFor(v, iterator, body):
		if (containsPushToVar(body, tempVarName)) {
			hasLoopWithPush = true;
			break;
		};	
	default:
}) {
					var ` = statements[i].expr;
					if (enumIndex ` == 15) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var v = `;
							var iterator = `;
							var body = `;
							{
								if (reflaxe.elixir.ast.ElixirASTBuilder.containsPushToVar(body, tempVarName)) {
									hasLoopWithPush = true;
									break;
								};
							};
						};
					} else {};
				};
			};
		};
		var lastStmt = statements[statements.length - 1];
		var returnsTemp = @:ast(switch (lastStmt.expr) {
	case TLocal(v) if (v.name == tempVarName):
		true;	
	default:
		false;	
}) {
			var ` = lastStmt.expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var v = `;
					if (v.name == tempVarName) {
						true;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
		return hasLoopWithPush && returnsTemp;
	}

	static function isUnrolledComprehension(statements:Array<haxe.macro.TypedExpr>) {
		if (statements.length < 3) {
			return false;
		};
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[0]);
		var tempVarName = null;
		@:ast(switch (firstStmt.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
				return false;			
		};	
	default:
		return false;	
}) {
			var ` = firstStmt.expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var v = `;
					var init = `;
					if (init != null) {
						@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
		return false;	
}) {
							var ` = init.expr;
							if (enumIndex ` == 8) {
								var ` = `[0];
								if (`.length == 0) {
									{
										tempVarName = v.name;
									};
								} else {
									return false;
								};
							} else {
								return false;
							};
						};
					} else {
						return false;
					};
				};
			} else {
				return false;
			};
		};
		var hasConcatenations = false;
		var hasConditionals = false;
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		hasConcatenations = true;	
	case TBinop(OpAdd, { expr : TLocal(v) }, { expr : TArrayDecl([_]) }) if (v.name == tempVarName):
		hasConcatenations = true;	
	case TIf(cond, thenExpr, null):
		switch (thenExpr.expr) {
			case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
				hasConditionals = true;
				hasConcatenations = true;			
			default:
		};	
	default:
}) {
					var ` = statements[i].expr;
					switch (enumIndex `) {
						case 3: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							switch (enumIndex `) {
								case 0: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 8) {
													var ` = `[0];
													if (`.length == 1) {
														var ` = `[0];
														{
															var v = `;
															if (v.name == tempVarName) {
																hasConcatenations = true;
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								};
								case 4: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 3) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													if (enumIndex ` == 0) {
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 8) {
																		var ` = `[0];
																		if (`.length == 1) {
																			var ` = `[0];
																			{
																				var v2 = `;
																				var v = `;
																				if (v.name == tempVarName && v2.name == tempVarName) {
																					hasConcatenations = true;
																				} else {};
																			};
																		} else {};
																	} else {};
																};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								};
								default: {}
							};
						};
						case 16: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (` == null) {
								var thenExpr = `;
								var cond = `;
								{
									@:ast(switch (thenExpr.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([_]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		hasConditionals = true;
		hasConcatenations = true;	
	default:
}) {
										var ` = thenExpr.expr;
										if (enumIndex ` == 3) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 4) {
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 1) {
														var ` = `[0];
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 3) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (enumIndex ` == 0) {
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 8) {
																					var ` = `[0];
																					if (`.length == 1) {
																						var ` = `[0];
																						{
																							var v2 = `;
																							var v = `;
																							if (v.name == tempVarName && v2.name == tempVarName) {
																								hasConditionals = true;
																								hasConcatenations = true;
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															} else {};
														};
													} else {};
												};
											} else {};
										} else {};
									};
								};
							} else {};
						};
						default: {}
					};
				};
			};
		};
		var lastStmt = statements[statements.length - 1];
		var returnsTemp = @:ast(switch (lastStmt.expr) {
	case TLocal(v) if (v.name == tempVarName):
		true;	
	default:
		false;	
}) {
			var ` = lastStmt.expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var v = `;
					if (v.name == tempVarName) {
						true;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
		return hasConcatenations && returnsTemp;
	}

	static function extractComprehensionData(statements:Array<haxe.macro.TypedExpr>) {
		if (statements.length < 3) {
			return null;
		};
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[0]);
		var tempVarName = null;
		@:ast(switch (firstStmt.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
				return null;			
		};	
	default:
		return null;	
}) {
			var ` = firstStmt.expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var v = `;
					var init = `;
					if (init != null) {
						@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
		return null;	
}) {
							var ` = init.expr;
							if (enumIndex ` == 8) {
								var ` = `[0];
								if (`.length == 0) {
									{
										tempVarName = v.name;
									};
								} else {
									return null;
								};
							} else {
								return null;
							};
						};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TFor(v, iterator, body):
		var pushBody = extractPushBody(body, tempVarName);
		if (pushBody != null) {
			var isNested = switch (pushBody.expr) {
				case TArrayDecl([{ expr : TFor(_) }]):
					true;				
				case TBlock(stmts) if (isComprehensionPattern(stmts) || isUnrolledComprehension(stmts)):
					true;				
				default:
					false;				
			};
			return { tempVar : tempVarName, loopVar : v.name, iterator : iterator, body : pushBody, isNested : isNested };
		};	
	default:
}) {
					var ` = statements[i].expr;
					if (enumIndex ` == 15) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var v = `;
							var iterator = `;
							var body = `;
							{
								var pushBody = reflaxe.elixir.ast.ElixirASTBuilder.extractPushBody(body, tempVarName);
								if (pushBody != null) {
									var isNested = @:ast(switch (pushBody.expr) {
	case TArrayDecl([{ expr : TFor(_) }]):
		true;	
	case TBlock(stmts) if (isComprehensionPattern(stmts) || isUnrolledComprehension(stmts)):
		true;	
	default:
		false;	
}) {
										var ` = pushBody.expr;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												if (`.length == 1) {
													var ` = `[0];
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 15) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																true;
															};
														} else {
															false;
														};
													};
												} else {
													false;
												};
											};
											case 14: {
												var ` = `[0];
												{
													var stmts = `;
													if (reflaxe.elixir.ast.ElixirASTBuilder.isComprehensionPattern(stmts) || reflaxe.elixir.ast.ElixirASTBuilder.isUnrolledComprehension(stmts)) {
														true;
													} else {
														false;
													};
												};
											};
											default: {
												false;
											}
										};
									};
									return {tempVar : tempVarName, loopVar : v.name, iterator : iterator, body : pushBody, isNested : isNested};
								};
							};
						};
					} else {};
				};
			};
		};
		return null;
	}

	static function buildIteratorAST(iterator:haxe.macro.TypedExpr, variableUsageMap:Null<Map<Int, Bool>> = null) {
		return @:ast(switch (iterator.expr) {
	case TBinop(OpInterval, e1, e2):
		var start = buildFromTypedExpr(e1, currentContext);
		var end = buildFromTypedExpr(e2, currentContext);
		var adjustedEnd = makeAST(EBinary(Subtract, end, makeAST(EInteger(1))));
		makeAST(ERange(start, adjustedEnd, false));	
	default:
		buildFromTypedExpr(iterator, currentContext);	
}) {
			var ` = iterator.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 21) {
					{
						var e1 = `;
						var e2 = `;
						{
							var start = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var end = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							var adjustedEnd = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, end, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
								}), metadata : {}, pos : pos};
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERange(start, adjustedEnd, false), metadata : {}, pos : pos};
							};
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(iterator, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
				};
			} else {
				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(iterator, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
			};
		};
	}

	static function extractUnrolledElements(statements:Array<haxe.macro.TypedExpr>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		if (statements.length < 3) {
			return null;
		};
		var tempVarName = null;
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(statements[0]);
		@:ast(switch (firstStmt.expr) {
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
				return null;			
		};	
	default:
		return null;	
}) {
			var ` = firstStmt.expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var v = `;
					var init = `;
					if (init != null) {
						@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
		return null;	
}) {
							var ` = init.expr;
							if (enumIndex ` == 8) {
								var ` = `[0];
								if (`.length == 0) {
									{
										tempVarName = v.name;
									};
								} else {
									return null;
								};
							} else {
								return null;
							};
						};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
		var isConditional = false;
		var hasConditions = false;
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TIf(_, thenExpr, null):
		switch (thenExpr.expr) {
			case TBinop(OpAssign, { expr : TLocal(v) }, _) if (v.name == tempVarName):
				hasConditions = true;			
			default:
		};	
	default:
}) {
					var ` = statements[i].expr;
					if (enumIndex ` == 16) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) {
							var thenExpr = `;
							{
								@:ast(switch (thenExpr.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, _) if (v.name == tempVarName):
		hasConditions = true;	
	default:
}) {
									var ` = thenExpr.expr;
									if (enumIndex ` == 3) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 4) {
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 1) {
													var ` = `[0];
													{
														var v = `;
														if (v.name == tempVarName) {
															hasConditions = true;
														} else {};
													};
												} else {};
											};
										} else {};
									} else {};
								};
							};
						} else {};
					} else {};
				};
			};
		};
		if (hasConditions) {
			var result = reflaxe.elixir.ast.ElixirASTBuilder.tryReconstructConditionalComprehension(statements, tempVarName, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
			if (result != null) {
				return [result];
			};
			return null;
		};
		var elements = [];
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (statements[i].expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
				switch (value.expr) {
					case TBlock(stmts):
						var nested = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
						if (nested != null) {
							elements.push(nested);
						} else {
							elements.push(buildFromTypedExpr(value, currentContext));
						};					
					default:
						elements.push(buildFromTypedExpr(value, currentContext));					
				};			
			default:
		};	
	default:
}) {
					var ` = statements[i].expr;
					if (enumIndex ` == 3) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 4) {
							{
								var ` = `.expr;
								var ` = `.pos;
								var ` = `.t;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var v = `;
										var rhs = `;
										if (v.name == tempVarName) {
											@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
		switch (value.expr) {
			case TBlock(stmts):
				var nested = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
				if (nested != null) {
					elements.push(nested);
				} else {
					elements.push(buildFromTypedExpr(value, currentContext));
				};			
			default:
				elements.push(buildFromTypedExpr(value, currentContext));			
		};	
	default:
}) {
												var ` = rhs.expr;
												if (enumIndex ` == 3) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													if (enumIndex ` == 0) {
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 8) {
																		var ` = `[0];
																		if (`.length == 1) {
																			var ` = `[0];
																			{
																				var value = `;
																				var v2 = `;
																				if (v2.name == tempVarName) {
																					@:ast(switch (value.expr) {
	case TBlock(stmts):
		var nested = tryBuildArrayComprehensionFromBlock(stmts, currentContext.variableUsageMap);
		if (nested != null) {
			elements.push(nested);
		} else {
			elements.push(buildFromTypedExpr(value, currentContext));
		};	
	default:
		elements.push(buildFromTypedExpr(value, currentContext));	
}) {
																						var ` = value.expr;
																						if (enumIndex ` == 14) {
																							var ` = `[0];
																							{
																								var stmts = `;
																								{
																									var nested = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap);
																									if (nested != null) {
																										elements.push(nested);
																									} else {
																										elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																									};
																								};
																							};
																						} else {
																							elements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																						};
																					};
																				} else {};
																			};
																		} else {};
																	} else {};
																};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								} else {};
							};
						} else {};
					} else {};
				};
			};
		};
		return if (elements.length > 0) {
			elements;
		} else {
			null;
		};
	}

	static function tryReconstructFromElements(elements:Array<reflaxe.elixir.ast.ElixirAST>) {
		var isSimpleRange = true;
		var maxVal = -1;
		{
			var ` = 0;
			var ` = elements.length;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (elements[i].def) {
	case EInteger(val):
		if (val != i) {
			isSimpleRange = false;
			break;
		};
		maxVal = val;	
	default:
		isSimpleRange = false;
		break;	
}) {
					var ` = elements[i].def;
					if (enumIndex ` == 33) {
						var ` = `[0];
						{
							var val = `;
							{
								if (val != i) {
									isSimpleRange = false;
									break;
								};
								maxVal = val;
							};
						};
					} else {
						isSimpleRange = false;
						break;
					};
				};
			};
		};
		if (isSimpleRange && maxVal >= 0) {
			var range = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(maxVal), metadata : {}, pos : pos};
				}, false), metadata : {}, pos : pos};
			};
			var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("i"), expr : range};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("i"), metadata : {}, pos : pos};
				}, null, false), metadata : {}, pos : pos};
			};
		};
		var allComprehensions = true;
		{
			var ` = 0;
			while (` < elements.length) {
				var elem = elements[`];
				++ `;
				@:ast(switch (elem.def) {
	case EFor(_, _, _, _, _):
	case EList(_):
	default:
		allComprehensions = false;
		break;	
}) {
					var ` = elem.def;
					switch (enumIndex `) {
						case 15: {
							var ` = `[0];
							{};
						};
						case 41: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							var ` = `[3];
							var ` = `[4];
							{};
						};
						default: {
							allComprehensions = false;
							break;
						}
					};
				};
			};
		};
		if (allComprehensions && elements.length > 0) {
			var range = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(elements.length - 1), metadata : {}, pos : pos};
				}, false), metadata : {}, pos : pos};
			};
			var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("i"), expr : range};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], elements[0], null, false), metadata : {}, pos : pos};
			};
		};
		return null;
	}

	static function replaceIndexInCondition(ast:reflaxe.elixir.ast.ElixirAST, index:Int, varName:String) {
		@:ast(switch (ast.def) {
	case EInteger(val) if (val == index):
		return makeAST(EVar(varName));	
	case EBinary(op, left, right):
		return makeAST(EBinary(op, replaceIndexInCondition(left, index, varName), replaceIndexInCondition(right, index, varName)));	
	case ERemoteCall(module, func, args):
		var newArgs = [for (arg  in  args) replaceIndexInCondition(arg, index, varName)];
		return makeAST(ERemoteCall(module, func, newArgs));	
	case EParen(inner):
		return makeAST(EParen(replaceIndexInCondition(inner, index, varName)));	
	default:
		return ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var newArgs = {
								var ` = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTBuilder.replaceIndexInCondition(arg, index, varName));
									};
								};
								`;
							};
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, func, newArgs), metadata : {}, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.replaceIndexInCondition(left, index, varName), reflaxe.elixir.ast.ElixirASTBuilder.replaceIndexInCondition(right, index, varName));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var val = `;
						if (val == index) {
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
							};
						} else {
							return ast;
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTBuilder.replaceIndexInCondition(inner, index, varName));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					return ast;
				}
			};
		};
	}

	static function transformConditionToFilter(condition:haxe.macro.TypedExpr, variableUsageMap:Null<Map<Int, Bool>> = null) {
		var transformExpr = [null];
		transformExpr[0] = function(expr:haxe.macro.TypedExpr, isFirstArgOfMod:Bool = false) {
			@:ast(switch (expr.expr) {
	case TConst(TInt(i)):
		if (isFirstArgOfMod && i >= 0 && i < 10) {
			return makeAST(EVar("i"));
		};
		return makeAST(EInteger(i));	
	case TCall(e, el):
		var isMod = switch (e.expr) {
			case TIdent("__mod__"):
				true;			
			case TField(_, FStatic(_, cf)) if (cf.get().name == "mod"):
				true;			
			default:
				false;			
		};
		var argsAST = [];
		for (i  in  0 ... el.length) {
			argsAST.push(transformExpr(el[i], isMod && i == 0));
		};
		switch (e.expr) {
			case TIdent("__mod__"):
				return makeAST(ERemoteCall(makeAST(EAtom("erlang")), "rem", argsAST));			
			case TField(_, FStatic(_, cf)) if (cf.get().name == "mod"):
				return makeAST(ERemoteCall(makeAST(EAtom("erlang")), "rem", argsAST));			
			case TIdent(name):
				return makeAST(ECall(null, name, argsAST));			
			default:
				return buildFromTypedExpr(expr, currentContext);			
		};	
	case TBinop(OpMod, e1, e2):
		var left = transformExpr(e1, true);
		var right = transformExpr(e2, false);
		return makeAST(ERemoteCall(makeAST(EAtom("erlang")), "rem", [left, right]));	
	case TBinop(op, e1, e2):
		var left = transformExpr(e1, false);
		var right = transformExpr(e2, false);
		var opStr = switch (op) {
			case OpEq:
				"==";			
			case OpNotEq:
				"!=";			
			case OpGt:
				">";			
			case OpGte:
				">=";			
			case OpLt:
				"<";			
			case OpLte:
				"<=";			
			case OpAdd:
				"+";			
			case OpSub:
				"-";			
			case OpMult:
				"*";			
			case OpDiv:
				"/";			
			default:
				Std.string(op);			
		};
		var binOp:EBinaryOp = switch (opStr) {
			case "==":
				Equal;			
			case "!=":
				NotEqual;			
			case ">":
				Greater;			
			case ">=":
				GreaterEqual;			
			case "<":
				Less;			
			case "<=":
				LessEqual;			
			case "+":
				Add;			
			case "-":
				Subtract;			
			case "*":
				Multiply;			
			case "/":
				Divide;			
			default:
				Add;			
		};
		return makeAST(EBinary(binOp, left, right));	
	case TParenthesis(e):
		return transformExpr(e, isFirstArgOfMod);	
	default:
		return buildFromTypedExpr(expr, currentContext);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var i = `;
								{
									if (isFirstArgOfMod && i >= 0 && i < 10) {
										return {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("i"), metadata : {}, pos : pos};
										};
									};
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(i), metadata : {}, pos : pos};
									};
								};
							};
						} else {
							return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 19) {
							{
								var e1 = `;
								var e2 = `;
								{
									var left = transformExpr[0](e1, true);
									var right = transformExpr[0](e2, false);
									return {
										var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase("erlang");
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										}, "rem", [left, right]);
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									};
								};
							};
						} else {
							var op = `;
							var e1 = `;
							var e2 = `;
							{
								var left = transformExpr[0](e1, false);
								var right = transformExpr[0](e2, false);
								var opStr = @:ast(switch (op) {
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpAdd:
		"+";	
	case OpSub:
		"-";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	default:
		Std.string(op);	
}) switch (enumIndex op) {
									case 0: {
										{
											"+";
										};
									};
									case 1: {
										{
											"*";
										};
									};
									case 2: {
										{
											"/";
										};
									};
									case 3: {
										{
											"-";
										};
									};
									case 5: {
										{
											"==";
										};
									};
									case 6: {
										{
											"!=";
										};
									};
									case 7: {
										{
											">";
										};
									};
									case 8: {
										{
											">=";
										};
									};
									case 9: {
										{
											"<";
										};
									};
									case 10: {
										{
											"<=";
										};
									};
									default: {
										Std.string(op);
									}
								};
								var binOp = @:ast(switch (opStr) {
	case "==":
		Equal;	
	case "!=":
		NotEqual;	
	case ">":
		Greater;	
	case ">=":
		GreaterEqual;	
	case "<":
		Less;	
	case "<=":
		LessEqual;	
	case "+":
		Add;	
	case "-":
		Subtract;	
	case "*":
		Multiply;	
	case "/":
		Divide;	
	default:
		Add;	
}) switch (opStr) {
									case "!=": {
										{
											reflaxe.elixir.ast.EBinaryOp.NotEqual;
										};
									};
									case "*": {
										{
											reflaxe.elixir.ast.EBinaryOp.Multiply;
										};
									};
									case "+": {
										{
											reflaxe.elixir.ast.EBinaryOp.Add;
										};
									};
									case "-": {
										{
											reflaxe.elixir.ast.EBinaryOp.Subtract;
										};
									};
									case "/": {
										{
											reflaxe.elixir.ast.EBinaryOp.Divide;
										};
									};
									case "<": {
										{
											reflaxe.elixir.ast.EBinaryOp.Less;
										};
									};
									case "<=": {
										{
											reflaxe.elixir.ast.EBinaryOp.LessEqual;
										};
									};
									case "==": {
										{
											reflaxe.elixir.ast.EBinaryOp.Equal;
										};
									};
									case ">": {
										{
											reflaxe.elixir.ast.EBinaryOp.Greater;
										};
									};
									case ">=": {
										{
											reflaxe.elixir.ast.EBinaryOp.GreaterEqual;
										};
									};
									default: {
										reflaxe.elixir.ast.EBinaryOp.Add;
									}
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(binOp, left, right), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 6: {
						var ` = `[0];
						{
							var e = `;
							{
								return transformExpr[0](e, isFirstArgOfMod);
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var el = `;
							{
								var isMod = @:ast(switch (e.expr) {
	case TIdent("__mod__"):
		true;	
	case TField(_, FStatic(_, cf)) if (cf.get().name == "mod"):
		true;	
	default:
		false;	
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 4: {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 1) {
												var ` = `[0];
												var ` = `[1];
												{
													var cf = `;
													if (cf.get().name == "mod") {
														true;
													} else {
														false;
													};
												};
											} else {
												false;
											};
										};
										case 28: {
											var ` = `[0];
											if (` == "__mod__") {
												{
													true;
												};
											} else {
												false;
											};
										};
										default: {
											false;
										}
									};
								};
								var argsAST = [];
								{
									var ` = 0;
									var ` = el.length;
									while (` < `) {
										var i = ` ++;
										argsAST.push(transformExpr[0](el[i], isMod && i == 0));
									};
								};
								@:ast(switch (e.expr) {
	case TIdent("__mod__"):
		return makeAST(ERemoteCall(makeAST(EAtom("erlang")), "rem", argsAST));	
	case TField(_, FStatic(_, cf)) if (cf.get().name == "mod"):
		return makeAST(ERemoteCall(makeAST(EAtom("erlang")), "rem", argsAST));	
	case TIdent(name):
		return makeAST(ECall(null, name, argsAST));	
	default:
		return buildFromTypedExpr(expr, currentContext);	
}) {
									var ` = e.expr;
									switch (enumIndex `) {
										case 4: {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 1) {
												var ` = `[0];
												var ` = `[1];
												{
													var cf = `;
													if (cf.get().name == "mod") {
														return {
															var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																	var this;
																	this = reflaxe.elixir.ast.NameUtils.toSnakeCase("erlang");
																	cast this;
																});
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															}, "rem", argsAST);
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														};
													} else {
														return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													};
												};
											} else {
												return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											};
										};
										case 28: {
											var ` = `[0];
											if (` == "__mod__") {
												{
													return {
														var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																var this;
																this = reflaxe.elixir.ast.NameUtils.toSnakeCase("erlang");
																cast this;
															});
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}, "rem", argsAST);
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													};
												};
											} else {
												var name = `;
												{
													return {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, name, argsAST), metadata : {}, pos : pos};
													};
												};
											};
										};
										default: {
											return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										}
									};
								};
							};
						};
					};
					default: {
						return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
					}
				};
			};
		};
		var result = transformExpr[0](condition, false);
		return if (result != null) {
			result;
		} else {
			{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("true"), metadata : {}, pos : pos};
			};
		};
	}

	static function tryReconstructConditionalComprehension(statements:Array<haxe.macro.TypedExpr>, tempVarName:String, variableUsageMap:Null<Map<Int, Bool>> = null) {
		var conditions = [];
		var values = [];
		var indices = [];
		if (statements.length >= 3) {
			@:ast(switch (statements[1].expr) {
	case TBlock(innerStmts):
		for (innerStmt  in  innerStmts) {
			switch (innerStmt.expr) {
				case TIf(cond, thenExpr, null):
					switch (thenExpr.expr) {
						case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
							switch (rhs.expr) {
								case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
									conditions.push(cond);
									values.push(value);
									indices.push(conditions.length - 1);								
								default:
							};						
						case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [value]) if (v.name == tempVarName && cf.get().name == "push"):
							conditions.push(cond);
							values.push(value);
							indices.push(conditions.length - 1);						
						default:
					};				
				default:
			};
		};	
	default:
}) {
				var ` = statements[1].expr;
				if (enumIndex ` == 14) {
					var ` = `[0];
					{
						var innerStmts = `;
						{
							{
								var ` = 0;
								while (` < innerStmts.length) {
									var innerStmt = innerStmts[`];
									++ `;
									@:ast(switch (innerStmt.expr) {
	case TIf(cond, thenExpr, null):
		switch (thenExpr.expr) {
			case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
				switch (rhs.expr) {
					case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
						conditions.push(cond);
						values.push(value);
						indices.push(conditions.length - 1);					
					default:
				};			
			case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [value]) if (v.name == tempVarName && cf.get().name == "push"):
				conditions.push(cond);
				values.push(value);
				indices.push(conditions.length - 1);			
			default:
		};	
	default:
}) {
										var ` = innerStmt.expr;
										if (enumIndex ` == 16) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (` == null) {
												var thenExpr = `;
												var cond = `;
												{
													@:ast(switch (thenExpr.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
				conditions.push(cond);
				values.push(value);
				indices.push(conditions.length - 1);			
			default:
		};	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [value]) if (v.name == tempVarName && cf.get().name == "push"):
		conditions.push(cond);
		values.push(value);
		indices.push(conditions.length - 1);	
	default:
}) {
														var ` = thenExpr.expr;
														switch (enumIndex `) {
															case 3: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (enumIndex ` == 4) {
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				var rhs = `;
																				if (v.name == tempVarName) {
																					@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([value]) }) if (v2.name == tempVarName):
		conditions.push(cond);
		values.push(value);
		indices.push(conditions.length - 1);	
	default:
}) {
																						var ` = rhs.expr;
																						if (enumIndex ` == 3) {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							if (enumIndex ` == 0) {
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 8) {
																												var ` = `[0];
																												if (`.length == 1) {
																													var ` = `[0];
																													{
																														var value = `;
																														var v2 = `;
																														if (v2.name == tempVarName) {
																															conditions.push(cond);
																															values.push(value);
																															indices.push(conditions.length - 1);
																														} else {};
																													};
																												} else {};
																											} else {};
																										};
																									} else {};
																								};
																							} else {};
																						} else {};
																					};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
															case 9: {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 4) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var ` = `.expr;
																			var ` = `.pos;
																			var ` = `.t;
																			if (enumIndex ` == 1) {
																				var ` = `[0];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					if (`.length == 1) {
																						var ` = `[0];
																						{
																							var value = `;
																							var v = `;
																							var cf = `;
																							if (v.name == tempVarName && cf.get().name == "push") {
																								conditions.push(cond);
																								values.push(value);
																								indices.push(conditions.length - 1);
																							} else {};
																						};
																					} else {};
																				} else {};
																			} else {};
																		};
																	} else {};
																};
															};
															default: {}
														};
													};
												};
											} else {};
										} else {};
									};
								};
							};
						};
					};
				} else {};
			};
		};
		if (conditions.length == 0) {
			return null;
		};
		var maxIndex = conditions.length - 1;
		var range = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
			}, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(maxIndex), metadata : {}, pos : pos};
			}, false), metadata : {}, pos : pos};
		};
		var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("i"), expr : range};
		var filter = if (conditions.length > 0) {
			var firstCondition = conditions[0];
			var filterExpr = reflaxe.elixir.ast.ElixirASTBuilder.transformConditionToFilter(firstCondition, variableUsageMap);
			filterExpr;
		} else {
			null;
		};
		var body = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("i"), metadata : {}, pos : pos};
		};
		var forExpr = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], if ((filter != null)) [filter] else [], body, null, false), metadata : {}, pos : pos};
		};
		return forExpr;
	}

	static function tryBuildMapLiteralFromBlock(blockStmts:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		if (blockStmts == null || blockStmts.length < 3) {
			return null;
		};
		var tempVar = null;
		var tempInit = null;
		@:ast(switch (blockStmts[0].expr) {
	case TVar(tv, init) if (init != null):
		tempVar = tv;
		tempInit = init;	
	default:
		return null;	
}) {
			var ` = blockStmts[0].expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var tv = `;
					var init = `;
					if (init != null) {
						tempVar = tv;
						tempInit = init;
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
		if (tempVar == null || tempInit == null) {
			return null;
		};
		var isMapCtor = @:ast(switch (tempInit.expr) {
	case TNew(c, _, _):
		var className = c.get().name;
		className == "StringMap" || className == "Map" || className.endsWith("Map");	
	default:
		false;	
}) {
			var ` = tempInit.expr;
			if (enumIndex ` == 10) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var c = `;
					{
						var className = c.get().name;
						className == "StringMap" || className == "Map" || StringTools.endsWith(className, "Map");
					};
				};
			} else {
				false;
			};
		};
		if (! isMapCtor) {
			return null;
		};
		var tempName = tempVar.name;
		var pairs = [];
		{
			var ` = 1;
			var ` = blockStmts.length - 1;
			while (` < `) {
				var i = ` ++;
				var stmt = blockStmts[i];
				@:ast(switch (stmt.expr) {
	case TCall({ expr : TField({ expr : TLocal(local) }, FInstance(_, _, cf)) }, callArgs):
		if (local.name != tempName || cf.get().name != "set" || callArgs.length != 2) {
			return null;
		};
		var keyAst = buildFromTypedExpr(callArgs[0], context);
		var valueAst = buildFromTypedExpr(callArgs[1], context);
		pairs.push({ key : keyAst, value : valueAst });	
	default:
		return null;	
}) {
					var ` = stmt.expr;
					if (enumIndex ` == 9) {
						var ` = `[0];
						var ` = `[1];
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 1) {
										var ` = `[0];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var local = `;
												var callArgs = `;
												{
													if (local.name != tempName || cf.get().name != "set" || callArgs.length != 2) {
														return null;
													};
													var keyAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(callArgs[0], context);
													var valueAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(callArgs[1], context);
													pairs.push({key : keyAst, value : valueAst});
												};
											};
										} else {
											return null;
										};
									} else {
										return null;
									};
								};
							} else {
								return null;
							};
						};
					} else {
						return null;
					};
				};
			};
		};
		@:ast(switch (blockStmts[blockStmts.length - 1].expr) {
	case TLocal(retVar) if (retVar.name == tempName):
		return makeAST(EMap(pairs));	
	default:
		return null;	
}) {
			var ` = blockStmts[blockStmts.length - 1].expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var retVar = `;
					if (retVar.name == tempName) {
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EMap(pairs), metadata : {}, pos : pos};
						};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
	}

	static function containsPushToVar(expr:haxe.macro.TypedExpr, varName:String) {
		return @:ast(switch (expr.expr) {
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, _) if (v.name == varName && cf.get().name == "push"):
		true;	
	case TBlock(el):
		for (e  in  el) {
			if (containsPushToVar(e, varName)) return true;
		};
		false;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.expr;
						var ` = `.pos;
						var ` = `.t;
						if (enumIndex ` == 4) {
							var ` = `[0];
							var ` = `[1];
							{
								var ` = `.expr;
								var ` = `.pos;
								var ` = `.t;
								if (enumIndex ` == 1) {
									var ` = `[0];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cf = `;
											var v = `;
											if (v.name == varName && cf.get().name == "push") {
												true;
											} else {
												false;
											};
										};
									} else {
										false;
									};
								} else {
									false;
								};
							};
						} else {
							false;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsPushToVar(e, varName)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function extractPushBody(expr:haxe.macro.TypedExpr, varName:String) {
		return @:ast(switch (expr.expr) {
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == varName && cf.get().name == "push"):
		arg;	
	case TBlock(el):
		for (e  in  el) {
			var result = extractPushBody(e, varName);
			if (result != null) return result;
		};
		null;	
	default:
		null;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.expr;
						var ` = `.pos;
						var ` = `.t;
						if (enumIndex ` == 4) {
							var ` = `[0];
							var ` = `[1];
							{
								var ` = `.expr;
								var ` = `.pos;
								var ` = `.t;
								if (enumIndex ` == 1) {
									var ` = `[0];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (`.length == 1) {
											var ` = `[0];
											{
												var arg = `;
												var v = `;
												var cf = `;
												if (v.name == varName && cf.get().name == "push") {
													arg;
												} else {
													null;
												};
											};
										} else {
											null;
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									var result = reflaxe.elixir.ast.ElixirASTBuilder.extractPushBody(e, varName);
									if (result != null) {
										return result;
									};
								};
							};
							null;
						};
					};
				};
				default: {
					null;
				}
			};
		};
	}

	static function tryBuildArrayComprehensionFromBlock(statements:Array<haxe.macro.TypedExpr>, variableUsageMap:Null<Map<Int, Bool>> = null) {
		if (statements.length < 2) {
			return null;
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.isComprehensionPattern(statements)) {
			var data = reflaxe.elixir.ast.ElixirASTBuilder.extractComprehensionData(statements);
			if (data != null) {
				var iteratorAst = reflaxe.elixir.ast.ElixirASTBuilder.buildIteratorAST(data.iterator, variableUsageMap);
				var pattern = reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(data.loopVar, null));
				var generator = {pattern : pattern, expr : iteratorAst};
				var bodyAst = if (data.isNested) {
					@:ast(switch (data.body.expr) {
	case TArrayDecl([elem]):
		switch (elem.expr) {
			case TFor(_):
				buildFromTypedExpr(elem, currentContext);			
			default:
				buildFromTypedExpr(data.body, currentContext);			
		};	
	case TBlock(stmts):
		var nested = tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
		if (nested != null) nested else buildFromTypedExpr(data.body, currentContext);	
	default:
		buildFromTypedExpr(data.body, currentContext);	
}) {
						var ` = data.body.expr;
						switch (enumIndex `) {
							case 8: {
								var ` = `[0];
								if (`.length == 1) {
									var ` = `[0];
									{
										var elem = `;
										{
											@:ast(switch (elem.expr) {
	case TFor(_):
		buildFromTypedExpr(elem, currentContext);	
	default:
		buildFromTypedExpr(data.body, currentContext);	
}) {
												var ` = elem.expr;
												if (enumIndex ` == 15) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(elem, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													};
												} else {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(data.body, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												};
											};
										};
									};
								} else {
									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(data.body, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								};
							};
							case 14: {
								var ` = `[0];
								{
									var stmts = `;
									{
										var nested = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildArrayComprehensionFromBlock(stmts, variableUsageMap);
										if (nested != null) {
											nested;
										} else {
											reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(data.body, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										};
									};
								};
							};
							default: {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(data.body, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							}
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(data.body, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
				};
				return {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], bodyAst, null, false), metadata : {}, pos : pos};
				};
			};
		} else {
			if (reflaxe.elixir.ast.ElixirASTBuilder.isUnrolledComprehension(statements)) {
				var elements = reflaxe.elixir.ast.ElixirASTBuilder.extractUnrolledElements(statements, variableUsageMap);
				if (elements != null && elements.length > 0) {
					var comprehension = reflaxe.elixir.ast.ElixirASTBuilder.tryReconstructFromElements(elements);
					if (comprehension != null) {
						return comprehension;
					} else {
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EList(elements), metadata : {}, pos : pos};
						};
					};
				};
			};
		};
		return null;
	}

	static function looksLikeListBuildingBlock(stmts:Array<haxe.macro.TypedExpr>) {
		if (stmts.length < 2) {
			return false;
		};
		var firstStmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[0]);
		var tempVarName = null;
		@:ast(switch (firstStmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TArrayDecl([]) }):
		tempVarName = v.name;	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TArrayDecl([]):
				tempVarName = v.name;			
			default:
		};	
	default:
		return false;	
}) {
			var ` = firstStmt.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 4) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 8) {
										var ` = `[0];
										if (`.length == 0) {
											{
												var v = `;
												{
													tempVarName = v.name;
												};
											};
										} else {
											return false;
										};
									} else {
										return false;
									};
								};
							} else {
								return false;
							};
						};
					} else {
						return false;
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							@:ast(switch (init.expr) {
	case TArrayDecl([]):
		tempVarName = v.name;	
	default:
}) {
								var ` = init.expr;
								if (enumIndex ` == 8) {
									var ` = `[0];
									if (`.length == 0) {
										{
											tempVarName = v.name;
										};
									} else {};
								} else {};
							};
						} else {
							return false;
						};
					};
				};
				default: {
					return false;
				}
			};
		};
		{
			var ` = 1;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				var stmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[i]);
				if (i == stmts.length - 1) {
					@:ast(switch (stmt.expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		return false;	
}) {
						var ` = stmt.expr;
						if (enumIndex ` == 1) {
							var ` = `[0];
							{
								var v = `;
								if (v.name == tempVarName) {} else {
									return false;
								};
							};
						} else {
							return false;
						};
					};
				} else {
					@:ast(switch (stmt.expr) {
	case TBinop(OpAdd, { expr : TLocal(v) }, { expr : TArrayDecl(_) }) if (v.name == tempVarName):
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl(_) }) if (v2.name == tempVarName):
			case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TBlock(_) }) if (v2.name == tempVarName):
			default:
				return false;			
		};	
	default:
		return false;	
}) {
						var ` = stmt.expr;
						if (enumIndex ` == 3) {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							switch (enumIndex `) {
								case 0: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 8) {
													var ` = `[0];
													{
														var v = `;
														if (v.name == tempVarName) {} else {
															return false;
														};
													};
												} else {
													return false;
												};
											};
										} else {
											return false;
										};
									};
								};
								case 4: {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												var rhs = `;
												if (v.name == tempVarName) {
													@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl(_) }) if (v2.name == tempVarName):
	case TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TBlock(_) }) if (v2.name == tempVarName):
	default:
		return false;	
}) {
														var ` = rhs.expr;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 0) {
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var ` = `.expr;
																			var ` = `.pos;
																			var ` = `.t;
																			switch (enumIndex `) {
																				case 8: {
																					var ` = `[0];
																					{
																						var v2 = `;
																						if (v2.name == tempVarName) {} else {
																							return false;
																						};
																					};
																				};
																				case 14: {
																					var ` = `[0];
																					{
																						var v2 = `;
																						if (v2.name == tempVarName) {} else {
																							return false;
																						};
																					};
																				};
																				default: {
																					return false;
																				}
																			};
																		};
																	} else {
																		return false;
																	};
																};
															} else {
																return false;
															};
														} else {
															return false;
														};
													};
												} else {
													return false;
												};
											};
										} else {
											return false;
										};
									};
								};
								default: {
									return false;
								}
							};
						} else {
							return false;
						};
					};
				};
			};
		};
		return true;
	}

	static function isEnumParameterUsedAtIndex(index:Int, caseBody:haxe.macro.TypedExpr) {
		var isUsed = [false];
		var checkUsage = [null];
		checkUsage[0] = function(expr:haxe.macro.TypedExpr) {
			if (isUsed[0]) {
				return;
			};
			@:ast(switch (expr.expr) {
	case TEnumParameter(_, _, paramIndex) if (paramIndex == index):
		isUsed = true;	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, paramIndex) if (paramIndex == index):
				var assignedVar = toElixirVarName(v.name);
				isUsed = isPatternVariableUsed(assignedVar, caseBody);			
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, checkUsage);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TEnumParameter(_, _, paramIndex) if (paramIndex == index):
		var assignedVar = toElixirVarName(v.name);
		isUsed = isPatternVariableUsed(assignedVar, caseBody);	
	default:
}) {
									var ` = init.expr;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var paramIndex = `;
											if (paramIndex == index) {
												var assignedVar = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
												isUsed[0] = reflaxe.elixir.ast.ElixirASTBuilder.isPatternVariableUsed(assignedVar, caseBody);
											} else {};
										};
									} else {};
								};
							} else {
								haxe.macro.TypedExprTools.iter(expr, checkUsage[0]);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var paramIndex = `;
							if (paramIndex == index) {
								isUsed[0] = true;
							} else {
								haxe.macro.TypedExprTools.iter(expr, checkUsage[0]);
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, checkUsage[0]);
					}
				};
			};
		};
		checkUsage[0](caseBody);
		return isUsed[0];
	}

	static function isPatternVariableUsed(varName:String, caseBody:haxe.macro.TypedExpr) {
		var aliasMap = {
			{};
			new haxe.ds.StringMap();
		};
		var tempsByIndex = {
			{};
			new haxe.ds.IntMap();
		};
		var isUsed = [false];
		var collectAliases = [null];
		collectAliases[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TVar(v, init) if (init != null):
		var vName = toElixirVarName(v.name);
		switch (init.expr) {
			case TEnumParameter(_, _, index):
				tempsByIndex.set(index, vName);
				if (!aliasMap.exists(vName)) {
					aliasMap.set(vName, [vName]);
				};			
			case TLocal(sourceVar):
				var sourceName = toElixirVarName(sourceVar.name);
				if (aliasMap.exists(sourceName)) {
					var aliases = aliasMap.get(sourceName);
					if (aliases.indexOf(vName) == -1) {
						aliases.push(vName);
					};
					aliasMap.set(vName, aliases);
				} else {
					var aliases = [sourceName, vName];
					aliasMap.set(sourceName, aliases);
					aliasMap.set(vName, aliases);
				};			
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, collectAliases);	
}) {
				var ` = expr.expr;
				if (enumIndex ` == 13) {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						if (init != null) {
							var vName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
							@:ast(switch (init.expr) {
	case TEnumParameter(_, _, index):
		tempsByIndex.set(index, vName);
		if (!aliasMap.exists(vName)) {
			aliasMap.set(vName, [vName]);
		};	
	case TLocal(sourceVar):
		var sourceName = toElixirVarName(sourceVar.name);
		if (aliasMap.exists(sourceName)) {
			var aliases = aliasMap.get(sourceName);
			if (aliases.indexOf(vName) == -1) {
				aliases.push(vName);
			};
			aliasMap.set(vName, aliases);
		} else {
			var aliases = [sourceName, vName];
			aliasMap.set(sourceName, aliases);
			aliasMap.set(vName, aliases);
		};	
	default:
}) {
								var ` = init.expr;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										{
											var sourceVar = `;
											{
												var sourceName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(sourceVar.name, null);
												if (aliasMap.exists(sourceName)) {
													var aliases = cast aliasMap.get(sourceName);
													if (aliases.indexOf(vName, null) == -1) {
														aliases.push(vName);
													};
													{
														aliasMap.set(vName, aliases);
													};
												} else {
													var aliases = [sourceName, vName];
													{
														aliasMap.set(sourceName, aliases);
													};
													{
														aliasMap.set(vName, aliases);
													};
												};
											};
										};
									};
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var index = `;
											{
												{
													tempsByIndex.set(index, vName);
												};
												if (! aliasMap.exists(vName)) {
													{
														aliasMap.set(vName, [vName]);
													};
												};
											};
										};
									};
									default: {}
								};
							};
						} else {
							haxe.macro.TypedExprTools.iter(expr, collectAliases[0]);
						};
					};
				} else {
					haxe.macro.TypedExprTools.iter(expr, collectAliases[0]);
				};
			};
		};
		if (caseBody != null) {
			collectAliases[0](caseBody);
		};
		var aliasesToCheck = [[varName]];
		if (aliasMap.exists(varName)) {
			aliasesToCheck[0] = cast aliasMap.get(varName).copy();
		};
		if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
			for (alias in aliasMap.keys()) {
				var aliases = cast aliasMap.get(alias);
				if (aliases.indexOf(varName, null) != -1 && aliasesToCheck[0].indexOf(alias, null) == -1) {
					aliasesToCheck[0].push(alias);
				};
			};
		} else {
			for (tempName in tempsByIndex.iterator()) {
				if (aliasMap.exists(tempName)) {
					var aliases = cast aliasMap.get(tempName);
					if (aliases.indexOf(varName, null) != -1) {
						{
							var ` = 0;
							while (` < aliases.length) {
								var a = aliases[`];
								++ `;
								if (aliasesToCheck[0].indexOf(a, null) == -1) {
									aliasesToCheck[0].push(a);
								};
							};
						};
					};
				};
			};
		};
		var checkUsage = [null];
		checkUsage[0] = function(expr:haxe.macro.TypedExpr) {
			if (isUsed[0]) {
				return;
			};
			@:ast(switch (expr.expr) {
	case TLocal(v):
		var vName = toElixirVarName(v.name);
		if (aliasesToCheck.indexOf(vName) != -1) {
			isUsed = true;
		};	
	case TVar(v, _):
	default:
		haxe.macro.TypedExprTools.iter(expr, checkUsage);	
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						{
							var v = `;
							{
								var vName = reflaxe.elixir.ast.ElixirASTBuilder.toElixirVarName(v.name, null);
								if (aliasesToCheck[0].indexOf(vName, null) != -1) {
									isUsed[0] = true;
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							{};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(expr, checkUsage[0]);
					}
				};
			};
		};
		if (caseBody != null) {
			checkUsage[0](caseBody);
		};
		return isUsed[0];
	}

	static function isPatternVariableUsedById(varId:Int, caseBody:haxe.macro.TypedExpr, varOriginMap:Null<Map<Int, reflaxe.elixir.ast.VarOrigin>> = null) {
		var usedVarIds = {
			{};
			new haxe.ds.IntMap();
		};
		var collectUsedVarIds = [null];
		collectUsedVarIds[0] = function(expr:haxe.macro.TypedExpr) {
			@:ast(switch (expr.expr) {
	case TLocal(v):
		usedVarIds.set(v.id, true);	
	case TVar(v, _):
	default:
}) {
				var ` = expr.expr;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						{
							var v = `;
							{
								{
									var key = v.id;
									usedVarIds.set(key, true);
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							{};
						};
					};
					default: {}
				};
			};
			haxe.macro.TypedExprTools.iter(expr, collectUsedVarIds[0]);
		};
		if (caseBody != null) {
			collectUsedVarIds[0](caseBody);
		};
		return usedVarIds.exists(varId);
	}

	static function updateMappingForUnderscorePrefixes(pattern:reflaxe.elixir.ast.EPattern, originalMapping:Map<Int, String>, extractedParams:Array<String>) {
		var needsUpdate = [false];
		var newMapping = {
			{};
			new haxe.ds.IntMap();
		};
		{
			var ` = cast new haxe.iterators.MapKeyValueIterator(originalMapping);
			while (`.hasNext()) {
				var ` = `.next();
				var id = `.key;
				var name = `.value;
				{
					{
						newMapping.set(id, name);
					};
				};
			};
		};
		var checkPattern = [null];
		checkPattern[0] = function(p:reflaxe.elixir.ast.EPattern, index:Int = 0) {
			@:ast(switch (p) {
	case PTuple(patterns):
		for (i  in  0 ... patterns.length) {
			checkPattern(patterns[i], i);
		};	
	case PVar(name) if (name.startsWith("_") && name.length > 1):
		var originalName = name.substring(1);
		for (id => mappedName  in  originalMapping) {
			if (mappedName == originalName) {
				newMapping.set(id, name);
				needsUpdate = true;
			};
		};	
	default:
}) switch (enumIndex p) {
				case 0: {
					var ` = p[0];
					{
						var name = `;
						if (StringTools.startsWith(name, "_") && name.length > 1) {
							var originalName = name.substring(1, null);
							{
								var ` = cast new haxe.iterators.MapKeyValueIterator(originalMapping);
								while (`.hasNext()) {
									var ` = `.next();
									var id = `.key;
									var mappedName = `.value;
									{
										if (mappedName == originalName) {
											{
												newMapping.set(id, name);
											};
											needsUpdate[0] = true;
										};
									};
								};
							};
						} else {};
					};
				};
				case 2: {
					var ` = p[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								var ` = patterns.length;
								while (` < `) {
									var i = ` ++;
									checkPattern[0](patterns[i], i);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		checkPattern[0](pattern, null);
		return if (needsUpdate[0]) {
			newMapping;
		} else {
			originalMapping;
		};
	}

	static function applyUnderscorePrefixToUnusedPatternVars(pattern:reflaxe.elixir.ast.EPattern, variableUsageMap:Map<Int, Bool>, extractedParams:Array<String>) {
		return @:ast(switch (pattern) {
	case PTuple(patterns):
		var updatedPatterns = [];
		for (i  in  0 ... patterns.length) {
			var p = patterns[i];
			switch (p) {
				case PVar(name):
					var isUsed = false;
					if (i > 0 && extractedParams != null && i - 1 < extractedParams.length) {
						var expectedParamName = extractedParams[i - 1];
						if (expectedParamName == name) {
							if (name == "g" || (name.length > 1 && name.charAt(0) == "g" && name.charAt(1) >= "0" && name.charAt(1) <= "9")) {
								isUsed = false;
							} else {
								isUsed = true;
							};
						};
					};
					if (!isUsed && !name.startsWith("_")) {
						updatedPatterns.push(PVar(name));
					} else {
						updatedPatterns.push(p);
					};				
				default:
					updatedPatterns.push(applyUnderscorePrefixToUnusedPatternVars(p, variableUsageMap, extractedParams));				
			};
		};
		PTuple(updatedPatterns);	
	case PVar(name):
		PVar(name);	
	case PLiteral(_) | PWildcard:
		pattern;	
	case PList(elements):
		PList([for (e  in  elements) applyUnderscorePrefixToUnusedPatternVars(e, variableUsageMap, extractedParams)]);	
	case PCons(head, tail):
		PCons(applyUnderscorePrefixToUnusedPatternVars(head, variableUsageMap, extractedParams), applyUnderscorePrefixToUnusedPatternVars(tail, variableUsageMap, extractedParams));	
	case PMap(pairs):
		PMap([for (pair  in  pairs) { key : pair.key, value : applyUnderscorePrefixToUnusedPatternVars(pair.value, variableUsageMap, extractedParams) }]);	
	case PStruct(module, fields):
		PStruct(module, [for (f  in  fields) { key : f.key, value : applyUnderscorePrefixToUnusedPatternVars(f.value, variableUsageMap, extractedParams) }]);	
	case PPin(subPattern):
		PPin(applyUnderscorePrefixToUnusedPatternVars(subPattern, variableUsageMap, extractedParams));	
	case PAlias(varName, subPattern):
		var isUsed = false;
		for (param  in  extractedParams) {
			if (param == varName) {
				isUsed = true;
				break;
			};
		};
		var newVarName = varName;
		PAlias(newVarName, applyUnderscorePrefixToUnusedPatternVars(subPattern, variableUsageMap, extractedParams));	
	case PBinary(segments):
		PBinary([for (s  in  segments) { pattern : applyUnderscorePrefixToUnusedPatternVars(s.pattern, variableUsageMap, extractedParams), size : s.size, type : s.type, modifiers : s.modifiers }]);	
}) switch (@:exhaustive enumIndex pattern) {
			case 0: {
				var ` = pattern[0];
				{
					var name = `;
					{
						reflaxe.elixir.ast.EPattern.PVar(name);
					};
				};
			};
			case 1: {
				var ` = pattern[0];
				{
					pattern;
				};
			};
			case 2: {
				var ` = pattern[0];
				{
					var patterns = `;
					{
						var updatedPatterns = [];
						{
							var ` = 0;
							var ` = patterns.length;
							while (` < `) {
								var i = ` ++;
								var p = patterns[i];
								@:ast(switch (p) {
	case PVar(name):
		var isUsed = false;
		if (i > 0 && extractedParams != null && i - 1 < extractedParams.length) {
			var expectedParamName = extractedParams[i - 1];
			if (expectedParamName == name) {
				if (name == "g" || (name.length > 1 && name.charAt(0) == "g" && name.charAt(1) >= "0" && name.charAt(1) <= "9")) {
					isUsed = false;
				} else {
					isUsed = true;
				};
			};
		};
		if (!isUsed && !name.startsWith("_")) {
			updatedPatterns.push(PVar(name));
		} else {
			updatedPatterns.push(p);
		};	
	default:
		updatedPatterns.push(applyUnderscorePrefixToUnusedPatternVars(p, variableUsageMap, extractedParams));	
}) if (enumIndex p == 0) {
									var ` = p[0];
									{
										var name = `;
										{
											var isUsed = false;
											if (i > 0 && extractedParams != null && i - 1 < extractedParams.length) {
												var expectedParamName = extractedParams[i - 1];
												if (expectedParamName == name) {
													if (name == "g" || (name.length > 1 && name.charAt(0) == "g" && name.charAt(1) >= "0" && name.charAt(1) <= "9")) {
														isUsed = false;
													} else {
														isUsed = true;
													};
												};
											};
											if (! isUsed && ! StringTools.startsWith(name, "_")) {
												updatedPatterns.push(reflaxe.elixir.ast.EPattern.PVar(name));
											} else {
												updatedPatterns.push(p);
											};
										};
									};
								} else {
									updatedPatterns.push(reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(p, variableUsageMap, extractedParams));
								};
							};
						};
						reflaxe.elixir.ast.EPattern.PTuple(updatedPatterns);
					};
				};
			};
			case 3: {
				var ` = pattern[0];
				{
					var elements = `;
					{
						reflaxe.elixir.ast.EPattern.PList({
							var ` = [];
							{
								var ` = 0;
								while (` < elements.length) {
									var e = elements[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(e, variableUsageMap, extractedParams));
								};
							};
							`;
						});
					};
				};
			};
			case 4: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var head = `;
					var tail = `;
					{
						reflaxe.elixir.ast.EPattern.PCons(reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(head, variableUsageMap, extractedParams), reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(tail, variableUsageMap, extractedParams));
					};
				};
			};
			case 5: {
				var ` = pattern[0];
				{
					var pairs = `;
					{
						reflaxe.elixir.ast.EPattern.PMap({
							var ` = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									`.push({key : pair.key, value : reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(pair.value, variableUsageMap, extractedParams)});
								};
							};
							`;
						});
					};
				};
			};
			case 6: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var module = `;
					var fields = `;
					{
						reflaxe.elixir.ast.EPattern.PStruct(module, {
							var ` = [];
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									`.push({key : f.key, value : reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(f.value, variableUsageMap, extractedParams)});
								};
							};
							`;
						});
					};
				};
			};
			case 7: {
				var ` = pattern[0];
				{
					var subPattern = `;
					{
						reflaxe.elixir.ast.EPattern.PPin(reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(subPattern, variableUsageMap, extractedParams));
					};
				};
			};
			case 8: {
				{
					pattern;
				};
			};
			case 9: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var varName = `;
					var subPattern = `;
					{
						var isUsed = false;
						{
							var ` = 0;
							while (` < extractedParams.length) {
								var param = extractedParams[`];
								++ `;
								if (param == varName) {
									isUsed = true;
									break;
								};
							};
						};
						var newVarName = varName;
						reflaxe.elixir.ast.EPattern.PAlias(newVarName, reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(subPattern, variableUsageMap, extractedParams));
					};
				};
			};
			case 10: {
				var ` = pattern[0];
				{
					var segments = `;
					{
						reflaxe.elixir.ast.EPattern.PBinary({
							var ` = [];
							{
								var ` = 0;
								while (` < segments.length) {
									var s = segments[`];
									++ `;
									`.push({pattern : reflaxe.elixir.ast.ElixirASTBuilder.applyUnderscorePrefixToUnusedPatternVars(s.pattern, variableUsageMap, extractedParams), size : s.size, type : s.type, modifiers : s.modifiers});
								};
							};
							`;
						});
					};
				};
			};
		};
	}

	static function extractListElements(stmts:Array<haxe.macro.TypedExpr>) {
		if (! reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(stmts)) {
			return null;
		};
		var elements = [];
		{
			var ` = 1;
			var ` = stmts.length - 1;
			while (` < `) {
				var i = ` ++;
				var stmt = reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(stmts[i]);
				@:ast(switch (stmt.expr) {
	case TBinop(OpAdd, { expr : TLocal(v) }, { expr : TArrayDecl([value]) }):
		switch (value.expr) {
			case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
				var nestedElements = extractListElements(innerStmts);
				if (nestedElements != null && nestedElements.length > 0) {
					var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
					elements.push(listExpr);
				} else {
					elements.push(value);
				};			
			default:
				elements.push(value);			
		};	
	case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
		if (looksLikeListBuildingBlock(blockStmts)) {
			var nestedElements = extractListElements(blockStmts);
			if (nestedElements != null && nestedElements.length > 0) {
				var listExpr = { expr : TArrayDecl(nestedElements), pos : stmt.pos, t : stmt.t };
				elements.push(listExpr);
			} else {
				elements.push({ expr : TBlock(blockStmts), pos : stmt.pos, t : stmt.t });
			};
		} else {
			elements.push({ expr : TBlock(blockStmts), pos : stmt.pos, t : stmt.t });
		};	
	case TBinop(OpAssign, _, rhs):
		switch (rhs.expr) {
			case TBinop(OpAdd, _, { expr : TArrayDecl([value]) }):
				switch (value.expr) {
					case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
						var nestedElements = extractListElements(innerStmts);
						if (nestedElements != null && nestedElements.length > 0) {
							var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
							elements.push(listExpr);
						} else {
							elements.push(value);
						};					
					default:
						elements.push(value);					
				};			
			case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
				if (looksLikeListBuildingBlock(blockStmts)) {
					var nestedElements = extractListElements(blockStmts);
					if (nestedElements != null && nestedElements.length > 0) {
						var listExpr = { expr : TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t };
						elements.push(listExpr);
					} else {
						elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
					};
				} else {
					elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
				};			
			default:
		};	
	default:
}) {
					var ` = stmt.expr;
					if (enumIndex ` == 3) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						switch (enumIndex `) {
							case 0: {
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var ` = `.expr;
											var ` = `.pos;
											var ` = `.t;
											switch (enumIndex `) {
												case 8: {
													var ` = `[0];
													if (`.length == 1) {
														var ` = `[0];
														{
															var value = `;
															var v = `;
															{
																@:ast(switch (value.expr) {
	case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
		var nestedElements = extractListElements(innerStmts);
		if (nestedElements != null && nestedElements.length > 0) {
			var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
			elements.push(listExpr);
		} else {
			elements.push(value);
		};	
	default:
		elements.push(value);	
}) {
																	var ` = value.expr;
																	if (enumIndex ` == 14) {
																		var ` = `[0];
																		{
																			var innerStmts = `;
																			if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(innerStmts)) {
																				var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(innerStmts);
																				if (nestedElements != null && nestedElements.length > 0) {
																					var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : value.pos, t : value.t};
																					elements.push(listExpr);
																				} else {
																					elements.push(value);
																				};
																			} else {
																				elements.push(value);
																			};
																		};
																	} else {
																		elements.push(value);
																	};
																};
															};
														};
													} else {};
												};
												case 14: {
													var ` = `[0];
													{
														var blockStmts = `;
														{
															if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(blockStmts)) {
																var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(blockStmts);
																if (nestedElements != null && nestedElements.length > 0) {
																	var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : stmt.pos, t : stmt.t};
																	elements.push(listExpr);
																} else {
																	elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
																};
															} else {
																elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
															};
														};
													};
												};
												default: {}
											};
										};
									} else {
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 14) {
											var ` = `[0];
											{
												var blockStmts = `;
												{
													if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(blockStmts)) {
														var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(blockStmts);
														if (nestedElements != null && nestedElements.length > 0) {
															var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : stmt.pos, t : stmt.t};
															elements.push(listExpr);
														} else {
															elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
														};
													} else {
														elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : stmt.pos, t : stmt.t});
													};
												};
											};
										} else {};
									};
								};
							};
							case 4: {
								{
									var rhs = `;
									{
										@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, _, { expr : TArrayDecl([value]) }):
		switch (value.expr) {
			case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
				var nestedElements = extractListElements(innerStmts);
				if (nestedElements != null && nestedElements.length > 0) {
					var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
					elements.push(listExpr);
				} else {
					elements.push(value);
				};			
			default:
				elements.push(value);			
		};	
	case TBinop(OpAdd, _, { expr : TBlock(blockStmts) }):
		if (looksLikeListBuildingBlock(blockStmts)) {
			var nestedElements = extractListElements(blockStmts);
			if (nestedElements != null && nestedElements.length > 0) {
				var listExpr = { expr : TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t };
				elements.push(listExpr);
			} else {
				elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
			};
		} else {
			elements.push({ expr : TBlock(blockStmts), pos : rhs.pos, t : rhs.t });
		};	
	default:
}) {
											var ` = rhs.expr;
											if (enumIndex ` == 3) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 0) {
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														switch (enumIndex `) {
															case 8: {
																var ` = `[0];
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var value = `;
																		{
																			@:ast(switch (value.expr) {
	case TBlock(innerStmts) if (looksLikeListBuildingBlock(innerStmts)):
		var nestedElements = extractListElements(innerStmts);
		if (nestedElements != null && nestedElements.length > 0) {
			var listExpr = { expr : TArrayDecl(nestedElements), pos : value.pos, t : value.t };
			elements.push(listExpr);
		} else {
			elements.push(value);
		};	
	default:
		elements.push(value);	
}) {
																				var ` = value.expr;
																				if (enumIndex ` == 14) {
																					var ` = `[0];
																					{
																						var innerStmts = `;
																						if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(innerStmts)) {
																							var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(innerStmts);
																							if (nestedElements != null && nestedElements.length > 0) {
																								var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : value.pos, t : value.t};
																								elements.push(listExpr);
																							} else {
																								elements.push(value);
																							};
																						} else {
																							elements.push(value);
																						};
																					};
																				} else {
																					elements.push(value);
																				};
																			};
																		};
																	};
																} else {};
															};
															case 14: {
																var ` = `[0];
																{
																	var blockStmts = `;
																	{
																		if (reflaxe.elixir.ast.ElixirASTBuilder.looksLikeListBuildingBlock(blockStmts)) {
																			var nestedElements = reflaxe.elixir.ast.ElixirASTBuilder.extractListElements(blockStmts);
																			if (nestedElements != null && nestedElements.length > 0) {
																				var listExpr = {expr : haxe.macro.TypedExprDef.TArrayDecl(nestedElements), pos : rhs.pos, t : rhs.t};
																				elements.push(listExpr);
																			} else {
																				elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : rhs.pos, t : rhs.t});
																			};
																		} else {
																			elements.push({expr : haxe.macro.TypedExprDef.TBlock(blockStmts), pos : rhs.pos, t : rhs.t});
																		};
																	};
																};
															};
															default: {}
														};
													};
												} else {};
											} else {};
										};
									};
								};
							};
							default: {}
						};
					} else {};
				};
			};
		};
		return elements;
	}

	static function extractYieldExpression(body:haxe.macro.TypedExpr, tempVarName:String, variableUsageMap:Null<Map<Int, Bool>> = null) {
		@:ast(switch (body.expr) {
	case TBlock(stmts):
		for (stmt  in  stmts) {
			switch (stmt.expr) {
				case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
					return arg;				
				case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
					switch (rhs.expr) {
						case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
							return expr;						
						default:
					};				
				default:
			};
		};	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		return arg;	
	default:
}) {
			var ` = body.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.expr;
						var ` = `.pos;
						var ` = `.t;
						if (enumIndex ` == 4) {
							var ` = `[0];
							var ` = `[1];
							{
								var ` = `.expr;
								var ` = `.pos;
								var ` = `.t;
								if (enumIndex ` == 1) {
									var ` = `[0];
									if (enumIndex ` == 0) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (`.length == 1) {
											var ` = `[0];
											{
												var arg = `;
												var v = `;
												var cf = `;
												if (v.name == tempVarName && cf.get().name == "push") {
													return arg;
												} else {};
											};
										} else {};
									} else {};
								} else {};
							};
						} else {};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var stmts = `;
						{
							{
								var ` = 0;
								while (` < stmts.length) {
									var stmt = stmts[`];
									++ `;
									@:ast(switch (stmt.expr) {
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		return arg;	
	case TBinop(OpAssign, { expr : TLocal(v) }, rhs) if (v.name == tempVarName):
		switch (rhs.expr) {
			case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
				return expr;			
			default:
		};	
	default:
}) {
										var ` = stmt.expr;
										switch (enumIndex `) {
											case 3: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 4) {
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var v = `;
																var rhs = `;
																if (v.name == tempVarName) {
																	@:ast(switch (rhs.expr) {
	case TBinop(OpAdd, _, { expr : TArrayDecl([expr]) }):
		return expr;	
	default:
}) {
																		var ` = rhs.expr;
																		if (enumIndex ` == 3) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			if (enumIndex ` == 0) {
																				{
																					var ` = `.expr;
																					var ` = `.pos;
																					var ` = `.t;
																					if (enumIndex ` == 8) {
																						var ` = `[0];
																						if (`.length == 1) {
																							var ` = `[0];
																							{
																								var expr = `;
																								{
																									return expr;
																								};
																							};
																						} else {};
																					} else {};
																				};
																			} else {};
																		} else {};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											};
											case 9: {
												var ` = `[0];
												var ` = `[1];
												{
													var ` = `.expr;
													var ` = `.pos;
													var ` = `.t;
													if (enumIndex ` == 4) {
														var ` = `[0];
														var ` = `[1];
														{
															var ` = `.expr;
															var ` = `.pos;
															var ` = `.t;
															if (enumIndex ` == 1) {
																var ` = `[0];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	if (`.length == 1) {
																		var ` = `[0];
																		{
																			var arg = `;
																			var v = `;
																			var cf = `;
																			if (v.name == tempVarName && cf.get().name == "push") {
																				return arg;
																			} else {};
																		};
																	} else {};
																} else {};
															} else {};
														};
													} else {};
												};
											};
											default: {}
										};
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function captureExpressionText(expr:haxe.macro.TypedExpr, loopVar:String) {
		if (expr == null) {
			return null;
		};
		var buildExprText = [null];
		buildExprText[0] = function(e:haxe.macro.TypedExpr) {
			return @:ast(switch (e.expr) {
	case TConst(c):
		switch (c) {
			case TInt(i):
				Std.string(i);			
			case TFloat(f):
				Std.string(f);			
			case TString(s):
				"\"$s\"";			
			case TBool(b):
				Std.string(b);			
			case TNull:
				"nil";			
			default:
				null;			
		};	
	case TLocal(v):
		if (v.name == loopVar) {
			"#{" + loopVar + "}";
		} else {
			v.name;
		};	
	case TBinop(op, e1, e2):
		var left = buildExprText(e1);
		var right = buildExprText(e2);
		if (left == null || right == null) return null;
		var opStr = switch (op) {
			case OpAdd:
				"+";			
			case OpSub:
				"-";			
			case OpMult:
				"*";			
			case OpDiv:
				"/";			
			case OpMod:
				"%";			
			case OpAnd:
				"&&";			
			case OpOr:
				"||";			
			case OpEq:
				"==";			
			case OpNotEq:
				"!=";			
			case OpLt:
				"<";			
			case OpLte:
				"<=";			
			case OpGt:
				">";			
			case OpGte:
				">=";			
			default:
				null;			
		};
		if (opStr == null) return null;
		"($left $opStr $right)";	
	case TUnop(op, postfix, e):
		var inner = buildExprText(e);
		if (inner == null) return null;
		switch (op) {
			case OpNot:
				"!$inner";			
			case OpNeg:
				"-$inner";			
			case OpIncrement:
				postfix ? "$inner++" : "++$inner";			
			case OpDecrement:
				postfix ? "$inner--" : "--$inner";			
			default:
				null;			
		};	
	case TParenthesis(e):
		var inner = buildExprText(e);
		if (inner == null) return null;
		"($inner)";	
	case TCall(e, args):
		switch (e.expr) {
			case TField(_, FStatic(_, cf)):
				if (cf.get().name == "trace" && args.length == 1) {
					var arg = buildExprText(args[0]);
					if (arg != null) {
						return "trace($arg)";
					};
				};			
			default:
		};
		null;	
	default:
		null;	
}) {
				var ` = e.expr;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						{
							var c = `;
							{
								@:ast(switch (c) {
	case TInt(i):
		Std.string(i);	
	case TFloat(f):
		Std.string(f);	
	case TString(s):
		"\"$s\"";	
	case TBool(b):
		Std.string(b);	
	case TNull:
		"nil";	
	default:
		null;	
}) switch (enumIndex c) {
									case 0: {
										var ` = c[0];
										{
											var i = `;
											{
												Std.string(i);
											};
										};
									};
									case 1: {
										var ` = c[0];
										{
											var f = `;
											{
												Std.string(f);
											};
										};
									};
									case 2: {
										var ` = c[0];
										{
											var s = `;
											{
												"\"" + s + "\"";
											};
										};
									};
									case 3: {
										var ` = c[0];
										{
											var b = `;
											{
												Std.string(b);
											};
										};
									};
									case 4: {
										{
											"nil";
										};
									};
									default: {
										null;
									}
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						{
							var v = `;
							{
								if (v.name == loopVar) {
									"#{" + loopVar + "}";
								} else {
									v.name;
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var e1 = `;
							var e2 = `;
							{
								var left = buildExprText[0](e1);
								var right = buildExprText[0](e2);
								if (left == null || right == null) {
									return null;
								};
								var opStr = @:ast(switch (op) {
	case OpAdd:
		"+";	
	case OpSub:
		"-";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpMod:
		"%";	
	case OpAnd:
		"&&";	
	case OpOr:
		"||";	
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	default:
		null;	
}) switch (enumIndex op) {
									case 0: {
										{
											"+";
										};
									};
									case 1: {
										{
											"*";
										};
									};
									case 2: {
										{
											"/";
										};
									};
									case 3: {
										{
											"-";
										};
									};
									case 5: {
										{
											"==";
										};
									};
									case 6: {
										{
											"!=";
										};
									};
									case 7: {
										{
											">";
										};
									};
									case 8: {
										{
											">=";
										};
									};
									case 9: {
										{
											"<";
										};
									};
									case 10: {
										{
											"<=";
										};
									};
									case 11: {
										{
											"&&";
										};
									};
									case 12: {
										{
											"||";
										};
									};
									case 19: {
										{
											"%";
										};
									};
									default: {
										null;
									}
								};
								if (opStr == null) {
									return null;
								};
								"(" + left + " " + opStr + " " + right + ")";
							};
						};
					};
					case 6: {
						var ` = `[0];
						{
							var e = `;
							{
								var inner = buildExprText[0](e);
								if (inner == null) {
									return null;
								};
								"(" + inner + ")";
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								@:ast(switch (e.expr) {
	case TField(_, FStatic(_, cf)):
		if (cf.get().name == "trace" && args.length == 1) {
			var arg = buildExprText(args[0]);
			if (arg != null) {
				return "trace($arg)";
			};
		};	
	default:
}) {
									var ` = e.expr;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 1) {
											var ` = `[0];
											var ` = `[1];
											{
												var cf = `;
												{
													if (cf.get().name == "trace" && args.length == 1) {
														var arg = buildExprText[0](args[0]);
														if (arg != null) {
															return "trace(" + arg + ")";
														};
													};
												};
											};
										} else {};
									} else {};
								};
								null;
							};
						};
					};
					case 11: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var postfix = `;
							var e = `;
							{
								var inner = buildExprText[0](e);
								if (inner == null) {
									return null;
								};
								@:ast(switch (op) {
	case OpNot:
		"!$inner";	
	case OpNeg:
		"-$inner";	
	case OpIncrement:
		postfix ? "$inner++" : "++$inner";	
	case OpDecrement:
		postfix ? "$inner--" : "--$inner";	
	default:
		null;	
}) switch (enumIndex op) {
									case 0: {
										{
											if (postfix) {
												"" + inner + "++";
											} else {
												"++" + inner;
											};
										};
									};
									case 1: {
										{
											if (postfix) {
												"" + inner + "--";
											} else {
												"--" + inner;
											};
										};
									};
									case 2: {
										{
											"!" + inner;
										};
									};
									case 3: {
										{
											"-" + inner;
										};
									};
									default: {
										null;
									}
								};
							};
						};
					};
					default: {
						null;
					}
				};
			};
		};
		var result = buildExprText[0](expr);
		return result;
	}
}