class reflaxe.elixir.SourceMapWriter {

	public function new(generatedFile:String) {
		this.lastMappedPos = null;
		this.printComma = false;
		this.currentGeneratedColumn = 0;
		this.lastGeneratedColumn = 0;
		this.lastSourceColumn = 0;
		this.lastSourceLine = 0;
		this.lastSourceIndex = 0;
		this.generatedFile = generatedFile;
		this.mappingsBuffer = new StringBuf();
		this.sources = [];
		this.sourceIndexes = new haxe.ds.StringMap();
	}

	var generatedFile:String;

	var mappingsBuffer:StringBuf;

	var sources:Array<String>;

	var sourceIndexes:Map<String, Int>;

	@:value(0)
	var lastSourceIndex:Int;

	@:value(0)
	var lastSourceLine:Int;

	@:value(0)
	var lastSourceColumn:Int;

	@:value(0)
	var lastGeneratedColumn:Int;

	@:value(0)
	var currentGeneratedColumn:Int;

	@:value(false)
	var printComma:Bool;

	@:value(null)
	var lastMappedPos:Null<haxe.macro.Position>;

	public function mapPosition(pos:haxe.macro.Position) {
		if (pos == null) {
			return;
		};
		this.lastMappedPos = pos;
		var sourceFile = reflaxe.helpers.PositionHelper.getFile(pos);
		var sourceIndex = this.getOrCreateSourceIndex(sourceFile);
		var sourceLine = reflaxe.helpers.PositionHelper.line(pos) - 1;
		var sourceColumn = reflaxe.helpers.PositionHelper.column(pos);
		if (this.printComma) {
			this.mappingsBuffer.add(",");
		} else {
			this.printComma = true;
		};
		this.writeVLQ(this.currentGeneratedColumn - this.lastGeneratedColumn);
		this.writeVLQ(sourceIndex - this.lastSourceIndex);
		this.writeVLQ(sourceLine - this.lastSourceLine);
		this.writeVLQ(sourceColumn - this.lastSourceColumn);
		this.lastSourceIndex = sourceIndex;
		this.lastSourceLine = sourceLine;
		this.lastSourceColumn = sourceColumn;
		this.lastGeneratedColumn = this.currentGeneratedColumn;
	}

	public function stringWritten(str:String) {
		var length = str.length;
		var lastNewlineIndex = str.lastIndexOf("\n", null);
		if (lastNewlineIndex >= 0) {
			this.printComma = false;
			this.currentGeneratedColumn = length - lastNewlineIndex - 1;
			this.lastGeneratedColumn = 0;
			var newlineCount = str.split("\n").length - 1;
			{
				var ` = 0;
				var ` = newlineCount;
				while (` < `) {
					var i = ` ++;
					this.mappingsBuffer.add(";");
				};
			};
		} else {
			this.currentGeneratedColumn += length;
		};
	}

	public function generateSourceMap() {
		var sourceMapPath = this.generatedFile + ".map";
		var dir = haxe.io.Path.directory(sourceMapPath);
		if (dir != "" && ! sys.FileSystem.exists(dir)) {
			sys.FileSystem.createDirectory(dir);
		};
		var sourceMap = {version : 3, file : this.extractFileName(this.generatedFile), sourceRoot : "", sources : this.sources, names : [], mappings : this.mappingsBuffer.toString()};
		var sourceMapJson = {
			var replacer = null;
			haxe.format.JsonPrinter.print(cast sourceMap, replacer, "  ");
		};
		sys.io.File.saveContent(sourceMapPath, sourceMapJson);
		return sourceMapPath;
	}

	function getOrCreateSourceIndex(sourceFile:String) {
		var normalizedPath = this.normalizeSourcePath(sourceFile);
		if ({
			var this = this.sourceIndexes;
			cast this.exists(normalizedPath);
		}) {
			return {
				var this = this.sourceIndexes;
				cast this.get(normalizedPath);
			};
		};
		var index = this.sources.length;
		this.sources.push(normalizedPath);
		{
			var this = this.sourceIndexes;
			cast this.set(normalizedPath, index);
		};
		return index;
	}

	function normalizeSourcePath(sourceFile:String) {
		if (sourceFile.indexOf("/std/", null) >= 0) {
			var stdIndex = sourceFile.indexOf("/std/", null);
			return sourceFile.substring(stdIndex + 1, null);
		};
		if (sourceFile.indexOf("/src/", null) >= 0) {
			var srcIndex = sourceFile.indexOf("/src/", null);
			return sourceFile.substring(srcIndex + 1, null);
		};
		var lastSlash = sourceFile.lastIndexOf("/", null);
		if (lastSlash >= 0) {
			return sourceFile.substring(lastSlash + 1, null);
		};
		return sourceFile;
	}

	function writeVLQ(value:Int) {
		var vlq = if (value < 0) {
			((- value) << 1) | 1;
		} else {
			value << 1;
		};
		do ({
			var digit = vlq & 31;
			vlq >>>= 5;
			if (vlq > 0) {
				digit |= 32;
			};
			this.mappingsBuffer.add(reflaxe.elixir.SourceMapWriter.VLQ_CHARS[digit]);
		}) while(vlq > 0);
	}

	function extractFileName(filePath:String) {
		var lastSlash = filePath.lastIndexOf("/", null);
		if (lastSlash >= 0) {
			return filePath.substring(lastSlash + 1, null);
		};
		return filePath;
	}

	public function getDebugInfo() {
		return "SourceMapWriter Debug Info:\n" + "  Generated file: " + this.generatedFile + "\n" + "  Sources: " + this.sources.length + " files\n" + "  Current position: line unknown, column " + this.currentGeneratedColumn + "\n" + "  Last mapped: " + if (this.lastMappedPos != null) {
			reflaxe.helpers.PositionHelper.getFile(this.lastMappedPos) + ":" + reflaxe.helpers.PositionHelper.line(this.lastMappedPos);
		} else {
			"none";
		} + "\n" + "  Mappings length: " + this.mappingsBuffer.get_length();
	}

	@:value(["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"])
	static var VLQ_CHARS:Array<String> = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
}