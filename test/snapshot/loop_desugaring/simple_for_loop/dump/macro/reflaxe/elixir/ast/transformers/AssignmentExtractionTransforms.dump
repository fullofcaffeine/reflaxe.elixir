@:nullSafety(Off)
class reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms {

	@:value(0)
	static var extractionCounter:Int = 0;

	public static function assignmentExtractionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(ast);
	}

	static function transformAssignments(node:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (node.def) {
	case ECase(expr, clauses):
		var transformedExpr = transformAssignments(expr);
		var transformedClauses = [];
		for (clause  in  clauses) {
			var transformedGuard = clause.guard != null ? transformAssignments(clause.guard) : null;
			var transformedBody = transformClauseBody(clause.body);
			transformedClauses.push({ pattern : clause.pattern, guard : transformedGuard, body : transformedBody });
		};
		return makeASTWithMeta(ECase(transformedExpr, transformedClauses), node.metadata, node.pos);	
	default:
}) {
			var ` = node.def;
			if (enumIndex ` == 6) {
				var ` = `[0];
				var ` = `[1];
				{
					var expr = `;
					var clauses = `;
					{
						var transformedExpr = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(expr);
						var transformedClauses = [];
						{
							var ` = 0;
							while (` < clauses.length) {
								var clause = clauses[`];
								++ `;
								var transformedGuard = if (clause.guard != null) {
									reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(clause.guard);
								} else {
									null;
								};
								var transformedBody = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformClauseBody(clause.body);
								transformedClauses.push({pattern : clause.pattern, guard : transformedGuard, body : transformedBody});
							};
						};
						return {def : reflaxe.elixir.ast.ElixirASTDef.ECase(transformedExpr, transformedClauses), metadata : node.metadata, pos : node.pos};
					};
				};
			} else {};
		};
		var transformedNode = node;
		@:ast(switch (node.def) {
	case EBlock(expressions):
		transformedNode = makeASTWithMeta(EBlock(expressions.map(transformAssignments)), node.metadata, node.pos);	
	case EIf(cond, thenBranch, elseBranch):
		transformedNode = makeASTWithMeta(EIf(transformAssignments(cond), transformAssignments(thenBranch), elseBranch != null ? transformAssignments(elseBranch) : null), node.metadata, node.pos);	
	case EBinary(op, left, right):
		transformedNode = makeASTWithMeta(EBinary(op, transformAssignments(left), transformAssignments(right)), node.metadata, node.pos);	
	default:
		transformedNode = node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							transformedNode = {
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(cond), reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(thenBranch), if ((elseBranch != null)) reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(elseBranch) else null);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							transformedNode = {
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(left), reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments(right));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							transformedNode = {
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var f = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = expressions;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					transformedNode = node;
				}
			};
		};
		if (transformedNode == null) {
			return null;
		};
		@:ast(switch (transformedNode.def) {
	case EMatch(pattern, value):
		var result = extractAndTransformExpression(value);
		if (result.hasExtracted) {
			var statements = result.extracted.copy();
			statements.push(makeASTWithMeta(EMatch(pattern, result.expression), transformedNode.metadata, transformedNode.pos));
			return makeAST(EBlock(statements));
		};
		return transformedNode;	
	case EBinary(op, left, right):
		var result = extractAndTransformExpression(transformedNode);
		if (result.hasExtracted) {
			var statements = result.extracted.copy();
			statements.push(result.expression);
			return makeAST(EBlock(statements));
		};
		return transformedNode;	
	case ECall(_, _, _):
		var result = extractAndTransformExpression(transformedNode);
		if (result.hasExtracted) {
			var statements = result.extracted.copy();
			statements.push(result.expression);
			return makeAST(EBlock(statements));
		};
		return transformedNode;	
	case ERemoteCall(_, _, _):
		var result = extractAndTransformExpression(transformedNode);
		if (result.hasExtracted) {
			var statements = result.extracted.copy();
			statements.push(result.expression);
			return makeAST(EBlock(statements));
		};
		return transformedNode;	
	case ECase(expr, clauses):
		var exprResult = extractAndTransformExpression(expr);
		var processedClauses = [];
		for (clause  in  clauses) {
			var transformedBody = transformClauseBody(clause.body);
			processedClauses.push({ pattern : clause.pattern, guard : clause.guard, body : transformedBody });
		};
		if (exprResult.hasExtracted) {
			var statements = exprResult.extracted.copy();
			statements.push(makeASTWithMeta(ECase(exprResult.expression, processedClauses), transformedNode.metadata, transformedNode.pos));
			return makeAST(EBlock(statements));
		} else {
			return transformedNode;
		};	
	case EIf(condition, thenBranch, elseBranch):
		var actualCondition = switch (condition.def) {
			case EParen(inner):
				inner;			
			default:
				condition;			
		};
		var condResult = extractAndTransformExpression(actualCondition);
		if (condResult.hasExtracted) {
			var statements = condResult.extracted.copy();
			var newCondition = switch (condition.def) {
				case EParen(_):
					makeASTWithMeta(EParen(condResult.expression), condition.metadata, condition.pos);				
				default:
					condResult.expression;				
			};
			statements.push(makeASTWithMeta(EIf(newCondition, thenBranch, elseBranch), transformedNode.metadata, transformedNode.pos));
			return makeAST(EBlock(statements));
		};
		return transformedNode;	
	default:
		return transformedNode;	
}) {
			var ` = transformedNode.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							var exprResult = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(expr);
							var processedClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var transformedBody = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformClauseBody(clause.body);
									processedClauses.push({pattern : clause.pattern, guard : clause.guard, body : transformedBody});
								};
							};
							if (exprResult.hasExtracted) {
								var statements = exprResult.extracted.copy();
								statements.push({def : reflaxe.elixir.ast.ElixirASTDef.ECase(exprResult.expression, processedClauses), metadata : transformedNode.metadata, pos : transformedNode.pos});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
								};
							} else {
								return transformedNode;
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var value = `;
						{
							var result = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(value);
							if (result.hasExtracted) {
								var statements = result.extracted.copy();
								statements.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, result.expression), metadata : transformedNode.metadata, pos : transformedNode.pos});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
								};
							};
							return transformedNode;
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var actualCondition = @:ast(switch (condition.def) {
	case EParen(inner):
		inner;	
	default:
		condition;	
}) {
								var ` = condition.def;
								if (enumIndex ` == 54) {
									var ` = `[0];
									{
										var inner = `;
										{
											inner;
										};
									};
								} else {
									condition;
								};
							};
							var condResult = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(actualCondition);
							if (condResult.hasExtracted) {
								var statements = condResult.extracted.copy();
								var newCondition = @:ast(switch (condition.def) {
	case EParen(_):
		makeASTWithMeta(EParen(condResult.expression), condition.metadata, condition.pos);	
	default:
		condResult.expression;	
}) {
									var ` = condition.def;
									if (enumIndex ` == 54) {
										var ` = `[0];
										{
											{def : reflaxe.elixir.ast.ElixirASTDef.EParen(condResult.expression), metadata : condition.metadata, pos : condition.pos};
										};
									} else {
										condResult.expression;
									};
								};
								statements.push({def : reflaxe.elixir.ast.ElixirASTDef.EIf(newCondition, thenBranch, elseBranch), metadata : transformedNode.metadata, pos : transformedNode.pos});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
								};
							};
							return transformedNode;
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var result = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(transformedNode);
						if (result.hasExtracted) {
							var statements = result.extracted.copy();
							statements.push(result.expression);
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
							};
						};
						return transformedNode;
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var result = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(transformedNode);
						if (result.hasExtracted) {
							var statements = result.extracted.copy();
							statements.push(result.expression);
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
							};
						};
						return transformedNode;
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							var result = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(transformedNode);
							if (result.hasExtracted) {
								var statements = result.extracted.copy();
								statements.push(result.expression);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
								};
							};
							return transformedNode;
						};
					};
				};
				default: {
					return transformedNode;
				}
			};
		};
	}

	static function transformClauseBody(body:reflaxe.elixir.ast.ElixirAST) {
		if (body == null || body.def == null) {
			return body;
		};
		@:ast(switch (body.def) {
	case EBlock(statements):
		var transformedStatements = [];
		for (stmt  in  statements) {
			var transformedStmt = transformClauseBody(stmt);
			if (shouldDropTempAssignment(transformedStmt)) {
				continue;
			};
			transformedStatements.push(transformedStmt);
		};
		return makeASTWithMeta(EBlock(transformedStatements), body.metadata, body.pos);	
	default:
		return ElixirASTTransformer.transformAST(body, transformAssignments);	
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var statements = `;
					{
						var transformedStatements = [];
						{
							var ` = 0;
							while (` < statements.length) {
								var stmt = statements[`];
								++ `;
								var transformedStmt = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformClauseBody(stmt);
								if (reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.shouldDropTempAssignment(transformedStmt)) {
									continue;
								};
								transformedStatements.push(transformedStmt);
							};
						};
						return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedStatements), metadata : body.metadata, pos : body.pos};
					};
				};
			} else {
				return reflaxe.elixir.ast.ElixirASTTransformer.transformAST(body, reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.transformAssignments);
			};
		};
	}

	static function shouldDropTempAssignment(stmt:reflaxe.elixir.ast.ElixirAST) {
		if (stmt == null || stmt.def == null) {
			return false;
		};
		return @:ast(switch (stmt.def) {
	case EMatch(pattern, value):
		switch pattern {
			case PVar(name):
				var valueVar = switch (value.def) {
					case EVar(varName):
						varName;					
					default:
						null;					
				};
				if (ElixirASTBuilder.isTempPatternVarName(name)) {
					return true;
				};
				if (valueVar != null) {
					if (valueVar == name) {
						return true;
					};
					if (ElixirASTBuilder.isTempPatternVarName(valueVar)) {
						return true;
					};
				};
				false;			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = stmt.def;
			if (enumIndex ` == 8) {
				var ` = `[0];
				var ` = `[1];
				{
					var pattern = `;
					var value = `;
					{
						@:ast(switch pattern {
	case PVar(name):
		var valueVar = switch (value.def) {
			case EVar(varName):
				varName;			
			default:
				null;			
		};
		if (ElixirASTBuilder.isTempPatternVarName(name)) {
			return true;
		};
		if (valueVar != null) {
			if (valueVar == name) {
				return true;
			};
			if (ElixirASTBuilder.isTempPatternVarName(valueVar)) {
				return true;
			};
		};
		false;	
	default:
		false;	
}) if (enumIndex pattern == 0) {
							var ` = pattern[0];
							{
								var name = `;
								{
									var valueVar = @:ast(switch (value.def) {
	case EVar(varName):
		varName;	
	default:
		null;	
}) {
										var ` = value.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var varName = `;
												{
													varName;
												};
											};
										} else {
											null;
										};
									};
									if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(name)) {
										return true;
									};
									if (valueVar != null) {
										if (valueVar == name) {
											return true;
										};
										if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(valueVar)) {
											return true;
										};
									};
									false;
								};
							};
						} else {
							false;
						};
					};
				};
			} else {
				false;
			};
		};
	}

	static function extractAndTransformExpression(expr:reflaxe.elixir.ast.ElixirAST) {
		var extracted = [];
		var parentOf = new haxe.ds.ObjectMap();
		var buildParentMap = [null];
		buildParentMap[0] = function(node:reflaxe.elixir.ast.ElixirAST, parent:Null<reflaxe.elixir.ast.ElixirAST>) {
			if (node == null || node.def == null) {
				return;
			};
			if (parent != null) {
				parentOf.set(node, parent);
			};
			@:ast(switch (node.def) {
	case ECase(expr, clauses):
		buildParentMap(expr, node);
		if (clauses != null) {
			for (clause  in  clauses) {
				if (clause != null && clause.body != null) {
					buildParentMap(clause.body, node);
				};
				if (clause != null && clause.guard != null) {
					buildParentMap(clause.guard, node);
				};
			};
		};	
	case EBlock(statements):
		if (statements != null) {
			for (stmt  in  statements) {
				if (stmt != null) {
					buildParentMap(stmt, node);
				};
			};
		};	
	case EIf(condition, thenBranch, elseBranch):
		buildParentMap(condition, node);
		buildParentMap(thenBranch, node);
		if (elseBranch != null) {
			buildParentMap(elseBranch, node);
		};	
	case EBinary(_, left, right):
		buildParentMap(left, node);
		buildParentMap(right, node);	
	case EUnary(_, operand):
		buildParentMap(operand, node);	
	case ECall(target, _, args):
		if (target != null) buildParentMap(target, node);
		for (arg  in  args) {
			buildParentMap(arg, node);
		};	
	case ERemoteCall(module, _, args):
		buildParentMap(module, node);
		for (arg  in  args) {
			buildParentMap(arg, node);
		};	
	case EFn(clauses):
		for (clause  in  clauses) {
			buildParentMap(clause.body, node);
			if (clause.guard != null) {
				buildParentMap(clause.guard, node);
			};
		};	
	case EParen(inner):
		buildParentMap(inner, node);	
	case EMatch(_, value):
		buildParentMap(value, node);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								buildParentMap[0](expr, node);
								if (clauses != null) {
									{
										var ` = 0;
										while (` < clauses.length) {
											var clause = clauses[`];
											++ `;
											if (clause != null && clause.body != null) {
												buildParentMap[0](clause.body, node);
											};
											if (clause != null && clause.guard != null) {
												buildParentMap[0](clause.guard, node);
											};
										};
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var value = `;
							{
								buildParentMap[0](value, node);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								buildParentMap[0](condition, node);
								buildParentMap[0](thenBranch, node);
								if (elseBranch != null) {
									buildParentMap[0](elseBranch, node);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var args = `;
							{
								if (target != null) {
									buildParentMap[0](target, node);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										buildParentMap[0](arg, node);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var args = `;
							{
								buildParentMap[0](module, node);
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										buildParentMap[0](arg, node);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var left = `;
							var right = `;
							{
								buildParentMap[0](left, node);
								buildParentMap[0](right, node);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var operand = `;
							{
								buildParentMap[0](operand, node);
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										buildParentMap[0](clause.body, node);
										if (clause.guard != null) {
											buildParentMap[0](clause.guard, node);
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var statements = `;
							{
								if (statements != null) {
									{
										var ` = 0;
										while (` < statements.length) {
											var stmt = statements[`];
											++ `;
											if (stmt != null) {
												buildParentMap[0](stmt, node);
											};
										};
									};
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var inner = `;
							{
								buildParentMap[0](inner, node);
							};
						};
					};
					default: {}
				};
			};
		};
		buildParentMap[0](expr, null);
		var isInStatementContext = [null];
		isInStatementContext[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			var parent = parentOf.get(node);
			if (parent == null) {
				return true;
			};
			@:ast(switch (parent.def) {
	case ECase(_, _):
		return true;	
	case EBlock(_):
		return true;	
	case EFn(_):
		return true;	
	default:
		return isInStatementContext(parent);	
}) {
				var ` = parent.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							return true;
						};
					};
					case 42: {
						var ` = `[0];
						{
							return true;
						};
					};
					case 53: {
						var ` = `[0];
						{
							return true;
						};
					};
					default: {
						return isInStatementContext[0](parent);
					}
				};
			};
		};
		var extractFromExpr = [null];
		extractFromExpr[0] = function(e:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (e.def) {
	case EMatch(pattern, value):
		var cleanValue = extractFromExpr(value);
		switch pattern {
			case PVar(name) if (ElixirASTBuilder.isTempPatternVarName(name)):
				return cleanValue;			
			case PVar(name):
				switch (cleanValue.def) {
					case EVar(varName) if (varName == name):
						return cleanValue;					
					default:
				};			
			default:
		};
		extracted.push(makeASTWithMeta(EMatch(pattern, cleanValue), e.metadata, e.pos));
		switch (pattern) {
			case PVar(name):
				return makeAST(EVar(name));			
			default:
				var tempVar = "_extracted_${extractionCounter++}";
				extracted[extracted.length - 1] = makeASTWithMeta(EMatch(PVar(tempVar), cleanValue), e.metadata, e.pos);
				extracted.push(makeASTWithMeta(EMatch(pattern, makeAST(EVar(tempVar))), e.metadata, e.pos));
				return makeAST(EVar(tempVar));			
		};	
	case EUnary(op, operand):
		switch (operand.def) {
			case EBlock(_):
				var cleanOperand = extractFromExpr(operand);
				return makeASTWithMeta(EUnary(op, cleanOperand), e.metadata, e.pos);			
			default:
				var cleanOperand = extractFromExpr(operand);
				return makeASTWithMeta(EUnary(op, cleanOperand), e.metadata, e.pos);			
		};	
	case EBinary(op, left, right):
		var cleanLeft = extractFromExpr(left);
		var cleanRight = extractFromExpr(right);
		return makeASTWithMeta(EBinary(op, cleanLeft, cleanRight), e.metadata, e.pos);	
	case ECall(target, funcName, args):
		var cleanTarget = target != null ? extractFromExpr(target) : null;
		var cleanArgs = args.map(extractFromExpr);
		return makeASTWithMeta(ECall(cleanTarget, funcName, cleanArgs), e.metadata, e.pos);	
	case ERemoteCall(module, funcName, args):
		var cleanModule = extractFromExpr(module);
		var cleanArgs = args.map(extractFromExpr);
		return makeASTWithMeta(ERemoteCall(cleanModule, funcName, cleanArgs), e.metadata, e.pos);	
	case EIf(condition, thenBranch, elseBranch):
		var cleanCondition = extractFromExpr(condition);
		var cleanThen = extractFromExpr(thenBranch);
		var cleanElse = elseBranch != null ? extractFromExpr(elseBranch) : null;
		return makeASTWithMeta(EIf(cleanCondition, cleanThen, cleanElse), e.metadata, e.pos);	
	case EParen(inner):
		var cleanInner = extractFromExpr(inner);
		if (extracted.length > 0) {
			return cleanInner;
		} else {
			return makeASTWithMeta(EParen(cleanInner), e.metadata, e.pos);
		};	
	case EFn(clauses):
		var cleanClauses = [];
		for (clause  in  clauses) {
			var result = extractAndTransformExpression(clause.body);
			if (result.hasExtracted) {
				var statements = result.extracted.copy();
				statements.push(result.expression);
				var cleanBody = makeAST(EBlock(statements));
				cleanClauses.push({ args : clause.args, guard : clause.guard, body : cleanBody });
			} else {
				cleanClauses.push({ args : clause.args, guard : clause.guard, body : result.expression });
			};
		};
		return makeASTWithMeta(EFn(cleanClauses), e.metadata, e.pos);	
	case EBlock(statements):
		if (!isInStatementContext(e)) {
			if (statements.length == 2) {
				switch (statements[0].def) {
					case EMatch(pattern, value):
						extracted.push(statements[0]);
						return extractFromExpr(statements[1]);					
					default:
				};
			};
		} else { };
		var cleanStatements = [];
		for (i  in  0 ... statements.length) {
			var stmt = statements[i];
			var isLast = (i == statements.length - 1);
			if (isLast) {
				var cleanStmt = extractFromExpr(stmt);
				cleanStatements.push(cleanStmt);
			} else {
				switch (stmt.def) {
					case EMatch(_, _):
						var cleanStmt = extractFromExpr(stmt);					
					default:
						cleanStatements.push(extractFromExpr(stmt));					
				};
			};
		};
		if (cleanStatements.length == 1) {
			return cleanStatements[0];
		} else if (cleanStatements.length == 0) {
			return makeAST(ENil);
		} else {
			return makeASTWithMeta(EBlock(cleanStatements), e.metadata, e.pos);
		};	
	default:
		return e;	
}) {
				var ` = e.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var value = `;
							{
								var cleanValue = extractFromExpr[0](value);
								@:ast(switch pattern {
	case PVar(name) if (ElixirASTBuilder.isTempPatternVarName(name)):
		return cleanValue;	
	case PVar(name):
		switch (cleanValue.def) {
			case EVar(varName) if (varName == name):
				return cleanValue;			
			default:
		};	
	default:
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var name = `;
										if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(name)) {
											return cleanValue;
										} else {
											var name = `;
											{
												@:ast(switch (cleanValue.def) {
	case EVar(varName) if (varName == name):
		return cleanValue;	
	default:
}) {
													var ` = cleanValue.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var varName = `;
															if (varName == name) {
																return cleanValue;
															} else {};
														};
													} else {};
												};
											};
										};
									};
								} else {};
								extracted.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, cleanValue), metadata : e.metadata, pos : e.pos});
								@:ast(switch (pattern) {
	case PVar(name):
		return makeAST(EVar(name));	
	default:
		var tempVar = "_extracted_${extractionCounter++}";
		extracted[extracted.length - 1] = makeASTWithMeta(EMatch(PVar(tempVar), cleanValue), e.metadata, e.pos);
		extracted.push(makeASTWithMeta(EMatch(pattern, makeAST(EVar(tempVar))), e.metadata, e.pos));
		return makeAST(EVar(tempVar));	
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var name = `;
										{
											return {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									var tempVar = "_extracted_" + reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractionCounter ++;
									extracted[extracted.length - 1] = {def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tempVar), cleanValue), metadata : e.metadata, pos : e.pos};
									extracted.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVar), metadata : {}, pos : pos};
									}), metadata : e.metadata, pos : e.pos});
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVar), metadata : {}, pos : pos};
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								var cleanCondition = extractFromExpr[0](condition);
								var cleanThen = extractFromExpr[0](thenBranch);
								var cleanElse = if (elseBranch != null) {
									extractFromExpr[0](elseBranch);
								} else {
									null;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EIf(cleanCondition, cleanThen, cleanElse), metadata : e.metadata, pos : e.pos};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var funcName = `;
							var args = `;
							{
								var cleanTarget = if (target != null) {
									extractFromExpr[0](target);
								} else {
									null;
								};
								var cleanArgs = {
									var f = extractFromExpr[0];
									{
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.ECall(cleanTarget, funcName, cleanArgs), metadata : e.metadata, pos : e.pos};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var funcName = `;
							var args = `;
							{
								var cleanModule = extractFromExpr[0](module);
								var cleanArgs = {
									var f = extractFromExpr[0];
									{
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(cleanModule, funcName, cleanArgs), metadata : e.metadata, pos : e.pos};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								var cleanLeft = extractFromExpr[0](left);
								var cleanRight = extractFromExpr[0](right);
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, cleanLeft, cleanRight), metadata : e.metadata, pos : e.pos};
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var operand = `;
							{
								@:ast(switch (operand.def) {
	case EBlock(_):
		var cleanOperand = extractFromExpr(operand);
		return makeASTWithMeta(EUnary(op, cleanOperand), e.metadata, e.pos);	
	default:
		var cleanOperand = extractFromExpr(operand);
		return makeASTWithMeta(EUnary(op, cleanOperand), e.metadata, e.pos);	
}) {
									var ` = operand.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var cleanOperand = extractFromExpr[0](operand);
											return {def : reflaxe.elixir.ast.ElixirASTDef.EUnary(op, cleanOperand), metadata : e.metadata, pos : e.pos};
										};
									} else {
										var cleanOperand = extractFromExpr[0](operand);
										return {def : reflaxe.elixir.ast.ElixirASTDef.EUnary(op, cleanOperand), metadata : e.metadata, pos : e.pos};
									};
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var cleanClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										var result = reflaxe.elixir.ast.transformers.AssignmentExtractionTransforms.extractAndTransformExpression(clause.body);
										if (result.hasExtracted) {
											var statements = result.extracted.copy();
											statements.push(result.expression);
											var cleanBody = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
											};
											cleanClauses.push({args : clause.args, guard : clause.guard, body : cleanBody});
										} else {
											cleanClauses.push({args : clause.args, guard : clause.guard, body : result.expression});
										};
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(cleanClauses), metadata : e.metadata, pos : e.pos};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var statements = `;
							{
								if (! isInStatementContext[0](e)) {
									if (statements.length == 2) {
										@:ast(switch (statements[0].def) {
	case EMatch(pattern, value):
		extracted.push(statements[0]);
		return extractFromExpr(statements[1]);	
	default:
}) {
											var ` = statements[0].def;
											if (enumIndex ` == 8) {
												var ` = `[0];
												var ` = `[1];
												{
													var pattern = `;
													var value = `;
													{
														extracted.push(statements[0]);
														return extractFromExpr[0](statements[1]);
													};
												};
											} else {};
										};
									};
								} else {};
								var cleanStatements = [];
								{
									var ` = 0;
									var ` = statements.length;
									while (` < `) {
										var i = ` ++;
										var stmt = statements[i];
										var isLast = (i == statements.length - 1);
										if (isLast) {
											var cleanStmt = extractFromExpr[0](stmt);
											cleanStatements.push(cleanStmt);
										} else {
											@:ast(switch (stmt.def) {
	case EMatch(_, _):
		var cleanStmt = extractFromExpr(stmt);	
	default:
		cleanStatements.push(extractFromExpr(stmt));	
}) {
												var ` = stmt.def;
												if (enumIndex ` == 8) {
													var ` = `[0];
													var ` = `[1];
													{
														var cleanStmt = extractFromExpr[0](stmt);
													};
												} else {
													cleanStatements.push(extractFromExpr[0](stmt));
												};
											};
										};
									};
								};
								if (cleanStatements.length == 1) {
									return cleanStatements[0];
								} else {
									if (cleanStatements.length == 0) {
										return {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										};
									} else {
										return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(cleanStatements), metadata : e.metadata, pos : e.pos};
									};
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var inner = `;
							{
								var cleanInner = extractFromExpr[0](inner);
								if (extracted.length > 0) {
									return cleanInner;
								} else {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EParen(cleanInner), metadata : e.metadata, pos : e.pos};
								};
							};
						};
					};
					default: {
						return e;
					}
				};
			};
		};
		var cleanExpr = extractFromExpr[0](expr);
		return {extracted : extracted, expression : cleanExpr, hasExtracted : extracted.length > 0};
	}
}