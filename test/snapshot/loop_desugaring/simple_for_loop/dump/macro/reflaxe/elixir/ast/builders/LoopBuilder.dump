class reflaxe.elixir.ast.builders.LoopBuilder {

	@:value(0.7)
	static inline var CONFIDENCE_THRESHOLD:Float = 0.7;

	public static function analyzeFor(v:haxe.macro.TVar, e1:haxe.macro.TypedExpr, e2:haxe.macro.TypedExpr) {
		@:ast(switch (e1.expr) {
	case TBinop(OpInterval, startExpr, endExpr):
		if (hasSideEffectsOnly(e2)) {
			return EnumEachRange(v.name, startExpr, endExpr, e2);
		} else {
			return StandardFor(v, e1, e2);
		};	
	case TLocal(_) | TField(_, _):
		if (hasSideEffectsOnly(e2)) {
			return EnumEachCollection(v.name, e1, e2);
		} else {
			return StandardFor(v, e1, e2);
		};	
	default:
		return StandardFor(v, e1, e2);	
}) {
			var ` = e1.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						if (reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(e2)) {
							return reflaxe.elixir.ast.builders.LoopTransform.EnumEachCollection(v.name, e1, e2);
						} else {
							return reflaxe.elixir.ast.builders.LoopTransform.StandardFor(v, e1, e2);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 21) {
						{
							var startExpr = `;
							var endExpr = `;
							{
								if (reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(e2)) {
									return reflaxe.elixir.ast.builders.LoopTransform.EnumEachRange(v.name, startExpr, endExpr, e2);
								} else {
									return reflaxe.elixir.ast.builders.LoopTransform.StandardFor(v, e1, e2);
								};
							};
						};
					} else {
						return reflaxe.elixir.ast.builders.LoopTransform.StandardFor(v, e1, e2);
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						if (reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(e2)) {
							return reflaxe.elixir.ast.builders.LoopTransform.EnumEachCollection(v.name, e1, e2);
						} else {
							return reflaxe.elixir.ast.builders.LoopTransform.StandardFor(v, e1, e2);
						};
					};
				};
				default: {
					return reflaxe.elixir.ast.builders.LoopTransform.StandardFor(v, e1, e2);
				}
			};
		};
	}

	public static function buildFromTransform(transform:reflaxe.elixir.ast.builders.LoopTransform, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		@:ast(switch (transform) {
	case EnumEachRange(varName, startExpr, endExpr, body):
		var range = makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));
		var snakeVar = toSnakeCase(varName);
		var bodyAst = buildExpr(body);
		return makeAST(ERemoteCall(makeAST(EVar("Enum")), "each", [range, makeAST(EFn([{ args : [PVar(snakeVar)], body : bodyAst }]))]));	
	case EnumEachCollection(varName, collection, body):
		var collectionAst = buildExpr(collection);
		var snakeVar = toSnakeCase(varName);
		var bodyAst = buildExpr(body);
		return makeAST(ERemoteCall(makeAST(EVar("Enum")), "each", [collectionAst, makeAST(EFn([{ args : [PVar(snakeVar)], body : bodyAst }]))]));	
	case Comprehension(targetVar, v, iterator, filter, body):
		var varName = toSnakeCase(v.name);
		var pattern = PVar(varName);
		var iteratorExpr = buildExpr(iterator);
		var bodyExpr = buildExpr(body);
		return makeAST(EFor([{ pattern : pattern, expr : iteratorExpr }], [], bodyExpr, null, false));	
	case StandardFor(v, iterator, body):
		var varName = toSnakeCase(v.name);
		var pattern = PVar(varName);
		var iteratorExpr = buildExpr(iterator);
		var bodyExpr = buildExpr(body);
		return makeAST(EFor([{ pattern : pattern, expr : iteratorExpr }], [], bodyExpr, null, false));	
}) switch (@:exhaustive enumIndex transform) {
			case 0: {
				var ` = transform[0];
				var ` = transform[1];
				var ` = transform[2];
				var ` = transform[3];
				{
					var varName = `;
					var startExpr = `;
					var endExpr = `;
					var body = `;
					{
						var range = {
							var def = reflaxe.elixir.ast.ElixirASTDef.ERange(buildExpr(startExpr), buildExpr(endExpr), false);
							var pos = null;
							{def : def, metadata : {}, pos : pos};
						};
						var snakeVar = toSnakeCase(varName);
						var bodyAst = buildExpr(body);
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
							}, "each", [range, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(snakeVar)], body : bodyAst}]), metadata : {}, pos : pos};
							}]), metadata : {}, pos : pos};
						};
					};
				};
			};
			case 1: {
				var ` = transform[0];
				var ` = transform[1];
				var ` = transform[2];
				{
					var varName = `;
					var collection = `;
					var body = `;
					{
						var collectionAst = buildExpr(collection);
						var snakeVar = toSnakeCase(varName);
						var bodyAst = buildExpr(body);
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
							}, "each", [collectionAst, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(snakeVar)], body : bodyAst}]), metadata : {}, pos : pos};
							}]), metadata : {}, pos : pos};
						};
					};
				};
			};
			case 2: {
				var ` = transform[0];
				var ` = transform[1];
				var ` = transform[2];
				var ` = transform[3];
				var ` = transform[4];
				{
					var targetVar = `;
					var v = `;
					var iterator = `;
					var filter = `;
					var body = `;
					{
						var varName = toSnakeCase(v.name);
						var pattern = reflaxe.elixir.ast.EPattern.PVar(varName);
						var iteratorExpr = buildExpr(iterator);
						var bodyExpr = buildExpr(body);
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : iteratorExpr}], [], bodyExpr, null, false), metadata : {}, pos : pos};
						};
					};
				};
			};
			case 3: {
				var ` = transform[0];
				var ` = transform[1];
				var ` = transform[2];
				{
					var v = `;
					var iterator = `;
					var body = `;
					{
						var varName = toSnakeCase(v.name);
						var pattern = reflaxe.elixir.ast.EPattern.PVar(varName);
						var iteratorExpr = buildExpr(iterator);
						var bodyExpr = buildExpr(body);
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : iteratorExpr}], [], bodyExpr, null, false), metadata : {}, pos : pos};
						};
					};
				};
			};
		};
	}

	static function hasSideEffectsOnly(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TCall(e, _):
		switch (e.expr) {
			case TField(_, FStatic(_, cf)):
				var name = cf.get().name;
				return name == "trace" || name == "log" || name == "println" || name == "print" || name == "debug" || name == "info" || name == "warn" || name == "error";			
			case TField(_, FInstance(_, _, cf)):
				var name = cf.get().name;
				return name == "push" || name == "add" || name == "remove" || name == "set" || name == "clear";			
			default:
				return false;			
		};	
	case TBlock(exprs):
		if (exprs.length == 0) return true;
		for (e  in  exprs) {
			if (!hasSideEffectsOnly(e)) return false;
		};
		return true;	
	case TBinop(OpAssign | OpAssignOp(_), _, _):
		return true;	
	case TUnop(OpIncrement | OpDecrement, _, _):
		return true;	
	case TIf(_, then_, else_):
		return hasSideEffectsOnly(then_) && (else_ == null || hasSideEffectsOnly(else_));	
	case TConst(_):
		return true;	
	case TLocal(_):
		return true;	
	default:
		return false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						return true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						return true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								return true;
							};
						};
						case 20: {
							var ` = `[0];
							{
								return true;
							};
						};
						default: {
							return false;
						}
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							@:ast(switch (e.expr) {
	case TField(_, FStatic(_, cf)):
		var name = cf.get().name;
		return name == "trace" || name == "log" || name == "println" || name == "print" || name == "debug" || name == "info" || name == "warn" || name == "error";	
	case TField(_, FInstance(_, _, cf)):
		var name = cf.get().name;
		return name == "push" || name == "add" || name == "remove" || name == "set" || name == "clear";	
	default:
		return false;	
}) {
								var ` = e.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												{
													var name = cf.get().name;
													return name == "push" || name == "add" || name == "remove" || name == "set" || name == "clear";
												};
											};
										};
										case 1: {
											var ` = `[0];
											var ` = `[1];
											{
												var cf = `;
												{
													var name = cf.get().name;
													return name == "trace" || name == "log" || name == "println" || name == "print" || name == "debug" || name == "info" || name == "warn" || name == "error";
												};
											};
										};
										default: {
											return false;
										}
									};
								} else {
									return false;
								};
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								return true;
							};
						};
						default: {
							return false;
						}
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							if (exprs.length == 0) {
								return true;
							};
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									if (! reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(e)) {
										return false;
									};
								};
							};
							return true;
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var then_ = `;
						var else_ = `;
						{
							return reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(then_) && (else_ == null || reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(else_));
						};
					};
				};
				default: {
					return false;
				}
			};
		};
	}

	@:value({ toSnakeCase : null })
	public static function buildWhile(econd:haxe.macro.TypedExpr, e:haxe.macro.TypedExpr, normalWhile:Bool, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:Null<String -> String> = null) {
		if (toSnakeCase == null) {
			toSnakeCase = function(s:String) return s.toLowerCase();
		};
		var forPattern = reflaxe.elixir.ast.builders.LoopBuilder.detectDesugarForLoopPattern(econd, e);
		if (forPattern != null) {
			haxe.Log.trace("[LoopBuilder] Detected desugared for loop pattern", {fileName : "../../../../src/reflaxe/elixir/ast/builders/LoopBuilder.hx", lineNumber : 292, className : "reflaxe.elixir.ast.builders.LoopBuilder", methodName : "buildWhile"});
			return reflaxe.elixir.ast.builders.LoopBuilder.buildFromForPattern(forPattern, buildExpr, toSnakeCase);
		};
		var whileExpr = {expr : haxe.macro.TypedExprDef.TWhile(econd, e, normalWhile), pos : econd.pos, t : e.t};
		var ir = reflaxe.elixir.ast.builders.LoopBuilder.analyzeLoop(whileExpr, buildExpr);
		if (ir.confidence >= 0.7) {
			return reflaxe.elixir.ast.builders.LoopBuilder.emitFromIR(ir, buildExpr, null, toSnakeCase);
		} else {
			return reflaxe.elixir.ast.builders.LoopBuilder.buildLegacyWhile(buildExpr(econd), buildExpr(e), normalWhile, buildExpr);
		};
	}

	static function detectDesugarForLoopPattern(cond:haxe.macro.TypedExpr, body:haxe.macro.TypedExpr) {
		var bounds = @:ast(switch (cond.expr) {
	case TBinop(OpLt | OpLte, e1, e2):
		var counter = extractInfrastructureVarName(e1);
		var limit = extractInfrastructureVarName(e2);
		if (counter != null && limit != null) {
			{ counter : counter, limit : limit };
		} else null;	
	default:
		null;	
}) {
			var ` = cond.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				switch (enumIndex `) {
					case 9, 10: {
						{
							var e1 = `;
							var e2 = `;
							{
								var counter = reflaxe.elixir.ast.builders.LoopBuilder.extractInfrastructureVarName(e1);
								var limit = reflaxe.elixir.ast.builders.LoopBuilder.extractInfrastructureVarName(e2);
								if (counter != null && limit != null) {
									{counter : counter, limit : limit};
								} else {
									null;
								};
							};
						};
					};
					default: {
						null;
					}
				};
			} else {
				null;
			};
		};
		if (bounds == null) {
			return null;
		};
		var bodyInfo = reflaxe.elixir.ast.builders.LoopBuilder.analyzeForLoopBody(body, bounds.counter);
		if (bodyInfo == null) {
			return null;
		};
		var startExpr = {expr : haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TInt(0)), pos : cond.pos, t : cond.t};
		var endExpr = @:ast(switch (cond.expr) {
	case TBinop(_, _, limit):
		limit;	
	default:
		startExpr;	
}) {
			var ` = cond.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var limit = `;
					{
						limit;
					};
				};
			} else {
				startExpr;
			};
		};
		return {userVar : bodyInfo.userVar, startExpr : startExpr, endExpr : endExpr, userCode : bodyInfo.userCode, hasSideEffectsOnly : bodyInfo.hasSideEffectsOnly};
	}

	static function extractInfrastructureVarName(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TLocal(v):
		var name = v.name;
		if (name == "_g" || name == "g" || name.indexOf("_g") == 0 || (name.charAt(0) == "g" && ~/^g[0-9]+/.match(name))) {
			name;
		} else null;	
	default:
		null;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var v = `;
					{
						var name = v.name;
						if (name == "_g" || name == "g" || name.indexOf("_g", null) == 0 || (name.charAt(0) == "g" && new EReg("^g[0-9]+", "").match(name))) {
							name;
						} else {
							null;
						};
					};
				};
			} else {
				null;
			};
		};
	}

	static function analyzeForLoopBody(body:haxe.macro.TypedExpr, counterVar:String) {
		@:ast(switch (body.expr) {
	case TBlock(exprs) if (exprs.length >= 2):
		var userVar = "i";
		var userCodeStart = 0;
		switch (exprs[0].expr) {
			case TVar(v, init) if (init != null):
				if (extractInfrastructureVarName(init) == counterVar) {
					userVar = v.name;
					userCodeStart = 1;
				};			
			default:
		};
		var lastExpr = exprs[exprs.length - 1];
		var isIncrement = switch (lastExpr.expr) {
			case TUnop(OpIncrement, _, e):
				extractInfrastructureVarName(e) == counterVar;			
			case TBinop(OpAssign, e1, _):
				extractInfrastructureVarName(e1) == counterVar;			
			default:
				false;			
		};
		if (!isIncrement) return null;
		var userCodeExprs = exprs.slice(userCodeStart, exprs.length - 1);
		var userCode = if (userCodeExprs.length == 1) {
			userCodeExprs[0];
		} else {
			{ expr : TBlock(userCodeExprs), pos : body.pos, t : body.t };
		};
		return { userVar : userVar, userCode : userCode, hasSideEffectsOnly : hasSideEffectsOnly(userCode) };	
	default:
		return null;	
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length >= 2) {
						var userVar = "i";
						var userCodeStart = 0;
						@:ast(switch (exprs[0].expr) {
	case TVar(v, init) if (init != null):
		if (extractInfrastructureVarName(init) == counterVar) {
			userVar = v.name;
			userCodeStart = 1;
		};	
	default:
}) {
							var ` = exprs[0].expr;
							if (enumIndex ` == 13) {
								var ` = `[0];
								var ` = `[1];
								{
									var v = `;
									var init = `;
									if (init != null) {
										if (reflaxe.elixir.ast.builders.LoopBuilder.extractInfrastructureVarName(init) == counterVar) {
											userVar = v.name;
											userCodeStart = 1;
										};
									} else {};
								};
							} else {};
						};
						var lastExpr = exprs[exprs.length - 1];
						var isIncrement = @:ast(switch (lastExpr.expr) {
	case TUnop(OpIncrement, _, e):
		extractInfrastructureVarName(e) == counterVar;	
	case TBinop(OpAssign, e1, _):
		extractInfrastructureVarName(e1) == counterVar;	
	default:
		false;	
}) {
							var ` = lastExpr.expr;
							switch (enumIndex `) {
								case 3: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (enumIndex ` == 4) {
										{
											var e1 = `;
											{
												reflaxe.elixir.ast.builders.LoopBuilder.extractInfrastructureVarName(e1) == counterVar;
											};
										};
									} else {
										false;
									};
								};
								case 11: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (enumIndex ` == 0) {
										{
											var e = `;
											{
												reflaxe.elixir.ast.builders.LoopBuilder.extractInfrastructureVarName(e) == counterVar;
											};
										};
									} else {
										false;
									};
								};
								default: {
									false;
								}
							};
						};
						if (! isIncrement) {
							return null;
						};
						var userCodeExprs = exprs.slice(userCodeStart, exprs.length - 1);
						var userCode = if (userCodeExprs.length == 1) {
							userCodeExprs[0];
						} else {
							{expr : haxe.macro.TypedExprDef.TBlock(userCodeExprs), pos : body.pos, t : body.t};
						};
						return {userVar : userVar, userCode : userCode, hasSideEffectsOnly : reflaxe.elixir.ast.builders.LoopBuilder.hasSideEffectsOnly(userCode)};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
	}

	static function buildFromForPattern(pattern:{ userVar : String, userCode : haxe.macro.TypedExpr, startExpr : haxe.macro.TypedExpr, hasSideEffectsOnly : Bool, endExpr : haxe.macro.TypedExpr }, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		var range = {
			var def = reflaxe.elixir.ast.ElixirASTDef.ERange(buildExpr(pattern.startExpr), buildExpr(pattern.endExpr), false);
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		var varName = toSnakeCase(pattern.userVar);
		var body = buildExpr(pattern.userCode);
		if (pattern.hasSideEffectsOnly) {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
				}, "each", [range, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(varName)], body : body}]), metadata : {}, pos : pos};
				}]), metadata : {}, pos : pos};
			};
		} else {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : reflaxe.elixir.ast.EPattern.PVar(varName), expr : range}], [], body, null, false), metadata : {}, pos : pos};
			};
		};
	}

	static function analyzeLoop(expr:haxe.macro.TypedExpr, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST) {
		var ir = {kind : @:ast(switch (expr.expr) {
	case TFor(_, _, _):
		ForEach;	
	case TWhile(_, _, _):
		While;	
	case _:
		ForEach;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						reflaxe.elixir.ast.loop_ir.LoopKind.ForEach;
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						reflaxe.elixir.ast.loop_ir.LoopKind.While;
					};
				};
				default: {
					reflaxe.elixir.ast.loop_ir.LoopKind.ForEach;
				}
			};
		}, source : reflaxe.elixir.ast.loop_ir.LoopSource.Collection({
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		}), elementPattern : null, accumulators : [], filters : [], yield : null, earlyExit : null, bodyEffects : {hasSideEffects : false, producesValue : false, modifiesAccumulator : false, hasNestedLoops : false, hasComplexControl : false}, confidence : 0.0, originalExpr : expr};
		var analyzers = [new reflaxe.elixir.ast.analyzers.RangeIterationAnalyzer(buildExpr)];
		var totalConfidence = 0.0;
		var analyzerCount = 0;
		{
			var ` = 0;
			while (` < analyzers.length) {
				var analyzer = analyzers[`];
				++ `;
				analyzer.analyze(expr, ir);
				var confidence = analyzer.calculateConfidence();
				if (confidence > 0) {
					totalConfidence += confidence;
					analyzerCount ++;
				};
			};
		};
		if (analyzerCount > 0) {
			ir.confidence = totalConfidence / analyzerCount;
		};
		return ir;
	}

	static function emitFromIR(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, extractPattern:Null<haxe.macro.TypedExpr -> reflaxe.elixir.ast.EPattern>, toSnakeCase:String -> String) {
		var strategy = reflaxe.elixir.ast.builders.LoopBuilder.selectStrategy(ir);
		return @:ast(switch (strategy) {
	case EnumEach:
		emitEnumEach(ir, buildExpr, toSnakeCase);	
	case EnumMap:
		emitEnumMap(ir, buildExpr, toSnakeCase);	
	case Comprehension:
		emitComprehension(ir, buildExpr, toSnakeCase);	
	case EnumReduce:
		emitEnumReduce(ir, buildExpr, toSnakeCase);	
	case _:
		emitSimpleLoop(ir, buildExpr, toSnakeCase);	
}) switch (enumIndex strategy) {
			case 0: {
				{
					reflaxe.elixir.ast.builders.LoopBuilder.emitEnumEach(ir, buildExpr, toSnakeCase);
				};
			};
			case 1: {
				{
					reflaxe.elixir.ast.builders.LoopBuilder.emitEnumMap(ir, buildExpr, toSnakeCase);
				};
			};
			case 2: {
				{
					reflaxe.elixir.ast.builders.LoopBuilder.emitEnumReduce(ir, buildExpr, toSnakeCase);
				};
			};
			case 4: {
				{
					reflaxe.elixir.ast.builders.LoopBuilder.emitComprehension(ir, buildExpr, toSnakeCase);
				};
			};
			default: {
				reflaxe.elixir.ast.builders.LoopBuilder.emitSimpleLoop(ir, buildExpr, toSnakeCase);
			}
		};
	}

	static function selectStrategy(ir:reflaxe.elixir.ast.loop_ir.LoopIR) {
		if (ir.bodyEffects.hasSideEffects && ! ir.bodyEffects.producesValue) {
			return reflaxe.elixir.ast.loop_ir.EmissionStrategy.EnumEach;
		};
		if (ir.filters.length > 0 && ir.yield != null) {
			return reflaxe.elixir.ast.loop_ir.EmissionStrategy.Comprehension;
		};
		if (ir.yield != null && ! ir.bodyEffects.modifiesAccumulator) {
			return reflaxe.elixir.ast.loop_ir.EmissionStrategy.EnumMap;
		};
		if (ir.accumulators.length > 0) {
			return reflaxe.elixir.ast.loop_ir.EmissionStrategy.EnumReduce;
		};
		return reflaxe.elixir.ast.loop_ir.EmissionStrategy.EnumEach;
	}

	static function emitEnumEach(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		var source = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, e1, _):
		switch (e1.expr) {
			case TBinop(OpInterval, startExpr, endExpr):
				makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));			
			case _:
				buildExpr(e1);			
		};	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.originalExpr.expr;
			if (enumIndex ` == 15) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var e1 = `;
					{
						@:ast(switch (e1.expr) {
	case TBinop(OpInterval, startExpr, endExpr):
		makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));	
	case _:
		buildExpr(e1);	
}) {
							var ` = e1.expr;
							if (enumIndex ` == 3) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								if (enumIndex ` == 21) {
									{
										var startExpr = `;
										var endExpr = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ERange(buildExpr(startExpr), buildExpr(endExpr), false);
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										};
									};
								} else {
									buildExpr(e1);
								};
							} else {
								buildExpr(e1);
							};
						};
					};
				};
			} else {
				{
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
				};
			};
		};
		var varName = if (ir.elementPattern != null) {
			toSnakeCase(ir.elementPattern.varName);
		} else {
			"_item";
		};
		var body = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, _, bodyExpr):
		buildExpr(bodyExpr);	
	case TWhile(_, bodyExpr, _):
		buildExpr(bodyExpr);	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.originalExpr.expr;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				default: {
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					};
				}
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
			}, "each", [source, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(varName)], body : body}]), metadata : {}, pos : pos};
			}]), metadata : {}, pos : pos};
		};
	}

	static function emitEnumMap(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		var source = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, e1, _):
		switch (e1.expr) {
			case TBinop(OpInterval, startExpr, endExpr):
				makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));			
			case _:
				buildExpr(e1);			
		};	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.originalExpr.expr;
			if (enumIndex ` == 15) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var e1 = `;
					{
						@:ast(switch (e1.expr) {
	case TBinop(OpInterval, startExpr, endExpr):
		makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));	
	case _:
		buildExpr(e1);	
}) {
							var ` = e1.expr;
							if (enumIndex ` == 3) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								if (enumIndex ` == 21) {
									{
										var startExpr = `;
										var endExpr = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ERange(buildExpr(startExpr), buildExpr(endExpr), false);
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										};
									};
								} else {
									buildExpr(e1);
								};
							} else {
								buildExpr(e1);
							};
						};
					};
				};
			} else {
				{
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
				};
			};
		};
		var varName = if (ir.elementPattern != null) {
			toSnakeCase(ir.elementPattern.varName);
		} else {
			"_item";
		};
		var body = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, _, bodyExpr):
		buildExpr(bodyExpr);	
	case TWhile(_, bodyExpr, _):
		buildExpr(bodyExpr);	
	case _:
		if (ir.yield != null) {
			ir.yield.expr;
		} else {
			makeAST(ENil);
		};	
}) {
			var ` = ir.originalExpr.expr;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				default: {
					if (ir.yield != null) {
						ir.yield.expr;
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
						};
					};
				}
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
			}, "map", [source, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(varName)], body : body}]), metadata : {}, pos : pos};
			}]), metadata : {}, pos : pos};
		};
	}

	static function emitComprehension(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		var source = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, e1, _):
		switch (e1.expr) {
			case TBinop(OpInterval, startExpr, endExpr):
				makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));			
			case _:
				buildExpr(e1);			
		};	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.originalExpr.expr;
			if (enumIndex ` == 15) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var e1 = `;
					{
						@:ast(switch (e1.expr) {
	case TBinop(OpInterval, startExpr, endExpr):
		makeAST(ERange(buildExpr(startExpr), buildExpr(endExpr), false));	
	case _:
		buildExpr(e1);	
}) {
							var ` = e1.expr;
							if (enumIndex ` == 3) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								if (enumIndex ` == 21) {
									{
										var startExpr = `;
										var endExpr = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ERange(buildExpr(startExpr), buildExpr(endExpr), false);
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										};
									};
								} else {
									buildExpr(e1);
								};
							} else {
								buildExpr(e1);
							};
						};
					};
				};
			} else {
				{
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
				};
			};
		};
		var varName = if (ir.elementPattern != null) {
			toSnakeCase(ir.elementPattern.varName);
		} else {
			"_item";
		};
		var generators = [{pattern : reflaxe.elixir.ast.EPattern.PVar(varName), expr : source}];
		var filters = [];
		{
			var ` = 0;
			var ` = ir.filters;
			while (` < `.length) {
				var filter = `[`];
				++ `;
				filters.push(filter.condition);
			};
		};
		var body = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, _, bodyExpr):
		buildExpr(bodyExpr);	
	case TWhile(_, bodyExpr, _):
		buildExpr(bodyExpr);	
	case _:
		if (ir.yield != null) {
			ir.yield.expr;
		} else {
			makeAST(ENil);
		};	
}) {
			var ` = ir.originalExpr.expr;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var bodyExpr = `;
						{
							buildExpr(bodyExpr);
						};
					};
				};
				default: {
					if (ir.yield != null) {
						ir.yield.expr;
					} else {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
						};
					};
				}
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFor(generators, filters, body, null, false), metadata : {}, pos : pos};
		};
	}

	static function emitEnumReduce(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		return reflaxe.elixir.ast.builders.LoopBuilder.emitSimpleLoop(ir, buildExpr, toSnakeCase);
	}

	static function emitSimpleLoop(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		@:ast(switch (ir.kind) {
	case ForRange | ForEach:
		return buildLegacyForFromIR(ir, buildExpr, toSnakeCase);	
	case While | DoWhile:
		return buildLegacyWhileFromIR(ir, buildExpr);	
	case _:
		return makeAST(ENil);	
}) {
			var ` = ir.kind;
			switch (enumIndex `) {
				case 0, 1: {
					{
						return reflaxe.elixir.ast.builders.LoopBuilder.buildLegacyForFromIR(ir, buildExpr, toSnakeCase);
					};
				};
				case 2, 3: {
					{
						return reflaxe.elixir.ast.builders.LoopBuilder.buildLegacyWhileFromIR(ir, buildExpr);
					};
				};
				default: {
					return {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					};
				}
			};
		};
	}

	static function buildLegacyFor(v:haxe.macro.TVar, e1:haxe.macro.TypedExpr, e2:haxe.macro.TypedExpr, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, extractPattern:haxe.macro.TypedExpr -> reflaxe.elixir.ast.EPattern, toSnakeCase:String -> String) {
		var varName = toSnakeCase(v.name);
		var pattern = reflaxe.elixir.ast.EPattern.PVar(varName);
		var expr = buildExpr(e1);
		var body = buildExpr(e2);
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : pattern, expr : expr}], [], body, null, false), metadata : {}, pos : pos};
		};
	}

	static function buildLegacyWhile(cond:reflaxe.elixir.ast.ElixirAST, body:reflaxe.elixir.ast.ElixirAST, normalWhile:Bool, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST) {
		var stream = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Stream"), metadata : {}, pos : pos};
			}, "iterate", [{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
			}, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar("n")], body : {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("n"), metadata : {}, pos : pos};
					}, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
					}), metadata : {}, pos : pos};
				}}]), metadata : {}, pos : pos};
			}]), metadata : {}, pos : pos};
		};
		var initAcc = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
				var this;
				this = reflaxe.elixir.ast.NameUtils.toSnakeCase("ok");
				cast this;
			});
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		var reducerBody = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EIf(cond, {
				var def = reflaxe.elixir.ast.ElixirASTDef.ETuple([{
					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
						var this;
						this = reflaxe.elixir.ast.NameUtils.toSnakeCase("cont");
						cast this;
					});
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}, {
					var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([body, {
						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
							var this;
							this = reflaxe.elixir.ast.NameUtils.toSnakeCase("ok");
							cast this;
						});
						var pos = null;
						{def : def, metadata : {}, pos : pos};
					}]);
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}]);
				var pos = null;
				{def : def, metadata : {}, pos : pos};
			}, {
				var def = reflaxe.elixir.ast.ElixirASTDef.ETuple([{
					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
						var this;
						this = reflaxe.elixir.ast.NameUtils.toSnakeCase("halt");
						cast this;
					});
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}, {
					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
						var this;
						this = reflaxe.elixir.ast.NameUtils.toSnakeCase("ok");
						cast this;
					});
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}]);
				var pos = null;
				{def : def, metadata : {}, pos : pos};
			});
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		var reducerFn = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PWildcard, reflaxe.elixir.ast.EPattern.PVar("acc")], body : reducerBody}]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
			}, "reduce_while", [stream, initAcc, reducerFn]), metadata : {}, pos : pos};
		};
	}

	static function buildLegacyForFromIR(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toSnakeCase:String -> String) {
		var varName = if (ir.elementPattern != null) {
			toSnakeCase(ir.elementPattern.varName);
		} else {
			"_item";
		};
		var source = @:ast(switch (ir.source) {
	case Range(start, end, _):
		makeAST(ERange(start, end, false));	
	case Collection(expr):
		expr;	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.source;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var start = `;
						var end = `;
						{
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERange(start, end, false), metadata : {}, pos : pos};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						var expr = `;
						{
							expr;
						};
					};
				};
				default: {
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					};
				}
			};
		};
		var body = @:ast(switch (ir.originalExpr.expr) {
	case TFor(_, _, bodyExpr):
		buildExpr(bodyExpr);	
	case _:
		makeAST(ENil);	
}) {
			var ` = ir.originalExpr.expr;
			if (enumIndex ` == 15) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var bodyExpr = `;
					{
						buildExpr(bodyExpr);
					};
				};
			} else {
				{
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
				};
			};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFor([{pattern : reflaxe.elixir.ast.EPattern.PVar(varName), expr : source}], [], body, null, false), metadata : {}, pos : pos};
		};
	}

	static function buildLegacyWhileFromIR(ir:reflaxe.elixir.ast.loop_ir.LoopIR, buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST) {
		var cond = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		};
		var body = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		};
		@:ast(switch (ir.originalExpr.expr) {
	case TWhile(condExpr, bodyExpr, _):
		cond = buildExpr(condExpr);
		body = buildExpr(bodyExpr);	
	case _:
}) {
			var ` = ir.originalExpr.expr;
			if (enumIndex ` == 17) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var condExpr = `;
					var bodyExpr = `;
					{
						cond = buildExpr(condExpr);
						body = buildExpr(bodyExpr);
					};
				};
			} else {};
		};
		return reflaxe.elixir.ast.builders.LoopBuilder.buildLegacyWhile(cond, body, true, buildExpr);
	}
}