class reflaxe.elixir.ElixirTyper {

	public function new() {
		this.typeCache = new haxe.ds.StringMap();
	}

	@:value(new Map())
	var typeCache:Map<String, String>;

	public function compileType(haxeType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		if (haxeType == null || haxeType.length == 0) {
			return "term()";
		};
		if ({
			var this = this.typeCache;
			cast this.exists(haxeType);
		}) {
			var cached = {
				var this = this.typeCache;
				cast this.get(haxeType);
			};
			return if (cached != null) {
				cached;
			} else {
				"any()";
			};
		};
		var result = this.compileTypeInternal(haxeType, context);
		{
			var this = this.typeCache;
			cast this.set(haxeType, result);
		};
		return result;
	}

	function compileTypeInternal(haxeType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		if (haxeType.indexOf("Null<", null) == 0) {
			var innerType = this.extractGenericType(haxeType);
			var innerElixirType = this.compileType(innerType, context);
			return "" + innerElixirType + " | nil";
		};
		if (haxeType.indexOf("Array<", null) == 0) {
			var elementType = this.extractGenericType(haxeType);
			var elementElixirType = this.compileType(elementType, context);
			return "list(" + elementElixirType + ")";
		};
		if (haxeType.indexOf("Map<", null) == 0) {
			var typeParams = this.extractMapTypes(haxeType);
			var keyType = this.compileType(typeParams.key, context);
			var valueType = this.compileType(typeParams.value, context);
			return "%{" + keyType + " => " + valueType + "}";
		};
		if ({
			var this = reflaxe.elixir.ElixirTyper.phoenixTypes;
			cast this.exists(haxeType);
		}) {
			var phoenixType = {
				var this = reflaxe.elixir.ElixirTyper.phoenixTypes;
				cast this.get(haxeType);
			};
			return if (phoenixType != null) {
				phoenixType;
			} else {
				"any()";
			};
		};
		if ({
			var this = reflaxe.elixir.ElixirTyper.ectoTypes;
			cast this.exists(haxeType);
		}) {
			var ectoType = {
				var this = reflaxe.elixir.ElixirTyper.ectoTypes;
				cast this.get(haxeType);
			};
			return if (ectoType != null) {
				ectoType;
			} else {
				"any()";
			};
		};
		return @:ast(switch (haxeType) {
	case "Int":
		"integer()";	
	case "Float":
		"float()";	
	case "Bool":
		"boolean()";	
	case "String":
		"String.t()";	
	case "Void":
		"nil";	
	case "Dynamic":
		"term()";	
	case _:
		handleComplexType(haxeType, context);	
}) switch (haxeType) {
			case "Bool": {
				{
					"boolean()";
				};
			};
			case "Dynamic": {
				{
					"term()";
				};
			};
			case "Float": {
				{
					"float()";
				};
			};
			case "Int": {
				{
					"integer()";
				};
			};
			case "String": {
				{
					"String.t()";
				};
			};
			case "Void": {
				{
					"nil";
				};
			};
			default: {
				this.handleComplexType(haxeType, context);
			}
		};
	}

	@:value({ indentLevel : 1 })
	public function generateFunctionSpec(funcName:String, paramTypes:Array<String>, returnType:String, context:Null<reflaxe.elixir.TypeContext> = null, indentLevel:Int = 1) {
		var `this = this;
		var elixirFuncName = reflaxe.elixir.ast.NameUtils.toSnakeCase(funcName);
		var elixirParamTypes = {
			var ` = [];
			{
				var ` = 0;
				var ` = paramTypes;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(type:String) {
						return `this.compileType(type, context);
					}(v));
				};
			};
			`;
		};
		var elixirReturnType = this.compileType(returnType, context);
		var indent = {
			var ` = [];
			{
				var ` = 0;
				var ` = indentLevel;
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var paramsStr = elixirParamTypes.join(", ");
		return indent + "@spec " + elixirFuncName + "(" + paramsStr + ") :: " + elixirReturnType;
	}

	@:value({ indentLevel : 1 })
	public function generateFunctionOverloadSpecs(funcName:String, overloads:Array<{ returns : String, params : Array<String> }>, context:Null<reflaxe.elixir.TypeContext> = null, indentLevel:Int = 1) {
		var specs = [];
		{
			var ` = 0;
			while (` < overloads.length) {
				var signature = overloads[`];
				++ `;
				specs.push(this.generateFunctionSpec(funcName, signature.params, signature.returns, context, indentLevel));
			};
		};
		return specs.join("\n");
	}

	@:value({ indentLevel : 1 })
	public function generateTypeDefinition(typeName:String, fields:Array<{ type : String, name : String }>, context:Null<reflaxe.elixir.TypeContext> = null, indentLevel:Int = 1) {
		var baseIndent = {
			var ` = [];
			{
				var ` = 0;
				var ` = indentLevel;
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var fieldIndent = {
			var ` = [];
			{
				var ` = 0;
				var ` = (indentLevel + 1);
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var result = baseIndent + "@type t() :: %__MODULE__{\n";
		{
			var ` = 0;
			var ` = fields.length;
			while (` < `) {
				var i = ` ++;
				var field = fields[i];
				var fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
				var fieldType = this.compileType(field.type, context);
				var comma = if ((i < fields.length - 1)) {
					",";
				} else {
					"";
				};
				result += fieldIndent + "" + fieldName + ": " + fieldType + comma + "\n";
			};
		};
		result += baseIndent + "}";
		return result;
	}

	@:value({ indentLevel : 1 })
	public function generateUnionTypeDefinition(typeName:String, variants:Array<String>, context:Null<reflaxe.elixir.TypeContext> = null, indentLevel:Int = 1) {
		var baseIndent = {
			var ` = [];
			{
				var ` = 0;
				var ` = indentLevel;
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var variantIndent = {
			var ` = [];
			{
				var ` = 0;
				var ` = (indentLevel + 1);
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var result = baseIndent + "@type t() ::\n";
		{
			var ` = 0;
			var ` = variants.length;
			while (` < `) {
				var i = ` ++;
				var variant = variants[i];
				var elixirType = this.compileType(variant, context);
				var separator = if ((i < variants.length - 1)) {
					" |";
				} else {
					"";
				};
				result += variantIndent + "" + elixirType + separator + "\n";
			};
		};
		return result;
	}

	@:value({ indentLevel : 1 })
	public function generateOpaqueTypeDefinition(typeName:String, baseType:String, context:Null<reflaxe.elixir.TypeContext> = null, indentLevel:Int = 1) {
		var baseIndent = {
			var ` = [];
			{
				var ` = 0;
				var ` = indentLevel;
				while (` < `) {
					var i = ` ++;
					`.push("  ");
				};
			};
			`;
		}.join("");
		var elixirBaseType = this.compileType(baseType, context);
		return baseIndent + "@opaque t() :: " + elixirBaseType;
	}

	public function isValidElixirType(typeStr:String) {
		if (typeStr == null || typeStr.length == 0) {
			return false;
		};
		var validPatterns = ["integer()", "float()", "boolean()", "String.t()", "nil", "list(", "%{", " | ", "term()", "any()", "atom()"];
		{
			var ` = 0;
			while (` < validPatterns.length) {
				var pattern = validPatterns[`];
				++ `;
				if (typeStr.indexOf(pattern, null) >= 0) {
					return true;
				};
			};
		};
		return false;
	}

	public function isHaxeType(typeStr:String) {
		if (typeStr == null || typeStr.length == 0) {
			return false;
		};
		var haxePatterns = ["Array<", "Map<", "Null<", "Int", "Float", "Bool", "String", "Void", "Dynamic"];
		{
			var ` = 0;
			while (` < haxePatterns.length) {
				var pattern = haxePatterns[`];
				++ `;
				if (typeStr.indexOf(pattern, null) >= 0) {
					return true;
				};
			};
		};
		if (typeStr.indexOf("String.t()", null) >= 0) {
			return false;
		};
		if (typeStr.indexOf("integer()", null) >= 0) {
			return false;
		};
		return true;
	}

	function extractGenericType(genericType:String) {
		var startIndex = genericType.indexOf("<", null) + 1;
		var endIndex = genericType.lastIndexOf(">", null);
		if (startIndex > 0 && endIndex > startIndex) {
			return genericType.substring(startIndex, endIndex);
		};
		return "any()";
	}

	function extractMapTypes(mapType:String) {
		var startIndex = mapType.indexOf("<", null) + 1;
		var endIndex = mapType.lastIndexOf(">", null);
		if (startIndex > 0 && endIndex > startIndex) {
			var typeParams = mapType.substring(startIndex, endIndex);
			var commaIndex = typeParams.indexOf(",", null);
			if (commaIndex > 0) {
				var keyType = StringTools.trim(typeParams.substring(0, commaIndex));
				var valueType = StringTools.trim(typeParams.substring(commaIndex + 1, null));
				return {key : keyType, value : valueType};
			};
		};
		return {key : "any()", value : "any()"};
	}

	function handleComplexType(haxeType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		if (haxeType.indexOf("->", null) > 0) {
			return this.compileFunctionType(haxeType, context);
		};
		if (haxeType.indexOf("{", null) == 0 && haxeType.indexOf("}", null) > 0) {
			return this.compileTupleType(haxeType, context);
		};
		if (haxeType.indexOf("<", null) > 0 && ! this.isBuiltinGeneric(haxeType)) {
			return this.compileGenericType(haxeType, context);
		};
		if (new EReg("^[A-Z]", "").match(haxeType)) {
			var moduleName = reflaxe.elixir.ast.NameUtils.getElixirModuleName(haxeType);
			return "" + moduleName + ".t()";
		};
		if (new EReg("^[a-z]", "").match(haxeType)) {
			if (haxeType.indexOf("(", null) > -1) {
				return haxeType;
			};
			return ":" + haxeType;
		};
		return "term()";
	}

	function compileFunctionType(funcType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		var `this = this;
		var arrowIndex = funcType.indexOf("->", null);
		if (arrowIndex < 0) {
			return "function()";
		};
		var paramsPart = StringTools.trim(funcType.substring(0, arrowIndex));
		var returnPart = StringTools.trim(funcType.substring(arrowIndex + 2, null));
		if (paramsPart.indexOf("(", null) == 0) {
			paramsPart = paramsPart.substring(1, paramsPart.length - 1);
		};
		var paramTypes = {
			var _this = paramsPart.split(",");
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(p:String) {
							return `this.compileType(StringTools.trim(p), context);
						}(v));
					};
				};
				`;
			};
		};
		var returnType = this.compileType(returnPart, context);
		var paramStr = paramTypes.join(", ");
		return "(" + paramStr + " -> " + returnType + ")";
	}

	function compileTupleType(tupleType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		var `this = this;
		var inner = tupleType.substring(1, tupleType.length - 1);
		var elementTypes = {
			var _this = inner.split(",");
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(t:String) {
							return `this.compileType(StringTools.trim(t), context);
						}(v));
					};
				};
				`;
			};
		};
		return "{" + elementTypes.join(", ") + "}";
	}

	function compileGenericType(genericType:String, context:Null<reflaxe.elixir.TypeContext> = null) {
		var `this = this;
		var baseType = genericType.substring(0, genericType.indexOf("<", null));
		var typeParams = this.extractGenericType(genericType);
		var moduleName = reflaxe.elixir.ast.NameUtils.getElixirModuleName(baseType);
		var paramTypes = {
			var _this = typeParams.split(",");
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(t:String) {
							return `this.compileType(StringTools.trim(t), context);
						}(v));
					};
				};
				`;
			};
		};
		return "" + moduleName + ".t(" + paramTypes.join(", ") + ")";
	}

	function isBuiltinGeneric(genericType:String) {
		var builtins = ["Array<", "Map<", "Null<"];
		{
			var ` = 0;
			while (` < builtins.length) {
				var builtin = builtins[`];
				++ `;
				if (genericType.indexOf(builtin, null) == 0) {
					return true;
				};
			};
		};
		return false;
	}

	public function clearCache() {
		{
			var this = this.typeCache;
			cast this.clear();
		};
	}

	public function getCacheStats() {
		var keys = [];
		for (key in {
			var this = this.typeCache;
			cast this.keys();
		}) {
			keys.push(key);
		};
		return {size : keys.length, keys : keys};
	}

	@:value(["Conn" => "Plug.Conn.t()", "Socket" => "Phoenix.Socket.t()", "LiveView" => "Phoenix.LiveView.t()", "Channel" => "Phoenix.Channel.t()", "Endpoint" => "Phoenix.Endpoint.t()"])
	static var phoenixTypes:Map<String, String> = {
		var ` = {
			{};
			new haxe.ds.StringMap();
		};
		{
			`.set("Conn", "Plug.Conn.t()");
		};
		{
			`.set("Socket", "Phoenix.Socket.t()");
		};
		{
			`.set("LiveView", "Phoenix.LiveView.t()");
		};
		{
			`.set("Channel", "Phoenix.Channel.t()");
		};
		{
			`.set("Endpoint", "Phoenix.Endpoint.t()");
		};
		`;
	};

	@:value(["Schema" => "Ecto.Schema.t()", "Changeset" => "Ecto.Changeset.t()", "Query" => "Ecto.Query.t()", "Repo" => "Ecto.Repo.t()"])
	static var ectoTypes:Map<String, String> = {
		var ` = {
			{};
			new haxe.ds.StringMap();
		};
		{
			`.set("Schema", "Ecto.Schema.t()");
		};
		{
			`.set("Changeset", "Ecto.Changeset.t()");
		};
		{
			`.set("Query", "Ecto.Query.t()");
		};
		{
			`.set("Repo", "Ecto.Repo.t()");
		};
		`;
	};
}