class reflaxe.elixir.ast.builders.ModuleBuilder {

	@:value(None)
	static var bootstrapStrategy:reflaxe.elixir.ast.builders.BootstrapStrategy = reflaxe.elixir.ast.builders.BootstrapStrategy.None;

	public static function getBootstrapStrategy() {
		return reflaxe.elixir.ast.builders.ModuleBuilder.bootstrapStrategy;
	}

	public static function setBootstrapStrategy(strategy:reflaxe.elixir.ast.builders.BootstrapStrategy) {
		reflaxe.elixir.ast.builders.ModuleBuilder.bootstrapStrategy = strategy;
	}

	public static function extractModuleName(classType:haxe.macro.ClassType) {
		if (classType.meta.has(":native")) {
			var nativeMeta = classType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		return s;	
	default:
}) {
					var ` = nativeMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									return s;
								};
							};
						} else {};
					} else {};
				};
			};
		};
		if (classType.meta.has(":application") && ! classType.meta.has(":native")) {
			return classType.name + ".Application";
		};
		return classType.name;
	}

	public static function buildClassModule(classType:haxe.macro.ClassType, fields:Array<reflaxe.elixir.ast.ElixirAST>, metadata:Null<reflaxe.elixir.ast.ElixirMetadata> = null) {
		var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
		var attributes = [];
		var moduleMetadata = if (metadata != null) {
			metadata;
		} else {};
		if (moduleMetadata.isException == true) {};
		var result = {def : reflaxe.elixir.ast.ElixirASTDef.EModule(moduleName, attributes, fields), metadata : moduleMetadata, pos : classType.pos};
		return result;
	}

	static function makeExceptionStructDefinition() {
		return {def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "defstruct", [{def : reflaxe.elixir.ast.ElixirASTDef.EKeywordList([{key : "message", value : {def : reflaxe.elixir.ast.ElixirASTDef.EString(""), metadata : {}, pos : null}}]), metadata : {}, pos : null}]), metadata : {}, pos : null};
	}

	static inline function makeAST(def:reflaxe.elixir.ast.ElixirASTDef) {
		return {def : def, metadata : {}, pos : null};
	}
}