class reflaxe.elixir.ast.transformers.LoopTransforms {

	static function transformChildrenManually(node:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (node.def) {
	case EIf(cond, thenBranch, elseBranch):
		return makeAST(EIf(transformer(cond), transformer(thenBranch), elseBranch != null ? transformer(elseBranch) : null));	
	case ECase(expr, clauses):
		return makeAST(ECase(transformer(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })));	
	case ECall(target, funcName, args):
		return makeAST(ECall(target != null ? transformer(target) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformer(a))));	
	case ERemoteCall(module, funcName, args):
		return makeAST(ERemoteCall(transformer(module), funcName, args.map(function(a) ->  @:implicitReturn return transformer(a))));	
	case EList(elements):
		return makeAST(EList(elements.map(function(e) ->  @:implicitReturn return transformer(e))));	
	case ETuple(elements):
		return makeAST(ETuple(elements.map(function(e) ->  @:implicitReturn return transformer(e))));	
	case EMap(pairs):
		return makeAST(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformer(p.key), value : transformer(p.value) })));	
	case EBinary(op, left, right):
		return makeAST(EBinary(op, transformer(left), transformer(right)));	
	case EUnary(op, expr):
		return makeAST(EUnary(op, transformer(expr)));	
	case EFn(clauses):
		return makeAST(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })));	
	case EDo(body):
		return makeAST(EDo(body.map(function(stmt) ->  @:implicitReturn return transformer(stmt))));	
	case EVar(_) | EAtom(_) | EInteger(_) | EFloat(_) | EString(_) | ENil:
		return node;	
	default:
		return node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformer(expr), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformer(cond), transformer(thenBranch), if ((elseBranch != null)) transformer(elseBranch) else null);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : transformer(v.key), value : transformer(v.value)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformer(target) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(transformer(module), funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformer(left), transformer(right));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, transformer(expr));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 32: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 33: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 34: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 36: {
					{
						return node;
					};
				};
				case 38: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({args : v.args, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var body = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EDo({
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					return node;
				}
			};
		};
	}

	@:value({ depth : 0, prefix : "" })
	static function dumpAST(ast:reflaxe.elixir.ast.ElixirAST, prefix:String = "", depth:Int = 0) {
		var indent = "";
		{
			var ` = 0;
			var ` = depth;
			while (` < `) {
				var i = ` ++;
				indent += "  ";
			};
		};
		@:ast(switch (ast.def) {
	case ERemoteCall(module, func, args):
		Sys.println(indent + prefix + "ERemoteCall:");
		Sys.println(indent + "  module: " + ElixirASTPrinter.print(module, 0));
		Sys.println(indent + "  func: " + func);
		Sys.println(indent + "  args (" + args.length + "):");
		for (i  in  0 ... args.length) {
			dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
		};	
	case ECall(target, func, args):
		Sys.println(indent + prefix + "ECall:");
		if (target != null) {
			Sys.println(indent + "  target: " + ElixirASTPrinter.print(target, 0));
		};
		Sys.println(indent + "  func: " + func);
		Sys.println(indent + "  args (" + args.length + "):");
		for (i  in  0 ... args.length) {
			dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
		};	
	case EString(s):
		Sys.println(indent + prefix + "EString: \"" + s + "\"");	
	case EBinary(op, left, right):
		Sys.println(indent + prefix + "EBinary: " + op);
		dumpAST(left, "left: ", depth + 1);
		dumpAST(right, "right: ", depth + 1);	
	case EVar(name):
		Sys.println(indent + prefix + "EVar: " + name);	
	case EInteger(n):
		Sys.println(indent + prefix + "EInteger: " + n);	
	case EFloat(f):
		Sys.println(indent + prefix + "EFloat: " + f);	
	case EAtom(a):
		Sys.println(indent + prefix + "EAtom: :" + a);	
	case EList(elements):
		Sys.println(indent + prefix + "EList (" + elements.length + " elements):");
		for (i  in  0 ... elements.length) {
			dumpAST(elements[i], "[" + i + "]: ", depth + 1);
		};	
	case ETuple(elements):
		Sys.println(indent + prefix + "ETuple (" + elements.length + " elements):");
		for (i  in  0 ... elements.length) {
			dumpAST(elements[i], "{" + i + "}: ", depth + 1);
		};	
	case EMap(pairs):
		Sys.println(indent + prefix + "EMap (" + pairs.length + " pairs):");
		for (i  in  0 ... pairs.length) {
			Sys.println(indent + "  pair[" + i + "]:");
			dumpAST(pairs[i].key, "key: ", depth + 2);
			dumpAST(pairs[i].value, "value: ", depth + 2);
		};	
	case EBlock(stmts):
		Sys.println(indent + prefix + "EBlock (" + stmts.length + " statements):");
		for (i  in  0 ... Std.int(Math.min(stmts.length, 5))) {
			dumpAST(stmts[i], "stmt[" + i + "]: ", depth + 1);
		};
		if (stmts.length > 5) {
			Sys.println(indent + "  ... and " + (stmts.length - 5) + " more statements");
		};	
	case ENil:
		Sys.println(indent + prefix + "ENil");	
	default:
		Sys.println(indent + prefix + "AST Node: " + Type.enumConstructor(ast.def));	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							Sys.println(indent + prefix + "EList (" + elements.length + " elements):");
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(elements[i], "[" + i + "]: ", depth + 1);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							Sys.println(indent + prefix + "ETuple (" + elements.length + " elements):");
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(elements[i], "{" + i + "}: ", depth + 1);
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							Sys.println(indent + prefix + "EMap (" + pairs.length + " pairs):");
							{
								var ` = 0;
								var ` = pairs.length;
								while (` < `) {
									var i = ` ++;
									Sys.println(indent + "  pair[" + i + "]:");
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(pairs[i].key, "key: ", depth + 2);
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(pairs[i].value, "value: ", depth + 2);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var func = `;
						var args = `;
						{
							Sys.println(indent + prefix + "ECall:");
							if (target != null) {
								Sys.println(indent + "  target: " + reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0));
							};
							Sys.println(indent + "  func: " + func);
							Sys.println(indent + "  args (" + args.length + "):");
							{
								var ` = 0;
								var ` = args.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
								};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							Sys.println(indent + prefix + "ERemoteCall:");
							Sys.println(indent + "  module: " + reflaxe.elixir.ast.ElixirASTPrinter.print(module, 0));
							Sys.println(indent + "  func: " + func);
							Sys.println(indent + "  args (" + args.length + "):");
							{
								var ` = 0;
								var ` = args.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							Sys.println(indent + prefix + "EBinary: " + Std.string(op));
							reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(left, "left: ", depth + 1);
							reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(right, "right: ", depth + 1);
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							Sys.println(indent + prefix + "EAtom: :" + a);
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							Sys.println(indent + prefix + "EString: \"" + s + "\"");
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var n = `;
						{
							Sys.println(indent + prefix + "EInteger: " + n);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Sys.println(indent + prefix + "EFloat: " + f);
						};
					};
				};
				case 36: {
					{
						Sys.println(indent + prefix + "ENil");
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							Sys.println(indent + prefix + "EVar: " + name);
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						{
							Sys.println(indent + prefix + "EBlock (" + stmts.length + " statements):");
							{
								var ` = 0;
								var ` = Std.int(Math.min(stmts.length, 5));
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(stmts[i], "stmt[" + i + "]: ", depth + 1);
								};
							};
							if (stmts.length > 5) {
								Sys.println(indent + "  ... and " + (stmts.length - 5) + " more statements");
							};
						};
					};
				};
				default: {
					Sys.println(indent + prefix + "AST Node: " + Type.enumConstructor(ast.def));
				}
			};
		};
	}

	public static function unrolledLoopTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		Sys.println("[XRay LoopTransforms] ============ UNROLLED LOOP TRANSFORM STARTED ============");
		var detectAndTransformUnrolledLoops = [null];
		detectAndTransformUnrolledLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EModule(name, attributes, body):
		trace("[XRay LoopTransforms] Found EModule: $name with ${body.length} body items");
		var transformedBody = body.map(function(b) ->  @:implicitReturn return detectAndTransformUnrolledLoops(b));
		return makeAST(EModule(name, attributes, transformedBody));	
	case EDefmodule(name, doBlock):
		trace("[XRay LoopTransforms] Found EDefmodule: $name");
		var transformedBlock = detectAndTransformUnrolledLoops(doBlock);
		return makeAST(EDefmodule(name, transformedBlock));	
	case EDef(name, args, guards, body):
		trace("[XRay LoopTransforms] Found EDef (public function): $name");
		var transformedBody = detectAndTransformUnrolledLoops(body);
		return makeAST(EDef(name, args, guards, transformedBody));	
	case EDefp(name, args, guards, body):
		trace("[XRay LoopTransforms] Found EDefp (private function): $name");
		var transformedBody = detectAndTransformUnrolledLoops(body);
		return makeAST(EDefp(name, args, guards, transformedBody));	
	case EBlock(stmts):
		if (stmts.length > 2) {
			Sys.println("[XRay LoopTransforms] Found EBlock with " + stmts.length + " statements");
			var maxToShow = stmts.length < 3 ? stmts.length : 3;
			for (i  in  0 ... maxToShow) {
				Sys.println("[XRay LoopTransforms]   Statement " + i + " type: " + stmts[i].def);
			};
		};
		var nestedLoop = NestedLoopDetector.detectNestedLoop(stmts);
		if (nestedLoop != null) {
			trace("[XRay LoopTransforms] ✅ DETECTED NESTED LOOP - transforming ${nestedLoop.count} statements");
			var remainingStmts = stmts.slice(nestedLoop.count);
			if (remainingStmts.length > 0) {
				var processedRemaining = remainingStmts.map(function(stmt) ->  @:implicitReturn return detectAndTransformUnrolledLoops(stmt));
				return makeAST(EBlock([nestedLoop.transformed].concat(processedRemaining)));
			};
			return nestedLoop.transformed;
		};
		var unrolledLoop = detectUnrolledLoop(stmts);
		if (unrolledLoop != null) {
			trace("[XRay LoopTransforms] ✅ DETECTED UNROLLED LOOP - transforming ${stmts.length} statements");
			return unrolledLoop;
		} else {
			trace("[XRay LoopTransforms] ❌ Not an unrolled loop pattern");
		};
		var transformedStmts = stmts.map(function(stmt) ->  @:implicitReturn return detectAndTransformUnrolledLoops(stmt));
		return makeAST(EBlock(transformedStmts));	
	default:
		return transformChildrenManually(node, detectAndTransformUnrolledLoops);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EModule: " + name + " with " + body.length + " body items", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 235, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = {
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(b:reflaxe.elixir.ast.ElixirAST) {
												return detectAndTransformUnrolledLoops[0](b);
											}(v));
										};
									};
									`;
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDefmodule: " + name, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 240, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBlock = detectAndTransformUnrolledLoops[0](doBlock);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformedBlock), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDef (public function): " + name, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 246, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = detectAndTransformUnrolledLoops[0](body);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDefp (private function): " + name, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 251, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = detectAndTransformUnrolledLoops[0](body);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								if (stmts.length > 2) {
									Sys.println("[XRay LoopTransforms] Found EBlock with " + stmts.length + " statements");
									var maxToShow = if (stmts.length < 3) {
										stmts.length;
									} else {
										3;
									};
									{
										var ` = 0;
										var ` = maxToShow;
										while (` < `) {
											var i = ` ++;
											Sys.println("[XRay LoopTransforms]   Statement " + i + " type: " + Std.string(stmts[i].def));
										};
									};
								};
								var nestedLoop = reflaxe.elixir.ast.transformers.NestedLoopDetector.detectNestedLoop(stmts);
								if (nestedLoop != null) {
									haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED NESTED LOOP - transforming " + nestedLoop.count + " statements", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 270, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
									var remainingStmts = stmts.slice(nestedLoop.count, null);
									if (remainingStmts.length > 0) {
										var processedRemaining = {
											var ` = [];
											{
												var ` = 0;
												var ` = remainingStmts;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(function(stmt:reflaxe.elixir.ast.ElixirAST) {
														return detectAndTransformUnrolledLoops[0](stmt);
													}(v));
												};
											};
											`;
										};
										return {
											var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([nestedLoop.transformed].concat(processedRemaining));
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										};
									};
									return nestedLoop.transformed;
								};
								var unrolledLoop = reflaxe.elixir.ast.transformers.LoopTransforms.detectUnrolledLoop(stmts);
								if (unrolledLoop != null) {
									haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED UNROLLED LOOP - transforming " + stmts.length + " statements", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 283, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
									return unrolledLoop;
								} else {
									haxe.Log.trace("[XRay LoopTransforms] ❌ Not an unrolled loop pattern", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 286, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								};
								var transformedStmts = {
									var ` = [];
									{
										var ` = 0;
										var ` = stmts;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(stmt:reflaxe.elixir.ast.ElixirAST) {
												return detectAndTransformUnrolledLoops[0](stmt);
											}(v));
										};
									};
									`;
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedStmts), metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						return reflaxe.elixir.ast.transformers.LoopTransforms.transformChildrenManually(node, detectAndTransformUnrolledLoops[0]);
					}
				};
			};
		};
		return detectAndTransformUnrolledLoops[0](ast);
	}

	static function detectUnrolledLoop(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (stmts.length < 2) {
			return null;
		};
		Sys.println("[XRay LoopTransforms] detectUnrolledLoop: Analyzing " + stmts.length + " statements");
		var i = 0;
		var transformedStmts = [];
		while (i < stmts.length) {
			var loopGroup = reflaxe.elixir.ast.transformers.LoopTransforms.detectLoopGroup(stmts, i);
			if (loopGroup != null) {
				haxe.Log.trace("[XRay LoopTransforms] ✅ Found loop group at position " + i + " with " + loopGroup.count + " iterations", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 324, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
				transformedStmts.push(loopGroup.transformed);
				i += loopGroup.count;
			} else {
				transformedStmts.push(stmts[i]);
				i ++;
			};
		};
		if (transformedStmts.length != stmts.length) {
			haxe.Log.trace("[XRay LoopTransforms] Transformed block: " + stmts.length + " statements → " + transformedStmts.length + " statements", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 336, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedStmts), metadata : {}, pos : pos};
			};
		};
		return null;
	}

	static function detectLoopGroup(stmts:Array<reflaxe.elixir.ast.ElixirAST>, startIdx:Int) {
		if (startIdx >= stmts.length) {
			return null;
		};
		var firstCall = reflaxe.elixir.ast.transformers.LoopTransforms.extractFunctionCall(stmts[startIdx]);
		if (firstCall == null) {
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] detectLoopGroup: Checking from index " + startIdx + ", first call: " + firstCall.module + "." + firstCall.func, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 353, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		var count = 0;
		var expectedIndex = 0;
		{
			var ` = startIdx;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				var call = reflaxe.elixir.ast.transformers.LoopTransforms.extractFunctionCall(stmts[i]);
				if (call == null || call.module != firstCall.module || call.func != firstCall.func) {
					break;
				};
				if (call.args.length > 0) {
					var hasExpectedIndex = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(call.args[0], expectedIndex);
					if (! hasExpectedIndex) {
						break;
					};
					haxe.Log.trace("[XRay LoopTransforms]   ✓ Statement " + i + " matches with index " + expectedIndex, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 374, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
				};
				count ++;
				expectedIndex ++;
			};
		};
		if (count < 2) {
			haxe.Log.trace("[XRay LoopTransforms] detectLoopGroup: Only " + count + " matching statements, not enough for a loop", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 383, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED LOOP GROUP: " + firstCall.module + "." + firstCall.func + " with " + count + " iterations", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 387, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		var transformed = reflaxe.elixir.ast.transformers.LoopTransforms.transformToEnumEach(firstCall, count);
		return {transformed : transformed, count : count};
	}

	static function checkForIndex(ast:reflaxe.elixir.ast.ElixirAST, expectedIndex:Int) {
		haxe.Log.trace("[XRay LoopTransforms] checkForIndex: Looking for index " + expectedIndex + " in " + Std.string(ast.def), {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 402, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
		@:ast(switch (ast.def) {
	case EString(s):
		var exactPattern = "Iteration " + expectedIndex;
		if (s == exactPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT match found: \"" + s + "\"");
			return true;
		};
		var interpolationPattern = "Iteration #{" + expectedIndex + "}";
		if (s == interpolationPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT interpolation match: \"" + s + "\"");
			return true;
		};
		var placeholderPattern = "#{" + expectedIndex + "}";
		if (s == placeholderPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT placeholder match: \"" + s + "\"");
			return true;
		};
		var indexStr = Std.string(expectedIndex);
		if (s == indexStr) {
			trace("[XRay LoopTransforms]   ✓ EXACT index string match: \"" + s + "\"");
			return true;
		};
		if (s.indexOf(exactPattern) != -1 || s.indexOf(interpolationPattern) != -1 || s.indexOf(placeholderPattern) != -1) {
			trace("[XRay LoopTransforms]   ✓ Found index via contains fallback in: \"" + s + "\"");
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ No match in string: \"" + s + "\"");
		return false;	
	case EBinary(StringConcat, left, right):
		var leftHas = checkForIndex(left, expectedIndex);
		var rightHas = checkForIndex(right, expectedIndex);
		if (leftHas || rightHas) {
			trace("[XRay LoopTransforms]   ✓ Found index in binary concat");
		};
		return leftHas || rightHas;	
	case EInteger(n):
		if (n == expectedIndex) {
			trace("[XRay LoopTransforms]   ✓ Found exact index as integer: " + n);
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ Integer " + n + " does not match expected " + expectedIndex);
		return false;	
	case EVar(name):
		var indexStr = Std.string(expectedIndex);
		if (name == indexStr || name == "i" + indexStr) {
			trace("[XRay LoopTransforms]   ✓ Found index in variable name: " + name);
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ Variable " + name + " does not match index");
		return false;	
	case ERaw(rawString):
		var indexStr = Std.string(expectedIndex);
		var patterns = ["Iteration #{" + indexStr + "}", "#{" + indexStr + "}", "Iteration " + indexStr, "Value: #{" + indexStr + "}", "Pair: #{" + indexStr + "}"];
		for (pattern  in  patterns) {
			if (rawString.indexOf(pattern) != -1) {
				trace("[XRay LoopTransforms]   ✓ Found index in ERaw string: \"" + rawString + "\" (matched: \"" + pattern + "\")");
				return true;
			};
		};
		var interpolationPattern = "#{" + indexStr + "}";
		if (rawString.indexOf(interpolationPattern) != -1) {
			trace("[XRay LoopTransforms]   ✓ Found index interpolation in ERaw: \"" + rawString + "\"");
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ No index " + expectedIndex + " found in ERaw: \"" + rawString + "\"");
		return false;	
	default:
		trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def));
		return false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								var leftHas = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(left, expectedIndex);
								var rightHas = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(right, expectedIndex);
								if (leftHas || rightHas) {
									haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in binary concat", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 452, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								};
								return leftHas || rightHas;
							};
						};
					} else {
						haxe.Log.trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def), {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 509, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
						return false;
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							var exactPattern = "Iteration " + expectedIndex;
							if (s == exactPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT match found: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 409, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var interpolationPattern = "Iteration #{" + expectedIndex + "}";
							if (s == interpolationPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT interpolation match: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 416, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var placeholderPattern = "#{" + expectedIndex + "}";
							if (s == placeholderPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT placeholder match: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 423, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var indexStr = Std.string(expectedIndex);
							if (s == indexStr) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT index string match: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 430, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							if (s.indexOf(exactPattern, null) != -1 || s.indexOf(interpolationPattern, null) != -1 || s.indexOf(placeholderPattern, null) != -1) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index via contains fallback in: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 439, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ No match in string: \"" + s + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 443, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var n = `;
						{
							if (n == expectedIndex) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found exact index as integer: " + n, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 459, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ Integer " + n + " does not match expected " + expectedIndex, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 462, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							var indexStr = Std.string(expectedIndex);
							if (name == indexStr || name == "i" + indexStr) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in variable name: " + name, {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 470, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ Variable " + name + " does not match index", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 473, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var rawString = `;
						{
							var indexStr = Std.string(expectedIndex);
							var patterns = ["Iteration #{" + indexStr + "}", "#{" + indexStr + "}", "Iteration " + indexStr, "Value: #{" + indexStr + "}", "Pair: #{" + indexStr + "}"];
							{
								var ` = 0;
								while (` < patterns.length) {
									var pattern = patterns[`];
									++ `;
									if (rawString.indexOf(pattern, null) != -1) {
										haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in ERaw string: \"" + rawString + "\" (matched: \"" + pattern + "\")", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 492, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
										return true;
									};
								};
							};
							var interpolationPattern = "#{" + indexStr + "}";
							if (rawString.indexOf(interpolationPattern, null) != -1) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index interpolation in ERaw: \"" + rawString + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 500, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ No index " + expectedIndex + " found in ERaw: \"" + rawString + "\"", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 504, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				default: {
					haxe.Log.trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def), {fileName : "../../../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 509, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
					return false;
				}
			};
		};
	}

	static function extractFunctionCall(ast:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (ast.def) {
	case ERemoteCall({ def : EVar(module) }, funcName, args):
		return { module : module, func : funcName, args : args };	
	case ECall(target, funcName, args):
		return { module : "", func : funcName, args : args };	
	default:
		return null;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							return {module : "", func : funcName, args : args};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var module = `;
								var funcName = `;
								var args = `;
								{
									return {module : module, func : funcName, args : args};
								};
							};
						} else {
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function transformToEnumEach(callInfo:{ module : String, func : String, args : Array<reflaxe.elixir.ast.ElixirAST> }, count:Int) {
		var range = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
			}, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(count - 1), metadata : {}, pos : pos};
			}, false), metadata : {}, pos : pos};
		};
		var loopVar = "i";
		var bodyArgs = [];
		if (callInfo.args.length > 0) {
			var firstArg = callInfo.args[0];
			var transformedArg = @:ast(switch (firstArg.def) {
	case ERaw(s):
		var pattern = ~/#{[0-9]+}/;
		var replaced = pattern.replace(s, "#{" + loopVar + "}");
		makeAST(ERaw(replaced));	
	case EString(s):
		makeAST(ERaw(s + "#{" + loopVar + "}"));	
	default:
		makeAST(ERaw("Iteration #{" + loopVar + "}"));	
}) {
				var ` = firstArg.def;
				switch (enumIndex `) {
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(s + "#{" + loopVar + "}"), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var s = `;
							{
								var pattern = new EReg("#{[0-9]+}", "");
								var replaced = pattern.replace(s, "#{" + loopVar + "}");
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(replaced), metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("Iteration #{" + loopVar + "}"), metadata : {}, pos : pos};
						};
					}
				};
			};
			bodyArgs.push(transformedArg);
			{
				var ` = 1;
				var ` = callInfo.args.length;
				while (` < `) {
					var i = ` ++;
					bodyArgs.push(callInfo.args[i]);
				};
			};
		};
		var body = if (callInfo.module != "") {
			{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(callInfo.module), metadata : {}, pos : pos};
				}, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		} else {
			{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		};
		var clause = {args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], body : body};
		var func = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([clause]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
			}, "each", [range, func]), metadata : {}, pos : pos};
		};
	}

	public static function whileLoopTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformWhileLoops = [null];
		transformWhileLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall({ def : EVar("Enum") }, "reduce_while", args) if (args.length >= 3):
		var hasEmptyBody = switch (args[2].def) {
			case EFn(clauses) if (clauses.length > 0):
				switch (clauses[0].body.def) {
					case ENil:
						true;					
					case EBlock([]):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};
		if (hasEmptyBody) {
			return makeAST(ENil);
		};
		return ElixirASTTransformer.transformNode(node, transformWhileLoops);	
	default:
		return ElixirASTTransformer.transformNode(node, transformWhileLoops);	
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							if (` == "Enum") {
								if (` == "reduce_while") {
									{
										var args = `;
										if (args.length >= 3) {
											var hasEmptyBody = @:ast(switch (args[2].def) {
	case EFn(clauses) if (clauses.length > 0):
		switch (clauses[0].body.def) {
			case ENil:
				true;			
			case EBlock([]):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
												var ` = args[2].def;
												if (enumIndex ` == 42) {
													var ` = `[0];
													{
														var clauses = `;
														if (clauses.length > 0) {
															@:ast(switch (clauses[0].body.def) {
	case ENil:
		true;	
	case EBlock([]):
		true;	
	default:
		false;	
}) {
																var ` = clauses[0].body.def;
																switch (enumIndex `) {
																	case 36: {
																		{
																			true;
																		};
																	};
																	case 53: {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				true;
																			};
																		} else {
																			false;
																		};
																	};
																	default: {
																		false;
																	}
																};
															};
														} else {
															false;
														};
													};
												} else {
													false;
												};
											};
											if (hasEmptyBody) {
												return {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
												};
											};
											return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
										} else {
											return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
										};
									};
								} else {
									return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
								};
							} else {
								return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
							};
						} else {
							return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
						};
					};
				} else {
					return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
				};
			};
		};
		return transformWhileLoops[0](ast);
	}
}