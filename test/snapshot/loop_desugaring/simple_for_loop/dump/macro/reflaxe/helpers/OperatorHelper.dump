class reflaxe.helpers.OperatorHelper {

	public static function binopToString(op:haxe.macro.Binop) {
		return @:ast(switch (op) {
	case OpAdd:
		"+";	
	case OpMult:
		"*";	
	case OpDiv:
		"/";	
	case OpSub:
		"-";	
	case OpAssign:
		"=";	
	case OpEq:
		"==";	
	case OpNotEq:
		"!=";	
	case OpGt:
		">";	
	case OpGte:
		">=";	
	case OpLt:
		"<";	
	case OpLte:
		"<=";	
	case OpAnd:
		"&";	
	case OpOr:
		"|";	
	case OpXor:
		"^";	
	case OpBoolAnd:
		"&&";	
	case OpBoolOr:
		"||";	
	case OpShl:
		"<<";	
	case OpShr:
		">>";	
	case OpUShr:
		">>>";	
	case OpMod:
		"%";	
	case OpAssignOp(assignOp):
		binopToString(assignOp) + "=";	
	case OpInterval:
		"...";	
	case OpArrow:
		"=>";	
	case OpIn:
		"in";	
	case OpNullCoal:
		"??";	
}) switch (@:exhaustive enumIndex op) {
			case 0: {
				{
					"+";
				};
			};
			case 1: {
				{
					"*";
				};
			};
			case 2: {
				{
					"/";
				};
			};
			case 3: {
				{
					"-";
				};
			};
			case 4: {
				{
					"=";
				};
			};
			case 5: {
				{
					"==";
				};
			};
			case 6: {
				{
					"!=";
				};
			};
			case 7: {
				{
					">";
				};
			};
			case 8: {
				{
					">=";
				};
			};
			case 9: {
				{
					"<";
				};
			};
			case 10: {
				{
					"<=";
				};
			};
			case 11: {
				{
					"&";
				};
			};
			case 12: {
				{
					"|";
				};
			};
			case 13: {
				{
					"^";
				};
			};
			case 14: {
				{
					"&&";
				};
			};
			case 15: {
				{
					"||";
				};
			};
			case 16: {
				{
					"<<";
				};
			};
			case 17: {
				{
					">>";
				};
			};
			case 18: {
				{
					">>>";
				};
			};
			case 19: {
				{
					"%";
				};
			};
			case 20: {
				var ` = op[0];
				{
					var assignOp = `;
					{
						reflaxe.helpers.OperatorHelper.binopToString(assignOp) + "=";
					};
				};
			};
			case 21: {
				{
					"...";
				};
			};
			case 22: {
				{
					"=>";
				};
			};
			case 23: {
				{
					"in";
				};
			};
			case 24: {
				{
					"??";
				};
			};
		};
	}

	public static function isEqualityCheck(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpEq | OpNotEq:
		true;	
	case _:
		false;	
}) switch (enumIndex op) {
		case 5, 6: {
			{
				true;
			};
		};
		default: {
			false;
		}
	}

	public static function isAssign(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpAssign | OpAssignOp(_):
		true;	
	case _:
		false;	
}) switch (enumIndex op) {
		case 4: {
			{
				true;
			};
		};
		case 20: {
			var ` = op[0];
			{
				true;
			};
		};
		default: {
			false;
		}
	}

	public static function isAssignDirect(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpAssign:
		true;	
	case _:
		false;	
}) if (enumIndex op == 4) {
		{
			true;
		};
	} else {
		false;
	}

	@:value({ innerOp : null })
	public static function isAssignOp(op:haxe.macro.Binop, innerOp:Null<haxe.macro.Binop> = null) return @:ast(switch (op) {
	case OpAssignOp(inner) if (innerOp == null || innerOp == inner):
		true;	
	case _:
		false;	
}) if (enumIndex op == 20) {
		var ` = op[0];
		{
			var inner = `;
			if (innerOp == null || innerOp == inner) {
				true;
			} else {
				false;
			};
		};
	} else {
		false;
	}

	public static function isAddition(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpAdd:
		true;	
	case _:
		false;	
}) if (enumIndex op == 0) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isSubtraction(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpSub:
		true;	
	case _:
		false;	
}) if (enumIndex op == 3) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isMultiplication(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpMult:
		true;	
	case _:
		false;	
}) if (enumIndex op == 1) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isDivision(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpDiv:
		true;	
	case _:
		false;	
}) if (enumIndex op == 2) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isGreaterThan(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpGt:
		true;	
	case _:
		false;	
}) if (enumIndex op == 7) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isGreaterThanOrEqual(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpGte:
		true;	
	case _:
		false;	
}) if (enumIndex op == 8) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isLessThan(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpLt:
		true;	
	case _:
		false;	
}) if (enumIndex op == 9) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isLessThanOrEqual(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpLte:
		true;	
	case _:
		false;	
}) if (enumIndex op == 10) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isEquals(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpEq:
		true;	
	case _:
		false;	
}) if (enumIndex op == 5) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isNotEquals(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpNotEq:
		true;	
	case _:
		false;	
}) if (enumIndex op == 6) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBoolAnd(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpBoolAnd:
		true;	
	case _:
		false;	
}) if (enumIndex op == 14) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBoolOr(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpBoolOr:
		true;	
	case _:
		false;	
}) if (enumIndex op == 15) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBitAnd(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpAnd:
		true;	
	case _:
		false;	
}) if (enumIndex op == 11) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBitOr(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpOr:
		true;	
	case _:
		false;	
}) if (enumIndex op == 12) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBitXOr(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpXor:
		true;	
	case _:
		false;	
}) if (enumIndex op == 13) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isShiftLeft(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpShl:
		true;	
	case _:
		false;	
}) if (enumIndex op == 16) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isShiftRight(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpShr:
		true;	
	case _:
		false;	
}) if (enumIndex op == 17) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isUnsignedShiftRight(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpUShr:
		true;	
	case _:
		false;	
}) if (enumIndex op == 18) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isModulus(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpMod:
		true;	
	case _:
		false;	
}) if (enumIndex op == 19) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isInterval(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpInterval:
		true;	
	case _:
		false;	
}) if (enumIndex op == 21) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isArrow(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpArrow:
		true;	
	case _:
		false;	
}) if (enumIndex op == 22) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isIn(op:haxe.macro.Binop) return @:ast(switch (op) {
	case OpIn:
		true;	
	case _:
		false;	
}) if (enumIndex op == 23) {
		{
			true;
		};
	} else {
		false;
	}

	public static function unopToString(op:haxe.macro.Unop) {
		return @:ast(switch (op) {
	case OpIncrement:
		"++";	
	case OpDecrement:
		"--";	
	case OpNot:
		"!";	
	case OpNeg:
		"-";	
	case OpNegBits:
		"~";	
	case OpSpread:
		"...";	
}) switch (@:exhaustive enumIndex op) {
			case 0: {
				{
					"++";
				};
			};
			case 1: {
				{
					"--";
				};
			};
			case 2: {
				{
					"!";
				};
			};
			case 3: {
				{
					"-";
				};
			};
			case 4: {
				{
					"~";
				};
			};
			case 5: {
				{
					"...";
				};
			};
		};
	}

	public static function isIncrement(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpIncrement:
		true;	
	case _:
		false;	
}) if (enumIndex op == 0) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isDecrement(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpDecrement:
		true;	
	case _:
		false;	
}) if (enumIndex op == 1) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBoolNot(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpNot:
		true;	
	case _:
		false;	
}) if (enumIndex op == 2) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isNegative(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpNeg:
		true;	
	case _:
		false;	
}) if (enumIndex op == 3) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isBitNegative(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpNegBits:
		true;	
	case _:
		false;	
}) if (enumIndex op == 4) {
		{
			true;
		};
	} else {
		false;
	}

	public static function isSpread(op:haxe.macro.Unop) return @:ast(switch (op) {
	case OpSpread:
		true;	
	case _:
		false;	
}) if (enumIndex op == 5) {
		{
			true;
		};
	} else {
		false;
	}
}