class reflaxe.preprocessors.implementations.WrapLambdaCaptureVariablesInArrayImpl {

	public function new(expr:haxe.macro.TypedExpr, wrapMetadata:Null<Array<String>>) {
		this.wrapMetadata = null;
		this.isInLambda = false;
		this.expr = expr;
		this.wrapMetadata = wrapMetadata;
		var _g = expr.expr;
		var tmp;
		if ((enumIndex _g == 14)) {
			var exprs = _g[0];
			var _g = [];
			{
				var _g1 = 0;
				var _g2 = exprs;
				while ((_g1 < _g2.length)) {
					var v = _g2[_g1];
					++ _g1;
					_g.push((function(e:haxe.macro.TypedExpr) {
						return reflaxe.helpers.TypedExprHelper.copy(e, null);
					})(v));
				};
			};
			tmp = _g;
		} else tmp = [reflaxe.helpers.TypedExprHelper.copy(expr, null)];
		this.exprList = tmp;
		this.nonLambdaVars = new haxe.ds.IntMap();
		this.arrayWrapVarIds = [];
		this.tempPos = reflaxe.helpers.PositionHelper.unknownPos();
	}

	var expr:haxe.macro.TypedExpr;

	var exprList:Array<haxe.macro.TypedExpr>;

	@:value(false)
	var isInLambda:Bool;

	var nonLambdaVars:Map<Int, haxe.macro.TVar>;

	var arrayWrapVarIds:Array<Int>;

	@:value(null)
	var wrapMetadata:Null<Array<String>>;

	var tempPos:haxe.macro.Position;

	public function fixCaptures() {
		{
			var ` = 0;
			var ` = this.exprList;
			while (` < `.length) {
				var e = `[`];
				++ `;
				this.fixCaptureExpr(e);
			};
		};
		{
			var ` = 0;
			var ` = this.exprList;
			while (` < `.length) {
				var e = `[`];
				++ `;
				this.addMetaToLocals(e);
			};
		};
		return {expr : haxe.macro.TypedExprDef.TBlock(this.exprList), pos : this.expr.pos, t : this.expr.t};
	}

	function fixCaptureExpr(e:haxe.macro.TypedExpr) {
		@:ast(switch (e.expr) {
	case TFunction(tfunc):
		{
			var original = isInLambda;
			isInLambda = true;
			haxe.macro.TypedExprTools.iter(e, fixCaptureExpr);
			isInLambda = original;
		};	
	case TVar(tvar, _):
		{
			if (!isInLambda && !nonLambdaVars.exists(tvar.id)) {
				nonLambdaVars.set(tvar.id, tvar);
			};
		};	
	case TLocal(tvar):
		{
			if (isInLambda && nonLambdaVars.exists(tvar.id)) {
				nonLambdaVars.remove(tvar.id);
				arrayWrapVarIds.push(tvar.id);
			};
		};	
	case _:
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var tvar = `;
						{
							{
								if (this.isInLambda && {
									var this = this.nonLambdaVars;
									var key = tvar.id;
									cast this.exists(key);
								}) {
									{
										var this = this.nonLambdaVars;
										var key = tvar.id;
										cast this.remove(key);
									};
									this.arrayWrapVarIds.push(tvar.id);
								};
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var tfunc = `;
						{
							{
								var original = this.isInLambda;
								this.isInLambda = true;
								haxe.macro.TypedExprTools.iter(e, this.fixCaptureExpr);
								this.isInLambda = original;
							};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var tvar = `;
						{
							{
								if (! this.isInLambda && ! {
									var this = this.nonLambdaVars;
									var key = tvar.id;
									cast this.exists(key);
								}) {
									{
										var this = this.nonLambdaVars;
										var key = tvar.id;
										cast this.set(key, tvar);
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		haxe.macro.TypedExprTools.iter(e, this.fixCaptureExpr);
	}

	function addMetaToLocals(e:haxe.macro.TypedExpr) {
		var typeAndTVar = @:ast(switch (e.expr) {
	case TLocal(tvar):
		{ type : e.t, tvar : tvar };	
	case TVar(tvar, _):
		{ type : tvar.t, tvar : tvar };	
	case _:
		null;	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var tvar = `;
						{
							{type : e.t, tvar : tvar};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var tvar = `;
						{
							{type : tvar.t, tvar : tvar};
						};
					};
				};
				default: {
					null;
				}
			};
		};
		if (typeAndTVar != null) {
			var tvar = typeAndTVar.tvar;
			var t = typeAndTVar.type;
			if (t != null && this.isWrapType(t) && this.arrayWrapVarIds.contains(tvar.id)) {
				reflaxe.helpers.NullableMetaAccessHelper.maybeAdd(tvar.meta, ":arrayWrap", [], this.tempPos);
			};
		};
		haxe.macro.TypedExprTools.iter(e, this.addMetaToLocals);
	}

	function isWrapType(t:haxe.macro.Type) {
		if (reflaxe.helpers.TypeHelper.isPrimitive(t)) {
			return true;
		};
		if (this.wrapMetadata != null) {
			var m = reflaxe.helpers.TypeHelper.getMeta(t);
			if (m != null) {
				{
					var ` = 0;
					var ` = this.wrapMetadata;
					while (` < `.length) {
						var metaName = `[`];
						++ `;
						if (m.has(metaName)) {
							return true;
						};
					};
				};
			};
		};
		return false;
	}
}