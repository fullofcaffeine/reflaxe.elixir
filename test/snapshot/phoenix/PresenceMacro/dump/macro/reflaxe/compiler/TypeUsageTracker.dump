class reflaxe.compiler.TypeUsageTracker {

	static var functionType:Null<haxe.macro.Type>;

	public static function init() {
		{
			var ` = 0;
			var ` = haxe.macro.Context.getModule("haxe.Function");
			while (` < `.length) {
				var funcType = `[`];
				++ `;
				@:ast(switch (funcType) {
	case TAbstract(t, params):
		{
			if (t.get().name == "Function") {
				functionType = funcType;
			};
		};	
	case _:
		{ };	
}) if (enumIndex funcType == 8) {
					var ` = funcType[0];
					var ` = funcType[1];
					{
						var t = `;
						var params = `;
						{
							{
								if (t.get().name == "Function") {
									reflaxe.compiler.TypeUsageTracker.functionType = funcType;
								};
							};
						};
					};
				} else {
					{};
				};
			};
		};
	}

	public static function trackTypesInModuleType(moduleType:haxe.macro.ModuleType) {
		var modules = {
			{};
			new haxe.ds.StringMap();
		};
		var addType = [function(_:Null<haxe.macro.Type>, _:reflaxe.compiler.TypeUsageLevel) {}];
		var addToMap = function(id:String, data:{ m : reflaxe.compiler.TypeOrModuleType, level : Int }) {
			return if (! modules.exists(id)) {
				{
					modules.set(id, data);
				};
				true;
			} else {
				var m = cast modules.get(id);
				if (m != null && (m.level & data.level) == 0) {
					m.level |= data.level;
					true;
				} else {
					false;
				};
			};
		};
		var addModuleType = function(mt:Null<haxe.macro.ModuleType>, level:reflaxe.compiler.TypeUsageLevel) {
			if (mt == null) {
				return;
			};
			var id = reflaxe.helpers.ModuleTypeHelper.getUniqueId(mt);
			var newType = addToMap(id, {m : reflaxe.compiler.TypeOrModuleType.EModuleType(mt), level : cast level});
			if (newType) {
				@:ast(switch (mt) {
	case TAbstract(a):
		{
			addType(Context.followWithAbstracts(TypeHelper.fromModuleType(mt)), level);
		};	
	case _:
}) if (mt == null) {} else if (enumIndex mt == 3) {
					var ` = mt[0];
					{
						var a = `;
						{
							{
								addType[0](haxe.macro.Context.followWithAbstracts(reflaxe.helpers.TypeHelper.fromModuleType(mt), null), level);
							};
						};
					};
				} else {};
			};
		};
		addType[0] = function(t:Null<haxe.macro.Type>, level:reflaxe.compiler.TypeUsageLevel) {
			if (t == null) {
				return;
			};
			var typeMt = reflaxe.helpers.TypeHelper.toModuleType(t);
			if (typeMt != null) {
				addModuleType(typeMt, level);
			};
			@:ast(switch (t) {
	case TFun(_, _) | TAnonymous(_):
		{
			addToMap(t.getUniqueId(), { m : EType(t), level : level });
		};	
	case _:
		{ };	
}) if (t == null) {
				{};
			} else switch (enumIndex t) {
				case 4: {
					var ` = t[0];
					var ` = t[1];
					{
						{
							addToMap(reflaxe.helpers.TypeHelper.getUniqueId(t), {m : reflaxe.compiler.TypeOrModuleType.EType(t), level : cast level});
						};
					};
				};
				case 5: {
					var ` = t[0];
					{
						{
							addToMap(reflaxe.helpers.TypeHelper.getUniqueId(t), {m : reflaxe.compiler.TypeOrModuleType.EType(t), level : cast level});
						};
					};
				};
				default: {
					{};
				}
			};
			@:ast(switch (t) {
	case TFun(args, ret):
		{
			for (a  in  args) {
				addType(a.t, level);
			};
			addType(ret, level);
			if (functionType != null) {
				addType(functionType, level);
			};
		};	
	case TAnonymous(anonRef):
		{
			for (f  in  anonRef.get().fields) {
				addType(f.type, level);
			};
		};	
	case _:
		{ };	
}) if (t == null) {
				{};
			} else switch (enumIndex t) {
				case 4: {
					var ` = t[0];
					var ` = t[1];
					{
						var args = `;
						var ret = `;
						{
							{
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										addType[0](a.t, level);
									};
								};
								addType[0](ret, level);
								if (reflaxe.compiler.TypeUsageTracker.functionType != null) {
									addType[0](reflaxe.compiler.TypeUsageTracker.functionType, level);
								};
							};
						};
					};
				};
				case 5: {
					var ` = t[0];
					{
						var anonRef = `;
						{
							{
								{
									var ` = 0;
									var ` = anonRef.get().fields;
									while (` < `.length) {
										var f = `[`];
										++ `;
										addType[0](f.type, level);
									};
								};
							};
						};
					};
				};
				default: {
					{};
				}
			};
			var params = reflaxe.helpers.TypeHelper.getParams(t);
			if (params != null) {
				{
					var ` = 0;
					while (` < params.length) {
						var p = params[`];
						++ `;
						addType[0](p, level);
					};
				};
			};
		};
		var addFunction = function(t:haxe.macro.Type) {
			@:ast(switch (t) {
	case TFun(args, ret):
		{
			for (a  in  args) {
				addType(a.t, FunctionDeclaration);
			};
			addType(ret, FunctionDeclaration);
		};	
	case _:
		{ };	
}) if (enumIndex t == 4) {
				var ` = t[0];
				var ` = t[1];
				{
					var args = `;
					var ret = `;
					{
						{
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									addType[0](a.t, cast 16);
								};
							};
							addType[0](ret, cast 16);
						};
					};
				};
			} else {
				{};
			};
		};
		var addTypedExpr = [null];
		addTypedExpr[0] = function(te:haxe.macro.TypedExpr) {
			@:ast(switch (te.expr) {
	case TField(_, fa):
		{
			switch (fa) {
				case FStatic(clsRef, clsFieldRef):
					{
						addType(TypeHelper.fromModuleType(TClassDecl(clsRef)), StaticAccess);
					};				
				case _:
			};
		};	
	case _:
}) {
				var ` = te.expr;
				if (enumIndex ` == 4) {
					var ` = `[0];
					var ` = `[1];
					{
						var fa = `;
						{
							{
								@:ast(switch (fa) {
	case FStatic(clsRef, clsFieldRef):
		{
			addType(TypeHelper.fromModuleType(TClassDecl(clsRef)), StaticAccess);
		};	
	case _:
}) if (enumIndex fa == 1) {
									var ` = fa[0];
									var ` = fa[1];
									{
										var clsRef = `;
										var clsFieldRef = `;
										{
											{
												addType[0](reflaxe.helpers.TypeHelper.fromModuleType(haxe.macro.ModuleType.TClassDecl(clsRef)), cast 4);
											};
										};
									};
								} else {};
							};
						};
					};
				} else {};
			};
			@:ast(switch (te.expr) {
	case TNew(clsRef, params, el):
		{
			addType(TInst(clsRef, params), Constructed);
		};	
	case TVar(tvar, maybeExpr):
		{
			addType(tvar.t, VariableType);
		};	
	case _:
		{
			addType(te.t, Expression);
		};	
}) {
				var ` = te.expr;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var clsRef = `;
							var params = `;
							var el = `;
							{
								{
									addType[0](haxe.macro.Type.TInst(clsRef, params), cast 8);
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var tvar = `;
							var maybeExpr = `;
							{
								{
									addType[0](tvar.t, cast 2);
								};
							};
						};
					};
					default: {
						{
							addType[0](te.t, cast 1);
						};
					}
				};
			};
			haxe.macro.TypedExprTools.iter(te, addTypedExpr[0]);
		};
		var addClassField = function(clsField:haxe.macro.ClassField, isStatic:Bool = false) {
			var e = clsField.expr();
			if (e != null) {
				addTypedExpr[0](e);
			};
			@:ast(switch (clsField.kind) {
	case FVar(read, write):
		{
			addType(clsField.type, VariableDeclaration);
		};	
	case FMethod(k):
		{
			addFunction(clsField.type);
		};	
}) {
				var ` = clsField.kind;
				switch (@:exhaustive enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						{
							var read = `;
							var write = `;
							{
								{
									addType[0](clsField.type, cast 32);
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						{
							var k = `;
							{
								{
									addFunction(clsField.type);
								};
							};
						};
					};
				};
			};
		};
		@:ast(switch (moduleType) {
	case TClassDecl(c):
		{
			var cls = c.get();
			if (cls.superClass != null) {
				addModuleType(TClassDecl(cls.superClass.t), ExtendedFrom);
				for (t  in  cls.superClass.params) {
					addType(t, ExtendedFrom);
				};
			};
			for (i  in  cls.interfaces) {
				addModuleType(TClassDecl(i.t), ExtendedFrom);
				for (t  in  i.params) {
					addType(t, ExtendedFrom);
				};
			};
			if (cls.constructor != null) {
				addClassField(cls.constructor.get());
			};
			for (field  in  cls.fields.get()) {
				addClassField(field);
			};
			for (field  in  cls.statics.get()) {
				addClassField(field, true);
			};
		};	
	case TEnumDecl(e):
		{
			var enm = e.get();
			for (name => field  in  enm.constructs) {
				addFunction(field.type);
			};
		};	
	case TTypeDecl(defType):
		{
			addType(defType.get().type, ExtendedFrom);
		};	
	case TAbstract(a):
		{
			addType(Context.followWithAbstracts(TypeHelper.fromModuleType(moduleType)), ExtendedFrom);
		};	
}) switch (@:exhaustive enumIndex moduleType) {
			case 0: {
				var ` = moduleType[0];
				{
					var c = `;
					{
						{
							var cls = c.get();
							if (cls.superClass != null) {
								addModuleType(haxe.macro.ModuleType.TClassDecl(cls.superClass.t), cast 64);
								{
									var ` = 0;
									var ` = cls.superClass.params;
									while (` < `.length) {
										var t = `[`];
										++ `;
										addType[0](t, cast 64);
									};
								};
							};
							{
								var ` = 0;
								var ` = cls.interfaces;
								while (` < `.length) {
									var i = `[`];
									++ `;
									addModuleType(haxe.macro.ModuleType.TClassDecl(i.t), cast 64);
									{
										var ` = 0;
										var ` = i.params;
										while (` < `.length) {
											var t = `[`];
											++ `;
											addType[0](t, cast 64);
										};
									};
								};
							};
							if (cls.constructor != null) {
								addClassField(cls.constructor.get(), null);
							};
							{
								var ` = 0;
								var ` = cls.fields.get();
								while (` < `.length) {
									var field = `[`];
									++ `;
									addClassField(field, null);
								};
							};
							{
								var ` = 0;
								var ` = cls.statics.get();
								while (` < `.length) {
									var field = `[`];
									++ `;
									addClassField(field, true);
								};
							};
						};
					};
				};
			};
			case 1: {
				var ` = moduleType[0];
				{
					var e = `;
					{
						{
							var enm = e.get();
							{
								var ` = {
									var this = enm.constructs;
									cast new haxe.iterators.MapKeyValueIterator(cast this);
								};
								while (`.hasNext()) {
									var ` = `.next();
									var name = `.key;
									var field = `.value;
									{
										addFunction(field.type);
									};
								};
							};
						};
					};
				};
			};
			case 2: {
				var ` = moduleType[0];
				{
					var defType = `;
					{
						{
							addType[0](defType.get().type, cast 64);
						};
					};
				};
			};
			case 3: {
				var ` = moduleType[0];
				{
					var a = `;
					{
						{
							addType[0](haxe.macro.Context.followWithAbstracts(reflaxe.helpers.TypeHelper.fromModuleType(moduleType), null), cast 64);
						};
					};
				};
			};
		};
		var result = {
			{};
			new haxe.ds.IntMap();
		};
		{
			var ` = 0;
			var ` = reflaxe.compiler._TypeUsageTracker.TypeUsageLevel_Impl_.LevelCount();
			while (` < `) {
				var i = ` ++;
				var level = Std.int(Math.pow(2, i));
				{
					result.set(cast cast level, []);
				};
			};
		};
		{
			var ` = cast new haxe.iterators.MapKeyValueIterator(modules);
			while (`.hasNext()) {
				var ` = `.next();
				var id = `.key;
				var moduleData = `.value;
				{
					{
						var ` = 0;
						var ` = reflaxe.compiler._TypeUsageTracker.TypeUsageLevel_Impl_.LevelCount();
						while (` < `) {
							var i = ` ++;
							var level = Std.int(Math.pow(2, i));
							if ((moduleData.level & level) != 0) {
								var t = cast result.get(level);
								if (t != null) {
									t.push(moduleData.m);
								};
							};
						};
					};
				};
			};
		};
		return result;
	}
}