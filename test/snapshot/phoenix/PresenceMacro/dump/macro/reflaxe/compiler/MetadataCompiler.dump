class reflaxe.compiler.MetadataCompiler {

	public static function compileMetadata(options:reflaxe.BaseCompilerOptions, metaAccess:Null<haxe.macro.MetaAccess>, target:haxe.display.MetadataTarget) {
		if (metaAccess == null) {
			return null;
		};
		var compiledMeta = [];
		if (options.allowMetaMetadata && options.autoNativeMetaFormat != null) {
			var nativeMeta = reflaxe.helpers.NullableMetaAccessHelper.extractNativeMeta(metaAccess, null);
			if (nativeMeta != null) {
				{
					var ` = 0;
					while (` < nativeMeta.length) {
						var m = nativeMeta[`];
						++ `;
						var tempMeta = StringTools.replace(options.autoNativeMetaFormat, "{}", m);
						compiledMeta.push(tempMeta);
					};
				};
			};
		};
		{
			var ` = 0;
			var ` = options.metadataTemplates;
			while (` < `.length) {
				var template = `[`];
				++ `;
				var name = template.meta.metadata;
				var entries = metaAccess.extract(name);
				if (template.disallowMultiple && entries.length > 1) {
					reflaxe.compiler.MetadataCompiler.err("'@" + name + "' metadata can only be applied once.", entries[1].pos);
				};
				{
					var ` = 0;
					while (` < entries.length) {
						var e = entries[`];
						++ `;
						if (template.meta.targets != null && ! template.meta.targets.contains(target)) {
							reflaxe.compiler.MetadataCompiler.err("'@" + name + "' metadata expected to be used on " + Std.string(template.meta.targets) + " only.", e.pos);
						};
						var argsMatch = true;
						if (template.paramTypes != null) {
							var entryArgTypes = {
								var _this = (if (e.params == null) {
									[];
								} else {
									e.params;
								});
								var f = reflaxe.compiler.MetadataCompiler.getMetaArgInputType;
								{
									var ` = [];
									{
										var ` = 0;
										var ` = _this;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							};
							var paramTypes = {
								var _this = template.paramTypes;
								var f = reflaxe.compiler.MetadataCompiler.getMetaArgType;
								{
									var ` = [];
									{
										var ` = 0;
										var ` = _this;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							};
							if (entryArgTypes.length > paramTypes.length) {
								argsMatch = false;
								reflaxe.compiler.MetadataCompiler.err("Too many arguments supplied to meta '@" + name + "'.", e.pos);
							};
							{
								var ` = 0;
								var ` = paramTypes.length;
								while (` < `) {
									var i = ` ++;
									var matches = false;
									if (i < entryArgTypes.length) {
										if (paramTypes[i].t == "any" || paramTypes[i].t == entryArgTypes[i]) {
											matches = true;
										};
									};
									if (! matches && paramTypes[i].opt) {
										matches = true;
									};
									if (! matches) {
										argsMatch = false;
										var params = {
											var maybe = e.params;
											if (maybe != null) {
												maybe;
											} else {
												[];
											};
										};
										var pos = if (i < params.length) {
											params[i].pos;
										} else {
											e.pos;
										};
										reflaxe.compiler.MetadataCompiler.err("Metadata argument of type '" + paramTypes[i].t + "' expected.", pos);
									};
								};
							};
						};
						if (argsMatch) {
							if (template.compileFunc != null) {
								var args = {
									var _this = (if (e.params == null) {
										[];
									} else {
										e.params;
									});
									var f = haxe.macro.ExprTools.toString;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = _this;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								};
								var result = template.compileFunc(e, args);
								if (result != null) {
									compiledMeta.push(result);
								};
							};
						};
					};
				};
			};
		};
		return if (compiledMeta.length > 0) {
			compiledMeta.join("\n") + "\n";
		} else {
			"";
		};
	}

	static function err(msg:String, pos:haxe.macro.Position) {
		haxe.macro.Context.error(msg, pos, null);
	}

	static function getMetaArgInputType(e:haxe.macro.Expr) {
		return @:ast(switch (e.expr) {
	case EConst(CInt(_)) | EConst(CFloat(_)):
		"number";	
	case EConst(CString(_, _)):
		"string";	
	case EConst(CIdent("true")) | EConst(CIdent("false")):
		"bool";	
	case EConst(CIdent(_)):
		"ident";	
	case EArrayDecl(_):
		"array";	
	case _:
		"any";	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					switch (enumIndex `) {
						case 0: {
							var ` = `[0];
							var ` = `[1];
							{
								"number";
							};
						};
						case 1: {
							var ` = `[0];
							var ` = `[1];
							{
								"number";
							};
						};
						case 2: {
							var ` = `[0];
							var ` = `[1];
							{
								"string";
							};
						};
						case 3: {
							var ` = `[0];
							switch (`) {
								case "false", "true": {
									{
										"bool";
									};
								};
								default: {
									"ident";
								}
							};
						};
						default: {
							"any";
						}
					};
				};
				case 6: {
					var ` = `[0];
					{
						"array";
					};
				};
				default: {
					"any";
				}
			};
		};
	}

	static function getMetaArgType(arg:reflaxe.MetaArgumentType) {
		var opt = false;
		var s = (cast arg);
		if (StringTools.endsWith(arg, "?")) {
			opt = true;
			s = s.substring(0, s.length - 2);
		};
		return {t : s, opt : opt};
	}
}