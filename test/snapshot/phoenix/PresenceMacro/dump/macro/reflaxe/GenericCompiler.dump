class reflaxe.GenericCompiler<CompiledClassType, CompiledEnumType, CompiledExpressionType, CompiledTypedefType = { }, CompiledAbstractType = { }> extends reflaxe.BaseCompiler {

	public function new() {
		this.abstracts = [];
		this.typedefs = [];
		this.enums = [];
		this.classes = [];
		super();
	}

	public function compileClassImpl

	public function compileEnumImpl

	public function compileExpressionImpl

	public function compileTypedefImpl(typedefType:haxe.macro.DefType) {
		return null;
	}

	public function compileAbstractImpl(abstractType:haxe.macro.AbstractType) {
		return null;
	}

	@:value([])
	var classes:reflaxe.CompiledCollection<reflaxe.GenericCompiler.CompiledClassType>;

	@:value([])
	var enums:reflaxe.CompiledCollection<reflaxe.GenericCompiler.CompiledEnumType>;

	@:value([])
	var typedefs:reflaxe.CompiledCollection<reflaxe.GenericCompiler.CompiledTypedefType>;

	@:value([])
	var abstracts:reflaxe.CompiledCollection<reflaxe.GenericCompiler.CompiledAbstractType>;

	function generateCompiledCollection<T>(compiledObject:generateCompiledCollection.T, baseType:haxe.macro.BaseType) {
		var result = new reflaxe.output.DataAndFileInfo(compiledObject, baseType, this.fileNameOverride, this.fileDirOverride);
		this.fileNameOverride = null;
		this.fileDirOverride = null;
		return result;
	}

	public function compileClass(classType:haxe.macro.ClassType, varFields:Array<reflaxe.data.ClassVarData>, funcFields:Array<reflaxe.data.ClassFuncData>) {
		var data = {
			this.compileClassImpl(classType, varFields, funcFields);
		};
		if (data != null) {
			this.classes.push(this.generateCompiledCollection(cast cast {
				if (data == null) {
					throw "Trusted on null value.";
				};
				@:nullSafety(Off) data;
			}, classType));
		};
	}

	public function compileEnum(enumType:haxe.macro.EnumType, options:Array<reflaxe.data.EnumOptionData>) {
		var data = {
			this.compileEnumImpl(enumType, options);
		};
		if (data != null) {
			this.enums.push(this.generateCompiledCollection(cast cast {
				if (data == null) {
					throw "Trusted on null value.";
				};
				@:nullSafety(Off) data;
			}, enumType));
		};
	}

	public function compileTypedef(typedefType:haxe.macro.DefType) {
		var data = {
			this.compileTypedefImpl(typedefType);
		};
		if (data != null) {
			this.typedefs.push(this.generateCompiledCollection(cast cast {
				if (data == null) {
					throw "Trusted on null value.";
				};
				@:nullSafety(Off) data;
			}, typedefType));
		};
	}

	public function compileAbstract(abstractType:haxe.macro.AbstractType) {
		var data = {
			this.compileAbstractImpl(abstractType);
		};
		if (data != null) {
			this.abstracts.push(this.generateCompiledCollection(cast cast {
				if (data == null) {
					throw "Trusted on null value.";
				};
				@:nullSafety(Off) data;
			}, abstractType));
		};
	}

	@:value({ topLevel : false })
	public function compileExpression(expr:haxe.macro.TypedExpr, topLevel:Bool = false) {
		var result = this.compileExpressionImpl(expr, topLevel);
		return result;
	}

	public function compileExpressionOrError(expr:haxe.macro.TypedExpr) {
		var result = this.compileExpression(expr, false);
		if (result == null) {
			return this.onExpressionUnsuccessful(expr.pos);
		};
		return result;
	}
}