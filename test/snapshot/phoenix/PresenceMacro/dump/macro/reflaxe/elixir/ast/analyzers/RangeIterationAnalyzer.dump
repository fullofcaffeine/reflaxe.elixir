class reflaxe.elixir.ast.analyzers.RangeIterationAnalyzer extends reflaxe.elixir.ast.analyzers.BaseLoopAnalyzer {

	public function new(buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST) {
		this.detectedRange = null;
		super(buildExpr);
	}

	@:value(null)
	var detectedRange:Null<reflaxe.elixir.ast.analyzers.RangeInfo>;

	public function analyze(expr:haxe.macro.TypedExpr, ir:reflaxe.elixir.ast.loop_ir.LoopIR) {
		@:ast(switch (expr.expr) {
	case TFor(v, iterator, body):
		analyzeForLoop(v, iterator, body, ir);	
	case TWhile(cond, body, true):
		analyzeWhileLoop(cond, body, ir);	
	case _:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var v = `;
						var iterator = `;
						var body = `;
						{
							this.analyzeForLoop(v, iterator, body, ir);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == true) {
						{
							var body = `;
							var cond = `;
							{
								this.analyzeWhileLoop(cond, body, ir);
							};
						};
					} else {};
				};
				default: {}
			};
		};
	}

	function analyzeForLoop(v:haxe.macro.TVar, iterator:haxe.macro.TypedExpr, body:haxe.macro.TypedExpr, ir:reflaxe.elixir.ast.loop_ir.LoopIR) {
		@:ast(switch (iterator.expr) {
	case TBinop(OpInterval, startExpr, endExpr):
		detectedRange = { start : startExpr, end : endExpr, step : 1, indexVar : v.name, isInclusive : false };
		ir.kind = ForRange;
		detectedRange = { start : startExpr, end : endExpr, step : 1, indexVar : v.name, isInclusive : false };
		ir.source = Collection(makeAST(ENil));
		ir.elementPattern = { varName : v.name, pattern : makeAST(ENil), type : v.t };
		trace("Detected range iteration: ${v.name} in ${printExpr(startExpr)}...${printExpr(endExpr)}");	
	case _:
}) {
			var ` = iterator.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 21) {
					{
						var startExpr = `;
						var endExpr = `;
						{
							this.detectedRange = {start : startExpr, end : endExpr, step : 1, indexVar : v.name, isInclusive : false};
							ir.kind = reflaxe.elixir.ast.loop_ir.LoopKind.ForRange;
							this.detectedRange = {start : startExpr, end : endExpr, step : 1, indexVar : v.name, isInclusive : false};
							ir.source = reflaxe.elixir.ast.loop_ir.LoopSource.Collection({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
							});
							ir.elementPattern = {varName : v.name, pattern : {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
							}, type : v.t};
							haxe.Log.trace("Detected range iteration: " + v.name + " in " + this.printExpr(startExpr) + "..." + this.printExpr(endExpr), {fileName : "../../../../src/reflaxe/elixir/ast/analyzers/RangeIterationAnalyzer.hx", lineNumber : 94, className : "reflaxe.elixir.ast.analyzers.RangeIterationAnalyzer", methodName : "analyzeForLoop"});
						};
					};
				} else {};
			} else {};
		};
	}

	function analyzeWhileLoop(cond:haxe.macro.TypedExpr, body:haxe.macro.TypedExpr, ir:reflaxe.elixir.ast.loop_ir.LoopIR) {
		var condPattern = this.extractWhileCondition(cond);
		if (condPattern == null) {
			return;
		};
		var increment = this.findIncrement(body, condPattern.indexVar);
		if (increment == null) {
			return;
		};
		this.detectedRange = {start : this.makeConstInt(0), end : condPattern.limit, step : increment.step, indexVar : condPattern.indexVar, isInclusive : condPattern.isInclusive};
		ir.kind = reflaxe.elixir.ast.loop_ir.LoopKind.While;
		ir.source = reflaxe.elixir.ast.loop_ir.LoopSource.Range({
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		}, {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		}, this.detectedRange.step);
		ir.elementPattern = {varName : condPattern.indexVar, pattern : {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
		}, type : condPattern.type};
		haxe.Log.trace("Detected while-based range: " + condPattern.indexVar + " from 0 to " + this.printExpr(condPattern.limit), {fileName : "../../../../src/reflaxe/elixir/ast/analyzers/RangeIterationAnalyzer.hx", lineNumber : 134, className : "reflaxe.elixir.ast.analyzers.RangeIterationAnalyzer", methodName : "analyzeWhileLoop"});
	}

	function extractWhileCondition(cond:haxe.macro.TypedExpr) {
		var actualCond = @:ast(switch (cond.expr) {
	case TParenthesis(e):
		e;	
	case _:
		cond;	
}) {
			var ` = cond.expr;
			if (enumIndex ` == 6) {
				var ` = `[0];
				{
					var e = `;
					{
						e;
					};
				};
			} else {
				cond;
			};
		};
		@:ast(switch (actualCond.expr) {
	case TBinop(OpLt, { expr : TLocal(v) }, limitExpr):
		return { indexVar : v.name, limit : limitExpr, isInclusive : false, type : v.t };	
	case TBinop(OpLte, { expr : TLocal(v) }, limitExpr):
		return { indexVar : v.name, limit : limitExpr, isInclusive : true, type : v.t };	
	case _:
		return null;	
}) {
			var ` = actualCond.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				switch (enumIndex `) {
					case 9: {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var limitExpr = `;
									{
										return {indexVar : v.name, limit : limitExpr, isInclusive : false, type : v.t};
									};
								};
							} else {
								return null;
							};
						};
					};
					case 10: {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var limitExpr = `;
									{
										return {indexVar : v.name, limit : limitExpr, isInclusive : true, type : v.t};
									};
								};
							} else {
								return null;
							};
						};
					};
					default: {
						return null;
					}
				};
			} else {
				return null;
			};
		};
	}

	function findIncrement(body:haxe.macro.TypedExpr, varName:String) {
		var increments = this.findAll(body, reflaxe.elixir.ast.analyzers.ExprPattern.FunctionCall);
		{
			var ` = 0;
			while (` < increments.length) {
				var expr = increments[`];
				++ `;
				@:ast(switch (expr.expr) {
	case TUnop(OpIncrement, _, { expr : TLocal(v) }) if (v.name == varName):
		return { step : 1 };	
	case TBinop(OpAssignOp(OpAdd), { expr : TLocal(v) }, { expr : TConst(TInt(n)) }) if (v.name == varName):
		return { step : n };	
	case _:
}) {
					var ` = expr.expr;
					switch (enumIndex `) {
						case 3: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 20) {
								var ` = `[0];
								if (enumIndex ` == 0) {
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 0) {
													var ` = `[0];
													if (enumIndex ` == 0) {
														var ` = `[0];
														{
															var n = `;
															var v = `;
															if (v.name == varName) {
																return {step : n};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								} else {};
							} else {};
						};
						case 11: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 0) {
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 1) {
										var ` = `[0];
										{
											var v = `;
											if (v.name == varName) {
												return {step : 1};
											} else {};
										};
									} else {};
								};
							} else {};
						};
						default: {}
					};
				};
			};
		};
		return null;
	}

	public function calculateConfidence() {
		if (this.detectedRange != null) {
			return 0.9;
		};
		return 0.0;
	}

	@:has_untyped
	function makeConstInt(n:Int) {
		return {expr : haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TInt(n)), pos : haxe.macro.Context.currentPos(), t : haxe.macro.Context.typeof(cast haxe.macro.Context.makeExpr(n, $__mk_pos__("../../../../src/reflaxe/elixir/ast/analyzers/RangeIterationAnalyzer.hx", 6471, 6472)))};
	}

	function printExpr(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(TInt(n)):
		Std.string(n);	
	case TLocal(v):
		v.name;	
	case _:
		"expr";	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var n = `;
							{
								Std.string(n);
							};
						};
					} else {
						"expr";
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							v.name;
						};
					};
				};
				default: {
					"expr";
				}
			};
		};
	}
}