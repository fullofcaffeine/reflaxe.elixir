class reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms {

	public static function discardPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var assigned = new Map<String,Bool>();
			var used = new Map<String,Bool>();
			collectAssignedAndUsed(cl.body, assigned, used);
			var dead = new Map<String,Bool>();
			for (k  in  assigned.keys()) if (!used.exists(k)) dead.set(k, true);
			var body1 = rewriteDeadAssignments(cl.body, dead);
			var newBody = discardPerBlockUnusedAssignments(body1);
			newClauses.push({ args : cl.args, guard : cl.guard, body : newBody });
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var assigned = {
										{};
										new haxe.ds.StringMap();
									};
									var used = {
										{};
										new haxe.ds.StringMap();
									};
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(cl.body, assigned, used);
									var dead = {
										{};
										new haxe.ds.StringMap();
									};
									for (k in assigned.keys()) {
										if (! used.exists(k)) {
											{
												dead.set(k, true);
											};
										};
									};
									var body1 = reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.rewriteDeadAssignments(cl.body, dead);
									var newBody = reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.discardPerBlockUnusedAssignments(body1);
									newClauses.push({args : cl.args, guard : cl.guard, body : newBody});
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function collectAssignedAndUsed(n:reflaxe.elixir.ast.ElixirAST, assigned:Map<String, Bool>, used:Map<String, Bool>) {
		if (n == null || n.def == null) {
			return;
		};
		@:ast(switch (n.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(name):
				assigned.set(name, true);			
			default:
		};
		collectAssignedAndUsed(rhs, assigned, used);	
	case EMatch(_, rhs):
		collectAssignedAndUsed(rhs, assigned, used);	
	case EVar(name):
		used.set(name, true);	
	case EBlock(stmts):
		for (s  in  stmts) collectAssignedAndUsed(s, assigned, used);	
	case EDo(stmts2):
		for (s2  in  stmts2) collectAssignedAndUsed(s2, assigned, used);	
	case EIf(c, t, e):
		collectAssignedAndUsed(c, assigned, used);
		collectAssignedAndUsed(t, assigned, used);
		if (e != null) collectAssignedAndUsed(e, assigned, used);	
	case ECase(expr, cs):
		collectAssignedAndUsed(expr, assigned, used);
		for (c  in  cs) collectAssignedAndUsed(c.body, assigned, used);	
	case ECall(tgt, _, args):
		if (tgt != null) collectAssignedAndUsed(tgt, assigned, used);
		for (a  in  args) collectAssignedAndUsed(a, assigned, used);	
	case ERemoteCall(t2, _, args2):
		collectAssignedAndUsed(t2, assigned, used);
		for (a  in  args2) collectAssignedAndUsed(a, assigned, used);	
	case EBinary(_, l, r):
		collectAssignedAndUsed(l, assigned, used);
		collectAssignedAndUsed(r, assigned, used);	
	case EField(t, _):
		collectAssignedAndUsed(t, assigned, used);	
	case EMap(pairs):
		for (p  in  pairs) {
			collectAssignedAndUsed(p.key, assigned, used);
			collectAssignedAndUsed(p.value, assigned, used);
		};	
	case EString(str):
		var i = 0;
		while (str != null && i < str.length) {
			var idx = str.indexOf("#{", i);
			if (idx == -1) break;
			var j = str.indexOf("}", idx + 2);
			if (j == -1) break;
			var inner = str.substr(idx + 2, j - (idx + 2));
			var vars = inner.split(" ");
			for (v  in  vars) if (v != null && v.length > 0) used.set(v, true);
			i = j + 1;
		};	
	default:
}) {
			var ` = n.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var cs = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(expr, assigned, used);
							{
								var ` = 0;
								while (` < cs.length) {
									var c = cs[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(c.body, assigned, used);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var rhs = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(rhs, assigned, used);
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var t = `;
						var e = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(c, assigned, used);
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(t, assigned, used);
							if (e != null) {
								reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(e, assigned, used);
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(p.key, assigned, used);
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(p.value, assigned, used);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var tgt = `;
						var args = `;
						{
							if (tgt != null) {
								reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(tgt, assigned, used);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(a, assigned, used);
								};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var t2 = `;
						var args2 = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(t2, assigned, used);
							{
								var ` = 0;
								while (` < args2.length) {
									var a = args2[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(a, assigned, used);
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var left = `;
							var rhs = `;
							{
								@:ast(switch (left.def) {
	case EVar(name):
		assigned.set(name, true);	
	default:
}) {
									var ` = left.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												{
													assigned.set(name, true);
												};
											};
										};
									} else {};
								};
								reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(rhs, assigned, used);
							};
						};
					} else {
						var l = `;
						var r = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(l, assigned, used);
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(r, assigned, used);
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var t = `;
						{
							reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(t, assigned, used);
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var str = `;
						{
							var i = 0;
							while (str != null && i < str.length) {
								var idx = str.indexOf("#{", i);
								if (idx == -1) {
									break;
								};
								var j = str.indexOf("}", idx + 2);
								if (j == -1) {
									break;
								};
								var inner = str.substr(idx + 2, j - (idx + 2));
								var vars = inner.split(" ");
								{
									var ` = 0;
									while (` < vars.length) {
										var v = vars[`];
										++ `;
										if (v != null && v.length > 0) {
											{
												used.set(v, true);
											};
										};
									};
								};
								i = j + 1;
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							{
								used.set(name, true);
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						{
							{
								var ` = 0;
								while (` < stmts.length) {
									var s = stmts[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(s, assigned, used);
								};
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var stmts2 = `;
						{
							{
								var ` = 0;
								while (` < stmts2.length) {
									var s2 = stmts2[`];
									++ `;
									reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.collectAssignedAndUsed(s2, assigned, used);
								};
							};
						};
					};
				};
				default: {}
			};
		};
	}

	static function rewriteDeadAssignments(n:reflaxe.elixir.ast.ElixirAST, dead:Map<String, Bool>) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(name) if (dead.exists(name) && name != null && name.length > 0 && name.charAt(0) == "_"):
				switch (rhs.def) {
					case EList(_):
						x;					
					default:
						makeASTWithMeta(EMatch(PWildcard, rhs), x.metadata, x.pos);					
				};			
			default:
				x;			
		};	
	default:
		x;	
}) {
				var ` = x.def;
				if (enumIndex ` == 26) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var left = `;
							var rhs = `;
							{
								@:ast(switch (left.def) {
	case EVar(name) if (dead.exists(name) && name != null && name.length > 0 && name.charAt(0) == "_"):
		switch (rhs.def) {
			case EList(_):
				x;			
			default:
				makeASTWithMeta(EMatch(PWildcard, rhs), x.metadata, x.pos);			
		};	
	default:
		x;	
}) {
									var ` = left.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											if (dead.exists(name) && name != null && name.length > 0 && name.charAt(0) == "_") {
												@:ast(switch (rhs.def) {
	case EList(_):
		x;	
	default:
		makeASTWithMeta(EMatch(PWildcard, rhs), x.metadata, x.pos);	
}) {
													var ` = rhs.def;
													if (enumIndex ` == 15) {
														var ` = `[0];
														{
															x;
														};
													} else {
														{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PWildcard, rhs), metadata : x.metadata, pos : x.pos};
													};
												};
											} else {
												x;
											};
										};
									} else {
										x;
									};
								};
							};
						};
					} else {
						x;
					};
				} else {
					x;
				};
			};
		});
	}

	static function discardPerBlockUnusedAssignments(n:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EBlock(stmts):
		var out:Array<ElixirAST> = [];
		for (i  in  0 ... stmts.length) {
			var s = stmts[i];
			var replaced = false;
			switch (s.def) {
				case EBinary(Match, left, rhs):
					switch (left.def) {
						case EVar(name):
							if (!nameUsedLater(stmts, i + 1, name)) {
								switch (rhs.def) {
									case EList(_):
									default:
										out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
										replaced = true;									
								};
							};						
						default:
					};				
				default:
			};
			if (!replaced) out.push(s);
		};
		makeASTWithMeta(EBlock(out), x.metadata, x.pos);	
	case EDo(stmts2):
		var out2:Array<ElixirAST> = [];
		for (i  in  0 ... stmts2.length) {
			var s2 = stmts2[i];
			var replaced2 = false;
			switch (s2.def) {
				case EBinary(Match, left2, rhs2):
					switch (left2.def) {
						case EVar(name2):
							if ((name2 != null && name2.length > 0 && name2.charAt(0) == "_") && !nameUsedLater(stmts2, i + 1, name2)) {
								out2.push(makeASTWithMeta(EMatch(PWildcard, rhs2), s2.metadata, s2.pos));
								replaced2 = true;
							};						
						default:
					};				
				default:
			};
			if (!replaced2) out2.push(s2);
		};
		makeASTWithMeta(EDo(out2), x.metadata, x.pos);	
	default:
		x;	
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								var out = [];
								{
									var ` = 0;
									var ` = stmts.length;
									while (` < `) {
										var i = ` ++;
										var s = stmts[i];
										var replaced = false;
										@:ast(switch (s.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(name):
				if (!nameUsedLater(stmts, i + 1, name)) {
					switch (rhs.def) {
						case EList(_):
						default:
							out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
							replaced = true;						
					};
				};			
			default:
		};	
	default:
}) {
											var ` = s.def;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var rhs = `;
														{
															@:ast(switch (left.def) {
	case EVar(name):
		if (!nameUsedLater(stmts, i + 1, name)) {
			switch (rhs.def) {
				case EList(_):
				default:
					out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
					replaced = true;				
			};
		};	
	default:
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var name = `;
																		{
																			if (! reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.nameUsedLater(stmts, i + 1, name)) {
																				@:ast(switch (rhs.def) {
	case EList(_):
	default:
		out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
		replaced = true;	
}) {
																					var ` = rhs.def;
																					if (enumIndex ` == 15) {
																						var ` = `[0];
																						{};
																					} else {
																						out.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PWildcard, rhs), metadata : s.metadata, pos : s.pos});
																						replaced = true;
																					};
																				};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											} else {};
										};
										if (! replaced) {
											out.push(s);
										};
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : x.metadata, pos : x.pos};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var stmts2 = `;
							{
								var out2 = [];
								{
									var ` = 0;
									var ` = stmts2.length;
									while (` < `) {
										var i = ` ++;
										var s2 = stmts2[i];
										var replaced2 = false;
										@:ast(switch (s2.def) {
	case EBinary(Match, left2, rhs2):
		switch (left2.def) {
			case EVar(name2):
				if ((name2 != null && name2.length > 0 && name2.charAt(0) == "_") && !nameUsedLater(stmts2, i + 1, name2)) {
					out2.push(makeASTWithMeta(EMatch(PWildcard, rhs2), s2.metadata, s2.pos));
					replaced2 = true;
				};			
			default:
		};	
	default:
}) {
											var ` = s2.def;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left2 = `;
														var rhs2 = `;
														{
															@:ast(switch (left2.def) {
	case EVar(name2):
		if ((name2 != null && name2.length > 0 && name2.charAt(0) == "_") && !nameUsedLater(stmts2, i + 1, name2)) {
			out2.push(makeASTWithMeta(EMatch(PWildcard, rhs2), s2.metadata, s2.pos));
			replaced2 = true;
		};	
	default:
}) {
																var ` = left2.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var name2 = `;
																		{
																			if ((name2 != null && name2.length > 0 && name2.charAt(0) == "_") && ! reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.nameUsedLater(stmts2, i + 1, name2)) {
																				out2.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PWildcard, rhs2), metadata : s2.metadata, pos : s2.pos});
																				replaced2 = true;
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											} else {};
										};
										if (! replaced2) {
											out2.push(s2);
										};
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EDo(out2), metadata : x.metadata, pos : x.pos};
							};
						};
					};
					default: {
						x;
					}
				};
			};
		});
	}

	static function nameUsedLater(stmts:Array<reflaxe.elixir.ast.ElixirAST>, start:Int, name:String) {
		{
			var ` = start;
			var ` = stmts.length;
			while (` < `) {
				var k = ` ++;
				if (reflaxe.elixir.ast.transformers.EFnLocalAssignDiscardTransforms.statementUsesName(stmts[k], name)) {
					return true;
				};
			};
		};
		return false;
	}

	static function statementUsesName(s:reflaxe.elixir.ast.ElixirAST, name:String) {
		var found = [false];
		var visit = [null];
		visit[0] = function(e:reflaxe.elixir.ast.ElixirAST) {
			if (found[0] || e == null || e.def == null) {
				return;
			};
			@:ast(switch (e.def) {
	case EVar(n) if (n == name):
		found = true;	
	case EBlock(ss):
		for (x  in  ss) visit(x);	
	case EIf(c, t, el):
		visit(c);
		visit(t);
		if (el != null) visit(el);	
	case ECase(expr, cs):
		visit(expr);
		for (c  in  cs) {
			if (c.guard != null) visit(c.guard);
			visit(c.body);
		};	
	case EBinary(_, l, r):
		visit(l);
		visit(r);	
	case EMatch(_, rhs):
		visit(rhs);	
	case ECall(tgt, _, args):
		if (tgt != null) visit(tgt);
		for (a  in  args) visit(a);	
	case ERemoteCall(tgt2, _, args2):
		visit(tgt2);
		for (a  in  args2) visit(a);	
	case EList(els):
		for (el  in  els) visit(el);	
	case ETuple(els):
		for (el  in  els) visit(el);	
	case EMap(pairs):
		for (p  in  pairs) {
			visit(p.key);
			visit(p.value);
		};	
	case EKeywordList(pairs):
		for (p  in  pairs) visit(p.value);	
	case EStructUpdate(base, fields):
		visit(base);
		for (f  in  fields) visit(f.value);	
	case EFn(clauses):
		for (cl  in  clauses) visit(cl.body);	
	case EString(str):
		var k = 0;
		while (!found && str != null && k < str.length) {
			var idx2 = str.indexOf("#{", k);
			if (idx2 == -1) break;
			var j2 = str.indexOf("}", idx2 + 2);
			if (j2 == -1) break;
			var inner = str.substr(idx2 + 2, j2 - (idx2 + 2));
			if (inner.indexOf(name) != -1) {
				found = true;
				break;
			};
			k = j2 + 1;
		};	
	default:
}) {
				var ` = e.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var cs = `;
							{
								visit[0](expr);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											visit[0](c.guard);
										};
										visit[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								visit[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var el = `;
							{
								visit[0](c);
								visit[0](t);
								if (el != null) {
									visit[0](el);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var els = `;
							{
								{
									var ` = 0;
									while (` < els.length) {
										var el = els[`];
										++ `;
										visit[0](el);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var els = `;
							{
								{
									var ` = 0;
									while (` < els.length) {
										var el = els[`];
										++ `;
										visit[0](el);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										visit[0](p.key);
										visit[0](p.value);
									};
								};
							};
						};
					};
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var base = `;
							var fields = `;
							{
								visit[0](base);
								{
									var ` = 0;
									while (` < fields.length) {
										var f = fields[`];
										++ `;
										visit[0](f.value);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										visit[0](p.value);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt = `;
							var args = `;
							{
								if (tgt != null) {
									visit[0](tgt);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										visit[0](a);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt2 = `;
							var args2 = `;
							{
								visit[0](tgt2);
								{
									var ` = 0;
									while (` < args2.length) {
										var a = args2[`];
										++ `;
										visit[0](a);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								visit[0](l);
								visit[0](r);
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var str = `;
							{
								var k = 0;
								while (! found[0] && str != null && k < str.length) {
									var idx2 = str.indexOf("#{", k);
									if (idx2 == -1) {
										break;
									};
									var j2 = str.indexOf("}", idx2 + 2);
									if (j2 == -1) {
										break;
									};
									var inner = str.substr(idx2 + 2, j2 - (idx2 + 2));
									if (inner.indexOf(name, null) != -1) {
										found[0] = true;
										break;
									};
									k = j2 + 1;
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var n = `;
							if (n == name) {
								found[0] = true;
							} else {};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										visit[0](cl.body);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var x = ss[`];
										++ `;
										visit[0](x);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		visit[0](s);
		return found[0];
	}
}