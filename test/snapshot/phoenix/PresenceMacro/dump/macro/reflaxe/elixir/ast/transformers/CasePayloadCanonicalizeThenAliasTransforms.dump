class reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ECase(expr, clauses):
		var out:Array<ECaseClause> = [];
		for (cl  in  clauses) out.push(processClause(cl));
		makeASTWithMeta(ECase(expr, out), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							var out = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									out.push(reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.processClause(cl));
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(expr, out), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	@:has_untyped
	static function processClause(cl:reflaxe.elixir.ast.ECaseClause) {
		var isTwoTuple = false;
		var originalBinder = null;
		var tagAtom = null;
		@:ast(switch (cl.pattern) {
	case PTuple(es) if (es.length == 2):
		switch (es[0]) {
			case PLiteral({ def : EAtom(a) }):
				isTwoTuple = true;
				tagAtom = a;			
			case PLiteral(_):
				isTwoTuple = true;			
			default:
		};
		switch (es[1]) {
			case PVar(n):
				originalBinder = n;			
			default:
		};	
	default:
}) {
			var ` = cl.pattern;
			if (enumIndex ` == 2) {
				var ` = `[0];
				{
					var es = `;
					if (es.length == 2) {
						@:ast(switch (es[0]) {
	case PLiteral({ def : EAtom(a) }):
		isTwoTuple = true;
		tagAtom = a;	
	case PLiteral(_):
		isTwoTuple = true;	
	default:
}) {
							var ` = es[0];
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var ` = `.def;
									var ` = `.metadata;
									var ` = `.pos;
									if (enumIndex ` == 31) {
										var ` = `[0];
										{
											var a = `;
											{
												isTwoTuple = true;
												tagAtom = a;
											};
										};
									} else {
										isTwoTuple = true;
									};
								};
							} else {};
						};
						@:ast(switch (es[1]) {
	case PVar(n):
		originalBinder = n;	
	default:
}) {
							var ` = es[1];
							if (enumIndex ` == 0) {
								var ` = `[0];
								{
									var n = `;
									{
										originalBinder = n;
									};
								};
							} else {};
						};
					} else {};
				};
			} else {};
		};
		if (! isTwoTuple) {
			return cl;
		};
		if (tagAtom != null) {
			var ta = tagAtom;
			var low = ta.toLowerCase();
			if (! (low == "ok" || low == "error")) {
				return cl;
			};
		} else {
			return cl;
		};
		var declared = reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.collectDeclared(cl.pattern, cl.body);
		var used = reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.collectUsed(cl.body, cl.guard);
		var undefined = [];
		for (u in used.keys()) {
			if (reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.allow(u) && ! declared.exists(u)) {
				undefined.push(u);
			};
		};
		var pat2 = @:ast(switch (cl.pattern) {
	case PTuple(es2) if (es2.length == 2):
		PTuple([es2[0], PVar("_value")]);	
	default:
		cl.pattern;	
}) {
			var ` = cl.pattern;
			if (enumIndex ` == 2) {
				var ` = `[0];
				{
					var es2 = `;
					if (es2.length == 2) {
						reflaxe.elixir.ast.EPattern.PTuple([es2[0], reflaxe.elixir.ast.EPattern.PVar("_value")]);
					} else {
						cl.pattern;
					};
				};
			} else {
				cl.pattern;
			};
		};
		var prefix = [];
		var needBinderAlias = originalBinder != null && originalBinder != "_value" && reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.allow(originalBinder) && used.exists(originalBinder) && ! reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.hasAlias(cl.body, originalBinder, "_value");
		var extraAliases = [];
		{
			var ` = 0;
			while (` < undefined.length) {
				var u = undefined[`];
				++ `;
				if (u != "fn_" && (originalBinder == null || u != originalBinder) && ! reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.hasAlias(cl.body, u, "_value")) {
					extraAliases.push(u);
				};
			};
		};
		var needAnyAlias = needBinderAlias || extraAliases.length > 0;
		if (needAnyAlias && ! reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.hasAlias(cl.body, "fn_", "_value")) {
			prefix.push({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("fn_"), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_value"), metadata : {}, pos : pos};
				}), metadata : {}, pos : pos};
			});
		};
		if (needBinderAlias) {
			prefix.push({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(originalBinder), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_value"), metadata : {}, pos : pos};
				}), metadata : {}, pos : pos};
			});
		};
		{
			var ` = 0;
			while (` < extraAliases.length) {
				var u = extraAliases[`];
				++ `;
				prefix.push({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(u), metadata : {}, pos : pos};
					}, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_value"), metadata : {}, pos : pos};
					}), metadata : {}, pos : pos};
				});
			};
		};
		var newBody = @:ast(switch (cl.body.def) {
	case EBlock(sts):
		makeASTWithMeta(EBlock(prefix.concat(sts)), cl.body.metadata, cl.body.pos);	
	case EDo(sts2):
		makeASTWithMeta(EDo(prefix.concat(sts2)), cl.body.metadata, cl.body.pos);	
	default:
		makeASTWithMeta(EBlock(prefix.concat([cl.body])), cl.body.metadata, cl.body.pos);	
}) {
			var ` = cl.body.def;
			switch (enumIndex `) {
				case 53: {
					var ` = `[0];
					{
						var sts = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(prefix.concat(sts));
								var meta = cl.body.metadata;
								var pos = cl.body.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var sts2 = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDo(prefix.concat(sts2));
								var meta = cl.body.metadata;
								var pos = cl.body.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					{
						var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(prefix.concat([cl.body]));
						var meta = cl.body.metadata;
						var pos = cl.body.pos;
						{def : def, metadata : meta, pos : pos};
					};
				}
			};
		};
		try {
			if (newBody.metadata == null) {
				newBody.metadata = {};
			};
			newBody.metadata.lockPayloadBinder = true;
			newBody.metadata.canonicalPayloadValue = true;
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
		return {pattern : pat2, guard : cl.guard, body : newBody};
	}

	static function hasAlias(body:reflaxe.elixir.ast.ElixirAST, lhs:String, rhs:String) {
		var found = [false];
		var scan = [null];
		scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (found[0] || n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EBlock(ss) | EDo(ss):
		for (s  in  ss) scan(s);	
	case EBinary(Match, { def : EVar(l) }, { def : EVar(r) }):
		if (l == lhs && r == rhs) {
			found = true;
			return;
		};	
	case EMatch(PVar(l2), { def : EVar(r2) }):
		if (l2 == lhs && r2 == rhs) {
			found = true;
			return;
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var r2 = `;
										var l2 = `;
										{
											if (l2 == lhs && r2 == rhs) {
												found[0] = true;
												return;
											};
										};
									};
								} else {};
							};
						} else {};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var ` = `.def;
										var ` = `.metadata;
										var ` = `.pos;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var r = `;
												var l = `;
												{
													if (l == lhs && r == rhs) {
														found[0] = true;
														return;
													};
												};
											};
										} else {};
									};
								} else {};
							};
						} else {};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										scan[0](s);
									};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										scan[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](body);
		return found[0];
	}

	static function allow(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		if (name == "socket" || name == "params" || name == "_params" || name == "event") {
			return false;
		};
		@:ast(switch (name) {
	case "end" | "do" | "case" | "fn" | "receive" | "after" | "else" | "catch" | "rescue" | "true" | "false" | "nil" | "when":
		return false;	
	default:
}) switch (name) {
			case "after", "case", "catch", "do", "else", "end", "false", "fn", "nil", "receive", "rescue", "true", "when": {
				{
					return false;
				};
			};
			default: {}
		};
		var c = name.charAt(0);
		return c.toLowerCase() == c && c != "_";
	}

	static function collectDeclared(p:reflaxe.elixir.ast.EPattern, body:reflaxe.elixir.ast.ElixirAST) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var pat = [null];
		pat[0] = function(px:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (px) {
	case PVar(n):
		m.set(n, true);	
	case PTuple(es) | PList(es):
		for (e  in  es) pat(e);	
	case PCons(h, t):
		pat(h);
		pat(t);	
	case PMap(kvs):
		for (kv  in  kvs) pat(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) pat(f.value);	
	case PPin(inner):
		pat(inner);	
	default:
}) switch (enumIndex px) {
				case 0: {
					var ` = px[0];
					{
						var n = `;
						{
							{
								m.set(n, true);
							};
						};
					};
				};
				case 2: {
					var ` = px[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									pat[0](e);
								};
							};
						};
					};
				};
				case 3: {
					var ` = px[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									pat[0](e);
								};
							};
						};
					};
				};
				case 4: {
					var ` = px[0];
					var ` = px[1];
					{
						var h = `;
						var t = `;
						{
							pat[0](h);
							pat[0](t);
						};
					};
				};
				case 5: {
					var ` = px[0];
					{
						var kvs = `;
						{
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									pat[0](kv.value);
								};
							};
						};
					};
				};
				case 6: {
					var ` = px[0];
					var ` = px[1];
					{
						var fs = `;
						{
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									pat[0](f.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = px[0];
					{
						var inner = `;
						{
							pat[0](inner);
						};
					};
				};
				default: {}
			};
		};
		pat[0](p);
		reflaxe.elixir.ast.ASTUtils.walk(body, function(x:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (x.def) {
	case EMatch(pt, _):
		pat(pt);	
	case EBinary(Match, { def : EVar(lhs) }, _):
		m.set(lhs, true);	
	default:
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pt = `;
							{
								pat[0](pt);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var lhs = `;
										{
											{
												m.set(lhs, true);
											};
										};
									};
								} else {};
							};
						} else {};
					};
					default: {}
				};
			};
		});
		return m;
	}

	static function collectUsed(body:reflaxe.elixir.ast.ElixirAST, guard:Null<reflaxe.elixir.ast.ElixirAST>) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var scan = [null];
		scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(v):
		if (allow(v)) m.set(v, true);	
	case EString(s):
		markInterps(s, m);	
	case ERaw(code):
		markInterps(code, m);	
	case EBlock(ss):
		for (s  in  ss) scan(s);	
	case EDo(ss2):
		for (s  in  ss2) scan(s);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EMatch(_, rhs):
		scan(rhs);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(e, cs):
		scan(e);
		for (c  in  cs) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var cs = `;
							{
								scan[0](e);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											scan[0](c.guard);
										};
										scan[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								scan[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								scan[0](c);
								scan[0](t);
								if (e != null) {
									scan[0](e);
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								scan[0](l);
								scan[0](r);
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.markInterps(s, m);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var v = `;
							{
								if (reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.allow(v)) {
									{
										m.set(v, true);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										scan[0](s);
									};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var ss2 = `;
							{
								{
									var ` = 0;
									while (` < ss2.length) {
										var s = ss2[`];
										++ `;
										scan[0](s);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.markInterps(code, m);
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](body);
		if (guard != null) {
			scan[0](guard);
		};
		return m;
	}

	static function markInterps(s:String, used:Map<String, Bool>) {
		if (s == null) {
			return;
		};
		var re = new EReg("\\#\\{([^}]*)\\}", "g");
		var pos = 0;
		while (re.matchSub(s, pos, null)) {
			var inner = re.matched(1);
			var tok = new EReg("[A-Za-z_][A-Za-z0-9_]*", "g");
			var tpos = 0;
			while (tok.matchSub(inner, tpos, null)) {
				var id = tok.matched(0);
				if (reflaxe.elixir.ast.transformers.CasePayloadCanonicalizeThenAliasTransforms.allow(id)) {
					{
						used.set(id, true);
					};
				};
				tpos = tok.matchedPos().pos + tok.matchedPos().len;
			};
			pos = re.matchedPos().pos + re.matchedPos().len;
		};
	}
}