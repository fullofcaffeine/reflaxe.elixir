class reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var info = collectRepoGetInfo(body);
		var newBody = [for (b  in  body) rewriteFunctions(b, info)];
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		var innerBody = switch (doBlock.def) {
			case EBlock(stmts):
				stmts;			
			default:
				[doBlock];			
		};
		var info2 = collectRepoGetInfo(innerBody);
		var rewritten = rewriteFunctions(doBlock, info2);
		makeASTWithMeta(EDefmodule(name, rewritten), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var info = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectRepoGetInfo(body);
								var newBody = {
									var ` = [];
									{
										var ` = 0;
										while (` < body.length) {
											var b = body[`];
											++ `;
											`.push(reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.rewriteFunctions(b, info));
										};
									};
									`;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var innerBody = @:ast(switch (doBlock.def) {
	case EBlock(stmts):
		stmts;	
	default:
		[doBlock];	
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var stmts = `;
											{
												stmts;
											};
										};
									} else {
										[doBlock];
									};
								};
								var info2 = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectRepoGetInfo(innerBody);
								var rewritten = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.rewriteFunctions(doBlock, info2);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, rewritten), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static function collectRepoGetInfo(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var scan = [null];
		scan[0] = function(x:reflaxe.elixir.ast.ElixirAST) {
			if (x == null || x.def == null) {
				return;
			};
			@:ast(switch (x.def) {
	case ERemoteCall(mod, func, args) if (func == "get" && args != null && args.length >= 2):
		var repoLooksOk = switch (mod.def) {
			case EVar(v) if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")):
				true;			
			default:
				false;			
		};
		if (repoLooksOk) {
			var schema = args[0];
			var base:Null<String> = switch (schema.def) {
				case EAtom(a):
					a;				
				case EVar(v):
					v != null ? v.toLowerCase() : null;				
				default:
					null;				
			};
			if (base != null) m.set(base, { repoMod : mod, schemaArg : schema });
		};
		for (a  in  args) scan(a);	
	case ERemoteCall(modA, funcA, argsA) if (funcA == "all" && argsA != null && argsA.length >= 1):
		var repoLooksOk2 = switch (modA.def) {
			case EVar(v) if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")):
				true;			
			default:
				false;			
		};
		if (repoLooksOk2 && !m.exists("__repo__")) {
			m.set("__repo__", { repoMod : modA, schemaArg : null });
		};
		for (a  in  argsA) scan(a);	
	case EBlock(ss):
		for (s  in  ss) scan(s);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(expr, cs):
		scan(expr);
		for (c  in  cs) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EMatch(_, rhs):
		scan(rhs);	
	case ECall(t, _, as):
		if (t != null) scan(t);
		if (as != null) for (a  in  as) scan(a);	
	case ERemoteCall(t2, _, as2):
		scan(t2);
		if (as2 != null) for (a2  in  as2) scan(a2);	
	case EFn(clauses):
		for (cl  in  clauses) scan(cl.body);	
	default:
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var cs = `;
							{
								scan[0](expr);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											scan[0](c.guard);
										};
										scan[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								scan[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								scan[0](c);
								scan[0](t);
								if (e != null) {
									scan[0](e);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t = `;
							var as = `;
							{
								if (t != null) {
									scan[0](t);
								};
								if (as != null) {
									{
										var ` = 0;
										while (` < as.length) {
											var a = as[`];
											++ `;
											scan[0](a);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var func = `;
							var args = `;
							if (func == "get" && args != null && args.length >= 2) {
								var repoLooksOk = @:ast(switch (mod.def) {
	case EVar(v) if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")):
		true;	
	default:
		false;	
}) {
									var ` = mod.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var v = `;
											if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")) {
												true;
											} else {
												false;
											};
										};
									} else {
										false;
									};
								};
								if (repoLooksOk) {
									var schema = args[0];
									var base = @:ast(switch (schema.def) {
	case EAtom(a):
		a;	
	case EVar(v):
		v != null ? v.toLowerCase() : null;	
	default:
		null;	
}) {
										var ` = schema.def;
										switch (enumIndex `) {
											case 31: {
												var ` = `[0];
												{
													var a = `;
													{
														a;
													};
												};
											};
											case 38: {
												var ` = `[0];
												{
													var v = `;
													{
														if (v != null) {
															v.toLowerCase();
														} else {
															null;
														};
													};
												};
											};
											default: {
												null;
											}
										};
									};
									if (base != null) {
										{
											m.set(base, {repoMod : mod, schemaArg : schema});
										};
									};
								};
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										scan[0](a);
									};
								};
							} else {
								var modA = `;
								var funcA = `;
								var argsA = `;
								if (funcA == "all" && argsA != null && argsA.length >= 1) {
									var repoLooksOk2 = @:ast(switch (modA.def) {
	case EVar(v) if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")):
		true;	
	default:
		false;	
}) {
										var ` = modA.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var v = `;
												if (v != null && (StringTools.endsWith(v, ".Repo") || v == "Repo")) {
													true;
												} else {
													false;
												};
											};
										} else {
											false;
										};
									};
									if (repoLooksOk2 && ! m.exists("__repo__")) {
										{
											m.set("__repo__", {repoMod : modA, schemaArg : null});
										};
									};
									{
										var ` = 0;
										while (` < argsA.length) {
											var a = argsA[`];
											++ `;
											scan[0](a);
										};
									};
								} else {
									var t2 = `;
									var as2 = `;
									{
										scan[0](t2);
										if (as2 != null) {
											{
												var ` = 0;
												while (` < as2.length) {
													var a2 = as2[`];
													++ `;
													scan[0](a2);
												};
											};
										};
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								scan[0](l);
								scan[0](r);
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										scan[0](cl.body);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										scan[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		{
			var ` = 0;
			while (` < stmts.length) {
				var s = stmts[`];
				++ `;
				scan[0](s);
			};
		};
		return m;
	}

	static function rewriteFunctions(node:reflaxe.elixir.ast.ElixirAST, info:Map<String, { schemaArg : reflaxe.elixir.ast.ElixirAST, repoMod : reflaxe.elixir.ast.ElixirAST }>) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, params, guards, body):
		var newBody = rewriteBodyIfBareUndeclaredVar(body, params, info);
		makeASTWithMeta(EDef(name, params, guards, newBody), n.metadata, n.pos);	
	case EDefp(name, params, guards, body):
		var newBody = rewriteBodyIfBareUndeclaredVar(body, params, info);
		makeASTWithMeta(EDefp(name, params, guards, newBody), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var params = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.rewriteBodyIfBareUndeclaredVar(body, params, info);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, params, guards, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var params = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.rewriteBodyIfBareUndeclaredVar(body, params, info);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, params, guards, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static function rewriteBodyIfBareUndeclaredVar(body:reflaxe.elixir.ast.ElixirAST, params:Array<reflaxe.elixir.ast.EPattern>, info:Map<String, { schemaArg : reflaxe.elixir.ast.ElixirAST, repoMod : reflaxe.elixir.ast.ElixirAST }>) {
		var bareVar = null;
		var declared = {
			{};
			new haxe.ds.StringMap();
		};
		var collectDecls = [null];
		collectDecls[0] = function(x:reflaxe.elixir.ast.ElixirAST) {
			if (x == null || x.def == null) {
				return;
			};
			@:ast(switch (x.def) {
	case EMatch(p, _):
		collectPatternDecls(p, declared);	
	case EBinary(Match, left, _):
		collectLhsDecls(left, declared);	
	case EBlock(ss):
		for (s  in  ss) collectDecls(s);	
	case EIf(c, t, e):
		collectDecls(c);
		collectDecls(t);
		if (e != null) collectDecls(e);	
	case ECase(expr, cs):
		collectDecls(expr);
		for (c  in  cs) collectDecls(c.body);	
	case EFn(clauses):
		for (cl  in  clauses) for (a  in  cl.args) collectPatternDecls(a, declared);	
	default:
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var cs = `;
							{
								collectDecls[0](expr);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										collectDecls[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var p = `;
							{
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(p, declared);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								collectDecls[0](c);
								collectDecls[0](t);
								if (e != null) {
									collectDecls[0](e);
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var left = `;
								{
									reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectLhsDecls(left, declared);
								};
							};
						} else {};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										{
											var ` = 0;
											var ` = cl.args;
											while (` < `.length) {
												var a = `[`];
												++ `;
												reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(a, declared);
											};
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										collectDecls[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		collectDecls[0](body);
		@:ast(switch (body.def) {
	case EVar(v):
		bareVar = v;	
	case EBlock(stmts) if (stmts.length == 1):
		switch (stmts[0].def) {
			case EVar(v2):
				bareVar = v2;			
			default:
		};	
	default:
}) {
			var ` = body.def;
			switch (enumIndex `) {
				case 38: {
					var ` = `[0];
					{
						var v = `;
						{
							bareVar = v;
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length == 1) {
							@:ast(switch (stmts[0].def) {
	case EVar(v2):
		bareVar = v2;	
	default:
}) {
								var ` = stmts[0].def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v2 = `;
										{
											bareVar = v2;
										};
									};
								} else {};
							};
						} else {};
					};
				};
				default: {}
			};
		};
		if (bareVar == null) {
			return body;
		};
		if (declared.exists(bareVar)) {
			return body;
		};
		var base = bareVar.toLowerCase();
		var repoInfo = null;
		if (info.exists(base)) {
			repoInfo = cast info.get(base);
		} else {
			if (info.exists("__repo__")) {
				var fallback = cast info.get("__repo__");
				repoInfo = {repoMod : fallback.repoMod, schemaArg : {
					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
						var this;
						this = reflaxe.elixir.ast.NameUtils.toSnakeCase(base);
						cast this;
					});
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}};
			} else {
				return body;
			};
		};
		var firstParamName = reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.deriveFirstParamName(params);
		if (firstParamName == null) {
			firstParamName = "id";
		};
		var call = {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(repoInfo.repoMod, "get", [repoInfo.schemaArg, {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(firstParamName), metadata : {}, pos : pos};
		}]), metadata : body.metadata, pos : body.pos};
		return call;
	}

	static function deriveFirstParamName(params:Array<reflaxe.elixir.ast.EPattern>) {
		if (params == null || params.length == 0) {
			return null;
		};
		return @:ast(switch (params[0]) {
	case PVar(n):
		n;	
	case PTuple(es) if (es.length > 0):
		switch (es[0]) {
			case PVar(n2):
				n2;			
			default:
				null;			
		};	
	default:
		null;	
}) {
			var ` = params[0];
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						var n = `;
						{
							n;
						};
					};
				};
				case 2: {
					var ` = `[0];
					{
						var es = `;
						if (es.length > 0) {
							@:ast(switch (es[0]) {
	case PVar(n2):
		n2;	
	default:
		null;	
}) {
								var ` = es[0];
								if (enumIndex ` == 0) {
									var ` = `[0];
									{
										var n2 = `;
										{
											n2;
										};
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
				};
				default: {
					null;
				}
			};
		};
	}

	static function collectPatternDecls(p:reflaxe.elixir.ast.EPattern, declared:Map<String, Bool>) {
		@:ast(switch (p) {
	case PVar(n):
		declared.set(n, true);	
	case PTuple(es):
		for (e  in  es) collectPatternDecls(e, declared);	
	case PList(es):
		for (e  in  es) collectPatternDecls(e, declared);	
	case PCons(h, t):
		collectPatternDecls(h, declared);
		collectPatternDecls(t, declared);	
	case PMap(kvs):
		for (kv  in  kvs) collectPatternDecls(kv.value, declared);	
	case PStruct(_, fs):
		for (f  in  fs) collectPatternDecls(f.value, declared);	
	case PPin(inner):
		collectPatternDecls(inner, declared);	
	default:
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var n = `;
					{
						{
							declared.set(n, true);
						};
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(e, declared);
							};
						};
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(e, declared);
							};
						};
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(h, declared);
						reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(t, declared);
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						{
							var ` = 0;
							while (` < kvs.length) {
								var kv = kvs[`];
								++ `;
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(kv.value, declared);
							};
						};
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var fs = `;
					{
						{
							var ` = 0;
							while (` < fs.length) {
								var f = fs[`];
								++ `;
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(f.value, declared);
							};
						};
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectPatternDecls(inner, declared);
					};
				};
			};
			default: {}
		};
	}

	static function collectLhsDecls(lhs:reflaxe.elixir.ast.ElixirAST, declared:Map<String, Bool>) {
		if (lhs == null || lhs.def == null) {
			return;
		};
		@:ast(switch (lhs.def) {
	case EVar(n):
		declared.set(n, true);	
	case EBinary(Match, l2, r2):
		collectLhsDecls(l2, declared);
		collectLhsDecls(r2, declared);	
	default:
}) {
			var ` = lhs.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var l2 = `;
							var r2 = `;
							{
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectLhsDecls(l2, declared);
								reflaxe.elixir.ast.transformers.RepoGetBinderRepairTransforms.collectLhsDecls(r2, declared);
							};
						};
					} else {};
				};
				case 38: {
					var ` = `[0];
					{
						var n = `;
						{
							{
								declared.set(n, true);
							};
						};
					};
				};
				default: {}
			};
		};
	}
}