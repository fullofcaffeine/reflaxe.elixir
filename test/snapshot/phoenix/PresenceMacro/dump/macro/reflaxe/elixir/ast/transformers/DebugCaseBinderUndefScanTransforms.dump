class reflaxe.elixir.ast.transformers.DebugCaseBinderUndefScanTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case ECase(_, clauses):
		for (cl  in  clauses) {
			var binder = switch (cl.pattern) {
				case PTuple(es) if (es.length == 2):
					switch (es[1]) {
						case PVar(n):
							n;						
						default:
							null;						
					};				
				default:
					null;				
			};
			if (binder != null) {
				var declared = new Map<String,Bool>();
				function pat(p:EPattern) {
					switch (p) {
						case PVar(n):
							declared.set(n, true);						
						case PTuple(es) | PList(es):
							for (e  in  es) pat(e);						
						case PCons(h, t):
							pat(h);
							pat(t);						
						case PMap(kvs):
							for (kv  in  kvs) pat(kv.value);						
						case PStruct(_, fs):
							for (f  in  fs) pat(f.value);						
						case PPin(inner):
							pat(inner);						
						default:
					};
				};
				pat(cl.pattern);
				reflaxe.elixir.ast.ASTUtils.walk(cl.body, function(x:ElixirAST) {
					switch (x.def) {
						case EMatch(p, _):
							pat(p);						
						case EBinary(Match, { def : EVar(l) }, _):
							declared.set(l, true);						
						default:
					};
				});
				var used = new Map<String,Bool>();
				reflaxe.elixir.ast.ASTUtils.walk(cl.body, function(x:ElixirAST) {
					switch (x.def) {
						case EVar(v):
							used.set(v, true);						
						default:
					};
				});
				var undef:Array<String> = [];
				for (k  in  used.keys()) if (!declared.exists(k) && allow(k)) undef.push(k);
				if (undef.length > 0) Sys.println("[DebugCaseBinderUndef] binder=" + binder + " undef={" + undef.join(",") + "}");
			};
		};	
	default:
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var binder = @:ast(switch (cl.pattern) {
	case PTuple(es) if (es.length == 2):
		switch (es[1]) {
			case PVar(n):
				n;			
			default:
				null;			
		};	
	default:
		null;	
}) {
										var ` = cl.pattern;
										if (enumIndex ` == 2) {
											var ` = `[0];
											{
												var es = `;
												if (es.length == 2) {
													@:ast(switch (es[1]) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
														var ` = es[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															{
																var n = `;
																{
																	n;
																};
															};
														} else {
															null;
														};
													};
												} else {
													null;
												};
											};
										} else {
											null;
										};
									};
									if (binder != null) {
										var declared = {
											{};
											new haxe.ds.StringMap();
										};
										var pat = [null];
										pat[0] = function(p:reflaxe.elixir.ast.EPattern) {
											@:ast(switch (p) {
	case PVar(n):
		declared.set(n, true);	
	case PTuple(es) | PList(es):
		for (e  in  es) pat(e);	
	case PCons(h, t):
		pat(h);
		pat(t);	
	case PMap(kvs):
		for (kv  in  kvs) pat(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) pat(f.value);	
	case PPin(inner):
		pat(inner);	
	default:
}) switch (enumIndex p) {
												case 0: {
													var ` = p[0];
													{
														var n = `;
														{
															{
																declared.set(n, true);
															};
														};
													};
												};
												case 2: {
													var ` = p[0];
													{
														var es = `;
														{
															{
																var ` = 0;
																while (` < es.length) {
																	var e = es[`];
																	++ `;
																	pat[0](e);
																};
															};
														};
													};
												};
												case 3: {
													var ` = p[0];
													{
														var es = `;
														{
															{
																var ` = 0;
																while (` < es.length) {
																	var e = es[`];
																	++ `;
																	pat[0](e);
																};
															};
														};
													};
												};
												case 4: {
													var ` = p[0];
													var ` = p[1];
													{
														var h = `;
														var t = `;
														{
															pat[0](h);
															pat[0](t);
														};
													};
												};
												case 5: {
													var ` = p[0];
													{
														var kvs = `;
														{
															{
																var ` = 0;
																while (` < kvs.length) {
																	var kv = kvs[`];
																	++ `;
																	pat[0](kv.value);
																};
															};
														};
													};
												};
												case 6: {
													var ` = p[0];
													var ` = p[1];
													{
														var fs = `;
														{
															{
																var ` = 0;
																while (` < fs.length) {
																	var f = fs[`];
																	++ `;
																	pat[0](f.value);
																};
															};
														};
													};
												};
												case 7: {
													var ` = p[0];
													{
														var inner = `;
														{
															pat[0](inner);
														};
													};
												};
												default: {}
											};
										};
										pat[0](cl.pattern);
										reflaxe.elixir.ast.ASTUtils.walk(cl.body, function(x:reflaxe.elixir.ast.ElixirAST) {
											@:ast(switch (x.def) {
	case EMatch(p, _):
		pat(p);	
	case EBinary(Match, { def : EVar(l) }, _):
		declared.set(l, true);	
	default:
}) {
												var ` = x.def;
												switch (enumIndex `) {
													case 8: {
														var ` = `[0];
														var ` = `[1];
														{
															var p = `;
															{
																pat[0](p);
															};
														};
													};
													case 26: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (enumIndex ` == 27) {
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var l = `;
																		{
																			{
																				declared.set(l, true);
																			};
																		};
																	};
																} else {};
															};
														} else {};
													};
													default: {}
												};
											};
										});
										var used = {
											{};
											new haxe.ds.StringMap();
										};
										reflaxe.elixir.ast.ASTUtils.walk(cl.body, function(x:reflaxe.elixir.ast.ElixirAST) {
											@:ast(switch (x.def) {
	case EVar(v):
		used.set(v, true);	
	default:
}) {
												var ` = x.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var v = `;
														{
															{
																used.set(v, true);
															};
														};
													};
												} else {};
											};
										});
										var undef = [];
										for (k in used.keys()) {
											if (! declared.exists(k) && if (k == null || k.length == 0) {
												false;
											} else {
												if (k == "socket" || k == "params" || k == "_params" || k == "event") {
													false;
												} else {
													var c = k.charAt(0);
													c.toLowerCase() == c && c != "_";
												};
											}) {
												undef.push(k);
											};
										};
										if (undef.length > 0) {
											Sys.println("[DebugCaseBinderUndef] binder=" + binder + " undef={" + undef.join(",") + "}");
										};
									};
								};
							};
						};
					};
				} else {};
			};
			return n;
		});
	}

	static inline function allow(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		if (name == "socket" || name == "params" || name == "_params" || name == "event") {
			return false;
		};
		var c = name.charAt(0);
		return c.toLowerCase() == c && c != "_";
	}
}