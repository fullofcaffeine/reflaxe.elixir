class reflaxe.elixir.ast.transformers.GuardSanitizationTransforms {

	public static function guardSanitizePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return node;
			};
			return @:ast(switch (node.def) {
	case EDef(name, args, guards, body):
		var newGuards = guards != null ? sanitizeGuardExpr(guards) : null;
		makeASTWithMeta(EDef(name, args, newGuards, body), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		var newGuards = guards != null ? sanitizeGuardExpr(guards) : null;
		makeASTWithMeta(EDefp(name, args, newGuards, body), node.metadata, node.pos);	
	case EFn(clauses):
		var newClauses = clauses.map(function(c) ->  @:implicitReturn return {
			var g = c.guard != null ? sanitizeGuardExpr(c.guard) : null;
			return { args : c.args, guard : g, body : c.body };
		});
		makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);	
	case ECase(target, clauses):
		var newClauses2 = clauses.map(function(c) ->  @:implicitReturn return {
			var g = c.guard != null ? sanitizeGuardExpr(c.guard) : null;
			return { pattern : c.pattern, guard : g, body : c.body };
		});
		makeASTWithMeta(ECase(target, newClauses2), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var newGuards = if (guards != null) {
									reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExpr(guards);
								} else {
									null;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, newGuards, body), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var newGuards = if (guards != null) {
									reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExpr(guards);
								} else {
									null;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, newGuards, body), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var clauses = `;
							{
								var newClauses2 = {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(c:reflaxe.elixir.ast.ECaseClause) {
												return {
													var g = if ((c.guard != null)) reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExpr(c.guard) else null;
													return {pattern : c.pattern, guard : g, body : c.body};
												};
											}(v));
										};
									};
									`;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses2), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var newClauses = {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(c:reflaxe.elixir.ast.EFnClause) {
												return {
													var g = if ((c.guard != null)) reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExpr(c.guard) else null;
													return {args : c.args, guard : g, body : c.body};
												};
											}(v));
										};
									};
									`;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function sanitizeGuardExpr(expr:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null || expr.def == null) {
			return expr;
		};
		return reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(expr);
	}

	static function sanitizeGuardExprRecursive(expr:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null || expr.def == null) {
			return expr;
		};
		return @:ast(switch (expr.def) {
	case EBinary(op, left, right):
		var l = sanitizeGuardExprRecursive(left);
		var r = sanitizeGuardExprRecursive(right);
		var leftGet = extractMapGetCall(l);
		var rightGet = extractMapGetCall(r);
		var isNilLeft = isNil(l);
		var isNilRight = isNil(r);
		if (leftGet != null && isNilRight) {
			var call = makeIsMapKey(leftGet.mapExpr, leftGet.keyExpr, expr.metadata, expr.pos);
			switch (op) {
				case NotEqual:
					call;				
				case Equal:
					makeASTWithMeta(EUnary(Not, call), expr.metadata, expr.pos);				
				default:
					makeASTWithMeta(EBinary(op, l, r), expr.metadata, expr.pos);				
			};
		} else if (rightGet != null && isNilLeft) {
			var call = makeIsMapKey(rightGet.mapExpr, rightGet.keyExpr, expr.metadata, expr.pos);
			switch (op) {
				case NotEqual:
					call;				
				case Equal:
					makeASTWithMeta(EUnary(Not, call), expr.metadata, expr.pos);				
				default:
					makeASTWithMeta(EBinary(op, l, r), expr.metadata, expr.pos);				
			};
		} else {
			makeASTWithMeta(EBinary(op, l, r), expr.metadata, expr.pos);
		};	
	case EUnary(uop, sub):
		var s = sanitizeGuardExprRecursive(sub);
		makeASTWithMeta(EUnary(uop, s), expr.metadata, expr.pos);	
	case ECall(target, name, args):
		var t = target != null ? sanitizeGuardExprRecursive(target) : null;
		var a = args != null ? args.map(sanitizeGuardExprRecursive) : [];
		makeASTWithMeta(ECall(t, name, a), expr.metadata, expr.pos);	
	case ERemoteCall(mod, name, args):
		var m = sanitizeGuardExprRecursive(mod);
		var a = args != null ? args.map(sanitizeGuardExprRecursive) : [];
		makeASTWithMeta(ERemoteCall(m, name, a), expr.metadata, expr.pos);	
	case EList(items):
		makeASTWithMeta(EList(items.map(sanitizeGuardExprRecursive)), expr.metadata, expr.pos);	
	case EParen(inner):
		makeASTWithMeta(EParen(sanitizeGuardExprRecursive(inner)), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var f = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = items;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								});
								var meta = expr.metadata;
								var pos = expr.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var name = `;
						var args = `;
						{
							var t = if (target != null) {
								reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(target);
							} else {
								null;
							};
							var a = if (args != null) {
								{
									var f = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								};
							} else {
								[];
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECall(t, name, a), metadata : expr.metadata, pos : expr.pos};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var mod = `;
						var name = `;
						var args = `;
						{
							var m = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(mod);
							var a = if (args != null) {
								{
									var f = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive;
									{
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while (` < `.length) {
												var v = `[`];
												++ `;
												`.push(f(v));
											};
										};
										`;
									};
								};
							} else {
								[];
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(m, name, a), metadata : expr.metadata, pos : expr.pos};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							var l = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(left);
							var r = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(right);
							var leftGet = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.extractMapGetCall(l);
							var rightGet = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.extractMapGetCall(r);
							var isNilLeft = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.isNil(l);
							var isNilRight = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.isNil(r);
							if (leftGet != null && isNilRight) {
								var call = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.makeIsMapKey(leftGet.mapExpr, leftGet.keyExpr, expr.metadata, expr.pos);
								@:ast(switch (op) {
	case NotEqual:
		call;	
	case Equal:
		makeASTWithMeta(EUnary(Not, call), expr.metadata, expr.pos);	
	default:
		makeASTWithMeta(EBinary(op, l, r), expr.metadata, expr.pos);	
}) switch (enumIndex op) {
									case 6: {
										{
											{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, call), metadata : expr.metadata, pos : expr.pos};
										};
									};
									case 7: {
										{
											call;
										};
									};
									default: {
										{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, l, r), metadata : expr.metadata, pos : expr.pos};
									}
								};
							} else {
								if (rightGet != null && isNilLeft) {
									var call = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.makeIsMapKey(rightGet.mapExpr, rightGet.keyExpr, expr.metadata, expr.pos);
									@:ast(switch (op) {
	case NotEqual:
		call;	
	case Equal:
		makeASTWithMeta(EUnary(Not, call), expr.metadata, expr.pos);	
	default:
		makeASTWithMeta(EBinary(op, l, r), expr.metadata, expr.pos);	
}) switch (enumIndex op) {
										case 6: {
											{
												{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, call), metadata : expr.metadata, pos : expr.pos};
											};
										};
										case 7: {
											{
												call;
											};
										};
										default: {
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, l, r), metadata : expr.metadata, pos : expr.pos};
										}
									};
								} else {
									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, l, r), metadata : expr.metadata, pos : expr.pos};
								};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var uop = `;
						var sub = `;
						{
							var s = reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(sub);
							{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(uop, s), metadata : expr.metadata, pos : expr.pos};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.transformers.GuardSanitizationTransforms.sanitizeGuardExprRecursive(inner));
								var meta = expr.metadata;
								var pos = expr.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					expr;
				}
			};
		};
	}

	static function makeIsMapKey(mapExpr:reflaxe.elixir.ast.ElixirAST, keyExpr:reflaxe.elixir.ast.ElixirAST, meta:Dynamic, pos:haxe.macro.Position) {
		return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
		}, "is_map_key", [mapExpr, keyExpr]), metadata : cast meta, pos : pos};
	}

	static function isNil(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EAtom(atom):
		atom == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 31: {
					var ` = `[0];
					{
						var atom = `;
						{
							atom == "nil";
						};
					};
				};
				case 36: {
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function extractMapGetCall(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case ERemoteCall(module, funcName, args):
		switch (module.def) {
			case EVar(modName) if (modName == "Map" && funcName == "get" && args != null && args.length == 2):
				{ mapExpr : args[0], keyExpr : args[1] };			
			default:
				null;			
		};	
	default:
		null;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var module = `;
					var funcName = `;
					var args = `;
					{
						@:ast(switch (module.def) {
	case EVar(modName) if (modName == "Map" && funcName == "get" && args != null && args.length == 2):
		{ mapExpr : args[0], keyExpr : args[1] };	
	default:
		null;	
}) {
							var ` = module.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var modName = `;
									if (modName == "Map" && funcName == "get" && args != null && args.length == 2) {
										{mapExpr : args[0], keyExpr : args[1]};
									} else {
										null;
									};
								};
							} else {
								null;
							};
						};
					};
				};
			} else {
				null;
			};
		};
	}
}