class reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, args, guards, body) if (name != "mount"):
		if (n.metadata != null && (Reflect.field(n.metadata, "isLiveView") == true)) {
			if (!StringTools.startsWith(name, "render_") && !(name == "handle_event" && args != null && args.length == 3)) return n;
		};
		var usedInFn = collectUsedVars(body);
		var newBody = rewriteBlocks(body, usedInFn);
		makeASTWithMeta(EDef(name, args, guards, newBody), n.metadata, n.pos);	
	case EDefp(name2, args2, guards2, body2) if (name2 != "mount"):
		if (n.metadata != null && (Reflect.field(n.metadata, "isLiveView") == true)) {
			if (!StringTools.startsWith(name2, "render_") && !(name2 == "handle_event" && args2 != null && args2.length == 3)) return n;
		};
		var usedInFn2 = collectUsedVars(body2);
		var newBody2 = rewriteBlocks(body2, usedInFn2);
		makeASTWithMeta(EDefp(name2, args2, guards2, newBody2), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							if (name != "mount") {
								if (n.metadata != null && (Reflect.field(n.metadata, "isLiveView") == true)) {
									if (! StringTools.startsWith(name, "render_") && ! (name == "handle_event" && args != null && args.length == 3)) {
										return n;
									};
								};
								var usedInFn = reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.collectUsedVars(body);
								var newBody = reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.rewriteBlocks(body, usedInFn);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, newBody), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name2 = `;
							var args2 = `;
							var guards2 = `;
							var body2 = `;
							if (name2 != "mount") {
								if (n.metadata != null && (Reflect.field(n.metadata, "isLiveView") == true)) {
									if (! StringTools.startsWith(name2, "render_") && ! (name2 == "handle_event" && args2 != null && args2.length == 3)) {
										return n;
									};
								};
								var usedInFn2 = reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.collectUsedVars(body2);
								var newBody2 = reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.rewriteBlocks(body2, usedInFn2);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name2, args2, guards2, newBody2), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static function rewriteBlocks(node:reflaxe.elixir.ast.ElixirAST, used:Map<String, Bool>) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EBlock(stmts):
		makeASTWithMeta(EBlock(rewrite(stmts, used)), x.metadata, x.pos);	
	case EDo(stmts2):
		makeASTWithMeta(EDo(rewrite(stmts2, used)), x.metadata, x.pos);	
	case EFn(clauses):
		var newClauses = [];
		for (c  in  clauses) {
			var nb = rewriteBlocks(c.body, used);
			newClauses.push({ args : c.args, guard : c.guard, body : nb });
		};
		makeASTWithMeta(EFn(newClauses), x.metadata, x.pos);	
	default:
		x;	
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										var nb = reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.rewriteBlocks(c.body, used);
										newClauses.push({args : c.args, guard : c.guard, body : nb});
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : x.metadata, pos : x.pos};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.rewrite(stmts, used));
									var meta = x.metadata;
									var pos = x.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var stmts2 = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDo(reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.rewrite(stmts2, used));
									var meta = x.metadata;
									var pos = x.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						x;
					}
				};
			};
		});
	}

	static function rewrite(stmts:Array<reflaxe.elixir.ast.ElixirAST>, used:Map<String, Bool>) {
		if (stmts == null) {
			return stmts;
		};
		var out = [];
		{
			var ` = 0;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				var s = stmts[i];
				var s1 = @:ast(switch (s.def) {
	case EMatch(PVar(b), rhs) if (b != "children" && !usedLater(stmts, i + 1, b) && !used.exists(b) && (isEphemeralRhs(rhs) || (b == "g" && isCase(rhs)))):
		makeASTWithMeta(EMatch(PVar("_" + b), rhs), s.metadata, s.pos);	
	case EBinary(Match, { def : EVar(b2) }, rhs2) if (b2 != "children" && !usedLater(stmts, i + 1, b2) && !used.exists(b2) && (isEphemeralRhs(rhs2) || (b2 == "g" && isCase(rhs2)))):
		makeASTWithMeta(EBinary(Match, makeAST(EVar("_" + b2)), rhs2), s.metadata, s.pos);	
	case EBinary(Match, { def : EVar(b3) }, rhs3):
		switch (rhs3.def) {
			case ERemoteCall({ def : EVar("Map") }, "get", ra) if (ra != null && ra.length == 2):
				switch (ra[1].def) {
					case EString(key) if (usedLater(stmts, i + 1, key) && !used.exists(key)):
						makeASTWithMeta(EBinary(Match, makeAST(EVar(key)), rhs3), s.metadata, s.pos);					
					default:
						s;					
				};			
			default:
				s;			
		};	
	default:
		s;	
}) {
					var ` = s.def;
					switch (enumIndex `) {
						case 8: {
							var ` = `[0];
							var ` = `[1];
							if (enumIndex ` == 0) {
								var ` = `[0];
								{
									var b = `;
									var rhs = `;
									if (b != "children" && ! reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.usedLater(stmts, i + 1, b) && ! used.exists(b) && (reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.isEphemeralRhs(rhs) || (b == "g" && reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.isCase(rhs)))) {
										{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("_" + b), rhs), metadata : s.metadata, pos : s.pos};
									} else {
										s;
									};
								};
							} else {
								s;
							};
						};
						case 26: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 27) {
								{
									var ` = `.def;
									var ` = `.metadata;
									var ` = `.pos;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var b2 = `;
											var rhs2 = `;
											if (b2 != "children" && ! reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.usedLater(stmts, i + 1, b2) && ! used.exists(b2) && (reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.isEphemeralRhs(rhs2) || (b2 == "g" && reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.isCase(rhs2)))) {
												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_" + b2), metadata : {}, pos : pos};
												}, rhs2), metadata : s.metadata, pos : s.pos};
											} else {
												var b3 = `;
												var rhs3 = `;
												{
													@:ast(switch (rhs3.def) {
	case ERemoteCall({ def : EVar("Map") }, "get", ra) if (ra != null && ra.length == 2):
		switch (ra[1].def) {
			case EString(key) if (usedLater(stmts, i + 1, key) && !used.exists(key)):
				makeASTWithMeta(EBinary(Match, makeAST(EVar(key)), rhs3), s.metadata, s.pos);			
			default:
				s;			
		};	
	default:
		s;	
}) {
														var ` = rhs3.def;
														if (enumIndex ` == 24) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	if (` == "Map") {
																		if (` == "get") {
																			{
																				var ra = `;
																				if (ra != null && ra.length == 2) {
																					@:ast(switch (ra[1].def) {
	case EString(key) if (usedLater(stmts, i + 1, key) && !used.exists(key)):
		makeASTWithMeta(EBinary(Match, makeAST(EVar(key)), rhs3), s.metadata, s.pos);	
	default:
		s;	
}) {
																						var ` = ra[1].def;
																						if (enumIndex ` == 32) {
																							var ` = `[0];
																							{
																								var key = `;
																								if (reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.usedLater(stmts, i + 1, key) && ! used.exists(key)) {
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(key), metadata : {}, pos : pos};
																									}, rhs3), metadata : s.metadata, pos : s.pos};
																								} else {
																									s;
																								};
																							};
																						} else {
																							s;
																						};
																					};
																				} else {
																					s;
																				};
																			};
																		} else {
																			s;
																		};
																	} else {
																		s;
																	};
																} else {
																	s;
																};
															};
														} else {
															s;
														};
													};
												};
											};
										};
									} else {
										s;
									};
								};
							} else {
								s;
							};
						};
						default: {
							s;
						}
					};
				};
				out.push(s1);
			};
		};
		return out;
	}

	static function usedLater(stmts:Array<reflaxe.elixir.ast.ElixirAST>, start:Int, name:String) {
		var found = [false];
		{
			var ` = start;
			var ` = stmts.length;
			while (` < `) {
				var j = ` ++;
				if (! found[0]) {
					reflaxe.elixir.ast.ASTUtils.walk(stmts[j], function(x:reflaxe.elixir.ast.ElixirAST) {
						@:ast(switch (x.def) {
	case EVar(v) if (v == name):
		found = true;	
	default:
}) {
							var ` = x.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var v = `;
									if (v == name) {
										found[0] = true;
									} else {};
								};
							} else {};
						};
					});
				};
			};
		};
		return found[0];
	}

	static function isCase(rhs:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (rhs.def) {
	case ECase(_, _):
		true;	
	default:
		false;	
}) {
			var ` = rhs.def;
			if (enumIndex ` == 6) {
				var ` = `[0];
				var ` = `[1];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function collectUsedVars(node:reflaxe.elixir.ast.ElixirAST) {
		var used = {
			{};
			new haxe.ds.StringMap();
		};
		reflaxe.elixir.ast.ASTUtils.walk(node, function(x:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (x.def) {
	case EVar(v):
		used.set(v, true);	
	default:
}) {
				var ` = x.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						{
							{
								used.set(v, true);
							};
						};
					};
				} else {};
			};
		});
		return used;
	}

	static function isEphemeralRhs(rhs:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (rhs.def) {
	case ERemoteCall({ def : EVar("Map") }, fnName, args) if (fnName == "get" && args != null && args.length == 2):
		switch (args[1].def) {
			case EString(_):
				true;			
			default:
				isNuisanceKey(args[1]);			
		};	
	default:
		false;	
}) {
			var ` = rhs.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var ` = `.def;
					var ` = `.metadata;
					var ` = `.pos;
					if (enumIndex ` == 38) {
						var ` = `[0];
						if (` == "Map") {
							{
								var fnName = `;
								var args = `;
								if (fnName == "get" && args != null && args.length == 2) {
									@:ast(switch (args[1].def) {
	case EString(_):
		true;	
	default:
		isNuisanceKey(args[1]);	
}) {
										var ` = args[1].def;
										if (enumIndex ` == 32) {
											var ` = `[0];
											{
												true;
											};
										} else {
											reflaxe.elixir.ast.transformers.LocalAssignUnusedUnderscoreScopedTransforms.isNuisanceKey(args[1]);
										};
									};
								} else {
									false;
								};
							};
						} else {
							false;
						};
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
	}

	static function isNuisanceKey(arg:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (arg.def) {
	case EString(s) if (s == "to_string" || s == "fn" || s == "end" || s == "sort_by"):
		true;	
	default:
		false;	
}) {
			var ` = arg.def;
			if (enumIndex ` == 32) {
				var ` = `[0];
				{
					var s = `;
					if (s == "to_string" || s == "fn" || s == "end" || s == "sort_by") {
						true;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
	}
}