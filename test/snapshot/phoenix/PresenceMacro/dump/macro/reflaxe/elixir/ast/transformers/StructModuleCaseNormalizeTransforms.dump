class reflaxe.elixir.ast.transformers.StructModuleCaseNormalizeTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EStruct(modName, fields):
		var newName = (function() {
			var parts = modName.split(".");
			if (parts.length <= 1) return modName;
			var changed = false;
			for (i  in  0 ... parts.length) {
				var p = parts[i];
				var c = capFirst(p);
				if (c != p) {
					parts[i] = c;
					changed = true;
				};
			};
			return changed ? parts.join(".") : modName;
		})();
		if (newName != modName) makeASTWithMeta(EStruct(newName, fields), n.metadata, n.pos) else n;	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 18) {
					var ` = `[0];
					var ` = `[1];
					{
						var modName = `;
						var fields = `;
						{
							var newName = (function() {
								var parts = modName.split(".");
								if (parts.length <= 1) {
									return modName;
								};
								var changed = false;
								{
									var ` = 0;
									var ` = parts.length;
									while (` < `) {
										var i = ` ++;
										var p = parts[i];
										var c = if (p == null || p.length == 0) {
											p;
										} else {
											var c = p.charAt(0);
											var cu = c.toUpperCase();
											var cl = c.toLowerCase();
											if (c == cl && c != cu) {
												cu + p.substr(1, null);
											} else {
												p;
											};
										};
										if (c != p) {
											parts[i] = c;
											changed = true;
										};
									};
								};
								return if (changed) {
									parts.join(".");
								} else {
									modName;
								};
							})();
							if (newName != modName) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EStruct(newName, fields), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}
}