class reflaxe.elixir.ast.transformers.CaseSecondBinderCanonicalUnderscoreTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ECase(expr, clauses):
		var out:Array<ECaseClause> = [];
		for (cl  in  clauses) out.push(canonicalize(cl));
		makeASTWithMeta(ECase(expr, out), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							var out = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									out.push(reflaxe.elixir.ast.transformers.CaseSecondBinderCanonicalUnderscoreTransforms.canonicalize(cl));
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(expr, out), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	@:has_untyped
	static function canonicalize(cl:reflaxe.elixir.ast.ECaseClause) {
		var binder = null;
		var newPat = @:ast(switch (cl.pattern) {
	case PTuple(es) if (es.length == 2):
		switch (es[1]) {
			case PVar(n) if (n != null && n.length > 0):
				binder = n;			
			default:
		};
		cl.pattern;	
	default:
		cl.pattern;	
}) {
			var ` = cl.pattern;
			if (enumIndex ` == 2) {
				var ` = `[0];
				{
					var es = `;
					if (es.length == 2) {
						@:ast(switch (es[1]) {
	case PVar(n) if (n != null && n.length > 0):
		binder = n;	
	default:
}) {
							var ` = es[1];
							if (enumIndex ` == 0) {
								var ` = `[0];
								{
									var n = `;
									if (n != null && n.length > 0) {
										binder = n;
									} else {};
								};
							} else {};
						};
						cl.pattern;
					} else {
						cl.pattern;
					};
				};
			} else {
				cl.pattern;
			};
		};
		if (binder == null) {
			return cl;
		};
		var used = reflaxe.elixir.ast.transformers.CaseSecondBinderCanonicalUnderscoreTransforms.collectUsed(cl.body, cl.guard);
		var pat2 = @:ast(switch (cl.pattern) {
	case PTuple(es2) if (es2.length == 2):
		PTuple([es2[0], PVar("_value")]);	
	default:
		cl.pattern;	
}) {
			var ` = cl.pattern;
			if (enumIndex ` == 2) {
				var ` = `[0];
				{
					var es2 = `;
					if (es2.length == 2) {
						reflaxe.elixir.ast.EPattern.PTuple([es2[0], reflaxe.elixir.ast.EPattern.PVar("_value")]);
					} else {
						cl.pattern;
					};
				};
			} else {
				cl.pattern;
			};
		};
		if (pat2 != cl.pattern) {
			Sys.println("[CaseSecondBinderCanonical] canonicalized second binder to _value");
		};
		var body2 = cl.body;
		try {
			if (body2 != null) {
				if (body2.metadata == null) {
					body2.metadata = {};
				};
				body2.metadata.lockPayloadBinder = true;
				body2.metadata.canonicalPayloadValue = true;
			};
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
		return {pattern : pat2, guard : cl.guard, body : body2};
	}

	static function collectUsed(body:reflaxe.elixir.ast.ElixirAST, guard:Null<reflaxe.elixir.ast.ElixirAST>) {
		var s = {
			{};
			new haxe.ds.StringMap();
		};
		var scan = [null];
		scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(v):
		s.set(v, true);	
	case EString(str):
		markInterpolations(str, s);	
	case ERaw(code):
		markInterpolations(code, s);	
	case EBlock(ss):
		for (x  in  ss) scan(x);	
	case EDo(ss2):
		for (x  in  ss2) scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EMatch(_, rhs):
		scan(rhs);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(e, cls):
		scan(e);
		for (c  in  cls) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var cls = `;
							{
								scan[0](e);
								{
									var ` = 0;
									while (` < cls.length) {
										var c = cls[`];
										++ `;
										if (c.guard != null) {
											scan[0](c.guard);
										};
										scan[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								scan[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								scan[0](c);
								scan[0](t);
								if (e != null) {
									scan[0](e);
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								scan[0](l);
								scan[0](r);
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var str = `;
							{
								reflaxe.elixir.ast.transformers.CaseSecondBinderCanonicalUnderscoreTransforms.markInterpolations(str, s);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var v = `;
							{
								{
									s.set(v, true);
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var x = ss[`];
										++ `;
										scan[0](x);
									};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var ss2 = `;
							{
								{
									var ` = 0;
									while (` < ss2.length) {
										var x = ss2[`];
										++ `;
										scan[0](x);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								reflaxe.elixir.ast.transformers.CaseSecondBinderCanonicalUnderscoreTransforms.markInterpolations(code, s);
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](body);
		if (guard != null) {
			scan[0](guard);
		};
		return s;
	}

	static function markInterpolations(s:String, used:Map<String, Bool>) {
		if (s == null) {
			return;
		};
		var re = new EReg("\\#\\{([^}]*)\\}", "g");
		var pos = 0;
		while (re.matchSub(s, pos, null)) {
			var inner = re.matched(1);
			var tok = new EReg("[A-Za-z_][A-Za-z0-9_]*", "g");
			var tpos = 0;
			while (tok.matchSub(inner, tpos, null)) {
				{
					var key = tok.matched(0);
					used.set(key, true);
				};
				tpos = tok.matchedPos().pos + tok.matchedPos().len;
			};
			pos = re.matchedPos().pos + re.matchedPos().len;
		};
	}
}