class reflaxe.elixir.ast.transformers.ClosureUnusedAssignmentDiscardTransforms {

	public static function discardPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var body = cl.body;
			switch (body.def) {
				case EBlock(stmts):
					var out:Array<ElixirAST> = [];
					for (i  in  0 ... stmts.length) {
						var s = stmts[i];
						var replaced = false;
						switch (s.def) {
							case EBinary(Match, left, rhs):
								switch (left.def) {
									case EVar(name):
										if ((name != null && name.length > 0 && name.charAt(0) == "_") && !futureUsesName(stmts, i + 1, name) && !exprReferencesName(rhs, name)) {
											out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
											replaced = true;
										};									
									default:
								};							
							default:
						};
						if (!replaced) out.push(s);
					};
					newClauses.push({ args : cl.args, guard : cl.guard, body : makeASTWithMeta(EBlock(out), body.metadata, body.pos) });				
				default:
					newClauses.push(cl);				
			};
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var body = cl.body;
									@:ast(switch (body.def) {
	case EBlock(stmts):
		var out:Array<ElixirAST> = [];
		for (i  in  0 ... stmts.length) {
			var s = stmts[i];
			var replaced = false;
			switch (s.def) {
				case EBinary(Match, left, rhs):
					switch (left.def) {
						case EVar(name):
							if ((name != null && name.length > 0 && name.charAt(0) == "_") && !futureUsesName(stmts, i + 1, name) && !exprReferencesName(rhs, name)) {
								out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
								replaced = true;
							};						
						default:
					};				
				default:
			};
			if (!replaced) out.push(s);
		};
		newClauses.push({ args : cl.args, guard : cl.guard, body : makeASTWithMeta(EBlock(out), body.metadata, body.pos) });	
	default:
		newClauses.push(cl);	
}) {
										var ` = body.def;
										if (enumIndex ` == 53) {
											var ` = `[0];
											{
												var stmts = `;
												{
													var out = [];
													{
														var ` = 0;
														var ` = stmts.length;
														while (` < `) {
															var i = ` ++;
															var s = stmts[i];
															var replaced = false;
															@:ast(switch (s.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(name):
				if ((name != null && name.length > 0 && name.charAt(0) == "_") && !futureUsesName(stmts, i + 1, name) && !exprReferencesName(rhs, name)) {
					out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
					replaced = true;
				};			
			default:
		};	
	default:
}) {
																var ` = s.def;
																if (enumIndex ` == 26) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	if (enumIndex ` == 27) {
																		{
																			var left = `;
																			var rhs = `;
																			{
																				@:ast(switch (left.def) {
	case EVar(name):
		if ((name != null && name.length > 0 && name.charAt(0) == "_") && !futureUsesName(stmts, i + 1, name) && !exprReferencesName(rhs, name)) {
			out.push(makeASTWithMeta(EMatch(PWildcard, rhs), s.metadata, s.pos));
			replaced = true;
		};	
	default:
}) {
																					var ` = left.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var name = `;
																							{
																								if ((name != null && name.length > 0 && name.charAt(0) == "_") && ! reflaxe.elixir.ast.transformers.ClosureUnusedAssignmentDiscardTransforms.futureUsesName(stmts, i + 1, name) && ! reflaxe.elixir.ast.transformers.ClosureUnusedAssignmentDiscardTransforms.exprReferencesName(rhs, name)) {
																									out.push({def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PWildcard, rhs), metadata : s.metadata, pos : s.pos});
																									replaced = true;
																								};
																							};
																						};
																					} else {};
																				};
																			};
																		};
																	} else {};
																} else {};
															};
															if (! replaced) {
																out.push(s);
															};
														};
													};
													newClauses.push({args : cl.args, guard : cl.guard, body : {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : body.metadata, pos : body.pos}});
												};
											};
										} else {
											newClauses.push(cl);
										};
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function exprReferencesName(e:reflaxe.elixir.ast.ElixirAST, name:String) {
		var found = [false];
		var visit = [null];
		visit[0] = function(x:reflaxe.elixir.ast.ElixirAST) {
			if (found[0] || x == null || x.def == null) {
				return;
			};
			@:ast(switch (x.def) {
	case EVar(n) if (n == name):
		found = true;	
	case EBinary(_, l, r):
		visit(l);
		visit(r);	
	case EMatch(_, rhs):
		visit(rhs);	
	case ECall(t, _, args):
		if (t != null) visit(t);
		if (args != null) for (a  in  args) visit(a);	
	case ERemoteCall(moduleExpr, _, remoteArgs):
		visit(moduleExpr);
		if (remoteArgs != null) for (argument  in  remoteArgs) visit(argument);	
	case EBlock(ss):
		for (s  in  ss) visit(s);	
	case EIf(c, t, el):
		visit(c);
		visit(t);
		if (el != null) visit(el);	
	case ECase(cond, cs):
		visit(cond);
		for (c  in  cs) {
			if (c.guard != null) visit(c.guard);
			visit(c.body);
		};	
	default:
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var cond = `;
							var cs = `;
							{
								visit[0](cond);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											visit[0](c.guard);
										};
										visit[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								visit[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var el = `;
							{
								visit[0](c);
								visit[0](t);
								if (el != null) {
									visit[0](el);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t = `;
							var args = `;
							{
								if (t != null) {
									visit[0](t);
								};
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var a = args[`];
											++ `;
											visit[0](a);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var moduleExpr = `;
							var remoteArgs = `;
							{
								visit[0](moduleExpr);
								if (remoteArgs != null) {
									{
										var ` = 0;
										while (` < remoteArgs.length) {
											var argument = remoteArgs[`];
											++ `;
											visit[0](argument);
										};
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								visit[0](l);
								visit[0](r);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var n = `;
							if (n == name) {
								found[0] = true;
							} else {};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										visit[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		visit[0](e);
		return found[0];
	}

	static function futureUsesName(stmts:Array<reflaxe.elixir.ast.ElixirAST>, start:Int, name:String) {
		{
			var ` = start;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				if (reflaxe.elixir.ast.transformers.ClosureUnusedAssignmentDiscardTransforms.statementUsesName(stmts[i], name)) {
					return true;
				};
			};
		};
		return false;
	}

	static function statementUsesName(s:reflaxe.elixir.ast.ElixirAST, name:String) {
		var found = [false];
		var visit = [null];
		visit[0] = function(e:reflaxe.elixir.ast.ElixirAST) {
			if (found[0] || e == null || e.def == null) {
				return;
			};
			@:ast(switch (e.def) {
	case EVar(n) if (n == name):
		found = true;	
	case ERaw(code):
		if (code != null && containsIdent(code, name)) found = true;	
	case EBlock(ss):
		for (x  in  ss) visit(x);	
	case EIf(c, t, el):
		visit(c);
		visit(t);
		if (el != null) visit(el);	
	case ECase(expr, cs):
		visit(expr);
		for (c  in  cs) {
			if (c.guard != null) visit(c.guard);
			visit(c.body);
		};	
	case EBinary(_, l, r):
		visit(l);
		visit(r);	
	case EMatch(_, rhs):
		visit(rhs);	
	case ECall(target, _, arguments):
		if (target != null) visit(target);
		for (argument  in  arguments) visit(argument);	
	case ERemoteCall(remoteTarget, _, remoteArgs):
		visit(remoteTarget);
		for (argument  in  remoteArgs) visit(argument);	
	case EList(els):
		for (el  in  els) visit(el);	
	case ETuple(els):
		for (el  in  els) visit(el);	
	case EMap(pairs):
		for (p  in  pairs) {
			visit(p.key);
			visit(p.value);
		};	
	case EKeywordList(pairs):
		for (p  in  pairs) visit(p.value);	
	case EStructUpdate(base, fields):
		visit(base);
		for (f  in  fields) visit(f.value);	
	case EFn(clauses):
		for (cl  in  clauses) visit(cl.body);	
	default:
}) {
				var ` = e.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var cs = `;
							{
								visit[0](expr);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											visit[0](c.guard);
										};
										visit[0](c.body);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var rhs = `;
							{
								visit[0](rhs);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var el = `;
							{
								visit[0](c);
								visit[0](t);
								if (el != null) {
									visit[0](el);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var els = `;
							{
								{
									var ` = 0;
									while (` < els.length) {
										var el = els[`];
										++ `;
										visit[0](el);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var els = `;
							{
								{
									var ` = 0;
									while (` < els.length) {
										var el = els[`];
										++ `;
										visit[0](el);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										visit[0](p.key);
										visit[0](p.value);
									};
								};
							};
						};
					};
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var base = `;
							var fields = `;
							{
								visit[0](base);
								{
									var ` = 0;
									while (` < fields.length) {
										var f = fields[`];
										++ `;
										visit[0](f.value);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										visit[0](p.value);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var arguments = `;
							{
								if (target != null) {
									visit[0](target);
								};
								{
									var ` = 0;
									while (` < arguments.length) {
										var argument = arguments[`];
										++ `;
										visit[0](argument);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var remoteTarget = `;
							var remoteArgs = `;
							{
								visit[0](remoteTarget);
								{
									var ` = 0;
									while (` < remoteArgs.length) {
										var argument = remoteArgs[`];
										++ `;
										visit[0](argument);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								visit[0](l);
								visit[0](r);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var n = `;
							if (n == name) {
								found[0] = true;
							} else {};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										visit[0](cl.body);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var x = ss[`];
										++ `;
										visit[0](x);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								if (code != null && reflaxe.elixir.ast.transformers.ClosureUnusedAssignmentDiscardTransforms.containsIdent(code, name)) {
									found[0] = true;
								};
							};
						};
					};
					default: {}
				};
			};
		};
		visit[0](s);
		return found[0];
	}

	static function containsIdent(s:String, ident:String) {
		if (s == null || ident == null || ident.length == 0) {
			return false;
		};
		var i = 0;
		while (i < s.length) {
			var idx = s.indexOf(ident, i);
			if (idx == -1) {
				return false;
			};
			var ok = true;
			if (idx > 0) {
				var p = s.charAt(idx - 1);
				if (if (p == null || p.length == 0) {
					false;
				} else {
					var c = p.charCodeAt(0);
					(c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57) || c == 95;
				}) {
					ok = false;
				};
			};
			var endIdx = idx + ident.length;
			if (endIdx < s.length) {
				var n = s.charAt(endIdx);
				if (if (n == null || n.length == 0) {
					false;
				} else {
					var c = n.charCodeAt(0);
					(c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57) || c == 95;
				}) {
					ok = false;
				};
			};
			if (ok) {
				return true;
			} else {
				i = endIdx;
			};
		};
		return false;
	}

	static inline function isIdent(ch:String) {
		if (ch == null || ch.length == 0) {
			return false;
		};
		var c = ch.charCodeAt(0);
		return (c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57) || c == 95;
	}
}