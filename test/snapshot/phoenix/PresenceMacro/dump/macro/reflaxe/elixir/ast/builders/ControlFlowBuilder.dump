@:nullSafety(Off)
class reflaxe.elixir.ast.builders.ControlFlowBuilder {

	public static function buildIf(econd:haxe.macro.TypedExpr, eif:haxe.macro.TypedExpr, eelse:Null<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		var optimizedSwitch = reflaxe.elixir.ast.builders.ControlFlowBuilder.detectOptimizedEnumSwitch(econd, eif, eelse, context);
		if (optimizedSwitch != null) {
			return optimizedSwitch;
		};
		var condition = buildExpression(econd);
		var thenBranch = buildExpression(eif);
		var elseBranch = if (eelse != null) {
			buildExpression(eelse);
		} else {
			null;
		};
		if (reflaxe.elixir.ast.builders.ControlFlowBuilder.shouldUseCond(eif, eelse)) {
			return reflaxe.elixir.ast.builders.ControlFlowBuilder.buildCondStatement(econd, eif, eelse, context);
		};
		return reflaxe.elixir.ast.ElixirASTDef.EIf(condition, thenBranch, elseBranch);
	}

	static function detectOptimizedEnumSwitch(econd:haxe.macro.TypedExpr, eif:haxe.macro.TypedExpr, eelse:Null<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		var condToCheck = @:ast(switch (econd.expr) {
	case TParenthesis(inner):
		inner;	
	default:
		econd;	
}) {
			var ` = econd.expr;
			if (enumIndex ` == 6) {
				var ` = `[0];
				{
					var inner = `;
					{
						inner;
					};
				};
			} else {
				econd;
			};
		};
		var enumValue = null;
		var enumIndex = -1;
		var enumTypeRef = null;
		@:ast(switch (condToCheck.expr) {
	case TBinop(OpEq, { expr : TEnumIndex(e) }, { expr : TConst(TInt(index)) }) | TBinop(OpEq, { expr : TConst(TInt(index)) }, { expr : TEnumIndex(e) }):
		switch (e.t) {
			case TEnum(eRef, _):
				enumValue = e;
				enumIndex = index;
				enumTypeRef = eRef;			
			default:
		};	
	default:
}) {
			var ` = condToCheck.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 5) {
					{
						var ` = `.expr;
						var ` = `.pos;
						var ` = `.t;
						switch (enumIndex `) {
							case 0: {
								var ` = `[0];
								if (enumIndex ` == 0) {
									var ` = `[0];
									{
										var ` = `.expr;
										var ` = `.pos;
										var ` = `.t;
										if (enumIndex ` == 27) {
											var ` = `[0];
											{
												var e = `;
												var index = `;
												{
													@:ast(switch (e.t) {
	case TEnum(eRef, _):
		enumValue = e;
		enumIndex = index;
		enumTypeRef = eRef;	
	default:
}) {
														var ` = e.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															var ` = `[1];
															{
																var eRef = `;
																{
																	enumValue = e;
																	enumIndex = index;
																	enumTypeRef = eRef;
																};
															};
														} else {};
													};
												};
											};
										} else {};
									};
								} else {};
							};
							case 27: {
								var ` = `[0];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var index = `;
												var e = `;
												{
													@:ast(switch (e.t) {
	case TEnum(eRef, _):
		enumValue = e;
		enumIndex = index;
		enumTypeRef = eRef;	
	default:
}) {
														var ` = e.t;
														if (enumIndex ` == 1) {
															var ` = `[0];
															var ` = `[1];
															{
																var eRef = `;
																{
																	enumValue = e;
																	enumIndex = index;
																	enumTypeRef = eRef;
																};
															};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
							};
							default: {}
						};
					};
				} else {};
			} else {};
		};
		if (enumValue != null && enumIndex >= 0 && enumTypeRef != null) {
			var enumTypeInfo = enumTypeRef.get();
			var matchingConstructor = null;
			var constructorParams = 0;
			for (name in {
				var this = enumTypeInfo.constructs;
				cast this.keys();
			}) {
				var construct = {
					var this = enumTypeInfo.constructs;
					cast this.get(name);
				};
				if (construct.index == enumIndex) {
					matchingConstructor = name;
					@:ast(switch (construct.type) {
	case TFun(args, _):
		constructorParams = args.length;	
	default:
		constructorParams = 0;	
}) {
						var ` = construct.type;
						if (enumIndex ` == 4) {
							var ` = `[0];
							var ` = `[1];
							{
								var args = `;
								{
									constructorParams = args.length;
								};
							};
						} else {
							constructorParams = 0;
						};
					};
					break;
				};
			};
			if (matchingConstructor != null) {
				var enumExpr = buildExpression(enumValue);
				var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(matchingConstructor);
				var patternAST = if (constructorParams == 0) {
					{
						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
							var this;
							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
							cast this;
						});
						var pos = null;
						{def : def, metadata : {}, pos : pos};
					};
				} else {
					var elements = [{
						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
							var this;
							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
							cast this;
						});
						var pos = null;
						{def : def, metadata : {}, pos : pos};
					}];
					{
						var ` = 0;
						var ` = constructorParams;
						while (` < `) {
							var _ = ` ++;
							elements.push({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_"), metadata : {}, pos : pos};
							});
						};
					};
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(elements), metadata : {}, pos : pos};
					};
				};
				var pattern = reflaxe.elixir.ast.EPattern.PLiteral(patternAST);
				var clauses = [];
				clauses.push({pattern : pattern, guard : null, body : buildExpression(eif)});
				if (eelse != null) {
					clauses.push({pattern : reflaxe.elixir.ast.EPattern.PWildcard, guard : null, body : buildExpression(eelse)});
				} else {
					clauses.push({pattern : reflaxe.elixir.ast.EPattern.PWildcard, guard : null, body : {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EThrow({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EString("Unmatched enum value"), metadata : {}, pos : pos};
						}), metadata : {}, pos : pos};
					}});
				};
				return reflaxe.elixir.ast.ElixirASTDef.ECase(enumExpr, clauses);
			};
		};
		return null;
	}

	static function shouldUseCond(eif:haxe.macro.TypedExpr, eelse:Null<haxe.macro.TypedExpr>) {
		if (eelse == null) {
			return false;
		};
		{};
		return @:ast(switch (eelse.expr) {
	case TIf(_, if2, else2):
		if (isSimpleLiteral(eif) && isSimpleLiteral(if2) && else2 != null && isSimpleLiteral(else2)) false else true;	
	case TBlock([single]) if (single.expr.match(TIf(_, _, _))):
		switch (single.expr) {
			case TIf(_, ifb, elseb):
				if (isSimpleLiteral(eif) && isSimpleLiteral(ifb) && elseb != null && isSimpleLiteral(elseb)) false else true;			
			case _:
				true;			
		};	
	default:
		false;	
}) {
			var ` = eelse.expr;
			switch (enumIndex `) {
				case 14: {
					var ` = `[0];
					if (`.length == 1) {
						var ` = `[0];
						{
							var single = `;
							if ({
								var ` = single.expr;
								if (enumIndex ` == 16) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									true;
								} else false;
							}) {
								@:ast(switch (single.expr) {
	case TIf(_, ifb, elseb):
		if (isSimpleLiteral(eif) && isSimpleLiteral(ifb) && elseb != null && isSimpleLiteral(elseb)) false else true;	
	case _:
		true;	
}) {
									var ` = single.expr;
									if (enumIndex ` == 16) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var ifb = `;
											var elseb = `;
											{
												if (@:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
													var ` = eif.expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														switch (enumIndex `) {
															case 0: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 1: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 2: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 3: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 4: {
																{
																	true;
																};
															};
															default: {
																false;
															}
														};
													} else {
														false;
													};
												} && @:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
													var ` = ifb.expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														switch (enumIndex `) {
															case 0: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 1: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 2: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 3: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 4: {
																{
																	true;
																};
															};
															default: {
																false;
															}
														};
													} else {
														false;
													};
												} && elseb != null && @:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
													var ` = elseb.expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														switch (enumIndex `) {
															case 0: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 1: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 2: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 3: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 4: {
																{
																	true;
																};
															};
															default: {
																false;
															}
														};
													} else {
														false;
													};
												}) {
													false;
												} else {
													true;
												};
											};
										};
									} else {
										true;
									};
								};
							} else {
								false;
							};
						};
					} else {
						false;
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var if2 = `;
						var else2 = `;
						{
							if (@:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
								var ` = eif.expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											{
												true;
											};
										};
										case 1: {
											var ` = `[0];
											{
												true;
											};
										};
										case 2: {
											var ` = `[0];
											{
												true;
											};
										};
										case 3: {
											var ` = `[0];
											{
												true;
											};
										};
										case 4: {
											{
												true;
											};
										};
										default: {
											false;
										}
									};
								} else {
									false;
								};
							} && @:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
								var ` = if2.expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											{
												true;
											};
										};
										case 1: {
											var ` = `[0];
											{
												true;
											};
										};
										case 2: {
											var ` = `[0];
											{
												true;
											};
										};
										case 3: {
											var ` = `[0];
											{
												true;
											};
										};
										case 4: {
											{
												true;
											};
										};
										default: {
											false;
										}
									};
								} else {
									false;
								};
							} && else2 != null && @:ast(switch (te.expr) {
	case TConst(TInt(_)) | TConst(TFloat(_)) | TConst(TString(_)) | TConst(TNull) | TConst(TBool(_)):
		true;	
	case _:
		false;	
}) {
								var ` = else2.expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									switch (enumIndex `) {
										case 0: {
											var ` = `[0];
											{
												true;
											};
										};
										case 1: {
											var ` = `[0];
											{
												true;
											};
										};
										case 2: {
											var ` = `[0];
											{
												true;
											};
										};
										case 3: {
											var ` = `[0];
											{
												true;
											};
										};
										case 4: {
											{
												true;
											};
										};
										default: {
											false;
										}
									};
								} else {
									false;
								};
							}) {
								false;
							} else {
								true;
							};
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function buildCondStatement(econd:haxe.macro.TypedExpr, eif:haxe.macro.TypedExpr, eelse:Null<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		var clauses = [];
		var hasFinalElse = false;
		clauses.push({condition : buildExpression(econd), body : buildExpression(eif)});
		var current = eelse;
		while (current != null) {
			@:ast(switch (current.expr) {
	case TIf(cond2, if2, else2):
		clauses.push({ condition : buildExpression(cond2), body : buildExpression(if2) });
		current = else2;	
	case TBlock([single]):
		current = single;	
	default:
		clauses.push({ condition : makeAST(EAtom("true")), body : buildExpression(current) });
		hasFinalElse = true;
		break;	
}) {
				var ` = current.expr;
				switch (enumIndex `) {
					case 14: {
						var ` = `[0];
						if (`.length == 1) {
							var ` = `[0];
							{
								var single = `;
								{
									current = single;
								};
							};
						} else {
							clauses.push({condition : {
								var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
									var this;
									this = reflaxe.elixir.ast.NameUtils.toSnakeCase("true");
									cast this;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							}, body : buildExpression(current)});
							hasFinalElse = true;
							break;
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond2 = `;
							var if2 = `;
							var else2 = `;
							{
								clauses.push({condition : buildExpression(cond2), body : buildExpression(if2)});
								current = else2;
							};
						};
					};
					default: {
						clauses.push({condition : {
							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
								var this;
								this = reflaxe.elixir.ast.NameUtils.toSnakeCase("true");
								cast this;
							});
							var pos = null;
							{def : def, metadata : {}, pos : pos};
						}, body : buildExpression(current)});
						hasFinalElse = true;
						break;
					}
				};
			};
		};
		if (! hasFinalElse) {
			clauses.push({condition : {
				var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
					var this;
					this = reflaxe.elixir.ast.NameUtils.toSnakeCase("true");
					cast this;
				});
				var pos = null;
				{def : def, metadata : {}, pos : pos};
			}, body : {
				var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
					var this;
					this = reflaxe.elixir.ast.NameUtils.toSnakeCase("nil");
					cast this;
				});
				var pos = null;
				{def : def, metadata : {}, pos : pos};
			}});
		};
		return reflaxe.elixir.ast.ElixirASTDef.ECond(clauses);
	}

	static function isInlineExpression(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_):
		true;	
	case TLocal(_):
		true;	
	case TCall(_, _):
		true;	
	case TField(_, _):
		true;	
	case TBinop(_, _, _):
		true;	
	case TUnop(_, _, _):
		true;	
	case TArrayDecl(_):
		true;	
	case TObjectDecl(_):
		true;	
	case TBlock([single]):
		isInlineExpression(single);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 7: {
					var ` = `[0];
					{
						true;
					};
				};
				case 8: {
					var ` = `[0];
					{
						true;
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 14: {
					var ` = `[0];
					if (`.length == 1) {
						var ` = `[0];
						{
							var single = `;
							{
								reflaxe.elixir.ast.builders.ControlFlowBuilder.isInlineExpression(single);
							};
						};
					} else {
						false;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static inline function makeAST(def:reflaxe.elixir.ast.ElixirASTDef, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : {}, pos : pos};
	}
}