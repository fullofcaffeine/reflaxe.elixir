class reflaxe.elixir.ast.analyzers.BaseLoopAnalyzer {

	public function new(buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST) {
		this.buildExpr = buildExpr;
	}

	var buildExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST;

	public function analyze

	public function calculateConfidence

	function matchesPattern(expr:haxe.macro.TypedExpr, pattern:reflaxe.elixir.ast.analyzers.ExprPattern) {
		return @:ast(switch (expr.expr) {
	case TConst(TInt(n)):
		switch (pattern) {
			case IntLiteral(expected):
				n == expected;			
			case _:
				false;			
		};	
	case TLocal(v):
		switch (pattern) {
			case LocalVar(name):
				v.name == name || name == "*";			
			case _:
				false;			
		};	
	case TBinop(op1, _, _):
		switch (pattern) {
			case BinaryOp(op2):
				op1 == op2;			
			case _:
				false;			
		};	
	case TCall(_, _):
		switch (pattern) {
			case FunctionCall:
				true;			
			case _:
				false;			
		};	
	case TField(_, _):
		switch (pattern) {
			case FieldAccess:
				true;			
			case _:
				false;			
		};	
	case TBlock(_):
		switch (pattern) {
			case BlockExpr:
				true;			
			case _:
				false;			
		};	
	case TIf(_, _, _):
		switch (pattern) {
			case Conditional:
				true;			
			case _:
				false;			
		};	
	case TWhile(_, _, _):
		switch (pattern) {
			case WhileLoop:
				true;			
			case _:
				false;			
		};	
	case TFor(_, _, _):
		switch (pattern) {
			case ForLoop:
				true;			
			case _:
				false;			
		};	
	case _:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var n = `;
							{
								@:ast(switch (pattern) {
	case IntLiteral(expected):
		n == expected;	
	case _:
		false;	
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var expected = `;
										{
											n == expected;
										};
									};
								} else {
									false;
								};
							};
						};
					} else {
						false;
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							@:ast(switch (pattern) {
	case LocalVar(name):
		v.name == name || name == "*";	
	case _:
		false;	
}) if (enumIndex pattern == 1) {
								var ` = pattern[0];
								{
									var name = `;
									{
										v.name == name || name == "*";
									};
								};
							} else {
								false;
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op1 = `;
						{
							@:ast(switch (pattern) {
	case BinaryOp(op2):
		op1 == op2;	
	case _:
		false;	
}) if (enumIndex pattern == 2) {
								var ` = pattern[0];
								{
									var op2 = `;
									{
										op1 == op2;
									};
								};
							} else {
								false;
							};
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						@:ast(switch (pattern) {
	case FieldAccess:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 4) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						@:ast(switch (pattern) {
	case FunctionCall:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 3) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						@:ast(switch (pattern) {
	case BlockExpr:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 5) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						@:ast(switch (pattern) {
	case ForLoop:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 8) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						@:ast(switch (pattern) {
	case Conditional:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 6) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						@:ast(switch (pattern) {
	case WhileLoop:
		true;	
	case _:
		false;	
}) if (enumIndex pattern == 7) {
							{
								true;
							};
						} else {
							false;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	function findAll(expr:haxe.macro.TypedExpr, pattern:reflaxe.elixir.ast.analyzers.ExprPattern) {
		var `this = this;
		var results = [];
		var traverse = [null];
		traverse[0] = function(e:haxe.macro.TypedExpr) {
			if (`this.matchesPattern(e, pattern)) {
				results.push(e);
			};
			@:ast(switch (e.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) traverse(expr);	
	case TBinop(_, e1, e2):
		traverse(e1);
		traverse(e2);	
	case TUnop(_, _, e):
		traverse(e);	
	case TCall(e, args):
		traverse(e);
		for (arg  in  args) traverse(arg);	
	case TField(e, _):
		traverse(e);	
	case TIf(cond, then, els):
		traverse(cond);
		traverse(then);
		if (els != null) traverse(els);	
	case TWhile(cond, body, _):
		traverse(cond);
		traverse(body);	
	case TFor(_, iter, body):
		traverse(iter);
		traverse(body);	
	case TSwitch(e, cases, def):
		traverse(e);
		for (c  in  cases) {
			for (v  in  c.values) traverse(v);
			traverse(c.expr);
		};
		if (def != null) traverse(def);	
	case TReturn(e) if (e != null):
		traverse(e);	
	case TThrow(e):
		traverse(e);	
	case TTry(e, catches):
		traverse(e);
		for (c  in  catches) traverse(c.expr);	
	case TParenthesis(e):
		traverse(e);	
	case TArrayDecl(values):
		for (v  in  values) traverse(v);	
	case _:
}) {
				var ` = e.expr;
				switch (enumIndex `) {
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e1 = `;
							var e2 = `;
							{
								traverse[0](e1);
								traverse[0](e2);
							};
						};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							{
								traverse[0](e);
							};
						};
					};
					case 6: {
						var ` = `[0];
						{
							var e = `;
							{
								traverse[0](e);
							};
						};
					};
					case 8: {
						var ` = `[0];
						{
							var values = `;
							{
								{
									var ` = 0;
									while (` < values.length) {
										var v = values[`];
										++ `;
										traverse[0](v);
									};
								};
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var args = `;
							{
								traverse[0](e);
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										traverse[0](arg);
									};
								};
							};
						};
					};
					case 11: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							{
								traverse[0](e);
							};
						};
					};
					case 14: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var expr = exprs[`];
										++ `;
										traverse[0](expr);
									};
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var iter = `;
							var body = `;
							{
								traverse[0](iter);
								traverse[0](body);
							};
						};
					};
					case 16: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var then = `;
							var els = `;
							{
								traverse[0](cond);
								traverse[0](then);
								if (els != null) {
									traverse[0](els);
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var body = `;
							{
								traverse[0](cond);
								traverse[0](body);
							};
						};
					};
					case 18: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var e = `;
							var cases = `;
							var def = `;
							{
								traverse[0](e);
								{
									var ` = 0;
									while (` < cases.length) {
										var c = cases[`];
										++ `;
										{
											var ` = 0;
											var ` = c.values;
											while (` < `.length) {
												var v = `[`];
												++ `;
												traverse[0](v);
											};
										};
										traverse[0](c.expr);
									};
								};
								if (def != null) {
									traverse[0](def);
								};
							};
						};
					};
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var catches = `;
							{
								traverse[0](e);
								{
									var ` = 0;
									while (` < catches.length) {
										var c = catches[`];
										++ `;
										traverse[0](c.expr);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								traverse[0](e);
							} else {};
						};
					};
					case 23: {
						var ` = `[0];
						{
							var e = `;
							{
								traverse[0](e);
							};
						};
					};
					default: {}
				};
			};
		};
		traverse[0](expr);
		return results;
	}

	function extractVariableNames(expr:haxe.macro.TypedExpr) {
		var names = [];
		@:ast(switch (expr.expr) {
	case TLocal(v):
		names.push(v.name);	
	case TVar(v, _):
		names.push(v.name);	
	case TBlock(exprs):
		for (e  in  exprs) {
			names = names.concat(extractVariableNames(e));
		};	
	case _:
		for (e  in  findAll(expr, LocalVar("*"))) {
			switch (e.expr) {
				case TLocal(v):
					names.push(v.name);				
				case _:
			};
		};	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							names.push(v.name);
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						{
							names.push(v.name);
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									names = names.concat(this.extractVariableNames(e));
								};
							};
						};
					};
				};
				default: {
					{
						var ` = 0;
						var ` = this.findAll(expr, reflaxe.elixir.ast.analyzers.ExprPattern.LocalVar("*"));
						while (` < `.length) {
							var e = `[`];
							++ `;
							@:ast(switch (e.expr) {
	case TLocal(v):
		names.push(v.name);	
	case _:
}) {
								var ` = e.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var v = `;
										{
											names.push(v.name);
										};
									};
								} else {};
							};
						};
					};
				}
			};
		};
		return names;
	}

	function hasSideEffects(expr:haxe.macro.TypedExpr) {
		var hasEffects = false;
		@:ast(switch (expr.expr) {
	case TCall(e, _):
		switch (e.expr) {
			case TField(_, FStatic(_, cf)):
				var name = cf.get().name;
				hasEffects = name == "trace" || name == "print" || name == "println" || name == "push" || name == "add" || name == "remove";			
			case _:
				hasEffects = true;			
		};	
	case TBinop(OpAssign | OpAssignOp(_), _, _):
		hasEffects = true;	
	case TUnop(OpIncrement | OpDecrement, _, _):
		hasEffects = true;	
	case _:
		for (child  in  findAll(expr, FunctionCall)) {
			if (hasSideEffects(child)) {
				hasEffects = true;
				break;
			};
		};	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								hasEffects = true;
							};
						};
						case 20: {
							var ` = `[0];
							{
								hasEffects = true;
							};
						};
						default: {
							{
								var ` = 0;
								var ` = this.findAll(expr, reflaxe.elixir.ast.analyzers.ExprPattern.FunctionCall);
								while (` < `.length) {
									var child = `[`];
									++ `;
									if (this.hasSideEffects(child)) {
										hasEffects = true;
										break;
									};
								};
							};
						}
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							@:ast(switch (e.expr) {
	case TField(_, FStatic(_, cf)):
		var name = cf.get().name;
		hasEffects = name == "trace" || name == "print" || name == "println" || name == "push" || name == "add" || name == "remove";	
	case _:
		hasEffects = true;	
}) {
								var ` = e.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 1) {
										var ` = `[0];
										var ` = `[1];
										{
											var cf = `;
											{
												var name = cf.get().name;
												hasEffects = name == "trace" || name == "print" || name == "println" || name == "push" || name == "add" || name == "remove";
											};
										};
									} else {
										hasEffects = true;
									};
								} else {
									hasEffects = true;
								};
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								hasEffects = true;
							};
						};
						default: {
							{
								var ` = 0;
								var ` = this.findAll(expr, reflaxe.elixir.ast.analyzers.ExprPattern.FunctionCall);
								while (` < `.length) {
									var child = `[`];
									++ `;
									if (this.hasSideEffects(child)) {
										hasEffects = true;
										break;
									};
								};
							};
						}
					};
				};
				default: {
					{
						var ` = 0;
						var ` = this.findAll(expr, reflaxe.elixir.ast.analyzers.ExprPattern.FunctionCall);
						while (` < `.length) {
							var child = `[`];
							++ `;
							if (this.hasSideEffects(child)) {
								hasEffects = true;
								break;
							};
						};
					};
				}
			};
		};
		return hasEffects;
	}

	function trace(message:String) {}
}