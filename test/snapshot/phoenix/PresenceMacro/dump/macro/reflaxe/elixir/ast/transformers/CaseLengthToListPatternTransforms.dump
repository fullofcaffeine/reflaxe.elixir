class reflaxe.elixir.ast.transformers.CaseLengthToListPatternTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var listExpr:Null<ElixirAST> = extractListFromLength(target);
		if (listExpr == null) n else {
			var listVarName = tryExtractVarName(listExpr);
			var newClauses = [];
			for (cl  in  clauses) {
				var newPat = switch (cl.pattern) {
					case PLiteral({ def : EInteger(0) }):
						PList([]);					
					case PLiteral({ def : EInteger(1) }):
						PCons(PVar("head"), PVar("tail"));					
					case PVar(name) if (name == "_" || name == "_any"):
						PVar("_");					
					default:
						cl.pattern;					
				};
				var newGuard = cl.guard;
				if (newGuard != null) newGuard = substituteArrAlias(newGuard, listVarName);
				newClauses.push({ pattern : newPat, guard : newGuard, body : cl.body });
			};
			makeASTWithMeta(ECase(listExpr, newClauses), n.metadata, n.pos);
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var listExpr = reflaxe.elixir.ast.transformers.CaseLengthToListPatternTransforms.extractListFromLength(target);
							if (listExpr == null) {
								n;
							} else {
								var listVarName = reflaxe.elixir.ast.transformers.CaseLengthToListPatternTransforms.tryExtractVarName(listExpr);
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										var newPat = @:ast(switch (cl.pattern) {
	case PLiteral({ def : EInteger(0) }):
		PList([]);	
	case PLiteral({ def : EInteger(1) }):
		PCons(PVar("head"), PVar("tail"));	
	case PVar(name) if (name == "_" || name == "_any"):
		PVar("_");	
	default:
		cl.pattern;	
}) {
											var ` = cl.pattern;
											switch (enumIndex `) {
												case 0: {
													var ` = `[0];
													{
														var name = `;
														if (name == "_" || name == "_any") {
															reflaxe.elixir.ast.EPattern.PVar("_");
														} else {
															cl.pattern;
														};
													};
												};
												case 1: {
													var ` = `[0];
													{
														var ` = `.def;
														var ` = `.metadata;
														var ` = `.pos;
														if (enumIndex ` == 33) {
															var ` = `[0];
															switch (`) {
																case 0: {
																	{
																		reflaxe.elixir.ast.EPattern.PList([]);
																	};
																};
																case 1: {
																	{
																		reflaxe.elixir.ast.EPattern.PCons(reflaxe.elixir.ast.EPattern.PVar("head"), reflaxe.elixir.ast.EPattern.PVar("tail"));
																	};
																};
																default: {
																	cl.pattern;
																}
															};
														} else {
															cl.pattern;
														};
													};
												};
												default: {
													cl.pattern;
												}
											};
										};
										var newGuard = cl.guard;
										if (newGuard != null) {
											newGuard = reflaxe.elixir.ast.transformers.CaseLengthToListPatternTransforms.substituteArrAlias(newGuard, listVarName);
										};
										newClauses.push({pattern : newPat, guard : newGuard, body : cl.body});
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.ECase(listExpr, newClauses), metadata : n.metadata, pos : n.pos};
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function extractListFromLength(e:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (e.def) {
	case ERemoteCall({ def : EVar(mod) }, "length", [list]) if (mod == "Kernel" || mod == "Enum"):
		list;	
	case ECall(null, "length", [list2]):
		list2;	
	default:
		null;	
}) {
			var ` = e.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == null) if (` == "length") {
						if (`.length == 1) {
							var ` = `[0];
							{
								var list2 = `;
								{
									list2;
								};
							};
						} else {
							null;
						};
					} else {
						null;
					} else {
						null;
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							if (` == "length") {
								if (`.length == 1) {
									var ` = `[0];
									{
										var list = `;
										var mod = `;
										if (mod == "Kernel" || mod == "Enum") {
											list;
										} else {
											null;
										};
									};
								} else {
									null;
								};
							} else {
								null;
							};
						} else {
							null;
						};
					};
				};
				default: {
					null;
				}
			};
		};
	}

	static function tryExtractVarName(e:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (e.def) {
	case EVar(v):
		v;	
	default:
		"";	
}) {
			var ` = e.def;
			if (enumIndex ` == 38) {
				var ` = `[0];
				{
					var v = `;
					{
						v;
					};
				};
			} else {
				"";
			};
		};
	}

	static function substituteArrAlias(guard:reflaxe.elixir.ast.ElixirAST, listVar:String) {
		if (listVar == null || listVar == "") {
			return guard;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(guard, function(m:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (m.def) {
	case EVar(v) if (v == "arr"):
		makeAST(EVar(listVar));	
	default:
		m;	
}) {
				var ` = m.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == "arr") {
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(listVar), metadata : {}, pos : pos};
							};
						} else {
							m;
						};
					};
				} else {
					m;
				};
			};
		});
	}
}