class reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms {

	public static function transformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		var renames = computeParamRenames(args);
		var newArgs = renameParams(args, renames);
		var newBody = applyRenamesToBody(body, renames);
		makeASTWithMeta(EDef(name, newArgs, guards, newBody), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		var renames2 = computeParamRenames(args);
		var newArgs2 = renameParams(args, renames2);
		var newBody2 = applyRenamesToBody(body, renames2);
		makeASTWithMeta(EDefp(name, newArgs2, guards, newBody2), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var renames = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.computeParamRenames(args);
								var newArgs = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.renameParams(args, renames);
								var newBody = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.applyRenamesToBody(body, renames);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, newArgs, guards, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var renames2 = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.computeParamRenames(args);
								var newArgs2 = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.renameParams(args, renames2);
								var newBody2 = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.applyRenamesToBody(body, renames2);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, newArgs2, guards, newBody2), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static function computeParamRenames(args:Array<reflaxe.elixir.ast.EPattern>) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		if (args == null) {
			return m;
		};
		{
			var ` = 0;
			while (` < args.length) {
				var a = args[`];
				++ `;
				reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(a, m);
			};
		};
		return m;
	}

	static function collectRenames(p:reflaxe.elixir.ast.EPattern, m:Map<String, String>) {
		@:ast(switch (p) {
	case PVar(n):
		var s = toSnake(n);
		if (s != n) m.set(n, s);	
	case PTuple(es) | PList(es):
		for (e  in  es) collectRenames(e, m);	
	case PCons(h, t):
		collectRenames(h, m);
		collectRenames(t, m);	
	case PMap(kvs):
		for (kv  in  kvs) collectRenames(kv.value, m);	
	case PStruct(_, fs):
		for (f  in  fs) collectRenames(f.value, m);	
	case PPin(inner):
		collectRenames(inner, m);	
	default:
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var n = `;
					{
						var s = reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.toSnake(n);
						if (s != n) {
							{
								m.set(n, s);
							};
						};
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(e, m);
							};
						};
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(e, m);
							};
						};
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(h, m);
						reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(t, m);
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						{
							var ` = 0;
							while (` < kvs.length) {
								var kv = kvs[`];
								++ `;
								reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(kv.value, m);
							};
						};
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var fs = `;
					{
						{
							var ` = 0;
							while (` < fs.length) {
								var f = fs[`];
								++ `;
								reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(f.value, m);
							};
						};
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.transformers.DefParamCamelToSnakeTransforms.collectRenames(inner, m);
					};
				};
			};
			default: {}
		};
	}

	static function renameParams(args:Array<reflaxe.elixir.ast.EPattern>, renames:Map<String, String>) {
		if (args == null || renames == null || renames.keys() == null) {
			return args;
		};
		var rw = [null];
		rw[0] = function(p:reflaxe.elixir.ast.EPattern) {
			return @:ast(switch (p) {
	case PVar(n) if (renames.exists(n)):
		PVar(renames.get(n));	
	case PTuple(es):
		PTuple([for (e  in  es) rw(e)]);	
	case PList(es):
		PList([for (e  in  es) rw(e)]);	
	case PCons(h, t):
		PCons(rw(h), rw(t));	
	case PMap(kvs):
		PMap([for (kv  in  kvs) { key : kv.key, value : rw(kv.value) }]);	
	case PStruct(mod, fs):
		PStruct(mod, [for (f  in  fs) { key : f.key, value : rw(f.value) }]);	
	case PPin(inner):
		PPin(rw(inner));	
	default:
		p;	
}) switch (enumIndex p) {
				case 0: {
					var ` = p[0];
					{
						var n = `;
						if (renames.exists(n)) {
							reflaxe.elixir.ast.EPattern.PVar(cast renames.get(n));
						} else {
							p;
						};
					};
				};
				case 2: {
					var ` = p[0];
					{
						var es = `;
						{
							reflaxe.elixir.ast.EPattern.PTuple({
								var ` = [];
								{
									var ` = 0;
									while (` < es.length) {
										var e = es[`];
										++ `;
										`.push(rw[0](e));
									};
								};
								`;
							});
						};
					};
				};
				case 3: {
					var ` = p[0];
					{
						var es = `;
						{
							reflaxe.elixir.ast.EPattern.PList({
								var ` = [];
								{
									var ` = 0;
									while (` < es.length) {
										var e = es[`];
										++ `;
										`.push(rw[0](e));
									};
								};
								`;
							});
						};
					};
				};
				case 4: {
					var ` = p[0];
					var ` = p[1];
					{
						var h = `;
						var t = `;
						{
							reflaxe.elixir.ast.EPattern.PCons(rw[0](h), rw[0](t));
						};
					};
				};
				case 5: {
					var ` = p[0];
					{
						var kvs = `;
						{
							reflaxe.elixir.ast.EPattern.PMap({
								var ` = [];
								{
									var ` = 0;
									while (` < kvs.length) {
										var kv = kvs[`];
										++ `;
										`.push({key : kv.key, value : rw[0](kv.value)});
									};
								};
								`;
							});
						};
					};
				};
				case 6: {
					var ` = p[0];
					var ` = p[1];
					{
						var mod = `;
						var fs = `;
						{
							reflaxe.elixir.ast.EPattern.PStruct(mod, {
								var ` = [];
								{
									var ` = 0;
									while (` < fs.length) {
										var f = fs[`];
										++ `;
										`.push({key : f.key, value : rw[0](f.value)});
									};
								};
								`;
							});
						};
					};
				};
				case 7: {
					var ` = p[0];
					{
						var inner = `;
						{
							reflaxe.elixir.ast.EPattern.PPin(rw[0](inner));
						};
					};
				};
				default: {
					p;
				}
			};
		};
		return {
			var ` = [];
			{
				var ` = 0;
				while (` < args.length) {
					var a = args[`];
					++ `;
					`.push(rw[0](a));
				};
			};
			`;
		};
	}

	static function applyRenamesToBody(body:reflaxe.elixir.ast.ElixirAST, renames:Map<String, String>) {
		if (renames == null || ! renames.iterator().hasNext()) {
			return body;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EVar(v) if (renames.exists(v)):
		makeASTWithMeta(EVar(renames.get(v)), x.metadata, x.pos);	
	default:
		x;	
}) {
				var ` = x.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (renames.exists(v)) {
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renames.get(v));
								var meta = x.metadata;
								var pos = x.pos;
								{def : def, metadata : meta, pos : pos};
							};
						} else {
							x;
						};
					};
				} else {
					x;
				};
			};
		});
	}

	static function toSnake(s:String) {
		if (s == null || s.length == 0) {
			return s;
		};
		var buf = new StringBuf();
		{
			var ` = 0;
			var ` = s.length;
			while (` < `) {
				var i = ` ++;
				var c = s.substr(i, 1);
				var lower = c.toLowerCase();
				var upper = c.toUpperCase();
				if (c == upper && c != lower) {
					if (i != 0) {
						buf.add("_");
					};
					buf.add(lower);
				} else {
					buf.add(c);
				};
			};
		};
		return buf.toString();
	}
}