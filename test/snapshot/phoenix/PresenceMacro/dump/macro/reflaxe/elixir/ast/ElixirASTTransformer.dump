class reflaxe.elixir.ast.ElixirASTTransformer {

	@:value(abstractMethodThisPass)
	public static var alias_abstractMethodThisPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.abstractMethodThisPass;

	@:value(arrayLengthFieldToFunctionPass)
	public static var alias_arrayLengthFieldToFunctionPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass;

	@:value(bitwiseImportPass)
	public static var alias_bitwiseImportPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.bitwiseImportPass;

	@:value(comprehensionConversionPass)
	public static var alias_comprehensionConversionPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.comprehensionConversionPass;

	@:value(conditionalReassignmentPass)
	public static var alias_conditionalReassignmentPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.conditionalReassignmentPass;

	@:value(constantFoldingPass)
	public static var alias_constantFoldingPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.constantFoldingPass;

	@:value(ectoQueryRequirePass)
	public static var alias_ectoQueryRequirePass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.ectoQueryRequirePass;

	@:value(fixBareConcatenationsPass)
	public static var alias_fixBareConcatenationsPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.fixBareConcatenationsPass;

	@:value(fluentApiOptimizationPass)
	public static var alias_fluentApiOptimizationPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.fluentApiOptimizationPass;

	@:value(functionReferenceTransformPass)
	public static var alias_functionReferenceTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.functionReferenceTransformPass;

	@:value(guardGroupingPass)
	public static var alias_guardGroupingPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass;

	@:value(heexContentInlinePass)
	public static var alias_heexContentInlinePass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.heexContentInlinePass;

	@:value(identityPass)
	public static var alias_identityPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.identityPass;

	@:value(idiomaticEnumPatternMatchingPass)
	public static var alias_idiomaticEnumPatternMatchingPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass;

	@:value(immutabilityTransformPass)
	public static var alias_immutabilityTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.immutabilityTransformPass;

	@:value(instanceMethodTransformPass)
	public static var alias_instanceMethodTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.instanceMethodTransformPass;

	@:value(listEffectLiftingPass)
	public static var alias_listEffectLiftingPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.listEffectLiftingPass;

	@:value(liveViewCoreComponentsImportPass)
	public static var alias_liveViewCoreComponentsImportPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.liveViewCoreComponentsImportPass;

	@:value(loopTransformationPass)
	public static var alias_loopTransformationPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.loopTransformationPass;

	@:value(nullCoalescingInlinePass)
	public static var alias_nullCoalescingInlinePass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.nullCoalescingInlinePass;

	@:value(numericNoOpCleanupPass)
	public static var alias_numericNoOpCleanupPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.numericNoOpCleanupPass;

	@:value(otpChildSpecTransformPass)
	public static var alias_otpChildSpecTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.otpChildSpecTransformPass;

	@:value(phoenixComponentImportPass)
	public static var alias_phoenixComponentImportPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.phoenixComponentImportPass;

	@:value(phoenixFunctionMappingPass)
	public static var alias_phoenixFunctionMappingPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.phoenixFunctionMappingPass;

	@:value(pipelineOptimizationPass)
	public static var alias_pipelineOptimizationPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.pipelineOptimizationPass;

	@:value(prefixUnusedParametersPass)
	public static var alias_prefixUnusedParametersPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.prefixUnusedParametersPass;

	@:value(removeRedundantEnumExtractionPass)
	public static var alias_removeRedundantEnumExtractionPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantEnumExtractionPass;

	@:value(removeRedundantNilInitPass)
	public static var alias_removeRedundantNilInitPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass;

	@:value(selfReferenceTransformPass)
	public static var alias_selfReferenceTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.selfReferenceTransformPass;

	@:value(statementContextTransformPass)
	public static var alias_statementContextTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.statementContextTransformPass;

	@:value(stringInterpolationPass)
	public static var alias_stringInterpolationPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.stringInterpolationPass;

	@:value(stringMethodTransformPass)
	public static var alias_stringMethodTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.stringMethodTransformPass;

	@:value(structFieldAssignmentTransformPass)
	public static var alias_structFieldAssignmentTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.structFieldAssignmentTransformPass;

	@:value(supervisorOptionsTransformPass)
	public static var alias_supervisorOptionsTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.supervisorOptionsTransformPass;

	@:value(throwStatementTransformPass)
	public static var alias_throwStatementTransformPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.throwStatementTransformPass;

	@:value(tupleElemFieldToFunctionPass)
	public static var alias_tupleElemFieldToFunctionPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass;

	@:value(underscoreVariableCleanupPass)
	public static var alias_underscoreVariableCleanupPass:reflaxe.elixir.ast.TransformPass = reflaxe.elixir.ast.ElixirASTTransformer.underscoreVariableCleanupPass;

	public static function transform(ast:reflaxe.elixir.ast.ElixirAST, context:Null<reflaxe.elixir.CompilationContext> = null) {
		var passes = reflaxe.elixir.ast.ElixirASTTransformer.getEnabledPasses();
		var result = ast;
		{
			var ` = 0;
			while (` < passes.length) {
				var passConfig = passes[`];
				++ `;
				if (passConfig.contextualPass != null && context != null) {
					result = passConfig.contextualPass(result, context);
				} else {
					result = passConfig.pass(result);
				};
			};
		};
		return result;
	}

	static function getEnabledPasses() {
		return reflaxe.elixir.ast.transformers.registry.ElixirASTPassRegistry.getEnabledPasses();
	}

	public static function guardGroupingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EParen(inner):
		switch (inner?.def) {
			case ECase(target, clauses):
				var transformedClauses = [];
				for (clause  in  clauses) {
					var transformedClause = transformClauseWithGuards(clause);
					transformedClauses.push(transformedClause);
				};
				makeASTWithMeta(ECase(transformAST(target, guardGroupingPass), transformedClauses), ast.metadata, ast.pos);			
			default:
				makeASTWithMeta(EParen(transformAST(inner, guardGroupingPass)), ast.metadata, ast.pos);			
		};	
	case ECase(target, clauses):
		var transformedClauses = [];
		for (clause  in  clauses) {
			var transformedClause = transformClauseWithGuards(clause);
			transformedClauses.push(transformedClause);
		};
		makeASTWithMeta(ECase(transformAST(target, guardGroupingPass), transformedClauses), ast.metadata, ast.pos);	
	default:
		transformAST(ast, guardGroupingPass);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var transformedClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var transformedClause = reflaxe.elixir.ast.ElixirASTTransformer.transformClauseWithGuards(clause);
									transformedClauses.push(transformedClause);
								};
							};
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass), transformedClauses);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							@:ast(switch (inner?.def) {
	case ECase(target, clauses):
		var transformedClauses = [];
		for (clause  in  clauses) {
			var transformedClause = transformClauseWithGuards(clause);
			transformedClauses.push(transformedClause);
		};
		makeASTWithMeta(ECase(transformAST(target, guardGroupingPass), transformedClauses), ast.metadata, ast.pos);	
	default:
		makeASTWithMeta(EParen(transformAST(inner, guardGroupingPass)), ast.metadata, ast.pos);	
}) {
								var ` = if (inner != null) inner.def else null;
								if (` == null) {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(inner, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass));
										var meta = ast.metadata;
										var pos = ast.pos;
										{def : def, metadata : meta, pos : pos};
									};
								} else if (enumIndex ` == 6) {
									var ` = `[0];
									var ` = `[1];
									{
										var target = `;
										var clauses = `;
										{
											var transformedClauses = [];
											{
												var ` = 0;
												while (` < clauses.length) {
													var clause = clauses[`];
													++ `;
													var transformedClause = reflaxe.elixir.ast.ElixirASTTransformer.transformClauseWithGuards(clause);
													transformedClauses.push(transformedClause);
												};
											};
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass), transformedClauses);
												var meta = ast.metadata;
												var pos = ast.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								} else {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EParen(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(inner, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass));
										var meta = ast.metadata;
										var pos = ast.pos;
										{def : def, metadata : meta, pos : pos};
									};
								};
							};
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass);
				}
			};
		};
	}

	static function transformClauseWithGuards(clause:reflaxe.elixir.ast.ECaseClause) {
		var guardBranches = reflaxe.elixir.ast.transformers.GuardConditionCollector.collectAllGuardConditions(clause.body);
		if (guardBranches.length == 0) {
			return {pattern : clause.pattern, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTTransformer.transformAST(clause.body, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass)};
		};
		var boundVars = reflaxe.elixir.ast.ElixirASTTransformer.extractBoundVariablesFromPattern(clause.pattern);
		var validationResult = reflaxe.elixir.ast.transformers.GuardGroupValidator.validateGuardGroup(guardBranches, boundVars);
		if (! validationResult.canGroup) {
			return {pattern : clause.pattern, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTTransformer.transformAST(clause.body, reflaxe.elixir.ast.ElixirASTTransformer.guardGroupingPass)};
		};
		var flatCond = reflaxe.elixir.ast.transformers.GuardConditionReconstructor.buildFlatCond(guardBranches, boundVars, clause.pattern);
		return {pattern : clause.pattern, guard : null, body : flatCond};
	}

	static function extractBoundVariablesFromPattern(pattern:reflaxe.elixir.ast.EPattern) {
		var vars = [];
		var extract = [null];
		extract[0] = function(p:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (p) {
	case PVar(name):
		vars.push(name);	
	case PTuple(patterns):
		for (subPattern  in  patterns) {
			extract(subPattern);
		};	
	case PList(patterns):
		for (subPattern  in  patterns) {
			extract(subPattern);
		};	
	case PAlias(varName, pattern):
		vars.push(varName);
		extract(pattern);	
	case PCons(head, tail):
		extract(head);
		extract(tail);	
	default:
}) switch (enumIndex p) {
				case 0: {
					var ` = p[0];
					{
						var name = `;
						{
							vars.push(name);
						};
					};
				};
				case 2: {
					var ` = p[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var subPattern = patterns[`];
									++ `;
									extract[0](subPattern);
								};
							};
						};
					};
				};
				case 3: {
					var ` = p[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var subPattern = patterns[`];
									++ `;
									extract[0](subPattern);
								};
							};
						};
					};
				};
				case 4: {
					var ` = p[0];
					var ` = p[1];
					{
						var head = `;
						var tail = `;
						{
							extract[0](head);
							extract[0](tail);
						};
					};
				};
				case 9: {
					var ` = p[0];
					var ` = p[1];
					{
						var varName = `;
						var pattern = `;
						{
							vars.push(varName);
							extract[0](pattern);
						};
					};
				};
				default: {}
			};
		};
		if (pattern != null) {
			extract[0](pattern);
		};
		return vars;
	}

	static function removeNilAssignments(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EBlock(exprs):
		var filtered = [];
		for (expr  in  exprs) {
			var isGeneratedNilAssignment = switch (expr.def) {
				case EMatch(PVar(varName), rhs) if (rhs != null):
					switch (rhs.def) {
						case EAtom(a):
							var atomStr = ((a : String));
							if (atomStr == "nil") {
								var isGenerated = ~/^[a-z]+\d+$/.match(varName);
								isGenerated;
							} else {
								false;
							};						
						default:
							false;						
					};				
				default:
					false;				
			};
			if (!isGeneratedNilAssignment) {
				filtered.push(removeNilAssignments(expr));
			};
		};
		if (filtered.length == 0) {
			null;
		} else if (filtered.length == 1) {
			filtered[0];
		} else {
			makeASTWithMeta(EBlock(filtered), ast.metadata, ast.pos);
		};	
	default:
		transformAST(ast, removeNilAssignments);	
}) {
			var ` = ast.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var filtered = [];
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								var isGeneratedNilAssignment = @:ast(switch (expr.def) {
	case EMatch(PVar(varName), rhs) if (rhs != null):
		switch (rhs.def) {
			case EAtom(a):
				var atomStr = ((a : String));
				if (atomStr == "nil") {
					var isGenerated = ~/^[a-z]+\d+$/.match(varName);
					isGenerated;
				} else {
					false;
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var rhs = `;
												if (rhs != null) {
													@:ast(switch (rhs.def) {
	case EAtom(a):
		var atomStr = ((a : String));
		if (atomStr == "nil") {
			var isGenerated = ~/^[a-z]+\d+$/.match(varName);
			isGenerated;
		} else {
			false;
		};	
	default:
		false;	
}) {
														var ` = rhs.def;
														if (enumIndex ` == 31) {
															var ` = `[0];
															{
																var a = `;
																{
																	var atomStr = (cast a);
																	if (atomStr == "nil") {
																		var isGenerated = new EReg("^[a-z]+\\d+$", "").match(varName);
																		isGenerated;
																	} else {
																		false;
																	};
																};
															};
														} else {
															false;
														};
													};
												} else {
													false;
												};
											};
										} else {
											false;
										};
									} else {
										false;
									};
								};
								if (! isGeneratedNilAssignment) {
									filtered.push(reflaxe.elixir.ast.ElixirASTTransformer.removeNilAssignments(expr));
								};
							};
						};
						if (filtered.length == 0) {
							null;
						} else {
							if (filtered.length == 1) {
								filtered[0];
							} else {
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filtered), metadata : ast.metadata, pos : ast.pos};
							};
						};
					};
				};
			} else {
				reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.removeNilAssignments);
			};
		};
	}

	static function fixUndefinedVariables(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		var fixedName = name;
		if (~/^[a-z]\d+$/.match(name)) {
			fixedName = name.charAt(0);
		} else if (~/^(r|g|b|h|s|l)\d+$/.match(name)) {
			fixedName = ~/^([a-z]+)\d+$/.replace(name, "$1");
		} else if (~/^(\w+?)\d+$/.match(name)) {
			var base = ~/^(\w+?)\d+$/.replace(name, "$1");
			if (base.length <= 2) {
				fixedName = base;
			};
		};
		if (fixedName != name) {
			makeASTWithMeta(EVar(fixedName), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EBinary(op, left, right):
		var fixedLeft = fixUndefinedVariables(left);
		var fixedRight = fixUndefinedVariables(right);
		makeASTWithMeta(EBinary(op, fixedLeft, fixedRight), ast.metadata, ast.pos);	
	case ECall(expr, method, args):
		var fixedExpr = fixUndefinedVariables(expr);
		var fixedArgs = args.map(fixUndefinedVariables);
		makeASTWithMeta(ECall(fixedExpr, method, fixedArgs), ast.metadata, ast.pos);	
	case EIf(cond, thenBranch, elseBranch):
		var fixedCond = fixUndefinedVariables(cond);
		var fixedThen = fixUndefinedVariables(thenBranch);
		var fixedElse = elseBranch != null ? fixUndefinedVariables(elseBranch) : null;
		makeASTWithMeta(EIf(fixedCond, fixedThen, fixedElse), ast.metadata, ast.pos);	
	case EParen(inner):
		var fixedInner = fixUndefinedVariables(inner);
		makeASTWithMeta(EParen(fixedInner), ast.metadata, ast.pos);	
	default:
		transformAST(ast, fixUndefinedVariables);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var fixedCond = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(cond);
							var fixedThen = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(thenBranch);
							var fixedElse = if (elseBranch != null) {
								reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(elseBranch);
							} else {
								null;
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EIf(fixedCond, fixedThen, fixedElse), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var expr = `;
						var method = `;
						var args = `;
						{
							var fixedExpr = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(expr);
							var fixedArgs = {
								var f = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables;
								{
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECall(fixedExpr, method, fixedArgs), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							var fixedLeft = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(left);
							var fixedRight = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(right);
							{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, fixedLeft, fixedRight), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							var fixedName = name;
							if (new EReg("^[a-z]\\d+$", "").match(name)) {
								fixedName = name.charAt(0);
							} else {
								if (new EReg("^(r|g|b|h|s|l)\\d+$", "").match(name)) {
									fixedName = new EReg("^([a-z]+)\\d+$", "").replace(name, "$1");
								} else {
									if (new EReg("^(\\w+?)\\d+$", "").match(name)) {
										var base = new EReg("^(\\w+?)\\d+$", "").replace(name, "$1");
										if (base.length <= 2) {
											fixedName = base;
										};
									};
								};
							};
							if (fixedName != name) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fixedName), metadata : ast.metadata, pos : ast.pos};
							} else {
								ast;
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							var fixedInner = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(inner);
							{def : reflaxe.elixir.ast.ElixirASTDef.EParen(fixedInner), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables);
				}
			};
		};
	}

	static function extractCondBranches(ast:reflaxe.elixir.ast.ElixirAST) {
		var branches = [];
		var extract = [null];
		extract[0] = function(node:reflaxe.elixir.ast.ElixirAST, depth:Int = 0) {
			if (node == null) {
				return;
			};
			var cleanedNode = reflaxe.elixir.ast.ElixirASTTransformer.removeNilAssignments(node);
			if (cleanedNode == null) {
				return;
			};
			var nodeToProcess = cleanedNode;
			var unwrapping = true;
			while (unwrapping && nodeToProcess != null) {
				@:ast(switch (nodeToProcess.def) {
	case EBlock(exprs) if (exprs.length == 1):
		nodeToProcess = exprs[0];	
	case EParen(inner):
		nodeToProcess = inner;	
	default:
		unwrapping = false;	
}) {
					var ` = nodeToProcess.def;
					switch (enumIndex `) {
						case 53: {
							var ` = `[0];
							{
								var exprs = `;
								if (exprs.length == 1) {
									nodeToProcess = exprs[0];
								} else {
									unwrapping = false;
								};
							};
						};
						case 54: {
							var ` = `[0];
							{
								var inner = `;
								{
									nodeToProcess = inner;
								};
							};
						};
						default: {
							unwrapping = false;
						}
					};
				};
			};
			@:ast(switch (nodeToProcess.def) {
	case EIf(cond, thenBranch, elseBranch):
		var fixedCond = fixUndefinedVariables(cond);
		var fixedBody = fixUndefinedVariables(thenBranch);
		branches.push({ condition : fixedCond, body : fixedBody });
		if (elseBranch != null) {
			extract(elseBranch, depth + 1);
		};	
	case _:
		var fixedNode = fixUndefinedVariables(nodeToProcess);
		branches.push({ condition : makeAST(EBoolean(true)), body : fixedNode });	
}) {
				var ` = nodeToProcess.def;
				if (enumIndex ` == 10) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var fixedCond = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(cond);
							var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(thenBranch);
							branches.push({condition : fixedCond, body : fixedBody});
							if (elseBranch != null) {
								extract[0](elseBranch, depth + 1);
							};
						};
					};
				} else {
					var fixedNode = reflaxe.elixir.ast.ElixirASTTransformer.fixUndefinedVariables(nodeToProcess);
					branches.push({condition : {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), metadata : {}, pos : pos};
					}, body : fixedNode});
				};
			};
		};
		extract[0](ast, null);
		return branches;
	}

	static function throwStatementTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null || ast.def == null) {
			return ast;
		};
		return @:ast(switch (ast.def) {
	case EThrow(value):
		var transformedValue = transformThrowValue(value);
		{ def : EThrow(transformedValue), metadata : ast.metadata, pos : ast.pos };	
	default:
		transformAST(ast, throwStatementTransformPass);	
}) {
			var ` = ast.def;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var value = `;
					{
						var transformedValue = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(value);
						{def : reflaxe.elixir.ast.ElixirASTDef.EThrow(transformedValue), metadata : ast.metadata, pos : ast.pos};
					};
				};
			} else {
				reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.throwStatementTransformPass);
			};
		};
	}

	static function transformThrowValue(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EBinary(StringConcat, left, right):
		var leftTransformed = transformThrowValue(left);
		var rightTransformed = transformThrowValue(right);
		var rightWrapped = switch (rightTransformed.def) {
			case EIf(_, _, _):
				{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };			
			case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
				{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };			
			default:
				rightTransformed;			
		};
		{ def : EBinary(StringConcat, leftTransformed, rightWrapped), metadata : expr.metadata, pos : expr.pos };	
	case EIf(cond, then, els):
		{ def : EParen(expr), metadata : expr.metadata, pos : expr.pos };	
	default:
		expr;	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var then = `;
						var els = `;
						{
							{def : reflaxe.elixir.ast.ElixirASTDef.EParen(expr), metadata : expr.metadata, pos : expr.pos};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								var leftTransformed = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(left);
								var rightTransformed = reflaxe.elixir.ast.ElixirASTTransformer.transformThrowValue(right);
								var rightWrapped = @:ast(switch (rightTransformed.def) {
	case EIf(_, _, _):
		{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };	
	case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
		{ def : EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos };	
	default:
		rightTransformed;	
}) {
									var ` = rightTransformed.def;
									switch (enumIndex `) {
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												{def : reflaxe.elixir.ast.ElixirASTDef.EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos};
											};
										};
										case 22: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (reflaxe.elixir.ast.ElixirASTTransformer.hasConditionalInCall(rightTransformed)) {
												{def : reflaxe.elixir.ast.ElixirASTDef.EParen(rightTransformed), metadata : rightTransformed.metadata, pos : rightTransformed.pos};
											} else {
												rightTransformed;
											};
										};
										default: {
											rightTransformed;
										}
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.StringConcat, leftTransformed, rightWrapped), metadata : expr.metadata, pos : expr.pos};
							};
						};
					} else {
						expr;
					};
				};
				default: {
					expr;
				}
			};
		};
	}

	static function hasConditionalInCall(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case ECall(_, _, args):
		Lambda.exists(args, function(arg) {
			return switch (arg.def) {
				case EIf(_, _, _):
					true;				
				default:
					false;				
			};
		});	
	default:
		false;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 22) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var args = `;
					{
						Lambda.exists(args, function(arg:reflaxe.elixir.ast.ElixirAST) {
							return @:ast(switch (arg.def) {
	case EIf(_, _, _):
		true;	
	default:
		false;	
}) {
								var ` = arg.def;
								if (enumIndex ` == 10) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										true;
									};
								} else {
									false;
								};
							};
						});
					};
				};
			} else {
				false;
			};
		};
	}

	static function identityPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return ast;
	}

	static function removeRedundantEnumExtractionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var caseTargetVar = [null];
		var currentCaseHasBindingPlan = [false];
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ECase(target, clauses):
		var targetDebug = switch (target.def) {
			case EVar(v):
				"variable: $v";			
			case EParen(inner):
				switch (inner.def) {
					case EVar(v):
						"variable in parens: $v";					
					default:
						"complex expression";					
				};			
			default:
				"complex expression";			
		};
		currentCaseHasBindingPlan = node.metadata != null && node.metadata.hasEnumBindingPlan == true;
		switch (target.def) {
			case EVar(v):
				caseTargetVar = v;			
			case EParen(inner):
				switch (inner.def) {
					case EVar(v):
						caseTargetVar = v;					
					default:
				};			
			default:
		};
		var newClauses = [];
		for (i  in  0 ... clauses.length) {
			var clause = clauses[i];
			var pattern = clause.pattern;
			var guard = clause.guard;
			var body = clause.body;
			var patternDebug = switch (pattern) {
				case PTuple(elements):
					var elemStrs = [for (e  in  elements) switch (e) {
						case PLiteral(ast):
							switch (ast.def) {
								case EAtom(a):
									":$a";								
								default:
									"?";								
							};						
						case PVar(v):
							v;						
						default:
							"?";						
					}];
					"{${elemStrs.join(\", \")}}";				
				default:
					"other pattern";				
			};
			trace("[RemoveRedundantEnumExtraction] Clause $i pattern: $patternDebug");
			if (currentCaseHasBindingPlan && body != null) {
				if (body.metadata == null) body.metadata = { };
				body.metadata.parentHasBindingPlan = true;
			};
			var newBody = switch (body.def) {
				case EBlock(exprs):
					var varRenames:Map<String,String> = new Map();
					var filtered = [];
					for (i  in  0 ... exprs.length) {
						var expr = exprs[i];
						if (expr == null) {
							continue;
						};
						var isRedundant = false;
						if (expr.metadata != null && expr.metadata.redundantEnumExtraction == true) {
							isRedundant = true;
						};
						switch (expr.def) {
							case EMatch(PVar(varName), rhs):
								if (rhs != null) {
									var rhsDebug = switch (rhs.def) {
										case EVar(v):
											"EVar($v)";										
										case ECall(_, fn, _):
											"ECall($fn)";										
										default:
											Type.enumConstructor(rhs.def);										
									};
								} else {
									isRedundant = true;
								};
								if (varName == switch (rhs.def) {
									case EVar(v):
										v;									
									default:
										null;									
								}) {
									isRedundant = true;
								} else if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
									isRedundant = true;
								} else switch (rhs.def) {
									case EVar(v):
										if (v == "g" || v == "_g") {
											isRedundant = true;
										} else if (v.length > 1 && v.charAt(0) == "g" && v.length == 2 && v.charAt(1) >= "0" && v.charAt(1) <= "9") {
											isRedundant = true;
										} else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" && v.charAt(2) >= "0" && v.charAt(2) <= "9") {
											isRedundant = true;
										} else if (v == caseTargetVar) {
											if (varName == "g" || varName == "_g" || (varName.length == 2 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9") || (varName.length == 3 && varName.charAt(0) == "_" && varName.charAt(1) == "g" && varName.charAt(2) >= "0" && varName.charAt(2) <= "9")) {
												isRedundant = true;
											};
										};									
									case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
										var isTargetMatch = switch (targetExpr.def) {
											case EVar(v):
												v == caseTargetVar;											
											default:
												false;											
										};
										if (isTargetMatch) {
											if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
												isRedundant = true;
											} else { };
										} else { };									
									default:
								};							
							default:
						};
						if (!isRedundant) {
							filtered.push(expr);
						};
					};
					if (filtered.length == 0) {
						makeAST(ENil);
					} else if (filtered.length == 1) {
						transformNode(filtered[0], function(n) {
							return n;
						});
					} else {
						var transformedFiltered = filtered.map(function(expr) {
							return transformNode(expr, function(n) {
								return n;
							});
						});
						makeASTWithMeta(EBlock(transformedFiltered), body.metadata, body.pos);
					};				
				default:
					body;				
			};
			var fullyTransformedBody = transformNode(newBody, function(n) {
				return n;
			});
			newClauses.push({ pattern : pattern, guard : guard, body : fullyTransformedBody });
		};
		return makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var targetDebug = @:ast(switch (target.def) {
	case EVar(v):
		"variable: $v";	
	case EParen(inner):
		switch (inner.def) {
			case EVar(v):
				"variable in parens: $v";			
			default:
				"complex expression";			
		};	
	default:
		"complex expression";	
}) {
								var ` = target.def;
								switch (enumIndex `) {
									case 38: {
										var ` = `[0];
										{
											var v = `;
											{
												"variable: " + v;
											};
										};
									};
									case 54: {
										var ` = `[0];
										{
											var inner = `;
											{
												@:ast(switch (inner.def) {
	case EVar(v):
		"variable in parens: $v";	
	default:
		"complex expression";	
}) {
													var ` = inner.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v = `;
															{
																"variable in parens: " + v;
															};
														};
													} else {
														"complex expression";
													};
												};
											};
										};
									};
									default: {
										"complex expression";
									}
								};
							};
							currentCaseHasBindingPlan[0] = node.metadata != null && node.metadata.hasEnumBindingPlan == true;
							@:ast(switch (target.def) {
	case EVar(v):
		caseTargetVar = v;	
	case EParen(inner):
		switch (inner.def) {
			case EVar(v):
				caseTargetVar = v;			
			default:
		};	
	default:
}) {
								var ` = target.def;
								switch (enumIndex `) {
									case 38: {
										var ` = `[0];
										{
											var v = `;
											{
												caseTargetVar[0] = v;
											};
										};
									};
									case 54: {
										var ` = `[0];
										{
											var inner = `;
											{
												@:ast(switch (inner.def) {
	case EVar(v):
		caseTargetVar = v;	
	default:
}) {
													var ` = inner.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v = `;
															{
																caseTargetVar[0] = v;
															};
														};
													} else {};
												};
											};
										};
									};
									default: {}
								};
							};
							var newClauses = [];
							{
								var ` = 0;
								var ` = clauses.length;
								while (` < `) {
									var i = ` ++;
									var clause = clauses[i];
									var pattern = clause.pattern;
									var guard = clause.guard;
									var body = clause.body;
									var patternDebug = @:ast(switch (pattern) {
	case PTuple(elements):
		var elemStrs = [for (e  in  elements) switch (e) {
			case PLiteral(ast):
				switch (ast.def) {
					case EAtom(a):
						":$a";					
					default:
						"?";					
				};			
			case PVar(v):
				v;			
			default:
				"?";			
		}];
		"{${elemStrs.join(\", \")}}";	
	default:
		"other pattern";	
}) if (enumIndex pattern == 2) {
										var ` = pattern[0];
										{
											var elements = `;
											{
												var elemStrs = {
													var ` = [];
													{
														var ` = 0;
														while (` < elements.length) {
															var e = elements[`];
															++ `;
															`.push(@:ast(switch (e) {
	case PLiteral(ast):
		switch (ast.def) {
			case EAtom(a):
				":$a";			
			default:
				"?";			
		};	
	case PVar(v):
		v;	
	default:
		"?";	
}) switch (enumIndex e) {
																case 0: {
																	var ` = e[0];
																	{
																		var v = `;
																		{
																			v;
																		};
																	};
																};
																case 1: {
																	var ` = e[0];
																	{
																		var ast = `;
																		{
																			@:ast(switch (ast.def) {
	case EAtom(a):
		":$a";	
	default:
		"?";	
}) {
																				var ` = ast.def;
																				if (enumIndex ` == 31) {
																					var ` = `[0];
																					{
																						var a = `;
																						{
																							":" + a;
																						};
																					};
																				} else {
																					"?";
																				};
																			};
																		};
																	};
																};
																default: {
																	"?";
																}
															});
														};
													};
													`;
												};
												"{" + elemStrs.join(", ") + "}";
											};
										};
									} else {
										"other pattern";
									};
									haxe.Log.trace("[RemoveRedundantEnumExtraction] Clause " + i + " pattern: " + patternDebug, {fileName : "../../../../src/reflaxe/elixir/ast/ElixirASTTransformer.hx", lineNumber : 1015, className : "reflaxe.elixir.ast.ElixirASTTransformer", methodName : "removeRedundantEnumExtractionPass"});
									if (currentCaseHasBindingPlan[0] && body != null) {
										if (body.metadata == null) {
											body.metadata = {};
										};
										body.metadata.parentHasBindingPlan = true;
									};
									var newBody = @:ast(switch (body.def) {
	case EBlock(exprs):
		var varRenames:Map<String,String> = new Map();
		var filtered = [];
		for (i  in  0 ... exprs.length) {
			var expr = exprs[i];
			if (expr == null) {
				continue;
			};
			var isRedundant = false;
			if (expr.metadata != null && expr.metadata.redundantEnumExtraction == true) {
				isRedundant = true;
			};
			switch (expr.def) {
				case EMatch(PVar(varName), rhs):
					if (rhs != null) {
						var rhsDebug = switch (rhs.def) {
							case EVar(v):
								"EVar($v)";							
							case ECall(_, fn, _):
								"ECall($fn)";							
							default:
								Type.enumConstructor(rhs.def);							
						};
					} else {
						isRedundant = true;
					};
					if (varName == switch (rhs.def) {
						case EVar(v):
							v;						
						default:
							null;						
					}) {
						isRedundant = true;
					} else if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
						isRedundant = true;
					} else switch (rhs.def) {
						case EVar(v):
							if (v == "g" || v == "_g") {
								isRedundant = true;
							} else if (v.length > 1 && v.charAt(0) == "g" && v.length == 2 && v.charAt(1) >= "0" && v.charAt(1) <= "9") {
								isRedundant = true;
							} else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" && v.charAt(2) >= "0" && v.charAt(2) <= "9") {
								isRedundant = true;
							} else if (v == caseTargetVar) {
								if (varName == "g" || varName == "_g" || (varName.length == 2 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9") || (varName.length == 3 && varName.charAt(0) == "_" && varName.charAt(1) == "g" && varName.charAt(2) >= "0" && varName.charAt(2) <= "9")) {
									isRedundant = true;
								};
							};						
						case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
							var isTargetMatch = switch (targetExpr.def) {
								case EVar(v):
									v == caseTargetVar;								
								default:
									false;								
							};
							if (isTargetMatch) {
								if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
									isRedundant = true;
								} else { };
							} else { };						
						default:
					};				
				default:
			};
			if (!isRedundant) {
				filtered.push(expr);
			};
		};
		if (filtered.length == 0) {
			makeAST(ENil);
		} else if (filtered.length == 1) {
			transformNode(filtered[0], function(n) {
				return n;
			});
		} else {
			var transformedFiltered = filtered.map(function(expr) {
				return transformNode(expr, function(n) {
					return n;
				});
			});
			makeASTWithMeta(EBlock(transformedFiltered), body.metadata, body.pos);
		};	
	default:
		body;	
}) {
										var ` = body.def;
										if (enumIndex ` == 53) {
											var ` = `[0];
											{
												var exprs = `;
												{
													var varRenames = {
														{};
														new haxe.ds.StringMap();
													};
													var filtered = [];
													{
														var ` = 0;
														var ` = exprs.length;
														while (` < `) {
															var i = ` ++;
															var expr = exprs[i];
															if (expr == null) {
																continue;
															};
															var isRedundant = false;
															if (expr.metadata != null && expr.metadata.redundantEnumExtraction == true) {
																isRedundant = true;
															};
															@:ast(switch (expr.def) {
	case EMatch(PVar(varName), rhs):
		if (rhs != null) {
			var rhsDebug = switch (rhs.def) {
				case EVar(v):
					"EVar($v)";				
				case ECall(_, fn, _):
					"ECall($fn)";				
				default:
					Type.enumConstructor(rhs.def);				
			};
		} else {
			isRedundant = true;
		};
		if (varName == switch (rhs.def) {
			case EVar(v):
				v;			
			default:
				null;			
		}) {
			isRedundant = true;
		} else if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
			isRedundant = true;
		} else switch (rhs.def) {
			case EVar(v):
				if (v == "g" || v == "_g") {
					isRedundant = true;
				} else if (v.length > 1 && v.charAt(0) == "g" && v.length == 2 && v.charAt(1) >= "0" && v.charAt(1) <= "9") {
					isRedundant = true;
				} else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" && v.charAt(2) >= "0" && v.charAt(2) <= "9") {
					isRedundant = true;
				} else if (v == caseTargetVar) {
					if (varName == "g" || varName == "_g" || (varName.length == 2 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9") || (varName.length == 3 && varName.charAt(0) == "_" && varName.charAt(1) == "g" && varName.charAt(2) >= "0" && varName.charAt(2) <= "9")) {
						isRedundant = true;
					};
				};			
			case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
				var isTargetMatch = switch (targetExpr.def) {
					case EVar(v):
						v == caseTargetVar;					
					default:
						false;					
				};
				if (isTargetMatch) {
					if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
						isRedundant = true;
					} else { };
				} else { };			
			default:
		};	
	default:
}) {
																var ` = expr.def;
																if (enumIndex ` == 8) {
																	var ` = `[0];
																	var ` = `[1];
																	if (enumIndex ` == 0) {
																		var ` = `[0];
																		{
																			var varName = `;
																			var rhs = `;
																			{
																				if (rhs != null) {
																					var rhsDebug = @:ast(switch (rhs.def) {
	case EVar(v):
		"EVar($v)";	
	case ECall(_, fn, _):
		"ECall($fn)";	
	default:
		Type.enumConstructor(rhs.def);	
}) {
																						var ` = rhs.def;
																						switch (enumIndex `) {
																							case 22: {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								{
																									var fn = `;
																									{
																										"ECall(" + fn + ")";
																									};
																								};
																							};
																							case 38: {
																								var ` = `[0];
																								{
																									var v = `;
																									{
																										"EVar(" + v + ")";
																									};
																								};
																							};
																							default: {
																								Type.enumConstructor(rhs.def);
																							}
																						};
																					};
																				} else {
																					isRedundant = true;
																				};
																				if (varName == @:ast(switch (rhs.def) {
	case EVar(v):
		v;	
	default:
		null;	
}) {
																					var ` = rhs.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v = `;
																							{
																								v;
																							};
																						};
																					} else {
																						null;
																					};
																				}) {
																					isRedundant = true;
																				} else {
																					if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
																						isRedundant = true;
																					} else {
																						@:ast(switch (rhs.def) {
	case EVar(v):
		if (v == "g" || v == "_g") {
			isRedundant = true;
		} else if (v.length > 1 && v.charAt(0) == "g" && v.length == 2 && v.charAt(1) >= "0" && v.charAt(1) <= "9") {
			isRedundant = true;
		} else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" && v.charAt(2) >= "0" && v.charAt(2) <= "9") {
			isRedundant = true;
		} else if (v == caseTargetVar) {
			if (varName == "g" || varName == "_g" || (varName.length == 2 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9") || (varName.length == 3 && varName.charAt(0) == "_" && varName.charAt(1) == "g" && varName.charAt(2) >= "0" && varName.charAt(2) <= "9")) {
				isRedundant = true;
			};
		};	
	case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
		var isTargetMatch = switch (targetExpr.def) {
			case EVar(v):
				v == caseTargetVar;			
			default:
				false;			
		};
		if (isTargetMatch) {
			if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
				isRedundant = true;
			} else { };
		} else { };	
	default:
}) {
																							var ` = rhs.def;
																							switch (enumIndex `) {
																								case 22: {
																									var ` = `[0];
																									var ` = `[1];
																									var ` = `[2];
																									{
																										var targetExpr = `;
																										var funcName = `;
																										var args = `;
																										if (funcName == "elem" && args.length == 1) {
																											var isTargetMatch = @:ast(switch (targetExpr.def) {
	case EVar(v):
		v == caseTargetVar;	
	default:
		false;	
}) {
																												var ` = targetExpr.def;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var v = `;
																														{
																															v == caseTargetVar[0];
																														};
																													};
																												} else {
																													false;
																												};
																											};
																											if (isTargetMatch) {
																												if (varName == "g" || (varName.length > 1 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
																													isRedundant = true;
																												} else {};
																											} else {};
																										} else {};
																									};
																								};
																								case 38: {
																									var ` = `[0];
																									{
																										var v = `;
																										{
																											if (v == "g" || v == "_g") {
																												isRedundant = true;
																											} else {
																												if (v.length > 1 && v.charAt(0) == "g" && v.length == 2 && v.charAt(1) >= "0" && v.charAt(1) <= "9") {
																													isRedundant = true;
																												} else {
																													if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" && v.charAt(2) >= "0" && v.charAt(2) <= "9") {
																														isRedundant = true;
																													} else {
																														if (v == caseTargetVar[0]) {
																															if (varName == "g" || varName == "_g" || (varName.length == 2 && varName.charAt(0) == "g" && varName.charAt(1) >= "0" && varName.charAt(1) <= "9") || (varName.length == 3 && varName.charAt(0) == "_" && varName.charAt(1) == "g" && varName.charAt(2) >= "0" && varName.charAt(2) <= "9")) {
																																isRedundant = true;
																															};
																														};
																													};
																												};
																											};
																										};
																									};
																								};
																								default: {}
																							};
																						};
																					};
																				};
																			};
																		};
																	} else {};
																} else {};
															};
															if (! isRedundant) {
																filtered.push(expr);
															};
														};
													};
													if (filtered.length == 0) {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
														};
													} else {
														if (filtered.length == 1) {
															reflaxe.elixir.ast.ElixirASTTransformer.transformNode(filtered[0], function(n:reflaxe.elixir.ast.ElixirAST) {
																return n;
															});
														} else {
															var transformedFiltered = {
																var ` = [];
																{
																	var ` = 0;
																	var ` = filtered;
																	while (` < `.length) {
																		var v = `[`];
																		++ `;
																		`.push(function(expr:reflaxe.elixir.ast.ElixirAST) {
																			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, function(n:reflaxe.elixir.ast.ElixirAST) {
																				return n;
																			});
																		}(v));
																	};
																};
																`;
															};
															{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedFiltered), metadata : body.metadata, pos : body.pos};
														};
													};
												};
											};
										} else {
											body;
										};
									};
									var fullyTransformedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(newBody, function(n:reflaxe.elixir.ast.ElixirAST) {
										return n;
									});
									newClauses.push({pattern : pattern, guard : guard, body : fullyTransformedBody});
								};
							};
							return {def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function functionReferenceTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EField(target, field):
		if (field.indexOf("__FUNC_REF__") != -1) {
			var parts = field.split("__FUNC_REF__");
			var actualField = parts[0];
			var arity = parts.length > 1 ? Std.parseInt(parts[1]) : 0;
			if (arity == null) arity = 0;
			var cleanField = makeAST(EField(target, actualField));
			return makeAST(ECapture(cleanField, arity));
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 28) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var field = `;
						{
							if (field.indexOf("__FUNC_REF__", null) != -1) {
								var parts = field.split("__FUNC_REF__");
								var actualField = parts[0];
								var arity = if (parts.length > 1) {
									Std.parseInt(parts[1]);
								} else {
									0;
								};
								if (arity == null) {
									arity = 0;
								};
								var cleanField = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EField(target, actualField), metadata : {}, pos : pos};
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ECapture(cleanField, arity), metadata : {}, pos : pos};
								};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function nullCoalescingInlinePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EMatch(PVar(name), value) if (value != null):
		switch (value.def) {
			case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
				switch (assign.def) {
					case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
						switch (ifExpr.def) {
							case EIf(condition, thenBranch, elseBranch):
								switch (condition.def) {
									case EBinary(NotEqual, tmpVar, nilExpr):
										switch (tmpVar.def) {
											case EVar(checkName) if (checkName == tmpName):
												var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
												var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
												makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));											
											default:
												node;											
										};									
									default:
										node;									
								};							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 8) {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var name = `;
							var value = `;
							if (value != null) {
								@:ast(switch (value.def) {
	case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
		switch (assign.def) {
			case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
				switch (ifExpr.def) {
					case EIf(condition, thenBranch, elseBranch):
						switch (condition.def) {
							case EBinary(NotEqual, tmpVar, nilExpr):
								switch (tmpVar.def) {
									case EVar(checkName) if (checkName == tmpName):
										var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
										var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
										makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));									
									default:
										node;									
								};							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
									var ` = value.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var assign = `;
												var ifExpr = `;
												if (assign != null && ifExpr != null) {
													@:ast(switch (assign.def) {
	case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
		switch (ifExpr.def) {
			case EIf(condition, thenBranch, elseBranch):
				switch (condition.def) {
					case EBinary(NotEqual, tmpVar, nilExpr):
						switch (tmpVar.def) {
							case EVar(checkName) if (checkName == tmpName):
								var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
								var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
								makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));							
							default:
								node;							
						};					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
														var ` = assign.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var tmpName = `;
																	var expr = `;
																	if (tmpName != null && tmpName.indexOf("tmp", null) >= 0) {
																		@:ast(switch (ifExpr.def) {
	case EIf(condition, thenBranch, elseBranch):
		switch (condition.def) {
			case EBinary(NotEqual, tmpVar, nilExpr):
				switch (tmpVar.def) {
					case EVar(checkName) if (checkName == tmpName):
						var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
						var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
						makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));					
					default:
						node;					
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
																			var ` = ifExpr.def;
																			if (enumIndex ` == 10) {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var condition = `;
																					var thenBranch = `;
																					var elseBranch = `;
																					{
																						@:ast(switch (condition.def) {
	case EBinary(NotEqual, tmpVar, nilExpr):
		switch (tmpVar.def) {
			case EVar(checkName) if (checkName == tmpName):
				var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
				var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
				makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));			
			default:
				node;			
		};	
	default:
		node;	
}) {
																							var ` = condition.def;
																							if (enumIndex ` == 26) {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 7) {
																									{
																										var tmpVar = `;
																										var nilExpr = `;
																										{
																											@:ast(switch (tmpVar.def) {
	case EVar(checkName) if (checkName == tmpName):
		var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
		var inlineCondition = makeAST(EBinary(NotEqual, makeAST(EParen(assignExpr)), makeAST(ENil)));
		makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));	
	default:
		node;	
}) {
																												var ` = tmpVar.def;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var checkName = `;
																														if (checkName == tmpName) {
																															var assignExpr = {
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpName), expr), metadata : {}, pos : pos};
																															};
																															var inlineCondition = {
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.EParen(assignExpr), metadata : {}, pos : pos};
																																}, {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																																}), metadata : {}, pos : pos};
																															};
																															{
																																var pos = null;
																																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																																	var pos = null;
																																	{def : reflaxe.elixir.ast.ElixirASTDef.EIf(inlineCondition, thenBranch, elseBranch), metadata : {}, pos : pos};
																																}), metadata : {}, pos : pos};
																															};
																														} else {
																															node;
																														};
																													};
																												} else {
																													node;
																												};
																											};
																										};
																									};
																								} else {
																									node;
																								};
																							} else {
																								node;
																							};
																						};
																					};
																				};
																			} else {
																				node;
																			};
																		};
																	} else {
																		node;
																	};
																};
															} else {
																node;
															};
														} else {
															node;
														};
													};
												} else {
													node;
												};
											};
										} else {
											node;
										};
									} else {
										node;
									};
								};
							} else {
								node;
							};
						};
					} else {
						node;
					};
				} else {
					node;
				};
			};
		});
	}

	static function selfReferenceTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var moduleMetadata = [null];
		var collectModuleMetadata = [null];
		collectModuleMetadata[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EModule(_, _, _):
		if (node.metadata != null) {
			moduleMetadata = node.metadata;
		};	
	default:
		iterateAST(node, collectModuleMetadata);	
}) {
				var ` = node.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						if (node.metadata != null) {
							moduleMetadata[0] = node.metadata;
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, collectModuleMetadata[0]);
				};
			};
		};
		collectModuleMetadata[0](ast);
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall(target, methodName, args):
		if (methodName == "__super__") {
			return makeAST(ENil);
		};
		if (methodName == "call" && args.length > 0) {
			switch (args[0].def) {
				case EField(superVar, fieldName):
					if (superVar.def.match(EVar("super"))) {
						if (fieldName == "to_string" || fieldName == "toString") {
							return makeAST(EString(""));
						};
					};				
				default:
			};
		};
		if (target != null) {
			switch (target.def) {
				case EVar("super"):
					var parentModule = if (node.metadata != null && node.metadata.parentModule != null) {
						node.metadata.parentModule;
					} else if (moduleMetadata != null && moduleMetadata.parentModule != null) {
						moduleMetadata.parentModule;
					} else {
						null;
					};
					if (parentModule != null) {
						if (parentModule == "Exception" && (methodName == "toString" || methodName == "to_string")) {
							return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
						};
						var elixirMethodName = if (methodName == "toString") {
							"to_string";
						} else {
							NameUtils.toSnakeCase(methodName);
						};
						var delegationArgs = [makeAST(EVar("struct"))].concat(args);
						return makeAST(ERemoteCall(makeAST(EVar(parentModule)), elixirMethodName, delegationArgs));
					} else if (methodName == "to_string" || methodName == "toString") {
						var isException = (moduleMetadata != null && moduleMetadata.isException == true);
						if (isException) {
							return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
						} else {
							return makeAST(EField(makeAST(EVar("struct")), "message"));
						};
					} else {
						node;
					};				
				case EField(superVar, fieldName):
					if (superVar.def.match(EVar("super"))) {
						if (fieldName == "to_string" || fieldName == "toString") {
							var isException = (moduleMetadata != null && moduleMetadata.isException == true);
							if (isException) {
								return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
							} else {
								return makeAST(EString(""));
							};
						} else {
							node;
						};
					} else {
						node;
					};				
				default:
					node;				
			};
		} else {
			node;
		};	
	case EField(target, fieldName):
		switch (target.def) {
			case EVar("self"):
				makeAST(EField(makeAST(EVar("struct")), fieldName));			
			case EVar("super"):
				node;			
			default:
				node;			
		};	
	case EVar("self"):
		makeAST(EVar("struct"));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var methodName = `;
							var args = `;
							{
								if (methodName == "__super__") {
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									};
								};
								if (methodName == "call" && args.length > 0) {
									@:ast(switch (args[0].def) {
	case EField(superVar, fieldName):
		if (superVar.def.match(EVar("super"))) {
			if (fieldName == "to_string" || fieldName == "toString") {
				return makeAST(EString(""));
			};
		};	
	default:
}) {
										var ` = args[0].def;
										if (enumIndex ` == 28) {
											var ` = `[0];
											var ` = `[1];
											{
												var superVar = `;
												var fieldName = `;
												{
													if ({
														var ` = superVar.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															if (` == "super") {
																true;
															} else false;
														} else false;
													}) {
														if (fieldName == "to_string" || fieldName == "toString") {
															return {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EString(""), metadata : {}, pos : pos};
															};
														};
													};
												};
											};
										} else {};
									};
								};
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar("super"):
		var parentModule = if (node.metadata != null && node.metadata.parentModule != null) {
			node.metadata.parentModule;
		} else if (moduleMetadata != null && moduleMetadata.parentModule != null) {
			moduleMetadata.parentModule;
		} else {
			null;
		};
		if (parentModule != null) {
			if (parentModule == "Exception" && (methodName == "toString" || methodName == "to_string")) {
				return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
			};
			var elixirMethodName = if (methodName == "toString") {
				"to_string";
			} else {
				NameUtils.toSnakeCase(methodName);
			};
			var delegationArgs = [makeAST(EVar("struct"))].concat(args);
			return makeAST(ERemoteCall(makeAST(EVar(parentModule)), elixirMethodName, delegationArgs));
		} else if (methodName == "to_string" || methodName == "toString") {
			var isException = (moduleMetadata != null && moduleMetadata.isException == true);
			if (isException) {
				return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
			} else {
				return makeAST(EField(makeAST(EVar("struct")), "message"));
			};
		} else {
			node;
		};	
	case EField(superVar, fieldName):
		if (superVar.def.match(EVar("super"))) {
			if (fieldName == "to_string" || fieldName == "toString") {
				var isException = (moduleMetadata != null && moduleMetadata.isException == true);
				if (isException) {
					return makeAST(ERemoteCall(makeAST(EVar("Kernel")), "to_string", [makeAST(EField(makeAST(EVar("struct")), "message"))]));
				} else {
					return makeAST(EString(""));
				};
			} else {
				node;
			};
		} else {
			node;
		};	
	default:
		node;	
}) {
										var ` = target.def;
										switch (enumIndex `) {
											case 28: {
												var ` = `[0];
												var ` = `[1];
												{
													var superVar = `;
													var fieldName = `;
													{
														if ({
															var ` = superVar.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																if (` == "super") {
																	true;
																} else false;
															} else false;
														}) {
															if (fieldName == "to_string" || fieldName == "toString") {
																var isException = (moduleMetadata[0] != null && moduleMetadata[0].isException == true);
																if (isException) {
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																		}, "to_string", [{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																			}, "message"), metadata : {}, pos : pos};
																		}]), metadata : {}, pos : pos};
																	};
																} else {
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EString(""), metadata : {}, pos : pos};
																	};
																};
															} else {
																node;
															};
														} else {
															node;
														};
													};
												};
											};
											case 38: {
												var ` = `[0];
												if (` == "super") {
													{
														var parentModule = if (node.metadata != null && node.metadata.parentModule != null) {
															node.metadata.parentModule;
														} else {
															if (moduleMetadata[0] != null && moduleMetadata[0].parentModule != null) {
																moduleMetadata[0].parentModule;
															} else {
																null;
															};
														};
														if (parentModule != null) {
															if (parentModule == "Exception" && (methodName == "toString" || methodName == "to_string")) {
																return {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																	}, "to_string", [{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																		}, "message"), metadata : {}, pos : pos};
																	}]), metadata : {}, pos : pos};
																};
															};
															var elixirMethodName = if (methodName == "toString") {
																"to_string";
															} else {
																reflaxe.elixir.ast.NameUtils.toSnakeCase(methodName);
															};
															var delegationArgs = [{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
															}].concat(args);
															return {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar(parentModule), metadata : {}, pos : pos};
																}, elixirMethodName, delegationArgs), metadata : {}, pos : pos};
															};
														} else {
															if (methodName == "to_string" || methodName == "toString") {
																var isException = (moduleMetadata[0] != null && moduleMetadata[0].isException == true);
																if (isException) {
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																		}, "to_string", [{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																			}, "message"), metadata : {}, pos : pos};
																		}]), metadata : {}, pos : pos};
																	};
																} else {
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																		}, "message"), metadata : {}, pos : pos};
																	};
																};
															} else {
																node;
															};
														};
													};
												} else {
													node;
												};
											};
											default: {
												node;
											}
										};
									};
								} else {
									node;
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var fieldName = `;
							{
								@:ast(switch (target.def) {
	case EVar("self"):
		makeAST(EField(makeAST(EVar("struct")), fieldName));	
	case EVar("super"):
		node;	
	default:
		node;	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										switch (`) {
											case "self": {
												{
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EField({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
														}, fieldName), metadata : {}, pos : pos};
													};
												};
											};
											case "super": {
												{
													node;
												};
											};
											default: {
												node;
											}
										};
									} else {
										node;
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						if (` == "self") {
							{
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
								};
							};
						} else {
							node;
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function phoenixComponentImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsPhoenixComponent = [false];
		var checkForHSigil = [null];
		checkForHSigil[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case ESigil(type, _, _):
		if (type == "H") {
			needsPhoenixComponent = true;
		};	
	case ERaw(code):
		if (code != null && (code.indexOf("~H\"\"\"") != -1 || code.indexOf("~H\"") != -1)) {
			needsPhoenixComponent = true;
		} else {
			iterateAST(node, checkForHSigil);
		};	
	default:
		iterateAST(node, checkForHSigil);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 61: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var type = `;
							{
								if (type == "H") {
									needsPhoenixComponent[0] = true;
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								if (code != null && (code.indexOf("~H\"\"\"", null) != -1 || code.indexOf("~H\"", null) != -1)) {
									needsPhoenixComponent[0] = true;
								} else {
									reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForHSigil[0]);
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForHSigil[0]);
					}
				};
			};
		};
		checkForHSigil[0](ast);
		if (! needsPhoenixComponent[0]) {
			return ast;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EModule(name, attributes, body):
		var hasImport = false;
		for (stmt  in  body) switch (stmt.def) {
			case EUse(mod, _):
				if (mod == "Phoenix.Component") {
					hasImport = true;
				};			
			case EImport(mod, _, _):
				if (mod == "Phoenix.Component") {
					hasImport = true;
				};			
			default:
		};
		if (!hasImport) {
			var importStmt = makeAST(EUse("Phoenix.Component", []));
			var newBody = [importStmt].concat(body);
			return makeASTWithMeta(EModule(name, attributes, newBody), node.metadata, node.pos);
		};
		return node;	
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				var hasLiveViewUse = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == "Phoenix.Component") {
								hasImport = true;
								break;
							};						
						case EUse(module, opts):
							if (module == "Phoenix.Component") {
								hasImport = true;
								break;
							};
							if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
								for (opt  in  opts) {
									switch (opt.def) {
										case EAtom(atom) if (atom == "live_view"):
											hasLiveViewUse = true;
											hasImport = true;
											break;										
										default:
									};
								};
							};						
						default:
					};
				};
				var isLayoutsModule = (name != null && StringTools.endsWith(name, ".Layouts"));
				if (hasLiveViewUse) {
					return node;
				};
				if (isLayoutsModule) {
					var appIdx = name.indexOf("Web");
					var appPrefix = appIdx > 0 ? name.substr(0, appIdx) : null;
					if (appPrefix != null) {
						var webModule = appPrefix + "Web";
						var hasHtmlUse = false;
						for (stmt  in  statements) switch (stmt.def) {
							case EUse(mod, opts):
								if (mod == webModule && opts != null) {
									for (o  in  opts) switch (o.def) {
										case EAtom(a) if (a == "html"):
											hasHtmlUse = true;										
										default:
									};
								};							
							default:
						};
						if (!hasHtmlUse) {
							var htmlUse = makeAST(EUse(webModule, [makeAST(EAtom("html"))]));
							var newStatements = [htmlUse].concat(statements);
							var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
							return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
						};
					};
				} else if (!hasImport) {
					var importStmt = makeAST(EUse("Phoenix.Component", []));
					var newStatements = [importStmt].concat(statements);
					var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
					return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
				};
				return node;			
			default:
				var importStmt = makeAST(EUse("Phoenix.Component", []));
				var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
				return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);			
		};	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								var hasImport = false;
								{
									var ` = 0;
									while (` < body.length) {
										var stmt = body[`];
										++ `;
										@:ast(switch (stmt.def) {
	case EUse(mod, _):
		if (mod == "Phoenix.Component") {
			hasImport = true;
		};	
	case EImport(mod, _, _):
		if (mod == "Phoenix.Component") {
			hasImport = true;
		};	
	default:
}) {
											var ` = stmt.def;
											switch (enumIndex `) {
												case 45: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var mod = `;
														{
															if (mod == "Phoenix.Component") {
																hasImport = true;
															};
														};
													};
												};
												case 46: {
													var ` = `[0];
													var ` = `[1];
													{
														var mod = `;
														{
															if (mod == "Phoenix.Component") {
																hasImport = true;
															};
														};
													};
												};
												default: {}
											};
										};
									};
								};
								if (! hasImport) {
									var importStmt = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EUse("Phoenix.Component", []), metadata : {}, pos : pos};
									};
									var newBody = [importStmt].concat(body);
									return {def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, newBody), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		var hasLiveViewUse = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == "Phoenix.Component") {
						hasImport = true;
						break;
					};				
				case EUse(module, opts):
					if (module == "Phoenix.Component") {
						hasImport = true;
						break;
					};
					if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
						for (opt  in  opts) {
							switch (opt.def) {
								case EAtom(atom) if (atom == "live_view"):
									hasLiveViewUse = true;
									hasImport = true;
									break;								
								default:
							};
						};
					};				
				default:
			};
		};
		var isLayoutsModule = (name != null && StringTools.endsWith(name, ".Layouts"));
		if (hasLiveViewUse) {
			return node;
		};
		if (isLayoutsModule) {
			var appIdx = name.indexOf("Web");
			var appPrefix = appIdx > 0 ? name.substr(0, appIdx) : null;
			if (appPrefix != null) {
				var webModule = appPrefix + "Web";
				var hasHtmlUse = false;
				for (stmt  in  statements) switch (stmt.def) {
					case EUse(mod, opts):
						if (mod == webModule && opts != null) {
							for (o  in  opts) switch (o.def) {
								case EAtom(a) if (a == "html"):
									hasHtmlUse = true;								
								default:
							};
						};					
					default:
				};
				if (!hasHtmlUse) {
					var htmlUse = makeAST(EUse(webModule, [makeAST(EAtom("html"))]));
					var newStatements = [htmlUse].concat(statements);
					var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
					return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
				};
			};
		} else if (!hasImport) {
			var importStmt = makeAST(EUse("Phoenix.Component", []));
			var newStatements = [importStmt].concat(statements);
			var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
			return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
		};
		return node;	
	default:
		var importStmt = makeAST(EUse("Phoenix.Component", []));
		var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
		return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);	
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var statements = `;
											{
												var hasImport = false;
												var hasLiveViewUse = false;
												{
													var ` = 0;
													while (` < statements.length) {
														var stmt = statements[`];
														++ `;
														@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == "Phoenix.Component") {
			hasImport = true;
			break;
		};	
	case EUse(module, opts):
		if (module == "Phoenix.Component") {
			hasImport = true;
			break;
		};
		if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
			for (opt  in  opts) {
				switch (opt.def) {
					case EAtom(atom) if (atom == "live_view"):
						hasLiveViewUse = true;
						hasImport = true;
						break;					
					default:
				};
			};
		};	
	default:
}) {
															var ` = stmt.def;
															switch (enumIndex `) {
																case 45: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var module = `;
																		{
																			if (module == "Phoenix.Component") {
																				hasImport = true;
																				break;
																			};
																		};
																	};
																};
																case 46: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var module = `;
																		var opts = `;
																		{
																			if (module == "Phoenix.Component") {
																				hasImport = true;
																				break;
																			};
																			if (module.indexOf("Web", null) != -1 && opts != null && opts.length > 0) {
																				{
																					var ` = 0;
																					while (` < opts.length) {
																						var opt = opts[`];
																						++ `;
																						@:ast(switch (opt.def) {
	case EAtom(atom) if (atom == "live_view"):
		hasLiveViewUse = true;
		hasImport = true;
		break;	
	default:
}) {
																							var ` = opt.def;
																							if (enumIndex ` == 31) {
																								var ` = `[0];
																								{
																									var atom = `;
																									if (atom == "live_view") {
																										hasLiveViewUse = true;
																										hasImport = true;
																										break;
																									} else {};
																								};
																							} else {};
																						};
																					};
																				};
																			};
																		};
																	};
																};
																default: {}
															};
														};
													};
												};
												var isLayoutsModule = (name != null && StringTools.endsWith(name, ".Layouts"));
												if (hasLiveViewUse) {
													return node;
												};
												if (isLayoutsModule) {
													var appIdx = name.indexOf("Web", null);
													var appPrefix = if (appIdx > 0) {
														name.substr(0, appIdx);
													} else {
														null;
													};
													if (appPrefix != null) {
														var webModule = appPrefix + "Web";
														var hasHtmlUse = false;
														{
															var ` = 0;
															while (` < statements.length) {
																var stmt = statements[`];
																++ `;
																@:ast(switch (stmt.def) {
	case EUse(mod, opts):
		if (mod == webModule && opts != null) {
			for (o  in  opts) switch (o.def) {
				case EAtom(a) if (a == "html"):
					hasHtmlUse = true;				
				default:
			};
		};	
	default:
}) {
																	var ` = stmt.def;
																	if (enumIndex ` == 46) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var mod = `;
																			var opts = `;
																			{
																				if (mod == webModule && opts != null) {
																					{
																						var ` = 0;
																						while (` < opts.length) {
																							var o = opts[`];
																							++ `;
																							@:ast(switch (o.def) {
	case EAtom(a) if (a == "html"):
		hasHtmlUse = true;	
	default:
}) {
																								var ` = o.def;
																								if (enumIndex ` == 31) {
																									var ` = `[0];
																									{
																										var a = `;
																										if (a == "html") {
																											hasHtmlUse = true;
																										} else {};
																									};
																								} else {};
																							};
																						};
																					};
																				};
																			};
																		};
																	} else {};
																};
															};
														};
														if (! hasHtmlUse) {
															var htmlUse = {
																var def = reflaxe.elixir.ast.ElixirASTDef.EUse(webModule, [{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase("html");
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																}]);
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															};
															var newStatements = [htmlUse].concat(statements);
															var newDoBlock = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
															return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
														};
													};
												} else {
													if (! hasImport) {
														var importStmt = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EUse("Phoenix.Component", []), metadata : {}, pos : pos};
														};
														var newStatements = [importStmt].concat(statements);
														var newDoBlock = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
														return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
													};
												};
												return node;
											};
										};
									} else {
										var importStmt = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EUse("Phoenix.Component", []), metadata : {}, pos : pos};
										};
										var newDoBlock = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([importStmt, doBlock]), metadata : {}, pos : pos};
										};
										return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
									};
								};
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function ectoQueryRequirePass(node:reflaxe.elixir.ast.ElixirAST) {
		var scanForEctoCalls = [null];
		scanForEctoCalls[0] = function(x:reflaxe.elixir.ast.ElixirAST, found:{ needs : Bool, has : Bool }) {
			if (x == null || x.def == null) {
				return;
			};
			@:ast(switch (x.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (m == "Kernel" && func == "require" && args != null && args.length == 1):
				switch (args[0].def) {
					case EVar(v) if (v == "Ecto.Query"):
						found.has = true;					
					default:
				};			
			case EVar(m) if (m == "Ecto.Query"):
				found.needs = true;			
			default:
		};
		if (args != null) for (a  in  args) scanForEctoCalls(a, found);	
	case ERaw(code):
		if (code != null && code.indexOf("Ecto.Query.") != -1) found.needs = true;	
	case ECall(target, _, args):
		if (target != null) scanForEctoCalls(target, found);
		if (args != null) for (a  in  args) scanForEctoCalls(a, found);	
	case EBlock(es):
		for (e  in  es) scanForEctoCalls(e, found);	
	case EIf(c, t, e):
		scanForEctoCalls(c, found);
		scanForEctoCalls(t, found);
		if (e != null) scanForEctoCalls(e, found);	
	case ECase(e, cs):
		scanForEctoCalls(e, found);
		for (c  in  cs) {
			if (c.guard != null) scanForEctoCalls(c.guard, found);
			scanForEctoCalls(c.body, found);
		};	
	case EBinary(_, l, r):
		scanForEctoCalls(l, found);
		scanForEctoCalls(r, found);	
	case EFn(cs):
		for (cl  in  cs) scanForEctoCalls(cl.body, found);	
	case EDef(_, _, _, body):
		scanForEctoCalls(body, found);	
	case EDefp(_, _, _, body):
		scanForEctoCalls(body, found);	
	default:
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var body = `;
							{
								scanForEctoCalls[0](body, found);
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var body = `;
							{
								scanForEctoCalls[0](body, found);
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							var cs = `;
							{
								scanForEctoCalls[0](e, found);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										if (c.guard != null) {
											scanForEctoCalls[0](c.guard, found);
										};
										scanForEctoCalls[0](c.body, found);
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								scanForEctoCalls[0](c, found);
								scanForEctoCalls[0](t, found);
								if (e != null) {
									scanForEctoCalls[0](e, found);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var args = `;
							{
								if (target != null) {
									scanForEctoCalls[0](target, found);
								};
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var a = args[`];
											++ `;
											scanForEctoCalls[0](a, found);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var func = `;
							var args = `;
							{
								@:ast(switch (mod.def) {
	case EVar(m) if (m == "Kernel" && func == "require" && args != null && args.length == 1):
		switch (args[0].def) {
			case EVar(v) if (v == "Ecto.Query"):
				found.has = true;			
			default:
		};	
	case EVar(m) if (m == "Ecto.Query"):
		found.needs = true;	
	default:
}) {
									var ` = mod.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var m = `;
											if (m == "Kernel" && func == "require" && args != null && args.length == 1) {
												@:ast(switch (args[0].def) {
	case EVar(v) if (v == "Ecto.Query"):
		found.has = true;	
	default:
}) {
													var ` = args[0].def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v = `;
															if (v == "Ecto.Query") {
																found.has = true;
															} else {};
														};
													} else {};
												};
											} else {
												var m = `;
												if (m == "Ecto.Query") {
													found.needs = true;
												} else {};
											};
										};
									} else {};
								};
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var a = args[`];
											++ `;
											scanForEctoCalls[0](a, found);
										};
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								scanForEctoCalls[0](l, found);
								scanForEctoCalls[0](r, found);
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var cs = `;
							{
								{
									var ` = 0;
									while (` < cs.length) {
										var cl = cs[`];
										++ `;
										scanForEctoCalls[0](cl.body, found);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var es = `;
							{
								{
									var ` = 0;
									while (` < es.length) {
										var e = es[`];
										++ `;
										scanForEctoCalls[0](e, found);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								if (code != null && code.indexOf("Ecto.Query.", null) != -1) {
									found.needs = true;
								};
							};
						};
					};
					default: {}
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements) | EDo(statements):
				var found = { needs : false, has : false };
				for (s  in  statements) scanForEctoCalls(s, found);
				if (found.needs && !found.has) {
					var requireStmt = makeAST(ERequire("Ecto.Query", null));
					var newStatements = [requireStmt].concat(statements);
					var newDo:ElixirAST = switch (doBlock.def) {
						case EBlock(_):
							makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);						
						case EDo(_):
							makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);						
						default:
							doBlock;						
					};
					return makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
				};
				return n;			
			default:
				return n;			
		};	
	case EModule(name, attrs, body):
		var found2 = { needs : false, has : false };
		for (b  in  body) scanForEctoCalls(b, found2);
		if (found2.needs && !found2.has) {
			var requireStmt2 = makeAST(ERequire("Ecto.Query", null));
			var newBody = [requireStmt2].concat(body);
			return makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);
		};
		return n;	
	default:
		return n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var found2 = {needs : false, has : false};
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										scanForEctoCalls[0](b, found2);
									};
								};
								if (found2.needs && ! found2.has) {
									var requireStmt2 = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ERequire("Ecto.Query", null), metadata : {}, pos : pos};
									};
									var newBody = [requireStmt2].concat(body);
									return {def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
								};
								return n;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								@:ast(switch (doBlock.def) {
	case EBlock(statements) | EDo(statements):
		var found = { needs : false, has : false };
		for (s  in  statements) scanForEctoCalls(s, found);
		if (found.needs && !found.has) {
			var requireStmt = makeAST(ERequire("Ecto.Query", null));
			var newStatements = [requireStmt].concat(statements);
			var newDo:ElixirAST = switch (doBlock.def) {
				case EBlock(_):
					makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);				
				case EDo(_):
					makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);				
				default:
					doBlock;				
			};
			return makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
		};
		return n;	
	default:
		return n;	
}) {
									var ` = doBlock.def;
									switch (enumIndex `) {
										case 53: {
											var ` = `[0];
											{
												var statements = `;
												{
													var found = {needs : false, has : false};
													{
														var ` = 0;
														while (` < statements.length) {
															var s = statements[`];
															++ `;
															scanForEctoCalls[0](s, found);
														};
													};
													if (found.needs && ! found.has) {
														var requireStmt = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ERequire("Ecto.Query", null), metadata : {}, pos : pos};
														};
														var newStatements = [requireStmt].concat(statements);
														var newDo = @:ast(switch (doBlock.def) {
	case EBlock(_):
		makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);	
	case EDo(_):
		makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);	
	default:
		doBlock;	
}) {
															var ` = doBlock.def;
															switch (enumIndex `) {
																case 53: {
																	var ` = `[0];
																	{
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
																	};
																};
																case 55: {
																	var ` = `[0];
																	{
																		{def : reflaxe.elixir.ast.ElixirASTDef.EDo(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
																	};
																};
																default: {
																	doBlock;
																}
															};
														};
														return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
													};
													return n;
												};
											};
										};
										case 55: {
											var ` = `[0];
											{
												var statements = `;
												{
													var found = {needs : false, has : false};
													{
														var ` = 0;
														while (` < statements.length) {
															var s = statements[`];
															++ `;
															scanForEctoCalls[0](s, found);
														};
													};
													if (found.needs && ! found.has) {
														var requireStmt = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ERequire("Ecto.Query", null), metadata : {}, pos : pos};
														};
														var newStatements = [requireStmt].concat(statements);
														var newDo = @:ast(switch (doBlock.def) {
	case EBlock(_):
		makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);	
	case EDo(_):
		makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);	
	default:
		doBlock;	
}) {
															var ` = doBlock.def;
															switch (enumIndex `) {
																case 53: {
																	var ` = `[0];
																	{
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
																	};
																};
																case 55: {
																	var ` = `[0];
																	{
																		{def : reflaxe.elixir.ast.ElixirASTDef.EDo(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
																	};
																};
																default: {
																	doBlock;
																}
															};
														};
														return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
													};
													return n;
												};
											};
										};
										default: {
											return n;
										}
									};
								};
							};
						};
					};
					default: {
						return n;
					}
				};
			};
		});
	}

	static function heexContentInlinePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body) if (name == "render"):
		switch (body.def) {
			case EBlock(stmts):
				var contentHtml:Null<String> = null;
				var contentAssignIdx:Int = -1;
				for (i  in  0 ... stmts.length) {
					switch (stmts[i].def) {
						case EMatch(PVar(varName), rhs) if (varName == "content"):
							switch (rhs.def) {
								case EString(s):
									contentHtml = s;								
								case EParen(inner):
									switch (inner.def) {
										case EString(s2):
											contentHtml = s2;										
										default:
									};								
								default:
							};
							contentAssignIdx = i;
							break;						
						default:
					};
				};
				if (contentHtml == null) return node;
				var sigilIdx:Int = -1;
				for (i  in  0 ... stmts.length) {
					switch (stmts[i].def) {
						case ESigil(type, content, modifiers) if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)") != -1):
							sigilIdx = i;
							break;						
						case EParen(inner):
							switch (inner.def) {
								case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
									sigilIdx = i;
									break;								
								default:
							};						
						default:
					};
				};
				if (sigilIdx == -1) return node;
				var newStmts = [];
				for (i  in  0 ... stmts.length) {
					if (i == contentAssignIdx) continue;
					if (i == sigilIdx) {
						switch (stmts[i].def) {
							case EParen(_):
								newStmts.push(makeASTWithMeta(EParen(makeAST(ESigil("H", contentHtml, ""))), stmts[i].metadata, stmts[i].pos));							
							default:
								newStmts.push(makeASTWithMeta(ESigil("H", contentHtml, ""), stmts[i].metadata, stmts[i].pos));							
						};
					} else {
						newStmts.push(stmts[i]);
					};
				};
				return makeASTWithMeta(EDef(name, args, guards, makeAST(EBlock(newStmts))), node.metadata, node.pos);			
			default:
				return node;			
		};	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 2) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						if (name == "render") {
							@:ast(switch (body.def) {
	case EBlock(stmts):
		var contentHtml:Null<String> = null;
		var contentAssignIdx:Int = -1;
		for (i  in  0 ... stmts.length) {
			switch (stmts[i].def) {
				case EMatch(PVar(varName), rhs) if (varName == "content"):
					switch (rhs.def) {
						case EString(s):
							contentHtml = s;						
						case EParen(inner):
							switch (inner.def) {
								case EString(s2):
									contentHtml = s2;								
								default:
							};						
						default:
					};
					contentAssignIdx = i;
					break;				
				default:
			};
		};
		if (contentHtml == null) return node;
		var sigilIdx:Int = -1;
		for (i  in  0 ... stmts.length) {
			switch (stmts[i].def) {
				case ESigil(type, content, modifiers) if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)") != -1):
					sigilIdx = i;
					break;				
				case EParen(inner):
					switch (inner.def) {
						case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
							sigilIdx = i;
							break;						
						default:
					};				
				default:
			};
		};
		if (sigilIdx == -1) return node;
		var newStmts = [];
		for (i  in  0 ... stmts.length) {
			if (i == contentAssignIdx) continue;
			if (i == sigilIdx) {
				switch (stmts[i].def) {
					case EParen(_):
						newStmts.push(makeASTWithMeta(EParen(makeAST(ESigil("H", contentHtml, ""))), stmts[i].metadata, stmts[i].pos));					
					default:
						newStmts.push(makeASTWithMeta(ESigil("H", contentHtml, ""), stmts[i].metadata, stmts[i].pos));					
				};
			} else {
				newStmts.push(stmts[i]);
			};
		};
		return makeASTWithMeta(EDef(name, args, guards, makeAST(EBlock(newStmts))), node.metadata, node.pos);	
	default:
		return node;	
}) {
								var ` = body.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var stmts = `;
										{
											var contentHtml = null;
											var contentAssignIdx = -1;
											{
												var ` = 0;
												var ` = stmts.length;
												while (` < `) {
													var i = ` ++;
													@:ast(switch (stmts[i].def) {
	case EMatch(PVar(varName), rhs) if (varName == "content"):
		switch (rhs.def) {
			case EString(s):
				contentHtml = s;			
			case EParen(inner):
				switch (inner.def) {
					case EString(s2):
						contentHtml = s2;					
					default:
				};			
			default:
		};
		contentAssignIdx = i;
		break;	
	default:
}) {
														var ` = stmts[i].def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var varName = `;
																	var rhs = `;
																	if (varName == "content") {
																		@:ast(switch (rhs.def) {
	case EString(s):
		contentHtml = s;	
	case EParen(inner):
		switch (inner.def) {
			case EString(s2):
				contentHtml = s2;			
			default:
		};	
	default:
}) {
																			var ` = rhs.def;
																			switch (enumIndex `) {
																				case 32: {
																					var ` = `[0];
																					{
																						var s = `;
																						{
																							contentHtml = s;
																						};
																					};
																				};
																				case 54: {
																					var ` = `[0];
																					{
																						var inner = `;
																						{
																							@:ast(switch (inner.def) {
	case EString(s2):
		contentHtml = s2;	
	default:
}) {
																								var ` = inner.def;
																								if (enumIndex ` == 32) {
																									var ` = `[0];
																									{
																										var s2 = `;
																										{
																											contentHtml = s2;
																										};
																									};
																								} else {};
																							};
																						};
																					};
																				};
																				default: {}
																			};
																		};
																		contentAssignIdx = i;
																		break;
																	} else {};
																};
															} else {};
														} else {};
													};
												};
											};
											if (contentHtml == null) {
												return node;
											};
											var sigilIdx = -1;
											{
												var ` = 0;
												var ` = stmts.length;
												while (` < `) {
													var i = ` ++;
													@:ast(switch (stmts[i].def) {
	case ESigil(type, content, modifiers) if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)") != -1):
		sigilIdx = i;
		break;	
	case EParen(inner):
		switch (inner.def) {
			case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
				sigilIdx = i;
				break;			
			default:
		};	
	default:
}) {
														var ` = stmts[i].def;
														switch (enumIndex `) {
															case 54: {
																var ` = `[0];
																{
																	var inner = `;
																	{
																		@:ast(switch (inner.def) {
	case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
		sigilIdx = i;
		break;	
	default:
}) {
																			var ` = inner.def;
																			if (enumIndex ` == 61) {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var type2 = `;
																					var content2 = `;
																					var modifiers2 = `;
																					if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)", null) != -1) {
																						sigilIdx = i;
																						break;
																					} else {};
																				};
																			} else {};
																		};
																	};
																};
															};
															case 61: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var type = `;
																	var content = `;
																	var modifiers = `;
																	if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)", null) != -1) {
																		sigilIdx = i;
																		break;
																	} else {};
																};
															};
															default: {}
														};
													};
												};
											};
											if (sigilIdx == -1) {
												return node;
											};
											var newStmts = [];
											{
												var ` = 0;
												var ` = stmts.length;
												while (` < `) {
													var i = ` ++;
													if (i == contentAssignIdx) {
														continue;
													};
													if (i == sigilIdx) {
														@:ast(switch (stmts[i].def) {
	case EParen(_):
		newStmts.push(makeASTWithMeta(EParen(makeAST(ESigil("H", contentHtml, ""))), stmts[i].metadata, stmts[i].pos));	
	default:
		newStmts.push(makeASTWithMeta(ESigil("H", contentHtml, ""), stmts[i].metadata, stmts[i].pos));	
}) {
															var ` = stmts[i].def;
															if (enumIndex ` == 54) {
																var ` = `[0];
																{
																	newStmts.push({def : reflaxe.elixir.ast.ElixirASTDef.EParen({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ESigil("H", contentHtml, ""), metadata : {}, pos : pos};
																	}), metadata : stmts[i].metadata, pos : stmts[i].pos});
																};
															} else {
																newStmts.push({def : reflaxe.elixir.ast.ElixirASTDef.ESigil("H", contentHtml, ""), metadata : stmts[i].metadata, pos : stmts[i].pos});
															};
														};
													} else {
														newStmts.push(stmts[i]);
													};
												};
											};
											return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStmts), metadata : {}, pos : pos};
											}), metadata : node.metadata, pos : node.pos};
										};
									};
								} else {
									return node;
								};
							};
						} else {
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function numericNoOpCleanupPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var isNumericLiteral = function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EInteger(_) | EFloat(_):
		true;	
	default:
		false;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 33: {
						var ` = `[0];
						{
							true;
						};
					};
					case 34: {
						var ` = `[0];
						{
							true;
						};
					};
					default: {
						false;
					}
				};
			};
		};
		var rewriteIfIncrements = [null];
		rewriteIfIncrements[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EBinary(Add, { def : EInteger(a) }, { def : EInteger(b) }):
		makeAST(EInteger(a + b));	
	case EIf(cond, thenB, elseB):
		var newThen = switch (thenB.def) {
			case EBinary(Add, { def : EVar(v) }, rhs):
				makeAST(EMatch(PVar(v), makeAST(EBinary(Add, makeAST(EVar(v)), rewriteIfIncrements(rhs)))));			
			case EBinary(Add, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
				makeAST(ENil);			
			default:
				rewriteIfIncrements(thenB);			
		};
		var newElse = if (elseB != null) switch (elseB.def) {
			case EBinary(Add, { def : EVar(v2) }, rhs2):
				makeAST(EMatch(PVar(v2), makeAST(EBinary(Add, makeAST(EVar(v2)), rewriteIfIncrements(rhs2)))));			
			case EBinary(Add, l2, r2) if (isNumericLiteral(l2) && isNumericLiteral(r2)):
				makeAST(ENil);			
			default:
				rewriteIfIncrements(elseB);			
		} else null;
		makeASTWithMeta(EIf(rewriteIfIncrements(cond), newThen, newElse), n.metadata, n.pos);	
	case EBlock(stmts):
		var out:Array<ElixirAST> = [];
		for (idx  in  0 ... stmts.length) {
			var s = stmts[idx];
			var isLast = (idx == stmts.length - 1);
			var drop = switch (s.def) {
				case EBinary(_, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
					true;				
				case EInteger(_) if (!isLast):
					true;				
				default:
					false;				
			};
			if (!drop) out.push(rewriteIfIncrements(s));
		};
		makeASTWithMeta(EBlock(out), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenB = `;
							var elseB = `;
							{
								var newThen = @:ast(switch (thenB.def) {
	case EBinary(Add, { def : EVar(v) }, rhs):
		makeAST(EMatch(PVar(v), makeAST(EBinary(Add, makeAST(EVar(v)), rewriteIfIncrements(rhs)))));	
	case EBinary(Add, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
		makeAST(ENil);	
	default:
		rewriteIfIncrements(thenB);	
}) {
									var ` = thenB.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 0) {
											{
												var ` = `.def;
												var ` = `.metadata;
												var ` = `.pos;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var v = `;
														var rhs = `;
														{
															{
																var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v), {
																	var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(v), metadata : {}, pos : pos};
																	}, rewriteIfIncrements[0](rhs));
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																});
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															};
														};
													};
												} else {
													var l = `;
													var r = `;
													if (isNumericLiteral(l) && isNumericLiteral(r)) {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
														};
													} else {
														rewriteIfIncrements[0](thenB);
													};
												};
											};
										} else {
											rewriteIfIncrements[0](thenB);
										};
									} else {
										rewriteIfIncrements[0](thenB);
									};
								};
								var newElse = if (elseB != null) {
									@:ast(switch (elseB.def) {
	case EBinary(Add, { def : EVar(v2) }, rhs2):
		makeAST(EMatch(PVar(v2), makeAST(EBinary(Add, makeAST(EVar(v2)), rewriteIfIncrements(rhs2)))));	
	case EBinary(Add, l2, r2) if (isNumericLiteral(l2) && isNumericLiteral(r2)):
		makeAST(ENil);	
	default:
		rewriteIfIncrements(elseB);	
}) {
										var ` = elseB.def;
										if (enumIndex ` == 26) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 0) {
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v2 = `;
															var rhs2 = `;
															{
																{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v2), {
																		var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(v2), metadata : {}, pos : pos};
																		}, rewriteIfIncrements[0](rhs2));
																		var pos = null;
																		{def : def, metadata : {}, pos : pos};
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																};
															};
														};
													} else {
														var l2 = `;
														var r2 = `;
														if (isNumericLiteral(l2) && isNumericLiteral(r2)) {
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
															};
														} else {
															rewriteIfIncrements[0](elseB);
														};
													};
												};
											} else {
												rewriteIfIncrements[0](elseB);
											};
										} else {
											rewriteIfIncrements[0](elseB);
										};
									};
								} else {
									null;
								};
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EIf(rewriteIfIncrements[0](cond), newThen, newElse);
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 0) {
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 33) {
									var ` = `[0];
									{
										var ` = `.def;
										var ` = `.metadata;
										var ` = `.pos;
										if (enumIndex ` == 33) {
											var ` = `[0];
											{
												var b = `;
												var a = `;
												{
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(a + b), metadata : {}, pos : pos};
													};
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						} else {
							n;
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								var out = [];
								{
									var ` = 0;
									var ` = stmts.length;
									while (` < `) {
										var idx = ` ++;
										var s = stmts[idx];
										var isLast = (idx == stmts.length - 1);
										var drop = @:ast(switch (s.def) {
	case EBinary(_, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
		true;	
	case EInteger(_) if (!isLast):
		true;	
	default:
		false;	
}) {
											var ` = s.def;
											switch (enumIndex `) {
												case 26: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var l = `;
														var r = `;
														if (isNumericLiteral(l) && isNumericLiteral(r)) {
															true;
														} else {
															false;
														};
													};
												};
												case 33: {
													var ` = `[0];
													if (! isLast) {
														true;
													} else {
														false;
													};
												};
												default: {
													false;
												}
											};
										};
										if (! drop) {
											out.push(rewriteIfIncrements[0](s));
										};
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		};
		return rewriteIfIncrements[0](ast);
	}

	static function phoenixFunctionMappingPass(node:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case ECall(null, "assign_multiple", args):
		return makeASTWithMeta(ECall(null, "assign", args), n.metadata, n.pos);	
	default:
		return n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 22) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == null) if (` == "assign_multiple") {
						{
							var args = `;
							{
								return {def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "assign", args), metadata : n.metadata, pos : n.pos};
							};
						};
					} else {
						return n;
					} else {
						return n;
					};
				} else {
					return n;
				};
			};
		});
	}

	static function liveViewCoreComponentsImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsCoreComponents = [false];
		var moduleName = [""];
		var findModuleName = [null];
		findModuleName[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EDefmodule(name, _):
		moduleName = name;
		return;	
	default:
		iterateAST(node, findModuleName);	
}) {
				var ` = node.def;
				if (enumIndex ` == 1) {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						{
							moduleName[0] = name;
							return;
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, findModuleName[0]);
				};
			};
		};
		findModuleName[0](ast);
		if (moduleName[0] == "" || moduleName[0].indexOf("Live", null) == -1) {
			return ast;
		};
		var checkForComponents = [null];
		checkForComponents[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ESigil(type, content, _):
		if (type == "H") {
			if (content.indexOf("<.") != -1) {
				needsCoreComponents = true;
			};
		};	
	default:
		iterateAST(node, checkForComponents);	
}) {
				var ` = node.def;
				if (enumIndex ` == 61) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var type = `;
						var content = `;
						{
							if (type == "H") {
								if (content.indexOf("<.", null) != -1) {
									needsCoreComponents[0] = true;
								};
							};
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForComponents[0]);
				};
			};
		};
		checkForComponents[0](ast);
		if (! needsCoreComponents[0]) {
			return ast;
		};
		var appWebName = "";
		if (moduleName[0].indexOf(".", null) != -1) {
			var parts = moduleName[0].split(".");
			if (parts.length > 0) {
				appWebName = parts[0];
			};
		};
		if (appWebName == "") {
			return ast;
		};
		var coreComponentsModule = appWebName + ".CoreComponents";
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == coreComponentsModule) {
								hasImport = true;
								break;
							};						
						default:
					};
				};
				if (!hasImport) {
					var exceptOptions:Array<EImportOption> = [{ name : "label", arity : 1 }];
					var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
					var newStatements = [];
					var importAdded = false;
					for (stmt  in  statements) {
						newStatements.push(stmt);
						if (!importAdded) {
							switch (stmt.def) {
								case EUse(_, _):
									newStatements.push(importStmt);
									importAdded = true;								
								default:
							};
						};
					};
					if (!importAdded) {
						newStatements = [importStmt].concat(statements);
					};
					var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
					return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
				};
				return node;			
			default:
				return node;			
		};	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 1) {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == coreComponentsModule) {
						hasImport = true;
						break;
					};				
				default:
			};
		};
		if (!hasImport) {
			var exceptOptions:Array<EImportOption> = [{ name : "label", arity : 1 }];
			var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
			var newStatements = [];
			var importAdded = false;
			for (stmt  in  statements) {
				newStatements.push(stmt);
				if (!importAdded) {
					switch (stmt.def) {
						case EUse(_, _):
							newStatements.push(importStmt);
							importAdded = true;						
						default:
					};
				};
			};
			if (!importAdded) {
				newStatements = [importStmt].concat(statements);
			};
			var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
			return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
								var ` = doBlock.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var statements = `;
										{
											var hasImport = false;
											{
												var ` = 0;
												while (` < statements.length) {
													var stmt = statements[`];
													++ `;
													@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == coreComponentsModule) {
			hasImport = true;
			break;
		};	
	default:
}) {
														var ` = stmt.def;
														if (enumIndex ` == 45) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var module = `;
																{
																	if (module == coreComponentsModule) {
																		hasImport = true;
																		break;
																	};
																};
															};
														} else {};
													};
												};
											};
											if (! hasImport) {
												var exceptOptions = [{name : "label", arity : 1}];
												var importStmt = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EImport(coreComponentsModule, null, exceptOptions), metadata : {}, pos : pos};
												};
												var newStatements = [];
												var importAdded = false;
												{
													var ` = 0;
													while (` < statements.length) {
														var stmt = statements[`];
														++ `;
														newStatements.push(stmt);
														if (! importAdded) {
															@:ast(switch (stmt.def) {
	case EUse(_, _):
		newStatements.push(importStmt);
		importAdded = true;	
	default:
}) {
																var ` = stmt.def;
																if (enumIndex ` == 46) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		newStatements.push(importStmt);
																		importAdded = true;
																	};
																} else {};
															};
														};
													};
												};
												if (! importAdded) {
													newStatements = [importStmt].concat(statements);
												};
												var newDoBlock = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : doBlock.metadata, pos : doBlock.pos};
												return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDoBlock), metadata : node.metadata, pos : node.pos};
											};
											return node;
										};
									};
								} else {
									return node;
								};
							};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function instanceMethodTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall({ def : EField(target, field), metadata : fieldMeta, pos : fieldPos }, methodName, args):
		if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
			var moduleName = switch (methodName) {
				case "add":
					"StringBuf";				
				case "toString" | "to_string":
					"StringBuf";				
				default:
					null;				
			};
			if (moduleName != null) {
				var moduleRef = makeAST(EVar(moduleName));
				var targetField = makeASTWithMeta(EField(target, field), fieldMeta, fieldPos);
				var newArgs = [targetField].concat(args);
				var functionName = switch (methodName) {
					case "toString" | "to_string":
						"to_string";					
					default:
						methodName;					
				};
				return makeASTWithMeta(ERemoteCall(moduleRef, functionName, newArgs), node.metadata, node.pos);
			};
		};
		node;	
	case ECall(target, methodName, args) if (target != null):
		switch (target.def) {
			case EVar(varName):
				if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
					var moduleName = "StringBuf";
					var moduleRef = makeAST(EVar(moduleName));
					var functionName = switch (methodName) {
						case "toString" | "to_string":
							"to_string";						
						default:
							methodName;						
					};
					return makeASTWithMeta(ERemoteCall(moduleRef, functionName, [target].concat(args)), node.metadata, node.pos);
				} else if (methodName == "write_value" || methodName == "writeValue") {
					var functionName = switch (methodName) {
						case "writeValue":
							"write_value";						
						default:
							methodName;						
					};
					return makeASTWithMeta(ECall(null, functionName, [target].concat(args)), node.metadata, node.pos);
				};			
			case EField(obj, field):
				if (methodName == "write_value" || methodName == "writeValue") {
					var functionName = switch (methodName) {
						case "writeValue":
							"write_value";						
						default:
							methodName;						
					};
					var targetExpr = makeAST(EField(obj, field));
					return makeASTWithMeta(ECall(null, functionName, [targetExpr].concat(args)), node.metadata, node.pos);
				};			
			default:
		};
		node;	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 22) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == null) {
						var target = `;
						var methodName = `;
						var args = `;
						if (target != null) {
							@:ast(switch (target.def) {
	case EVar(varName):
		if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
			var moduleName = "StringBuf";
			var moduleRef = makeAST(EVar(moduleName));
			var functionName = switch (methodName) {
				case "toString" | "to_string":
					"to_string";				
				default:
					methodName;				
			};
			return makeASTWithMeta(ERemoteCall(moduleRef, functionName, [target].concat(args)), node.metadata, node.pos);
		} else if (methodName == "write_value" || methodName == "writeValue") {
			var functionName = switch (methodName) {
				case "writeValue":
					"write_value";				
				default:
					methodName;				
			};
			return makeASTWithMeta(ECall(null, functionName, [target].concat(args)), node.metadata, node.pos);
		};	
	case EField(obj, field):
		if (methodName == "write_value" || methodName == "writeValue") {
			var functionName = switch (methodName) {
				case "writeValue":
					"write_value";				
				default:
					methodName;				
			};
			var targetExpr = makeAST(EField(obj, field));
			return makeASTWithMeta(ECall(null, functionName, [targetExpr].concat(args)), node.metadata, node.pos);
		};	
	default:
}) {
								var ` = target.def;
								switch (enumIndex `) {
									case 28: {
										var ` = `[0];
										var ` = `[1];
										{
											var obj = `;
											var field = `;
											{
												if (methodName == "write_value" || methodName == "writeValue") {
													var functionName = @:ast(switch (methodName) {
	case "writeValue":
		"write_value";	
	default:
		methodName;	
}) if (methodName == "writeValue") {
														{
															"write_value";
														};
													} else {
														methodName;
													};
													var targetExpr = {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EField(obj, field), metadata : {}, pos : pos};
													};
													return {
														var def = reflaxe.elixir.ast.ElixirASTDef.ECall(null, functionName, [targetExpr].concat(args));
														var meta = node.metadata;
														var pos = node.pos;
														{def : def, metadata : meta, pos : pos};
													};
												};
											};
										};
									};
									case 38: {
										var ` = `[0];
										{
											var varName = `;
											{
												if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
													var moduleName = "StringBuf";
													var moduleRef = {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
													};
													var functionName = @:ast(switch (methodName) {
	case "toString" | "to_string":
		"to_string";	
	default:
		methodName;	
}) switch (methodName) {
														case "toString", "to_string": {
															{
																"to_string";
															};
														};
														default: {
															methodName;
														}
													};
													return {
														var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, functionName, [target].concat(args));
														var meta = node.metadata;
														var pos = node.pos;
														{def : def, metadata : meta, pos : pos};
													};
												} else {
													if (methodName == "write_value" || methodName == "writeValue") {
														var functionName = @:ast(switch (methodName) {
	case "writeValue":
		"write_value";	
	default:
		methodName;	
}) if (methodName == "writeValue") {
															{
																"write_value";
															};
														} else {
															methodName;
														};
														return {
															var def = reflaxe.elixir.ast.ElixirASTDef.ECall(null, functionName, [target].concat(args));
															var meta = node.metadata;
															var pos = node.pos;
															{def : def, metadata : meta, pos : pos};
														};
													};
												};
											};
										};
									};
									default: {}
								};
							};
							node;
						} else {
							node;
						};
					} else {
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 28) {
							var ` = `[0];
							var ` = `[1];
							{
								var target = `;
								var field = `;
								var fieldMeta = `;
								var fieldPos = `;
								var methodName = `;
								var args = `;
								{
									if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
										var moduleName = @:ast(switch (methodName) {
	case "add":
		"StringBuf";	
	case "toString" | "to_string":
		"StringBuf";	
	default:
		null;	
}) switch (methodName) {
											case "add": {
												{
													"StringBuf";
												};
											};
											case "toString", "to_string": {
												{
													"StringBuf";
												};
											};
											default: {
												null;
											}
										};
										if (moduleName != null) {
											var moduleRef = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
											};
											var targetField = {def : reflaxe.elixir.ast.ElixirASTDef.EField(target, field), metadata : fieldMeta, pos : fieldPos};
											var newArgs = [targetField].concat(args);
											var functionName = @:ast(switch (methodName) {
	case "toString" | "to_string":
		"to_string";	
	default:
		methodName;	
}) switch (methodName) {
												case "toString", "to_string": {
													{
														"to_string";
													};
												};
												default: {
													methodName;
												}
											};
											return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, functionName, newArgs), metadata : node.metadata, pos : node.pos};
										};
									};
									node;
								};
							};
						} else {
							var target = `;
							var methodName = `;
							var args = `;
							if (target != null) {
								@:ast(switch (target.def) {
	case EVar(varName):
		if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
			var moduleName = "StringBuf";
			var moduleRef = makeAST(EVar(moduleName));
			var functionName = switch (methodName) {
				case "toString" | "to_string":
					"to_string";				
				default:
					methodName;				
			};
			return makeASTWithMeta(ERemoteCall(moduleRef, functionName, [target].concat(args)), node.metadata, node.pos);
		} else if (methodName == "write_value" || methodName == "writeValue") {
			var functionName = switch (methodName) {
				case "writeValue":
					"write_value";				
				default:
					methodName;				
			};
			return makeASTWithMeta(ECall(null, functionName, [target].concat(args)), node.metadata, node.pos);
		};	
	case EField(obj, field):
		if (methodName == "write_value" || methodName == "writeValue") {
			var functionName = switch (methodName) {
				case "writeValue":
					"write_value";				
				default:
					methodName;				
			};
			var targetExpr = makeAST(EField(obj, field));
			return makeASTWithMeta(ECall(null, functionName, [targetExpr].concat(args)), node.metadata, node.pos);
		};	
	default:
}) {
									var ` = target.def;
									switch (enumIndex `) {
										case 28: {
											var ` = `[0];
											var ` = `[1];
											{
												var obj = `;
												var field = `;
												{
													if (methodName == "write_value" || methodName == "writeValue") {
														var functionName = @:ast(switch (methodName) {
	case "writeValue":
		"write_value";	
	default:
		methodName;	
}) if (methodName == "writeValue") {
															{
																"write_value";
															};
														} else {
															methodName;
														};
														var targetExpr = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EField(obj, field), metadata : {}, pos : pos};
														};
														return {
															var def = reflaxe.elixir.ast.ElixirASTDef.ECall(null, functionName, [targetExpr].concat(args));
															var meta = node.metadata;
															var pos = node.pos;
															{def : def, metadata : meta, pos : pos};
														};
													};
												};
											};
										};
										case 38: {
											var ` = `[0];
											{
												var varName = `;
												{
													if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
														var moduleName = "StringBuf";
														var moduleRef = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
														};
														var functionName = @:ast(switch (methodName) {
	case "toString" | "to_string":
		"to_string";	
	default:
		methodName;	
}) switch (methodName) {
															case "toString", "to_string": {
																{
																	"to_string";
																};
															};
															default: {
																methodName;
															}
														};
														return {
															var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, functionName, [target].concat(args));
															var meta = node.metadata;
															var pos = node.pos;
															{def : def, metadata : meta, pos : pos};
														};
													} else {
														if (methodName == "write_value" || methodName == "writeValue") {
															var functionName = @:ast(switch (methodName) {
	case "writeValue":
		"write_value";	
	default:
		methodName;	
}) if (methodName == "writeValue") {
																{
																	"write_value";
																};
															} else {
																methodName;
															};
															return {
																var def = reflaxe.elixir.ast.ElixirASTDef.ECall(null, functionName, [target].concat(args));
																var meta = node.metadata;
																var pos = node.pos;
																{def : def, metadata : meta, pos : pos};
															};
														};
													};
												};
											};
										};
										default: {}
									};
								};
								node;
							} else {
								node;
							};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function stringMethodTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall(target, methodName, args) if (target != null):
		var stringMethod = switch (methodName) {
			case "charAt" | "char_at":
				"at";			
			case "charCodeAt" | "char_code_at":
				"to_charlist";			
			case "toLowerCase" | "to_lower_case":
				"downcase";			
			case "toUpperCase" | "to_upper_case":
				"upcase";			
			case "indexOf" | "index_of":
				"index";			
			case "substring" | "substr":
				"slice";			
			case "split":
				"split";			
			case "trim":
				"trim";			
			case "length":
				"length";			
			case "toString" | "to_string":
				"to_string";			
			case "lastIndexOf" | "last_index_of":
				null;			
			case _:
				null;			
		};
		if (stringMethod != null) {
			if (methodName == "charCodeAt" || methodName == "char_code_at") {
				makeASTWithMeta(ERemoteCall(makeAST(EAtom(ElixirAtom.raw("binary"))), "at", [target].concat(args)), node.metadata, node.pos);
			} else if (methodName == "toString" || methodName == "to_string") {
				makeASTWithMeta(ERemoteCall(makeAST(EVar("Integer")), "to_string", [target].concat(args)), node.metadata, node.pos);
			} else if (methodName == "length") {
				makeASTWithMeta(ERemoteCall(makeAST(EVar("String")), "length", [target]), node.metadata, node.pos);
			} else {
				var newArgs = [target].concat(args);
				makeASTWithMeta(ERemoteCall(makeAST(EVar("String")), stringMethod, newArgs), node.metadata, node.pos);
			};
		} else if (methodName == "lastIndexOf" || methodName == "last_index_of") {
			node;
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 22) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var methodName = `;
						var args = `;
						if (target != null) {
							var stringMethod = @:ast(switch (methodName) {
	case "charAt" | "char_at":
		"at";	
	case "charCodeAt" | "char_code_at":
		"to_charlist";	
	case "toLowerCase" | "to_lower_case":
		"downcase";	
	case "toUpperCase" | "to_upper_case":
		"upcase";	
	case "indexOf" | "index_of":
		"index";	
	case "substring" | "substr":
		"slice";	
	case "split":
		"split";	
	case "trim":
		"trim";	
	case "length":
		"length";	
	case "toString" | "to_string":
		"to_string";	
	case "lastIndexOf" | "last_index_of":
		null;	
	case _:
		null;	
}) switch (methodName) {
								case "charAt", "char_at": {
									{
										"at";
									};
								};
								case "charCodeAt", "char_code_at": {
									{
										"to_charlist";
									};
								};
								case "indexOf", "index_of": {
									{
										"index";
									};
								};
								case "lastIndexOf", "last_index_of": {
									{
										null;
									};
								};
								case "length": {
									{
										"length";
									};
								};
								case "split": {
									{
										"split";
									};
								};
								case "substr", "substring": {
									{
										"slice";
									};
								};
								case "toLowerCase", "to_lower_case": {
									{
										"downcase";
									};
								};
								case "toString", "to_string": {
									{
										"to_string";
									};
								};
								case "toUpperCase", "to_upper_case": {
									{
										"upcase";
									};
								};
								case "trim": {
									{
										"trim";
									};
								};
								default: {
									null;
								}
							};
							if (stringMethod != null) {
								if (methodName == "charCodeAt" || methodName == "char_code_at") {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "binary"), metadata : {}, pos : pos};
										}, "at", [target].concat(args));
										var meta = node.metadata;
										var pos = node.pos;
										{def : def, metadata : meta, pos : pos};
									};
								} else {
									if (methodName == "toString" || methodName == "to_string") {
										{
											var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Integer"), metadata : {}, pos : pos};
											}, "to_string", [target].concat(args));
											var meta = node.metadata;
											var pos = node.pos;
											{def : def, metadata : meta, pos : pos};
										};
									} else {
										if (methodName == "length") {
											{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
											}, "length", [target]), metadata : node.metadata, pos : node.pos};
										} else {
											var newArgs = [target].concat(args);
											{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
											}, stringMethod, newArgs), metadata : node.metadata, pos : node.pos};
										};
									};
								};
							} else {
								if (methodName == "lastIndexOf" || methodName == "last_index_of") {
									node;
								} else {
									node;
								};
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function constantFoldingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBinary(op, left, right):
		switch ([left.def, right.def]) {
			case [EInteger(l), EInteger(r)]:
				var result = switch (op) {
					case Add:
						l + r;					
					case Subtract:
						l - r;					
					case Multiply:
						l * r;					
					case Divide:
						Math.floor(l / r);					
					case Remainder:
						l % r;					
					case Less:
						l < r ? 1 : 0;					
					case Greater:
						l > r ? 1 : 0;					
					case LessEqual:
						l <= r ? 1 : 0;					
					case GreaterEqual:
						l >= r ? 1 : 0;					
					case Equal:
						l == r ? 1 : 0;					
					case NotEqual:
						l != r ? 1 : 0;					
					default:
						null;					
				};
				if (result != null) {
					if (op == Less || op == Greater || op == LessEqual || op == GreaterEqual || op == Equal || op == NotEqual) {
						makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
					} else {
						makeASTWithMeta(EInteger(result), node.metadata, node.pos);
					};
				} else {
					node;
				};			
			case [EString(l), EString(r)] if (op == StringConcat):
				makeASTWithMeta(EString(l + r), node.metadata, node.pos);			
			case [EList(l), EList(r)] if (op == Concat):
				makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);			
			default:
				node;			
		};	
	case EUnary(op, expr):
		switch (expr.def) {
			case EInteger(i) if (op == Negate):
				makeASTWithMeta(EInteger(-i), node.metadata, node.pos);			
			case EBoolean(b) if (op == Not):
				makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								@:ast(switch ([left.def, right.def]) {
	case [EInteger(l), EInteger(r)]:
		var result = switch (op) {
			case Add:
				l + r;			
			case Subtract:
				l - r;			
			case Multiply:
				l * r;			
			case Divide:
				Math.floor(l / r);			
			case Remainder:
				l % r;			
			case Less:
				l < r ? 1 : 0;			
			case Greater:
				l > r ? 1 : 0;			
			case LessEqual:
				l <= r ? 1 : 0;			
			case GreaterEqual:
				l >= r ? 1 : 0;			
			case Equal:
				l == r ? 1 : 0;			
			case NotEqual:
				l != r ? 1 : 0;			
			default:
				null;			
		};
		if (result != null) {
			if (op == Less || op == Greater || op == LessEqual || op == GreaterEqual || op == Equal || op == NotEqual) {
				makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
			} else {
				makeASTWithMeta(EInteger(result), node.metadata, node.pos);
			};
		} else {
			node;
		};	
	case [EString(l), EString(r)] if (op == StringConcat):
		makeASTWithMeta(EString(l + r), node.metadata, node.pos);	
	case [EList(l), EList(r)] if (op == Concat):
		makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = left.def;
									var ` = right.def;
									switch (enumIndex `) {
										case 15: {
											var ` = `[0];
											if (enumIndex ` == 15) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													if (op == reflaxe.elixir.ast.EBinaryOp.Concat) {
														{
															var def = reflaxe.elixir.ast.ElixirASTDef.EList(l.concat(r));
															var meta = node.metadata;
															var pos = node.pos;
															{def : def, metadata : meta, pos : pos};
														};
													} else {
														node;
													};
												};
											} else {
												node;
											};
										};
										case 32: {
											var ` = `[0];
											if (enumIndex ` == 32) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													if (op == reflaxe.elixir.ast.EBinaryOp.StringConcat) {
														{def : reflaxe.elixir.ast.ElixirASTDef.EString(l + r), metadata : node.metadata, pos : node.pos};
													} else {
														node;
													};
												};
											} else {
												node;
											};
										};
										case 33: {
											var ` = `[0];
											if (enumIndex ` == 33) {
												var ` = `[0];
												{
													var r = `;
													var l = `;
													{
														var result = @:ast(switch (op) {
	case Add:
		l + r;	
	case Subtract:
		l - r;	
	case Multiply:
		l * r;	
	case Divide:
		Math.floor(l / r);	
	case Remainder:
		l % r;	
	case Less:
		l < r ? 1 : 0;	
	case Greater:
		l > r ? 1 : 0;	
	case LessEqual:
		l <= r ? 1 : 0;	
	case GreaterEqual:
		l >= r ? 1 : 0;	
	case Equal:
		l == r ? 1 : 0;	
	case NotEqual:
		l != r ? 1 : 0;	
	default:
		null;	
}) switch (enumIndex op) {
															case 0: {
																{
																	l + r;
																};
															};
															case 1: {
																{
																	l - r;
																};
															};
															case 2: {
																{
																	l * r;
																};
															};
															case 3: {
																{
																	Math.floor(l / r);
																};
															};
															case 4: {
																{
																	l % r;
																};
															};
															case 6: {
																{
																	if (l == r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 7: {
																{
																	if (l != r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 10: {
																{
																	if (l < r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 11: {
																{
																	if (l > r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 12: {
																{
																	if (l <= r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															case 13: {
																{
																	if (l >= r) {
																		1;
																	} else {
																		0;
																	};
																};
															};
															default: {
																null;
															}
														};
														if (result != null) {
															if (op == reflaxe.elixir.ast.EBinaryOp.Less || op == reflaxe.elixir.ast.EBinaryOp.Greater || op == reflaxe.elixir.ast.EBinaryOp.LessEqual || op == reflaxe.elixir.ast.EBinaryOp.GreaterEqual || op == reflaxe.elixir.ast.EBinaryOp.Equal || op == reflaxe.elixir.ast.EBinaryOp.NotEqual) {
																{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(result == 1), metadata : node.metadata, pos : node.pos};
															} else {
																{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(result), metadata : node.metadata, pos : node.pos};
															};
														} else {
															node;
														};
													};
												};
											} else {
												node;
											};
										};
										default: {
											node;
										}
									};
								};
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var expr = `;
							{
								@:ast(switch (expr.def) {
	case EInteger(i) if (op == Negate):
		makeASTWithMeta(EInteger(-i), node.metadata, node.pos);	
	case EBoolean(b) if (op == Not):
		makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = expr.def;
									switch (enumIndex `) {
										case 33: {
											var ` = `[0];
											{
												var i = `;
												if (op == reflaxe.elixir.ast.EUnaryOp.Negate) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(- i), metadata : node.metadata, pos : node.pos};
												} else {
													node;
												};
											};
										};
										case 35: {
											var ` = `[0];
											{
												var b = `;
												if (op == reflaxe.elixir.ast.EUnaryOp.Not) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(! b), metadata : node.metadata, pos : node.pos};
												} else {
													node;
												};
											};
										};
										default: {
											node;
										}
									};
								};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function stringInterpolationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transform = [null];
		transform[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null) {
				return null;
			};
			@:ast(switch (node.def) {
	case EBinary(StringConcat, l, r):
		var parts = [];
		function collectParts(expr:ElixirAST) {
			switch (expr.def) {
				case EBinary(StringConcat, l, r):
					collectParts(l);
					collectParts(r);				
				case EString(s):
					parts.push({ isString : true, value : s, expr : null });				
				default:
					parts.push({ isString : false, value : null, expr : expr });				
			};
		};
		collectParts(node);
		var hasNonString = false;
		var hasEmptyString = false;
		for (part  in  parts) {
			if (!part.isString) {
				hasNonString = true;
			} else if (part.value == "") {
				hasEmptyString = true;
			};
		};
		if (hasNonString && parts.length > 1) {
			var result = "\"";
			for (i  in  0 ... parts.length) {
				var part = parts[i];
				if (part.isString) {
					var escaped = part.value;
					escaped = escaped.split("\\").join("\\\\");
					escaped = escaped.split("\"").join("\\\"");
					escaped = escaped.split("#{").join("\\#{");
					result += escaped;
				} else {
					var transformedExpr = transform(part.expr);
					var exprToInterpolate = switch (transformedExpr.def) {
						case ECall(target, "to_string", []) if (target != null):
							target;						
						default:
							transformedExpr;						
					};
					function simplifyInterpolationExpr(e:ElixirAST):ElixirAST {
						return switch (e.def) {
							case ECall(null, "inspect", [inner]):
								switch (inner.def) {
									case ERemoteCall({ def : EVar("Map") }, "get", args) if (args != null && args.length == 2):
										switch (args[1].def) {
											case EAtom(field):
												makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);											
											default:
												e;											
										};									
									default:
										e;									
								};							
							default:
								e;							
						};
					};
					exprToInterpolate = simplifyInterpolationExpr(exprToInterpolate);
					function sanitizeForInterpolation(n:ElixirAST):ElixirAST {
						return transformNode(n, function(x:ElixirAST):ElixirAST {
							return switch (x.def) {
								case ECall(t, name, args):
									var newArgs = [];
									for (a  in  args) switch (a.def) {
										case EBlock(sts) if (sts != null && sts.length > 1):
											newArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a }])), "", [])));										
										default:
											newArgs.push(a);										
									};
									if (newArgs != args) makeAST(ECall(t, name, newArgs)) else x;								
								case ERemoteCall(mod, fname, rargs):
									var newRArgs = [];
									for (a2  in  rargs) switch (a2.def) {
										case EBlock(sts2) if (sts2 != null && sts2.length > 1):
											newRArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a2 }])), "", [])));										
										default:
											newRArgs.push(a2);										
									};
									if (newRArgs != rargs) makeAST(ERemoteCall(mod, fname, newRArgs)) else x;								
								default:
									x;								
							};
						});
					};
					function isTrivialForInterpolation(x:ElixirAST, depth:Int = 0):Bool {
						if (x == null || depth > 4) return false;
						return switch (x.def) {
							case EVar(_):
								true;							
							case EInteger(_) | EFloat(_) | EBoolean(_) | ENil | EString(_) | EAtom(_):
								true;							
							case EField(obj, _):
								isTrivialForInterpolation(obj, depth + 1);							
							default:
								false;							
						};
					};
					var sanitizedExpr = sanitizeForInterpolation(exprToInterpolate);
					var exprStr = ElixirASTPrinter.printAST(sanitizedExpr);
					var trivial = isTrivialForInterpolation(sanitizedExpr);
					var needsWrapIife = !trivial && ((exprStr.indexOf("\n") != -1) || (exprStr.indexOf(" = ") != -1 && exprStr.indexOf("==") == -1));
					var printable = needsWrapIife ? "(fn -> " + exprStr + " end).()" : exprStr;
					result += "#{" + printable + "}";
				};
			};
			result += "\"";
			return makeASTWithMeta(ERaw(result), node.metadata, node.pos);
		};	
	default:
}) {
				var ` = node.def;
				if (enumIndex ` == 26) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var l = `;
							var r = `;
							{
								var parts = [];
								var collectParts = [null];
								collectParts[0] = function(expr:reflaxe.elixir.ast.ElixirAST) {
									@:ast(switch (expr.def) {
	case EBinary(StringConcat, l, r):
		collectParts(l);
		collectParts(r);	
	case EString(s):
		parts.push({ isString : true, value : s, expr : null });	
	default:
		parts.push({ isString : false, value : null, expr : expr });	
}) {
										var ` = expr.def;
										switch (enumIndex `) {
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 25) {
													{
														var l = `;
														var r = `;
														{
															collectParts[0](l);
															collectParts[0](r);
														};
													};
												} else {
													parts.push({isString : false, value : null, expr : expr});
												};
											};
											case 32: {
												var ` = `[0];
												{
													var s = `;
													{
														parts.push({isString : true, value : s, expr : null});
													};
												};
											};
											default: {
												parts.push({isString : false, value : null, expr : expr});
											}
										};
									};
								};
								collectParts[0](node);
								var hasNonString = false;
								var hasEmptyString = false;
								{
									var ` = 0;
									while (` < parts.length) {
										var part = parts[`];
										++ `;
										if (! part.isString) {
											hasNonString = true;
										} else {
											if (part.value == "") {
												hasEmptyString = true;
											};
										};
									};
								};
								if (hasNonString && parts.length > 1) {
									var result = "\"";
									{
										var ` = 0;
										var ` = parts.length;
										while (` < `) {
											var i = ` ++;
											var part = parts[i];
											if (part.isString) {
												var escaped = part.value;
												escaped = escaped.split("\\").join("\\\\");
												escaped = escaped.split("\"").join("\\\"");
												escaped = escaped.split("#{").join("\\#{");
												result += escaped;
											} else {
												var transformedExpr = transform[0](part.expr);
												var exprToInterpolate = @:ast(switch (transformedExpr.def) {
	case ECall(target, "to_string", []) if (target != null):
		target;	
	default:
		transformedExpr;	
}) {
													var ` = transformedExpr.def;
													if (enumIndex ` == 22) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (` == "to_string") {
															if (`.length == 0) {
																{
																	var target = `;
																	if (target != null) {
																		target;
																	} else {
																		transformedExpr;
																	};
																};
															} else {
																transformedExpr;
															};
														} else {
															transformedExpr;
														};
													} else {
														transformedExpr;
													};
												};
												var simplifyInterpolationExpr = function(e:reflaxe.elixir.ast.ElixirAST) {
													return @:ast(switch (e.def) {
	case ECall(null, "inspect", [inner]):
		switch (inner.def) {
			case ERemoteCall({ def : EVar("Map") }, "get", args) if (args != null && args.length == 2):
				switch (args[1].def) {
					case EAtom(field):
						makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);					
					default:
						e;					
				};			
			default:
				e;			
		};	
	default:
		e;	
}) {
														var ` = e.def;
														if (enumIndex ` == 22) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == null) if (` == "inspect") {
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var inner = `;
																		{
																			@:ast(switch (inner.def) {
	case ERemoteCall({ def : EVar("Map") }, "get", args) if (args != null && args.length == 2):
		switch (args[1].def) {
			case EAtom(field):
				makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);			
			default:
				e;			
		};	
	default:
		e;	
}) {
																				var ` = inner.def;
																				if (enumIndex ` == 24) {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 38) {
																							var ` = `[0];
																							if (` == "Map") {
																								if (` == "get") {
																									{
																										var args = `;
																										if (args != null && args.length == 2) {
																											@:ast(switch (args[1].def) {
	case EAtom(field):
		makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);	
	default:
		e;	
}) {
																												var ` = args[1].def;
																												if (enumIndex ` == 31) {
																													var ` = `[0];
																													{
																														var field = `;
																														{
																															{def : reflaxe.elixir.ast.ElixirASTDef.EField(args[0], field), metadata : e.metadata, pos : e.pos};
																														};
																													};
																												} else {
																													e;
																												};
																											};
																										} else {
																											e;
																										};
																									};
																								} else {
																									e;
																								};
																							} else {
																								e;
																							};
																						} else {
																							e;
																						};
																					};
																				} else {
																					e;
																				};
																			};
																		};
																	};
																} else {
																	e;
																};
															} else {
																e;
															} else {
																e;
															};
														} else {
															e;
														};
													};
												};
												exprToInterpolate = simplifyInterpolationExpr(exprToInterpolate);
												var sanitizeForInterpolation = function(n:reflaxe.elixir.ast.ElixirAST) {
													return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
														return @:ast(switch (x.def) {
	case ECall(t, name, args):
		var newArgs = [];
		for (a  in  args) switch (a.def) {
			case EBlock(sts) if (sts != null && sts.length > 1):
				newArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a }])), "", [])));			
			default:
				newArgs.push(a);			
		};
		if (newArgs != args) makeAST(ECall(t, name, newArgs)) else x;	
	case ERemoteCall(mod, fname, rargs):
		var newRArgs = [];
		for (a2  in  rargs) switch (a2.def) {
			case EBlock(sts2) if (sts2 != null && sts2.length > 1):
				newRArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a2 }])), "", [])));			
			default:
				newRArgs.push(a2);			
		};
		if (newRArgs != rargs) makeAST(ERemoteCall(mod, fname, newRArgs)) else x;	
	default:
		x;	
}) {
															var ` = x.def;
															switch (enumIndex `) {
																case 22: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var t = `;
																		var name = `;
																		var args = `;
																		{
																			var newArgs = [];
																			{
																				var ` = 0;
																				while (` < args.length) {
																					var a = args[`];
																					++ `;
																					@:ast(switch (a.def) {
	case EBlock(sts) if (sts != null && sts.length > 1):
		newArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a }])), "", [])));	
	default:
		newArgs.push(a);	
}) {
																						var ` = a.def;
																						if (enumIndex ` == 53) {
																							var ` = `[0];
																							{
																								var sts = `;
																								if (sts != null && sts.length > 1) {
																									newArgs.push({
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [], guard : null, body : a}]), metadata : {}, pos : pos};
																										}, "", []), metadata : {}, pos : pos};
																									});
																								} else {
																									newArgs.push(a);
																								};
																							};
																						} else {
																							newArgs.push(a);
																						};
																					};
																				};
																			};
																			if (newArgs != args) {
																				{
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ECall(t, name, newArgs), metadata : {}, pos : pos};
																				};
																			} else {
																				x;
																			};
																		};
																	};
																};
																case 24: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var fname = `;
																		var rargs = `;
																		{
																			var newRArgs = [];
																			{
																				var ` = 0;
																				while (` < rargs.length) {
																					var a2 = rargs[`];
																					++ `;
																					@:ast(switch (a2.def) {
	case EBlock(sts2) if (sts2 != null && sts2.length > 1):
		newRArgs.push(makeAST(ECall(makeAST(EFn([{ args : [], guard : null, body : a2 }])), "", [])));	
	default:
		newRArgs.push(a2);	
}) {
																						var ` = a2.def;
																						if (enumIndex ` == 53) {
																							var ` = `[0];
																							{
																								var sts2 = `;
																								if (sts2 != null && sts2.length > 1) {
																									newRArgs.push({
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.ECall({
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [], guard : null, body : a2}]), metadata : {}, pos : pos};
																										}, "", []), metadata : {}, pos : pos};
																									});
																								} else {
																									newRArgs.push(a2);
																								};
																							};
																						} else {
																							newRArgs.push(a2);
																						};
																					};
																				};
																			};
																			if (newRArgs != rargs) {
																				{
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, fname, newRArgs), metadata : {}, pos : pos};
																				};
																			} else {
																				x;
																			};
																		};
																	};
																};
																default: {
																	x;
																}
															};
														};
													});
												};
												var isTrivialForInterpolation = [null];
												isTrivialForInterpolation[0] = function(x:reflaxe.elixir.ast.ElixirAST, depth:Int = 0) {
													if (x == null || depth > 4) {
														return false;
													};
													return @:ast(switch (x.def) {
	case EVar(_):
		true;	
	case EInteger(_) | EFloat(_) | EBoolean(_) | ENil | EString(_) | EAtom(_):
		true;	
	case EField(obj, _):
		isTrivialForInterpolation(obj, depth + 1);	
	default:
		false;	
}) {
														var ` = x.def;
														switch (enumIndex `) {
															case 28: {
																var ` = `[0];
																var ` = `[1];
																{
																	var obj = `;
																	{
																		isTrivialForInterpolation[0](obj, depth + 1);
																	};
																};
															};
															case 31: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 32: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 33: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 34: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 35: {
																var ` = `[0];
																{
																	true;
																};
															};
															case 36: {
																{
																	true;
																};
															};
															case 38: {
																var ` = `[0];
																{
																	true;
																};
															};
															default: {
																false;
															}
														};
													};
												};
												var sanitizedExpr = sanitizeForInterpolation(exprToInterpolate);
												var exprStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(sanitizedExpr, null);
												var trivial = isTrivialForInterpolation[0](sanitizedExpr, null);
												var needsWrapIife = ! trivial && ((exprStr.indexOf("\n", null) != -1) || (exprStr.indexOf(" = ", null) != -1 && exprStr.indexOf("==", null) == -1));
												var printable = if (needsWrapIife) {
													"(fn -> " + exprStr + " end).()";
												} else {
													exprStr;
												};
												result += "#{" + printable + "}";
											};
										};
									};
									result += "\"";
									return {def : reflaxe.elixir.ast.ElixirASTDef.ERaw(result), metadata : node.metadata, pos : node.pos};
								};
							};
						};
					} else {};
				} else {};
			};
			return @:ast(switch (node.def) {
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(transform)), node.metadata, node.pos);	
	case EDefmodule(name, doBlock):
		makeASTWithMeta(EDefmodule(name, transform(doBlock)), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, transform(body)), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, transform(body)), node.metadata, node.pos);	
	case EBlock(expressions):
		makeASTWithMeta(EBlock(expressions.map(transform)), node.metadata, node.pos);	
	case EBinary(op, left, right) if (op != StringConcat):
		makeASTWithMeta(EBinary(op, transform(left), transform(right)), node.metadata, node.pos);	
	case ECall(target, method, args):
		makeASTWithMeta(ECall(target != null ? transform(target) : null, method, args.map(transform)), node.metadata, node.pos);	
	case ERemoteCall(module, func, args):
		makeASTWithMeta(ERemoteCall(transform(module), func, args.map(transform)), node.metadata, node.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transform(expr)), node.metadata, node.pos);	
	case EIf(condition, then_expr, else_expr):
		makeASTWithMeta(EIf(transform(condition), transform(then_expr), else_expr != null ? transform(else_expr) : null), node.metadata, node.pos);	
	case EList(items):
		makeASTWithMeta(EList(items.map(transform)), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transform(expr), clauses.map(function(clause) ->  @:implicitReturn return {
			var transformedBody = transform(clause.body);
			{ pattern : clause.pattern, guard : clause.guard != null ? transform(clause.guard) : null, body : transformedBody };
		})), node.metadata, node.pos);	
	case EParen(expr):
		makeASTWithMeta(EParen(transform(expr)), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
										var f = transform[0];
										{
											var ` = [];
											{
												var ` = 0;
												var ` = body;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transform[0](doBlock));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transform[0](body));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transform[0](body));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transform[0](expr), {
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({
													var transformedBody = transform[0](v.body);
													{pattern : v.pattern, guard : if ((v.guard != null)) transform[0](v.guard) else null, body : transformedBody};
												});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transform[0](expr));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var then_expr = `;
							var else_expr = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transform[0](condition), transform[0](then_expr), if ((else_expr != null)) transform[0](else_expr) else null);
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var items = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EList({
										var f = transform[0];
										{
											var ` = [];
											{
												var ` = 0;
												var ` = items;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var method = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transform[0](target) else null, method, {
										var f = transform[0];
										{
											var ` = [];
											{
												var ` = 0;
												var ` = args;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var func = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(transform[0](module), func, {
										var f = transform[0];
										{
											var ` = [];
											{
												var ` = 0;
												var ` = args;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							if (op != reflaxe.elixir.ast.EBinaryOp.StringConcat) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transform[0](left), transform[0](right));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							} else {
								node;
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var expressions = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
										var f = transform[0];
										{
											var ` = [];
											{
												var ` = 0;
												var ` = expressions;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													`.push(f(v));
												};
											};
											`;
										};
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var expr = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EParen(transform[0](expr));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		};
		return transform[0](ast);
	}

	static function loopTransformationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall(module, funcName, args):
		switch (module.def) {
			case EVar("Enum"):
				if (funcName == "reduce_while" && args != null && args.length >= 3) {
					var streamArg = args[0];
					switch (streamArg.def) {
						case ERemoteCall(streamModule, streamFunc, streamArgs):
							switch (streamModule.def) {
								case EVar("Stream"):
									if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
										var initValue = streamArgs[0];
										var incrementFunc = streamArgs[1];
										var isSimpleCounter = false;
										switch (initValue.def) {
											case EInteger(0):
												switch (incrementFunc.def) {
													case EFn(clauses) if (clauses.length > 0):
														var clause = clauses[0];
														if (clause.args.length == 1) {
															switch (clause.body.def) {
																case EBinary(Add, left, right):
																	switch (left.def) {
																		case EVar(varName):
																			var paramName = switch (clause.args[0]) {
																				case PVar(name):
																					name;																				
																				default:
																					null;																				
																			};
																			if (paramName != null && varName == paramName) {
																				switch (right.def) {
																					case EInteger(1):
																						isSimpleCounter = true;																					
																					default:
																				};
																			};																		
																		default:
																	};																
																default:
															};
														};													
													default:
												};											
											default:
										};
										if (isSimpleCounter) {
											var loopFunc = args[2];
											switch (loopFunc.def) {
												case EFn(clauses) if (clauses.length > 0):
													var clause = clauses[0];
													var loopInfo = analyzeLoopBody(clause.body);
													if (loopInfo != null) {
														if (loopInfo.hasSideEffectsOnly) {
															var range = makeAST(ERange(makeAST(EInteger(0), node.pos), makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos), false), node.pos);
															var eachFunc = makeAST(EFn([{ args : [PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody }]), node.pos);
															return makeAST(ERemoteCall(makeAST(EVar("Enum"), node.pos), "each", [range, eachFunc]), node.pos);
														};
													};												
												default:
											};
										};
									};								
								default:
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							@:ast(switch (module.def) {
	case EVar("Enum"):
		if (funcName == "reduce_while" && args != null && args.length >= 3) {
			var streamArg = args[0];
			switch (streamArg.def) {
				case ERemoteCall(streamModule, streamFunc, streamArgs):
					switch (streamModule.def) {
						case EVar("Stream"):
							if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
								var initValue = streamArgs[0];
								var incrementFunc = streamArgs[1];
								var isSimpleCounter = false;
								switch (initValue.def) {
									case EInteger(0):
										switch (incrementFunc.def) {
											case EFn(clauses) if (clauses.length > 0):
												var clause = clauses[0];
												if (clause.args.length == 1) {
													switch (clause.body.def) {
														case EBinary(Add, left, right):
															switch (left.def) {
																case EVar(varName):
																	var paramName = switch (clause.args[0]) {
																		case PVar(name):
																			name;																		
																		default:
																			null;																		
																	};
																	if (paramName != null && varName == paramName) {
																		switch (right.def) {
																			case EInteger(1):
																				isSimpleCounter = true;																			
																			default:
																		};
																	};																
																default:
															};														
														default:
													};
												};											
											default:
										};									
									default:
								};
								if (isSimpleCounter) {
									var loopFunc = args[2];
									switch (loopFunc.def) {
										case EFn(clauses) if (clauses.length > 0):
											var clause = clauses[0];
											var loopInfo = analyzeLoopBody(clause.body);
											if (loopInfo != null) {
												if (loopInfo.hasSideEffectsOnly) {
													var range = makeAST(ERange(makeAST(EInteger(0), node.pos), makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos), false), node.pos);
													var eachFunc = makeAST(EFn([{ args : [PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody }]), node.pos);
													return makeAST(ERemoteCall(makeAST(EVar("Enum"), node.pos), "each", [range, eachFunc]), node.pos);
												};
											};										
										default:
									};
								};
							};						
						default:
					};				
				default:
			};
		};	
	default:
}) {
								var ` = module.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									if (` == "Enum") {
										{
											if (funcName == "reduce_while" && args != null && args.length >= 3) {
												var streamArg = args[0];
												@:ast(switch (streamArg.def) {
	case ERemoteCall(streamModule, streamFunc, streamArgs):
		switch (streamModule.def) {
			case EVar("Stream"):
				if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
					var initValue = streamArgs[0];
					var incrementFunc = streamArgs[1];
					var isSimpleCounter = false;
					switch (initValue.def) {
						case EInteger(0):
							switch (incrementFunc.def) {
								case EFn(clauses) if (clauses.length > 0):
									var clause = clauses[0];
									if (clause.args.length == 1) {
										switch (clause.body.def) {
											case EBinary(Add, left, right):
												switch (left.def) {
													case EVar(varName):
														var paramName = switch (clause.args[0]) {
															case PVar(name):
																name;															
															default:
																null;															
														};
														if (paramName != null && varName == paramName) {
															switch (right.def) {
																case EInteger(1):
																	isSimpleCounter = true;																
																default:
															};
														};													
													default:
												};											
											default:
										};
									};								
								default:
							};						
						default:
					};
					if (isSimpleCounter) {
						var loopFunc = args[2];
						switch (loopFunc.def) {
							case EFn(clauses) if (clauses.length > 0):
								var clause = clauses[0];
								var loopInfo = analyzeLoopBody(clause.body);
								if (loopInfo != null) {
									if (loopInfo.hasSideEffectsOnly) {
										var range = makeAST(ERange(makeAST(EInteger(0), node.pos), makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos), false), node.pos);
										var eachFunc = makeAST(EFn([{ args : [PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody }]), node.pos);
										return makeAST(ERemoteCall(makeAST(EVar("Enum"), node.pos), "each", [range, eachFunc]), node.pos);
									};
								};							
							default:
						};
					};
				};			
			default:
		};	
	default:
}) {
													var ` = streamArg.def;
													if (enumIndex ` == 24) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var streamModule = `;
															var streamFunc = `;
															var streamArgs = `;
															{
																@:ast(switch (streamModule.def) {
	case EVar("Stream"):
		if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
			var initValue = streamArgs[0];
			var incrementFunc = streamArgs[1];
			var isSimpleCounter = false;
			switch (initValue.def) {
				case EInteger(0):
					switch (incrementFunc.def) {
						case EFn(clauses) if (clauses.length > 0):
							var clause = clauses[0];
							if (clause.args.length == 1) {
								switch (clause.body.def) {
									case EBinary(Add, left, right):
										switch (left.def) {
											case EVar(varName):
												var paramName = switch (clause.args[0]) {
													case PVar(name):
														name;													
													default:
														null;													
												};
												if (paramName != null && varName == paramName) {
													switch (right.def) {
														case EInteger(1):
															isSimpleCounter = true;														
														default:
													};
												};											
											default:
										};									
									default:
								};
							};						
						default:
					};				
				default:
			};
			if (isSimpleCounter) {
				var loopFunc = args[2];
				switch (loopFunc.def) {
					case EFn(clauses) if (clauses.length > 0):
						var clause = clauses[0];
						var loopInfo = analyzeLoopBody(clause.body);
						if (loopInfo != null) {
							if (loopInfo.hasSideEffectsOnly) {
								var range = makeAST(ERange(makeAST(EInteger(0), node.pos), makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos), false), node.pos);
								var eachFunc = makeAST(EFn([{ args : [PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody }]), node.pos);
								return makeAST(ERemoteCall(makeAST(EVar("Enum"), node.pos), "each", [range, eachFunc]), node.pos);
							};
						};					
					default:
				};
			};
		};	
	default:
}) {
																	var ` = streamModule.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		if (` == "Stream") {
																			{
																				if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
																					var initValue = streamArgs[0];
																					var incrementFunc = streamArgs[1];
																					var isSimpleCounter = false;
																					@:ast(switch (initValue.def) {
	case EInteger(0):
		switch (incrementFunc.def) {
			case EFn(clauses) if (clauses.length > 0):
				var clause = clauses[0];
				if (clause.args.length == 1) {
					switch (clause.body.def) {
						case EBinary(Add, left, right):
							switch (left.def) {
								case EVar(varName):
									var paramName = switch (clause.args[0]) {
										case PVar(name):
											name;										
										default:
											null;										
									};
									if (paramName != null && varName == paramName) {
										switch (right.def) {
											case EInteger(1):
												isSimpleCounter = true;											
											default:
										};
									};								
								default:
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
																						var ` = initValue.def;
																						if (enumIndex ` == 33) {
																							var ` = `[0];
																							if (` == 0) {
																								{
																									@:ast(switch (incrementFunc.def) {
	case EFn(clauses) if (clauses.length > 0):
		var clause = clauses[0];
		if (clause.args.length == 1) {
			switch (clause.body.def) {
				case EBinary(Add, left, right):
					switch (left.def) {
						case EVar(varName):
							var paramName = switch (clause.args[0]) {
								case PVar(name):
									name;								
								default:
									null;								
							};
							if (paramName != null && varName == paramName) {
								switch (right.def) {
									case EInteger(1):
										isSimpleCounter = true;									
									default:
								};
							};						
						default:
					};				
				default:
			};
		};	
	default:
}) {
																										var ` = incrementFunc.def;
																										if (enumIndex ` == 42) {
																											var ` = `[0];
																											{
																												var clauses = `;
																												if (clauses.length > 0) {
																													var clause = clauses[0];
																													if (clause.args.length == 1) {
																														@:ast(switch (clause.body.def) {
	case EBinary(Add, left, right):
		switch (left.def) {
			case EVar(varName):
				var paramName = switch (clause.args[0]) {
					case PVar(name):
						name;					
					default:
						null;					
				};
				if (paramName != null && varName == paramName) {
					switch (right.def) {
						case EInteger(1):
							isSimpleCounter = true;						
						default:
					};
				};			
			default:
		};	
	default:
}) {
																															var ` = clause.body.def;
																															if (enumIndex ` == 26) {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (enumIndex ` == 0) {
																																	{
																																		var left = `;
																																		var right = `;
																																		{
																																			@:ast(switch (left.def) {
	case EVar(varName):
		var paramName = switch (clause.args[0]) {
			case PVar(name):
				name;			
			default:
				null;			
		};
		if (paramName != null && varName == paramName) {
			switch (right.def) {
				case EInteger(1):
					isSimpleCounter = true;				
				default:
			};
		};	
	default:
}) {
																																				var ` = left.def;
																																				if (enumIndex ` == 38) {
																																					var ` = `[0];
																																					{
																																						var varName = `;
																																						{
																																							var paramName = @:ast(switch (clause.args[0]) {
	case PVar(name):
		name;	
	default:
		null;	
}) {
																																								var ` = clause.args[0];
																																								if (enumIndex ` == 0) {
																																									var ` = `[0];
																																									{
																																										var name = `;
																																										{
																																											name;
																																										};
																																									};
																																								} else {
																																									null;
																																								};
																																							};
																																							if (paramName != null && varName == paramName) {
																																								@:ast(switch (right.def) {
	case EInteger(1):
		isSimpleCounter = true;	
	default:
}) {
																																									var ` = right.def;
																																									if (enumIndex ` == 33) {
																																										var ` = `[0];
																																										if (` == 1) {
																																											{
																																												isSimpleCounter = true;
																																											};
																																										} else {};
																																									} else {};
																																								};
																																							};
																																						};
																																					};
																																				} else {};
																																			};
																																		};
																																	};
																																} else {};
																															} else {};
																														};
																													};
																												} else {};
																											};
																										} else {};
																									};
																								};
																							} else {};
																						} else {};
																					};
																					if (isSimpleCounter) {
																						var loopFunc = args[2];
																						@:ast(switch (loopFunc.def) {
	case EFn(clauses) if (clauses.length > 0):
		var clause = clauses[0];
		var loopInfo = analyzeLoopBody(clause.body);
		if (loopInfo != null) {
			if (loopInfo.hasSideEffectsOnly) {
				var range = makeAST(ERange(makeAST(EInteger(0), node.pos), makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos), false), node.pos);
				var eachFunc = makeAST(EFn([{ args : [PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody }]), node.pos);
				return makeAST(ERemoteCall(makeAST(EVar("Enum"), node.pos), "each", [range, eachFunc]), node.pos);
			};
		};	
	default:
}) {
																							var ` = loopFunc.def;
																							if (enumIndex ` == 42) {
																								var ` = `[0];
																								{
																									var clauses = `;
																									if (clauses.length > 0) {
																										var clause = clauses[0];
																										var loopInfo = reflaxe.elixir.ast.ElixirASTTransformer.analyzeLoopBody(clause.body);
																										if (loopInfo != null) {
																											if (loopInfo.hasSideEffectsOnly) {
																												var range = {def : reflaxe.elixir.ast.ElixirASTDef.ERange({def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : node.pos}, {def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, loopInfo.upperBound, {def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : node.pos}), metadata : {}, pos : node.pos}, false), metadata : {}, pos : node.pos};
																												var eachFunc = {def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(loopInfo.iteratorVar)], guard : null, body : loopInfo.loopBody}]), metadata : {}, pos : node.pos};
																												return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : node.pos}, "each", [range, eachFunc]), metadata : {}, pos : node.pos};
																											};
																										};
																									} else {};
																								};
																							} else {};
																						};
																					};
																				};
																			};
																		} else {};
																	} else {};
																};
															};
														};
													} else {};
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				} else {};
			};
			return node;
		});
	}

	static function analyzeLoopBody(body:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (body.def) {
	case EIf(condition, thenBranch, elseBranch):
		var upperBound:ElixirAST = null;
		var iteratorVar:String = null;
		switch (condition.def) {
			case EBinary(Less, left, right):
				switch (left.def) {
					case EVar(varName):
						iteratorVar = varName;
						upperBound = right;					
					default:
				};			
			default:
		};
		if (upperBound != null && iteratorVar != null) {
			var loopBody:ElixirAST = null;
			var hasSideEffectsOnly = true;
			switch (thenBranch.def) {
				case EBlock(exprs):
					var bodyExprs = [];
					for (expr  in  exprs) {
						switch (expr.def) {
							case ETuple([contAtom, _]):
								switch (contAtom.def) {
									case EAtom(cont) if (cont == "cont"):
									default:
										bodyExprs.push(expr);									
								};							
							case EBinary(Add, _, _):
							case EInteger(_):
							default:
								bodyExprs.push(expr);							
						};
					};
					if (bodyExprs.length == 1) {
						loopBody = bodyExprs[0];
					} else if (bodyExprs.length > 1) {
						loopBody = makeAST(EBlock(bodyExprs), body.pos);
					};				
				default:
			};
			if (loopBody != null) {
				return { upperBound : upperBound, iteratorVar : iteratorVar, loopBody : loopBody, hasSideEffectsOnly : hasSideEffectsOnly };
			};
		};	
	default:
}) {
			var ` = body.def;
			if (enumIndex ` == 10) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var condition = `;
					var thenBranch = `;
					var elseBranch = `;
					{
						var upperBound = null;
						var iteratorVar = null;
						@:ast(switch (condition.def) {
	case EBinary(Less, left, right):
		switch (left.def) {
			case EVar(varName):
				iteratorVar = varName;
				upperBound = right;			
			default:
		};	
	default:
}) {
							var ` = condition.def;
							if (enumIndex ` == 26) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								if (enumIndex ` == 10) {
									{
										var left = `;
										var right = `;
										{
											@:ast(switch (left.def) {
	case EVar(varName):
		iteratorVar = varName;
		upperBound = right;	
	default:
}) {
												var ` = left.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var varName = `;
														{
															iteratorVar = varName;
															upperBound = right;
														};
													};
												} else {};
											};
										};
									};
								} else {};
							} else {};
						};
						if (upperBound != null && iteratorVar != null) {
							var loopBody = null;
							var hasSideEffectsOnly = true;
							@:ast(switch (thenBranch.def) {
	case EBlock(exprs):
		var bodyExprs = [];
		for (expr  in  exprs) {
			switch (expr.def) {
				case ETuple([contAtom, _]):
					switch (contAtom.def) {
						case EAtom(cont) if (cont == "cont"):
						default:
							bodyExprs.push(expr);						
					};				
				case EBinary(Add, _, _):
				case EInteger(_):
				default:
					bodyExprs.push(expr);				
			};
		};
		if (bodyExprs.length == 1) {
			loopBody = bodyExprs[0];
		} else if (bodyExprs.length > 1) {
			loopBody = makeAST(EBlock(bodyExprs), body.pos);
		};	
	default:
}) {
								var ` = thenBranch.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var exprs = `;
										{
											var bodyExprs = [];
											{
												var ` = 0;
												while (` < exprs.length) {
													var expr = exprs[`];
													++ `;
													@:ast(switch (expr.def) {
	case ETuple([contAtom, _]):
		switch (contAtom.def) {
			case EAtom(cont) if (cont == "cont"):
			default:
				bodyExprs.push(expr);			
		};	
	case EBinary(Add, _, _):
	case EInteger(_):
	default:
		bodyExprs.push(expr);	
}) {
														var ` = expr.def;
														switch (enumIndex `) {
															case 16: {
																var ` = `[0];
																if (`.length == 2) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var contAtom = `;
																		{
																			@:ast(switch (contAtom.def) {
	case EAtom(cont) if (cont == "cont"):
	default:
		bodyExprs.push(expr);	
}) {
																				var ` = contAtom.def;
																				if (enumIndex ` == 31) {
																					var ` = `[0];
																					{
																						var cont = `;
																						if (cont == "cont") {} else {
																							bodyExprs.push(expr);
																						};
																					};
																				} else {
																					bodyExprs.push(expr);
																				};
																			};
																		};
																	};
																} else {
																	bodyExprs.push(expr);
																};
															};
															case 26: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (enumIndex ` == 0) {
																	{};
																} else {
																	bodyExprs.push(expr);
																};
															};
															case 33: {
																var ` = `[0];
																{};
															};
															default: {
																bodyExprs.push(expr);
															}
														};
													};
												};
											};
											if (bodyExprs.length == 1) {
												loopBody = bodyExprs[0];
											} else {
												if (bodyExprs.length > 1) {
													loopBody = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(bodyExprs), metadata : {}, pos : body.pos};
												};
											};
										};
									};
								} else {};
							};
							if (loopBody != null) {
								return {upperBound : upperBound, iteratorVar : iteratorVar, loopBody : loopBody, hasSideEffectsOnly : hasSideEffectsOnly};
							};
						};
					};
				};
			} else {};
		};
		return null;
	}

	static function pipelineOptimizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(expressions):
		var optimized = detectAndOptimizePipeline(expressions);
		if (optimized != null) {
			optimized;
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var optimized = reflaxe.elixir.ast.ElixirASTTransformer.detectAndOptimizePipeline(expressions);
							if (optimized != null) {
								optimized;
							} else {
								node;
							};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function mapIteratorTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.mapIteratorTransformPass(ast);
	}

	static function comprehensionConversionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var generatedFunctions = [];
		var loopCounter = [0];
		var transformLoops = [null];
		transformLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EFor(generators, filters, body, into, uniq):
		node;	
	case ECall(null, "while_loop", [condition, body]):
		var funcName = "loop_" + (loopCounter++);
		var transformedCondition = transformNode(condition, transformLoops);
		var transformedBody = transformNode(body, transformLoops);
		var recursiveFunc = makeAST(EDefp(funcName, [], null, makeAST(EIf(transformedCondition, makeAST(EBlock([transformedBody, makeAST(ECall(null, funcName, []))])), makeAST(EAtom(ElixirAtom.ok()))))));
		generatedFunctions.push(recursiveFunc);
		makeAST(ECall(null, funcName, []));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) if (` == "while_loop") {
							if (`.length == 2) {
								var ` = `[0];
								var ` = `[1];
								{
									var condition = `;
									var body = `;
									{
										var funcName = "loop_" + (loopCounter[0] ++);
										var transformedCondition = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(condition, transformLoops[0]);
										var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformLoops[0]);
										var recursiveFunc = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(funcName, [], null, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EIf(transformedCondition, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([transformedBody, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, funcName, []), metadata : {}, pos : pos};
													}]), metadata : {}, pos : pos};
												}, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "ok"), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											}), metadata : {}, pos : pos};
										};
										generatedFunctions.push(recursiveFunc);
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, funcName, []), metadata : {}, pos : pos};
										};
									};
								};
							} else {
								node;
							};
						} else {
							node;
						} else {
							node;
						};
					};
					case 41: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						var ` = `[4];
						{
							var generators = `;
							var filters = `;
							var body = `;
							var into = `;
							var uniq = `;
							{
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		};
		var transformed = transformLoops[0](ast);
		if (generatedFunctions.length > 0) {
			@:ast(switch (transformed.def) {
	case EModule(name, attributes, body):
		var newBody = body.concat(generatedFunctions);
		return makeAST(EModule(name, attributes, newBody));	
	default:
		return transformed;	
}) {
				var ` = transformed.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							var newBody = body.concat(generatedFunctions);
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, newBody), metadata : {}, pos : pos};
							};
						};
					};
				} else {
					return transformed;
				};
			};
		};
		return transformed;
	}

	static function abstractMethodThisPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EFn(clauses):
		var fixedClauses = [];
		var hasChanges = false;
		for (clause  in  clauses) {
			if (clause.args.length > 0) {
				switch (clause.args[0]) {
					case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
						var fixedBody = replaceStructWithParam(clause.body, paramName);
						hasChanges = true;
						fixedClauses.push({ args : clause.args, guard : clause.guard, body : fixedBody });					
					default:
						fixedClauses.push(clause);					
				};
			} else {
				fixedClauses.push(clause);
			};
		};
		if (hasChanges) {
			return makeASTWithMeta(EFn(fixedClauses), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var fixedClauses = [];
							var hasChanges = false;
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause.args.length > 0) {
										@:ast(switch (clause.args[0]) {
	case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
		var fixedBody = replaceStructWithParam(clause.body, paramName);
		hasChanges = true;
		fixedClauses.push({ args : clause.args, guard : clause.guard, body : fixedBody });	
	default:
		fixedClauses.push(clause);	
}) {
											var ` = clause.args[0];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var paramName = `;
													if (paramName.indexOf("this", null) == 0 || paramName == "_struct" || paramName == "struct") {
														var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.replaceStructWithParam(clause.body, paramName);
														hasChanges = true;
														fixedClauses.push({args : clause.args, guard : clause.guard, body : fixedBody});
													} else {
														fixedClauses.push(clause);
													};
												};
											} else {
												fixedClauses.push(clause);
											};
										};
									} else {
										fixedClauses.push(clause);
									};
								};
							};
							if (hasChanges) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(fixedClauses), metadata : node.metadata, pos : node.pos};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function replaceStructWithParam(ast:reflaxe.elixir.ast.ElixirAST, paramName:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EVar("struct") | EVar("this"):
		return makeASTWithMeta(EVar(paramName), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					switch (`) {
						case "struct", "this": {
							{
								return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(paramName), metadata : node.metadata, pos : node.pos};
							};
						};
						default: {
							return node;
						}
					};
				} else {
					return node;
				};
			};
		});
	}

	static function bitwiseImportPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var needsBitwise = [false];
		var checkForBitwise = [null];
		checkForBitwise[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EBinary(op, left, right):
		switch (op) {
			case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
				needsBitwise = true;			
			default:
		};
		checkForBitwise(left);
		checkForBitwise(right);	
	case EUnary(BitwiseNot, expr):
		needsBitwise = true;
		checkForBitwise(expr);	
	default:
		iterateAST(node, checkForBitwise);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								@:ast(switch (op) {
	case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
		needsBitwise = true;	
	default:
}) switch (enumIndex op) {
									case 18, 19, 20, 21, 22: {
										{
											needsBitwise[0] = true;
										};
									};
									default: {}
								};
								checkForBitwise[0](left);
								checkForBitwise[0](right);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 3) {
							{
								var expr = `;
								{
									needsBitwise[0] = true;
									checkForBitwise[0](expr);
								};
							};
						} else {
							reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForBitwise[0]);
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, checkForBitwise[0]);
					}
				};
			};
		};
		checkForBitwise[0](ast);
		if (! needsBitwise[0]) {
			return ast;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		switch (doBlock.def) {
			case EBlock(statements):
				var hasImport = false;
				for (stmt  in  statements) {
					switch (stmt.def) {
						case EImport(module, _, _):
							if (module == "Bitwise") {
								hasImport = true;
								break;
							};						
						default:
					};
				};
				if (!hasImport) {
					var newStatements = statements.copy();
					newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));
					return makeASTWithMeta(EDefmodule(name, makeAST(EBlock(newStatements))), node.metadata, node.pos);
				};			
			default:
		};
		return node;	
	case EModule(name, attributes, body):
		var hasImport = false;
		for (attr  in  attributes) {
			if (attr.name == "import" && attr.value != null) {
				switch (attr.value.def) {
					case EAtom(atomVal) if (atomVal == "Bitwise"):
						hasImport = true;					
					case EVar("Bitwise"):
						hasImport = true;					
					default:
				};
			};
		};
		if (!hasImport) {
			var newAttributes = attributes.copy();
			newAttributes.insert(0, { name : "import", value : makeAST(EAtom(ElixirAtom.raw("Bitwise"))) });
			return makeASTWithMeta(EModule(name, newAttributes, body), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								var hasImport = false;
								{
									var ` = 0;
									while (` < attributes.length) {
										var attr = attributes[`];
										++ `;
										if (attr.name == "import" && attr.value != null) {
											@:ast(switch (attr.value.def) {
	case EAtom(atomVal) if (atomVal == "Bitwise"):
		hasImport = true;	
	case EVar("Bitwise"):
		hasImport = true;	
	default:
}) {
												var ` = attr.value.def;
												switch (enumIndex `) {
													case 31: {
														var ` = `[0];
														{
															var atomVal = `;
															if (atomVal == "Bitwise") {
																hasImport = true;
															} else {};
														};
													};
													case 38: {
														var ` = `[0];
														if (` == "Bitwise") {
															{
																hasImport = true;
															};
														} else {};
													};
													default: {}
												};
											};
										};
									};
								};
								if (! hasImport) {
									var newAttributes = attributes.copy();
									newAttributes.insert(0, {name : "import", value : {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Bitwise"), metadata : {}, pos : pos};
									}});
									return {def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, newAttributes, body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								@:ast(switch (doBlock.def) {
	case EBlock(statements):
		var hasImport = false;
		for (stmt  in  statements) {
			switch (stmt.def) {
				case EImport(module, _, _):
					if (module == "Bitwise") {
						hasImport = true;
						break;
					};				
				default:
			};
		};
		if (!hasImport) {
			var newStatements = statements.copy();
			newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));
			return makeASTWithMeta(EDefmodule(name, makeAST(EBlock(newStatements))), node.metadata, node.pos);
		};	
	default:
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var statements = `;
											{
												var hasImport = false;
												{
													var ` = 0;
													while (` < statements.length) {
														var stmt = statements[`];
														++ `;
														@:ast(switch (stmt.def) {
	case EImport(module, _, _):
		if (module == "Bitwise") {
			hasImport = true;
			break;
		};	
	default:
}) {
															var ` = stmt.def;
															if (enumIndex ` == 45) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var module = `;
																	{
																		if (module == "Bitwise") {
																			hasImport = true;
																			break;
																		};
																	};
																};
															} else {};
														};
													};
												};
												if (! hasImport) {
													var newStatements = statements.copy();
													newStatements.insert(0, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EImport("Bitwise", null, null), metadata : {}, pos : pos};
													});
													return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStatements), metadata : {}, pos : pos};
													}), metadata : node.metadata, pos : node.pos};
												};
											};
										};
									} else {};
								};
								return node;
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function listEffectLiftingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EList(elements):
		var hasEffects = false;
		var liftedStatements:Array<ElixirAST> = [];
		var pureElements:Array<ElixirAST> = [];
		for (i  in  0 ... elements.length) {
			var elem = elements[i];
			switch (elem.def) {
				case EMatch(left, right):
					hasEffects = true;
					liftedStatements.push(elem);
					switch (left) {
						case PVar(name):
							pureElements.push(makeAST(EVar(name)));						
						default:
							pureElements.push(makeAST(EVar("_lifted_var")));						
					};				
				case EBlock(exprs) if (exprs.length > 0):
					hasEffects = true;
					for (j  in  0 ... exprs.length - 1) {
						liftedStatements.push(exprs[j]);
					};
					pureElements.push(exprs[exprs.length - 1]);				
				case EBinary(Concat, left, right):
					switch (right.def) {
						case EList(innerElements) if (innerElements.length > 0):
							var innerHasEffects = false;
							for (innerElem  in  innerElements) {
								switch (innerElem.def) {
									case EMatch(_, _) | EBlock(_):
										innerHasEffects = true;
										break;									
									default:
								};
							};
							if (innerHasEffects) {
								var processedInner = listEffectLiftingPass(makeAST(right.def));
								switch (processedInner.def) {
									case EBlock(stmts) if (stmts.length > 0):
										hasEffects = true;
										for (k  in  0 ... stmts.length - 1) {
											liftedStatements.push(stmts[k]);
										};
										pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));									
									default:
										pureElements.push(elem);									
								};
							} else {
								pureElements.push(elem);
							};						
						default:
							pureElements.push(elem);						
					};				
				default:
					pureElements.push(elem);				
			};
		};
		if (hasEffects) {
			var allStatements = liftedStatements.copy();
			allStatements.push(makeAST(EList(pureElements)));
			return makeAST(EBlock(allStatements));
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 15) {
					var ` = `[0];
					{
						var elements = `;
						{
							var hasEffects = false;
							var liftedStatements = [];
							var pureElements = [];
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									var elem = elements[i];
									@:ast(switch (elem.def) {
	case EMatch(left, right):
		hasEffects = true;
		liftedStatements.push(elem);
		switch (left) {
			case PVar(name):
				pureElements.push(makeAST(EVar(name)));			
			default:
				pureElements.push(makeAST(EVar("_lifted_var")));			
		};	
	case EBlock(exprs) if (exprs.length > 0):
		hasEffects = true;
		for (j  in  0 ... exprs.length - 1) {
			liftedStatements.push(exprs[j]);
		};
		pureElements.push(exprs[exprs.length - 1]);	
	case EBinary(Concat, left, right):
		switch (right.def) {
			case EList(innerElements) if (innerElements.length > 0):
				var innerHasEffects = false;
				for (innerElem  in  innerElements) {
					switch (innerElem.def) {
						case EMatch(_, _) | EBlock(_):
							innerHasEffects = true;
							break;						
						default:
					};
				};
				if (innerHasEffects) {
					var processedInner = listEffectLiftingPass(makeAST(right.def));
					switch (processedInner.def) {
						case EBlock(stmts) if (stmts.length > 0):
							hasEffects = true;
							for (k  in  0 ... stmts.length - 1) {
								liftedStatements.push(stmts[k]);
							};
							pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));						
						default:
							pureElements.push(elem);						
					};
				} else {
					pureElements.push(elem);
				};			
			default:
				pureElements.push(elem);			
		};	
	default:
		pureElements.push(elem);	
}) {
										var ` = elem.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var left = `;
													var right = `;
													{
														hasEffects = true;
														liftedStatements.push(elem);
														@:ast(switch (left) {
	case PVar(name):
		pureElements.push(makeAST(EVar(name)));	
	default:
		pureElements.push(makeAST(EVar("_lifted_var")));	
}) if (enumIndex left == 0) {
															var ` = left[0];
															{
																var name = `;
																{
																	pureElements.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
																	});
																};
															};
														} else {
															pureElements.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("_lifted_var"), metadata : {}, pos : pos};
															});
														};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 23) {
													{
														var left = `;
														var right = `;
														{
															@:ast(switch (right.def) {
	case EList(innerElements) if (innerElements.length > 0):
		var innerHasEffects = false;
		for (innerElem  in  innerElements) {
			switch (innerElem.def) {
				case EMatch(_, _) | EBlock(_):
					innerHasEffects = true;
					break;				
				default:
			};
		};
		if (innerHasEffects) {
			var processedInner = listEffectLiftingPass(makeAST(right.def));
			switch (processedInner.def) {
				case EBlock(stmts) if (stmts.length > 0):
					hasEffects = true;
					for (k  in  0 ... stmts.length - 1) {
						liftedStatements.push(stmts[k]);
					};
					pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));				
				default:
					pureElements.push(elem);				
			};
		} else {
			pureElements.push(elem);
		};	
	default:
		pureElements.push(elem);	
}) {
																var ` = right.def;
																if (enumIndex ` == 15) {
																	var ` = `[0];
																	{
																		var innerElements = `;
																		if (innerElements.length > 0) {
																			var innerHasEffects = false;
																			{
																				var ` = 0;
																				while (` < innerElements.length) {
																					var innerElem = innerElements[`];
																					++ `;
																					@:ast(switch (innerElem.def) {
	case EMatch(_, _) | EBlock(_):
		innerHasEffects = true;
		break;	
	default:
}) {
																						var ` = innerElem.def;
																						switch (enumIndex `) {
																							case 8: {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									innerHasEffects = true;
																									break;
																								};
																							};
																							case 53: {
																								var ` = `[0];
																								{
																									innerHasEffects = true;
																									break;
																								};
																							};
																							default: {}
																						};
																					};
																				};
																			};
																			if (innerHasEffects) {
																				var processedInner = reflaxe.elixir.ast.ElixirASTTransformer.listEffectLiftingPass({
																					var pos = null;
																					{def : right.def, metadata : {}, pos : pos};
																				});
																				@:ast(switch (processedInner.def) {
	case EBlock(stmts) if (stmts.length > 0):
		hasEffects = true;
		for (k  in  0 ... stmts.length - 1) {
			liftedStatements.push(stmts[k]);
		};
		pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));	
	default:
		pureElements.push(elem);	
}) {
																					var ` = processedInner.def;
																					if (enumIndex ` == 53) {
																						var ` = `[0];
																						{
																							var stmts = `;
																							if (stmts.length > 0) {
																								hasEffects = true;
																								{
																									var ` = 0;
																									var ` = stmts.length - 1;
																									while (` < `) {
																										var k = ` ++;
																										liftedStatements.push(stmts[k]);
																									};
																								};
																								pureElements.push({
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, left, stmts[stmts.length - 1]), metadata : {}, pos : pos};
																								});
																							} else {
																								pureElements.push(elem);
																							};
																						};
																					} else {
																						pureElements.push(elem);
																					};
																				};
																			} else {
																				pureElements.push(elem);
																			};
																		} else {
																			pureElements.push(elem);
																		};
																	};
																} else {
																	pureElements.push(elem);
																};
															};
														};
													};
												} else {
													pureElements.push(elem);
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 0) {
														hasEffects = true;
														{
															var ` = 0;
															var ` = exprs.length - 1;
															while (` < `) {
																var j = ` ++;
																liftedStatements.push(exprs[j]);
															};
														};
														pureElements.push(exprs[exprs.length - 1]);
													} else {
														pureElements.push(elem);
													};
												};
											};
											default: {
												pureElements.push(elem);
											}
										};
									};
								};
							};
							if (hasEffects) {
								var allStatements = liftedStatements.copy();
								allStatements.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EList(pureElements), metadata : {}, pos : pos};
								});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(allStatements), metadata : {}, pos : pos};
								};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function structFieldAssignmentTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var structVarTracking = {
			{};
			new haxe.ds.StringMap();
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(expressions):
		var transformed = [];
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			switch (expr.def) {
				case EMatch(PVar(varName), rhs):
					switch (rhs.def) {
						case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
							structVarTracking.set(varName, varName);						
						case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
							structVarTracking.set(varName, varName);						
						default:
					};
					if (i + 1 < expressions.length) {
						var nextExpr = expressions[i + 1];
						switch (nextExpr.def) {
							case EMatch(PVar(fieldName), fieldValue):
								if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
									transformed.push(expr);
									var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
									transformed.push(mapPut);
									i += 2;
									continue;
								};							
							default:
						};
					};
					transformed.push(expr);				
				default:
					transformed.push(expr);				
			};
			i++;
		};
		if (transformed.length > 0) {
			return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var transformed = [];
							var i = 0;
							while (i < expressions.length) {
								var expr = expressions[i];
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), rhs):
		switch (rhs.def) {
			case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
				structVarTracking.set(varName, varName);			
			case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
				structVarTracking.set(varName, varName);			
			default:
		};
		if (i + 1 < expressions.length) {
			var nextExpr = expressions[i + 1];
			switch (nextExpr.def) {
				case EMatch(PVar(fieldName), fieldValue):
					if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
						transformed.push(expr);
						var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
						transformed.push(mapPut);
						i += 2;
						continue;
					};				
				default:
			};
		};
		transformed.push(expr);	
	default:
		transformed.push(expr);	
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var rhs = `;
												{
													@:ast(switch (rhs.def) {
	case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
		structVarTracking.set(varName, varName);	
	case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
		structVarTracking.set(varName, varName);	
	default:
}) {
														var ` = rhs.def;
														switch (enumIndex `) {
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var funcName = `;
																	if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker") {
																		{
																			structVarTracking.set(varName, varName);
																		};
																	} else {};
																};
															};
															case 24: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var funcName = `;
																	if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker") {
																		{
																			structVarTracking.set(varName, varName);
																		};
																	} else {};
																};
															};
															default: {}
														};
													};
													if (i + 1 < expressions.length) {
														var nextExpr = expressions[i + 1];
														@:ast(switch (nextExpr.def) {
	case EMatch(PVar(fieldName), fieldValue):
		if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
			transformed.push(expr);
			var mapPut = makeAST(EMatch(PVar(varName), makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(varName)), makeAST(EAtom(fieldName)), fieldValue]))));
			transformed.push(mapPut);
			i += 2;
			continue;
		};	
	default:
}) {
															var ` = nextExpr.def;
															if (enumIndex ` == 8) {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var fieldName = `;
																		var fieldValue = `;
																		{
																			if (structVarTracking.exists(varName) && (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
																				transformed.push(expr);
																				var mapPut = {
																					var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), {
																						var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																						}, "put", [{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
																						}, {
																							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																								var this;
																								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																								cast this;
																							});
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						}, fieldValue]);
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					});
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				};
																				transformed.push(mapPut);
																				i += 2;
																				continue;
																			};
																		};
																	};
																} else {};
															} else {};
														};
													};
													transformed.push(expr);
												};
											};
										} else {
											transformed.push(expr);
										};
									} else {
										transformed.push(expr);
									};
								};
								i ++;
							};
							if (transformed.length > 0) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformed), metadata : node.metadata, pos : node.pos};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function statementContextTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformWithContext = [null];
		transformWithContext[0] = function(node:reflaxe.elixir.ast.ElixirAST, isStatementContext:Bool) {
			if (node == null || node.def == null) {
				return node;
			};
			var transformed = @:ast(switch (node.def) {
	case EDefmodule(name, doBlock):
		makeASTWithMeta(EDefmodule(name, transformWithContext(doBlock, true)), node.metadata, node.pos);	
	case EBlock(expressions):
		var newExpressions = [];
		for (i  in  0 ... expressions.length) {
			var isLast = (i == expressions.length - 1);
			var childContext = isLast ? isStatementContext : true;
			newExpressions.push(transformWithContext(expressions[i], childContext));
		};
		makeASTWithMeta(EBlock(newExpressions), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, transformWithContext(body, false)), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, transformWithContext(body, false)), node.metadata, node.pos);	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformWithContext(condition, false), transformWithContext(thenBranch, isStatementContext), elseBranch != null ? transformWithContext(elseBranch, isStatementContext) : null), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformWithContext(expr, false), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformWithContext(c.guard, false) : null, body : transformWithContext(c.body, isStatementContext) })), node.metadata, node.pos);	
	default:
		switch (node.def) {
			case EModule(name, attributes, body):
				makeASTWithMeta(EModule(name, attributes, body.map(function(e) ->  @:implicitReturn return transformWithContext(e, true))), node.metadata, node.pos);			
			case ECall(target, funcName, args):
				makeASTWithMeta(ECall(target != null ? transformWithContext(target, false) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);			
			case ERemoteCall(module, funcName, args):
				makeASTWithMeta(ERemoteCall(transformWithContext(module, false), funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);			
			case EBinary(op, left, right):
				makeASTWithMeta(EBinary(op, transformWithContext(left, false), transformWithContext(right, false)), node.metadata, node.pos);			
			case EMatch(pattern, expr):
				makeASTWithMeta(EMatch(pattern, transformWithContext(expr, false)), node.metadata, node.pos);			
			default:
				node;			
		};	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformWithContext[0](doBlock, true));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformWithContext[0](body, false));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformWithContext[0](body, false));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformWithContext[0](expr, false), {
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformWithContext[0](v.guard, false) else null, body : transformWithContext[0](v.body, isStatementContext)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformWithContext[0](condition, false), transformWithContext[0](thenBranch, isStatementContext), if ((elseBranch != null)) transformWithContext[0](elseBranch, isStatementContext) else null);
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var expressions = `;
							{
								var newExpressions = [];
								{
									var ` = 0;
									var ` = expressions.length;
									while (` < `) {
										var i = ` ++;
										var isLast = (i == expressions.length - 1);
										var childContext = if (isLast) {
											isStatementContext;
										} else {
											true;
										};
										newExpressions.push(transformWithContext[0](expressions[i], childContext));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newExpressions), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						@:ast(switch (node.def) {
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(function(e) ->  @:implicitReturn return transformWithContext(e, true))), node.metadata, node.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformWithContext(target, false) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);	
	case ERemoteCall(module, funcName, args):
		makeASTWithMeta(ERemoteCall(transformWithContext(module, false), funcName, args.map(function(a) ->  @:implicitReturn return transformWithContext(a, false))), node.metadata, node.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformWithContext(left, false), transformWithContext(right, false)), node.metadata, node.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transformWithContext(expr, false)), node.metadata, node.pos);	
	default:
		node;	
}) {
							var ` = node.def;
							switch (enumIndex `) {
								case 0: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var name = `;
										var attributes = `;
										var body = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
													var ` = [];
													{
														var ` = 0;
														var ` = body;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, true));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 8: {
									var ` = `[0];
									var ` = `[1];
									{
										var pattern = `;
										var expr = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformWithContext[0](expr, false));
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 22: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var target = `;
										var funcName = `;
										var args = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformWithContext[0](target, false) else null, funcName, {
													var ` = [];
													{
														var ` = 0;
														var ` = args;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, false));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 24: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var module = `;
										var funcName = `;
										var args = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(transformWithContext[0](module, false), funcName, {
													var ` = [];
													{
														var ` = 0;
														var ` = args;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															`.push(transformWithContext[0](v, false));
														};
													};
													`;
												});
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								case 26: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var op = `;
										var left = `;
										var right = `;
										{
											{
												var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformWithContext[0](left, false), transformWithContext[0](right, false));
												var meta = node.metadata;
												var pos = node.pos;
												{def : def, metadata : meta, pos : pos};
											};
										};
									};
								};
								default: {
									node;
								}
							};
						};
					}
				};
			};
			if (isStatementContext) {
				@:ast(switch (transformed.def) {
	case ERemoteCall(module, funcName, args):
		var moduleName:Null<String> = switch (module.def) {
			case EAtom(atom):
				atom;			
			case EVar(name):
				name;			
			default:
				null;			
		};
		if (moduleName != null) {
			var needsReassignment = switch (moduleName) {
				case "Map":
					["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;				
				case "List":
					["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;				
				case "MapSet":
					["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;				
				case "Keyword":
					["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;				
				case "String":
					["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;				
				default:
					false;				
			};
			if (needsReassignment && args.length >= 1) {
				switch (args[0].def) {
					case EVar(varName):
						return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);					
					default:
				};
			};
		};	
	case EBinary(Concat, left, right):
		switch (left.def) {
			case EVar(varName):
				return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);			
			default:
		};	
	default:
}) {
					var ` = transformed.def;
					switch (enumIndex `) {
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var module = `;
								var funcName = `;
								var args = `;
								{
									var moduleName = @:ast(switch (module.def) {
	case EAtom(atom):
		atom;	
	case EVar(name):
		name;	
	default:
		null;	
}) {
										var ` = module.def;
										switch (enumIndex `) {
											case 31: {
												var ` = `[0];
												{
													var atom = `;
													{
														atom;
													};
												};
											};
											case 38: {
												var ` = `[0];
												{
													var name = `;
													{
														name;
													};
												};
											};
											default: {
												null;
											}
										};
									};
									if (moduleName != null) {
										var needsReassignment = @:ast(switch (moduleName) {
	case "Map":
		["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;	
	case "List":
		["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;	
	case "MapSet":
		["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;	
	case "Keyword":
		["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;	
	case "String":
		["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;	
	default:
		false;	
}) if (moduleName == null) {
											false;
										} else switch (moduleName) {
											case "Keyword": {
												{
													["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName, null) >= 0;
												};
											};
											case "List": {
												{
													["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName, null) >= 0;
												};
											};
											case "Map": {
												{
													["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName, null) >= 0;
												};
											};
											case "MapSet": {
												{
													["put", "delete", "union", "intersection", "difference"].indexOf(funcName, null) >= 0;
												};
											};
											case "String": {
												{
													["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName, null) >= 0;
												};
											};
											default: {
												false;
											}
										};
										if (needsReassignment && args.length >= 1) {
											@:ast(switch (args[0].def) {
	case EVar(varName):
		return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);	
	default:
}) {
												var ` = args[0].def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var varName = `;
														{
															return {def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), transformed), metadata : node.metadata, pos : node.pos};
														};
													};
												} else {};
											};
										};
									};
								};
							};
						};
						case 26: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (enumIndex ` == 23) {
								{
									var left = `;
									var right = `;
									{
										@:ast(switch (left.def) {
	case EVar(varName):
		return makeASTWithMeta(EMatch(PVar(varName), transformed), node.metadata, node.pos);	
	default:
}) {
											var ` = left.def;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var varName = `;
													{
														return {def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), transformed), metadata : node.metadata, pos : node.pos};
													};
												};
											} else {};
										};
									};
								};
							} else {};
						};
						default: {}
					};
				};
			};
			return transformed;
		};
		return transformWithContext[0](ast, true);
	}

	static function immutabilityTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		ast = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EDef(name, args, guards, body) if ((name == "set" || name == "remove") && args.length > 0 && switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}):
		var updatedBody = transformStructFieldAssignments(body, args);
		if (updatedBody != body) {
			makeASTWithMeta(EDef(name, args, guards, updatedBody), node.metadata, node.pos);
		} else {
			node;
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 2) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						if ((name == "set" || name == "remove") && args.length > 0 && @:ast(switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}) {
							var ` = args[0];
							if (enumIndex ` == 0) {
								var ` = `[0];
								if (` == "struct") {
									{
										true;
									};
								} else {
									false;
								};
							} else {
								false;
							};
						}) {
							var updatedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformStructFieldAssignments(body, args);
							if (updatedBody != body) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, updatedBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECall(null, "pre_inc", [expr]):
		switch (expr.def) {
			case EVar(name):
				makeAST(EMatch(PVar(name), makeAST(EBinary(Add, expr, makeAST(EInteger(1))))));			
			default:
				node;			
		};	
	case ECall(null, "pre_dec", [expr]):
		switch (expr.def) {
			case EVar(name):
				makeAST(EMatch(PVar(name), makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))));			
			default:
				node;			
		};	
	case EBinary(Remainder, left, right):
		makeAST(ECall(null, "rem", [left, right]));	
	case ECall(target, "push", [item]):
		switch (target.def) {
			case EField(structVar, fieldName):
				switch (structVar.def) {
					case EVar("struct"):
						if (StructUpdateTransform.isArrayVariable(fieldName)) {
							makeAST(EBinary(Concat, target, makeAST(EList([item]))));
						} else {
							makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, target, makeAST(EList([item])))) }]));
						};					
					default:
						node;					
				};			
			case EVar(fieldName):
				if (StructUpdateTransform.isArrayVariable(fieldName)) {
					makeAST(EBinary(Concat, target, makeAST(EList([item]))));
				} else {
					var structVar = makeAST(EVar("struct"));
					makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, makeAST(EField(structVar, fieldName)), makeAST(EList([item])))) }]));
				};			
			default:
				makeAST(EBinary(Concat, target, makeAST(EList([item]))));			
		};	
	case ECall(target, "pop", []):
		makeAST(ERemoteCall(makeAST(EAtom(ElixirAtom.raw("List"))), "delete_at", [target, makeAST(EInteger(-1))]));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) switch (`) {
							case "pop": {
								if (`.length == 0) {
									{
										var target = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "List"), metadata : {}, pos : pos};
												}, "delete_at", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							case "pre_dec": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var expr = `;
										{
											@:ast(switch (expr.def) {
	case EVar(name):
		makeAST(EMatch(PVar(name), makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))));	
	default:
		node;	
}) {
												var ` = expr.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var name = `;
														{
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, expr, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																	}), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
													};
												} else {
													node;
												};
											};
										};
									};
								} else {
									node;
								};
							};
							case "pre_inc": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var expr = `;
										{
											@:ast(switch (expr.def) {
	case EVar(name):
		makeAST(EMatch(PVar(name), makeAST(EBinary(Add, expr, makeAST(EInteger(1))))));	
	default:
		node;	
}) {
												var ` = expr.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var name = `;
														{
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, expr, {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
																	}), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
													};
												} else {
													node;
												};
											};
										};
									};
								} else {
									node;
								};
							};
							case "push": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var target = `;
										var item = `;
										{
											@:ast(switch (target.def) {
	case EField(structVar, fieldName):
		switch (structVar.def) {
			case EVar("struct"):
				if (StructUpdateTransform.isArrayVariable(fieldName)) {
					makeAST(EBinary(Concat, target, makeAST(EList([item]))));
				} else {
					makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, target, makeAST(EList([item])))) }]));
				};			
			default:
				node;			
		};	
	case EVar(fieldName):
		if (StructUpdateTransform.isArrayVariable(fieldName)) {
			makeAST(EBinary(Concat, target, makeAST(EList([item]))));
		} else {
			var structVar = makeAST(EVar("struct"));
			makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, makeAST(EField(structVar, fieldName)), makeAST(EList([item])))) }]));
		};	
	default:
		makeAST(EBinary(Concat, target, makeAST(EList([item]))));	
}) {
												var ` = target.def;
												switch (enumIndex `) {
													case 28: {
														var ` = `[0];
														var ` = `[1];
														{
															var structVar = `;
															var fieldName = `;
															{
																@:ast(switch (structVar.def) {
	case EVar("struct"):
		if (StructUpdateTransform.isArrayVariable(fieldName)) {
			makeAST(EBinary(Concat, target, makeAST(EList([item]))));
		} else {
			makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, target, makeAST(EList([item])))) }]));
		};	
	default:
		node;	
}) {
																	var ` = structVar.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		if (` == "struct") {
																			{
																				if (reflaxe.elixir.ast.transformers.StructUpdateTransform.isArrayVariable(fieldName)) {
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					};
																				} else {
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate(structVar, [{key : fieldName, value : {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																							}), metadata : {}, pos : pos};
																						}}]), metadata : {}, pos : pos};
																					};
																				};
																			};
																		} else {
																			node;
																		};
																	} else {
																		node;
																	};
																};
															};
														};
													};
													case 38: {
														var ` = `[0];
														{
															var fieldName = `;
															{
																if (reflaxe.elixir.ast.transformers.StructUpdateTransform.isArrayVariable(fieldName)) {
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	};
																} else {
																	var structVar = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																	};
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate(structVar, [{key : fieldName, value : {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EField(structVar, fieldName), metadata : {}, pos : pos};
																			}, {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																			}), metadata : {}, pos : pos};
																		}}]), metadata : {}, pos : pos};
																	};
																};
															};
														};
													};
													default: {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														};
													}
												};
											};
										};
									};
								} else {
									node;
								};
							};
							default: {
								node;
							}
						} else switch (`) {
							case "pop": {
								if (`.length == 0) {
									{
										var target = `;
										{
											{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "List"), metadata : {}, pos : pos};
												}, "delete_at", [target, {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(-1), metadata : {}, pos : pos};
												}]), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									node;
								};
							};
							case "push": {
								if (`.length == 1) {
									var ` = `[0];
									{
										var target = `;
										var item = `;
										{
											@:ast(switch (target.def) {
	case EField(structVar, fieldName):
		switch (structVar.def) {
			case EVar("struct"):
				if (StructUpdateTransform.isArrayVariable(fieldName)) {
					makeAST(EBinary(Concat, target, makeAST(EList([item]))));
				} else {
					makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, target, makeAST(EList([item])))) }]));
				};			
			default:
				node;			
		};	
	case EVar(fieldName):
		if (StructUpdateTransform.isArrayVariable(fieldName)) {
			makeAST(EBinary(Concat, target, makeAST(EList([item]))));
		} else {
			var structVar = makeAST(EVar("struct"));
			makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, makeAST(EField(structVar, fieldName)), makeAST(EList([item])))) }]));
		};	
	default:
		makeAST(EBinary(Concat, target, makeAST(EList([item]))));	
}) {
												var ` = target.def;
												switch (enumIndex `) {
													case 28: {
														var ` = `[0];
														var ` = `[1];
														{
															var structVar = `;
															var fieldName = `;
															{
																@:ast(switch (structVar.def) {
	case EVar("struct"):
		if (StructUpdateTransform.isArrayVariable(fieldName)) {
			makeAST(EBinary(Concat, target, makeAST(EList([item]))));
		} else {
			makeAST(EStructUpdate(structVar, [{ key : fieldName, value : makeAST(EBinary(Concat, target, makeAST(EList([item])))) }]));
		};	
	default:
		node;	
}) {
																	var ` = structVar.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		if (` == "struct") {
																			{
																				if (reflaxe.elixir.ast.transformers.StructUpdateTransform.isArrayVariable(fieldName)) {
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					};
																				} else {
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate(structVar, [{key : fieldName, value : {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																							}), metadata : {}, pos : pos};
																						}}]), metadata : {}, pos : pos};
																					};
																				};
																			};
																		} else {
																			node;
																		};
																	} else {
																		node;
																	};
																};
															};
														};
													};
													case 38: {
														var ` = `[0];
														{
															var fieldName = `;
															{
																if (reflaxe.elixir.ast.transformers.StructUpdateTransform.isArrayVariable(fieldName)) {
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	};
																} else {
																	var structVar = {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
																	};
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate(structVar, [{key : fieldName, value : {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EField(structVar, fieldName), metadata : {}, pos : pos};
																			}, {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
																			}), metadata : {}, pos : pos};
																		}}]), metadata : {}, pos : pos};
																	};
																};
															};
														};
													};
													default: {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, target, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EList([item]), metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														};
													}
												};
											};
										};
									};
								} else {
									node;
								};
							};
							default: {
								node;
							}
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 4) {
							{
								var left = `;
								var right = `;
								{
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "rem", [left, right]), metadata : {}, pos : pos};
									};
								};
							};
						} else {
							node;
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function transformStructFieldAssignments(body:reflaxe.elixir.ast.ElixirAST, args:Array<reflaxe.elixir.ast.EPattern>) {
		var hasStructParam = args.length > 0 && @:ast(switch (args[0]) {
	case PVar("struct"):
		true;	
	default:
		false;	
}) {
			var ` = args[0];
			if (enumIndex ` == 0) {
				var ` = `[0];
				if (` == "struct") {
					{
						true;
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
		if (! hasStructParam) {
			return body;
		};
		var hasFieldAssignment = [false];
		var fieldUpdates = {
			{};
			new haxe.ds.StringMap();
		};
		var analyzeNode = [null];
		analyzeNode[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EMatch(PVar("root"), value):
		hasFieldAssignment = true;
		fieldUpdates.set("root", value);	
	case EBlock(statements):
		for (stmt  in  statements) {
			analyzeNode(stmt);
		};	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (` == "root") {
								{
									var value = `;
									{
										hasFieldAssignment[0] = true;
										{
											fieldUpdates.set("root", value);
										};
									};
								};
							} else {};
						} else {};
					};
					case 53: {
						var ` = `[0];
						{
							var statements = `;
							{
								{
									var ` = 0;
									while (` < statements.length) {
										var stmt = statements[`];
										++ `;
										analyzeNode[0](stmt);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		analyzeNode[0](body);
		if (hasFieldAssignment[0] && fieldUpdates.exists("root")) {
			var statements = [];
			@:ast(switch (body.def) {
	case EBlock(stmts):
		statements = stmts.copy();	
	default:
		statements = [body];	
}) {
				var ` = body.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							statements = stmts.copy();
						};
					};
				} else {
					statements = [body];
				};
			};
			var structUpdate = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("struct"), metadata : {}, pos : pos};
				}, [{key : "root", value : {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("root"), metadata : {}, pos : pos};
				}}]), metadata : {}, pos : pos};
			};
			statements.push(structUpdate);
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
			};
		};
		return body;
	}

	static function fluentApiOptimizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body):
		var optimizedBody = optimizeFluentBody(body);
		if (optimizedBody != body) {
			return makeAST(EDef(name, args, guards, optimizedBody));
		};	
	case EDefp(name, args, guards, body):
		var optimizedBody = optimizeFluentBody(body);
		if (optimizedBody != body) {
			return makeAST(EDefp(name, args, guards, optimizedBody));
		};	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var optimizedBody = reflaxe.elixir.ast.ElixirASTTransformer.optimizeFluentBody(body);
								if (optimizedBody != body) {
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, optimizedBody), metadata : {}, pos : pos};
									};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var optimizedBody = reflaxe.elixir.ast.ElixirASTTransformer.optimizeFluentBody(body);
								if (optimizedBody != body) {
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, optimizedBody), metadata : {}, pos : pos};
									};
								};
							};
						};
					};
					default: {}
				};
			};
			return node;
		});
	}

	static function optimizeFluentBody(body:reflaxe.elixir.ast.ElixirAST) {
		if (body == null) {
			return null;
		};
		@:ast(switch (body.def) {
	case EBlock(exprs) if (exprs.length == 2):
		var firstExpr = exprs[0];
		var secondExpr = exprs[1];
		switch (firstExpr.def) {
			case EMatch(PVar("struct"), updateExpr):
				switch (secondExpr.def) {
					case EVar("struct"):
						return updateExpr;					
					default:
				};			
			default:
		};	
	default:
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length == 2) {
						var firstExpr = exprs[0];
						var secondExpr = exprs[1];
						@:ast(switch (firstExpr.def) {
	case EMatch(PVar("struct"), updateExpr):
		switch (secondExpr.def) {
			case EVar("struct"):
				return updateExpr;			
			default:
		};	
	default:
}) {
							var ` = firstExpr.def;
							if (enumIndex ` == 8) {
								var ` = `[0];
								var ` = `[1];
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (` == "struct") {
										{
											var updateExpr = `;
											{
												@:ast(switch (secondExpr.def) {
	case EVar("struct"):
		return updateExpr;	
	default:
}) {
													var ` = secondExpr.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														if (` == "struct") {
															{
																return updateExpr;
															};
														} else {};
													} else {};
												};
											};
										};
									} else {};
								} else {};
							} else {};
						};
					} else {};
				};
			} else {};
		};
		return body;
	}

	static function extractParentModule(node:reflaxe.elixir.ast.ElixirAST) {
		if (node.metadata != null && node.metadata.sourceExpr != null) {};
		return null;
	}

	static function arrayLengthFieldToFunctionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EField(target, "length"):
		{ def : ECall(null, "length", [transformAST(target, arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };	
	case ECall(expr, funcName, args):
		{ def : ECall(expr != null ? transformAST(expr, arrayLengthFieldToFunctionPass) : null, funcName, [for (arg  in  args) transformAST(arg, arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };	
	default:
		transformAST(ast, arrayLengthFieldToFunctionPass);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var expr = `;
						var funcName = `;
						var args = `;
						{
							{def : reflaxe.elixir.ast.ElixirASTDef.ECall(if (expr != null) {
								reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
							} else {
								null;
							}, funcName, {
								var ` = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass));
									};
								};
								`;
							}), metadata : ast.metadata, pos : ast.pos};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (` == "length") {
						{
							var target = `;
							{
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "length", [reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.arrayLengthFieldToFunctionPass);
				}
			};
		};
	}

	static function toSnakeCase(name:String) {
		var result = "";
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
					result += "_";
				};
				result += char.toLowerCase();
			};
		};
		return result;
	}

	@:value(new Map())
	static var visitedNodes:Map<String, Int> = {
		{};
		new haxe.ds.StringMap();
	};

	@:value(0)
	static var nodeVisitCounter:Int = 0;

	@:value(10000)
	static var maxNodeVisits:Int = 10000;

	static function transformArray(arr:Array<reflaxe.elixir.ast.ElixirAST>, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		var changed = false;
		var result = arr;
		{
			var ` = 0;
			var ` = arr.length;
			while (` < `) {
				var i = ` ++;
				var original = arr[i];
				var transformed = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(original, transformer);
				if (transformed != original) {
					if (! changed) {
						result = arr.copy();
						changed = true;
					};
					result[i] = transformed;
				};
			};
		};
		return {array : result, changed : changed};
	}

	public static function transformNode(ast:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		if (ast == null || ast.def == null) {
			return ast;
		};
		var transformed = @:ast(switch (ast.def) {
	case EModule(name, attributes, body):
		var bodyResult = transformArray(body, transformer);
		if (bodyResult.changed) {
			makeASTWithMeta(EModule(name, attributes, bodyResult.array), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards != null ? transformNode(guards, transformer) : null, transformNode(body, transformer)), ast.metadata, ast.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards != null ? transformNode(guards, transformer) : null, transformNode(body, transformer)), ast.metadata, ast.pos);	
	case EBlock(expressions):
		var expResult = transformArray(expressions, transformer);
		if (expResult.changed) {
			makeASTWithMeta(EBlock(expResult.array), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EDo(body):
		var doResult = transformArray(body, transformer);
		if (doResult.changed) {
			makeASTWithMeta(EDo(doResult.array), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformNode(condition, transformer), transformNode(thenBranch, transformer), elseBranch != null ? transformNode(elseBranch, transformer) : null), ast.metadata, ast.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformNode(expr, transformer), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformNode(c.guard, transformer) : null, body : transformNode(c.body, transformer) })), ast.metadata, ast.pos);	
	case EFn(clauses):
		makeASTWithMeta(EFn(clauses.map(function(cl) ->  @:implicitReturn return { args : cl.args, guard : cl.guard != null ? transformNode(cl.guard, transformer) : null, body : transformNode(cl.body, transformer) })), ast.metadata, ast.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformNode(left, transformer), transformNode(right, transformer)), ast.metadata, ast.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, transformNode(expr, transformer)), ast.metadata, ast.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformNode(target, transformer) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformNode(a, transformer))), ast.metadata, ast.pos);	
	case EList(elements):
		makeASTWithMeta(EList(elements.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case ETuple(elements):
		makeASTWithMeta(ETuple(elements.map(function(e) ->  @:implicitReturn return transformNode(e, transformer))), ast.metadata, ast.pos);	
	case EMap(pairs):
		makeASTWithMeta(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformNode(p.key, transformer), value : transformNode(p.value, transformer) })), ast.metadata, ast.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transformNode(expr, transformer)), ast.metadata, ast.pos);	
	case EFor(generators, filters, body, into, uniq):
		makeASTWithMeta(EFor(generators.map(function(g) ->  @:implicitReturn return { pattern : g.pattern, expr : transformNode(g.expr, transformer) }), filters.map(function(f) ->  @:implicitReturn return transformNode(f, transformer)), transformNode(body, transformer), into != null ? transformNode(into, transformer) : null, uniq), ast.metadata, ast.pos);	
	case ERaw(code):
		return ast;	
	case EDefmodule(name, body):
		makeASTWithMeta(EDefmodule(name, transformNode(body, transformer)), ast.metadata, ast.pos);	
	default:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							var bodyResult = reflaxe.elixir.ast.ElixirASTTransformer.transformArray(body, transformer);
							if (bodyResult.changed) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, bodyResult.array), metadata : ast.metadata, pos : ast.pos};
							} else {
								ast;
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, if ((guards != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(guards, transformer) else null, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, if ((guards != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(guards, transformer) else null, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, transformer), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.guard, transformer) else null, body : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.body, transformer)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(condition, transformer), reflaxe.elixir.ast.ElixirASTTransformer.transformNode(thenBranch, transformer), if ((elseBranch != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(elseBranch, transformer) else null);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.key, transformer), value : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.value, transformer)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(target, transformer) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(left, transformer), reflaxe.elixir.ast.ElixirASTTransformer.transformNode(right, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, transformer));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFor({
									var ` = [];
									{
										var ` = 0;
										var ` = generators;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, expr : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.expr, transformer)});
										};
									};
									`;
								}, {
									var ` = [];
									{
										var ` = 0;
										var ` = filters;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v, transformer));
										};
									};
									`;
								}, reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, transformer), if ((into != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(into, transformer) else null, uniq);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({args : v.args, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.guard, transformer) else null, body : reflaxe.elixir.ast.ElixirASTTransformer.transformNode(v.body, transformer)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							var expResult = reflaxe.elixir.ast.ElixirASTTransformer.transformArray(expressions, transformer);
							if (expResult.changed) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(expResult.array), metadata : ast.metadata, pos : ast.pos};
							} else {
								ast;
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var body = `;
						{
							var doResult = reflaxe.elixir.ast.ElixirASTTransformer.transformArray(body, transformer);
							if (doResult.changed) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EDo(doResult.array), metadata : ast.metadata, pos : ast.pos};
							} else {
								ast;
							};
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var code = `;
						{
							return ast;
						};
					};
				};
				default: {
					ast;
				}
			};
		};
		var finalResult = transformer(transformed);
		@:ast(switch (finalResult.def) {
	case EAtom(_):
		return finalResult;	
	default:
		if (finalResult == transformed) {
			return finalResult;
		};
		return finalResult;	
}) {
			var ` = finalResult.def;
			if (enumIndex ` == 31) {
				var ` = `[0];
				{
					return finalResult;
				};
			} else {
				if (finalResult == transformed) {
					return finalResult;
				};
				return finalResult;
			};
		};
	}

	static function detectAndOptimizePipeline(expressions:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (expressions.length < 2) {
			return null;
		};
		var pipelineOps = [];
		var baseVar = null;
		var lastExpr = null;
		{
			var ` = 0;
			while (` < expressions.length) {
				var expr = expressions[`];
				++ `;
				@:ast(switch (expr.def) {
	case EMatch(PVar(name), call):
		switch (call.def) {
			case ECall(target, func, args):
				if (args.length > 0) {
					switch (args[0].def) {
						case EVar(argName) if (argName == name):
							if (baseVar == null) {
								baseVar = name;
							};
							if (baseVar == name) {
								pipelineOps.push({ func : func, args : args.slice(1), target : target });
								lastExpr = expr;
								continue;
							};						
						default:
					};
				};			
			case ERemoteCall(module, func, args):
				if (args.length > 0) {
					switch (args[0].def) {
						case EVar(argName) if (argName == name):
							if (baseVar == null) {
								baseVar = name;
							};
							if (baseVar == name) {
								pipelineOps.push({ func : func, args : args.slice(1), target : module });
								lastExpr = expr;
								continue;
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
					var ` = expr.def;
					if (enumIndex ` == 8) {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var name = `;
								var call = `;
								{
									@:ast(switch (call.def) {
	case ECall(target, func, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(argName) if (argName == name):
					if (baseVar == null) {
						baseVar = name;
					};
					if (baseVar == name) {
						pipelineOps.push({ func : func, args : args.slice(1), target : target });
						lastExpr = expr;
						continue;
					};				
				default:
			};
		};	
	case ERemoteCall(module, func, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(argName) if (argName == name):
					if (baseVar == null) {
						baseVar = name;
					};
					if (baseVar == name) {
						pipelineOps.push({ func : func, args : args.slice(1), target : module });
						lastExpr = expr;
						continue;
					};				
				default:
			};
		};	
	default:
}) {
										var ` = call.def;
										switch (enumIndex `) {
											case 22: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var target = `;
													var func = `;
													var args = `;
													{
														if (args.length > 0) {
															@:ast(switch (args[0].def) {
	case EVar(argName) if (argName == name):
		if (baseVar == null) {
			baseVar = name;
		};
		if (baseVar == name) {
			pipelineOps.push({ func : func, args : args.slice(1), target : target });
			lastExpr = expr;
			continue;
		};	
	default:
}) {
																var ` = args[0].def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var argName = `;
																		if (argName == name) {
																			if (baseVar == null) {
																				baseVar = name;
																			};
																			if (baseVar == name) {
																				pipelineOps.push({func : func, args : args.slice(1, null), target : target});
																				lastExpr = expr;
																				continue;
																			};
																		} else {};
																	};
																} else {};
															};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var module = `;
													var func = `;
													var args = `;
													{
														if (args.length > 0) {
															@:ast(switch (args[0].def) {
	case EVar(argName) if (argName == name):
		if (baseVar == null) {
			baseVar = name;
		};
		if (baseVar == name) {
			pipelineOps.push({ func : func, args : args.slice(1), target : module });
			lastExpr = expr;
			continue;
		};	
	default:
}) {
																var ` = args[0].def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var argName = `;
																		if (argName == name) {
																			if (baseVar == null) {
																				baseVar = name;
																			};
																			if (baseVar == name) {
																				pipelineOps.push({func : func, args : args.slice(1, null), target : module});
																				lastExpr = expr;
																				continue;
																			};
																		} else {};
																	};
																} else {};
															};
														};
													};
												};
											};
											default: {}
										};
									};
								};
							};
						} else {};
					} else {};
				};
				if (pipelineOps.length >= 2) {
					break;
				} else {
					pipelineOps = [];
					baseVar = null;
				};
			};
		};
		if (pipelineOps.length >= 2) {
			var pipeline = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(baseVar), metadata : {}, pos : pos};
			};
			{
				var ` = 0;
				while (` < pipelineOps.length) {
					var op = pipelineOps[`];
					++ `;
					if (op.target != null) {
						pipeline = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EPipe(pipeline, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(op.target, op.func, op.args), metadata : {}, pos : pos};
							}), metadata : {}, pos : pos};
						};
					} else {
						pipeline = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EPipe(pipeline, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, op.func, op.args), metadata : {}, pos : pos};
							}), metadata : {}, pos : pos};
						};
					};
				};
			};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(baseVar), pipeline), metadata : {}, pos : pos};
			};
		};
		return null;
	}

	static function conditionalReassignmentPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(expressions):
		var transformed = [];
		for (expr  in  expressions) {
			if (expr == null || expr.def == null) {
				continue;
			};
			switch (expr.def) {
				case EIf(cond, thenBranch, null):
					switch (thenBranch.def) {
						case EMatch(PVar(varName), value):
							if (referencesVariable(value, varName)) {
								var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
								transformed.push(makeAST(EMatch(PVar(varName), newIf)));
							} else {
								transformed.push(expr);
							};						
						default:
							transformed.push(expr);						
					};				
				default:
					transformed.push(expr);				
			};
		};
		return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var expressions = `;
						{
							var transformed = [];
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									if (expr == null || expr.def == null) {
										continue;
									};
									@:ast(switch (expr.def) {
	case EIf(cond, thenBranch, null):
		switch (thenBranch.def) {
			case EMatch(PVar(varName), value):
				if (referencesVariable(value, varName)) {
					var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
					transformed.push(makeAST(EMatch(PVar(varName), newIf)));
				} else {
					transformed.push(expr);
				};			
			default:
				transformed.push(expr);			
		};	
	default:
		transformed.push(expr);	
}) {
										var ` = expr.def;
										if (enumIndex ` == 10) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (` == null) {
												var thenBranch = `;
												var cond = `;
												{
													@:ast(switch (thenBranch.def) {
	case EMatch(PVar(varName), value):
		if (referencesVariable(value, varName)) {
			var newIf = makeAST(EIf(cond, value, makeAST(EVar(varName))));
			transformed.push(makeAST(EMatch(PVar(varName), newIf)));
		} else {
			transformed.push(expr);
		};	
	default:
		transformed.push(expr);	
}) {
														var ` = thenBranch.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var varName = `;
																	var value = `;
																	{
																		if (reflaxe.elixir.ast.ElixirASTTransformer.referencesVariable(value, varName)) {
																			var newIf = {
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, value, {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			};
																			transformed.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(varName), newIf), metadata : {}, pos : pos};
																			});
																		} else {
																			transformed.push(expr);
																		};
																	};
																};
															} else {
																transformed.push(expr);
															};
														} else {
															transformed.push(expr);
														};
													};
												};
											} else {
												transformed.push(expr);
											};
										} else {
											transformed.push(expr);
										};
									};
								};
							};
							return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformed), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function referencesVariable(ast:reflaxe.elixir.ast.ElixirAST, varName:String) {
		var found = [false];
		var visitor = [null];
		visitor[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (found[0]) {
				return;
			};
			@:ast(switch (node.def) {
	case EVar(name) if (name == varName):
		found = true;	
	case ERemoteCall(_, _, args):
		if (args.length > 0) {
			switch (args[0].def) {
				case EVar(name) if (name == varName):
					found = true;				
				default:
					for (arg  in  args) {
						visitor(arg);
					};				
			};
		};	
	default:
		transformAST(node, function(n) {
			visitor(n);
			return n;
		});	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var args = `;
							{
								if (args.length > 0) {
									@:ast(switch (args[0].def) {
	case EVar(name) if (name == varName):
		found = true;	
	default:
		for (arg  in  args) {
			visitor(arg);
		};	
}) {
										var ` = args[0].def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var name = `;
												if (name == varName) {
													found[0] = true;
												} else {
													{
														var ` = 0;
														while (` < args.length) {
															var arg = args[`];
															++ `;
															visitor[0](arg);
														};
													};
												};
											};
										} else {
											{
												var ` = 0;
												while (` < args.length) {
													var arg = args[`];
													++ `;
													visitor[0](arg);
												};
											};
										};
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							if (name == varName) {
								found[0] = true;
							} else {
								reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
									visitor[0](n);
									return n;
								});
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
							visitor[0](n);
							return n;
						});
					}
				};
			};
		};
		visitor[0](ast);
		return found[0];
	}

	static function removeRedundantNilInitPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body) if (name == "_new"):
		var transformedBody = switch (body.def) {
			case EBlock(expressions) if (expressions.length >= 2):
				var filteredExprs = [];
				var i = 0;
				while (i < expressions.length) {
					var expr = expressions[i];
					var shouldSkip = false;
					switch (expr.def) {
						case EMatch(PVar("this1"), nilValue):
							if (isNilValue(nilValue)) {
								if (i + 1 < expressions.length) {
									switch (expressions[i + 1].def) {
										case EMatch(PVar("this1"), value):
											if (isNilValue(value)) { } else {
												shouldSkip = true;
											};										
										default:
									};
								};
							};						
						default:
					};
					if (!shouldSkip) {
						filteredExprs.push(expr);
					};
					i++;
				};
				if (filteredExprs.length != expressions.length) {
					makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
				} else {
					body;
				};			
			default:
				body;			
		};
		return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EBlock(expressions):
		var filtered = [];
		var nilAssignments = new Map<String,Int>();
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			if (expr == null || expr.def == null) {
				i++;
				continue;
			};
			switch (expr.def) {
				case EMatch(PVar(varName), nilValue):
					if (isNilValue(nilValue)) {
						nilAssignments.set(varName, i);
					};				
				default:
			};
			i++;
		};
		i = 0;
		var varsToClean = new Map<String,Bool>();
		while (i < expressions.length) {
			var expr = expressions[i];
			if (expr == null || expr.def == null) {
				i++;
				continue;
			};
			switch (expr.def) {
				case EVar(v) if (varsToClean.exists(v)):
					varsToClean.remove(v);
					i++;
					continue;				
				default:
			};
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar(varName), nilValue):
					if (isNilValue(nilValue)) {
						if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
							if (i + 1 < expressions.length) {
								var nextExpr = expressions[i + 1];
								if (nextExpr != null && nextExpr.def != null) {
									switch (nextExpr.def) {
										case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
											if (isNilValue(value)) { } else {
												shouldSkip = true;
												if (i + 2 < expressions.length) {
													var afterNext = expressions[i + 2];
													if (afterNext != null && afterNext.def != null) {
														switch (afterNext.def) {
															case EVar(v) if (v == varName):
																varsToClean.set(varName, true);															
															default:
														};
													};
												};
											};										
										default:
									};
								};
							};
							if (!shouldSkip) {
								var j = i + 1;
								while (j < expressions.length) {
									var checkExpr = expressions[j];
									if (checkExpr == null || checkExpr.def == null) {
										j++;
										continue;
									};
									switch (checkExpr.def) {
										case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
											if (isNilValue(value)) { } else {
												shouldSkip = true;
												break;
											};										
										default:
									};
									j++;
								};
							};
						};
					};				
				default:
			};
			if (!shouldSkip) {
				var processed = removeRedundantNilInitPass(expr);
				filtered.push(processed);
			} else { };
			i++;
		};
		if (filtered.length != expressions.length) {
			return makeASTWithMeta(EBlock(filtered), node.metadata, node.pos);
		} else {
			return node;
		};	
	case EFn(clauses):
		var transformedClauses = [for (clause  in  clauses) { args : clause.args, guard : clause.guard, body : removeRedundantNilInitPass(clause.body) }];
		return makeASTWithMeta(EFn(transformedClauses), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		var transformedBody = removeRedundantNilInitPass(body);
		return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		var transformedBody = removeRedundantNilInitPass(body);
		return makeASTWithMeta(EDefp(name, args, guards, transformedBody), node.metadata, node.pos);	
	case EIf(cond, thenBranch, elseBranch):
		var processedCond = removeRedundantNilInitPass(cond);
		var processedThen = removeRedundantNilInitPass(thenBranch);
		var processedElse = elseBranch != null ? removeRedundantNilInitPass(elseBranch) : null;
		return makeASTWithMeta(EIf(processedCond, processedThen, processedElse), node.metadata, node.pos);	
	case ECase(expr, clauses):
		var processedExpr = removeRedundantNilInitPass(expr);
		var processedClauses = [for (clause  in  clauses) { pattern : clause.pattern, guard : clause.guard != null ? removeRedundantNilInitPass(clause.guard) : null, body : removeRedundantNilInitPass(clause.body) }];
		return makeASTWithMeta(ECase(processedExpr, processedClauses), node.metadata, node.pos);	
	case EFor(generators, filters, body, into, uniq):
		var processedGenerators = [for (gen  in  generators) { pattern : gen.pattern, expr : removeRedundantNilInitPass(gen.expr) }];
		var processedFilters = [for (filter  in  filters) removeRedundantNilInitPass(filter)];
		var processedBody = removeRedundantNilInitPass(body);
		var processedInto = into != null ? removeRedundantNilInitPass(into) : null;
		return makeASTWithMeta(EFor(processedGenerators, processedFilters, processedBody, processedInto, uniq), node.metadata, node.pos);	
	case EParen(inner):
		var transformedInner = switch (inner.def) {
			case EBlock(expressions) if (expressions.length == 3):
				var hasRedundantNil = false;
				switch (expressions[0].def) {
					case EMatch(PVar("this1"), nilValue):
						if (isNilValue(nilValue)) {
							switch (expressions[1].def) {
								case EMatch(PVar("this1"), _):
									switch (expressions[2].def) {
										case EVar("this1"):
											hasRedundantNil = true;										
										default:
									};								
								default:
							};
						};					
					default:
				};
				if (hasRedundantNil) {
					makeASTWithMeta(EBlock([expressions[1], expressions[2]]), inner.metadata, inner.pos);
				} else {
					removeRedundantNilInitPass(inner);
				};			
			default:
				removeRedundantNilInitPass(inner);			
		};
		return makeASTWithMeta(EParen(transformedInner), node.metadata, node.pos);	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							if (name == "_new") {
								var transformedBody = @:ast(switch (body.def) {
	case EBlock(expressions) if (expressions.length >= 2):
		var filteredExprs = [];
		var i = 0;
		while (i < expressions.length) {
			var expr = expressions[i];
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar("this1"), nilValue):
					if (isNilValue(nilValue)) {
						if (i + 1 < expressions.length) {
							switch (expressions[i + 1].def) {
								case EMatch(PVar("this1"), value):
									if (isNilValue(value)) { } else {
										shouldSkip = true;
									};								
								default:
							};
						};
					};				
				default:
			};
			if (!shouldSkip) {
				filteredExprs.push(expr);
			};
			i++;
		};
		if (filteredExprs.length != expressions.length) {
			makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
		} else {
			body;
		};	
	default:
		body;	
}) {
									var ` = body.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var expressions = `;
											if (expressions.length >= 2) {
												var filteredExprs = [];
												var i = 0;
												while (i < expressions.length) {
													var expr = expressions[i];
													var shouldSkip = false;
													@:ast(switch (expr.def) {
	case EMatch(PVar("this1"), nilValue):
		if (isNilValue(nilValue)) {
			if (i + 1 < expressions.length) {
				switch (expressions[i + 1].def) {
					case EMatch(PVar("this1"), value):
						if (isNilValue(value)) { } else {
							shouldSkip = true;
						};					
					default:
				};
			};
		};	
	default:
}) {
														var ` = expr.def;
														if (enumIndex ` == 8) {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																if (` == "this1") {
																	{
																		var nilValue = `;
																		{
																			if (if (nilValue == null) {
																				false;
																			} else {
																				@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																					var ` = nilValue.def;
																					switch (enumIndex `) {
																						case 31: {
																							var ` = `[0];
																							{
																								var a = `;
																								{
																									a == "nil";
																								};
																							};
																						};
																						case 36: {
																							{
																								true;
																							};
																						};
																						default: {
																							false;
																						}
																					};
																				};
																			}) {
																				if (i + 1 < expressions.length) {
																					@:ast(switch (expressions[i + 1].def) {
	case EMatch(PVar("this1"), value):
		if (isNilValue(value)) { } else {
			shouldSkip = true;
		};	
	default:
}) {
																						var ` = expressions[i + 1].def;
																						if (enumIndex ` == 8) {
																							var ` = `[0];
																							var ` = `[1];
																							if (enumIndex ` == 0) {
																								var ` = `[0];
																								if (` == "this1") {
																									{
																										var value = `;
																										{
																											if (if (value == null) {
																												false;
																											} else {
																												@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																													var ` = value.def;
																													switch (enumIndex `) {
																														case 31: {
																															var ` = `[0];
																															{
																																var a = `;
																																{
																																	a == "nil";
																																};
																															};
																														};
																														case 36: {
																															{
																																true;
																															};
																														};
																														default: {
																															false;
																														}
																													};
																												};
																											}) {} else {
																												shouldSkip = true;
																											};
																										};
																									};
																								} else {};
																							} else {};
																						} else {};
																					};
																				};
																			};
																		};
																	};
																} else {};
															} else {};
														} else {};
													};
													if (! shouldSkip) {
														filteredExprs.push(expr);
													};
													i ++;
												};
												if (filteredExprs.length != expressions.length) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filteredExprs), metadata : body.metadata, pos : body.pos};
												} else {
													body;
												};
											} else {
												body;
											};
										};
									} else {
										body;
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
							} else {
								var name = `;
								var args = `;
								var guards = `;
								var body = `;
								{
									var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(body);
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var transformedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(body);
								return {def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformedBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								var processedExpr = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(expr);
								var processedClauses = {
									var ` = [];
									{
										var ` = 0;
										while (` < clauses.length) {
											var clause = clauses[`];
											++ `;
											`.push({pattern : clause.pattern, guard : if (clause.guard != null) {
												reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(clause.guard);
											} else {
												null;
											}, body : reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(clause.body)});
										};
									};
									`;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.ECase(processedExpr, processedClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								var processedCond = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(cond);
								var processedThen = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(thenBranch);
								var processedElse = if (elseBranch != null) {
									reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(elseBranch);
								} else {
									null;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EIf(processedCond, processedThen, processedElse), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 41: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						var ` = `[4];
						{
							var generators = `;
							var filters = `;
							var body = `;
							var into = `;
							var uniq = `;
							{
								var processedGenerators = {
									var ` = [];
									{
										var ` = 0;
										while (` < generators.length) {
											var gen = generators[`];
											++ `;
											`.push({pattern : gen.pattern, expr : reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(gen.expr)});
										};
									};
									`;
								};
								var processedFilters = {
									var ` = [];
									{
										var ` = 0;
										while (` < filters.length) {
											var filter = filters[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(filter));
										};
									};
									`;
								};
								var processedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(body);
								var processedInto = if (into != null) {
									reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(into);
								} else {
									null;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFor(processedGenerators, processedFilters, processedBody, processedInto, uniq), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var transformedClauses = {
									var ` = [];
									{
										var ` = 0;
										while (` < clauses.length) {
											var clause = clauses[`];
											++ `;
											`.push({args : clause.args, guard : clause.guard, body : reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(clause.body)});
										};
									};
									`;
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(transformedClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var expressions = `;
							{
								var filtered = [];
								var nilAssignments = {
									{};
									new haxe.ds.StringMap();
								};
								var i = 0;
								while (i < expressions.length) {
									var expr = expressions[i];
									if (expr == null || expr.def == null) {
										i ++;
										continue;
									};
									@:ast(switch (expr.def) {
	case EMatch(PVar(varName), nilValue):
		if (isNilValue(nilValue)) {
			nilAssignments.set(varName, i);
		};	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var varName = `;
													var nilValue = `;
													{
														if (if (nilValue == null) {
															false;
														} else {
															@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																var ` = nilValue.def;
																switch (enumIndex `) {
																	case 31: {
																		var ` = `[0];
																		{
																			var a = `;
																			{
																				a == "nil";
																			};
																		};
																	};
																	case 36: {
																		{
																			true;
																		};
																	};
																	default: {
																		false;
																	}
																};
															};
														}) {
															{
																nilAssignments.set(varName, i);
															};
														};
													};
												};
											} else {};
										} else {};
									};
									i ++;
								};
								i = 0;
								var varsToClean = {
									{};
									new haxe.ds.StringMap();
								};
								while (i < expressions.length) {
									var expr = expressions[i];
									if (expr == null || expr.def == null) {
										i ++;
										continue;
									};
									@:ast(switch (expr.def) {
	case EVar(v) if (varsToClean.exists(v)):
		varsToClean.remove(v);
		i++;
		continue;	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var v = `;
												if (varsToClean.exists(v)) {
													varsToClean.remove(v);
													i ++;
													continue;
												} else {};
											};
										} else {};
									};
									var shouldSkip = false;
									@:ast(switch (expr.def) {
	case EMatch(PVar(varName), nilValue):
		if (isNilValue(nilValue)) {
			if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
				if (i + 1 < expressions.length) {
					var nextExpr = expressions[i + 1];
					if (nextExpr != null && nextExpr.def != null) {
						switch (nextExpr.def) {
							case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
								if (isNilValue(value)) { } else {
									shouldSkip = true;
									if (i + 2 < expressions.length) {
										var afterNext = expressions[i + 2];
										if (afterNext != null && afterNext.def != null) {
											switch (afterNext.def) {
												case EVar(v) if (v == varName):
													varsToClean.set(varName, true);												
												default:
											};
										};
									};
								};							
							default:
						};
					};
				};
				if (!shouldSkip) {
					var j = i + 1;
					while (j < expressions.length) {
						var checkExpr = expressions[j];
						if (checkExpr == null || checkExpr.def == null) {
							j++;
							continue;
						};
						switch (checkExpr.def) {
							case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
								if (isNilValue(value)) { } else {
									shouldSkip = true;
									break;
								};							
							default:
						};
						j++;
					};
				};
			};
		};	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var varName = `;
													var nilValue = `;
													{
														if (if (nilValue == null) {
															false;
														} else {
															@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																var ` = nilValue.def;
																switch (enumIndex `) {
																	case 31: {
																		var ` = `[0];
																		{
																			var a = `;
																			{
																				a == "nil";
																			};
																		};
																	};
																	case 36: {
																		{
																			true;
																		};
																	};
																	default: {
																		false;
																	}
																};
															};
														}) {
															if (varName == "this1" || varName == "this" || StringTools.startsWith(varName, "this")) {
																if (i + 1 < expressions.length) {
																	var nextExpr = expressions[i + 1];
																	if (nextExpr != null && nextExpr.def != null) {
																		@:ast(switch (nextExpr.def) {
	case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
		if (isNilValue(value)) { } else {
			shouldSkip = true;
			if (i + 2 < expressions.length) {
				var afterNext = expressions[i + 2];
				if (afterNext != null && afterNext.def != null) {
					switch (afterNext.def) {
						case EVar(v) if (v == varName):
							varsToClean.set(varName, true);						
						default:
					};
				};
			};
		};	
	default:
}) {
																			var ` = nextExpr.def;
																			if (enumIndex ` == 8) {
																				var ` = `[0];
																				var ` = `[1];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					{
																						var nextVarName = `;
																						var value = `;
																						if (nextVarName == varName) {
																							if (if (value == null) {
																								false;
																							} else {
																								@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																									var ` = value.def;
																									switch (enumIndex `) {
																										case 31: {
																											var ` = `[0];
																											{
																												var a = `;
																												{
																													a == "nil";
																												};
																											};
																										};
																										case 36: {
																											{
																												true;
																											};
																										};
																										default: {
																											false;
																										}
																									};
																								};
																							}) {} else {
																								shouldSkip = true;
																								if (i + 2 < expressions.length) {
																									var afterNext = expressions[i + 2];
																									if (afterNext != null && afterNext.def != null) {
																										@:ast(switch (afterNext.def) {
	case EVar(v) if (v == varName):
		varsToClean.set(varName, true);	
	default:
}) {
																											var ` = afterNext.def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var v = `;
																													if (v == varName) {
																														{
																															varsToClean.set(varName, true);
																														};
																													} else {};
																												};
																											} else {};
																										};
																									};
																								};
																							};
																						} else {};
																					};
																				} else {};
																			} else {};
																		};
																	};
																};
																if (! shouldSkip) {
																	var j = i + 1;
																	while (j < expressions.length) {
																		var checkExpr = expressions[j];
																		if (checkExpr == null || checkExpr.def == null) {
																			j ++;
																			continue;
																		};
																		@:ast(switch (checkExpr.def) {
	case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
		if (isNilValue(value)) { } else {
			shouldSkip = true;
			break;
		};	
	default:
}) {
																			var ` = checkExpr.def;
																			if (enumIndex ` == 8) {
																				var ` = `[0];
																				var ` = `[1];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					{
																						var nextVarName = `;
																						var value = `;
																						if (nextVarName == varName) {
																							if (if (value == null) {
																								false;
																							} else {
																								@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																									var ` = value.def;
																									switch (enumIndex `) {
																										case 31: {
																											var ` = `[0];
																											{
																												var a = `;
																												{
																													a == "nil";
																												};
																											};
																										};
																										case 36: {
																											{
																												true;
																											};
																										};
																										default: {
																											false;
																										}
																									};
																								};
																							}) {} else {
																								shouldSkip = true;
																								break;
																							};
																						} else {};
																					};
																				} else {};
																			} else {};
																		};
																		j ++;
																	};
																};
															};
														};
													};
												};
											} else {};
										} else {};
									};
									if (! shouldSkip) {
										var processed = reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(expr);
										filtered.push(processed);
									} else {};
									i ++;
								};
								if (filtered.length != expressions.length) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filtered), metadata : node.metadata, pos : node.pos};
								} else {
									return node;
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var inner = `;
							{
								var transformedInner = @:ast(switch (inner.def) {
	case EBlock(expressions) if (expressions.length == 3):
		var hasRedundantNil = false;
		switch (expressions[0].def) {
			case EMatch(PVar("this1"), nilValue):
				if (isNilValue(nilValue)) {
					switch (expressions[1].def) {
						case EMatch(PVar("this1"), _):
							switch (expressions[2].def) {
								case EVar("this1"):
									hasRedundantNil = true;								
								default:
							};						
						default:
					};
				};			
			default:
		};
		if (hasRedundantNil) {
			makeASTWithMeta(EBlock([expressions[1], expressions[2]]), inner.metadata, inner.pos);
		} else {
			removeRedundantNilInitPass(inner);
		};	
	default:
		removeRedundantNilInitPass(inner);	
}) {
									var ` = inner.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var expressions = `;
											if (expressions.length == 3) {
												var hasRedundantNil = false;
												@:ast(switch (expressions[0].def) {
	case EMatch(PVar("this1"), nilValue):
		if (isNilValue(nilValue)) {
			switch (expressions[1].def) {
				case EMatch(PVar("this1"), _):
					switch (expressions[2].def) {
						case EVar("this1"):
							hasRedundantNil = true;						
						default:
					};				
				default:
			};
		};	
	default:
}) {
													var ` = expressions[0].def;
													if (enumIndex ` == 8) {
														var ` = `[0];
														var ` = `[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (` == "this1") {
																{
																	var nilValue = `;
																	{
																		if (if (nilValue == null) {
																			false;
																		} else {
																			@:ast(switch (ast.def) {
	case EAtom(a):
		a == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
																				var ` = nilValue.def;
																				switch (enumIndex `) {
																					case 31: {
																						var ` = `[0];
																						{
																							var a = `;
																							{
																								a == "nil";
																							};
																						};
																					};
																					case 36: {
																						{
																							true;
																						};
																					};
																					default: {
																						false;
																					}
																				};
																			};
																		}) {
																			@:ast(switch (expressions[1].def) {
	case EMatch(PVar("this1"), _):
		switch (expressions[2].def) {
			case EVar("this1"):
				hasRedundantNil = true;			
			default:
		};	
	default:
}) {
																				var ` = expressions[1].def;
																				if (enumIndex ` == 8) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						if (` == "this1") {
																							{
																								@:ast(switch (expressions[2].def) {
	case EVar("this1"):
		hasRedundantNil = true;	
	default:
}) {
																									var ` = expressions[2].def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										if (` == "this1") {
																											{
																												hasRedundantNil = true;
																											};
																										} else {};
																									} else {};
																								};
																							};
																						} else {};
																					} else {};
																				} else {};
																			};
																		};
																	};
																};
															} else {};
														} else {};
													} else {};
												};
												if (hasRedundantNil) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([expressions[1], expressions[2]]), metadata : inner.metadata, pos : inner.pos};
												} else {
													reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
												};
											} else {
												reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
											};
										};
									} else {
										reflaxe.elixir.ast.ElixirASTTransformer.removeRedundantNilInitPass(inner);
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EParen(transformedInner), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function prefixUnusedParametersPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EDef(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDef(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefp(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefp(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefmacro(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefmacro(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EDefmacrop(name, args, guards, body):
		var result = handleFunctionParameters(args, guards, body);
		if (result.hasChanges) {
			return makeASTWithMeta(EDefmacrop(name, result.args, guards, result.body), node.metadata, node.pos);
		};
		return node;	
	case EFn(clauses):
		var hasAnyChange = false;
		var newClauses = [];
		for (clause  in  clauses) {
			var result = handleFunctionParameters(clause.args, clause.guard, clause.body);
			if (result.hasChanges) {
				hasAnyChange = true;
				newClauses.push({ args : result.args, guard : clause.guard, body : result.body });
			} else {
				newClauses.push(clause);
			};
		};
		if (hasAnyChange) {
			return makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmacro(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(args, guards, body);
								if (result.hasChanges) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmacrop(name, result.args, guards, result.body), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var hasAnyChange = false;
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										var result = reflaxe.elixir.ast.ElixirASTTransformer.handleFunctionParameters(clause.args, clause.guard, clause.body);
										if (result.hasChanges) {
											hasAnyChange = true;
											newClauses.push({args : result.args, guard : clause.guard, body : result.body});
										} else {
											newClauses.push(clause);
										};
									};
								};
								if (hasAnyChange) {
									return {def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : node.metadata, pos : node.pos};
								};
								return node;
							};
						};
					};
					default: {
						return node;
					}
				};
			};
		});
	}

	static function handleFunctionParameters(args:Array<reflaxe.elixir.ast.EPattern>, guards:Null<reflaxe.elixir.ast.ElixirAST>, body:reflaxe.elixir.ast.ElixirAST) {
		var paramNames = {
			{};
			new haxe.ds.StringMap();
		};
		var paramRenames = {
			{};
			new haxe.ds.StringMap();
		};
		var extractParamNames = [null];
		extractParamNames[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pattern) {
	case PVar(name):
		if (!name.startsWith("_")) {
			paramNames.set(name, false);
		};	
	case PTuple(patterns):
		for (p  in  patterns) extractParamNames(p);	
	case PList(patterns):
		for (p  in  patterns) extractParamNames(p);	
	case PMap(pairs):
		for (pair  in  pairs) extractParamNames(pair.value);	
	case PCons(head, tail):
		extractParamNames(head);
		extractParamNames(tail);	
	case PPin(pattern):
		extractParamNames(pattern);	
	default:
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (! StringTools.startsWith(name, "_")) {
								{
									paramNames.set(name, false);
								};
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									extractParamNames[0](p);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									extractParamNames[0](p);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							extractParamNames[0](head);
							extractParamNames[0](tail);
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									extractParamNames[0](pair.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pattern[0];
					{
						var pattern = `;
						{
							extractParamNames[0](pattern);
						};
					};
				};
				default: {}
			};
		};
		{
			var ` = 0;
			while (` < args.length) {
				var arg = args[`];
				++ `;
				extractParamNames[0](arg);
			};
		};
		if (Lambda.count(cast paramNames, null) == 0) {
			return {args : args, body : body, hasChanges : false};
		};
		var markUsedVars = [null];
		markUsedVars[0] = function(ast:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (ast.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	case EField(target, _):
		switch (target.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(target);			
		};	
	case EAccess(target, key):
		switch (target.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(target);			
		};
		markUsedVars(key);	
	case EStructUpdate(struct, fields):
		switch (struct.def) {
			case EVar(name):
				if (paramNames.exists(name)) {
					paramNames.set(name, true);
				};			
			default:
				markUsedVars(struct);			
		};
		for (field  in  fields) {
			markUsedVars(field.value);
		};	
	case ERaw(code):
		for (name => _  in  paramNames) {
			var pattern = "\\b${name}\\b";
			if (new EReg(pattern, "").match(code)) {
				paramNames.set(name, true);
			};
		};	
	case EKeywordList(pairs):
		for (pair  in  pairs) {
			markUsedVars(pair.value);
		};	
	default:
		iterateAST(ast, markUsedVars);	
}) {
				var ` = ast.def;
				switch (enumIndex `) {
					case 19: {
						var ` = `[0];
						var ` = `[1];
						{
							var struct = `;
							var fields = `;
							{
								@:ast(switch (struct.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(struct);	
}) {
									var ` = struct.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](struct);
									};
								};
								{
									var ` = 0;
									while (` < fields.length) {
										var field = fields[`];
										++ `;
										markUsedVars[0](field.value);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var pair = pairs[`];
										++ `;
										markUsedVars[0](pair.value);
									};
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							{
								@:ast(switch (target.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(target);	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](target);
									};
								};
							};
						};
					};
					case 29: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var key = `;
							{
								@:ast(switch (target.def) {
	case EVar(name):
		if (paramNames.exists(name)) {
			paramNames.set(name, true);
		};	
	default:
		markUsedVars(target);	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												if (paramNames.exists(name)) {
													{
														paramNames.set(name, true);
													};
												};
											};
										};
									} else {
										markUsedVars[0](target);
									};
								};
								markUsedVars[0](key);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (paramNames.exists(name)) {
									{
										paramNames.set(name, true);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								{
									var ` = cast new haxe.iterators.MapKeyValueIterator(paramNames);
									while (`.hasNext()) {
										var ` = `.next();
										var name = `.key;
										var _ = `.value;
										{
											var pattern = "\\b" + name + "\\b";
											if (new EReg(pattern, "").match(code)) {
												{
													paramNames.set(name, true);
												};
											};
										};
									};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(ast, markUsedVars[0]);
					}
				};
			};
		};
		if (guards != null) {
			markUsedVars[0](guards);
		};
		markUsedVars[0](body);
		var hasChanges = false;
		if (! hasChanges) {
			return {args : args, body : body, hasChanges : false};
		};
		var renameInPattern = [null];
		renameInPattern[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pattern) {
	case PVar(name):
		if (paramRenames.exists(name)) {
			return PVar(paramRenames.get(name));
		};
		return pattern;	
	case PTuple(patterns):
		return PTuple(patterns.map(renameInPattern));	
	case PList(patterns):
		return PList(patterns.map(renameInPattern));	
	case PMap(pairs):
		return PMap([for (pair  in  pairs) { key : pair.key, value : renameInPattern(pair.value) }]);	
	case PCons(head, tail):
		return PCons(renameInPattern(head), renameInPattern(tail));	
	case PPin(p):
		return PPin(renameInPattern(p));	
	default:
		return pattern;	
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (paramRenames.exists(name)) {
								return reflaxe.elixir.ast.EPattern.PVar(cast paramRenames.get(name));
							};
							return pattern;
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							return reflaxe.elixir.ast.EPattern.PTuple({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							return reflaxe.elixir.ast.EPattern.PList({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							return reflaxe.elixir.ast.EPattern.PCons(renameInPattern[0](head), renameInPattern[0](tail));
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							return reflaxe.elixir.ast.EPattern.PMap({
								var ` = [];
								{
									var ` = 0;
									while (` < pairs.length) {
										var pair = pairs[`];
										++ `;
										`.push({key : pair.key, value : renameInPattern[0](pair.value)});
									};
								};
								`;
							});
						};
					};
				};
				case 7: {
					var ` = pattern[0];
					{
						var p = `;
						{
							return reflaxe.elixir.ast.EPattern.PPin(renameInPattern[0](p));
						};
					};
				};
				default: {
					return pattern;
				}
			};
		};
		var newArgs = {
			var f = renameInPattern[0];
			{
				var ` = [];
				{
					var ` = 0;
					var ` = args;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(f(v));
					};
				};
				`;
			};
		};
		var renameInAST = [null];
		renameInAST[0] = function(ast:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (ast.def) {
	case EVar(name):
		if (paramRenames.exists(name)) {
			return { def : EVar(paramRenames.get(name)), metadata : ast.metadata };
		};
		return ast;	
	default:
		return transformAST(ast, renameInAST);	
}) {
				var ` = ast.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var name = `;
						{
							if (paramRenames.exists(name)) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(cast paramRenames.get(name)), metadata : ast.metadata};
							};
							return ast;
						};
					};
				} else {
					return reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, renameInAST[0]);
				};
			};
		};
		var newBody = renameInAST[0](body);
		return {args : newArgs, body : newBody, hasChanges : true};
	}

	@:value(0)
	static var uniqueCounter:Int = 0;

	static function generateUniqueId() {
		return Std.string(reflaxe.elixir.ast.ElixirASTTransformer.uniqueCounter ++);
	}

	static function iterateAST(node:reflaxe.elixir.ast.ElixirAST, visitor:reflaxe.elixir.ast.ElixirAST -> Void) {
		if (node == null || node.def == null) {
			return;
		};
		@:ast(switch (node.def) {
	case EBlock(expressions):
		for (expr  in  expressions) if (expr != null) visitor(expr);	
	case EModule(name, attributes, body):
		for (b  in  body) if (b != null) visitor(b);	
	case EDefmodule(name, doBlock):
		if (doBlock != null) visitor(doBlock);	
	case EDef(name, args, guards, body):
		if (body != null) visitor(body);	
	case EDefp(name, args, guards, body):
		if (body != null) visitor(body);	
	case EIf(condition, thenBranch, elseBranch):
		if (condition != null) visitor(condition);
		if (thenBranch != null) visitor(thenBranch);
		if (elseBranch != null) visitor(elseBranch);	
	case ECase(expr, clauses):
		if (expr != null) visitor(expr);
		for (clause  in  clauses) {
			if (clause != null) {
				if (clause.guard != null) visitor(clause.guard);
				if (clause.body != null) visitor(clause.body);
			};
		};	
	case EMatch(pattern, expr):
		if (expr != null) visitor(expr);	
	case EBinary(op, left, right):
		if (left != null) visitor(left);
		if (right != null) visitor(right);	
	case EUnary(op, expr):
		if (expr != null) visitor(expr);	
	case ECall(target, funcName, args):
		if (target != null) visitor(target);
		for (arg  in  args) if (arg != null) visitor(arg);	
	case EMacroCall(macroName, args, doBlock):
		for (arg  in  args) if (arg != null) visitor(arg);
		if (doBlock != null) visitor(doBlock);	
	case ETuple(elements):
		for (elem  in  elements) if (elem != null) visitor(elem);	
	case EList(elements):
		for (elem  in  elements) if (elem != null) visitor(elem);	
	case EMap(pairs):
		for (pair  in  pairs) {
			if (pair != null) {
				if (pair.key != null) visitor(pair.key);
				if (pair.value != null) visitor(pair.value);
			};
		};	
	case EStruct(name, fields):
		for (field  in  fields) if (field != null && field.value != null) visitor(field.value);	
	case EFor(generators, filters, body, into, uniq):
		for (gen  in  generators) {
			if (gen != null && gen.expr != null) visitor(gen.expr);
		};
		for (filter  in  filters) if (filter != null) visitor(filter);
		if (body != null) visitor(body);
		if (into != null) visitor(into);	
	case EFn(clauses):
		for (clause  in  clauses) {
			if (clause != null) {
				if (clause.guard != null) visitor(clause.guard);
				if (clause.body != null) visitor(clause.body);
			};
		};	
	case EReceive(clauses, after):
		for (clause  in  clauses) {
			if (clause != null) {
				if (clause.guard != null) visitor(clause.guard);
				if (clause.body != null) visitor(clause.body);
			};
		};
		if (after != null) {
			if (after.timeout != null) visitor(after.timeout);
			if (after.body != null) visitor(after.body);
		};	
	case ERemoteCall(module, funcName, args):
		if (module != null) visitor(module);
		for (arg  in  args) if (arg != null) visitor(arg);	
	case EParen(expr):
		if (expr != null) visitor(expr);	
	case EDo(body):
		for (stmt  in  body) if (stmt != null) visitor(stmt);	
	case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
		if (body != null) visitor(body);
		if (rescue != null) {
			for (clause  in  rescue) {
				if (clause != null && clause.body != null) visitor(clause.body);
			};
		};
		if (catchClauses != null) {
			for (clause  in  catchClauses) {
				if (clause != null && clause.body != null) visitor(clause.body);
			};
		};
		if (afterBlock != null) visitor(afterBlock);
		if (elseBlock != null) visitor(elseBlock);	
	case EWith(clauses, doBlock, elseBlock):
		for (clause  in  clauses) {
			if (clause != null && clause.expr != null) visitor(clause.expr);
		};
		if (doBlock != null) visitor(doBlock);
		if (elseBlock != null) visitor(elseBlock);	
	case ECond(clauses):
		for (clause  in  clauses) {
			if (clause != null) {
				if (clause.condition != null) visitor(clause.condition);
				if (clause.body != null) visitor(clause.body);
			};
		};	
	case EField(object, field):
		if (object != null) visitor(object);	
	case EModuleAttribute(name, value):
		if (value != null) visitor(value);	
	case EKeywordList(pairs):
		for (pair  in  pairs) {
			if (pair != null && pair.value != null) visitor(pair.value);
		};	
	case _:
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							{
								var ` = 0;
								while (` < body.length) {
									var b = body[`];
									++ `;
									if (b != null) {
										visitor(b);
									};
								};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							if (doBlock != null) {
								visitor(doBlock);
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							if (body != null) {
								visitor(body);
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							if (body != null) {
								visitor(body);
							};
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							if (expr != null) {
								visitor(expr);
							};
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause != null) {
										if (clause.guard != null) {
											visitor(clause.guard);
										};
										if (clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause != null) {
										if (clause.condition != null) {
											visitor(clause.condition);
										};
										if (clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							if (expr != null) {
								visitor(expr);
							};
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var clauses = `;
						var doBlock = `;
						var elseBlock = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause != null && clause.expr != null) {
										visitor(clause.expr);
									};
								};
							};
							if (doBlock != null) {
								visitor(doBlock);
							};
							if (elseBlock != null) {
								visitor(elseBlock);
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							if (condition != null) {
								visitor(condition);
							};
							if (thenBranch != null) {
								visitor(thenBranch);
							};
							if (elseBranch != null) {
								visitor(elseBranch);
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var body = `;
						var rescue = `;
						var catchClauses = `;
						var afterBlock = `;
						var elseBlock = `;
						{
							if (body != null) {
								visitor(body);
							};
							if (rescue != null) {
								{
									var ` = 0;
									while (` < rescue.length) {
										var clause = rescue[`];
										++ `;
										if (clause != null && clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
							if (catchClauses != null) {
								{
									var ` = 0;
									while (` < catchClauses.length) {
										var clause = catchClauses[`];
										++ `;
										if (clause != null && clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
							if (afterBlock != null) {
								visitor(afterBlock);
							};
							if (elseBlock != null) {
								visitor(elseBlock);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									if (elem != null) {
										visitor(elem);
									};
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									if (elem != null) {
										visitor(elem);
									};
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									if (pair != null) {
										if (pair.key != null) {
											visitor(pair.key);
										};
										if (pair.value != null) {
											visitor(pair.value);
										};
									};
								};
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									if (field != null && field.value != null) {
										visitor(field.value);
									};
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									if (pair != null && pair.value != null) {
										visitor(pair.value);
									};
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							if (target != null) {
								visitor(target);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (arg != null) {
										visitor(arg);
									};
								};
							};
						};
					};
				};
				case 23: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var macroName = `;
						var args = `;
						var doBlock = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (arg != null) {
										visitor(arg);
									};
								};
							};
							if (doBlock != null) {
								visitor(doBlock);
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							if (module != null) {
								visitor(module);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (arg != null) {
										visitor(arg);
									};
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							if (left != null) {
								visitor(left);
							};
							if (right != null) {
								visitor(right);
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							if (expr != null) {
								visitor(expr);
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var object = `;
						var field = `;
						{
							if (object != null) {
								visitor(object);
							};
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var ` = 0;
								while (` < generators.length) {
									var gen = generators[`];
									++ `;
									if (gen != null && gen.expr != null) {
										visitor(gen.expr);
									};
								};
							};
							{
								var ` = 0;
								while (` < filters.length) {
									var filter = filters[`];
									++ `;
									if (filter != null) {
										visitor(filter);
									};
								};
							};
							if (body != null) {
								visitor(body);
							};
							if (into != null) {
								visitor(into);
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause != null) {
										if (clause.guard != null) {
											visitor(clause.guard);
										};
										if (clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
						};
					};
				};
				case 51: {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						var after = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (clause != null) {
										if (clause.guard != null) {
											visitor(clause.guard);
										};
										if (clause.body != null) {
											visitor(clause.body);
										};
									};
								};
							};
							if (after != null) {
								if (after.timeout != null) {
									visitor(after.timeout);
								};
								if (after.body != null) {
									visitor(after.body);
								};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									if (expr != null) {
										visitor(expr);
									};
								};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							if (expr != null) {
								visitor(expr);
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var body = `;
						{
							{
								var ` = 0;
								while (` < body.length) {
									var stmt = body[`];
									++ `;
									if (stmt != null) {
										visitor(stmt);
									};
								};
							};
						};
					};
				};
				case 56: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var value = `;
						{
							if (value != null) {
								visitor(value);
							};
						};
					};
				};
				default: {}
			};
		};
	}

	public static function transformAST(node:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		if (node == null || node.def == null) {
			return null;
		};
		var transformed = @:ast(switch (node.def) {
	case EBlock(expressions):
		makeASTWithMeta(EBlock(expressions.map(transformer)), node.metadata, node.pos);	
	case EModule(name, attributes, body):
		makeASTWithMeta(EModule(name, attributes, body.map(transformer)), node.metadata, node.pos);	
	case EDefmodule(name, doBlock):
		makeASTWithMeta(EDefmodule(name, transformer(doBlock)), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, transformer(body)), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, transformer(body)), node.metadata, node.pos);	
	case EIf(condition, thenBranch, elseBranch):
		makeASTWithMeta(EIf(transformer(condition), transformer(thenBranch), elseBranch != null ? transformer(elseBranch) : null), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(transformer(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })), node.metadata, node.pos);	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(pattern, transformer(expr)), node.metadata, node.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, transformer(left), transformer(right)), node.metadata, node.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, transformer(expr)), node.metadata, node.pos);	
	case ECall(target, funcName, args):
		makeASTWithMeta(ECall(target != null ? transformer(target) : null, funcName, args.map(transformer)), node.metadata, node.pos);	
	case EMacroCall(macroName, args, doBlock):
		makeASTWithMeta(EMacroCall(macroName, args.map(transformer), transformer(doBlock)), node.metadata, node.pos);	
	case ETuple(elements):
		makeASTWithMeta(ETuple(elements.map(transformer)), node.metadata, node.pos);	
	case EList(elements):
		makeASTWithMeta(EList(elements.map(transformer)), node.metadata, node.pos);	
	case EMap(pairs):
		makeASTWithMeta(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformer(p.key), value : transformer(p.value) })), node.metadata, node.pos);	
	case EKeywordList(pairs):
		makeASTWithMeta(EKeywordList(pairs.map(function(p) ->  @:implicitReturn return { key : p.key, value : transformer(p.value) })), node.metadata, node.pos);	
	case EStruct(name, fields):
		makeASTWithMeta(EStruct(name, fields.map(function(f) ->  @:implicitReturn return { key : f.key, value : transformer(f.value) })), node.metadata, node.pos);	
	case EFor(generators, filters, body, into, uniq):
		makeASTWithMeta(EFor(generators.map(function(g) ->  @:implicitReturn return { pattern : g.pattern, expr : transformer(g.expr) }), filters.map(transformer), transformer(body), into != null ? transformer(into) : null, uniq), node.metadata, node.pos);	
	case EFn(clauses):
		makeASTWithMeta(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })), node.metadata, node.pos);	
	case EReceive(clauses, after):
		makeASTWithMeta(EReceive(clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) }), after != null ? { timeout : transformer(after.timeout), body : transformer(after.body) } : null), node.metadata, node.pos);	
	case EModuleAttribute(name, value):
		makeASTWithMeta(EModuleAttribute(name, transformer(value)), node.metadata, node.pos);	
	case ERemoteCall(module, funcName, args):
		makeASTWithMeta(ERemoteCall(module != null ? transformer(module) : null, funcName, args.map(transformer)), node.metadata, node.pos);	
	case EParen(expr):
		makeASTWithMeta(EParen(transformer(expr)), node.metadata, node.pos);	
	case _:
		node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, {
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformer(doBlock));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformer(body));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformer(body));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformer(expr), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformer(condition), transformer(thenBranch), if ((elseBranch != null)) transformer(elseBranch) else null);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : transformer(v.key), value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EStruct(name, {
									var ` = [];
									{
										var ` = 0;
										var ` = fields;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : v.key, value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EKeywordList({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : v.key, value : transformer(v.value)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformer(target) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 23: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var macroName = `;
						var args = `;
						var doBlock = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EMacroCall(macroName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								}, transformer(doBlock));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(if ((module != null)) transformer(module) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformer(left), transformer(right));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var generators = `;
						var filters = `;
						var body = `;
						var into = `;
						var uniq = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFor({
									var ` = [];
									{
										var ` = 0;
										var ` = generators;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, expr : transformer(v.expr)});
										};
									};
									`;
								}, {
									var ` = [];
									{
										var ` = 0;
										var ` = filters;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								}, transformer(body), if ((into != null)) transformer(into) else null, uniq);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({args : v.args, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 51: {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						var after = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EReceive({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								}, if ((after != null)) {timeout : transformer(after.timeout), body : transformer(after.body)} else null);
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = expressions;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EParen(transformer(expr));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 56: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var value = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EModuleAttribute(name, transformer(value));
								var meta = node.metadata;
								var pos = node.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					node;
				}
			};
		};
		return transformed;
	}

	static function supervisorOptionsTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.SupervisorOptionsTransformPass.transform(ast, null);
	}

	static function otpChildSpecTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformCount = 0;
		var transformIdiomaticNode = [null];
		transformIdiomaticNode[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			var nodeWithTransformedChildren = reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, transformIdiomaticNode[0]);
			if (nodeWithTransformedChildren == null) {
				return null;
			};
			if (nodeWithTransformedChildren.metadata != null && nodeWithTransformedChildren.metadata.requiresIdiomaticTransform == true) {
				var transformed = reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.applyIdiomaticEnumTransformation(nodeWithTransformedChildren);
				return transformed;
			};
			return nodeWithTransformedChildren;
		};
		var result = transformIdiomaticNode[0](ast);
		return result;
	}

	static function tupleElemFieldToFunctionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case EField(target, "elem"):
		{ def : EField(transformAST(target, tupleElemFieldToFunctionPass), "elem"), metadata : ast.metadata, pos : ast.pos };	
	case ECall(expr, funcName, args):
		if (funcName == "elem" && expr != null) {
			{ def : ECall(null, "elem", [transformAST(expr, tupleElemFieldToFunctionPass)].concat([for (arg  in  args) transformAST(arg, tupleElemFieldToFunctionPass)])), metadata : ast.metadata, pos : ast.pos };
		} else {
			{ def : ECall(expr != null ? transformAST(expr, tupleElemFieldToFunctionPass) : null, funcName, [for (arg  in  args) transformAST(arg, tupleElemFieldToFunctionPass)]), metadata : ast.metadata, pos : ast.pos };
		};	
	default:
		transformAST(ast, tupleElemFieldToFunctionPass);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var expr = `;
						var funcName = `;
						var args = `;
						{
							if (funcName == "elem" && expr != null) {
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass)].concat({
									var ` = [];
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass));
										};
									};
									`;
								})), metadata : ast.metadata, pos : ast.pos};
							} else {
								{def : reflaxe.elixir.ast.ElixirASTDef.ECall(if (expr != null) {
									reflaxe.elixir.ast.ElixirASTTransformer.transformAST(expr, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
								} else {
									null;
								}, funcName, {
									var ` = [];
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(arg, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass));
										};
									};
									`;
								}), metadata : ast.metadata, pos : ast.pos};
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (` == "elem") {
						{
							var target = `;
							{
								{def : reflaxe.elixir.ast.ElixirASTDef.EField(reflaxe.elixir.ast.ElixirASTTransformer.transformAST(target, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass), "elem"), metadata : ast.metadata, pos : ast.pos};
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.tupleElemFieldToFunctionPass);
				}
			};
		};
	}

	static function idiomaticEnumPatternMatchingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return @:ast(switch (ast.def) {
	case ECase(expr, clauses):
		var isEnumTagCheck = false;
		var baseExpr = expr;
		switch (expr.def) {
			case ECall(tupleExpr, "elem", [arg]):
				switch (arg.def) {
					case EInteger(0):
						isEnumTagCheck = true;
						baseExpr = tupleExpr;					
					default:
				};			
			case EField(tupleExpr, "elem"):
				isEnumTagCheck = true;
				baseExpr = tupleExpr;			
			default:
		};
		if (isEnumTagCheck) {
			var transformedClauses = [];
			for (clause  in  clauses) {
				var transformedClause = transformEnumClause(clause, baseExpr);
				transformedClauses.push(transformedClause);
			};
			{ def : ECase(baseExpr, transformedClauses), metadata : ast.metadata, pos : ast.pos };
		} else {
			transformAST(ast, idiomaticEnumPatternMatchingPass);
		};	
	default:
		transformAST(ast, idiomaticEnumPatternMatchingPass);	
}) {
			var ` = ast.def;
			if (enumIndex ` == 6) {
				var ` = `[0];
				var ` = `[1];
				{
					var expr = `;
					var clauses = `;
					{
						var isEnumTagCheck = false;
						var baseExpr = expr;
						@:ast(switch (expr.def) {
	case ECall(tupleExpr, "elem", [arg]):
		switch (arg.def) {
			case EInteger(0):
				isEnumTagCheck = true;
				baseExpr = tupleExpr;			
			default:
		};	
	case EField(tupleExpr, "elem"):
		isEnumTagCheck = true;
		baseExpr = tupleExpr;	
	default:
}) {
							var ` = expr.def;
							switch (enumIndex `) {
								case 22: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (` == "elem") {
										if (`.length == 1) {
											var ` = `[0];
											{
												var arg = `;
												var tupleExpr = `;
												{
													@:ast(switch (arg.def) {
	case EInteger(0):
		isEnumTagCheck = true;
		baseExpr = tupleExpr;	
	default:
}) {
														var ` = arg.def;
														if (enumIndex ` == 33) {
															var ` = `[0];
															if (` == 0) {
																{
																	isEnumTagCheck = true;
																	baseExpr = tupleExpr;
																};
															} else {};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
								case 28: {
									var ` = `[0];
									var ` = `[1];
									if (` == "elem") {
										{
											var tupleExpr = `;
											{
												isEnumTagCheck = true;
												baseExpr = tupleExpr;
											};
										};
									} else {};
								};
								default: {}
							};
						};
						if (isEnumTagCheck) {
							var transformedClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var transformedClause = reflaxe.elixir.ast.ElixirASTTransformer.transformEnumClause(clause, baseExpr);
									transformedClauses.push(transformedClause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(baseExpr, transformedClauses), metadata : ast.metadata, pos : ast.pos};
						} else {
							reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass);
						};
					};
				};
			} else {
				reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reflaxe.elixir.ast.ElixirASTTransformer.idiomaticEnumPatternMatchingPass);
			};
		};
	}

	static function transformEnumClause(clause:reflaxe.elixir.ast.ECaseClause, baseExpr:reflaxe.elixir.ast.ElixirAST) {
		var tagValue = @:ast(switch (clause.pattern) {
	case PLiteral(ast):
		switch (ast.def) {
			case EInteger(tag):
				tag;			
			default:
				return clause;			
		};	
	default:
		return clause;	
}) {
			var ` = clause.pattern;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var ast = `;
					{
						@:ast(switch (ast.def) {
	case EInteger(tag):
		tag;	
	default:
		return clause;	
}) {
							var ` = ast.def;
							if (enumIndex ` == 33) {
								var ` = `[0];
								{
									var tag = `;
									{
										tag;
									};
								};
							} else {
								return clause;
							};
						};
					};
				};
			} else {
				return clause;
			};
		};
		var extractedParams = reflaxe.elixir.ast.ElixirASTTransformer.analyzeEnumParameterExtraction(clause.body, baseExpr);
		var tuplePattern = if (extractedParams.length > 0) {
			var patterns = [reflaxe.elixir.ast.EPattern.PLiteral({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(tagValue), metadata : {}, pos : pos};
			})];
			{
				var ` = 0;
				while (` < extractedParams.length) {
					var param = extractedParams[`];
					++ `;
					patterns.push(reflaxe.elixir.ast.EPattern.PVar(param.finalName));
				};
			};
			reflaxe.elixir.ast.EPattern.PTuple(patterns);
		} else {
			reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PLiteral({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(tagValue), metadata : {}, pos : pos};
			}), reflaxe.elixir.ast.EPattern.PWildcard]);
		};
		var cleanedBody = reflaxe.elixir.ast.ElixirASTTransformer.removeEnumParameterExtractions(clause.body, extractedParams);
		return {pattern : tuplePattern, guard : clause.guard, body : cleanedBody};
	}

	static function analyzeEnumParameterExtraction(body:reflaxe.elixir.ast.ElixirAST, baseExpr:reflaxe.elixir.ast.ElixirAST) {
		var params = [];
		@:ast(switch (body.def) {
	case EBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.def) {
				case EMatch(PVar(varName), ast):
					switch (ast.def) {
						case ECall(tupleExpr, "elem", [arg]):
							switch (arg.def) {
								case EInteger(1):
									if (astEquals(tupleExpr, baseExpr)) {
										var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
										if (finalName != null) {
											params.push({ tempName : varName, finalName : finalName });
										} else {
											params.push({ tempName : varName, finalName : varName.replace("_", "") });
										};
									};								
								default:
							};						
						default:
					};				
				default:
			};
		};	
	default:
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), ast):
		switch (ast.def) {
			case ECall(tupleExpr, "elem", [arg]):
				switch (arg.def) {
					case EInteger(1):
						if (astEquals(tupleExpr, baseExpr)) {
							var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
							if (finalName != null) {
								params.push({ tempName : varName, finalName : finalName });
							} else {
								params.push({ tempName : varName, finalName : varName.replace("_", "") });
							};
						};					
					default:
				};			
			default:
		};	
	default:
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var ast = `;
												{
													@:ast(switch (ast.def) {
	case ECall(tupleExpr, "elem", [arg]):
		switch (arg.def) {
			case EInteger(1):
				if (astEquals(tupleExpr, baseExpr)) {
					var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
					if (finalName != null) {
						params.push({ tempName : varName, finalName : finalName });
					} else {
						params.push({ tempName : varName, finalName : varName.replace("_", "") });
					};
				};			
			default:
		};	
	default:
}) {
														var ` = ast.def;
														if (enumIndex ` == 22) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == "elem") {
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var arg = `;
																		var tupleExpr = `;
																		{
																			@:ast(switch (arg.def) {
	case EInteger(1):
		if (astEquals(tupleExpr, baseExpr)) {
			var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
			if (finalName != null) {
				params.push({ tempName : varName, finalName : finalName });
			} else {
				params.push({ tempName : varName, finalName : varName.replace("_", "") });
			};
		};	
	default:
}) {
																				var ` = arg.def;
																				if (enumIndex ` == 33) {
																					var ` = `[0];
																					if (` == 1) {
																						{
																							if (reflaxe.elixir.ast.ElixirASTTransformer.astEquals(tupleExpr, baseExpr)) {
																								var finalName = reflaxe.elixir.ast.ElixirASTTransformer.findSubsequentAssignment(exprs, StringTools.replace(varName, "_", ""));
																								if (finalName != null) {
																									params.push({tempName : varName, finalName : finalName});
																								} else {
																									params.push({tempName : varName, finalName : StringTools.replace(varName, "_", "")});
																								};
																							};
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																} else {};
															} else {};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
				};
			} else {};
		};
		return params;
	}

	static function findSubsequentAssignment(exprs:Array<reflaxe.elixir.ast.ElixirAST>, tempVarWithoutUnderscore:String) {
		{
			var ` = 0;
			while (` < exprs.length) {
				var expr = exprs[`];
				++ `;
				@:ast(switch (expr.def) {
	case EMatch(PVar(finalName), ast):
		switch (ast.def) {
			case EVar(srcVar):
				if (srcVar == tempVarWithoutUnderscore) {
					return finalName;
				};			
			default:
		};	
	default:
}) {
					var ` = expr.def;
					if (enumIndex ` == 8) {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var finalName = `;
								var ast = `;
								{
									@:ast(switch (ast.def) {
	case EVar(srcVar):
		if (srcVar == tempVarWithoutUnderscore) {
			return finalName;
		};	
	default:
}) {
										var ` = ast.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var srcVar = `;
												{
													if (srcVar == tempVarWithoutUnderscore) {
														return finalName;
													};
												};
											};
										} else {};
									};
								};
							};
						} else {};
					} else {};
				};
			};
		};
		return null;
	}

	static function removeEnumParameterExtractions(body:reflaxe.elixir.ast.ElixirAST, extractedParams:Array<{ tempName : String, finalName : String }>) {
		@:ast(switch (body.def) {
	case EBlock(exprs):
		var cleanedExprs = [];
		var skip = false;
		for (i  in  0 ... exprs.length) {
			var expr = exprs[i];
			var shouldSkip = false;
			switch (expr.def) {
				case EMatch(PVar(varName), ast):
					switch (ast.def) {
						case ECall(_, "elem", [arg]):
							switch (arg.def) {
								case EInteger(1):
									for (param  in  extractedParams) {
										if (varName == param.tempName) {
											shouldSkip = true;
											break;
										};
									};								
								default:
							};						
						case EVar(srcVar):
							for (param  in  extractedParams) {
								if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
									shouldSkip = true;
									break;
								};
							};						
						default:
					};				
				default:
			};
			if (!shouldSkip) {
				cleanedExprs.push(expr);
			};
		};
		if (cleanedExprs.length == 1) {
			return cleanedExprs[0];
		} else if (cleanedExprs.length == 0) {
			return makeAST(EAtom(ElixirAtom.nil()));
		} else {
			return { def : EBlock(cleanedExprs), metadata : body.metadata, pos : body.pos };
		};	
	default:
		return body;	
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var cleanedExprs = [];
						var skip = false;
						{
							var ` = 0;
							var ` = exprs.length;
							while (` < `) {
								var i = ` ++;
								var expr = exprs[i];
								var shouldSkip = false;
								@:ast(switch (expr.def) {
	case EMatch(PVar(varName), ast):
		switch (ast.def) {
			case ECall(_, "elem", [arg]):
				switch (arg.def) {
					case EInteger(1):
						for (param  in  extractedParams) {
							if (varName == param.tempName) {
								shouldSkip = true;
								break;
							};
						};					
					default:
				};			
			case EVar(srcVar):
				for (param  in  extractedParams) {
					if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
						shouldSkip = true;
						break;
					};
				};			
			default:
		};	
	default:
}) {
									var ` = expr.def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var ast = `;
												{
													@:ast(switch (ast.def) {
	case ECall(_, "elem", [arg]):
		switch (arg.def) {
			case EInteger(1):
				for (param  in  extractedParams) {
					if (varName == param.tempName) {
						shouldSkip = true;
						break;
					};
				};			
			default:
		};	
	case EVar(srcVar):
		for (param  in  extractedParams) {
			if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
				shouldSkip = true;
				break;
			};
		};	
	default:
}) {
														var ` = ast.def;
														switch (enumIndex `) {
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (` == "elem") {
																	if (`.length == 1) {
																		var ` = `[0];
																		{
																			var arg = `;
																			{
																				@:ast(switch (arg.def) {
	case EInteger(1):
		for (param  in  extractedParams) {
			if (varName == param.tempName) {
				shouldSkip = true;
				break;
			};
		};	
	default:
}) {
																					var ` = arg.def;
																					if (enumIndex ` == 33) {
																						var ` = `[0];
																						if (` == 1) {
																							{
																								{
																									var ` = 0;
																									while (` < extractedParams.length) {
																										var param = extractedParams[`];
																										++ `;
																										if (varName == param.tempName) {
																											shouldSkip = true;
																											break;
																										};
																									};
																								};
																							};
																						} else {};
																					} else {};
																				};
																			};
																		};
																	} else {};
																} else {};
															};
															case 38: {
																var ` = `[0];
																{
																	var srcVar = `;
																	{
																		{
																			var ` = 0;
																			while (` < extractedParams.length) {
																				var param = extractedParams[`];
																				++ `;
																				if (varName == param.finalName && srcVar == StringTools.replace(param.tempName, "_", "")) {
																					shouldSkip = true;
																					break;
																				};
																			};
																		};
																	};
																};
															};
															default: {}
														};
													};
												};
											};
										} else {};
									} else {};
								};
								if (! shouldSkip) {
									cleanedExprs.push(expr);
								};
							};
						};
						if (cleanedExprs.length == 1) {
							return cleanedExprs[0];
						} else {
							if (cleanedExprs.length == 0) {
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "nil"), metadata : {}, pos : pos};
								};
							} else {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(cleanedExprs), metadata : body.metadata, pos : body.pos};
							};
						};
					};
				};
			} else {
				return body;
			};
		};
	}

	static function astEquals(a:reflaxe.elixir.ast.ElixirAST, b:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch ([a.def, b.def]) {
	case [EVar(name1), EVar(name2)]:
		name1 == name2;	
	case [EField(obj1, field1), EField(obj2, field2)]:
		field1 == field2 && astEquals(obj1, obj2);	
	default:
		false;	
}) {
			var ` = a.def;
			var ` = b.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 28) {
						var ` = `[0];
						var ` = `[1];
						{
							var obj2 = `;
							var field2 = `;
							var field1 = `;
							var obj1 = `;
							{
								field1 == field2 && reflaxe.elixir.ast.ElixirASTTransformer.astEquals(obj1, obj2);
							};
						};
					} else {
						false;
					};
				};
				case 38: {
					var ` = `[0];
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var name2 = `;
							var name1 = `;
							{
								name1 == name2;
							};
						};
					} else {
						false;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function transformIdiomaticEnum(elements:Array<reflaxe.elixir.ast.ElixirAST>, node:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.applyIdiomaticEnumTransformation(node);
	}

	static function isModuleName(s:String) {
		if (s == null || s.length == 0) {
			return false;
		};
		var firstChar = s.charAt(0);
		if (firstChar != firstChar.toUpperCase()) {
			return false;
		};
		var segments = s.split(".");
		{
			var ` = 0;
			while (` < segments.length) {
				var segment = segments[`];
				++ `;
				if (segment.length == 0) {
					return false;
				};
				var first = segment.charAt(0);
				if (first != first.toUpperCase() || first == first.toLowerCase()) {
					return false;
				};
			};
		};
		return true;
	}

	static function toIdiomaticAtom(tag:String) {
		@:ast(switch (tag.toLowerCase()) {
	case "ok":
		return "ok";	
	case "error":
		return "error";	
	case "some":
		return "ok";	
	case "none":
		return "error";	
	default:
		return toSnakeCase(tag);	
}) {
			var ` = tag.toLowerCase();
			switch (`) {
				case "error": {
					{
						return "error";
					};
				};
				case "none": {
					{
						return "error";
					};
				};
				case "ok": {
					{
						return "ok";
					};
				};
				case "some": {
					{
						return "ok";
					};
				};
				default: {
					return reflaxe.elixir.ast.ElixirASTTransformer.toSnakeCase(tag);
				}
			};
		};
	}

	static function underscoreVariableCleanupPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var underscoreVars = {
			{};
			new haxe.ds.StringMap();
		};
		var varDeclarations = {
			{};
			new haxe.ds.StringMap();
		};
		var allUnderscoreVars = {
			{};
			new haxe.ds.StringMap();
		};
		var collectPatternVars = [null];
		collectPatternVars[0] = function(pattern:reflaxe.elixir.ast.EPattern, vars:Map<String, Bool>) {
			@:ast(switch (pattern) {
	case PVar(name):
		vars.set(name, true);
		if (name.charAt(0) == "_" && name.length > 1) {
			allUnderscoreVars.set(name, true);
			if (!underscoreVars.exists(name)) {
				underscoreVars.set(name, false);
			};
		};	
	case PTuple(patterns):
		for (p  in  patterns) collectPatternVars(p, vars);	
	case PList(patterns):
		for (p  in  patterns) collectPatternVars(p, vars);	
	case PCons(head, tail):
		collectPatternVars(head, vars);
		collectPatternVars(tail, vars);	
	case PMap(pairs):
		for (pair  in  pairs) collectPatternVars(pair.value, vars);	
	case PStruct(name, fields):
		for (field  in  fields) collectPatternVars(field.value, vars);	
	case _:
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							{
								vars.set(name, true);
							};
							if (name.charAt(0) == "_" && name.length > 1) {
								{
									allUnderscoreVars.set(name, true);
								};
								if (! underscoreVars.exists(name)) {
									{
										underscoreVars.set(name, false);
									};
								};
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									collectPatternVars[0](p, vars);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							{
								var ` = 0;
								while (` < patterns.length) {
									var p = patterns[`];
									++ `;
									collectPatternVars[0](p, vars);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							collectPatternVars[0](head, vars);
							collectPatternVars[0](tail, vars);
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									collectPatternVars[0](pair.value, vars);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var name = `;
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var field = fields[`];
									++ `;
									collectPatternVars[0](field.value, vars);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		var collectVariables = [null];
		collectVariables[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EMatch(pattern, expr):
		collectPatternVars(pattern, varDeclarations);
		collectVariables(expr);	
	case EVar(name):
		if (name.charAt(0) == "_" && name.length > 1) {
			underscoreVars.set(name, true);
			allUnderscoreVars.set(name, true);
		};	
	case ERemoteCall(module, funcName, args):
		if (module != null) collectVariables(module);
		for (arg  in  args) {
			collectVariables(arg);
		};	
	case EFn(clauses):
		for (clause  in  clauses) {
			if (clause.guard != null) collectVariables(clause.guard);
			collectVariables(clause.body);
		};	
	case _:
		iterateAST(node, collectVariables);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								collectPatternVars[0](pattern, varDeclarations);
								collectVariables[0](expr);
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var funcName = `;
							var args = `;
							{
								if (module != null) {
									collectVariables[0](module);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										collectVariables[0](arg);
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (name.charAt(0) == "_" && name.length > 1) {
									{
										underscoreVars.set(name, true);
									};
									{
										allUnderscoreVars.set(name, true);
									};
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										if (clause.guard != null) {
											collectVariables[0](clause.guard);
										};
										collectVariables[0](clause.body);
									};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.iterateAST(node, collectVariables[0]);
					}
				};
			};
		};
		collectVariables[0](ast);
		var renameMap = {
			{};
			new haxe.ds.StringMap();
		};
		for (varName in allUnderscoreVars.keys()) {
			var isUsed = underscoreVars.exists(varName) && cast underscoreVars.get(varName);
			if (isUsed) {
				if (new EReg("^_g(_?\\d*)?$", "").match(varName)) {
					continue;
				};
				if (new EReg("^_\\d+$", "").match(varName)) {
					var newName = "temp" + varName.substr(1, null);
					{
						renameMap.set(varName, newName);
					};
				};
			} else {};
		};
		if (renameMap.keys().hasNext()) {
			return reflaxe.elixir.ast.ElixirASTTransformer.applyVariableRenaming(ast, renameMap);
		};
		return ast;
	}

	static function applyVariableRenaming(ast:reflaxe.elixir.ast.ElixirAST, renameMap:Map<String, String>) {
		var renameInPattern = [null];
		renameInPattern[0] = function(pattern:reflaxe.elixir.ast.EPattern) {
			return @:ast(switch (pattern) {
	case PVar(name):
		renameMap.exists(name) ? PVar(renameMap.get(name)) : pattern;	
	case PTuple(patterns):
		PTuple(patterns.map(renameInPattern));	
	case PList(patterns):
		PList(patterns.map(renameInPattern));	
	case PCons(head, tail):
		PCons(renameInPattern(head), renameInPattern(tail));	
	case PMap(pairs):
		PMap(pairs.map(function(p) ->  @:implicitReturn return { key : p.key, value : renameInPattern(p.value) }));	
	case PStruct(name, fields):
		PStruct(name, fields.map(function(f) ->  @:implicitReturn return { key : f.key, value : renameInPattern(f.value) }));	
	case _:
		pattern;	
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							if (renameMap.exists(name)) {
								reflaxe.elixir.ast.EPattern.PVar(cast renameMap.get(name));
							} else {
								pattern;
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							reflaxe.elixir.ast.EPattern.PTuple({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var patterns = `;
						{
							reflaxe.elixir.ast.EPattern.PList({
								var f = renameInPattern[0];
								{
									var ` = [];
									{
										var ` = 0;
										var ` = patterns;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(f(v));
										};
									};
									`;
								};
							});
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							reflaxe.elixir.ast.EPattern.PCons(renameInPattern[0](head), renameInPattern[0](tail));
						};
					};
				};
				case 5: {
					var ` = pattern[0];
					{
						var pairs = `;
						{
							reflaxe.elixir.ast.EPattern.PMap({
								var ` = [];
								{
									var ` = 0;
									var ` = pairs;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(p:{ value : reflaxe.elixir.ast.EPattern, key : reflaxe.elixir.ast.ElixirAST }) {
											return {key : p.key, value : renameInPattern[0](p.value)};
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				case 6: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var name = `;
						var fields = `;
						{
							reflaxe.elixir.ast.EPattern.PStruct(name, {
								var ` = [];
								{
									var ` = 0;
									var ` = fields;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(f:{ value : reflaxe.elixir.ast.EPattern, key : String }) {
											return {key : f.key, value : renameInPattern[0](f.value)};
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				default: {
					pattern;
				}
			};
		};
		var renameInAST = [null];
		renameInAST[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			var transformed = @:ast(switch (node.def) {
	case EVar(name):
		if (renameMap.exists(name)) {
			makeASTWithMeta(EVar(renameMap.get(name)), node.metadata, node.pos);
		} else {
			node;
		};	
	case EMatch(pattern, expr):
		makeASTWithMeta(EMatch(renameInPattern(pattern), renameInAST(expr)), node.metadata, node.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(renameInAST(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : renameInPattern(c.pattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) })), node.metadata, node.pos);	
	case EReceive(clauses, after):
		makeASTWithMeta(EReceive(clauses.map(function(c) ->  @:implicitReturn return { pattern : renameInPattern(c.pattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) }), after != null ? { timeout : renameInAST(after.timeout), body : renameInAST(after.body) } : null), node.metadata, node.pos);	
	case EFn(clauses):
		makeASTWithMeta(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args.map(renameInPattern), guard : c.guard != null ? renameInAST(c.guard) : null, body : renameInAST(c.body) })), node.metadata, node.pos);	
	case _:
		transformAST(node, renameInAST);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECase(renameInAST[0](expr), {
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : renameInPattern[0](v.pattern), guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(renameInPattern[0](pattern), renameInAST[0](expr));
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (renameMap.exists(name)) {
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renameMap.get(name));
										var meta = node.metadata;
										var pos = node.pos;
										{def : def, metadata : meta, pos : pos};
									};
								} else {
									node;
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({args : {
													var _this = v.args;
													var f = renameInPattern[0];
													{
														var ` = [];
														{
															var ` = 0;
															var ` = _this;
															while ((` < `.length)) {
																var v = `[`];
																++ `;
																`.push(f(v));
															};
														};
														`;
													};
												}, guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									});
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 51: {
						var ` = `[0];
						var ` = `[1];
						{
							var clauses = `;
							var after = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EReceive({
										var ` = [];
										{
											var ` = 0;
											var ` = clauses;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push({pattern : renameInPattern[0](v.pattern), guard : if ((v.guard != null)) renameInAST[0](v.guard) else null, body : renameInAST[0](v.body)});
											};
										};
										`;
									}, if ((after != null)) {timeout : renameInAST[0](after.timeout), body : renameInAST[0](after.body)} else null);
									var meta = node.metadata;
									var pos = node.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, renameInAST[0]);
					}
				};
			};
			return transformed;
		};
		return renameInAST[0](ast);
	}

	static function fixBareConcatenationsPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var fixConcatenations = [null];
		fixConcatenations[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null) {
				return null;
			};
			return @:ast(switch (node.def) {
	case EBlock(statements):
		var fixedStatements = [];
		for (stmt  in  statements) {
			if (stmt == null) {
				continue;
			};
			var fixed = switch (stmt.def) {
				case EBinary(Concat, left, right):
					switch (left.def) {
						case EVar(name):
							makeAST(EBinary(Match, left, stmt));						
						case EField(structVar, fieldName):
							switch (structVar.def) {
								case EVar("struct"):
									makeAST(EBinary(Match, structVar, makeAST(EStructUpdate(structVar, [{ key : fieldName, value : stmt }]))));								
								default:
									stmt;								
							};						
						default:
							stmt;						
					};				
				default:
					fixConcatenations(stmt);				
			};
			fixedStatements.push(fixed);
		};
		makeAST(EBlock(fixedStatements));	
	case EList(elements):
		var fixedElements = [for (e  in  elements) fixConcatenations(e)];
		makeAST(EList(fixedElements));	
	default:
		transformAST(node, fixConcatenations);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 15: {
						var ` = `[0];
						{
							var elements = `;
							{
								var fixedElements = {
									var ` = [];
									{
										var ` = 0;
										while (` < elements.length) {
											var e = elements[`];
											++ `;
											`.push(fixConcatenations[0](e));
										};
									};
									`;
								};
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EList(fixedElements), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var statements = `;
							{
								var fixedStatements = [];
								{
									var ` = 0;
									while (` < statements.length) {
										var stmt = statements[`];
										++ `;
										if (stmt == null) {
											continue;
										};
										var fixed = @:ast(switch (stmt.def) {
	case EBinary(Concat, left, right):
		switch (left.def) {
			case EVar(name):
				makeAST(EBinary(Match, left, stmt));			
			case EField(structVar, fieldName):
				switch (structVar.def) {
					case EVar("struct"):
						makeAST(EBinary(Match, structVar, makeAST(EStructUpdate(structVar, [{ key : fieldName, value : stmt }]))));					
					default:
						stmt;					
				};			
			default:
				stmt;			
		};	
	default:
		fixConcatenations(stmt);	
}) {
											var ` = stmt.def;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 23) {
													{
														var left = `;
														var right = `;
														{
															@:ast(switch (left.def) {
	case EVar(name):
		makeAST(EBinary(Match, left, stmt));	
	case EField(structVar, fieldName):
		switch (structVar.def) {
			case EVar("struct"):
				makeAST(EBinary(Match, structVar, makeAST(EStructUpdate(structVar, [{ key : fieldName, value : stmt }]))));			
			default:
				stmt;			
		};	
	default:
		stmt;	
}) {
																var ` = left.def;
																switch (enumIndex `) {
																	case 28: {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var structVar = `;
																			var fieldName = `;
																			{
																				@:ast(switch (structVar.def) {
	case EVar("struct"):
		makeAST(EBinary(Match, structVar, makeAST(EStructUpdate(structVar, [{ key : fieldName, value : stmt }]))));	
	default:
		stmt;	
}) {
																					var ` = structVar.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						if (` == "struct") {
																							{
																								{
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, structVar, {
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EStructUpdate(structVar, [{key : fieldName, value : stmt}]), metadata : {}, pos : pos};
																									}), metadata : {}, pos : pos};
																								};
																							};
																						} else {
																							stmt;
																						};
																					} else {
																						stmt;
																					};
																				};
																			};
																		};
																	};
																	case 38: {
																		var ` = `[0];
																		{
																			var name = `;
																			{
																				{
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, left, stmt), metadata : {}, pos : pos};
																				};
																			};
																		};
																	};
																	default: {
																		stmt;
																	}
																};
															};
														};
													};
												} else {
													fixConcatenations[0](stmt);
												};
											} else {
												fixConcatenations[0](stmt);
											};
										};
										fixedStatements.push(fixed);
									};
								};
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(fixedStatements), metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, fixConcatenations[0]);
					}
				};
			};
		};
		return fixConcatenations[0](ast);
	}

	static function unrolledComprehensionReconstructionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var reconstructComprehension = [null];
		reconstructComprehension[0] = function(ast:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (ast.def) {
	case EBlock(stmts) if (ast.metadata != null && ast.metadata.isUnrolledComprehension == true):
		var comprehension = analyzeAndReconstructComprehension(stmts);
		if (comprehension != null) {
			comprehension;
		} else {
			ast;
		};	
	case _:
		transformAST(ast, reconstructComprehension);	
}) {
				var ` = ast.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (ast.metadata != null && ast.metadata.isUnrolledComprehension == true) {
							var comprehension = reflaxe.elixir.ast.ElixirASTTransformer.analyzeAndReconstructComprehension(stmts);
							if (comprehension != null) {
								comprehension;
							} else {
								ast;
							};
						} else {
							reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reconstructComprehension[0]);
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.transformAST(ast, reconstructComprehension[0]);
				};
			};
		};
		return reconstructComprehension[0](ast);
	}

	static function analyzeAndReconstructComprehension(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (stmts.length < 3) {
			return null;
		};
		var iterVar = @:ast(switch (stmts[0].def) {
	case EBinary(Match, { def : EVar(varName) }, { def : EList([]) }):
		varName;	
	case _:
		return null;	
}) {
			var ` = stmts[0].def;
			if (enumIndex ` == 26) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 27) {
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 15) {
									var ` = `[0];
									if (`.length == 0) {
										{
											var varName = `;
											{
												varName;
											};
										};
									} else {
										return null;
									};
								} else {
									return null;
								};
							};
						} else {
							return null;
						};
					};
				} else {
					return null;
				};
			} else {
				return null;
			};
		};
		var elements = [];
		{
			var ` = 1;
			var ` = stmts.length - 1;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (stmts[i].def) {
	case EBinary(Match, { def : EVar(v) }, { def : EBinary(Concat, { def : EVar(v2) }, { def : EList([elem]) }) }) if (v == iterVar && v2 == iterVar):
		elements.push(elem);	
	case EBinary(Concat, { def : EVar(v) }, { def : EList([elem]) }) if (v == iterVar):
		elements.push(elem);	
	case _:
}) {
					var ` = stmts[i].def;
					if (enumIndex ` == 26) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						switch (enumIndex `) {
							case 23: {
								{
									var ` = `.def;
									var ` = `.metadata;
									var ` = `.pos;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											if (enumIndex ` == 15) {
												var ` = `[0];
												if (`.length == 1) {
													var ` = `[0];
													{
														var elem = `;
														var v = `;
														if (v == iterVar) {
															elements.push(elem);
														} else {};
													};
												} else {};
											} else {};
										};
									} else {};
								};
							};
							case 27: {
								{
									var ` = `.def;
									var ` = `.metadata;
									var ` = `.pos;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 23) {
													{
														var ` = `.def;
														var ` = `.metadata;
														var ` = `.pos;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 15) {
																	var ` = `[0];
																	if (`.length == 1) {
																		var ` = `[0];
																		{
																			var elem = `;
																			var v2 = `;
																			var v = `;
																			if (v == iterVar && v2 == iterVar) {
																				elements.push(elem);
																			} else {};
																		};
																	} else {};
																} else {};
															};
														} else {};
													};
												} else {};
											} else {};
										};
									} else {};
								};
							};
							default: {}
						};
					} else {};
				};
			};
		};
		var returnsVar = @:ast(switch (stmts[stmts.length - 1].def) {
	case EVar(v) if (v == iterVar):
		true;	
	case _:
		false;	
}) {
			var ` = stmts[stmts.length - 1].def;
			if (enumIndex ` == 38) {
				var ` = `[0];
				{
					var v = `;
					if (v == iterVar) {
						true;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
		if (! returnsVar || elements.length == 0) {
			return null;
		};
		var rangeEnd = elements.length - 1;
		var isSimpleRange = true;
		var hasNestedComprehensions = false;
		{
			var ` = 0;
			var ` = elements.length;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (elements[i].def) {
	case EInteger(val):
		if (val != i) {
			isSimpleRange = false;
		};	
	case EList(_):
		hasNestedComprehensions = true;
		isSimpleRange = false;	
	case _:
		isSimpleRange = false;	
}) {
					var ` = elements[i].def;
					switch (enumIndex `) {
						case 15: {
							var ` = `[0];
							{
								hasNestedComprehensions = true;
								isSimpleRange = false;
							};
						};
						case 33: {
							var ` = `[0];
							{
								var val = `;
								{
									if (val != i) {
										isSimpleRange = false;
									};
								};
							};
						};
						default: {
							isSimpleRange = false;
						}
					};
				};
			};
		};
		if (isSimpleRange) {
			var range = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(rangeEnd), metadata : {}, pos : pos};
				}, false), metadata : {}, pos : pos};
			};
			var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("i"), expr : range};
			var body = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("i"), metadata : {}, pos : pos};
			};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], body, null, null), metadata : {}, pos : pos};
			};
		} else {
			if (hasNestedComprehensions) {
				var range = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
					}, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(rangeEnd), metadata : {}, pos : pos};
					}, false), metadata : {}, pos : pos};
				};
				var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("i"), expr : range};
				var body = elements[0];
				@:ast(switch (body.def) {
	case EList(innerElements):
		var innerComprehension = tryReconstructInnerComprehension(innerElements);
		if (innerComprehension != null) {
			body = innerComprehension;
		};	
	case _:
}) {
					var ` = body.def;
					if (enumIndex ` == 15) {
						var ` = `[0];
						{
							var innerElements = `;
							{
								var innerComprehension = reflaxe.elixir.ast.ElixirASTTransformer.tryReconstructInnerComprehension(innerElements);
								if (innerComprehension != null) {
									body = innerComprehension;
								};
							};
						};
					} else {};
				};
				return {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], body, null, null), metadata : {}, pos : pos};
				};
			} else {
				return null;
			};
		};
	}

	static function tryReconstructInnerComprehension(elements:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (elements.length == 0) {
			return null;
		};
		var isSimpleRange = true;
		{
			var ` = 0;
			var ` = elements.length;
			while (` < `) {
				var i = ` ++;
				@:ast(switch (elements[i].def) {
	case EInteger(val):
		if (val != i) {
			isSimpleRange = false;
			break;
		};	
	case _:
		isSimpleRange = false;
		break;	
}) {
					var ` = elements[i].def;
					if (enumIndex ` == 33) {
						var ` = `[0];
						{
							var val = `;
							{
								if (val != i) {
									isSimpleRange = false;
									break;
								};
							};
						};
					} else {
						isSimpleRange = false;
						break;
					};
				};
			};
		};
		if (isSimpleRange) {
			var rangeEnd = elements.length - 1;
			var range = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(rangeEnd), metadata : {}, pos : pos};
				}, false), metadata : {}, pos : pos};
			};
			var generator = {pattern : reflaxe.elixir.ast.EPattern.PVar("j"), expr : range};
			var body = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("j"), metadata : {}, pos : pos};
			};
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EFor([generator], [], body, null, null), metadata : {}, pos : pos};
			};
		};
		return null;
	}
}