class reflaxe.elixir.ElixirCompiler extends reflaxe.GenericCompiler<reflaxe.elixir.ast.ElixirAST, reflaxe.elixir.ast.ElixirAST, reflaxe.elixir.ast.ElixirAST, reflaxe.elixir.ast.ElixirAST, reflaxe.elixir.ast.ElixirAST> {

	public function new() {
		this.usedLogTrace = false;
		this.moduleBaseTypes = new haxe.ds.StringMap();
		this.modulePackages = new haxe.ds.StringMap();
		this.moduleOutputPaths = new haxe.ds.StringMap();
		this.modulesWithBootstrap = [];
		this.currentCompiledModule = null;
		this.moduleDependencies = new haxe.ds.StringMap();
		this.isInPresenceModule = false;
		this.consumedTempVariables = null;
		this.globalStructParameterMap = new haxe.ds.StringMap();
		this.isCompilingStructMethod = false;
		this.stateThreadingEnabled = false;
		this.currentClassType = null;
		this.currentSwitchCaseBody = null;
		this.currentEnumExtractionIndex = 0;
		this.enumExtractionVars = null;
		this.isInLoopCondition = false;
		this.loopLimitVar = null;
		this.loopCounterVar = null;
		this.isInEnumExtraction = false;
		this.isCompilingCaseArm = false;
		this.isCompilingAbstractMethod = false;
		this.inlineContextMap = new haxe.ds.StringMap();
		this.variableRenameMap = null;
		this.isStatementContext = false;
		this.returnContext = false;
		this.patternUsageContext = null;
		this.currentFunctionParameterMap = new haxe.ds.StringMap();
		this.pendingSourceMapWriters = [];
		this.sourceMapOutputEnabled = false;
		this.currentSourceMapWriter = null;
		this.isInLoopContext = false;
		this.outputDirectory = "lib/";
		this.fileExtension = ".ex";
		super();
		reflaxe.elixir.ElixirCompiler.instance = this;
		this.typer = new reflaxe.elixir.ElixirTyper();
		this.sourceMapOutputEnabled = haxe.macro.Context.defined("source_map_enabled") || haxe.macro.Context.defined("source-map") || haxe.macro.Context.defined("debug");
		reflaxe.elixir.behaviors.BehaviorTransformer.initialize();
		reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer = new reflaxe.elixir.behaviors.BehaviorTransformer();
	}

	@:value(".ex")
	public var fileExtension:String;

	@:value("lib/")
	public var outputDirectory:String;

	var typer:reflaxe.elixir.ElixirTyper;

	@:value(false)
	public var isInLoopContext:Bool;

	@:value(null)
	public var currentSourceMapWriter:Null<reflaxe.elixir.SourceMapWriter>;

	@:value(false)
	public var sourceMapOutputEnabled:Bool;

	@:value([])
	public var pendingSourceMapWriters:Array<reflaxe.elixir.SourceMapWriter>;

	@:value(new Map())
	public var currentFunctionParameterMap:Map<String, String>;

	@:value(null)
	public var patternUsageContext:Null<Map<String, Bool>>;

	@:value(false)
	public var returnContext:Bool;

	@:value(false)
	public var isStatementContext:Bool;

	@:value(null)
	public var variableRenameMap:Null<Map<String, String>>;

	@:value(new Map<String,String>())
	public var inlineContextMap:Map<String, String>;

	@:value(false)
	var isCompilingAbstractMethod:Bool;

	@:value(false)
	public var isCompilingCaseArm:Bool;

	@:value(false)
	public var isInEnumExtraction:Bool;

	@:value(null)
	public var loopCounterVar:String;

	@:value(null)
	public var loopLimitVar:String;

	@:value(false)
	public var isInLoopCondition:Bool;

	@:value(null)
	public var enumExtractionVars:Null<Array<{ varName : String, index : Int }>>;

	@:value(0)
	public var currentEnumExtractionIndex:Int;

	@:value(null)
	public var currentSwitchCaseBody:Null<haxe.macro.TypedExpr>;

	@:value(null)
	public var currentClassType:Null<haxe.macro.ClassType>;

	@:value(false)
	public var stateThreadingEnabled:Bool;

	@:value(false)
	public var isCompilingStructMethod:Bool;

	@:value(new Map())
	public var globalStructParameterMap:Map<String, String>;

	@:value(null)
	public var consumedTempVariables:Null<Map<String, String>>;

	@:value(false)
	public var isInPresenceModule:Bool;

	@:value(new Map())
	public var moduleDependencies:Map<String, Map<String, Bool>>;

	@:value(null)
	public var currentCompiledModule:String;

	@:value([])
	public var modulesWithBootstrap:Array<String>;

	@:value(new Map())
	public var moduleOutputPaths:Map<String, String>;

	@:value(new Map())
	public var modulePackages:Map<String, Array<String>>;

	@:value(new Map())
	public var moduleBaseTypes:Map<String, haxe.macro.BaseType>;

	@:value(false)
	public var usedLogTrace:Bool;

	public function filterTypes(moduleTypes:Array<haxe.macro.ModuleType>) {
		var result = if (moduleTypes != null) {
			moduleTypes.copy();
		} else {
			[];
		};
		var seen = {
			{};
			new haxe.ds.StringMap();
		};
		{
			var ` = 0;
			while (` < result.length) {
				var mt = result[`];
				++ `;
				var p = reflaxe.helpers.ModuleTypeHelper.getPath(mt);
				if (p != null) {
					{
						seen.set(p, true);
					};
				};
			};
		};
		try {
			{
				var ` = 0;
				while (` < result.length) {
					var mt = result[`];
					++ `;
					@:ast(switch (mt) {
	case TClassDecl(clsRef):
		var cls = clsRef.get();
		if (cls.meta != null && cls.meta.has(":repo")) { };	
	case _:
}) if (enumIndex mt == 0) {
						var ` = mt[0];
						{
							var clsRef = `;
							{
								var cls = clsRef.get();
								if (cls.meta != null && cls.meta.has(":repo")) {};
							};
						};
					} else {};
				};
			};
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
		try {
			var mods = reflaxe.elixir.macros.RepoDiscovery.getDiscovered();
			if (mods != null) {
				{
					var ` = 0;
					while (` < mods.length) {
						var mod = mods[`];
						++ `;
						try {
							var t = haxe.macro.Context.getType(mod);
							if (t != null) {
								var mt = reflaxe.helpers.TypeHelper.toModuleType(t);
								if (mt != null) {
									var pth = reflaxe.helpers.ModuleTypeHelper.getPath(mt);
									if (pth != null && ! seen.exists(pth)) {
										result.push(mt);
										{
											seen.set(pth, true);
										};
									};
								};
							};
						} catch (`:Dynamic) {
							{};
							{};
							if (true) {
								{};
								{};
							} else throw `;
						};
					};
				};
			};
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
		return result;
	}

	public function shouldGenerateClass(classType:haxe.macro.ClassType) {
		if (this.shouldSuppressStdEmission(classType)) {
			return false;
		};
		if (StringTools.startsWith(classType.name, "__") || classType.name == "___Int64") {
			return false;
		};
		if (classType.isExtern && this.hasSpecialAnnotations(classType)) {
			return true;
		};
		if (classType.meta.has(":presence")) {
			return true;
		};
		if (classType.meta.has(":coreApi")) {
			return true;
		};
		if (classType.meta.has(":component")) {
			return true;
		};
		if (classType.meta.has(":application")) {
			return true;
		};
		if (classType.name == "Date" && classType.pack.length == 0) {
			return true;
		};
		return super.shouldGenerateClass(classType);
	}

	function shouldSuppressStdEmission(classType:haxe.macro.ClassType) {
		var n = classType.name;
		if (n == null) {
			return false;
		};
		if (StringTools.endsWith(n, "_Impl_")) {
			return true;
		};
		if (classType.pack != null && classType.pack.length > 0) {
			var top = classType.pack[0];
			if (top == null) {
				top = "";
			};
			if (top == "reflaxe" || top == "js" || top == "genes") {
				return true;
			};
			if (top == "haxe") {
				if (classType.pack.length > 1) {
					var sub = classType.pack[1];
					if (sub != null && StringTools.startsWith(sub, "_")) {
						return true;
					};
				};
			};
			if (StringTools.startsWith(top, "_")) {
				return true;
			};
		};
		return false;
	}

	public function getOriginalVarName(v:haxe.macro.TVar) {
		return reflaxe.helpers.NameMetaHelper.getNameOrMeta(v, ":realPath");
	}

	public function toElixirName(haxeName:String) {
		return reflaxe.elixir.ast.NameUtils.toSnakeCase(haxeName);
	}

	function convertPackageToDirectoryPath(classType:haxe.macro.ClassType) {
		if (classType.pack.length == 0) {
			return "";
		};
		var segments = {
			var _this = classType.pack;
			{
				var ` = [];
				{
					var ` = 0;
					var ` = _this;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(segment:String) {
							return reflaxe.elixir.ast.NameUtils.toSnakeCase(segment);
						}(v));
					};
				};
				`;
			};
		};
		return segments.join("/");
	}

	@:value({ pack : null })
	public function getModuleOutputPath(moduleName:String, pack:Null<Array<String>> = null) {
		var fileName = reflaxe.elixir.ast.NameUtils.toSnakeCase(moduleName) + ".ex";
		if (pack != null && pack.length > 0) {
			var dirPath = {
				var ` = [];
				{
					var ` = 0;
					var ` = pack;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(segment:String) {
							return reflaxe.elixir.ast.NameUtils.toSnakeCase(segment);
						}(v));
					};
				};
				`;
			}.join("/");
			return dirPath + "/" + fileName;
		};
		return fileName;
	}

	@:value({ pack : null })
	function setUniversalOutputPath(moduleName:String, pack:Null<Array<String>> = null) {
		var fileName = reflaxe.elixir.ast.NameUtils.toSnakeCase(moduleName);
		this.setOutputFileName(fileName);
		if (pack != null && pack.length > 0) {
			var dirPath = {
				var ` = [];
				{
					var ` = 0;
					var ` = pack;
					while (` < `.length) {
						var v = `[`];
						++ `;
						`.push(function(segment:String) {
							return reflaxe.elixir.ast.NameUtils.toSnakeCase(segment);
						}(v));
					};
				};
				`;
			}.join("/");
			this.setOutputFileDir(dirPath);
		};
	}

	public function compileClassImpl(classType:haxe.macro.ClassType, varFields:Array<reflaxe.data.ClassVarData>, funcFields:Array<reflaxe.data.ClassFuncData>) {
		if (classType == null) {
			return null;
		};
		if (this.isStandardLibraryClass(classType.name) || this.shouldSuppressStdEmission(classType)) {
			return null;
		};
		var functionUsageCollector = new reflaxe.elixir.helpers.FunctionUsageCollector();
		functionUsageCollector.currentModule = classType.name;
		var moduleName = classType.name;
		var modulePack = classType.pack;
		if (classType.meta.has(":native")) {
			var nativeMeta = classType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		var parts = s.split(".");
		if (parts.length > 1) {
			moduleName = parts[parts.length - 1];
			modulePack = parts.slice(0, parts.length - 1).map(function(p) ->  @:implicitReturn return reflaxe.elixir.ast.NameUtils.toSnakeCase(p));
		} else {
			moduleName = s;
			modulePack = [];
		};	
	default:
}) {
					var ` = nativeMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									var parts = s.split(".");
									if (parts.length > 1) {
										moduleName = parts[parts.length - 1];
										modulePack = {
											var _this = parts.slice(0, parts.length - 1);
											{
												var ` = [];
												{
													var ` = 0;
													var ` = _this;
													while (` < `.length) {
														var v = `[`];
														++ `;
														`.push(function(p:String) {
															return reflaxe.elixir.ast.NameUtils.toSnakeCase(p);
														}(v));
													};
												};
												`;
											};
										};
									} else {
										moduleName = s;
										modulePack = [];
									};
								};
							};
						} else {};
					} else {};
				};
			};
		};
		this.currentCompiledModule = moduleName;
		if (! {
			var this = this.moduleDependencies;
			cast this.exists(moduleName);
		}) {
			{
				var this = this.moduleDependencies;
				var value = {
					{};
					new haxe.ds.StringMap();
				};
				cast this.set(moduleName, value);
			};
		};
		this.setUniversalOutputPath(moduleName, modulePack);
		var outputPath = this.getModuleOutputPath(moduleName, modulePack);
		{
			var this = this.moduleOutputPaths;
			cast this.set(moduleName, outputPath);
		};
		{
			var this = this.moduleBaseTypes;
			cast this.set(moduleName, cast classType);
		};
		this.currentClassType = classType;
		if (reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer != null) {
			var behaviorName = reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.checkAndActivateBehavior(classType);
		};
		var moduleAST = this.buildClassAST(classType, varFields, funcFields);
		if (classType.meta.has(":component")) {
			if (moduleAST != null) {
				if (moduleAST.metadata == null) {
					moduleAST.metadata = {};
				};
				Reflect.setField(moduleAST.metadata, "forceEmit", true);
			};
		};
		if (functionUsageCollector != null && moduleAST != null) {
			if (moduleAST.metadata == null) {
				moduleAST.metadata = {};
			};
			moduleAST.metadata.unusedPrivateFunctions = functionUsageCollector.getUnusedPrivateFunctions();
			moduleAST.metadata.unusedPrivateFunctionsWithArity = functionUsageCollector.getUnusedPrivateFunctionsWithArity();
		};
		return moduleAST;
	}

	public function compileEnumImpl(enumType:haxe.macro.EnumType, options:Array<reflaxe.data.EnumOptionData>) {
		if (enumType == null) {
			return null;
		};
		this.setUniversalOutputPath(enumType.name, enumType.pack);
		var enumAST = this.buildEnumAST(enumType, options);
		return enumAST;
	}

	@:value({ topLevel : false })
	public function compileExpression(expr:haxe.macro.TypedExpr, topLevel:Bool = false) {
		@:ast(switch (expr.expr) {
	case TCall(e, args):
		if (options.targetCodeInjectionName != null) {
			var result = TargetCodeInjection.checkTargetCodeInjectionGeneric(options.targetCodeInjectionName, expr, this);
			if (result != null) {
				var ectoAst = tryBuildEctoWhereAST(result, expr.pos);
				if (ectoAst != null) {
					return ectoAst;
				};
				var finalCode = "";
				var insideString = false;
				for (i  in  0 ... result.length) {
					var entry = result[i];
					switch (entry) {
						case Left(code):
							finalCode += code;
							var j = 0;
							while (j < code.length) {
								if (code.charAt(j) == "\"" && (j == 0 || code.charAt(j - 1) != "\\")) {
									insideString = !insideString;
								};
								j++;
							};						
						case Right(ast):
							var astStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(ast);
							if (insideString) {
								var needsIife = (astStr.indexOf("\n") != -1) || (astStr.indexOf("=") != -1 && astStr.indexOf("==") == -1);
								var wrapped = needsIife ? "(fn -> " + astStr + " end).()" : astStr;
								finalCode += "#{" + wrapped + "}";
							} else {
								finalCode += astStr;
							};						
					};
				};
				return reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.ERaw(finalCode));
			};
			var isInjectionCall = switch (e.expr) {
				case TIdent(id):
					id == options.targetCodeInjectionName;				
				case TField(_, fa):
					switch (fa) {
						case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
							cf.get().name == options.targetCodeInjectionName;						
						case FEnum(_, ef):
							ef.name == options.targetCodeInjectionName;						
						case FDynamic(s):
							s == options.targetCodeInjectionName;						
					};				
				case TLocal(v):
					v.name == options.targetCodeInjectionName;				
				case _:
					false;				
			};
			if (isInjectionCall && args.length > 0) {
				var injectionString:String = switch (args[0].expr) {
					case TConst(TString(s)):
						s;					
					case _:
						"";					
				};
				if (injectionString != "") {
					if (injectionString.indexOf("Ecto.Query.where") != -1 && injectionString.indexOf("[t]") != -1 && args.length >= 3) {
						var queryAst = compileExpression(args[1]);
						var rhsAst = compileExpression(args[2]);
						if (queryAst != null && rhsAst != null) {
							var rx = ~/\[t\]\s*,\s*t\.([a-zA-Z0-9_]+)\s*(==|!=|<=|>=|<|>)\s*\^\(/;
							if (rx.match(injectionString)) {
								var fieldName = rx.matched(1);
								var opStr = rx.matched(2);
								var binding = reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.EList([reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.EVar("t"))]));
								var rhsStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(rhsAst);
								var condition = reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.ERaw("t." + fieldName + " " + opStr + " ^(" + rhsStr + ")"));
								var whereCall = reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query")), "where", [queryAst, binding, condition]));
								return whereCall;
							};
						};
					};
					var finalCode = "";
					var insideString = false;
					var i = 0;
					while (i < injectionString.length) {
						var char = injectionString.charAt(i);
						if (char == "\"" && (i == 0 || injectionString.charAt(i - 1) != "\\")) {
							insideString = !insideString;
							finalCode += char;
							i++;
							continue;
						};
						if (char == "{" && i + 1 < injectionString.length) {
							var j = i + 1;
							var numStr = "";
							while (j < injectionString.length && injectionString.charAt(j) >= "0" && injectionString.charAt(j) <= "9") {
								numStr += injectionString.charAt(j);
								j++;
							};
							if (numStr != "" && j < injectionString.length && injectionString.charAt(j) == "}") {
								var num = Std.parseInt(numStr);
								if (num != null && num + 1 < args.length) {
									var argAst = compileExpression(args[num + 1]);
									if (argAst != null) {
										var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst);
										if (insideString) {
											finalCode += "#{$argStr}";
										} else {
											finalCode += argStr;
										};
										i = j + 1;
										continue;
									};
								};
							};
						};
						finalCode += char;
						i++;
					};
					return reflaxe.elixir.ast.ElixirAST.makeAST(reflaxe.elixir.ast.ElixirASTDef.ERaw(finalCode));
				};
			};
		};	
	case _:
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					var args = `;
					{
						if (this.options.targetCodeInjectionName != null) {
							var result = reflaxe.compiler.TargetCodeInjection.checkTargetCodeInjectionGeneric(this.options.targetCodeInjectionName, expr, this);
							if (result != null) {
								var ectoAst = this.tryBuildEctoWhereAST(result, expr.pos);
								if (ectoAst != null) {
									return ectoAst;
								};
								var finalCode = "";
								var insideString = false;
								{
									var ` = 0;
									var ` = result.length;
									while (` < `) {
										var i = ` ++;
										var entry = result[i];
										@:ast(switch (entry) {
	case Left(code):
		finalCode += code;
		var j = 0;
		while (j < code.length) {
			if (code.charAt(j) == "\"" && (j == 0 || code.charAt(j - 1) != "\\")) {
				insideString = !insideString;
			};
			j++;
		};	
	case Right(ast):
		var astStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(ast);
		if (insideString) {
			var needsIife = (astStr.indexOf("\n") != -1) || (astStr.indexOf("=") != -1 && astStr.indexOf("==") == -1);
			var wrapped = needsIife ? "(fn -> " + astStr + " end).()" : astStr;
			finalCode += "#{" + wrapped + "}";
		} else {
			finalCode += astStr;
		};	
}) switch (@:exhaustive enumIndex entry) {
											case 0: {
												var ` = entry[0];
												{
													var code = `;
													{
														finalCode += code;
														var j = 0;
														while (j < code.length) {
															if (code.charAt(j) == "\"" && (j == 0 || code.charAt(j - 1) != "\\")) {
																insideString = ! insideString;
															};
															j ++;
														};
													};
												};
											};
											case 1: {
												var ` = entry[0];
												{
													var ast = `;
													{
														var astStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(ast, null);
														if (insideString) {
															var needsIife = (astStr.indexOf("\n", null) != -1) || (astStr.indexOf("=", null) != -1 && astStr.indexOf("==", null) == -1);
															var wrapped = if (needsIife) {
																"(fn -> " + astStr + " end).()";
															} else {
																astStr;
															};
															finalCode += "#{" + wrapped + "}";
														} else {
															finalCode += astStr;
														};
													};
												};
											};
										};
									};
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(finalCode), metadata : {}, pos : pos};
								};
							};
							var isInjectionCall = @:ast(switch (e.expr) {
	case TIdent(id):
		id == options.targetCodeInjectionName;	
	case TField(_, fa):
		switch (fa) {
			case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
				cf.get().name == options.targetCodeInjectionName;			
			case FEnum(_, ef):
				ef.name == options.targetCodeInjectionName;			
			case FDynamic(s):
				s == options.targetCodeInjectionName;			
		};	
	case TLocal(v):
		v.name == options.targetCodeInjectionName;	
	case _:
		false;	
}) {
								var ` = e.expr;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										{
											var v = `;
											{
												v.name == this.options.targetCodeInjectionName;
											};
										};
									};
									case 4: {
										var ` = `[0];
										var ` = `[1];
										{
											var fa = `;
											{
												@:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
		cf.get().name == options.targetCodeInjectionName;	
	case FEnum(_, ef):
		ef.name == options.targetCodeInjectionName;	
	case FDynamic(s):
		s == options.targetCodeInjectionName;	
}) switch (@:exhaustive enumIndex fa) {
													case 0: {
														var ` = fa[0];
														var ` = fa[1];
														var ` = fa[2];
														{
															var cf = `;
															{
																cf.get().name == this.options.targetCodeInjectionName;
															};
														};
													};
													case 1: {
														var ` = fa[0];
														var ` = fa[1];
														{
															var cf = `;
															{
																cf.get().name == this.options.targetCodeInjectionName;
															};
														};
													};
													case 2: {
														var ` = fa[0];
														{
															var cf = `;
															{
																cf.get().name == this.options.targetCodeInjectionName;
															};
														};
													};
													case 3: {
														var ` = fa[0];
														{
															var s = `;
															{
																s == this.options.targetCodeInjectionName;
															};
														};
													};
													case 4: {
														var ` = fa[0];
														var ` = fa[1];
														{
															var cf = `;
															{
																cf.get().name == this.options.targetCodeInjectionName;
															};
														};
													};
													case 5: {
														var ` = fa[0];
														var ` = fa[1];
														{
															var ef = `;
															{
																ef.name == this.options.targetCodeInjectionName;
															};
														};
													};
												};
											};
										};
									};
									case 28: {
										var ` = `[0];
										{
											var id = `;
											{
												id == this.options.targetCodeInjectionName;
											};
										};
									};
									default: {
										false;
									}
								};
							};
							if (isInjectionCall && args.length > 0) {
								var injectionString = @:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		"";	
}) {
									var ` = args[0].expr;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 2) {
											var ` = `[0];
											{
												var s = `;
												{
													s;
												};
											};
										} else {
											"";
										};
									} else {
										"";
									};
								};
								if (injectionString != "") {
									if (injectionString.indexOf("Ecto.Query.where", null) != -1 && injectionString.indexOf("[t]", null) != -1 && args.length >= 3) {
										var queryAst = this.compileExpression(args[1], null);
										var rhsAst = this.compileExpression(args[2], null);
										if (queryAst != null && rhsAst != null) {
											var rx = new EReg("\\[t\\]\\s*,\\s*t\\.([a-zA-Z0-9_]+)\\s*(==|!=|<=|>=|<|>)\\s*\\^\\(", "");
											if (rx.match(injectionString)) {
												var fieldName = rx.matched(1);
												var opStr = rx.matched(2);
												var binding = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EList([{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
													}]), metadata : {}, pos : pos};
												};
												var rhsStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(rhsAst, null);
												var condition = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("t." + fieldName + " " + opStr + " ^(" + rhsStr + ")"), metadata : {}, pos : pos};
												};
												var whereCall = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
													}, "where", [queryAst, binding, condition]), metadata : {}, pos : pos};
												};
												return whereCall;
											};
										};
									};
									var finalCode = "";
									var insideString = false;
									var i = 0;
									while (i < injectionString.length) {
										var char = injectionString.charAt(i);
										if (char == "\"" && (i == 0 || injectionString.charAt(i - 1) != "\\")) {
											insideString = ! insideString;
											finalCode += char;
											i ++;
											continue;
										};
										if (char == "{" && i + 1 < injectionString.length) {
											var j = i + 1;
											var numStr = "";
											while (j < injectionString.length && injectionString.charAt(j) >= "0" && injectionString.charAt(j) <= "9") {
												numStr += injectionString.charAt(j);
												j ++;
											};
											if (numStr != "" && j < injectionString.length && injectionString.charAt(j) == "}") {
												var num = Std.parseInt(numStr);
												if (num != null && num + 1 < args.length) {
													var argAst = this.compileExpression(args[num + 1], null);
													if (argAst != null) {
														var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst, null);
														if (insideString) {
															finalCode += "#{" + argStr + "}";
														} else {
															finalCode += argStr;
														};
														i = j + 1;
														continue;
													};
												};
											};
										};
										finalCode += char;
										i ++;
									};
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(finalCode), metadata : {}, pos : pos};
									};
								};
							};
						};
					};
				};
			} else {};
		};
		return super.compileExpression(expr, topLevel);
	}

	function tryBuildEctoWhereAST(result:Array<haxe.ds.Either<String, reflaxe.elixir.ast.ElixirAST>>, pos:Null<haxe.macro.Position> = null) {
		if (result == null) {
			return null;
		};
		var code = new StringBuf();
		var queryAst = null;
		var rhsAst = null;
		{
			var ` = 0;
			while (` < result.length) {
				var entry = result[`];
				++ `;
				@:ast(switch (entry) {
	case Left(s):
		code.add(s);	
	case Right(ast):
		if (queryAst == null) queryAst = ast else if (rhsAst == null) rhsAst = ast;	
}) switch (@:exhaustive enumIndex entry) {
					case 0: {
						var ` = entry[0];
						{
							var s = `;
							{
								code.add(s);
							};
						};
					};
					case 1: {
						var ` = entry[0];
						{
							var ast = `;
							{
								if (queryAst == null) {
									queryAst = ast;
								} else {
									if (rhsAst == null) {
										rhsAst = ast;
									};
								};
							};
						};
					};
				};
			};
		};
		var s = code.toString();
		if (s.indexOf("Ecto.Query.where", null) == -1 || s.indexOf("[t]", null) == -1) {
			return null;
		};
		var fieldName = null;
		var opStr = null;
		var rx = new EReg("\\[t\\]\\s*,\\s*t\\.([a-zA-Z0-9_]+)\\s*(==|!=|<=|>=|<|>)\\s*\\^\\(", "");
		if (rx.match(s)) {
			fieldName = rx.matched(1);
			opStr = rx.matched(2);
		} else {
			return null;
		};
		if (queryAst == null || rhsAst == null) {
			return null;
		};
		var mod = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
			}, "require", [{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
			}]), metadata : {}, pos : pos};
		};
		var binding = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EList([{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
			}]), metadata : {}, pos : pos};
		};
		var lhsField = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EField({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
			}, fieldName), metadata : {}, pos : pos};
		};
		{};
		var pinnedRhs = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EPin(rhsAst), metadata : {}, pos : pos};
		};
		var condition = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(@:ast(switch (op) {
	case "==":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.Equal;	
	case "!=":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.NotEqual;	
	case "<":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.Less;	
	case "<=":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.LessEqual;	
	case ">":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.Greater;	
	case ">=":
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.GreaterEqual;	
	default:
		reflaxe.elixir.ast.ElixirAST.EBinaryOp.Equal;	
}) switch ((opStr)) {
				case "!=": reflaxe.elixir.ast.EBinaryOp.NotEqual;
				case "<": reflaxe.elixir.ast.EBinaryOp.Less;
				case "<=": reflaxe.elixir.ast.EBinaryOp.LessEqual;
				case "==": reflaxe.elixir.ast.EBinaryOp.Equal;
				case ">": reflaxe.elixir.ast.EBinaryOp.Greater;
				case ">=": reflaxe.elixir.ast.EBinaryOp.GreaterEqual;
				default: reflaxe.elixir.ast.EBinaryOp.Equal
			}, lhsField, pinnedRhs), metadata : {}, pos : pos};
		};
		var whereCall = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
			}, "where", [queryAst, binding, condition]), metadata : {}, pos : pos};
		};
		return whereCall;
	}

	function createCompilationContext() {
		var context = new reflaxe.elixir.CompilationContext();
		context.compiler = this;
		if (this.currentClassType != null && this.currentClassType.meta.has(":exunit")) {
			context.isInExUnitTest = true;
		};
		if (context.behaviorTransformer == null) {
			context.behaviorTransformer = new reflaxe.elixir.behaviors.BehaviorTransformer();
		};
		this.initializeFeatureFlags(context);
		if (context.isFeatureEnabled("use_new_pattern_builder") || context.isFeatureEnabled("use_new_loop_builder") || context.isFeatureEnabled("use_new_function_builder") || context.isFeatureEnabled("use_new_comprehension_builder")) {
			context.builderFacade = new reflaxe.elixir.ast.builders.BuilderFacade(this, context);
		};
		return context;
	}

	function initializeFeatureFlags(context:reflaxe.elixir.CompilationContext) {
		if (haxe.macro.Context.defined("elixir.feature.new_module_builder")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.new_module_builder");
			context.setFeatureFlag("new_module_builder", value != "false");
		};
		if (haxe.macro.Context.defined("elixir.feature.loop_builder_enabled")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.loop_builder_enabled");
			context.setFeatureFlag("loop_builder_enabled", value != "false");
		} else {
			context.setFeatureFlag("loop_builder_enabled", true);
		};
		if (haxe.macro.Context.defined("elixir.feature.idiomatic_comprehensions")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.idiomatic_comprehensions");
			context.setFeatureFlag("idiomatic_comprehensions", value != "false");
		};
		if (haxe.macro.Context.defined("elixir.feature.pattern_extraction")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.pattern_extraction");
			context.setFeatureFlag("pattern_extraction", value != "false");
		};
		if (haxe.macro.Context.defined("elixir.feature.use_new_pattern_builder")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.use_new_pattern_builder");
			context.setFeatureFlag("use_new_pattern_builder", value != "false");
		};
		if (haxe.macro.Context.defined("elixir.feature.use_new_loop_builder")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.use_new_loop_builder");
			context.setFeatureFlag("use_new_loop_builder", value != "false");
		};
		if (haxe.macro.Context.defined("elixir.feature.experimental")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.experimental");
			if (value != "false") {
				context.setFeatureFlag("new_module_builder", true);
				context.setFeatureFlag("loop_builder_enabled", true);
				context.setFeatureFlag("idiomatic_comprehensions", true);
				context.setFeatureFlag("pattern_extraction", true);
				context.setFeatureFlag("use_new_pattern_builder", true);
				context.setFeatureFlag("use_new_loop_builder", true);
			};
		};
		if (haxe.macro.Context.defined("elixir.feature.legacy")) {
			var value = haxe.macro.Context.definedValue("elixir.feature.legacy");
			if (value != "false") {
				context.setFeatureFlag("new_module_builder", false);
				context.setFeatureFlag("loop_builder_enabled", false);
				context.setFeatureFlag("idiomatic_comprehensions", false);
				context.setFeatureFlag("pattern_extraction", false);
				context.setFeatureFlag("use_new_pattern_builder", false);
				context.setFeatureFlag("use_new_loop_builder", false);
			};
		};
	}

	public function compileExpressionImpl(expr:haxe.macro.TypedExpr, topLevel:Bool) {
		@:ast(switch (expr.expr) {
	case TFunction(f):
		return compileFunctionWithPersistentContext(expr, f, topLevel);	
	default:
}) {
			var ` = expr.expr;
			if (enumIndex ` == 12) {
				var ` = `[0];
				{
					var f = `;
					{
						return this.compileFunctionWithPersistentContext(expr, f, topLevel);
					};
				};
			} else {};
		};
		var context = this.createCompilationContext();
		expr = reflaxe.elixir.preprocessor.TypedExprPreprocessor.preprocess(expr);
		context.infraVarSubstitutions = reflaxe.elixir.preprocessor.TypedExprPreprocessor.getLastSubstitutions();
		var usageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(expr);
		context.variableUsageMap = usageMap;
		var ast = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);
		haxe.Log.trace("[AST Pipeline] After Builder - AST type: " + if (ast != null) {
			Type.enumConstructor(ast.def);
		} else {
			"null";
		}, {fileName : "../../../../src/reflaxe/elixir/ElixirCompiler.hx", lineNumber : 1332, className : "reflaxe.elixir.ElixirCompiler", methodName : "compileExpressionImpl"});
		if (ast != null) {
			var originalAstId = Std.string(ast);
			var transformedAst = reflaxe.elixir.ast.ElixirASTTransformer.transform(ast, context);
			var transformedAstId = Std.string(transformedAst);
			haxe.Log.trace("[AST Pipeline] After Transformer - Same object: " + Std.string(originalAstId == transformedAstId), {fileName : "../../../../src/reflaxe/elixir/ElixirCompiler.hx", lineNumber : 1341, className : "reflaxe.elixir.ElixirCompiler", methodName : "compileExpressionImpl"});
			haxe.Log.trace("[AST Pipeline]   Original AST ID: " + originalAstId, {fileName : "../../../../src/reflaxe/elixir/ElixirCompiler.hx", lineNumber : 1342, className : "reflaxe.elixir.ElixirCompiler", methodName : "compileExpressionImpl"});
			haxe.Log.trace("[AST Pipeline]   Transformed AST ID: " + transformedAstId, {fileName : "../../../../src/reflaxe/elixir/ElixirCompiler.hx", lineNumber : 1343, className : "reflaxe.elixir.ElixirCompiler", methodName : "compileExpressionImpl"});
			ast = transformedAst;
		};
		haxe.Log.trace("[AST Pipeline] Returning AST to caller", {fileName : "../../../../src/reflaxe/elixir/ElixirCompiler.hx", lineNumber : 1384, className : "reflaxe.elixir.ElixirCompiler", methodName : "compileExpressionImpl"});
		return ast;
	}

	function compileFunctionWithPersistentContext(expr:haxe.macro.TypedExpr, f:haxe.macro.TFunc, topLevel:Bool) {
		var functionContext = this.createCompilationContext();
		var preprocessedExpr = reflaxe.elixir.preprocessor.TypedExprPreprocessor.preprocess(expr);
		var usageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(preprocessedExpr);
		functionContext.variableUsageMap = usageMap;
		var ast = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(preprocessedExpr, functionContext);
		if (ast != null) {
			var transformedAst = reflaxe.elixir.ast.ElixirASTTransformer.transform(ast, functionContext);
			ast = transformedAst;
		};
		return ast;
	}

	public function generateOutputIterator() {
		return new reflaxe.elixir.ElixirOutputIterator(this);
	}

	public function getSortedModules() {
		var sorted = [];
		var remaining = {
			{};
			new haxe.ds.StringMap();
		};
		for (moduleName in {
			var this = this.moduleDependencies;
			cast this.keys();
		}) {
			{
				remaining.set(moduleName, true);
			};
		};
		while (remaining.keys().hasNext()) {
			var added = false;
			for (moduleName in remaining.keys()) {
				var deps = {
					var this = this.moduleDependencies;
					cast this.get(moduleName);
				};
				var canAdd = true;
				if (deps != null) {
					for (dep in deps.keys()) {
						if (remaining.exists(dep)) {
							canAdd = false;
							break;
						};
					};
				};
				if (canAdd) {
					sorted.push(moduleName);
					remaining.remove(moduleName);
					added = true;
				};
			};
			if (! added) {
				for (moduleName in remaining.keys()) {
					sorted.push(moduleName);
				};
				{
					remaining.clear();
				};
				break;
			};
		};
		return sorted;
	}

	function hasSpecialAnnotations(classType:haxe.macro.ClassType) {
		return classType.meta.has(":endpoint") || classType.meta.has(":liveview") || classType.meta.has(":schema") || classType.meta.has(":repo") || classType.meta.has(":dbTypes") || classType.meta.has(":postgrexTypes") || classType.meta.has(":application") || classType.meta.has(":genserver") || classType.meta.has(":router") || classType.meta.has(":controller") || classType.meta.has(":presence") || classType.meta.has(":phoenixWeb") || classType.meta.has(":phoenixWebModule") || classType.meta.has(":exunit") || classType.meta.has(":coreApi");
	}

	function discoverDependencies(classType:haxe.macro.ClassType, funcFields:Array<haxe.macro.ClassField>) {
		var previousBehavior = null;
		if (reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer != null) {
			previousBehavior = reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.activeBehavior;
			var behaviorName = reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.checkAndActivateBehavior(classType);
		};
		reflaxe.elixir.ast.ElixirASTBuilder.compiler = this;
		{
			var ` = 0;
			while (` < funcFields.length) {
				var func = funcFields[`];
				++ `;
				var funcExpr = func.expr();
				if (funcExpr != null) {
					@:ast(switch (funcExpr.expr) {
	case TFunction(tfunc):
		if (tfunc.expr != null) {
			var context = createCompilationContext();
			if (context.behaviorTransformer == null) {
				context.behaviorTransformer = new reflaxe.elixir.behaviors.BehaviorTransformer();
			};
			tfunc.expr = reflaxe.elixir.preprocessor.TypedExprPreprocessor.preprocess(tfunc.expr);
			var usageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
			context.variableUsageMap = usageMap;
			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, context);
		};	
	default:
}) {
						var ` = funcExpr.expr;
						if (enumIndex ` == 12) {
							var ` = `[0];
							{
								var tfunc = `;
								{
									if (tfunc.expr != null) {
										var context = this.createCompilationContext();
										if (context.behaviorTransformer == null) {
											context.behaviorTransformer = new reflaxe.elixir.behaviors.BehaviorTransformer();
										};
										tfunc.expr = reflaxe.elixir.preprocessor.TypedExprPreprocessor.preprocess(tfunc.expr);
										var usageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(tfunc.expr);
										context.variableUsageMap = usageMap;
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tfunc.expr, context);
									};
								};
							};
						} else {};
					};
				};
			};
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.activeBehavior = previousBehavior;
		};
	}

	function buildClassAST(classType:haxe.macro.ClassType, varFields:Array<reflaxe.data.ClassVarData>, funcFields:Array<reflaxe.data.ClassFuncData>) {
		if (this.isBuiltinAbstractType(classType.name) || this.isStandardLibraryClass(classType.name) || this.shouldSuppressStdEmission(classType)) {
			return null;
		};
		var previousBehavior = null;
		if (reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer != null) {
			previousBehavior = reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.activeBehavior;
			var behaviorName = reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.checkAndActivateBehavior(classType);
		};
		if (classType.meta.has(":gettext")) {
			var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
			var appPrefix = null;
			var webIdx = moduleName.indexOf("Web", null);
			if (webIdx > 0) {
				appPrefix = moduleName.substr(0, webIdx);
			};
			if (appPrefix == null || appPrefix.length == 0) {
				try {
					appPrefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
				} catch (`:Dynamic) {
					{};
					{};
					if (true) {
						{};
						{};
					} else throw `;
				};
			};
			if (appPrefix == null || appPrefix.length == 0) {
				appPrefix = classType.name;
			};
			var appAtom = reflaxe.elixir.ast.NameUtils.toSnakeCase(appPrefix);
			var useStmt = {
				var def = reflaxe.elixir.ast.ElixirASTDef.EUse("Gettext.Backend", [{
					var def = reflaxe.elixir.ast.ElixirASTDef.EKeywordList([{key : "otp_app", value : {
						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
							var this;
							this = reflaxe.elixir.ast.NameUtils.toSnakeCase(appAtom);
							cast this;
						});
						var pos = null;
						{def : def, metadata : {}, pos : pos};
					}}]);
					var pos = null;
					{def : def, metadata : {}, pos : pos};
				}]);
				var pos = null;
				{def : def, metadata : {}, pos : pos};
			};
			var mod = {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(moduleName, {def : reflaxe.elixir.ast.ElixirASTDef.EBlock([useStmt]), metadata : {}, pos : classType.pos}), metadata : {}, pos : classType.pos};
			Reflect.setField(mod.metadata, "forceEmit", true);
			return mod;
		};
		var funcClassFields = {
			var ` = [];
			{
				var ` = 0;
				var ` = funcFields;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(fd:reflaxe.data.ClassFuncData) {
						return fd.field;
					}(v));
				};
			};
			`;
		};
		this.discoverDependencies(classType, funcClassFields);
		reflaxe.elixir.ast.ElixirASTBuilder.compiler = this;
		var context = this.createCompilationContext();
		context.currentClass = classType;
		var fields = [];
		{
			var ` = 0;
			while (` < funcFields.length) {
				var funcData = funcFields[`];
				++ `;
				if (funcData.field.name == "new") {
					continue;
				};
				var expr = funcData.expr;
				if (expr == null) {
					continue;
				};
				expr = reflaxe.elixir.preprocessor.TypedExprPreprocessor.preprocess(expr);
				var isExUnitTestMethod = funcData.field.meta.has("test") || funcData.field.meta.has("setup") || funcData.field.meta.has("setupAll") || funcData.field.meta.has("teardown") || funcData.field.meta.has("teardownAll") || funcData.field.meta.has(":test") || funcData.field.meta.has(":setup") || funcData.field.meta.has(":setupAll") || funcData.field.meta.has(":teardown") || funcData.field.meta.has(":teardownAll");
				var isStaticMethod = funcData.isStatic;
				if (isExUnitTestMethod) {
					context.isInClassMethodContext = false;
					context.currentReceiverParamName = null;
					context.isInExUnitTest = true;
				} else {
					context.isInClassMethodContext = ! isStaticMethod;
					context.isInExUnitTest = false;
					if (! isStaticMethod) {
						context.currentReceiverParamName = "struct";
					} else {
						context.currentReceiverParamName = null;
					};
				};
				if (funcData.tfunc != null) {
					{
						var ` = 0;
						var ` = funcData.tfunc.args;
						while (` < `.length) {
							var arg = `[`];
							++ `;
							var originalName = arg.v.name;
							var idKey = Std.string(arg.v.id);
							var strippedName = originalName;
							var renamedPattern = new EReg("^(.+?)(\\d+)$", "");
							if (renamedPattern.match(originalName)) {
								var baseWithoutSuffix = renamedPattern.matched(1);
								var suffix = renamedPattern.matched(2);
								var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items", "priority"];
								if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix, null) >= 0) {
									strippedName = baseWithoutSuffix;
								};
							};
							var isUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
								true;
							} else {
								if (funcData.expr != null) {
									! reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, funcData.expr);
								} else {
									false;
								};
							};
							var baseName = reflaxe.elixir.ast.NameUtils.toSafeElixirParameterName(strippedName);
							var finalName = if (isUnused && ! StringTools.startsWith(baseName, "_")) {
								"_" + baseName;
							} else {
								baseName;
							};
							if (! {
								var this = context.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								{
									var this = context.tempVarRenameMap;
									cast this.set(idKey, finalName);
								};
								{
									var this = context.tempVarRenameMap;
									cast this.set(originalName, finalName);
								};
							} else {};
						};
					};
				};
				var funcBody = @:ast(switch (expr.expr) {
	case TReturn(e) if (e != null):
		var innerExpr = e;
		switch (e.expr) {
			case TMeta(_, inner):
				innerExpr = inner;			
			case _:
		};
		switch (innerExpr.expr) {
			case TSwitch(_, _, _):
				var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, context);
				switchAST;			
			case _:
				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);			
		};	
	case _:
		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);	
}) {
					var ` = expr.expr;
					if (enumIndex ` == 20) {
						var ` = `[0];
						{
							var e = `;
							if (e != null) {
								var innerExpr = e;
								@:ast(switch (e.expr) {
	case TMeta(_, inner):
		innerExpr = inner;	
	case _:
}) {
									var ` = e.expr;
									if (enumIndex ` == 25) {
										var ` = `[0];
										var ` = `[1];
										{
											var inner = `;
											{
												innerExpr = inner;
											};
										};
									} else {};
								};
								@:ast(switch (innerExpr.expr) {
	case TSwitch(_, _, _):
		var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, context);
		switchAST;	
	case _:
		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);	
}) {
									var ` = innerExpr.expr;
									if (enumIndex ` == 18) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, context);
											switchAST;
										};
									} else {
										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);
									};
								};
							} else {
								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);
							};
						};
					} else {
						reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);
					};
				};
				var params = [];
				if (! isStaticMethod && ! isExUnitTestMethod) {
					params.push(reflaxe.elixir.ast.EPattern.PVar("struct"));
				};
				if (funcData.tfunc != null) {
					{
						var ` = 0;
						var ` = funcData.tfunc.args;
						while (` < `.length) {
							var arg = `[`];
							++ `;
							var idKey = Std.string(arg.v.id);
							var paramName = if ({
								var this = context.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								{
									var this = context.tempVarRenameMap;
									cast this.get(idKey);
								};
							} else {
								var originalName = arg.v.name;
								var strippedName = originalName;
								var renamedPattern = new EReg("^(.+?)(\\d+)$", "");
								if (renamedPattern.match(originalName)) {
									var baseWithoutSuffix = renamedPattern.matched(1);
									var suffix = renamedPattern.matched(2);
									var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items"];
									if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix, null) >= 0) {
										strippedName = baseWithoutSuffix;
									};
								};
								reflaxe.elixir.ast.NameUtils.toSafeElixirParameterName(strippedName);
							};
							params.push(reflaxe.elixir.ast.EPattern.PVar(paramName));
						};
					};
				};
				var elixirName = reflaxe.elixir.ast.NameUtils.toSafeElixirFunctionName(funcData.field.name);
				var funcDef = if (funcData.field.isPublic) {
					reflaxe.elixir.ast.ElixirASTDef.EDef(elixirName, params, null, funcBody);
				} else {
					reflaxe.elixir.ast.ElixirASTDef.EDefp(elixirName, params, null, funcBody);
				};
				var funcMetadata = {};
				{};
				funcMetadata.isTest = funcData.field.meta.has("test") || funcData.field.meta.has(":" + "test");
				funcMetadata.isSetup = funcData.field.meta.has("setup") || funcData.field.meta.has(":" + "setup");
				funcMetadata.isSetupAll = funcData.field.meta.has("setupAll") || funcData.field.meta.has(":" + "setupAll");
				funcMetadata.isTeardown = funcData.field.meta.has("teardown") || funcData.field.meta.has(":" + "teardown");
				funcMetadata.isTeardownAll = funcData.field.meta.has("teardownAll") || funcData.field.meta.has(":" + "teardownAll");
				funcMetadata.isAsync = funcData.field.meta.has("async") || funcData.field.meta.has(":" + "async");
				var tagMeta = funcData.field.meta.extract("tag");
				var tagMetaAlt = funcData.field.meta.extract(":tag");
				if (tagMetaAlt != null && tagMetaAlt.length > 0) {
					if (tagMeta == null) {
						tagMeta = tagMetaAlt;
					} else {
						tagMeta = tagMeta.concat(tagMetaAlt);
					};
				};
				if (tagMeta != null && tagMeta.length > 0) {
					var tags = [];
					{
						var ` = 0;
						while (` < tagMeta.length) {
							var entry = tagMeta[`];
							++ `;
							if (entry.params != null) {
								{
									var ` = 0;
									var ` = entry.params;
									while (` < `.length) {
										var param = `[`];
										++ `;
										@:ast(switch (param.expr) {
	case EConst(CString(tag)):
		tags.push(tag);	
	default:
}) {
											var ` = param.expr;
											if (enumIndex ` == 0) {
												var ` = `[0];
												if (enumIndex ` == 2) {
													var ` = `[0];
													var ` = `[1];
													{
														var tag = `;
														{
															tags.push(tag);
														};
													};
												} else {};
											} else {};
										};
									};
								};
							};
						};
					};
					if (tags.length > 0) {
						funcMetadata.testTags = tags;
					};
				};
				var describeMeta = funcData.field.meta.extract("describe");
				var describeMetaAlt = funcData.field.meta.extract(":describe");
				if (describeMetaAlt != null && describeMetaAlt.length > 0) {
					if (describeMeta == null) {
						describeMeta = describeMetaAlt;
					} else {
						describeMeta = describeMeta.concat(describeMetaAlt);
					};
				};
				if (describeMeta != null && describeMeta.length > 0) {
					{
						var ` = 0;
						while (` < describeMeta.length) {
							var entry = describeMeta[`];
							++ `;
							if (entry.params != null && entry.params.length > 0) {
								@:ast(switch (entry.params[0].expr) {
	case EConst(CString(block)):
		funcMetadata.describeBlock = block;	
	default:
}) {
									var ` = entry.params[0].expr;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var block = `;
												{
													funcMetadata.describeBlock = block;
												};
											};
										} else {};
									} else {};
								};
							};
						};
					};
				};
				fields.push({def : funcDef, metadata : funcMetadata, pos : funcData.field.pos});
			};
		};
		var metadata = {};
		if (classType.superClass != null) {
			var parentClass = classType.superClass.t.get();
			var parentModuleName = if (parentClass.meta.has(":native")) {
				var nativeMeta = parentClass.meta.extract(":native");
				if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
					@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		parentClass.name;	
}) {
						var ` = nativeMeta[0].params[0].expr;
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (enumIndex ` == 2) {
								var ` = `[0];
								var ` = `[1];
								{
									var s = `;
									{
										s;
									};
								};
							} else {
								parentClass.name;
							};
						} else {
							parentClass.name;
						};
					};
				} else {
					parentClass.name;
				};
			} else {
				parentClass.name;
			};
			metadata.parentModule = parentModuleName;
			var isException = false;
			var currentClass = parentClass;
			while (currentClass != null) {
				if (currentClass.pack.length == 1 && currentClass.pack[0] == "haxe" && currentClass.name == "Exception") {
					isException = true;
					break;
				};
				currentClass = if (currentClass.superClass != null) {
					currentClass.superClass.t.get();
				} else {
					null;
				};
			};
			metadata.isException = isException;
		};
		if (classType.meta.has("exunit") || classType.meta.has(":exunit")) {
			metadata.isExunit = true;
		};
		if (classType.meta.has(":liveview")) {
			metadata.isLiveView = true;
		};
		if (classType.meta.has(":application")) {
			metadata.isApplication = true;
		};
		if (classType.meta.has(":repo")) {
			metadata.isRepo = true;
			var repoMeta = classType.meta.extract(":repo");
			if (repoMeta.length > 0 && repoMeta[0].params != null && repoMeta[0].params.length > 0) {
				metadata.dbAdapter = "Ecto.Adapters.Postgres";
				metadata.needsPostgrexTypes = true;
				metadata.jsonModule = "Jason";
			};
		};
		if (classType.meta.has(":schema")) {
			metadata.isSchema = true;
			var schemaMeta = classType.meta.extract(":schema");
			if (schemaMeta.length > 0 && schemaMeta[0].params != null && schemaMeta[0].params.length > 0) {
				@:ast(switch (schemaMeta[0].params[0].expr) {
	case EConst(CString(tableName, _)):
		metadata.tableName = tableName;	
	default:
}) {
					var ` = schemaMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var tableName = `;
								{
									metadata.tableName = tableName;
								};
							};
						} else {};
					} else {};
				};
			};
			if (classType.meta.has(":timestamps")) {
				metadata.hasTimestamps = true;
			};
			var schemaFields = [];
			{
				var ` = 0;
				while (` < varFields.length) {
					var varData = varFields[`];
					++ `;
					if (! varData.isStatic && {
						var ` = varData.field.kind;
						if (enumIndex ` == 0) {
							var ` = `[0];
							var ` = `[1];
							true;
						} else false;
					}) {
						var fieldName = varData.field.name;
						var fieldType = reflaxe.elixir.ElixirCompiler.schemaTypeNameFromType(varData.field.type);
						schemaFields.push({name : fieldName, type : fieldType});
					};
				};
			};
			metadata.schemaFields = schemaFields;
			metadata.haxeFqcn = if (classType.pack.length > 0) {
				classType.pack.join(".") + "." + classType.name;
			} else {
				classType.name;
			};
		};
		if (classType.meta.has(":supervisor")) {
			metadata.isSupervisor = true;
		};
		if (classType.meta.has(":router")) {
			metadata.isRouter = true;
		};
		if (classType.meta.has(":presence")) {
			metadata.isPresence = true;
		};
		if (classType.meta.has(":endpoint")) {
			metadata.isEndpoint = true;
			metadata.isSupervisor = true;
		};
		var moduleAST = reflaxe.elixir.ast.builders.ModuleBuilder.buildClassModule(classType, fields, metadata);
		if (moduleAST != null && moduleAST.metadata == null) {
			moduleAST.metadata = metadata;
		};
		if (moduleAST != null && moduleAST.metadata != null && moduleAST.metadata.isExunit == true) {};
		if (moduleAST != null && moduleAST.metadata != null && moduleAST.metadata.isApplication == true) {};
		if (moduleAST != null && moduleAST.metadata != null) {
			this.generateCompanionModules(classType, moduleAST.metadata);
			if (moduleAST.metadata.isRouter == true) {
				var transformed = reflaxe.elixir.ast.transformers.AnnotationTransforms.routerTransformPass(moduleAST);
				this.generateRouterStubs(transformed);
			};
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer != null) {
			reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer.activeBehavior = previousBehavior;
		};
		return moduleAST;
	}

	function generateRouterStubs(routerAST:reflaxe.elixir.ast.ElixirAST) {
		var macroNames = {
			{};
			new haxe.ds.StringMap();
		};
		{
			{
				var n = "get";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "post";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "put";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "patch";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "delete";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "resources";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "live";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "forward";
				{
					macroNames.set(n, true);
				};
			};
			{
				var n = "match";
				{
					macroNames.set(n, true);
				};
			};
		};
		var referenced = {
			{};
			new haxe.ds.StringMap();
		};
		if (routerAST != null && routerAST.metadata != null && Reflect.hasField(routerAST.metadata, "routerRefs")) {
			var listed = Reflect.field(routerAST.metadata, "routerRefs");
			if (listed != null) {
				{
					var ` = 0;
					while (` < listed.length) {
						var x = listed[`];
						++ `;
						if (x != null) {
							{
								var key = Std.string(x);
								referenced.set(key, true);
							};
						};
					};
				};
			};
		};
		var existing = {
			{};
			new haxe.ds.StringMap();
		};
		{};
		reflaxe.elixir.ast.ASTUtils.walk(routerAST, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EDefmodule(modName, _):
		existing.set(modName, true);	
	case EModule(modName2, _, _):
		existing.set(modName2, true);	
	case ECall(target, _fname, args) if (target != null):
		switch (target.def) {
			case EVar(fnName) if (macroNames.exists(fnName)):
				if (args != null) for (a  in  args) {
					switch (a.def) {
						case EVar(mod):
							record(mod);						
						case EField(tgt, field):
							var base = extractVarName(tgt);
							record(base != null ? base + "." + field : field);						
						default:
					};
				};			
			default:
		};	
	case ERemoteCall(target2, _fname2, args2):
		if (args2 != null) for (a2  in  args2) switch (a2.def) {
			case EVar(mod2):
				record(mod2);			
			case EField(tgt2, field2):
				var base2 = extractVarName(tgt2);
				record(base2 != null ? base2 + "." + field2 : field2);			
			default:
		};	
	case ERaw(code) if (code != null && code.length > 0):
		var rex = ~/([A-Z][A-Za-z0-9_]*(?:\.[A-Z][A-Za-z0-9_]*)*)/;
		var pos = 0;
		while (rex.matchSub(code, pos)) {
			var token = rex.matched(1);
			pos = rex.matchedPos().pos + rex.matchedPos().len;
			if (token == "Phoenix" || token == "Kernel" || token == "Mix") continue;
			if (token.indexOf("MyAppRouter.Layouts") != -1) continue;
			record(token);
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var modName2 = `;
							{
								{
									existing.set(modName2, true);
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var modName = `;
							{
								{
									existing.set(modName, true);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var _fname = `;
							var args = `;
							if (target != null) {
								@:ast(switch (target.def) {
	case EVar(fnName) if (macroNames.exists(fnName)):
		if (args != null) for (a  in  args) {
			switch (a.def) {
				case EVar(mod):
					record(mod);				
				case EField(tgt, field):
					var base = extractVarName(tgt);
					record(base != null ? base + "." + field : field);				
				default:
			};
		};	
	default:
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var fnName = `;
											if (macroNames.exists(fnName)) {
												if (args != null) {
													{
														var ` = 0;
														while (` < args.length) {
															var a = args[`];
															++ `;
															@:ast(switch (a.def) {
	case EVar(mod):
		record(mod);	
	case EField(tgt, field):
		var base = extractVarName(tgt);
		record(base != null ? base + "." + field : field);	
	default:
}) {
																var ` = a.def;
																switch (enumIndex `) {
																	case 28: {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var tgt = `;
																			var field = `;
																			{
																				var base = @:ast(switch (e.def) {
	case EVar(v):
		v;	
	case EField(inner, field):
		var base = extractVarName(inner);
		base != null ? base + "." + field : field;	
	default:
		null;	
}) {
																					var ` = tgt.def;
																					switch (enumIndex `) {
																						case 28: {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var inner = `;
																								var field = `;
																								{
																									var base = reflaxe.elixir.ElixirCompiler.extractVarName(inner);
																									if (base != null) {
																										base + "." + field;
																									} else {
																										field;
																									};
																								};
																							};
																						};
																						case 38: {
																							var ` = `[0];
																							{
																								var v = `;
																								{
																									v;
																								};
																							};
																						};
																						default: {
																							null;
																						}
																					};
																				};
																				{
																					var name = if ((base != null)) base + "." + field else field;
																					if (name == null) {
																						null;
																					} else {
																						if (name.indexOf(".", null) != -1) {
																							name = name.split(".")[0];
																						};
																						if (name.length == 0) {
																							null;
																						} else {
																							if (name.charAt(0) < "A" || name.charAt(0) > "Z") {
																								null;
																							} else {
																								if (name == "Phoenix" || name == "Kernel") {
																									null;
																								} else {
																									{
																										referenced.set(name, true);
																									};
																								};
																							};
																						};
																					};
																				};
																			};
																		};
																	};
																	case 38: {
																		var ` = `[0];
																		{
																			var mod = `;
																			{
																				{
																					var name = mod;
																					if (name == null) {
																						null;
																					} else {
																						if (name.indexOf(".", null) != -1) {
																							name = name.split(".")[0];
																						};
																						if (name.length == 0) {
																							null;
																						} else {
																							if (name.charAt(0) < "A" || name.charAt(0) > "Z") {
																								null;
																							} else {
																								if (name == "Phoenix" || name == "Kernel") {
																									null;
																								} else {
																									{
																										referenced.set(name, true);
																									};
																								};
																							};
																						};
																					};
																				};
																			};
																		};
																	};
																	default: {}
																};
															};
														};
													};
												};
											} else {};
										};
									} else {};
								};
							} else {};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target2 = `;
							var _fname2 = `;
							var args2 = `;
							{
								if (args2 != null) {
									{
										var ` = 0;
										while (` < args2.length) {
											var a2 = args2[`];
											++ `;
											@:ast(switch (a2.def) {
	case EVar(mod2):
		record(mod2);	
	case EField(tgt2, field2):
		var base2 = extractVarName(tgt2);
		record(base2 != null ? base2 + "." + field2 : field2);	
	default:
}) {
												var ` = a2.def;
												switch (enumIndex `) {
													case 28: {
														var ` = `[0];
														var ` = `[1];
														{
															var tgt2 = `;
															var field2 = `;
															{
																var base2 = @:ast(switch (e.def) {
	case EVar(v):
		v;	
	case EField(inner, field):
		var base = extractVarName(inner);
		base != null ? base + "." + field : field;	
	default:
		null;	
}) {
																	var ` = tgt2.def;
																	switch (enumIndex `) {
																		case 28: {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var inner = `;
																				var field = `;
																				{
																					var base = reflaxe.elixir.ElixirCompiler.extractVarName(inner);
																					if (base != null) {
																						base + "." + field;
																					} else {
																						field;
																					};
																				};
																			};
																		};
																		case 38: {
																			var ` = `[0];
																			{
																				var v = `;
																				{
																					v;
																				};
																			};
																		};
																		default: {
																			null;
																		}
																	};
																};
																{
																	var name = if ((base2 != null)) base2 + "." + field2 else field2;
																	if (name == null) {
																		null;
																	} else {
																		if (name.indexOf(".", null) != -1) {
																			name = name.split(".")[0];
																		};
																		if (name.length == 0) {
																			null;
																		} else {
																			if (name.charAt(0) < "A" || name.charAt(0) > "Z") {
																				null;
																			} else {
																				if (name == "Phoenix" || name == "Kernel") {
																					null;
																				} else {
																					{
																						referenced.set(name, true);
																					};
																				};
																			};
																		};
																	};
																};
															};
														};
													};
													case 38: {
														var ` = `[0];
														{
															var mod2 = `;
															{
																{
																	var name = mod2;
																	if (name == null) {
																		null;
																	} else {
																		if (name.indexOf(".", null) != -1) {
																			name = name.split(".")[0];
																		};
																		if (name.length == 0) {
																			null;
																		} else {
																			if (name.charAt(0) < "A" || name.charAt(0) > "Z") {
																				null;
																			} else {
																				if (name == "Phoenix" || name == "Kernel") {
																					null;
																				} else {
																					{
																						referenced.set(name, true);
																					};
																				};
																			};
																		};
																	};
																};
															};
														};
													};
													default: {}
												};
											};
										};
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							if (code != null && code.length > 0) {
								var rex = new EReg("([A-Z][A-Za-z0-9_]*(?:\\.[A-Z][A-Za-z0-9_]*)*)", "g");
								var pos = 0;
								while (rex.matchSub(code, pos, null)) {
									var token = rex.matched(1);
									pos = rex.matchedPos().pos + rex.matchedPos().len;
									if (token == "Phoenix" || token == "Kernel" || token == "Mix") {
										continue;
									};
									if (token.indexOf("MyAppRouter.Layouts", null) != -1) {
										continue;
									};
									{
										var name = token;
										if (name == null) {
											null;
										} else {
											if (name.indexOf(".", null) != -1) {
												name = name.split(".")[0];
											};
											if (name.length == 0) {
												null;
											} else {
												if (name.charAt(0) < "A" || name.charAt(0) > "Z") {
													null;
												} else {
													if (name == "Phoenix" || name == "Kernel") {
														null;
													} else {
														{
															referenced.set(name, true);
														};
													};
												};
											};
										};
									};
								};
							} else {};
						};
					};
					default: {}
				};
			};
		});
		for (name in referenced.keys()) {
			if (existing.exists(name)) {
				continue;
			};
			var skip = false;
			if (routerAST != null && routerAST.metadata != null) {
				var routerName = null;
				@:ast(switch (routerAST.def) {
	case EDefmodule(nm, _):
		routerName = nm;	
	case EModule(nm2, _, _):
		routerName = nm2;	
	default:
}) {
					var ` = routerAST.def;
					switch (enumIndex `) {
						case 0: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var nm2 = `;
								{
									routerName = nm2;
								};
							};
						};
						case 1: {
							var ` = `[0];
							var ` = `[1];
							{
								var nm = `;
								{
									routerName = nm;
								};
							};
						};
						default: {}
					};
				};
				if (routerName != null) {
					var base = routerName;
					if (StringTools.endsWith(base, ".Router")) {
						base = base.substr(0, base.length - 7);
					};
					if (StringTools.endsWith(base, "Router")) {
						base = base.substr(0, base.length - 6);
					};
					if (name == routerName || name == (base + "Web")) {
						skip = true;
					};
				};
			};
			if (skip) {
				continue;
			};
			var fileName = reflaxe.elixir.ast.NameUtils.toSnakeCase(name) + ".ex";
			var body = null;
			if (StringTools.endsWith(name, "Live")) {
				body = "defmodule " + name + " do\n  use Phoenix.Component\nend\n";
			} else {
				body = "defmodule " + name + " do\nend\n";
			};
			this.setExtraFile(@:implicitCast reflaxe.output._OutputPath.OutputPath_Impl_.fromStr(fileName), body);
		};
		var baseName = null;
		@:ast(switch (routerAST.def) {
	case EDefmodule(nm, _):
		baseName = nm;	
	case EModule(nm2, _, _):
		baseName = nm2;	
	default:
}) {
			var ` = routerAST.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var nm2 = `;
						{
							baseName = nm2;
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var nm = `;
						{
							baseName = nm;
						};
					};
				};
				default: {}
			};
		};
		if (baseName != null) {
			if (StringTools.endsWith(baseName, ".Router")) {
				baseName = baseName.substr(0, baseName.length - 7);
			};
			if (StringTools.endsWith(baseName, "Router")) {
				baseName = baseName.substr(0, baseName.length - 6);
			};
			var webName = baseName + "Web";
			if (! existing.exists(webName)) {
				var fake = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(webName, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([]), metadata : {}, pos : pos};
					}), metadata : {}, pos : pos};
				};
				fake.metadata = {isPhoenixWeb : cast true};
				var transformed = reflaxe.elixir.ast.transformers.AnnotationTransforms.phoenixWebTransformPass(fake);
				var ctx = this.createCompilationContext();
				var content = reflaxe.elixir.ast.ElixirASTPrinter.printAST(transformed, ctx);
				var webFile = reflaxe.elixir.ast.NameUtils.toSnakeCase(webName) + ".ex";
				this.setExtraFile(@:implicitCast reflaxe.output._OutputPath.OutputPath_Impl_.fromStr(webFile), content);
			};
		};
	}

	function generateCompanionModules(classType:haxe.macro.ClassType, metadata:reflaxe.elixir.ast.ElixirMetadata) {
		if (metadata.isRepo && metadata.needsPostgrexTypes) {
			this.generatePostgrexTypesModule(classType, metadata);
		};
		if (this.usedLogTrace && ! {
			var this = reflaxe.elixir.ElixirCompiler.globalModuleRegistry;
			cast this.exists("__log_emitted__");
		}) {
			var logBody = new StringBuf();
			logBody.add("defmodule Log do\n");
			logBody.add("  def format_output(v, infos) do\n");
			logBody.add("    str = inspect(v)\n");
			logBody.add("    if Kernel.is_nil(infos), do: str\n");
			logBody.add("    str\n");
			logBody.add("  end\n");
			logBody.add("  def trace(v, infos) do\n");
			logBody.add("    (\n");
			logBody.add("            case infos do\n");
			logBody.add("              nil -> IO.inspect(v)\n");
			logBody.add("              infos ->\n");
			logBody.add("                file = Map.get(infos, :fileName)\n");
			logBody.add("                line = Map.get(infos, :lineNumber)\n");
			logBody.add("                base = if file != nil and line != nil, do: \"#{file}:#{line}\", else: nil\n");
			logBody.add("                class = Map.get(infos, :className)\n");
			logBody.add("                method = Map.get(infos, :methodName)\n");
			logBody.add("                label = cond do\n");
			logBody.add("                  class != nil and method != nil and base != nil -> \"#{class}.#{method} - #{base}\"\n");
			logBody.add("                  base != nil -> base\n");
			logBody.add("                  true -> nil\n");
			logBody.add("                end\n");
			logBody.add("                if label != nil, do: IO.inspect(v, label: label), else: IO.inspect(v)\n");
			logBody.add("            end\n");
			logBody.add("            \n)\n");
			logBody.add("  end\n");
			logBody.add("end\n");
			this.setExtraFile(@:implicitCast reflaxe.output._OutputPath.OutputPath_Impl_.fromStr("haxe/log.ex"), logBody.toString());
			{
				var this = reflaxe.elixir.ElixirCompiler.globalModuleRegistry;
				cast this.set("__log_emitted__", true);
			};
		};
	}

	function generatePostgrexTypesModule(classType:haxe.macro.ClassType, metadata:reflaxe.elixir.ast.ElixirMetadata) {
		var moduleName = reflaxe.elixir.ast.builders.ModuleBuilder.extractModuleName(classType);
		var appName = moduleName.split(".")[0];
		var typesModuleName = appName + ".PostgrexTypes";
		var statements = [];
		var extensionsAST = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EList([]), metadata : {}, pos : pos};
		};
		if (metadata.extensions != null && metadata.extensions.length > 0) {
			var extElements = {
				var _this = metadata.extensions;
				{
					var ` = [];
					{
						var ` = 0;
						var ` = _this;
						while (` < `.length) {
							var v = `[`];
							++ `;
							`.push(function(ext:String) {
								return {
									var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
										var this;
										this = reflaxe.elixir.ast.NameUtils.toSnakeCase(ext);
										cast this;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							}(v));
						};
					};
					`;
				};
			};
			extensionsAST = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EList(extElements), metadata : {}, pos : pos};
			};
		};
		var options = [];
		if (metadata.jsonModule != null) {
			var jsonAtom = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "json"), metadata : {}, pos : pos};
			};
			var jsonModule = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(metadata.jsonModule), metadata : {}, pos : pos};
			};
			var keywordElement = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ETuple([jsonAtom, jsonModule]), metadata : {}, pos : pos};
			};
			options.push(keywordElement);
		};
		var moduleRef = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(typesModuleName), metadata : {}, pos : pos};
		};
		var args = [moduleRef, extensionsAST, {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EList(options), metadata : {}, pos : pos};
		}];
		var defineCall = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Postgrex.Types"), metadata : {}, pos : pos};
			}, "define", args), metadata : {}, pos : pos};
		};
		statements.push(defineCall);
		var moduleAST = defineCall;
		var context = this.createCompilationContext();
		moduleAST = reflaxe.elixir.ast.ElixirASTTransformer.transform(moduleAST, context);
		var moduleString = reflaxe.elixir.ast.ElixirASTPrinter.printAST(moduleAST, context);
		var fileName = reflaxe.elixir.ast.NameUtils.toSnakeCase("PostgrexTypes");
		var filePackage = [reflaxe.elixir.ast.NameUtils.toSnakeCase(appName)];
		var outputPath = filePackage.join("/") + "/" + fileName + ".ex";
		this.setExtraFile(@:implicitCast reflaxe.output._OutputPath.OutputPath_Impl_.fromStr(outputPath), moduleString);
	}

	function buildFromTypedExpr(expr:haxe.macro.TypedExpr, usageMap:Null<Map<Int, Bool>> = null) {
		var context = this.createCompilationContext();
		if (usageMap != null) {
			context.variableUsageMap = usageMap;
		};
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, context);
	}

	function isBuiltinAbstractType(name:String) {
		return @:ast(switch (name) {
	case "Int" | "Float" | "Bool" | "String" | "Void" | "Dynamic":
		true;	
	case "__Int64" | "Int64":
		true;	
	case _:
		false;	
}) switch (name) {
			case "Bool", "Dynamic", "Float", "Int", "String", "Void": {
				{
					true;
				};
			};
			case "Int64", "__Int64": {
				{
					true;
				};
			};
			default: {
				false;
			}
		};
	}

	function isStandardLibraryClass(name:String) {
		return @:ast(switch (name) {
	case "String" | "Array" | "Map" | "Date" | "Math" | "List":
		true;	
	case "__Int64" | "Int64" | "Int64_Impl_":
		true;	
	case _:
		false;	
}) switch (name) {
			case "Int64", "Int64_Impl_", "__Int64": {
				{
					true;
				};
			};
			case "Array", "Date", "List", "Map", "Math", "String": {
				{
					true;
				};
			};
			default: {
				false;
			}
		};
	}

	function buildEnumAST(enumType:haxe.macro.EnumType, options:Array<reflaxe.data.EnumOptionData>) {
		if (this.shouldSuppressEnumEmission(enumType)) {
			return null;
		};
		var NameUtils = reflaxe.elixir.ast.NameUtils;
		var isIdiomatic = enumType.meta.has(":elixirIdiomatic");
		var moduleName = if (enumType.meta.has(":native")) {
			var nativeMeta = enumType.meta.extract(":native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		buildEnumModuleName(enumType);	
}) {
					var ` = nativeMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									s;
								};
							};
						} else {
							this.buildEnumModuleName(enumType);
						};
					} else {
						this.buildEnumModuleName(enumType);
					};
				};
			} else {
				this.buildEnumModuleName(enumType);
			};
		} else {
			this.buildEnumModuleName(enumType);
		};
		var functions = [];
		var constructorIndexMap = {
			{};
			new haxe.ds.StringMap();
		};
		for (name in {
			var this = enumType.constructs;
			cast this.keys();
		}) {
			var constructor = {
				var this = enumType.constructs;
				cast this.get(name);
			};
			{
				var value = constructor.index;
				constructorIndexMap.set(name, value);
			};
		};
		{
			var ` = 0;
			while (` < options.length) {
				var option = options[`];
				++ `;
				var funcName = NameUtils.toSafeElixirFunctionName(option.name);
				var args = [];
				{
					var ` = 0;
					var ` = option.args.length;
					while (` < `) {
						var i = ` ++;
						args.push(reflaxe.elixir.ast.EPattern.PVar("arg" + i));
					};
				};
				var tag = if (isIdiomatic) {
					{
						var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
							var s = option.name;
							{
								var this;
								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
								cast this;
							};
						});
						var pos = null;
						{def : def, metadata : {}, pos : pos};
					};
				} else {
					var index = {
						var key = option.name;
						constructorIndexMap.get(key);
					};
					if (index == null) {
						index = 0;
					};
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index), metadata : {}, pos : pos};
					};
				};
				var tupleElements = [tag];
				{
					var ` = 0;
					var ` = option.args.length;
					while (` < `) {
						var i = ` ++;
						tupleElements.push({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("arg" + i), metadata : {}, pos : pos};
						});
					};
				};
				var returnValue = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ETuple(tupleElements), metadata : {}, pos : pos};
				};
				if (isIdiomatic) {
					returnValue.metadata.requiresIdiomaticTransform = true;
					returnValue.metadata.idiomaticEnumType = enumType.name;
				};
				var funcDef = reflaxe.elixir.ast.ElixirASTDef.EDef(funcName, args, null, returnValue);
				functions.push({
					var pos = null;
					{def : funcDef, metadata : {}, pos : pos};
				});
			};
		};
		var moduleBody = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(functions), metadata : {}, pos : pos};
		};
		var moduleAST = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(moduleName, moduleBody), metadata : {}, pos : pos};
		};
		if (isIdiomatic) {
			moduleAST.metadata.requiresIdiomaticTransform = true;
			moduleAST.metadata.idiomaticEnumType = enumType.name;
		};
		return moduleAST;
	}

	function shouldSuppressEnumEmission(enumType:haxe.macro.EnumType) {
		if (enumType == null) {
			return false;
		};
		var n = enumType.name;
		if (n == null) {
			return false;
		};
		if (n == "ValueType" || n == "StackItem") {
			return true;
		};
		if (enumType.pack != null && enumType.pack.length > 0) {
			var top = enumType.pack[0];
			if (top == "haxe") {
				return true;
			};
			if (StringTools.startsWith(top, "_")) {
				return true;
			};
		};
		return false;
	}

	function buildEnumModuleName(enumType:haxe.macro.EnumType) {
		var parts = enumType.pack.copy();
		parts.push(enumType.name);
		var processedParts = [];
		{
			var ` = 0;
			while (` < parts.length) {
				var part = parts[`];
				++ `;
				if (part.length > 0) {
					var cleanPart = part;
					while (cleanPart.charAt(0) == "_") {
						cleanPart = cleanPart.substr(1, null);
					};
					if (cleanPart.length > 0) {
						cleanPart = cleanPart.charAt(0).toUpperCase() + cleanPart.substr(1, null);
						processedParts.push(cleanPart);
					};
				};
			};
		};
		return processedParts.join(".");
	}

	public function generateFunctionReference(functionName:String) {
		var elixirFunctionName = reflaxe.elixir.ast.NameUtils.toSnakeCase(functionName);
		var currentModuleName = this.getCurrentModuleName();
		var arity = this.getFunctionArity(functionName);
		return "&" + currentModuleName + "." + elixirFunctionName + "/" + arity;
	}

	public function getCurrentModuleName() {
		if (this.currentClassType != null) {
			return this.currentClassType.name;
		};
		return "UnknownModule";
	}

	public function getModuleName(classType:haxe.macro.ClassType) {
		return classType.name;
	}

	function isBeingCalled(expr:haxe.macro.TypedExpr) {
		return false;
	}

	function getFunctionArity(functionName:String) {
		if (this.currentClassType != null) {
			var classFields = this.currentClassType.statics.get();
			{
				var ` = 0;
				while (` < classFields.length) {
					var field = classFields[`];
					++ `;
					if (field.name == functionName) {
						@:ast(switch (field.type) {
	case TFun(args, _):
		return args.length;	
	case _:
}) {
							var ` = field.type;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								{
									var args = `;
									{
										return args.length;
									};
								};
							} else {};
						};
					};
				};
			};
			var instanceFields = this.currentClassType.fields.get();
			{
				var ` = 0;
				while (` < instanceFields.length) {
					var field = instanceFields[`];
					++ `;
					if (field.name == functionName) {
						@:ast(switch (field.type) {
	case TFun(args, _):
		return args.length;	
	case _:
}) {
							var ` = field.type;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								{
									var args = `;
									{
										return args.length;
									};
								};
							} else {};
						};
					};
				};
			};
		};
		return 1;
	}

	public function setCaseArmContext(inCaseArm:Bool) {
		this.isCompilingCaseArm = inCaseArm;
	}

	public function clearFunctionParameterMapping() {
		{
			var this = this.currentFunctionParameterMap;
			cast this.clear();
		};
		this.isCompilingAbstractMethod = false;
	}

	function getLambdaParameterFromBody(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TFunction(func):
		if (func.args.length > 0) {
			return func.args[0].v;
		};	
	case TBlock(exprs):
		for (e  in  exprs) {
			var result = getLambdaParameterFromBody(e);
			if (result != null) return result;
		};	
	case TBinop(_, e1, e2):
		var result = getLambdaParameterFromBody(e1);
		if (result != null) return result;
		return getLambdaParameterFromBody(e2);	
	case TCall(e, args):
		var result = getLambdaParameterFromBody(e);
		if (result != null) return result;
		for (arg  in  args) {
			result = getLambdaParameterFromBody(arg);
			if (result != null) return result;
		};	
	case TIf(econd, eif, eelse):
		var result = getLambdaParameterFromBody(econd);
		if (result != null) return result;
		result = getLambdaParameterFromBody(eif);
		if (result != null) return result;
		if (eelse != null) {
			result = getLambdaParameterFromBody(eelse);
			if (result != null) return result;
		};	
	case _:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							var result = this.getLambdaParameterFromBody(e1);
							if (result != null) {
								return result;
							};
							return this.getLambdaParameterFromBody(e2);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var args = `;
						{
							var result = this.getLambdaParameterFromBody(e);
							if (result != null) {
								return result;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									result = this.getLambdaParameterFromBody(arg);
									if (result != null) {
										return result;
									};
								};
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var func = `;
						{
							if (func.args.length > 0) {
								return func.args[0].v;
							};
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									var result = this.getLambdaParameterFromBody(e);
									if (result != null) {
										return result;
									};
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							var result = this.getLambdaParameterFromBody(econd);
							if (result != null) {
								return result;
							};
							result = this.getLambdaParameterFromBody(eif);
							if (result != null) {
								return result;
							};
							if (eelse != null) {
								result = this.getLambdaParameterFromBody(eelse);
								if (result != null) {
									return result;
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	@:value({ isAggressiveMode : false, sourceVar : null })
	public function shouldSubstituteVariable(varName:String, sourceVar:Null<String> = null, isAggressiveMode:Bool = false) {
		if (varName.indexOf("g_", null) == 0 || varName.indexOf("temp_", null) == 0) {
			return false;
		};
		if (sourceVar != null) {
			return varName == sourceVar;
		};
		if (isAggressiveMode) {
			return this.isInLoopContext;
		};
		return false;
	}

	public function getFieldName(fa:haxe.macro.FieldAccess) {
		var nameMeta = reflaxe.helpers.NameMetaHelper.getFieldAccessNameMeta(fa);
		var name = reflaxe.helpers.NameMetaHelper.getNameOrNative(nameMeta);
		return if (reflaxe.helpers.NameMetaHelper.hasMeta(nameMeta, ":native")) {
			name;
		} else {
			reflaxe.elixir.ast.NameUtils.toSnakeCase(name);
		};
	}

	function isValidAtomName(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var firstChar = name.charAt(0);
		if (! ((firstChar >= "a" && firstChar <= "z") || firstChar == "_")) {
			return false;
		};
		{
			var ` = 1;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (! ((char >= "a" && char <= "z") || (char >= "A" && char <= "Z") || (char >= "0" && char <= "9") || char == "_")) {
					return false;
				};
			};
		};
		return true;
	}

	function shouldUseAtomKeys(fields:Array<{ name : String, expr : haxe.macro.TypedExpr }>) {
		if (false) {
			return true;
		};
		if (fields != null && fields.length == 1 && fields[0].name == "name") {
			return this.isValidAtomName("name");
		};
		return false;
	}

	function isChildSpecObject(fields:Array<{ name : String, expr : haxe.macro.TypedExpr }>) {
		if (fields == null || fields.length == 0) {
			return false;
		};
		var fieldNames = {
			var ` = [];
			{
				var ` = 0;
				var ` = fields;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(f:{ name : String, expr : haxe.macro.TypedExpr }) {
						return f.name;
					}(v));
				};
			};
			`;
		};
		return fieldNames.indexOf("id", null) != -1 && fieldNames.indexOf("start", null) != -1;
	}

	function generateModernTupleFormat(idField:String, startField:String, appName:String) {
		var cleanId = idField.split("\"").join("");
		if (cleanId == "Phoenix.PubSub") {
			var pubsubName = "" + appName + ".PubSub";
			if (startField.indexOf("[%{name: ", null) > -1) {
				var namePattern = new EReg("\\[%\\{name: ([^}]+)\\}\\]", "");
				if (namePattern.match(startField)) {
					pubsubName = namePattern.matched(1);
				};
			};
			var atomName = pubsubName.split("\"").join("");
			return "{Phoenix.PubSub, name: " + atomName + "}";
		};
		if (startField.indexOf(", []", null) > -1) {
			return cleanId;
		} else {
			if (startField.indexOf("[%{", null) > -1) {
				var argsPattern = new EReg("\\[(%\\{[^}]+\\})\\]", "");
				if (argsPattern.match(startField)) {
					var args = argsPattern.matched(1);
					return "{" + cleanId + ", " + args + "}";
				};
			};
		};
		return cleanId;
	}

	function generateSimpleModuleFormat(idField:String, appName:String) {
		var cleanId = idField.split("\"").join("");
		if (cleanId.indexOf("Telemetry", null) > -1 && cleanId.indexOf(appName, null) == -1) {
			return "" + appName + "Web.Telemetry";
		};
		if (cleanId.indexOf("Endpoint", null) > -1 && cleanId.indexOf(appName, null) == -1) {
			return "" + appName + "Web.Endpoint";
		};
		if (cleanId.indexOf("Repo", null) > -1 && cleanId.indexOf(appName, null) == -1) {
			return "" + appName + ".Repo";
		};
		return cleanId;
	}

	function isSupervisorOptionsObject(fields:Array<{ name : String, expr : haxe.macro.TypedExpr }>) {
		if (fields == null || fields.length == 0) {
			return false;
		};
		var fieldNames = {
			var ` = [];
			{
				var ` = 0;
				var ` = fields;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(f:{ name : String, expr : haxe.macro.TypedExpr }) {
						return f.name;
					}(v));
				};
			};
			`;
		};
		return fieldNames.indexOf("strategy", null) != -1;
	}

	function isFieldAssignment(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TBinop(OpAssign, e1, e2):
		switch (e1.expr) {
			case TField(e, fa):
				switch (e.expr) {
					case TConst(TThis):
						true;					
					case TLocal(v):
						v.name == "this" || v.name == "_this";					
					case _:
						false;					
				};			
			case _:
				false;			
		};	
	case _:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 4) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e1.expr) {
	case TField(e, fa):
		switch (e.expr) {
			case TConst(TThis):
				true;			
			case TLocal(v):
				v.name == "this" || v.name == "_this";			
			case _:
				false;			
		};	
	case _:
		false;	
}) {
								var ` = e1.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									{
										var e = `;
										var fa = `;
										{
											@:ast(switch (e.expr) {
	case TConst(TThis):
		true;	
	case TLocal(v):
		v.name == "this" || v.name == "_this";	
	case _:
		false;	
}) {
												var ` = e.expr;
												switch (enumIndex `) {
													case 0: {
														var ` = `[0];
														if (enumIndex ` == 5) {
															{
																true;
															};
														} else {
															false;
														};
													};
													case 1: {
														var ` = `[0];
														{
															var v = `;
															{
																v.name == "this" || v.name == "_this";
															};
														};
													};
													default: {
														false;
													}
												};
											};
										};
									};
								} else {
									false;
								};
							};
						};
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	function isNilExpression(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(TNull):
		true;	
	case TIdent("nil"):
		true;	
	case _:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 4) {
						{
							true;
						};
					} else {
						false;
					};
				};
				case 28: {
					var ` = `[0];
					if (` == "nil") {
						{
							true;
						};
					} else {
						false;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	function detectYCombinatorInAST(expr:haxe.macro.TypedExpr) {
		return false;
	}

	function containsHSigil(expr:haxe.macro.TypedExpr) {
		if (expr == null) {
			return false;
		};
		@:ast(switch (expr.expr) {
	case TCall(e, _):
		switch (e.expr) {
			case TField(_, FStatic(_, cf)):
				if (cf.get().name == "hxx") {
					return true;
				};			
			default:
		};
		return containsHSigil(e);	
	case TBlock(exprs):
		for (e  in  exprs) {
			if (containsHSigil(e)) return true;
		};	
	case TReturn(e):
		return containsHSigil(e);	
	case TIf(econd, eif, eelse):
		return containsHSigil(econd) || containsHSigil(eif) || (eelse != null && containsHSigil(eelse));	
	case TSwitch(e, cases, edef):
		if (containsHSigil(e)) return true;
		for (c  in  cases) {
			if (containsHSigil(c.expr)) return true;
		};
		if (edef != null && containsHSigil(edef)) return true;	
	case TFunction(tfunc):
		return containsHSigil(tfunc.expr);	
	case TVar(_, expr):
		return expr != null && containsHSigil(expr);	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							@:ast(switch (e.expr) {
	case TField(_, FStatic(_, cf)):
		if (cf.get().name == "hxx") {
			return true;
		};	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 1) {
										var ` = `[0];
										var ` = `[1];
										{
											var cf = `;
											{
												if (cf.get().name == "hxx") {
													return true;
												};
											};
										};
									} else {};
								} else {};
							};
							return this.containsHSigil(e);
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var tfunc = `;
						{
							return this.containsHSigil(tfunc.expr);
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							return expr != null && this.containsHSigil(expr);
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									if (this.containsHSigil(e)) {
										return true;
									};
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							return this.containsHSigil(econd) || this.containsHSigil(eif) || (eelse != null && this.containsHSigil(eelse));
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var cases = `;
						var edef = `;
						{
							if (this.containsHSigil(e)) {
								return true;
							};
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									if (this.containsHSigil(c.expr)) {
										return true;
									};
								};
							};
							if (edef != null && this.containsHSigil(edef)) {
								return true;
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var e = `;
						{
							return this.containsHSigil(e);
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	public function onCompileEnd() {
		if (this.sourceMapOutputEnabled) {
			{
				var ` = 0;
				var ` = this.pendingSourceMapWriters;
				while (` < `.length) {
					var writer = `[`];
					++ `;
					if (writer != null) {
						writer.generateSourceMap();
					};
				};
			};
			this.pendingSourceMapWriters = [];
		};
	}

	public function typeToString(type:haxe.macro.Type) {
		return @:ast(switch (type) {
	case TInst(t, _):
		t.get().name;	
	case TAbstract(t, _):
		t.get().name;	
	case TEnum(t, _):
		t.get().name;	
	case TFun(_, ret):
		"Function";	
	case TMono(_):
		"Mono";	
	case TDynamic(_):
		"Dynamic";	
	case TAnonymous(_):
		"Anonymous";	
	case TType(t, _):
		t.get().name;	
	case TLazy(_):
		"Lazy";	
}) switch (@:exhaustive enumIndex type) {
			case 0: {
				var ` = type[0];
				{
					"Mono";
				};
			};
			case 1: {
				var ` = type[0];
				var ` = type[1];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 2: {
				var ` = type[0];
				var ` = type[1];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 3: {
				var ` = type[0];
				var ` = type[1];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 4: {
				var ` = type[0];
				var ` = type[1];
				{
					var ret = `;
					{
						"Function";
					};
				};
			};
			case 5: {
				var ` = type[0];
				{
					"Anonymous";
				};
			};
			case 6: {
				var ` = type[0];
				{
					"Dynamic";
				};
			};
			case 7: {
				var ` = type[0];
				{
					"Lazy";
				};
			};
			case 8: {
				var ` = type[0];
				var ` = type[1];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
		};
	}

	@:value(new Map())
	static var globalModuleRegistry:Map<String, Bool> = {
		{};
		new haxe.ds.StringMap();
	};

	public static function registerModule(name:String) {
		if (name != null && name.length > 0) {
			{
				var this = reflaxe.elixir.ElixirCompiler.globalModuleRegistry;
				cast this.set(name, true);
			};
		};
	}

	public static function isModuleKnown(name:String) {
		return name != null && {
			var this = reflaxe.elixir.ElixirCompiler.globalModuleRegistry;
			cast this.exists(name);
		};
	}

	public static var instance:reflaxe.elixir.ElixirCompiler;

	static inline function extractVarName(e:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (e.def) {
	case EVar(v):
		v;	
	case EField(inner, field):
		var base = extractVarName(inner);
		base != null ? base + "." + field : field;	
	default:
		null;	
}) {
			var ` = e.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var inner = `;
						var field = `;
						{
							var base = reflaxe.elixir.ElixirCompiler.extractVarName(inner);
							if (base != null) {
								base + "." + field;
							} else {
								field;
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var v = `;
						{
							v;
						};
					};
				};
				default: {
					null;
				}
			};
		};
	}

	static function schemaTypeNameFromType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TType(td, params):
		var underlying = td.get();
		if (underlying.name == "Null" && params != null && params.length == 1) {
			return schemaTypeNameFromType(params[0]);
		} else {
			underlying.name;
		};	
	case TAbstract(ad, params):
		var n = ad.get().name;
		if (n == "Null" && params != null && params.length == 1) {
			return schemaTypeNameFromType(params[0]);
		};
		switch (n) {
			case "Int":
				return "Int";			
			case "Bool":
				return "Bool";			
			case "Single", "Float":
				return "Float";			
			default:
				return n;			
		};	
	case TInst(td, params):
		var cls = td.get();
		if (cls.name == "Array" && params != null && params.length == 1) {
			return "Array<" + schemaTypeNameFromType(params[0]) + ">";
		};
		switch (cls.name) {
			case "String":
				return "String";			
			case "Int":
				return "Int";			
			case "Bool":
				return "Bool";			
			case "Date":
				return "Date";			
			default:
				return cls.name;			
		};	
	case TAnonymous(_):
		"Dynamic";	
	case _:
		"String";	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var td = `;
					var params = `;
					{
						var cls = td.get();
						if (cls.name == "Array" && params != null && params.length == 1) {
							return "Array<" + reflaxe.elixir.ElixirCompiler.schemaTypeNameFromType(params[0]) + ">";
						};
						@:ast(switch (cls.name) {
	case "String":
		return "String";	
	case "Int":
		return "Int";	
	case "Bool":
		return "Bool";	
	case "Date":
		return "Date";	
	default:
		return cls.name;	
}) {
							var ` = cls.name;
							switch (`) {
								case "Bool": {
									{
										return "Bool";
									};
								};
								case "Date": {
									{
										return "Date";
									};
								};
								case "Int": {
									{
										return "Int";
									};
								};
								case "String": {
									{
										return "String";
									};
								};
								default: {
									return cls.name;
								}
							};
						};
					};
				};
			};
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var td = `;
					var params = `;
					{
						var underlying = td.get();
						if (underlying.name == "Null" && params != null && params.length == 1) {
							return reflaxe.elixir.ElixirCompiler.schemaTypeNameFromType(params[0]);
						} else {
							underlying.name;
						};
					};
				};
			};
			case 5: {
				var ` = t[0];
				{
					"Dynamic";
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var ad = `;
					var params = `;
					{
						var n = ad.get().name;
						if (n == "Null" && params != null && params.length == 1) {
							return reflaxe.elixir.ElixirCompiler.schemaTypeNameFromType(params[0]);
						};
						@:ast(switch (n) {
	case "Int":
		return "Int";	
	case "Bool":
		return "Bool";	
	case "Single", "Float":
		return "Float";	
	default:
		return n;	
}) switch (n) {
							case "Bool": {
								{
									return "Bool";
								};
							};
							case "Float", "Single": {
								{
									return "Float";
								};
							};
							case "Int": {
								{
									return "Int";
								};
							};
							default: {
								return n;
							}
						};
					};
				};
			};
			default: {
				"String";
			}
		};
	}

	@:value("ModernTuple")
	static inline var MODERN_TUPLE:String = "ModernTuple";

	@:value("SimpleModule")
	static inline var SIMPLE_MODULE:String = "SimpleModule";

	@:value("TraditionalMap")
	static inline var TRADITIONAL_MAP:String = "TraditionalMap";
}