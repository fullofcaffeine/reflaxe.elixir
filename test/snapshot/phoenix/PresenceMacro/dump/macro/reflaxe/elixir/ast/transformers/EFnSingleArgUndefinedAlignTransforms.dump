class reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms {

	public static function alignPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var binderName:Null<String> = null;
			if (cl.args != null && cl.args.length == 1) {
				switch (cl.args[0]) {
					case PVar(name):
						binderName = name;					
					case _:
						binderName = null;					
				};
			};
			if (binderName == null) {
				newClauses.push(cl);
				continue;
			};
			if (VariableUsageCollector.usedInFunctionScope(cl.body, binderName)) {
				newClauses.push(cl);
				continue;
			};
			var referenced = VariableUsageCollector.referencedInFunctionScope(cl.body);
			var bound = collectLocallyBoundNames(cl);
			referenced.remove(binderName);
			for (k  in  bound.keys()) referenced.remove(k);
			var freeNames:Array<String> = [];
			for (k  in  referenced.keys()) if (looksLikeVar(k)) freeNames.push(k);
			if (freeNames.length == 1) {
				var victim = freeNames[0];
				var newBody = renameVarInNode(cl.body, victim, binderName);
				newClauses.push({ args : cl.args, guard : cl.guard, body : newBody });
			} else {
				newClauses.push(cl);
			};
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var binderName = null;
									if (cl.args != null && cl.args.length == 1) {
										@:ast(switch (cl.args[0]) {
	case PVar(name):
		binderName = name;	
	case _:
		binderName = null;	
}) {
											var ` = cl.args[0];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var name = `;
													{
														binderName = name;
													};
												};
											} else {
												binderName = null;
											};
										};
									};
									if (binderName == null) {
										newClauses.push(cl);
										continue;
									};
									if (reflaxe.elixir.ast.analyzers.VariableUsageCollector.usedInFunctionScope(cl.body, binderName)) {
										newClauses.push(cl);
										continue;
									};
									var referenced = reflaxe.elixir.ast.analyzers.VariableUsageCollector.referencedInFunctionScope(cl.body);
									var bound = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectLocallyBoundNames(cl);
									referenced.remove(binderName);
									for (k in bound.keys()) {
										referenced.remove(k);
									};
									var freeNames = [];
									for (k in referenced.keys()) {
										if (reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.looksLikeVar(k)) {
											freeNames.push(k);
										};
									};
									if (freeNames.length == 1) {
										var victim = freeNames[0];
										var newBody = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.renameVarInNode(cl.body, victim, binderName);
										newClauses.push({args : cl.args, guard : cl.guard, body : newBody});
									} else {
										newClauses.push(cl);
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function looksLikeVar(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var c = name.charAt(0);
		if (c == "_" || c.toLowerCase() != c) {
			return false;
		};
		return name.indexOf(".", null) == -1;
	}

	static function collectLocallyBoundNames(clause:{ guard : Null<reflaxe.elixir.ast.ElixirAST>, body : reflaxe.elixir.ast.ElixirAST, args : Array<reflaxe.elixir.ast.EPattern> }) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		if (clause.args != null) {
			{
				var ` = 0;
				var ` = clause.args;
				while (` < `.length) {
					var a = `[`];
					++ `;
					for (k in {
						var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(a);
						cast this.keys();
					}) {
						{
							m.set(k, true);
						};
					};
				};
			};
		};
		var walk = [null];
		walk[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EMatch(pat, _):
		for (k  in  collectPatternVars(pat).keys()) m.set(k, true);	
	case ECase(_, cs):
		for (c  in  cs) for (k  in  collectPatternVars(c.pattern).keys()) m.set(k, true);	
	case EReceive(cs, _):
		for (c  in  cs) for (k  in  collectPatternVars(c.pattern).keys()) m.set(k, true);	
	case EWith(cs, _, _):
		for (c  in  cs) for (k  in  collectPatternVars(c.pattern).keys()) m.set(k, true);	
	case EFn(inner):
		for (cc  in  inner) for (aa  in  cc.args) for (k  in  collectPatternVars(aa).keys()) m.set(k, true);	
	case EBlock(sts) | EDo(sts):
		for (s  in  sts) walk(s);	
	case EIf(c, t, e):
		walk(c);
		walk(t);
		if (e != null) walk(e);	
	case ECall(t, _, as):
		if (t != null) walk(t);
		if (as != null) for (a  in  as) walk(a);	
	case ERemoteCall(t2, _, as2):
		walk(t2);
		if (as2 != null) for (a  in  as2) walk(a);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var cs = `;
							{
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										for (k in {
											var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(c.pattern);
											cast this.keys();
										}) {
											{
												m.set(k, true);
											};
										};
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pat = `;
							{
								for (k in {
									var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(pat);
									cast this.keys();
								}) {
									{
										m.set(k, true);
									};
								};
							};
						};
					};
					case 9: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cs = `;
							{
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										for (k in {
											var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(c.pattern);
											cast this.keys();
										}) {
											{
												m.set(k, true);
											};
										};
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								walk[0](c);
								walk[0](t);
								if (e != null) {
									walk[0](e);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t = `;
							var as = `;
							{
								if (t != null) {
									walk[0](t);
								};
								if (as != null) {
									{
										var ` = 0;
										while (` < as.length) {
											var a = as[`];
											++ `;
											walk[0](a);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t2 = `;
							var as2 = `;
							{
								walk[0](t2);
								if (as2 != null) {
									{
										var ` = 0;
										while (` < as2.length) {
											var a = as2[`];
											++ `;
											walk[0](a);
										};
									};
								};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var inner = `;
							{
								{
									var ` = 0;
									while (` < inner.length) {
										var cc = inner[`];
										++ `;
										{
											var ` = 0;
											var ` = cc.args;
											while (` < `.length) {
												var aa = `[`];
												++ `;
												for (k in {
													var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(aa);
													cast this.keys();
												}) {
													{
														m.set(k, true);
													};
												};
											};
										};
									};
								};
							};
						};
					};
					case 51: {
						var ` = `[0];
						var ` = `[1];
						{
							var cs = `;
							{
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										for (k in {
											var this = reflaxe.elixir.ast.transformers.EFnSingleArgUndefinedAlignTransforms.collectPatternVars(c.pattern);
											cast this.keys();
										}) {
											{
												m.set(k, true);
											};
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var sts = `;
							{
								{
									var ` = 0;
									while (` < sts.length) {
										var s = sts[`];
										++ `;
										walk[0](s);
									};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var sts = `;
							{
								{
									var ` = 0;
									while (` < sts.length) {
										var s = sts[`];
										++ `;
										walk[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		walk[0](clause.body);
		return m;
	}

	static function collectPatternVars(p:reflaxe.elixir.ast.EPattern) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var add = function(nm:String) {
			if (nm != null && nm.length > 0) {
				{
					m.set(nm, true);
				};
			};
		};
		var visit = [null];
		visit[0] = function(pp:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pp) {
	case PVar(n):
		add(n);	
	case PAlias(n, pat):
		add(n);
		visit(pat);	
	case PTuple(es):
		for (e  in  es) visit(e);	
	case PList(es):
		for (e  in  es) visit(e);	
	case PCons(h, t):
		visit(h);
		visit(t);	
	case PMap(kvs):
		for (kv  in  kvs) visit(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) visit(f.value);	
	case PBinary(segs):
		for (s  in  segs) visit(s.pattern);	
	case PPin(inner):
		visit(inner);	
	default:
}) switch (enumIndex pp) {
				case 0: {
					var ` = pp[0];
					{
						var n = `;
						{
							add(n);
						};
					};
				};
				case 2: {
					var ` = pp[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									visit[0](e);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pp[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									visit[0](e);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var h = `;
						var t = `;
						{
							visit[0](h);
							visit[0](t);
						};
					};
				};
				case 5: {
					var ` = pp[0];
					{
						var kvs = `;
						{
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									visit[0](kv.value);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var fs = `;
						{
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									visit[0](f.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pp[0];
					{
						var inner = `;
						{
							visit[0](inner);
						};
					};
				};
				case 9: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var n = `;
						var pat = `;
						{
							add(n);
							visit[0](pat);
						};
					};
				};
				case 10: {
					var ` = pp[0];
					{
						var segs = `;
						{
							{
								var ` = 0;
								while (` < segs.length) {
									var s = segs[`];
									++ `;
									visit[0](s.pattern);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		visit[0](p);
		return m;
	}

	static function renameVarInNode(node:reflaxe.elixir.ast.ElixirAST, from:String, to:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EVar(name) if (name == from):
		makeASTWithMeta(EVar(to), n.metadata, n.pos);	
	case ERaw(_):
		n;	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 38: {
						var ` = `[0];
						{
							var name = `;
							if (name == from) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(to), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							n;
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}
}