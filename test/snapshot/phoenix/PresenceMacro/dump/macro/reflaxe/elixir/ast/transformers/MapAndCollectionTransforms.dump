class reflaxe.elixir.ast.transformers.MapAndCollectionTransforms {

	static inline function safeBinder(name:String) {
		return if ((name != null && name.length > 0 && name.charAt(0) == "_")) {
			name.substr(1, null);
		} else {
			name;
		};
	}

	public static function enumEachBinderIntegrityPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		var listExpr = args[0];
		var fnNode = args[1];
		switch (fnNode.def) {
			case EFn(clauses) if (clauses.length == 1):
				var clause = clauses[0];
				var binderName:Null<String> = null;
				switch (clause.args.length > 0 ? clause.args[0] : null) {
					case PVar(n):
						binderName = n;					
					case PWildcard:
						binderName = null;					
					default:
				};
				var stmts:Array<ElixirAST> = switch (clause.body.def) {
					case EBlock(ss):
						ss;					
					case EDo(ss2):
						ss2;					
					default:
						[clause.body];					
				};
				var replacementName = binderName != null ? safeBinder(binderName) : "item";
				function replaceHeadAccess(e:ElixirAST):ElixirAST {
					return ElixirASTTransformer.transformNode(e, function(x:ElixirAST):ElixirAST {
						return switch (x.def) {
							case EAccess(target, key):
								var isZero = switch (key.def) {
									case EInteger(v) if (v == 0):
										true;									
									default:
										false;									
								};
								if (isZero && astEquals(target, listExpr)) makeASTWithMeta(EVar(replacementName), x.metadata, x.pos) else x;							
							default:
								x;							
						};
					});
				};
				var newStmts:Array<ElixirAST> = [];
				var promoteFieldsList:Bool = false;
				var droppedAlias:Null<String> = null;
				for (s  in  stmts) {
					var keep = switch (s.def) {
						case EInteger(v) if (v == 0 || v == 1):
							false;						
						case EFloat(f) if (f == 0.0):
							false;						
						default:
							true;						
					};
					if (!keep) continue;
					var s1 = replaceHeadAccess(s);
					switch (s1.def) {
						case EBinary(Match, l, r):
							var lvar:Null<String> = switch (l.def) {
								case EVar(nm):
									nm;								
								default:
									null;								
							};
							var rIsBinder = switch (r.def) {
								case EVar(nm2) if (nm2 == replacementName):
									true;								
								default:
									false;								
							};
							if (lvar != null && rIsBinder) {
								droppedAlias = lvar;
								continue;
							};						
						case EMatch(patX, r2):
							var pvar:Null<String> = switch (patX) {
								case PVar(nm3):
									nm3;								
								default:
									null;								
							};
							var rIsBinder2 = switch (r2.def) {
								case EVar(nm4) if (nm4 == replacementName):
									true;								
								default:
									false;								
							};
							if (pvar != null && rIsBinder2) {
								droppedAlias = pvar;
								continue;
							};						
						default:
					};
					if (droppedAlias != null) s1 = replaceVarInExpr(s1, droppedAlias, replacementName);
					newStmts.push(s1);
				};
				var bodyExpr:ElixirAST = (newStmts.length == 1) ? newStmts[0] : makeAST(EBlock(newStmts));
				function collectUsedVars(n:ElixirAST, out:Map<String,Bool>):Void {
					if (n == null || n.def == null) return;
					switch (n.def) {
						case EVar(v):
							out.set(v, true);						
						case EBlock(ss):
							for (x  in  ss) collectUsedVars(x, out);						
						case EDo(ss2):
							for (x  in  ss2) collectUsedVars(x, out);						
						case EIf(c, t, e):
							collectUsedVars(c, out);
							collectUsedVars(t, out);
							if (e != null) collectUsedVars(e, out);						
						case ECase(expr, cs):
							collectUsedVars(expr, out);
							for (c  in  cs) collectUsedVars(c.body, out);						
						case EBinary(_, l, r):
							collectUsedVars(l, out);
							collectUsedVars(r, out);						
						case EField(obj, _):
							collectUsedVars(obj, out);						
						case EMatch(_, rhs):
							collectUsedVars(rhs, out);						
						case ECall(tgt, _, argsC):
							if (tgt != null) collectUsedVars(tgt, out);
							for (a  in  argsC) collectUsedVars(a, out);						
						case ERemoteCall(tgt2, _, argsR):
							collectUsedVars(tgt2, out);
							for (a  in  argsR) collectUsedVars(a, out);						
						case EList(els):
							for (el  in  els) collectUsedVars(el, out);						
						case ETuple(els2):
							for (el  in  els2) collectUsedVars(el, out);						
						case EKeywordList(ps):
							for (p  in  ps) collectUsedVars(p.value, out);						
						case EStructUpdate(base, fs):
							collectUsedVars(base, out);
							for (f  in  fs) collectUsedVars(f.value, out);						
						default:
					};
				};
				function collectPatternVars(p:EPattern, out:Map<String,Bool>):Void {
					switch (p) {
						case PVar(nm):
							out.set(nm, true);						
						case PTuple(elems):
							for (pe  in  elems) collectPatternVars(pe, out);						
						case PAlias(varName, pattern):
							out.set(varName, true);
							collectPatternVars(pattern, out);						
						case PList(ps):
							for (pe2  in  ps) collectPatternVars(pe2, out);						
						default:
					};
				};
				function collectBoundVars(stmts2:Array<ElixirAST>):Map<String,Bool> {
					var m = new Map<String,Bool>();
					if (binderName != null) m.set(safeBinder(binderName), true);
					for (sSt  in  stmts2) switch (sSt.def) {
						case EBinary(Match, lft, _):
							switch (lft.def) {
								case EVar(nv):
									m.set(nv, true);								
								default:
							};						
						case EMatch(patY, _):
							collectPatternVars(patY, m);						
						case ECase(_, clauses):
							for (cl  in  clauses) collectPatternVars(cl.pattern, m);						
						default:
					};
					return m;
				};
				var used = new Map<String,Bool>();
				collectUsedVars(bodyExpr, used);
				var bound = collectBoundVars(newStmts);
				var free:Array<String> = [];
				for (k  in  used.keys()) if (!bound.exists(k)) free.push(k);
				function appearsAsReceiverOrArg(n:ElixirAST, name:String):Bool {
					var found = false;
					ElixirASTTransformer.transformNode(n, function(x:ElixirAST):ElixirAST {
						if (found) return x;
						switch (x.def) {
							case EField({ def : EVar(v) }, _) if (v == name):
								found = true;
								return x;							
							case ECall(_, _, argsC):
								for (a  in  argsC) switch (a.def) {
									case EVar(v2) if (v2 == name):
										found = true;									
									default:
								};
								return x;							
							case ERemoteCall(tgt2, _, argsR):
								switch (tgt2.def) {
									case EVar(v3) if (v3 == name):
										found = true;									
									default:
								};
								for (a  in  argsR) switch (a.def) {
									case EVar(v4) if (v4 == name):
										found = true;									
									default:
								};
								return x;							
							case EString(str):
								if (str != null && (str.indexOf("#{" + name + "}") != -1 || str.indexOf("#{" + name + ".") != -1)) found = true;
								return x;							
							default:
								return x;							
						};
					});
					return found;
				};
				var eligible:Array<String> = [];
				for (nm  in  free) if (appearsAsReceiverOrArg(bodyExpr, nm)) eligible.push(nm);
				var didReplace = false;
				if (eligible.length == 1) {
					var aliasName = eligible[0];
					bodyExpr = replaceVarInExpr(bodyExpr, aliasName, replacementName);
					didReplace = true;
				} else if (free.length == 1) {
					var aliasName2 = free[0];
					bodyExpr = replaceVarInExpr(bodyExpr, aliasName2, replacementName);
					didReplace = true;
				} else if (free.length > 0) {
					var aliasName3 = free[0];
					bodyExpr = replaceVarInExpr(bodyExpr, aliasName3, replacementName);
					didReplace = true;
				};
				var finalBinder:EPattern = (didReplace || bodyUsesVar(bodyExpr, replacementName)) ? PVar(replacementName) : PWildcard;
				var newFn = makeAST(EFn([{ args : [finalBinder], guard : clause.guard, body : bodyExpr }]));
				makeASTWithMeta(ERemoteCall(mod, func, [listExpr, newFn]), node.metadata, node.pos);			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var mod = `;
						var func = `;
						var args = `;
						if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
							var ` = mod.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var name = `;
									if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						}) {
							var listExpr = args[0];
							var fnNode = args[1];
							@:ast(switch (fnNode.def) {
	case EFn(clauses) if (clauses.length == 1):
		var clause = clauses[0];
		var binderName:Null<String> = null;
		switch (clause.args.length > 0 ? clause.args[0] : null) {
			case PVar(n):
				binderName = n;			
			case PWildcard:
				binderName = null;			
			default:
		};
		var stmts:Array<ElixirAST> = switch (clause.body.def) {
			case EBlock(ss):
				ss;			
			case EDo(ss2):
				ss2;			
			default:
				[clause.body];			
		};
		var replacementName = binderName != null ? safeBinder(binderName) : "item";
		function replaceHeadAccess(e:ElixirAST):ElixirAST {
			return ElixirASTTransformer.transformNode(e, function(x:ElixirAST):ElixirAST {
				return switch (x.def) {
					case EAccess(target, key):
						var isZero = switch (key.def) {
							case EInteger(v) if (v == 0):
								true;							
							default:
								false;							
						};
						if (isZero && astEquals(target, listExpr)) makeASTWithMeta(EVar(replacementName), x.metadata, x.pos) else x;					
					default:
						x;					
				};
			});
		};
		var newStmts:Array<ElixirAST> = [];
		var promoteFieldsList:Bool = false;
		var droppedAlias:Null<String> = null;
		for (s  in  stmts) {
			var keep = switch (s.def) {
				case EInteger(v) if (v == 0 || v == 1):
					false;				
				case EFloat(f) if (f == 0.0):
					false;				
				default:
					true;				
			};
			if (!keep) continue;
			var s1 = replaceHeadAccess(s);
			switch (s1.def) {
				case EBinary(Match, l, r):
					var lvar:Null<String> = switch (l.def) {
						case EVar(nm):
							nm;						
						default:
							null;						
					};
					var rIsBinder = switch (r.def) {
						case EVar(nm2) if (nm2 == replacementName):
							true;						
						default:
							false;						
					};
					if (lvar != null && rIsBinder) {
						droppedAlias = lvar;
						continue;
					};				
				case EMatch(patX, r2):
					var pvar:Null<String> = switch (patX) {
						case PVar(nm3):
							nm3;						
						default:
							null;						
					};
					var rIsBinder2 = switch (r2.def) {
						case EVar(nm4) if (nm4 == replacementName):
							true;						
						default:
							false;						
					};
					if (pvar != null && rIsBinder2) {
						droppedAlias = pvar;
						continue;
					};				
				default:
			};
			if (droppedAlias != null) s1 = replaceVarInExpr(s1, droppedAlias, replacementName);
			newStmts.push(s1);
		};
		var bodyExpr:ElixirAST = (newStmts.length == 1) ? newStmts[0] : makeAST(EBlock(newStmts));
		function collectUsedVars(n:ElixirAST, out:Map<String,Bool>):Void {
			if (n == null || n.def == null) return;
			switch (n.def) {
				case EVar(v):
					out.set(v, true);				
				case EBlock(ss):
					for (x  in  ss) collectUsedVars(x, out);				
				case EDo(ss2):
					for (x  in  ss2) collectUsedVars(x, out);				
				case EIf(c, t, e):
					collectUsedVars(c, out);
					collectUsedVars(t, out);
					if (e != null) collectUsedVars(e, out);				
				case ECase(expr, cs):
					collectUsedVars(expr, out);
					for (c  in  cs) collectUsedVars(c.body, out);				
				case EBinary(_, l, r):
					collectUsedVars(l, out);
					collectUsedVars(r, out);				
				case EField(obj, _):
					collectUsedVars(obj, out);				
				case EMatch(_, rhs):
					collectUsedVars(rhs, out);				
				case ECall(tgt, _, argsC):
					if (tgt != null) collectUsedVars(tgt, out);
					for (a  in  argsC) collectUsedVars(a, out);				
				case ERemoteCall(tgt2, _, argsR):
					collectUsedVars(tgt2, out);
					for (a  in  argsR) collectUsedVars(a, out);				
				case EList(els):
					for (el  in  els) collectUsedVars(el, out);				
				case ETuple(els2):
					for (el  in  els2) collectUsedVars(el, out);				
				case EKeywordList(ps):
					for (p  in  ps) collectUsedVars(p.value, out);				
				case EStructUpdate(base, fs):
					collectUsedVars(base, out);
					for (f  in  fs) collectUsedVars(f.value, out);				
				default:
			};
		};
		function collectPatternVars(p:EPattern, out:Map<String,Bool>):Void {
			switch (p) {
				case PVar(nm):
					out.set(nm, true);				
				case PTuple(elems):
					for (pe  in  elems) collectPatternVars(pe, out);				
				case PAlias(varName, pattern):
					out.set(varName, true);
					collectPatternVars(pattern, out);				
				case PList(ps):
					for (pe2  in  ps) collectPatternVars(pe2, out);				
				default:
			};
		};
		function collectBoundVars(stmts2:Array<ElixirAST>):Map<String,Bool> {
			var m = new Map<String,Bool>();
			if (binderName != null) m.set(safeBinder(binderName), true);
			for (sSt  in  stmts2) switch (sSt.def) {
				case EBinary(Match, lft, _):
					switch (lft.def) {
						case EVar(nv):
							m.set(nv, true);						
						default:
					};				
				case EMatch(patY, _):
					collectPatternVars(patY, m);				
				case ECase(_, clauses):
					for (cl  in  clauses) collectPatternVars(cl.pattern, m);				
				default:
			};
			return m;
		};
		var used = new Map<String,Bool>();
		collectUsedVars(bodyExpr, used);
		var bound = collectBoundVars(newStmts);
		var free:Array<String> = [];
		for (k  in  used.keys()) if (!bound.exists(k)) free.push(k);
		function appearsAsReceiverOrArg(n:ElixirAST, name:String):Bool {
			var found = false;
			ElixirASTTransformer.transformNode(n, function(x:ElixirAST):ElixirAST {
				if (found) return x;
				switch (x.def) {
					case EField({ def : EVar(v) }, _) if (v == name):
						found = true;
						return x;					
					case ECall(_, _, argsC):
						for (a  in  argsC) switch (a.def) {
							case EVar(v2) if (v2 == name):
								found = true;							
							default:
						};
						return x;					
					case ERemoteCall(tgt2, _, argsR):
						switch (tgt2.def) {
							case EVar(v3) if (v3 == name):
								found = true;							
							default:
						};
						for (a  in  argsR) switch (a.def) {
							case EVar(v4) if (v4 == name):
								found = true;							
							default:
						};
						return x;					
					case EString(str):
						if (str != null && (str.indexOf("#{" + name + "}") != -1 || str.indexOf("#{" + name + ".") != -1)) found = true;
						return x;					
					default:
						return x;					
				};
			});
			return found;
		};
		var eligible:Array<String> = [];
		for (nm  in  free) if (appearsAsReceiverOrArg(bodyExpr, nm)) eligible.push(nm);
		var didReplace = false;
		if (eligible.length == 1) {
			var aliasName = eligible[0];
			bodyExpr = replaceVarInExpr(bodyExpr, aliasName, replacementName);
			didReplace = true;
		} else if (free.length == 1) {
			var aliasName2 = free[0];
			bodyExpr = replaceVarInExpr(bodyExpr, aliasName2, replacementName);
			didReplace = true;
		} else if (free.length > 0) {
			var aliasName3 = free[0];
			bodyExpr = replaceVarInExpr(bodyExpr, aliasName3, replacementName);
			didReplace = true;
		};
		var finalBinder:EPattern = (didReplace || bodyUsesVar(bodyExpr, replacementName)) ? PVar(replacementName) : PWildcard;
		var newFn = makeAST(EFn([{ args : [finalBinder], guard : clause.guard, body : bodyExpr }]));
		makeASTWithMeta(ERemoteCall(mod, func, [listExpr, newFn]), node.metadata, node.pos);	
	default:
		node;	
}) {
								var ` = fnNode.def;
								if (enumIndex ` == 42) {
									var ` = `[0];
									{
										var clauses = `;
										if (clauses.length == 1) {
											var clause = clauses[0];
											var binderName = [null];
											@:ast(switch (clause.args.length > 0 ? clause.args[0] : null) {
	case PVar(n):
		binderName = n;	
	case PWildcard:
		binderName = null;	
	default:
}) {
												var ` = if (clause.args.length > 0) {
													clause.args[0];
												} else {
													null;
												};
												if (` == null) {} else switch (enumIndex `) {
													case 0: {
														var ` = `[0];
														{
															var n = `;
															{
																binderName[0] = n;
															};
														};
													};
													case 8: {
														{
															binderName[0] = null;
														};
													};
													default: {}
												};
											};
											var stmts = @:ast(switch (clause.body.def) {
	case EBlock(ss):
		ss;	
	case EDo(ss2):
		ss2;	
	default:
		[clause.body];	
}) {
												var ` = clause.body.def;
												switch (enumIndex `) {
													case 53: {
														var ` = `[0];
														{
															var ss = `;
															{
																ss;
															};
														};
													};
													case 55: {
														var ` = `[0];
														{
															var ss2 = `;
															{
																ss2;
															};
														};
													};
													default: {
														[clause.body];
													}
												};
											};
											var replacementName = if (binderName[0] != null) {
												if ((binderName[0] != null && binderName[0].length > 0 && binderName[0].charAt(0) == "_")) {
													binderName[0].substr(1, null);
												} else {
													binderName[0];
												};
											} else {
												"item";
											};
											var replaceHeadAccess = function(e:reflaxe.elixir.ast.ElixirAST) {
												return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(e, function(x:reflaxe.elixir.ast.ElixirAST) {
													return @:ast(switch (x.def) {
	case EAccess(target, key):
		var isZero = switch (key.def) {
			case EInteger(v) if (v == 0):
				true;			
			default:
				false;			
		};
		if (isZero && astEquals(target, listExpr)) makeASTWithMeta(EVar(replacementName), x.metadata, x.pos) else x;	
	default:
		x;	
}) {
														var ` = x.def;
														if (enumIndex ` == 29) {
															var ` = `[0];
															var ` = `[1];
															{
																var target = `;
																var key = `;
																{
																	var isZero = @:ast(switch (key.def) {
	case EInteger(v) if (v == 0):
		true;	
	default:
		false;	
}) {
																		var ` = key.def;
																		if (enumIndex ` == 33) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (v == 0) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	};
																	if (isZero && reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.astEquals(target, listExpr)) {
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(replacementName), metadata : x.metadata, pos : x.pos};
																	} else {
																		x;
																	};
																};
															};
														} else {
															x;
														};
													};
												});
											};
											var newStmts = [];
											var promoteFieldsList = false;
											var droppedAlias = null;
											{
												var ` = 0;
												while (` < stmts.length) {
													var s = stmts[`];
													++ `;
													var keep = @:ast(switch (s.def) {
	case EInteger(v) if (v == 0 || v == 1):
		false;	
	case EFloat(f) if (f == 0.0):
		false;	
	default:
		true;	
}) {
														var ` = s.def;
														switch (enumIndex `) {
															case 33: {
																var ` = `[0];
																{
																	var v = `;
																	if (v == 0 || v == 1) {
																		false;
																	} else {
																		true;
																	};
																};
															};
															case 34: {
																var ` = `[0];
																{
																	var f = `;
																	if (f == 0.0) {
																		false;
																	} else {
																		true;
																	};
																};
															};
															default: {
																true;
															}
														};
													};
													if (! keep) {
														continue;
													};
													var s1 = replaceHeadAccess(s);
													@:ast(switch (s1.def) {
	case EBinary(Match, l, r):
		var lvar:Null<String> = switch (l.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		var rIsBinder = switch (r.def) {
			case EVar(nm2) if (nm2 == replacementName):
				true;			
			default:
				false;			
		};
		if (lvar != null && rIsBinder) {
			droppedAlias = lvar;
			continue;
		};	
	case EMatch(patX, r2):
		var pvar:Null<String> = switch (patX) {
			case PVar(nm3):
				nm3;			
			default:
				null;			
		};
		var rIsBinder2 = switch (r2.def) {
			case EVar(nm4) if (nm4 == replacementName):
				true;			
			default:
				false;			
		};
		if (pvar != null && rIsBinder2) {
			droppedAlias = pvar;
			continue;
		};	
	default:
}) {
														var ` = s1.def;
														switch (enumIndex `) {
															case 8: {
																var ` = `[0];
																var ` = `[1];
																{
																	var patX = `;
																	var r2 = `;
																	{
																		var pvar = @:ast(switch (patX) {
	case PVar(nm3):
		nm3;	
	default:
		null;	
}) if (enumIndex patX == 0) {
																			var ` = patX[0];
																			{
																				var nm3 = `;
																				{
																					nm3;
																				};
																			};
																		} else {
																			null;
																		};
																		var rIsBinder2 = @:ast(switch (r2.def) {
	case EVar(nm4) if (nm4 == replacementName):
		true;	
	default:
		false;	
}) {
																			var ` = r2.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var nm4 = `;
																					if (nm4 == replacementName) {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		};
																		if (pvar != null && rIsBinder2) {
																			droppedAlias = pvar;
																			continue;
																		};
																	};
																};
															};
															case 26: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (enumIndex ` == 27) {
																	{
																		var l = `;
																		var r = `;
																		{
																			var lvar = @:ast(switch (l.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
																				var ` = l.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var nm = `;
																						{
																							nm;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																			var rIsBinder = @:ast(switch (r.def) {
	case EVar(nm2) if (nm2 == replacementName):
		true;	
	default:
		false;	
}) {
																				var ` = r.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var nm2 = `;
																						if (nm2 == replacementName) {
																							true;
																						} else {
																							false;
																						};
																					};
																				} else {
																					false;
																				};
																			};
																			if (lvar != null && rIsBinder) {
																				droppedAlias = lvar;
																				continue;
																			};
																		};
																	};
																} else {};
															};
															default: {}
														};
													};
													if (droppedAlias != null) {
														s1 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(s1, droppedAlias, replacementName);
													};
													newStmts.push(s1);
												};
											};
											var bodyExpr = if ((newStmts.length == 1)) {
												newStmts[0];
											} else {
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStmts), metadata : {}, pos : pos};
												};
											};
											var collectUsedVars = [null];
											collectUsedVars[0] = function(n:reflaxe.elixir.ast.ElixirAST, out:Map<String, Bool>) {
												if (n == null || n.def == null) {
													return;
												};
												@:ast(switch (n.def) {
	case EVar(v):
		out.set(v, true);	
	case EBlock(ss):
		for (x  in  ss) collectUsedVars(x, out);	
	case EDo(ss2):
		for (x  in  ss2) collectUsedVars(x, out);	
	case EIf(c, t, e):
		collectUsedVars(c, out);
		collectUsedVars(t, out);
		if (e != null) collectUsedVars(e, out);	
	case ECase(expr, cs):
		collectUsedVars(expr, out);
		for (c  in  cs) collectUsedVars(c.body, out);	
	case EBinary(_, l, r):
		collectUsedVars(l, out);
		collectUsedVars(r, out);	
	case EField(obj, _):
		collectUsedVars(obj, out);	
	case EMatch(_, rhs):
		collectUsedVars(rhs, out);	
	case ECall(tgt, _, argsC):
		if (tgt != null) collectUsedVars(tgt, out);
		for (a  in  argsC) collectUsedVars(a, out);	
	case ERemoteCall(tgt2, _, argsR):
		collectUsedVars(tgt2, out);
		for (a  in  argsR) collectUsedVars(a, out);	
	case EList(els):
		for (el  in  els) collectUsedVars(el, out);	
	case ETuple(els2):
		for (el  in  els2) collectUsedVars(el, out);	
	case EKeywordList(ps):
		for (p  in  ps) collectUsedVars(p.value, out);	
	case EStructUpdate(base, fs):
		collectUsedVars(base, out);
		for (f  in  fs) collectUsedVars(f.value, out);	
	default:
}) {
													var ` = n.def;
													switch (enumIndex `) {
														case 6: {
															var ` = `[0];
															var ` = `[1];
															{
																var expr = `;
																var cs = `;
																{
																	collectUsedVars[0](expr, out);
																	{
																		var ` = 0;
																		while (` < cs.length) {
																			var c = cs[`];
																			++ `;
																			collectUsedVars[0](c.body, out);
																		};
																	};
																};
															};
														};
														case 8: {
															var ` = `[0];
															var ` = `[1];
															{
																var rhs = `;
																{
																	collectUsedVars[0](rhs, out);
																};
															};
														};
														case 10: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var c = `;
																var t = `;
																var e = `;
																{
																	collectUsedVars[0](c, out);
																	collectUsedVars[0](t, out);
																	if (e != null) {
																		collectUsedVars[0](e, out);
																	};
																};
															};
														};
														case 15: {
															var ` = `[0];
															{
																var els = `;
																{
																	{
																		var ` = 0;
																		while (` < els.length) {
																			var el = els[`];
																			++ `;
																			collectUsedVars[0](el, out);
																		};
																	};
																};
															};
														};
														case 16: {
															var ` = `[0];
															{
																var els2 = `;
																{
																	{
																		var ` = 0;
																		while (` < els2.length) {
																			var el = els2[`];
																			++ `;
																			collectUsedVars[0](el, out);
																		};
																	};
																};
															};
														};
														case 19: {
															var ` = `[0];
															var ` = `[1];
															{
																var base = `;
																var fs = `;
																{
																	collectUsedVars[0](base, out);
																	{
																		var ` = 0;
																		while (` < fs.length) {
																			var f = fs[`];
																			++ `;
																			collectUsedVars[0](f.value, out);
																		};
																	};
																};
															};
														};
														case 20: {
															var ` = `[0];
															{
																var ps = `;
																{
																	{
																		var ` = 0;
																		while (` < ps.length) {
																			var p = ps[`];
																			++ `;
																			collectUsedVars[0](p.value, out);
																		};
																	};
																};
															};
														};
														case 22: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var tgt = `;
																var argsC = `;
																{
																	if (tgt != null) {
																		collectUsedVars[0](tgt, out);
																	};
																	{
																		var ` = 0;
																		while (` < argsC.length) {
																			var a = argsC[`];
																			++ `;
																			collectUsedVars[0](a, out);
																		};
																	};
																};
															};
														};
														case 24: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var tgt2 = `;
																var argsR = `;
																{
																	collectUsedVars[0](tgt2, out);
																	{
																		var ` = 0;
																		while (` < argsR.length) {
																			var a = argsR[`];
																			++ `;
																			collectUsedVars[0](a, out);
																		};
																	};
																};
															};
														};
														case 26: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var l = `;
																var r = `;
																{
																	collectUsedVars[0](l, out);
																	collectUsedVars[0](r, out);
																};
															};
														};
														case 28: {
															var ` = `[0];
															var ` = `[1];
															{
																var obj = `;
																{
																	collectUsedVars[0](obj, out);
																};
															};
														};
														case 38: {
															var ` = `[0];
															{
																var v = `;
																{
																	{
																		out.set(v, true);
																	};
																};
															};
														};
														case 53: {
															var ` = `[0];
															{
																var ss = `;
																{
																	{
																		var ` = 0;
																		while (` < ss.length) {
																			var x = ss[`];
																			++ `;
																			collectUsedVars[0](x, out);
																		};
																	};
																};
															};
														};
														case 55: {
															var ` = `[0];
															{
																var ss2 = `;
																{
																	{
																		var ` = 0;
																		while (` < ss2.length) {
																			var x = ss2[`];
																			++ `;
																			collectUsedVars[0](x, out);
																		};
																	};
																};
															};
														};
														default: {}
													};
												};
											};
											var collectPatternVars = [null];
											collectPatternVars[0] = function(p:reflaxe.elixir.ast.EPattern, out:Map<String, Bool>) {
												@:ast(switch (p) {
	case PVar(nm):
		out.set(nm, true);	
	case PTuple(elems):
		for (pe  in  elems) collectPatternVars(pe, out);	
	case PAlias(varName, pattern):
		out.set(varName, true);
		collectPatternVars(pattern, out);	
	case PList(ps):
		for (pe2  in  ps) collectPatternVars(pe2, out);	
	default:
}) switch (enumIndex p) {
													case 0: {
														var ` = p[0];
														{
															var nm = `;
															{
																{
																	out.set(nm, true);
																};
															};
														};
													};
													case 2: {
														var ` = p[0];
														{
															var elems = `;
															{
																{
																	var ` = 0;
																	while (` < elems.length) {
																		var pe = elems[`];
																		++ `;
																		collectPatternVars[0](pe, out);
																	};
																};
															};
														};
													};
													case 3: {
														var ` = p[0];
														{
															var ps = `;
															{
																{
																	var ` = 0;
																	while (` < ps.length) {
																		var pe2 = ps[`];
																		++ `;
																		collectPatternVars[0](pe2, out);
																	};
																};
															};
														};
													};
													case 9: {
														var ` = p[0];
														var ` = p[1];
														{
															var varName = `;
															var pattern = `;
															{
																{
																	out.set(varName, true);
																};
																collectPatternVars[0](pattern, out);
															};
														};
													};
													default: {}
												};
											};
											var collectBoundVars = function(stmts2:Array<reflaxe.elixir.ast.ElixirAST>) {
												var m = {
													{};
													new haxe.ds.StringMap();
												};
												if (binderName[0] != null) {
													{
														var key = if ((binderName[0] != null && binderName[0].length > 0 && binderName[0].charAt(0) == "_")) binderName[0].substr(1, null) else binderName[0];
														m.set(key, true);
													};
												};
												{
													var ` = 0;
													while (` < stmts2.length) {
														var sSt = stmts2[`];
														++ `;
														@:ast(switch (sSt.def) {
	case EBinary(Match, lft, _):
		switch (lft.def) {
			case EVar(nv):
				m.set(nv, true);			
			default:
		};	
	case EMatch(patY, _):
		collectPatternVars(patY, m);	
	case ECase(_, clauses):
		for (cl  in  clauses) collectPatternVars(cl.pattern, m);	
	default:
}) {
															var ` = sSt.def;
															switch (enumIndex `) {
																case 6: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var clauses = `;
																		{
																			{
																				var ` = 0;
																				while (` < clauses.length) {
																					var cl = clauses[`];
																					++ `;
																					collectPatternVars[0](cl.pattern, m);
																				};
																			};
																		};
																	};
																};
																case 8: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var patY = `;
																		{
																			collectPatternVars[0](patY, m);
																		};
																	};
																};
																case 26: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	if (enumIndex ` == 27) {
																		{
																			var lft = `;
																			{
																				@:ast(switch (lft.def) {
	case EVar(nv):
		m.set(nv, true);	
	default:
}) {
																					var ` = lft.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var nv = `;
																							{
																								{
																									m.set(nv, true);
																								};
																							};
																						};
																					} else {};
																				};
																			};
																		};
																	} else {};
																};
																default: {}
															};
														};
													};
												};
												return m;
											};
											var used = {
												{};
												new haxe.ds.StringMap();
											};
											collectUsedVars[0](bodyExpr, used);
											var bound = collectBoundVars(newStmts);
											var free = [];
											for (k in used.keys()) {
												if (! bound.exists(k)) {
													free.push(k);
												};
											};
											var appearsAsReceiverOrArg = function(n:reflaxe.elixir.ast.ElixirAST, name:String) {
												var found = [false];
												reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
													if (found[0]) {
														return x;
													};
													@:ast(switch (x.def) {
	case EField({ def : EVar(v) }, _) if (v == name):
		found = true;
		return x;	
	case ECall(_, _, argsC):
		for (a  in  argsC) switch (a.def) {
			case EVar(v2) if (v2 == name):
				found = true;			
			default:
		};
		return x;	
	case ERemoteCall(tgt2, _, argsR):
		switch (tgt2.def) {
			case EVar(v3) if (v3 == name):
				found = true;			
			default:
		};
		for (a  in  argsR) switch (a.def) {
			case EVar(v4) if (v4 == name):
				found = true;			
			default:
		};
		return x;	
	case EString(str):
		if (str != null && (str.indexOf("#{" + name + "}") != -1 || str.indexOf("#{" + name + ".") != -1)) found = true;
		return x;	
	default:
		return x;	
}) {
														var ` = x.def;
														switch (enumIndex `) {
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var argsC = `;
																	{
																		{
																			var ` = 0;
																			while (` < argsC.length) {
																				var a = argsC[`];
																				++ `;
																				@:ast(switch (a.def) {
	case EVar(v2) if (v2 == name):
		found = true;	
	default:
}) {
																					var ` = a.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v2 = `;
																							if (v2 == name) {
																								found[0] = true;
																							} else {};
																						};
																					} else {};
																				};
																			};
																		};
																		return x;
																	};
																};
															};
															case 24: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var tgt2 = `;
																	var argsR = `;
																	{
																		@:ast(switch (tgt2.def) {
	case EVar(v3) if (v3 == name):
		found = true;	
	default:
}) {
																			var ` = tgt2.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var v3 = `;
																					if (v3 == name) {
																						found[0] = true;
																					} else {};
																				};
																			} else {};
																		};
																		{
																			var ` = 0;
																			while (` < argsR.length) {
																				var a = argsR[`];
																				++ `;
																				@:ast(switch (a.def) {
	case EVar(v4) if (v4 == name):
		found = true;	
	default:
}) {
																					var ` = a.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v4 = `;
																							if (v4 == name) {
																								found[0] = true;
																							} else {};
																						};
																					} else {};
																				};
																			};
																		};
																		return x;
																	};
																};
															};
															case 28: {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.def;
																	var ` = `.metadata;
																	var ` = `.pos;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var v = `;
																			if (v == name) {
																				found[0] = true;
																				return x;
																			} else {
																				return x;
																			};
																		};
																	} else {
																		return x;
																	};
																};
															};
															case 32: {
																var ` = `[0];
																{
																	var str = `;
																	{
																		if (str != null && (str.indexOf("#{" + name + "}", null) != -1 || str.indexOf("#{" + name + ".", null) != -1)) {
																			found[0] = true;
																		};
																		return x;
																	};
																};
															};
															default: {
																return x;
															}
														};
													};
												});
												return found[0];
											};
											var eligible = [];
											{
												var ` = 0;
												while (` < free.length) {
													var nm = free[`];
													++ `;
													if (appearsAsReceiverOrArg(bodyExpr, nm)) {
														eligible.push(nm);
													};
												};
											};
											var didReplace = false;
											if (eligible.length == 1) {
												var aliasName = eligible[0];
												bodyExpr = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(bodyExpr, aliasName, replacementName);
												didReplace = true;
											} else {
												if (free.length == 1) {
													var aliasName2 = free[0];
													bodyExpr = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(bodyExpr, aliasName2, replacementName);
													didReplace = true;
												} else {
													if (free.length > 0) {
														var aliasName3 = free[0];
														bodyExpr = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(bodyExpr, aliasName3, replacementName);
														didReplace = true;
													};
												};
											};
											var finalBinder = if ((didReplace || reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.bodyUsesVar(bodyExpr, replacementName))) {
												reflaxe.elixir.ast.EPattern.PVar(replacementName);
											} else {
												reflaxe.elixir.ast.EPattern.PWildcard;
											};
											var newFn = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [finalBinder], guard : clause.guard, body : bodyExpr}]), metadata : {}, pos : pos};
											};
											{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, [listExpr, newFn]), metadata : node.metadata, pos : node.pos};
										} else {
											node;
										};
									};
								} else {
									node;
								};
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function enumEachSentinelCleanupPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall(mod, "each", args) if (args != null && args.length == 2):
		switch (mod.def) {
			case EVar(mn) if (mn == "Enum"):
				var listExpr = args[0];
				var fnArg = args[1];
				switch (fnArg.def) {
					case EFn(clauses) if (clauses.length == 1):
						var cl = clauses[0];
						var cleanedBody = switch (cl.body.def) {
							case EBlock(stmts):
								var out:Array<ElixirAST> = [];
								for (s  in  stmts) switch (s.def) {
									case EInteger(v) if (v == 0 || v == 1):
									case EFloat(f) if (f == 0.0):
									default:
										out.push(s);									
								};
								makeASTWithMeta(EBlock(out), cl.body.metadata, cl.body.pos);							
							case EDo(stmts2):
								var out2:Array<ElixirAST> = [];
								for (s  in  stmts2) switch (s.def) {
									case EInteger(v2) if (v2 == 0 || v2 == 1):
									case EFloat(f2) if (f2 == 0.0):
									default:
										out2.push(s);									
								};
								makeASTWithMeta(EDo(out2), cl.body.metadata, cl.body.pos);							
							default:
								cl.body;							
						};
						var arg0 = cl.args.length > 0 ? cl.args[0] : PWildcard;
						var finalArg = switch (arg0) {
							case PVar(nm):
								(bodyUsesVar(cleanedBody, nm) ? arg0 : PWildcard);							
							default:
								arg0;							
						};
						var newFn = makeAST(EFn([{ args : [finalArg], guard : cl.guard, body : cleanedBody }]));
						makeASTWithMeta(ERemoteCall(mod, "each", [listExpr, newFn]), n.metadata, n.pos);					
					default:
						n;					
				};			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (` == "each") {
						{
							var mod = `;
							var args = `;
							if (args != null && args.length == 2) {
								@:ast(switch (mod.def) {
	case EVar(mn) if (mn == "Enum"):
		var listExpr = args[0];
		var fnArg = args[1];
		switch (fnArg.def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				var cleanedBody = switch (cl.body.def) {
					case EBlock(stmts):
						var out:Array<ElixirAST> = [];
						for (s  in  stmts) switch (s.def) {
							case EInteger(v) if (v == 0 || v == 1):
							case EFloat(f) if (f == 0.0):
							default:
								out.push(s);							
						};
						makeASTWithMeta(EBlock(out), cl.body.metadata, cl.body.pos);					
					case EDo(stmts2):
						var out2:Array<ElixirAST> = [];
						for (s  in  stmts2) switch (s.def) {
							case EInteger(v2) if (v2 == 0 || v2 == 1):
							case EFloat(f2) if (f2 == 0.0):
							default:
								out2.push(s);							
						};
						makeASTWithMeta(EDo(out2), cl.body.metadata, cl.body.pos);					
					default:
						cl.body;					
				};
				var arg0 = cl.args.length > 0 ? cl.args[0] : PWildcard;
				var finalArg = switch (arg0) {
					case PVar(nm):
						(bodyUsesVar(cleanedBody, nm) ? arg0 : PWildcard);					
					default:
						arg0;					
				};
				var newFn = makeAST(EFn([{ args : [finalArg], guard : cl.guard, body : cleanedBody }]));
				makeASTWithMeta(ERemoteCall(mod, "each", [listExpr, newFn]), n.metadata, n.pos);			
			default:
				n;			
		};	
	default:
		n;	
}) {
									var ` = mod.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var mn = `;
											if (mn == "Enum") {
												var listExpr = args[0];
												var fnArg = args[1];
												@:ast(switch (fnArg.def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		var cleanedBody = switch (cl.body.def) {
			case EBlock(stmts):
				var out:Array<ElixirAST> = [];
				for (s  in  stmts) switch (s.def) {
					case EInteger(v) if (v == 0 || v == 1):
					case EFloat(f) if (f == 0.0):
					default:
						out.push(s);					
				};
				makeASTWithMeta(EBlock(out), cl.body.metadata, cl.body.pos);			
			case EDo(stmts2):
				var out2:Array<ElixirAST> = [];
				for (s  in  stmts2) switch (s.def) {
					case EInteger(v2) if (v2 == 0 || v2 == 1):
					case EFloat(f2) if (f2 == 0.0):
					default:
						out2.push(s);					
				};
				makeASTWithMeta(EDo(out2), cl.body.metadata, cl.body.pos);			
			default:
				cl.body;			
		};
		var arg0 = cl.args.length > 0 ? cl.args[0] : PWildcard;
		var finalArg = switch (arg0) {
			case PVar(nm):
				(bodyUsesVar(cleanedBody, nm) ? arg0 : PWildcard);			
			default:
				arg0;			
		};
		var newFn = makeAST(EFn([{ args : [finalArg], guard : cl.guard, body : cleanedBody }]));
		makeASTWithMeta(ERemoteCall(mod, "each", [listExpr, newFn]), n.metadata, n.pos);	
	default:
		n;	
}) {
													var ` = fnArg.def;
													if (enumIndex ` == 42) {
														var ` = `[0];
														{
															var clauses = `;
															if (clauses.length == 1) {
																var cl = clauses[0];
																var cleanedBody = @:ast(switch (cl.body.def) {
	case EBlock(stmts):
		var out:Array<ElixirAST> = [];
		for (s  in  stmts) switch (s.def) {
			case EInteger(v) if (v == 0 || v == 1):
			case EFloat(f) if (f == 0.0):
			default:
				out.push(s);			
		};
		makeASTWithMeta(EBlock(out), cl.body.metadata, cl.body.pos);	
	case EDo(stmts2):
		var out2:Array<ElixirAST> = [];
		for (s  in  stmts2) switch (s.def) {
			case EInteger(v2) if (v2 == 0 || v2 == 1):
			case EFloat(f2) if (f2 == 0.0):
			default:
				out2.push(s);			
		};
		makeASTWithMeta(EDo(out2), cl.body.metadata, cl.body.pos);	
	default:
		cl.body;	
}) {
																	var ` = cl.body.def;
																	switch (enumIndex `) {
																		case 53: {
																			var ` = `[0];
																			{
																				var stmts = `;
																				{
																					var out = [];
																					{
																						var ` = 0;
																						while (` < stmts.length) {
																							var s = stmts[`];
																							++ `;
																							@:ast(switch (s.def) {
	case EInteger(v) if (v == 0 || v == 1):
	case EFloat(f) if (f == 0.0):
	default:
		out.push(s);	
}) {
																								var ` = s.def;
																								switch (enumIndex `) {
																									case 33: {
																										var ` = `[0];
																										{
																											var v = `;
																											if (v == 0 || v == 1) {} else {
																												out.push(s);
																											};
																										};
																									};
																									case 34: {
																										var ` = `[0];
																										{
																											var f = `;
																											if (f == 0.0) {} else {
																												out.push(s);
																											};
																										};
																									};
																									default: {
																										out.push(s);
																									}
																								};
																							};
																						};
																					};
																					{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : cl.body.metadata, pos : cl.body.pos};
																				};
																			};
																		};
																		case 55: {
																			var ` = `[0];
																			{
																				var stmts2 = `;
																				{
																					var out2 = [];
																					{
																						var ` = 0;
																						while (` < stmts2.length) {
																							var s = stmts2[`];
																							++ `;
																							@:ast(switch (s.def) {
	case EInteger(v2) if (v2 == 0 || v2 == 1):
	case EFloat(f2) if (f2 == 0.0):
	default:
		out2.push(s);	
}) {
																								var ` = s.def;
																								switch (enumIndex `) {
																									case 33: {
																										var ` = `[0];
																										{
																											var v2 = `;
																											if (v2 == 0 || v2 == 1) {} else {
																												out2.push(s);
																											};
																										};
																									};
																									case 34: {
																										var ` = `[0];
																										{
																											var f2 = `;
																											if (f2 == 0.0) {} else {
																												out2.push(s);
																											};
																										};
																									};
																									default: {
																										out2.push(s);
																									}
																								};
																							};
																						};
																					};
																					{def : reflaxe.elixir.ast.ElixirASTDef.EDo(out2), metadata : cl.body.metadata, pos : cl.body.pos};
																				};
																			};
																		};
																		default: {
																			cl.body;
																		}
																	};
																};
																var arg0 = if (cl.args.length > 0) {
																	cl.args[0];
																} else {
																	reflaxe.elixir.ast.EPattern.PWildcard;
																};
																var finalArg = @:ast(switch (arg0) {
	case PVar(nm):
		(bodyUsesVar(cleanedBody, nm) ? arg0 : PWildcard);	
	default:
		arg0;	
}) if (enumIndex arg0 == 0) {
																	var ` = arg0[0];
																	{
																		var nm = `;
																		{
																			(if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.bodyUsesVar(cleanedBody, nm)) {
																				arg0;
																			} else {
																				reflaxe.elixir.ast.EPattern.PWildcard;
																			});
																		};
																	};
																} else {
																	arg0;
																};
																var newFn = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [finalArg], guard : cl.guard, body : cleanedBody}]), metadata : {}, pos : pos};
																};
																{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, "each", [listExpr, newFn]), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													} else {
														n;
													};
												};
											} else {
												n;
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						};
					} else {
						n;
					};
				} else {
					n;
				};
			};
		});
	}

	public static function fnArgBodyRefNormalizePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var body = cl.body;
			var args = cl.args;
			if (args.length >= 1) {
				switch (args[0]) {
					case PVar(name) if (name != null && name.length > 0 && name.charAt(0) != "_"):
						var underscore = "_" + name;
						var fixed = replaceVarInExpr(body, underscore, name);
						if (args.length >= 2) {
							switch (args[1]) {
								case PVar(accName) if (accName != null && accName.length > 0 && accName.charAt(0) != "_"):
									fixed = replaceVarInExpr(fixed, "_" + accName, accName);								
								default:
							};
						};
						newClauses.push({ args : args, guard : cl.guard, body : fixed });					
					case PVar(name) if (name != null && name.length > 1 && name.charAt(0) == "_"):
						if (bodyUsesVar(body, name)) {
							var trimmed = name.substr(1);
							var fixedBody = replaceVarInExpr(body, name, trimmed);
							newClauses.push({ args : [PVar(trimmed)], guard : cl.guard, body : fixedBody });
						} else {
							newClauses.push(cl);
						};					
					default:
						newClauses.push(cl);					
				};
				if (args.length >= 2) {
					var a0 = switch (args[0]) {
						case PVar(nm):
							nm;						
						default:
							null;						
					};
					var a1 = switch (args[1]) {
						case PVar(nm2):
							nm2;						
						default:
							null;						
					};
					if (a0 != null && a0.length > 0) {
						var body2 = replaceVarInExpr(newClauses[newClauses.length - 1].body, "_" + a0, a0);
						if (a1 != null && a1.length > 0) body2 = replaceVarInExpr(body2, "_" + a1, a1);
						var last = newClauses.pop();
						newClauses.push({ args : last.args, guard : last.guard, body : body2 });
					};
				};
			} else {
				newClauses.push(cl);
			};
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var body = cl.body;
									var args = cl.args;
									if (args.length >= 1) {
										@:ast(switch (args[0]) {
	case PVar(name) if (name != null && name.length > 0 && name.charAt(0) != "_"):
		var underscore = "_" + name;
		var fixed = replaceVarInExpr(body, underscore, name);
		if (args.length >= 2) {
			switch (args[1]) {
				case PVar(accName) if (accName != null && accName.length > 0 && accName.charAt(0) != "_"):
					fixed = replaceVarInExpr(fixed, "_" + accName, accName);				
				default:
			};
		};
		newClauses.push({ args : args, guard : cl.guard, body : fixed });	
	case PVar(name) if (name != null && name.length > 1 && name.charAt(0) == "_"):
		if (bodyUsesVar(body, name)) {
			var trimmed = name.substr(1);
			var fixedBody = replaceVarInExpr(body, name, trimmed);
			newClauses.push({ args : [PVar(trimmed)], guard : cl.guard, body : fixedBody });
		} else {
			newClauses.push(cl);
		};	
	default:
		newClauses.push(cl);	
}) {
											var ` = args[0];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var name = `;
													if (name != null && name.length > 0 && name.charAt(0) != "_") {
														var underscore = "_" + name;
														var fixed = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(body, underscore, name);
														if (args.length >= 2) {
															@:ast(switch (args[1]) {
	case PVar(accName) if (accName != null && accName.length > 0 && accName.charAt(0) != "_"):
		fixed = replaceVarInExpr(fixed, "_" + accName, accName);	
	default:
}) {
																var ` = args[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var accName = `;
																		if (accName != null && accName.length > 0 && accName.charAt(0) != "_") {
																			fixed = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(fixed, "_" + accName, accName);
																		} else {};
																	};
																} else {};
															};
														};
														newClauses.push({args : args, guard : cl.guard, body : fixed});
													} else {
														var name = `;
														if (name != null && name.length > 1 && name.charAt(0) == "_") {
															if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.bodyUsesVar(body, name)) {
																var trimmed = name.substr(1, null);
																var fixedBody = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(body, name, trimmed);
																newClauses.push({args : [reflaxe.elixir.ast.EPattern.PVar(trimmed)], guard : cl.guard, body : fixedBody});
															} else {
																newClauses.push(cl);
															};
														} else {
															newClauses.push(cl);
														};
													};
												};
											} else {
												newClauses.push(cl);
											};
										};
										if (args.length >= 2) {
											var a0 = @:ast(switch (args[0]) {
	case PVar(nm):
		nm;	
	default:
		null;	
}) {
												var ` = args[0];
												if (enumIndex ` == 0) {
													var ` = `[0];
													{
														var nm = `;
														{
															nm;
														};
													};
												} else {
													null;
												};
											};
											var a1 = @:ast(switch (args[1]) {
	case PVar(nm2):
		nm2;	
	default:
		null;	
}) {
												var ` = args[1];
												if (enumIndex ` == 0) {
													var ` = `[0];
													{
														var nm2 = `;
														{
															nm2;
														};
													};
												} else {
													null;
												};
											};
											if (a0 != null && a0.length > 0) {
												var body2 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(newClauses[newClauses.length - 1].body, "_" + a0, a0);
												if (a1 != null && a1.length > 0) {
													body2 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(body2, "_" + a1, a1);
												};
												var last = newClauses.pop();
												newClauses.push({args : last.args, guard : last.guard, body : body2});
											};
										};
									} else {
										newClauses.push(cl);
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	public static function enumEachHeadExtractionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		var listExpr = args[0];
		var fnNode = args[1];
		switch (fnNode.def) {
			case EFn(clauses) if (clauses.length == 1):
				var clause = clauses[0];
				var binderName:Null<String> = null;
				switch (clause.args.length > 0 ? clause.args[0] : null) {
					case PVar(n):
						binderName = n;					
					default:
				};
				var newStmts:Array<ElixirAST> = [];
				var removedAlias:Null<String> = null;
				var promoteFieldsList:Bool = false;
				var stmts:Array<ElixirAST> = switch (clause.body.def) {
					case EBlock(ss):
						ss;					
					default:
						[clause.body];					
				};
				for (s  in  stmts) {
					var matched = false;
					switch (s.def) {
						case EBinary(Match, left, right):
							switch (left.def) {
								case EVar(aliasVar):
									if (isHeadAccessOf(right, listExpr)) {
										removedAlias = aliasVar;
										matched = true;
										switch (right.def) {
											case EAccess(tgt, key) if (switch (tgt.def) {
											case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
												true;											
											default:
												false;											
										}):
												promoteFieldsList = true;											
											default:
										};
									};								
								default:
							};						
						case EMatch(pattern, right2):
							switch (pattern) {
								case PVar(aliasVar2):
									if (isHeadAccessOf(right2, listExpr)) {
										removedAlias = aliasVar2;
										matched = true;
										switch (right2.def) {
											case EAccess(tgt2, key2) if (switch (tgt2.def) {
											case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
												true;											
											default:
												false;											
										}):
												promoteFieldsList = true;											
											default:
										};
									};								
								default:
							};						
						default:
					};
					if (!matched) newStmts.push(s);
				};
				if (binderName == null && removedAlias != null) binderName = "elem";
				if (binderName == null) return node;
				var rewritten:Array<ElixirAST> = [];
				for (s  in  newStmts) {
					var keep = switch (s.def) {
						case EInteger(v) if (v == 0 || v == 1):
							false;						
						case EFloat(f) if (f == 0.0):
							false;						
						default:
							true;						
					};
					if (!keep) continue;
					var s2 = if (removedAlias != null) replaceVarInExpr(s, removedAlias, binderName) else s;
					rewritten.push(s2);
				};
				if (removedAlias == null && binderName != null) {
					var bodyForVars = (rewritten.length == 1) ? rewritten[0] : makeAST(EBlock(rewritten));
					var varsUsed = collectVars(bodyForVars);
					varsUsed.remove(binderName);
					if (varsUsed.exists("_" + binderName)) varsUsed.remove("_" + binderName);
					if (varsUsed.exists("id")) varsUsed.remove("id");
					var declared = new Map<String,Bool>();
					for (s  in  newStmts) switch (s.def) {
						case EBinary(Match, left, _):
							switch (left.def) {
								case EVar(n):
									declared.set(n, true);								
								default:
							};						
						case EMatch(pat, _):
							switch (pat) {
								case PVar(n2):
									declared.set(n2, true);								
								default:
							};						
						default:
					};
					var tmp:Array<ElixirAST> = [];
					for (s  in  rewritten) {
						var s2 = s;
						for (k  in  varsUsed.keys()) {
							if (!declared.exists(k)) s2 = replaceVarInExpr(s2, k, binderName);
						};
						tmp.push(s2);
					};
					rewritten = tmp;
				};
				var newBody = (rewritten.length == 1) ? rewritten[0] : makeAST(EBlock(rewritten));
				var finalBinderName = safeBinder(binderName);
				var finalBinder:EPattern = bodyUsesVar(newBody, finalBinderName) ? PVar(finalBinderName) : PWildcard;
				var newFn = makeAST(EFn([{ args : [finalBinder], guard : clause.guard, body : newBody }]));
				if (promoteFieldsList) {
					var fieldsVar = "fields";
					var fieldBinder = "field";
					var assign = makeAST(EBinary(Match, makeAST(EVar(fieldsVar)), makeAST(ERemoteCall(makeAST(EVar("Map")), "keys", [listExpr]))));
					var fn2 = makeAST(EFn([{ args : [PVar(fieldBinder)], guard : clause.guard, body : replaceVarInExpr(newBody, finalBinderName, fieldBinder) }]));
					var eachCall = makeAST(ERemoteCall(mod, func, [makeAST(EVar(fieldsVar)), fn2]));
					makeASTWithMeta(EBlock([assign, eachCall]), node.metadata, node.pos);
				} else {
					var eachList = listExpr;
					makeASTWithMeta(ERemoteCall(mod, func, [eachList, newFn]), node.metadata, node.pos);
				};			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var mod = `;
						var func = `;
						var args = `;
						if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
							var ` = mod.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var name = `;
									if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						}) {
							var listExpr = args[0];
							var fnNode = args[1];
							@:ast(switch (fnNode.def) {
	case EFn(clauses) if (clauses.length == 1):
		var clause = clauses[0];
		var binderName:Null<String> = null;
		switch (clause.args.length > 0 ? clause.args[0] : null) {
			case PVar(n):
				binderName = n;			
			default:
		};
		var newStmts:Array<ElixirAST> = [];
		var removedAlias:Null<String> = null;
		var promoteFieldsList:Bool = false;
		var stmts:Array<ElixirAST> = switch (clause.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[clause.body];			
		};
		for (s  in  stmts) {
			var matched = false;
			switch (s.def) {
				case EBinary(Match, left, right):
					switch (left.def) {
						case EVar(aliasVar):
							if (isHeadAccessOf(right, listExpr)) {
								removedAlias = aliasVar;
								matched = true;
								switch (right.def) {
									case EAccess(tgt, key) if (switch (tgt.def) {
									case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
										true;									
									default:
										false;									
								}):
										promoteFieldsList = true;									
									default:
								};
							};						
						default:
					};				
				case EMatch(pattern, right2):
					switch (pattern) {
						case PVar(aliasVar2):
							if (isHeadAccessOf(right2, listExpr)) {
								removedAlias = aliasVar2;
								matched = true;
								switch (right2.def) {
									case EAccess(tgt2, key2) if (switch (tgt2.def) {
									case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
										true;									
									default:
										false;									
								}):
										promoteFieldsList = true;									
									default:
								};
							};						
						default:
					};				
				default:
			};
			if (!matched) newStmts.push(s);
		};
		if (binderName == null && removedAlias != null) binderName = "elem";
		if (binderName == null) return node;
		var rewritten:Array<ElixirAST> = [];
		for (s  in  newStmts) {
			var keep = switch (s.def) {
				case EInteger(v) if (v == 0 || v == 1):
					false;				
				case EFloat(f) if (f == 0.0):
					false;				
				default:
					true;				
			};
			if (!keep) continue;
			var s2 = if (removedAlias != null) replaceVarInExpr(s, removedAlias, binderName) else s;
			rewritten.push(s2);
		};
		if (removedAlias == null && binderName != null) {
			var bodyForVars = (rewritten.length == 1) ? rewritten[0] : makeAST(EBlock(rewritten));
			var varsUsed = collectVars(bodyForVars);
			varsUsed.remove(binderName);
			if (varsUsed.exists("_" + binderName)) varsUsed.remove("_" + binderName);
			if (varsUsed.exists("id")) varsUsed.remove("id");
			var declared = new Map<String,Bool>();
			for (s  in  newStmts) switch (s.def) {
				case EBinary(Match, left, _):
					switch (left.def) {
						case EVar(n):
							declared.set(n, true);						
						default:
					};				
				case EMatch(pat, _):
					switch (pat) {
						case PVar(n2):
							declared.set(n2, true);						
						default:
					};				
				default:
			};
			var tmp:Array<ElixirAST> = [];
			for (s  in  rewritten) {
				var s2 = s;
				for (k  in  varsUsed.keys()) {
					if (!declared.exists(k)) s2 = replaceVarInExpr(s2, k, binderName);
				};
				tmp.push(s2);
			};
			rewritten = tmp;
		};
		var newBody = (rewritten.length == 1) ? rewritten[0] : makeAST(EBlock(rewritten));
		var finalBinderName = safeBinder(binderName);
		var finalBinder:EPattern = bodyUsesVar(newBody, finalBinderName) ? PVar(finalBinderName) : PWildcard;
		var newFn = makeAST(EFn([{ args : [finalBinder], guard : clause.guard, body : newBody }]));
		if (promoteFieldsList) {
			var fieldsVar = "fields";
			var fieldBinder = "field";
			var assign = makeAST(EBinary(Match, makeAST(EVar(fieldsVar)), makeAST(ERemoteCall(makeAST(EVar("Map")), "keys", [listExpr]))));
			var fn2 = makeAST(EFn([{ args : [PVar(fieldBinder)], guard : clause.guard, body : replaceVarInExpr(newBody, finalBinderName, fieldBinder) }]));
			var eachCall = makeAST(ERemoteCall(mod, func, [makeAST(EVar(fieldsVar)), fn2]));
			makeASTWithMeta(EBlock([assign, eachCall]), node.metadata, node.pos);
		} else {
			var eachList = listExpr;
			makeASTWithMeta(ERemoteCall(mod, func, [eachList, newFn]), node.metadata, node.pos);
		};	
	default:
		node;	
}) {
								var ` = fnNode.def;
								if (enumIndex ` == 42) {
									var ` = `[0];
									{
										var clauses = `;
										if (clauses.length == 1) {
											var clause = clauses[0];
											var binderName = null;
											@:ast(switch (clause.args.length > 0 ? clause.args[0] : null) {
	case PVar(n):
		binderName = n;	
	default:
}) {
												var ` = if (clause.args.length > 0) {
													clause.args[0];
												} else {
													null;
												};
												if (` == null) {} else if (enumIndex ` == 0) {
													var ` = `[0];
													{
														var n = `;
														{
															binderName = n;
														};
													};
												} else {};
											};
											var newStmts = [];
											var removedAlias = null;
											var promoteFieldsList = false;
											var stmts = @:ast(switch (clause.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[clause.body];	
}) {
												var ` = clause.body.def;
												if (enumIndex ` == 53) {
													var ` = `[0];
													{
														var ss = `;
														{
															ss;
														};
													};
												} else {
													[clause.body];
												};
											};
											{
												var ` = 0;
												while (` < stmts.length) {
													var s = stmts[`];
													++ `;
													var matched = false;
													@:ast(switch (s.def) {
	case EBinary(Match, left, right):
		switch (left.def) {
			case EVar(aliasVar):
				if (isHeadAccessOf(right, listExpr)) {
					removedAlias = aliasVar;
					matched = true;
					switch (right.def) {
						case EAccess(tgt, key) if (switch (tgt.def) {
						case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
							true;						
						default:
							false;						
					}):
							promoteFieldsList = true;						
						default:
					};
				};			
			default:
		};	
	case EMatch(pattern, right2):
		switch (pattern) {
			case PVar(aliasVar2):
				if (isHeadAccessOf(right2, listExpr)) {
					removedAlias = aliasVar2;
					matched = true;
					switch (right2.def) {
						case EAccess(tgt2, key2) if (switch (tgt2.def) {
						case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
							true;						
						default:
							false;						
					}):
							promoteFieldsList = true;						
						default:
					};
				};			
			default:
		};	
	default:
}) {
														var ` = s.def;
														switch (enumIndex `) {
															case 8: {
																var ` = `[0];
																var ` = `[1];
																{
																	var pattern = `;
																	var right2 = `;
																	{
																		@:ast(switch (pattern) {
	case PVar(aliasVar2):
		if (isHeadAccessOf(right2, listExpr)) {
			removedAlias = aliasVar2;
			matched = true;
			switch (right2.def) {
				case EAccess(tgt2, key2) if (switch (tgt2.def) {
				case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
					true;				
				default:
					false;				
			}):
					promoteFieldsList = true;				
				default:
			};
		};	
	default:
}) if (enumIndex pattern == 0) {
																			var ` = pattern[0];
																			{
																				var aliasVar2 = `;
																				{
																					if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(right2, listExpr)) {
																						removedAlias = aliasVar2;
																						matched = true;
																						@:ast(switch (right2.def) {
	case EAccess(tgt2, key2) if (switch (tgt2.def) {
	case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
		true;	
	default:
		false;	
}):
		promoteFieldsList = true;	
	default:
}) {
																							var ` = right2.def;
																							if (enumIndex ` == 29) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var tgt2 = `;
																									var key2 = `;
																									if (@:ast(switch (tgt2.def) {
	case ERemoteCall({ def : EVar(mod2) }, fn2, args2) if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && astEquals(args2[0], listExpr)):
		true;	
	default:
		false;	
}) {
																										var ` = tgt2.def;
																										if (enumIndex ` == 24) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var mod2 = `;
																														var fn2 = `;
																														var args2 = `;
																														if (mod2 == "Reflect" && fn2 == "fields" && args2 != null && args2.length == 1 && reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.astEquals(args2[0], listExpr)) {
																															true;
																														} else {
																															false;
																														};
																													};
																												} else {
																													false;
																												};
																											};
																										} else {
																											false;
																										};
																									}) {
																										promoteFieldsList = true;
																									} else {};
																								};
																							} else {};
																						};
																					};
																				};
																			};
																		} else {};
																	};
																};
															};
															case 26: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																if (enumIndex ` == 27) {
																	{
																		var left = `;
																		var right = `;
																		{
																			@:ast(switch (left.def) {
	case EVar(aliasVar):
		if (isHeadAccessOf(right, listExpr)) {
			removedAlias = aliasVar;
			matched = true;
			switch (right.def) {
				case EAccess(tgt, key) if (switch (tgt.def) {
				case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
					true;				
				default:
					false;				
			}):
					promoteFieldsList = true;				
				default:
			};
		};	
	default:
}) {
																				var ` = left.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var aliasVar = `;
																						{
																							if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(right, listExpr)) {
																								removedAlias = aliasVar;
																								matched = true;
																								@:ast(switch (right.def) {
	case EAccess(tgt, key) if (switch (tgt.def) {
	case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
		true;	
	default:
		false;	
}):
		promoteFieldsList = true;	
	default:
}) {
																									var ` = right.def;
																									if (enumIndex ` == 29) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var tgt = `;
																											var key = `;
																											if (@:ast(switch (tgt.def) {
	case ERemoteCall({ def : EVar(mod) }, fn, args) if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && astEquals(args[0], listExpr)):
		true;	
	default:
		false;	
}) {
																												var ` = tgt.def;
																												if (enumIndex ` == 24) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													{
																														var ` = `.def;
																														var ` = `.metadata;
																														var ` = `.pos;
																														if (enumIndex ` == 38) {
																															var ` = `[0];
																															{
																																var mod = `;
																																var fn = `;
																																var args = `;
																																if (mod == "Reflect" && fn == "fields" && args != null && args.length == 1 && reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.astEquals(args[0], listExpr)) {
																																	true;
																																} else {
																																	false;
																																};
																															};
																														} else {
																															false;
																														};
																													};
																												} else {
																													false;
																												};
																											}) {
																												promoteFieldsList = true;
																											} else {};
																										};
																									} else {};
																								};
																							};
																						};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
															default: {}
														};
													};
													if (! matched) {
														newStmts.push(s);
													};
												};
											};
											if (binderName == null && removedAlias != null) {
												binderName = "elem";
											};
											if (binderName == null) {
												return node;
											};
											var rewritten = [];
											{
												var ` = 0;
												while (` < newStmts.length) {
													var s = newStmts[`];
													++ `;
													var keep = @:ast(switch (s.def) {
	case EInteger(v) if (v == 0 || v == 1):
		false;	
	case EFloat(f) if (f == 0.0):
		false;	
	default:
		true;	
}) {
														var ` = s.def;
														switch (enumIndex `) {
															case 33: {
																var ` = `[0];
																{
																	var v = `;
																	if (v == 0 || v == 1) {
																		false;
																	} else {
																		true;
																	};
																};
															};
															case 34: {
																var ` = `[0];
																{
																	var f = `;
																	if (f == 0.0) {
																		false;
																	} else {
																		true;
																	};
																};
															};
															default: {
																true;
															}
														};
													};
													if (! keep) {
														continue;
													};
													var s2 = if (removedAlias != null) {
														reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(s, removedAlias, binderName);
													} else {
														s;
													};
													rewritten.push(s2);
												};
											};
											if (removedAlias == null && binderName != null) {
												var bodyForVars = if ((rewritten.length == 1)) {
													rewritten[0];
												} else {
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(rewritten), metadata : {}, pos : pos};
													};
												};
												var varsUsed = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.collectVars(bodyForVars);
												varsUsed.remove(binderName);
												if (varsUsed.exists("_" + binderName)) {
													varsUsed.remove("_" + binderName);
												};
												if (varsUsed.exists("id")) {
													varsUsed.remove("id");
												};
												var declared = {
													{};
													new haxe.ds.StringMap();
												};
												{
													var ` = 0;
													while (` < newStmts.length) {
														var s = newStmts[`];
														++ `;
														@:ast(switch (s.def) {
	case EBinary(Match, left, _):
		switch (left.def) {
			case EVar(n):
				declared.set(n, true);			
			default:
		};	
	case EMatch(pat, _):
		switch (pat) {
			case PVar(n2):
				declared.set(n2, true);			
			default:
		};	
	default:
}) {
															var ` = s.def;
															switch (enumIndex `) {
																case 8: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var pat = `;
																		{
																			@:ast(switch (pat) {
	case PVar(n2):
		declared.set(n2, true);	
	default:
}) if (enumIndex pat == 0) {
																				var ` = pat[0];
																				{
																					var n2 = `;
																					{
																						{
																							declared.set(n2, true);
																						};
																					};
																				};
																			} else {};
																		};
																	};
																};
																case 26: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	if (enumIndex ` == 27) {
																		{
																			var left = `;
																			{
																				@:ast(switch (left.def) {
	case EVar(n):
		declared.set(n, true);	
	default:
}) {
																					var ` = left.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var n = `;
																							{
																								{
																									declared.set(n, true);
																								};
																							};
																						};
																					} else {};
																				};
																			};
																		};
																	} else {};
																};
																default: {}
															};
														};
													};
												};
												var tmp = [];
												{
													var ` = 0;
													while (` < rewritten.length) {
														var s = rewritten[`];
														++ `;
														var s2 = s;
														for (k in varsUsed.keys()) {
															if (! declared.exists(k)) {
																s2 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(s2, k, binderName);
															};
														};
														tmp.push(s2);
													};
												};
												rewritten = tmp;
											};
											var newBody = if ((rewritten.length == 1)) {
												rewritten[0];
											} else {
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(rewritten), metadata : {}, pos : pos};
												};
											};
											var finalBinderName = if ((binderName != null && binderName.length > 0 && binderName.charAt(0) == "_")) {
												binderName.substr(1, null);
											} else {
												binderName;
											};
											var finalBinder = if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.bodyUsesVar(newBody, finalBinderName)) {
												reflaxe.elixir.ast.EPattern.PVar(finalBinderName);
											} else {
												reflaxe.elixir.ast.EPattern.PWildcard;
											};
											var newFn = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [finalBinder], guard : clause.guard, body : newBody}]), metadata : {}, pos : pos};
											};
											if (promoteFieldsList) {
												var fieldsVar = "fields";
												var fieldBinder = "field";
												var assign = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fieldsVar), metadata : {}, pos : pos};
													}, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
														}, "keys", [listExpr]), metadata : {}, pos : pos};
													}), metadata : {}, pos : pos};
												};
												var fn2 = {
													var def = reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(fieldBinder)], guard : clause.guard, body : reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(newBody, finalBinderName, fieldBinder)}]);
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												};
												var eachCall = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, [{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fieldsVar), metadata : {}, pos : pos};
													}, fn2]), metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([assign, eachCall]), metadata : node.metadata, pos : node.pos};
											} else {
												var eachList = listExpr;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, [eachList, newFn]), metadata : node.metadata, pos : node.pos};
											};
										} else {
											node;
										};
									};
								} else {
									node;
								};
							};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static inline function isEnumEach(mod:reflaxe.elixir.ast.ElixirAST, func:String, args:Array<reflaxe.elixir.ast.ElixirAST>) {
		return @:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
			var ` = mod.def;
			if (enumIndex ` == 38) {
				var ` = `[0];
				{
					var name = `;
					if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
						true;
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
	}

	static function isHeadAccessOf(expr:reflaxe.elixir.ast.ElixirAST, listExpr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EAccess(target, key):
		var keyIsZero = switch (key.def) {
			case EInteger(v) if (v == 0):
				true;			
			default:
				false;			
		};
		if (!keyIsZero) return false;
		if (astEquals(target, listExpr)) return true;
		switch (target.def) {
			case ERemoteCall({ def : EVar(mod) }, func, args) if (mod == "Reflect" && func == "fields" && args != null && args.length == 1):
				return astEquals(args[0], listExpr);			
			default:
		};
		false;	
	default:
		false;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 29) {
				var ` = `[0];
				var ` = `[1];
				{
					var target = `;
					var key = `;
					{
						var keyIsZero = @:ast(switch (key.def) {
	case EInteger(v) if (v == 0):
		true;	
	default:
		false;	
}) {
							var ` = key.def;
							if (enumIndex ` == 33) {
								var ` = `[0];
								{
									var v = `;
									if (v == 0) {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						};
						if (! keyIsZero) {
							return false;
						};
						if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.astEquals(target, listExpr)) {
							return true;
						};
						@:ast(switch (target.def) {
	case ERemoteCall({ def : EVar(mod) }, func, args) if (mod == "Reflect" && func == "fields" && args != null && args.length == 1):
		return astEquals(args[0], listExpr);	
	default:
}) {
							var ` = target.def;
							if (enumIndex ` == 24) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								{
									var ` = `.def;
									var ` = `.metadata;
									var ` = `.pos;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var mod = `;
											var func = `;
											var args = `;
											if (mod == "Reflect" && func == "fields" && args != null && args.length == 1) {
												return reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.astEquals(args[0], listExpr);
											} else {};
										};
									} else {};
								};
							} else {};
						};
						false;
					};
				};
			} else {
				false;
			};
		};
	}

	static function astEquals(a:reflaxe.elixir.ast.ElixirAST, b:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTPrinter.print(a, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(b, 0);
	}

	static function replaceVarInExpr(n:reflaxe.elixir.ast.ElixirAST, from:String, to:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EVar(name) if (name == from):
		makeASTWithMeta(EVar(to), x.metadata, x.pos);	
	case EString(str):
		var s = str;
		if (s != null && s.indexOf("#{") != -1) {
			var needle1 = "#{" + from + "}";
			var needle2 = "#{" + from + ".";
			var repl1 = "#{" + to + "}";
			var repl2 = "#{" + to + ".";
			s = s.split(needle1).join(repl1);
			s = s.split(needle2).join(repl2);
		};
		makeASTWithMeta(EString(s), x.metadata, x.pos);	
	default:
		x;	
}) {
				var ` = x.def;
				switch (enumIndex `) {
					case 32: {
						var ` = `[0];
						{
							var str = `;
							{
								var s = str;
								if (s != null && s.indexOf("#{", null) != -1) {
									var needle1 = "#{" + from + "}";
									var needle2 = "#{" + from + ".";
									var repl1 = "#{" + to + "}";
									var repl2 = "#{" + to + ".";
									s = s.split(needle1).join(repl1);
									s = s.split(needle2).join(repl2);
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EString(s), metadata : x.metadata, pos : x.pos};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							if (name == from) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(to), metadata : x.metadata, pos : x.pos};
							} else {
								x;
							};
						};
					};
					default: {
						x;
					}
				};
			};
		});
	}

	static function replaceVarWithExpr(n:reflaxe.elixir.ast.ElixirAST, from:String, toExpr:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (x.def) {
	case EVar(name) if (name == from):
		makeASTWithMeta(toExpr.def, x.metadata, x.pos);	
	default:
		x;	
}) {
				var ` = x.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var name = `;
						if (name == from) {
							{def : toExpr.def, metadata : x.metadata, pos : x.pos};
						} else {
							x;
						};
					};
				} else {
					x;
				};
			};
		});
	}

	public static function countRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts) if (stmts.length >= 3):
		if (stmts.length == 3) {
			var cvar:Null<String> = null;
			var listExpr0:Null<ElixirAST> = null;
			var binder0:String = "_elem";
			var pred0:Null<ElixirAST> = null;
			switch (stmts[0].def) {
				case EBinary(Match, leftX0, rhsX0):
					switch (leftX0.def) {
						case EVar(nm0):
							cvar = (switch (rhsX0.def) {
								case EInteger(v0) if (v0 == 0):
									nm0;								
								default:
									null;								
							});						
						default:
					};				
				case EMatch(pat0, rhs0):
					switch (pat0) {
						case PVar(nm0b):
							cvar = (switch (rhs0.def) {
								case EInteger(v0b) if (v0b == 0):
									nm0b;								
								default:
									null;								
							});						
						default:
					};				
				default:
			};
			var eachExpr0:Null<ElixirAST> = null;
			switch (stmts[1].def) {
				case ERemoteCall(mod0, func0, args0) if (isEnumEach(mod0, func0, args0) && args0.length == 2):
					eachExpr0 = stmts[1];				
				case EMatch(_, rhsM0):
					switch (rhsM0.def) {
						case ERemoteCall(mod1, func1, args1) if (isEnumEach(mod1, func1, args1) && args1.length == 2):
							eachExpr0 = rhsM0;						
						default:
					};				
				case EBinary(Match, _, rhsB0):
					switch (rhsB0.def) {
						case ERemoteCall(mod2, func2, args2) if (isEnumEach(mod2, func2, args2) && args2.length == 2):
							eachExpr0 = rhsB0;						
						default:
					};				
				default:
					eachExpr0 = null;				
			};
			if (cvar != null && eachExpr0 != null) {
				switch (eachExpr0.def) {
					case ERemoteCall(_m0, _f0, argsE):
						listExpr0 = argsE[0];
						switch (argsE[1].def) {
							case EFn(clauses0) if (clauses0.length == 1):
								var cl0 = clauses0[0];
								switch (cl0.args.length > 0 ? cl0.args[0] : null) {
									case PVar(n0):
										binder0 = n0;									
									default:
								};
								var body0:Array<ElixirAST> = switch (cl0.body.def) {
									case EBlock(ss0):
										ss0;									
									default:
										[cl0.body];									
								};
								var alias0:Null<String> = null;
								for (bs0  in  body0) switch (bs0.def) {
									case EBinary(Match, lA0, rA0):
										switch (lA0.def) {
											case EVar(an0):
												if (isHeadAccessOf(rA0, listExpr0)) alias0 = an0;											
											default:
										};									
									case EMatch(patA0, rA1):
										switch (patA0) {
											case PVar(an1):
												if (isHeadAccessOf(rA1, listExpr0)) alias0 = an1;											
											default:
										};									
									case EIf(cond0, then0, _):
										if (pred0 == null) pred0 = cond0;									
									default:
								};
								if (alias0 != null && pred0 != null) {
									pred0 = replaceVarInExpr(pred0, alias0, binder0);
								};
								if (pred0 != null) {
									pred0 = normalizePredicateToBinder(pred0, binder0);
								};							
							default:
						};					
					default:
				};
			};
			var returns0 = switch (stmts[2].def) {
				case EVar(nr0) if (cvar != null && nr0 == cvar):
					true;				
				default:
					false;				
			};
			if (returns0 && listExpr0 != null && pred0 != null) {
				var adjusted0 = safeBinder(binder0);
				pred0 = replaceVarInExpr(pred0, binder0, adjusted0);
				pred0 = replaceVarInExpr(pred0, "_" + adjusted0, adjusted0);
				pred0 = normalizePredicateToBinder(pred0, adjusted0);
				var fn0 = makeAST(EFn([{ args : [PVar(adjusted0)], guard : null, body : pred0 }]));
				var new0 = makeAST(ERemoteCall(makeAST(EVar("Enum")), "count", [listExpr0, fn0]));
				return makeASTWithMeta(new0.def, node.metadata, node.pos);
			};
		};
		var countVar:Null<String> = null;
		var listExpr:Null<ElixirAST> = null;
		var binderName:String = "_elem";
		var predicate:Null<ElixirAST> = null;
		for (i  in  0 ... stmts.length) switch (stmts[i].def) {
			case EBinary(Match, left0, rhs):
				switch (left0.def) {
					case EVar(name):
						switch (rhs.def) {
							case EInteger(v) if (v == 0):
								countVar = name;							
							default:
						};					
					default:
				};			
			default:
		};
		if (countVar == null) return node;
		for (i  in  0 ... stmts.length) {
			var eachCall:Null<ElixirAST> = null;
			var aliasFromHead:Null<String> = null;
			switch (stmts[i].def) {
				case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
					eachCall = stmts[i];				
				case EMatch(_, rhs):
					switch (rhs.def) {
						case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
							eachCall = rhs;						
						default:
					};				
				case EBinary(Match, _, rhs2):
					switch (rhs2.def) {
						case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
							eachCall = rhs2;						
						default:
					};				
				default:
			};
			if (eachCall != null) {
				switch (eachCall.def) {
					case ERemoteCall(mod, func, args):
						listExpr = args[0];
						switch (args[1].def) {
							case EFn(clauses) if (clauses.length == 1):
								var cl = clauses[0];
								switch (cl.args.length > 0 ? cl.args[0] : null) {
									case PVar(n):
										binderName = n;									
									default:
								};
								var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
									case EBlock(ss):
										ss;									
									default:
										[cl.body];									
								};
								for (bs  in  bodyStmts) switch (bs.def) {
									case EBinary(Match, leftAlias, rightAlias):
										switch (leftAlias.def) {
											case EVar(an):
												if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;											
											default:
										};									
									case EMatch(patAlias, rightAlias2):
										switch (patAlias) {
											case PVar(an2):
												if (isHeadAccessOf(rightAlias2, listExpr)) aliasFromHead = an2;											
											default:
										};									
									case EIf(cond, thenBr, _):
										var inc = false;
										switch (thenBr.def) {
											case EBlock(ts):
												for (t  in  ts) if (isCountIncrement(t, countVar)) {
													inc = true;
													break;
												};											
											default:
												if (isCountIncrement(thenBr, countVar)) inc = true;											
										};
										if (inc) {
											var adjusted = if (aliasFromHead != null) replaceVarInExpr(cond, aliasFromHead, binderName) else cond;
											if (ElixirASTPrinter.print(adjusted, 0) == ElixirASTPrinter.print(cond, 0)) {
												switch (cond.def) {
													case EBinary(Equal, l2, r2):
														switch (l2.def) {
															case EField(objL, fieldL):
																switch (objL.def) {
																	case EVar(_):
																		adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));																	
																	default:
																};															
															default:
														};
														switch (r2.def) {
															case EField(objR, fieldR):
																switch (objR.def) {
																	case EVar(_):
																		adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));																	
																	default:
																};															
															default:
														};													
													default:
												};
											};
											predicate = adjusted;
										};									
									default:
								};							
							default:
						};					
					default:
				};
			};
		};
		if (predicate == null || listExpr == null) return node;
		var lastExpr = stmts[stmts.length - 1];
		var returnsCount = switch (lastExpr.def) {
			case EVar(n) if (n == countVar):
				true;			
			default:
				false;			
		};
		if (!returnsCount) return node;
		var adjustedBinder2 = safeBinder(binderName);
		predicate = replaceVarInExpr(predicate, binderName, adjustedBinder2);
		predicate = replaceVarInExpr(predicate, "_" + adjustedBinder2, adjustedBinder2);
		var fnNode = makeAST(EFn([{ args : [PVar(adjustedBinder2)], guard : null, body : predicate }]));
		var newCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "count", [listExpr, fnNode]));
		makeASTWithMeta(newCall.def, node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length >= 3) {
							if (stmts.length == 3) {
								var cvar = null;
								var listExpr0 = null;
								var binder0 = "_elem";
								var pred0 = null;
								@:ast(switch (stmts[0].def) {
	case EBinary(Match, leftX0, rhsX0):
		switch (leftX0.def) {
			case EVar(nm0):
				cvar = (switch (rhsX0.def) {
					case EInteger(v0) if (v0 == 0):
						nm0;					
					default:
						null;					
				});			
			default:
		};	
	case EMatch(pat0, rhs0):
		switch (pat0) {
			case PVar(nm0b):
				cvar = (switch (rhs0.def) {
					case EInteger(v0b) if (v0b == 0):
						nm0b;					
					default:
						null;					
				});			
			default:
		};	
	default:
}) {
									var ` = stmts[0].def;
									switch (enumIndex `) {
										case 8: {
											var ` = `[0];
											var ` = `[1];
											{
												var pat0 = `;
												var rhs0 = `;
												{
													@:ast(switch (pat0) {
	case PVar(nm0b):
		cvar = (switch (rhs0.def) {
			case EInteger(v0b) if (v0b == 0):
				nm0b;			
			default:
				null;			
		});	
	default:
}) if (enumIndex pat0 == 0) {
														var ` = pat0[0];
														{
															var nm0b = `;
															{
																cvar = (@:ast(switch (rhs0.def) {
	case EInteger(v0b) if (v0b == 0):
		nm0b;	
	default:
		null;	
}) {
																	var ` = rhs0.def;
																	if (enumIndex ` == 33) {
																		var ` = `[0];
																		{
																			var v0b = `;
																			if (v0b == 0) {
																				nm0b;
																			} else {
																				null;
																			};
																		};
																	} else {
																		null;
																	};
																});
															};
														};
													} else {};
												};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 27) {
												{
													var leftX0 = `;
													var rhsX0 = `;
													{
														@:ast(switch (leftX0.def) {
	case EVar(nm0):
		cvar = (switch (rhsX0.def) {
			case EInteger(v0) if (v0 == 0):
				nm0;			
			default:
				null;			
		});	
	default:
}) {
															var ` = leftX0.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var nm0 = `;
																	{
																		cvar = (@:ast(switch (rhsX0.def) {
	case EInteger(v0) if (v0 == 0):
		nm0;	
	default:
		null;	
}) {
																			var ` = rhsX0.def;
																			if (enumIndex ` == 33) {
																				var ` = `[0];
																				{
																					var v0 = `;
																					if (v0 == 0) {
																						nm0;
																					} else {
																						null;
																					};
																				};
																			} else {
																				null;
																			};
																		});
																	};
																};
															} else {};
														};
													};
												};
											} else {};
										};
										default: {}
									};
								};
								var eachExpr0 = null;
								@:ast(switch (stmts[1].def) {
	case ERemoteCall(mod0, func0, args0) if (isEnumEach(mod0, func0, args0) && args0.length == 2):
		eachExpr0 = stmts[1];	
	case EMatch(_, rhsM0):
		switch (rhsM0.def) {
			case ERemoteCall(mod1, func1, args1) if (isEnumEach(mod1, func1, args1) && args1.length == 2):
				eachExpr0 = rhsM0;			
			default:
		};	
	case EBinary(Match, _, rhsB0):
		switch (rhsB0.def) {
			case ERemoteCall(mod2, func2, args2) if (isEnumEach(mod2, func2, args2) && args2.length == 2):
				eachExpr0 = rhsB0;			
			default:
		};	
	default:
		eachExpr0 = null;	
}) {
									var ` = stmts[1].def;
									switch (enumIndex `) {
										case 8: {
											var ` = `[0];
											var ` = `[1];
											{
												var rhsM0 = `;
												{
													@:ast(switch (rhsM0.def) {
	case ERemoteCall(mod1, func1, args1) if (isEnumEach(mod1, func1, args1) && args1.length == 2):
		eachExpr0 = rhsM0;	
	default:
}) {
														var ` = rhsM0.def;
														if (enumIndex ` == 24) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var mod1 = `;
																var func1 = `;
																var args1 = `;
																if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																	var ` = mod1.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var name = `;
																			if ((name == "Enum") && func1 == "each" && args1 != null && args1.length == 2) {
																				true;
																			} else {
																				false;
																			};
																		};
																	} else {
																		false;
																	};
																} && args1.length == 2) {
																	eachExpr0 = rhsM0;
																} else {};
															};
														} else {};
													};
												};
											};
										};
										case 24: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var mod0 = `;
												var func0 = `;
												var args0 = `;
												if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
													var ` = mod0.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var name = `;
															if ((name == "Enum") && func0 == "each" && args0 != null && args0.length == 2) {
																true;
															} else {
																false;
															};
														};
													} else {
														false;
													};
												} && args0.length == 2) {
													eachExpr0 = stmts[1];
												} else {
													eachExpr0 = null;
												};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 27) {
												{
													var rhsB0 = `;
													{
														@:ast(switch (rhsB0.def) {
	case ERemoteCall(mod2, func2, args2) if (isEnumEach(mod2, func2, args2) && args2.length == 2):
		eachExpr0 = rhsB0;	
	default:
}) {
															var ` = rhsB0.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod2 = `;
																	var func2 = `;
																	var args2 = `;
																	if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																		var ` = mod2.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				if ((name == "Enum") && func2 == "each" && args2 != null && args2.length == 2) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	} && args2.length == 2) {
																		eachExpr0 = rhsB0;
																	} else {};
																};
															} else {};
														};
													};
												};
											} else {
												eachExpr0 = null;
											};
										};
										default: {
											eachExpr0 = null;
										}
									};
								};
								if (cvar != null && eachExpr0 != null) {
									@:ast(switch (eachExpr0.def) {
	case ERemoteCall(_m0, _f0, argsE):
		listExpr0 = argsE[0];
		switch (argsE[1].def) {
			case EFn(clauses0) if (clauses0.length == 1):
				var cl0 = clauses0[0];
				switch (cl0.args.length > 0 ? cl0.args[0] : null) {
					case PVar(n0):
						binder0 = n0;					
					default:
				};
				var body0:Array<ElixirAST> = switch (cl0.body.def) {
					case EBlock(ss0):
						ss0;					
					default:
						[cl0.body];					
				};
				var alias0:Null<String> = null;
				for (bs0  in  body0) switch (bs0.def) {
					case EBinary(Match, lA0, rA0):
						switch (lA0.def) {
							case EVar(an0):
								if (isHeadAccessOf(rA0, listExpr0)) alias0 = an0;							
							default:
						};					
					case EMatch(patA0, rA1):
						switch (patA0) {
							case PVar(an1):
								if (isHeadAccessOf(rA1, listExpr0)) alias0 = an1;							
							default:
						};					
					case EIf(cond0, then0, _):
						if (pred0 == null) pred0 = cond0;					
					default:
				};
				if (alias0 != null && pred0 != null) {
					pred0 = replaceVarInExpr(pred0, alias0, binder0);
				};
				if (pred0 != null) {
					pred0 = normalizePredicateToBinder(pred0, binder0);
				};			
			default:
		};	
	default:
}) {
										var ` = eachExpr0.def;
										if (enumIndex ` == 24) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var _m0 = `;
												var _f0 = `;
												var argsE = `;
												{
													listExpr0 = argsE[0];
													@:ast(switch (argsE[1].def) {
	case EFn(clauses0) if (clauses0.length == 1):
		var cl0 = clauses0[0];
		switch (cl0.args.length > 0 ? cl0.args[0] : null) {
			case PVar(n0):
				binder0 = n0;			
			default:
		};
		var body0:Array<ElixirAST> = switch (cl0.body.def) {
			case EBlock(ss0):
				ss0;			
			default:
				[cl0.body];			
		};
		var alias0:Null<String> = null;
		for (bs0  in  body0) switch (bs0.def) {
			case EBinary(Match, lA0, rA0):
				switch (lA0.def) {
					case EVar(an0):
						if (isHeadAccessOf(rA0, listExpr0)) alias0 = an0;					
					default:
				};			
			case EMatch(patA0, rA1):
				switch (patA0) {
					case PVar(an1):
						if (isHeadAccessOf(rA1, listExpr0)) alias0 = an1;					
					default:
				};			
			case EIf(cond0, then0, _):
				if (pred0 == null) pred0 = cond0;			
			default:
		};
		if (alias0 != null && pred0 != null) {
			pred0 = replaceVarInExpr(pred0, alias0, binder0);
		};
		if (pred0 != null) {
			pred0 = normalizePredicateToBinder(pred0, binder0);
		};	
	default:
}) {
														var ` = argsE[1].def;
														if (enumIndex ` == 42) {
															var ` = `[0];
															{
																var clauses0 = `;
																if (clauses0.length == 1) {
																	var cl0 = clauses0[0];
																	@:ast(switch (cl0.args.length > 0 ? cl0.args[0] : null) {
	case PVar(n0):
		binder0 = n0;	
	default:
}) {
																		var ` = if (cl0.args.length > 0) {
																			cl0.args[0];
																		} else {
																			null;
																		};
																		if (` == null) {} else if (enumIndex ` == 0) {
																			var ` = `[0];
																			{
																				var n0 = `;
																				{
																					binder0 = n0;
																				};
																			};
																		} else {};
																	};
																	var body0 = @:ast(switch (cl0.body.def) {
	case EBlock(ss0):
		ss0;	
	default:
		[cl0.body];	
}) {
																		var ` = cl0.body.def;
																		if (enumIndex ` == 53) {
																			var ` = `[0];
																			{
																				var ss0 = `;
																				{
																					ss0;
																				};
																			};
																		} else {
																			[cl0.body];
																		};
																	};
																	var alias0 = null;
																	{
																		var ` = 0;
																		while (` < body0.length) {
																			var bs0 = body0[`];
																			++ `;
																			@:ast(switch (bs0.def) {
	case EBinary(Match, lA0, rA0):
		switch (lA0.def) {
			case EVar(an0):
				if (isHeadAccessOf(rA0, listExpr0)) alias0 = an0;			
			default:
		};	
	case EMatch(patA0, rA1):
		switch (patA0) {
			case PVar(an1):
				if (isHeadAccessOf(rA1, listExpr0)) alias0 = an1;			
			default:
		};	
	case EIf(cond0, then0, _):
		if (pred0 == null) pred0 = cond0;	
	default:
}) {
																				var ` = bs0.def;
																				switch (enumIndex `) {
																					case 8: {
																						var ` = `[0];
																						var ` = `[1];
																						{
																							var patA0 = `;
																							var rA1 = `;
																							{
																								@:ast(switch (patA0) {
	case PVar(an1):
		if (isHeadAccessOf(rA1, listExpr0)) alias0 = an1;	
	default:
}) if (enumIndex patA0 == 0) {
																									var ` = patA0[0];
																									{
																										var an1 = `;
																										{
																											if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rA1, listExpr0)) {
																												alias0 = an1;
																											};
																										};
																									};
																								} else {};
																							};
																						};
																					};
																					case 10: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var cond0 = `;
																							var then0 = `;
																							{
																								if (pred0 == null) {
																									pred0 = cond0;
																								};
																							};
																						};
																					};
																					case 26: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						if (enumIndex ` == 27) {
																							{
																								var lA0 = `;
																								var rA0 = `;
																								{
																									@:ast(switch (lA0.def) {
	case EVar(an0):
		if (isHeadAccessOf(rA0, listExpr0)) alias0 = an0;	
	default:
}) {
																										var ` = lA0.def;
																										if (enumIndex ` == 38) {
																											var ` = `[0];
																											{
																												var an0 = `;
																												{
																													if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rA0, listExpr0)) {
																														alias0 = an0;
																													};
																												};
																											};
																										} else {};
																									};
																								};
																							};
																						} else {};
																					};
																					default: {}
																				};
																			};
																		};
																	};
																	if (alias0 != null && pred0 != null) {
																		pred0 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(pred0, alias0, binder0);
																	};
																	if (pred0 != null) {
																		pred0 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.normalizePredicateToBinder(pred0, binder0);
																	};
																} else {};
															};
														} else {};
													};
												};
											};
										} else {};
									};
								};
								var returns0 = @:ast(switch (stmts[2].def) {
	case EVar(nr0) if (cvar != null && nr0 == cvar):
		true;	
	default:
		false;	
}) {
									var ` = stmts[2].def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var nr0 = `;
											if (cvar != null && nr0 == cvar) {
												true;
											} else {
												false;
											};
										};
									} else {
										false;
									};
								};
								if (returns0 && listExpr0 != null && pred0 != null) {
									var adjusted0 = if ((binder0 != null && binder0.length > 0 && binder0.charAt(0) == "_")) {
										binder0.substr(1, null);
									} else {
										binder0;
									};
									pred0 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(pred0, binder0, adjusted0);
									pred0 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(pred0, "_" + adjusted0, adjusted0);
									pred0 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.normalizePredicateToBinder(pred0, adjusted0);
									var fn0 = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(adjusted0)], guard : null, body : pred0}]), metadata : {}, pos : pos};
									};
									var new0 = {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
										}, "count", [listExpr0, fn0]), metadata : {}, pos : pos};
									};
									return {def : new0.def, metadata : node.metadata, pos : node.pos};
								};
							};
							var countVar = null;
							var listExpr = null;
							var binderName = "_elem";
							var predicate = null;
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case EBinary(Match, left0, rhs):
		switch (left0.def) {
			case EVar(name):
				switch (rhs.def) {
					case EInteger(v) if (v == 0):
						countVar = name;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										if (enumIndex ` == 26) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 27) {
												{
													var left0 = `;
													var rhs = `;
													{
														@:ast(switch (left0.def) {
	case EVar(name):
		switch (rhs.def) {
			case EInteger(v) if (v == 0):
				countVar = name;			
			default:
		};	
	default:
}) {
															var ` = left0.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var name = `;
																	{
																		@:ast(switch (rhs.def) {
	case EInteger(v) if (v == 0):
		countVar = name;	
	default:
}) {
																			var ` = rhs.def;
																			if (enumIndex ` == 33) {
																				var ` = `[0];
																				{
																					var v = `;
																					if (v == 0) {
																						countVar = name;
																					} else {};
																				};
																			} else {};
																		};
																	};
																};
															} else {};
														};
													};
												};
											} else {};
										} else {};
									};
								};
							};
							if (countVar == null) {
								return node;
							};
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									var eachCall = null;
									var aliasFromHead = null;
									@:ast(switch (stmts[i].def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachCall = stmts[i];	
	case EMatch(_, rhs):
		switch (rhs.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
				eachCall = rhs;			
			default:
		};	
	case EBinary(Match, _, rhs2):
		switch (rhs2.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
				eachCall = rhs2;			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var rhs = `;
													{
														@:ast(switch (rhs.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachCall = rhs;	
	default:
}) {
															var ` = rhs.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod = `;
																	var func = `;
																	var args = `;
																	if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																		var ` = mod.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	} && args.length == 2) {
																		eachCall = rhs;
																	} else {};
																};
															} else {};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
														var ` = mod.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var name = `;
																if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																	true;
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													} && args.length == 2) {
														eachCall = stmts[i];
													} else {};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var rhs2 = `;
														{
															@:ast(switch (rhs2.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachCall = rhs2;	
	default:
}) {
																var ` = rhs2.def;
																if (enumIndex ` == 24) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var func = `;
																		var args = `;
																		if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																			var ` = mod.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var name = `;
																					if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		} && args.length == 2) {
																			eachCall = rhs2;
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									if (eachCall != null) {
										@:ast(switch (eachCall.def) {
	case ERemoteCall(mod, func, args):
		listExpr = args[0];
		switch (args[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				switch (cl.args.length > 0 ? cl.args[0] : null) {
					case PVar(n):
						binderName = n;					
					default:
				};
				var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
					case EBlock(ss):
						ss;					
					default:
						[cl.body];					
				};
				for (bs  in  bodyStmts) switch (bs.def) {
					case EBinary(Match, leftAlias, rightAlias):
						switch (leftAlias.def) {
							case EVar(an):
								if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;							
							default:
						};					
					case EMatch(patAlias, rightAlias2):
						switch (patAlias) {
							case PVar(an2):
								if (isHeadAccessOf(rightAlias2, listExpr)) aliasFromHead = an2;							
							default:
						};					
					case EIf(cond, thenBr, _):
						var inc = false;
						switch (thenBr.def) {
							case EBlock(ts):
								for (t  in  ts) if (isCountIncrement(t, countVar)) {
									inc = true;
									break;
								};							
							default:
								if (isCountIncrement(thenBr, countVar)) inc = true;							
						};
						if (inc) {
							var adjusted = if (aliasFromHead != null) replaceVarInExpr(cond, aliasFromHead, binderName) else cond;
							if (ElixirASTPrinter.print(adjusted, 0) == ElixirASTPrinter.print(cond, 0)) {
								switch (cond.def) {
									case EBinary(Equal, l2, r2):
										switch (l2.def) {
											case EField(objL, fieldL):
												switch (objL.def) {
													case EVar(_):
														adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));													
													default:
												};											
											default:
										};
										switch (r2.def) {
											case EField(objR, fieldR):
												switch (objR.def) {
													case EVar(_):
														adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));													
													default:
												};											
											default:
										};									
									default:
								};
							};
							predicate = adjusted;
						};					
					default:
				};			
			default:
		};	
	default:
}) {
											var ` = eachCall.def;
											if (enumIndex ` == 24) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													{
														listExpr = args[0];
														@:ast(switch (args[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				binderName = n;			
			default:
		};
		var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[cl.body];			
		};
		for (bs  in  bodyStmts) switch (bs.def) {
			case EBinary(Match, leftAlias, rightAlias):
				switch (leftAlias.def) {
					case EVar(an):
						if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;					
					default:
				};			
			case EMatch(patAlias, rightAlias2):
				switch (patAlias) {
					case PVar(an2):
						if (isHeadAccessOf(rightAlias2, listExpr)) aliasFromHead = an2;					
					default:
				};			
			case EIf(cond, thenBr, _):
				var inc = false;
				switch (thenBr.def) {
					case EBlock(ts):
						for (t  in  ts) if (isCountIncrement(t, countVar)) {
							inc = true;
							break;
						};					
					default:
						if (isCountIncrement(thenBr, countVar)) inc = true;					
				};
				if (inc) {
					var adjusted = if (aliasFromHead != null) replaceVarInExpr(cond, aliasFromHead, binderName) else cond;
					if (ElixirASTPrinter.print(adjusted, 0) == ElixirASTPrinter.print(cond, 0)) {
						switch (cond.def) {
							case EBinary(Equal, l2, r2):
								switch (l2.def) {
									case EField(objL, fieldL):
										switch (objL.def) {
											case EVar(_):
												adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));											
											default:
										};									
									default:
								};
								switch (r2.def) {
									case EField(objR, fieldR):
										switch (objR.def) {
											case EVar(_):
												adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));											
											default:
										};									
									default:
								};							
							default:
						};
					};
					predicate = adjusted;
				};			
			default:
		};	
	default:
}) {
															var ` = args[1].def;
															if (enumIndex ` == 42) {
																var ` = `[0];
																{
																	var clauses = `;
																	if (clauses.length == 1) {
																		var cl = clauses[0];
																		@:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		binderName = n;	
	default:
}) {
																			var ` = if (cl.args.length > 0) {
																				cl.args[0];
																			} else {
																				null;
																			};
																			if (` == null) {} else if (enumIndex ` == 0) {
																				var ` = `[0];
																				{
																					var n = `;
																					{
																						binderName = n;
																					};
																				};
																			} else {};
																		};
																		var bodyStmts = @:ast(switch (cl.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[cl.body];	
}) {
																			var ` = cl.body.def;
																			if (enumIndex ` == 53) {
																				var ` = `[0];
																				{
																					var ss = `;
																					{
																						ss;
																					};
																				};
																			} else {
																				[cl.body];
																			};
																		};
																		{
																			var ` = 0;
																			while (` < bodyStmts.length) {
																				var bs = bodyStmts[`];
																				++ `;
																				@:ast(switch (bs.def) {
	case EBinary(Match, leftAlias, rightAlias):
		switch (leftAlias.def) {
			case EVar(an):
				if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;			
			default:
		};	
	case EMatch(patAlias, rightAlias2):
		switch (patAlias) {
			case PVar(an2):
				if (isHeadAccessOf(rightAlias2, listExpr)) aliasFromHead = an2;			
			default:
		};	
	case EIf(cond, thenBr, _):
		var inc = false;
		switch (thenBr.def) {
			case EBlock(ts):
				for (t  in  ts) if (isCountIncrement(t, countVar)) {
					inc = true;
					break;
				};			
			default:
				if (isCountIncrement(thenBr, countVar)) inc = true;			
		};
		if (inc) {
			var adjusted = if (aliasFromHead != null) replaceVarInExpr(cond, aliasFromHead, binderName) else cond;
			if (ElixirASTPrinter.print(adjusted, 0) == ElixirASTPrinter.print(cond, 0)) {
				switch (cond.def) {
					case EBinary(Equal, l2, r2):
						switch (l2.def) {
							case EField(objL, fieldL):
								switch (objL.def) {
									case EVar(_):
										adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));									
									default:
								};							
							default:
						};
						switch (r2.def) {
							case EField(objR, fieldR):
								switch (objR.def) {
									case EVar(_):
										adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));									
									default:
								};							
							default:
						};					
					default:
				};
			};
			predicate = adjusted;
		};	
	default:
}) {
																					var ` = bs.def;
																					switch (enumIndex `) {
																						case 8: {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var patAlias = `;
																								var rightAlias2 = `;
																								{
																									@:ast(switch (patAlias) {
	case PVar(an2):
		if (isHeadAccessOf(rightAlias2, listExpr)) aliasFromHead = an2;	
	default:
}) if (enumIndex patAlias == 0) {
																										var ` = patAlias[0];
																										{
																											var an2 = `;
																											{
																												if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAlias2, listExpr)) {
																													aliasFromHead = an2;
																												};
																											};
																										};
																									} else {};
																								};
																							};
																						};
																						case 10: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var cond = `;
																								var thenBr = `;
																								{
																									var inc = false;
																									@:ast(switch (thenBr.def) {
	case EBlock(ts):
		for (t  in  ts) if (isCountIncrement(t, countVar)) {
			inc = true;
			break;
		};	
	default:
		if (isCountIncrement(thenBr, countVar)) inc = true;	
}) {
																										var ` = thenBr.def;
																										if (enumIndex ` == 53) {
																											var ` = `[0];
																											{
																												var ts = `;
																												{
																													{
																														var ` = 0;
																														while (` < ts.length) {
																															var t = ts[`];
																															++ `;
																															if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isCountIncrement(t, countVar)) {
																																inc = true;
																																break;
																															};
																														};
																													};
																												};
																											};
																										} else {
																											if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isCountIncrement(thenBr, countVar)) {
																												inc = true;
																											};
																										};
																									};
																									if (inc) {
																										var adjusted = if (aliasFromHead != null) {
																											reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(cond, aliasFromHead, binderName);
																										} else {
																											cond;
																										};
																										if (reflaxe.elixir.ast.ElixirASTPrinter.print(adjusted, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(cond, 0)) {
																											@:ast(switch (cond.def) {
	case EBinary(Equal, l2, r2):
		switch (l2.def) {
			case EField(objL, fieldL):
				switch (objL.def) {
					case EVar(_):
						adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));					
					default:
				};			
			default:
		};
		switch (r2.def) {
			case EField(objR, fieldR):
				switch (objR.def) {
					case EVar(_):
						adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));					
					default:
				};			
			default:
		};	
	default:
}) {
																												var ` = cond.def;
																												if (enumIndex ` == 26) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 6) {
																														{
																															var l2 = `;
																															var r2 = `;
																															{
																																@:ast(switch (l2.def) {
	case EField(objL, fieldL):
		switch (objL.def) {
			case EVar(_):
				adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));			
			default:
		};	
	default:
}) {
																																	var ` = l2.def;
																																	if (enumIndex ` == 28) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		{
																																			var objL = `;
																																			var fieldL = `;
																																			{
																																				@:ast(switch (objL.def) {
	case EVar(_):
		adjusted = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldL)), r2));	
	default:
}) {
																																					var ` = objL.def;
																																					if (enumIndex ` == 38) {
																																						var ` = `[0];
																																						{
																																							adjusted = {
																																								var pos = null;
																																								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, {
																																									var pos = null;
																																									{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																																										var pos = null;
																																										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderName), metadata : {}, pos : pos};
																																									}, fieldL), metadata : {}, pos : pos};
																																								}, r2), metadata : {}, pos : pos};
																																							};
																																						};
																																					} else {};
																																				};
																																			};
																																		};
																																	} else {};
																																};
																																@:ast(switch (r2.def) {
	case EField(objR, fieldR):
		switch (objR.def) {
			case EVar(_):
				adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));			
			default:
		};	
	default:
}) {
																																	var ` = r2.def;
																																	if (enumIndex ` == 28) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		{
																																			var objR = `;
																																			var fieldR = `;
																																			{
																																				@:ast(switch (objR.def) {
	case EVar(_):
		adjusted = makeAST(EBinary(Equal, l2, makeAST(EField(makeAST(EVar(binderName)), fieldR))));	
	default:
}) {
																																					var ` = objR.def;
																																					if (enumIndex ` == 38) {
																																						var ` = `[0];
																																						{
																																							adjusted = {
																																								var pos = null;
																																								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, l2, {
																																									var pos = null;
																																									{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																																										var pos = null;
																																										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderName), metadata : {}, pos : pos};
																																									}, fieldR), metadata : {}, pos : pos};
																																								}), metadata : {}, pos : pos};
																																							};
																																						};
																																					} else {};
																																				};
																																			};
																																		};
																																	} else {};
																																};
																															};
																														};
																													} else {};
																												} else {};
																											};
																										};
																										predicate = adjusted;
																									};
																								};
																							};
																						};
																						case 26: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							if (enumIndex ` == 27) {
																								{
																									var leftAlias = `;
																									var rightAlias = `;
																									{
																										@:ast(switch (leftAlias.def) {
	case EVar(an):
		if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;	
	default:
}) {
																											var ` = leftAlias.def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var an = `;
																													{
																														if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAlias, listExpr)) {
																															aliasFromHead = an;
																														};
																													};
																												};
																											} else {};
																										};
																									};
																								};
																							} else {};
																						};
																						default: {}
																					};
																				};
																			};
																		};
																	} else {};
																};
															} else {};
														};
													};
												};
											} else {};
										};
									};
								};
							};
							if (predicate == null || listExpr == null) {
								return node;
							};
							var lastExpr = stmts[stmts.length - 1];
							var returnsCount = @:ast(switch (lastExpr.def) {
	case EVar(n) if (n == countVar):
		true;	
	default:
		false;	
}) {
								var ` = lastExpr.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var n = `;
										if (n == countVar) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
							if (! returnsCount) {
								return node;
							};
							var adjustedBinder2 = if ((binderName != null && binderName.length > 0 && binderName.charAt(0) == "_")) {
								binderName.substr(1, null);
							} else {
								binderName;
							};
							predicate = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(predicate, binderName, adjustedBinder2);
							predicate = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(predicate, "_" + adjustedBinder2, adjustedBinder2);
							var fnNode = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(adjustedBinder2)], guard : null, body : predicate}]), metadata : {}, pos : pos};
							};
							var newCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "count", [listExpr, fnNode]), metadata : {}, pos : pos};
							};
							{def : newCall.def, metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function isCountIncrement(n:reflaxe.elixir.ast.ElixirAST, countVar:String) {
		return @:ast(switch (n.def) {
	case EBinary(Match, left1, rhs):
		var lhsName:Null<String> = switch (left1.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		if (lhsName != countVar) return false;
		switch (rhs.def) {
			case EBinary(Add, l, r):
				switch (l.def) {
					case EVar(n2) if (n2 == countVar):
						switch (r.def) {
							case EInteger(v) if (v == 1):
								true;							
							default:
								false;							
						};					
					default:
						false;					
				};			
			default:
				false;			
		};	
	case EMatch(pat, expr):
		var lhsName2:Null<String> = switch (pat) {
			case PVar(nm2):
				nm2;			
			default:
				null;			
		};
		if (lhsName2 != countVar) return false;
		switch (expr.def) {
			case EBinary(Add, l2, r2):
				switch (l2.def) {
					case EVar(n3) if (n3 == countVar):
						switch (r2.def) {
							case EInteger(v2) if (v2 == 1):
								true;							
							default:
								false;							
						};					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = n.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pat = `;
						var expr = `;
						{
							var lhsName2 = @:ast(switch (pat) {
	case PVar(nm2):
		nm2;	
	default:
		null;	
}) if (enumIndex pat == 0) {
								var ` = pat[0];
								{
									var nm2 = `;
									{
										nm2;
									};
								};
							} else {
								null;
							};
							if (lhsName2 != countVar) {
								return false;
							};
							@:ast(switch (expr.def) {
	case EBinary(Add, l2, r2):
		switch (l2.def) {
			case EVar(n3) if (n3 == countVar):
				switch (r2.def) {
					case EInteger(v2) if (v2 == 1):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
								var ` = expr.def;
								if (enumIndex ` == 26) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (enumIndex ` == 0) {
										{
											var l2 = `;
											var r2 = `;
											{
												@:ast(switch (l2.def) {
	case EVar(n3) if (n3 == countVar):
		switch (r2.def) {
			case EInteger(v2) if (v2 == 1):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
													var ` = l2.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var n3 = `;
															if (n3 == countVar) {
																@:ast(switch (r2.def) {
	case EInteger(v2) if (v2 == 1):
		true;	
	default:
		false;	
}) {
																	var ` = r2.def;
																	if (enumIndex ` == 33) {
																		var ` = `[0];
																		{
																			var v2 = `;
																			if (v2 == 1) {
																				true;
																			} else {
																				false;
																			};
																		};
																	} else {
																		false;
																	};
																};
															} else {
																false;
															};
														};
													} else {
														false;
													};
												};
											};
										};
									} else {
										false;
									};
								} else {
									false;
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var left1 = `;
							var rhs = `;
							{
								var lhsName = @:ast(switch (left1.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
									var ` = left1.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var nm = `;
											{
												nm;
											};
										};
									} else {
										null;
									};
								};
								if (lhsName != countVar) {
									return false;
								};
								@:ast(switch (rhs.def) {
	case EBinary(Add, l, r):
		switch (l.def) {
			case EVar(n2) if (n2 == countVar):
				switch (r.def) {
					case EInteger(v) if (v == 1):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
									var ` = rhs.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 0) {
											{
												var l = `;
												var r = `;
												{
													@:ast(switch (l.def) {
	case EVar(n2) if (n2 == countVar):
		switch (r.def) {
			case EInteger(v) if (v == 1):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
														var ` = l.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var n2 = `;
																if (n2 == countVar) {
																	@:ast(switch (r.def) {
	case EInteger(v) if (v == 1):
		true;	
	default:
		false;	
}) {
																		var ` = r.def;
																		if (enumIndex ` == 33) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (v == 1) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	};
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													};
												};
											};
										} else {
											false;
										};
									} else {
										false;
									};
								};
							};
						};
					} else {
						false;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	public static function mapJoinRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts) if (stmts.length >= 3):
		var tempVar:Null<String> = null;
		var initIdx = -1;
		var listExpr:Null<ElixirAST> = null;
		var binderName:String = "_elem";
		var mapExpr:Null<ElixirAST> = null;
		var aliasLocal:Null<String> = null;
		var sep:Null<ElixirAST> = null;
		for (idx  in  0 ... stmts.length) switch (stmts[idx].def) {
			case EBinary(Match, leftInit, rhs):
				switch (leftInit.def) {
					case EVar(name):
						switch (rhs.def) {
							case EList(_):
								tempVar = name;
								initIdx = idx;							
							default:
						};					
					default:
				};			
			case EMatch(patInit, rhsInit):
				switch (patInit) {
					case PVar(name2):
						switch (rhsInit.def) {
							case EList(_):
								tempVar = name2;
								initIdx = idx;							
							default:
						};					
					default:
				};			
			default:
		};
		if (tempVar == null || initIdx == -1) return node;
		for (i  in  (initIdx + 1) ... stmts.length) {
			var eachStmt:Null<ElixirAST> = null;
			switch (stmts[i].def) {
				case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
					eachStmt = stmts[i];				
				case EMatch(_, rhs):
					switch (rhs.def) {
						case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
							eachStmt = rhs;						
						default:
					};				
				case EBinary(Match, _, rhs2):
					switch (rhs2.def) {
						case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
							eachStmt = rhs2;						
						default:
					};				
				default:
			};
			if (eachStmt != null) {
				switch (eachStmt.def) {
					case ERemoteCall(mod, func, args):
						listExpr = args[0];
						switch (args[1].def) {
							case EFn(clauses) if (clauses.length == 1):
								var cl = clauses[0];
								switch (cl.args.length > 0 ? cl.args[0] : null) {
									case PVar(n):
										binderName = n;									
									default:
								};
								var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
									case EBlock(ss):
										ss;									
									default:
										[cl.body];									
								};
								for (bs  in  bodyStmts) switch (bs.def) {
									case EBinary(Match, leftAlias, rightAlias):
										switch (leftAlias.def) {
											case EVar(an):
												if (isHeadAccessOf(rightAlias, listExpr)) aliasLocal = an;											
											default:
										};									
									case EMatch(patAlias, rightAlias2):
										switch (patAlias) {
											case PVar(an2):
												if (isHeadAccessOf(rightAlias2, listExpr)) aliasLocal = an2;											
											default:
										};									
									case EBinary(Match, leftX, rhs):
										var lhsTemp:Null<String> = switch (leftX.def) {
											case EVar(nx):
												nx;											
											default:
												null;											
										};
										if (lhsTemp != tempVar) { } else {
											switch (rhs.def) {
												case ERemoteCall(mod2, "concat", concatArgs) if (concatArgs.length == 2):
													switch (mod2.def) {
														case EVar(mn) if (mn == "Enum"):
															var isSelf = switch (concatArgs[0].def) {
																case EVar(n2) if (n2 == tempVar):
																	true;																
																default:
																	false;																
															};
															var exprInside:Null<ElixirAST> = null;
															switch (concatArgs[1].def) {
																case EList(items) if (items.length == 1):
																	exprInside = items[0];																
																default:
															};
															if (isSelf && exprInside != null) {
																mapExpr = exprInside;
																if (aliasLocal != null) mapExpr = replaceVarInExpr(mapExpr, aliasLocal, binderName);
															};														
														default:
													};												
												case EMatch(patX, rhsP):
													var lhsTemp2:Null<String> = switch (patX) {
														case PVar(nx2):
															nx2;														
														default:
															null;														
													};
													if (lhsTemp2 == tempVar) {
														switch (rhsP.def) {
															case ERemoteCall(mod2b, "concat", concatArgs2) if (concatArgs2.length == 2):
																switch (mod2b.def) {
																	case EVar(mnb) if (mnb == "Enum"):
																		var isSelf2 = switch (concatArgs2[0].def) {
																			case EVar(n2b) if (n2b == tempVar):
																				true;																			
																			default:
																				false;																			
																		};
																		var exprInside2:Null<ElixirAST> = null;
																		switch (concatArgs2[1].def) {
																			case EList(items2) if (items2.length == 1):
																				exprInside2 = items2[0];																			
																			default:
																		};
																		if (isSelf2 && exprInside2 != null) mapExpr = exprInside2;																	
																	default:
																};															
															default:
														};
													};												
												default:
											};
										};									
									default:
								};							
							default:
						};					
					default:
				};
			};
		};
		if (listExpr == null || mapExpr == null) return node;
		var finalExpr = stmts[stmts.length - 1];
		switch (finalExpr.def) {
			case ERemoteCall(mod3, "join", jArgs) if (jArgs.length == 2):
				switch (mod3.def) {
					case EVar(mn3) if (mn3 == "Enum"):
						switch (jArgs[0].def) {
							case EVar(n3) if (n3 == tempVar):
								sep = jArgs[1];							
							default:
						};					
					default:
				};			
			default:
		};
		if (sep == null) return node;
		var adjustedBinder3 = safeBinder(binderName);
		mapExpr = replaceVarInExpr(mapExpr, binderName, adjustedBinder3);
		mapExpr = replaceVarInExpr(mapExpr, "_" + adjustedBinder3, adjustedBinder3);
		var fnNode = makeAST(EFn([{ args : [PVar(adjustedBinder3)], guard : null, body : mapExpr }]));
		var mapCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "map", [listExpr, fnNode]));
		var joinCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "join", [mapCall, sep]));
		makeASTWithMeta(joinCall.def, node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length >= 3) {
							var tempVar = null;
							var initIdx = -1;
							var listExpr = null;
							var binderName = "_elem";
							var mapExpr = null;
							var aliasLocal = null;
							var sep = null;
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var idx = ` ++;
									@:ast(switch (stmts[idx].def) {
	case EBinary(Match, leftInit, rhs):
		switch (leftInit.def) {
			case EVar(name):
				switch (rhs.def) {
					case EList(_):
						tempVar = name;
						initIdx = idx;					
					default:
				};			
			default:
		};	
	case EMatch(patInit, rhsInit):
		switch (patInit) {
			case PVar(name2):
				switch (rhsInit.def) {
					case EList(_):
						tempVar = name2;
						initIdx = idx;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[idx].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var patInit = `;
													var rhsInit = `;
													{
														@:ast(switch (patInit) {
	case PVar(name2):
		switch (rhsInit.def) {
			case EList(_):
				tempVar = name2;
				initIdx = idx;			
			default:
		};	
	default:
}) if (enumIndex patInit == 0) {
															var ` = patInit[0];
															{
																var name2 = `;
																{
																	@:ast(switch (rhsInit.def) {
	case EList(_):
		tempVar = name2;
		initIdx = idx;	
	default:
}) {
																		var ` = rhsInit.def;
																		if (enumIndex ` == 15) {
																			var ` = `[0];
																			{
																				tempVar = name2;
																				initIdx = idx;
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var leftInit = `;
														var rhs = `;
														{
															@:ast(switch (leftInit.def) {
	case EVar(name):
		switch (rhs.def) {
			case EList(_):
				tempVar = name;
				initIdx = idx;			
			default:
		};	
	default:
}) {
																var ` = leftInit.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var name = `;
																		{
																			@:ast(switch (rhs.def) {
	case EList(_):
		tempVar = name;
		initIdx = idx;	
	default:
}) {
																				var ` = rhs.def;
																				if (enumIndex ` == 15) {
																					var ` = `[0];
																					{
																						tempVar = name;
																						initIdx = idx;
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
								};
							};
							if (tempVar == null || initIdx == -1) {
								return node;
							};
							{
								var ` = (initIdx + 1);
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									var eachStmt = null;
									@:ast(switch (stmts[i].def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		eachStmt = stmts[i];	
	case EMatch(_, rhs):
		switch (rhs.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
				eachStmt = rhs;			
			default:
		};	
	case EBinary(Match, _, rhs2):
		switch (rhs2.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
				eachStmt = rhs2;			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var rhs = `;
													{
														@:ast(switch (rhs.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		eachStmt = rhs;	
	default:
}) {
															var ` = rhs.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod = `;
																	var func = `;
																	var args = `;
																	if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																		var ` = mod.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	}) {
																		eachStmt = rhs;
																	} else {};
																};
															} else {};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
														var ` = mod.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var name = `;
																if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																	true;
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													}) {
														eachStmt = stmts[i];
													} else {};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var rhs2 = `;
														{
															@:ast(switch (rhs2.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		eachStmt = rhs2;	
	default:
}) {
																var ` = rhs2.def;
																if (enumIndex ` == 24) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var func = `;
																		var args = `;
																		if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																			var ` = mod.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var name = `;
																					if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		}) {
																			eachStmt = rhs2;
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									if (eachStmt != null) {
										@:ast(switch (eachStmt.def) {
	case ERemoteCall(mod, func, args):
		listExpr = args[0];
		switch (args[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				switch (cl.args.length > 0 ? cl.args[0] : null) {
					case PVar(n):
						binderName = n;					
					default:
				};
				var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
					case EBlock(ss):
						ss;					
					default:
						[cl.body];					
				};
				for (bs  in  bodyStmts) switch (bs.def) {
					case EBinary(Match, leftAlias, rightAlias):
						switch (leftAlias.def) {
							case EVar(an):
								if (isHeadAccessOf(rightAlias, listExpr)) aliasLocal = an;							
							default:
						};					
					case EMatch(patAlias, rightAlias2):
						switch (patAlias) {
							case PVar(an2):
								if (isHeadAccessOf(rightAlias2, listExpr)) aliasLocal = an2;							
							default:
						};					
					case EBinary(Match, leftX, rhs):
						var lhsTemp:Null<String> = switch (leftX.def) {
							case EVar(nx):
								nx;							
							default:
								null;							
						};
						if (lhsTemp != tempVar) { } else {
							switch (rhs.def) {
								case ERemoteCall(mod2, "concat", concatArgs) if (concatArgs.length == 2):
									switch (mod2.def) {
										case EVar(mn) if (mn == "Enum"):
											var isSelf = switch (concatArgs[0].def) {
												case EVar(n2) if (n2 == tempVar):
													true;												
												default:
													false;												
											};
											var exprInside:Null<ElixirAST> = null;
											switch (concatArgs[1].def) {
												case EList(items) if (items.length == 1):
													exprInside = items[0];												
												default:
											};
											if (isSelf && exprInside != null) {
												mapExpr = exprInside;
												if (aliasLocal != null) mapExpr = replaceVarInExpr(mapExpr, aliasLocal, binderName);
											};										
										default:
									};								
								case EMatch(patX, rhsP):
									var lhsTemp2:Null<String> = switch (patX) {
										case PVar(nx2):
											nx2;										
										default:
											null;										
									};
									if (lhsTemp2 == tempVar) {
										switch (rhsP.def) {
											case ERemoteCall(mod2b, "concat", concatArgs2) if (concatArgs2.length == 2):
												switch (mod2b.def) {
													case EVar(mnb) if (mnb == "Enum"):
														var isSelf2 = switch (concatArgs2[0].def) {
															case EVar(n2b) if (n2b == tempVar):
																true;															
															default:
																false;															
														};
														var exprInside2:Null<ElixirAST> = null;
														switch (concatArgs2[1].def) {
															case EList(items2) if (items2.length == 1):
																exprInside2 = items2[0];															
															default:
														};
														if (isSelf2 && exprInside2 != null) mapExpr = exprInside2;													
													default:
												};											
											default:
										};
									};								
								default:
							};
						};					
					default:
				};			
			default:
		};	
	default:
}) {
											var ` = eachStmt.def;
											if (enumIndex ` == 24) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													{
														listExpr = args[0];
														@:ast(switch (args[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				binderName = n;			
			default:
		};
		var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[cl.body];			
		};
		for (bs  in  bodyStmts) switch (bs.def) {
			case EBinary(Match, leftAlias, rightAlias):
				switch (leftAlias.def) {
					case EVar(an):
						if (isHeadAccessOf(rightAlias, listExpr)) aliasLocal = an;					
					default:
				};			
			case EMatch(patAlias, rightAlias2):
				switch (patAlias) {
					case PVar(an2):
						if (isHeadAccessOf(rightAlias2, listExpr)) aliasLocal = an2;					
					default:
				};			
			case EBinary(Match, leftX, rhs):
				var lhsTemp:Null<String> = switch (leftX.def) {
					case EVar(nx):
						nx;					
					default:
						null;					
				};
				if (lhsTemp != tempVar) { } else {
					switch (rhs.def) {
						case ERemoteCall(mod2, "concat", concatArgs) if (concatArgs.length == 2):
							switch (mod2.def) {
								case EVar(mn) if (mn == "Enum"):
									var isSelf = switch (concatArgs[0].def) {
										case EVar(n2) if (n2 == tempVar):
											true;										
										default:
											false;										
									};
									var exprInside:Null<ElixirAST> = null;
									switch (concatArgs[1].def) {
										case EList(items) if (items.length == 1):
											exprInside = items[0];										
										default:
									};
									if (isSelf && exprInside != null) {
										mapExpr = exprInside;
										if (aliasLocal != null) mapExpr = replaceVarInExpr(mapExpr, aliasLocal, binderName);
									};								
								default:
							};						
						case EMatch(patX, rhsP):
							var lhsTemp2:Null<String> = switch (patX) {
								case PVar(nx2):
									nx2;								
								default:
									null;								
							};
							if (lhsTemp2 == tempVar) {
								switch (rhsP.def) {
									case ERemoteCall(mod2b, "concat", concatArgs2) if (concatArgs2.length == 2):
										switch (mod2b.def) {
											case EVar(mnb) if (mnb == "Enum"):
												var isSelf2 = switch (concatArgs2[0].def) {
													case EVar(n2b) if (n2b == tempVar):
														true;													
													default:
														false;													
												};
												var exprInside2:Null<ElixirAST> = null;
												switch (concatArgs2[1].def) {
													case EList(items2) if (items2.length == 1):
														exprInside2 = items2[0];													
													default:
												};
												if (isSelf2 && exprInside2 != null) mapExpr = exprInside2;											
											default:
										};									
									default:
								};
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
															var ` = args[1].def;
															if (enumIndex ` == 42) {
																var ` = `[0];
																{
																	var clauses = `;
																	if (clauses.length == 1) {
																		var cl = clauses[0];
																		@:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		binderName = n;	
	default:
}) {
																			var ` = if (cl.args.length > 0) {
																				cl.args[0];
																			} else {
																				null;
																			};
																			if (` == null) {} else if (enumIndex ` == 0) {
																				var ` = `[0];
																				{
																					var n = `;
																					{
																						binderName = n;
																					};
																				};
																			} else {};
																		};
																		var bodyStmts = @:ast(switch (cl.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[cl.body];	
}) {
																			var ` = cl.body.def;
																			if (enumIndex ` == 53) {
																				var ` = `[0];
																				{
																					var ss = `;
																					{
																						ss;
																					};
																				};
																			} else {
																				[cl.body];
																			};
																		};
																		{
																			var ` = 0;
																			while (` < bodyStmts.length) {
																				var bs = bodyStmts[`];
																				++ `;
																				@:ast(switch (bs.def) {
	case EBinary(Match, leftAlias, rightAlias):
		switch (leftAlias.def) {
			case EVar(an):
				if (isHeadAccessOf(rightAlias, listExpr)) aliasLocal = an;			
			default:
		};	
	case EMatch(patAlias, rightAlias2):
		switch (patAlias) {
			case PVar(an2):
				if (isHeadAccessOf(rightAlias2, listExpr)) aliasLocal = an2;			
			default:
		};	
	case EBinary(Match, leftX, rhs):
		var lhsTemp:Null<String> = switch (leftX.def) {
			case EVar(nx):
				nx;			
			default:
				null;			
		};
		if (lhsTemp != tempVar) { } else {
			switch (rhs.def) {
				case ERemoteCall(mod2, "concat", concatArgs) if (concatArgs.length == 2):
					switch (mod2.def) {
						case EVar(mn) if (mn == "Enum"):
							var isSelf = switch (concatArgs[0].def) {
								case EVar(n2) if (n2 == tempVar):
									true;								
								default:
									false;								
							};
							var exprInside:Null<ElixirAST> = null;
							switch (concatArgs[1].def) {
								case EList(items) if (items.length == 1):
									exprInside = items[0];								
								default:
							};
							if (isSelf && exprInside != null) {
								mapExpr = exprInside;
								if (aliasLocal != null) mapExpr = replaceVarInExpr(mapExpr, aliasLocal, binderName);
							};						
						default:
					};				
				case EMatch(patX, rhsP):
					var lhsTemp2:Null<String> = switch (patX) {
						case PVar(nx2):
							nx2;						
						default:
							null;						
					};
					if (lhsTemp2 == tempVar) {
						switch (rhsP.def) {
							case ERemoteCall(mod2b, "concat", concatArgs2) if (concatArgs2.length == 2):
								switch (mod2b.def) {
									case EVar(mnb) if (mnb == "Enum"):
										var isSelf2 = switch (concatArgs2[0].def) {
											case EVar(n2b) if (n2b == tempVar):
												true;											
											default:
												false;											
										};
										var exprInside2:Null<ElixirAST> = null;
										switch (concatArgs2[1].def) {
											case EList(items2) if (items2.length == 1):
												exprInside2 = items2[0];											
											default:
										};
										if (isSelf2 && exprInside2 != null) mapExpr = exprInside2;									
									default:
								};							
							default:
						};
					};				
				default:
			};
		};	
	default:
}) {
																					var ` = bs.def;
																					switch (enumIndex `) {
																						case 8: {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var patAlias = `;
																								var rightAlias2 = `;
																								{
																									@:ast(switch (patAlias) {
	case PVar(an2):
		if (isHeadAccessOf(rightAlias2, listExpr)) aliasLocal = an2;	
	default:
}) if (enumIndex patAlias == 0) {
																										var ` = patAlias[0];
																										{
																											var an2 = `;
																											{
																												if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAlias2, listExpr)) {
																													aliasLocal = an2;
																												};
																											};
																										};
																									} else {};
																								};
																							};
																						};
																						case 26: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							if (enumIndex ` == 27) {
																								{
																									var leftAlias = `;
																									var rightAlias = `;
																									{
																										@:ast(switch (leftAlias.def) {
	case EVar(an):
		if (isHeadAccessOf(rightAlias, listExpr)) aliasLocal = an;	
	default:
}) {
																											var ` = leftAlias.def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var an = `;
																													{
																														if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAlias, listExpr)) {
																															aliasLocal = an;
																														};
																													};
																												};
																											} else {};
																										};
																									};
																								};
																							} else {};
																						};
																						default: {}
																					};
																				};
																			};
																		};
																	} else {};
																};
															} else {};
														};
													};
												};
											} else {};
										};
									};
								};
							};
							if (listExpr == null || mapExpr == null) {
								return node;
							};
							var finalExpr = stmts[stmts.length - 1];
							@:ast(switch (finalExpr.def) {
	case ERemoteCall(mod3, "join", jArgs) if (jArgs.length == 2):
		switch (mod3.def) {
			case EVar(mn3) if (mn3 == "Enum"):
				switch (jArgs[0].def) {
					case EVar(n3) if (n3 == tempVar):
						sep = jArgs[1];					
					default:
				};			
			default:
		};	
	default:
}) {
								var ` = finalExpr.def;
								if (enumIndex ` == 24) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									if (` == "join") {
										{
											var mod3 = `;
											var jArgs = `;
											if (jArgs.length == 2) {
												@:ast(switch (mod3.def) {
	case EVar(mn3) if (mn3 == "Enum"):
		switch (jArgs[0].def) {
			case EVar(n3) if (n3 == tempVar):
				sep = jArgs[1];			
			default:
		};	
	default:
}) {
													var ` = mod3.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var mn3 = `;
															if (mn3 == "Enum") {
																@:ast(switch (jArgs[0].def) {
	case EVar(n3) if (n3 == tempVar):
		sep = jArgs[1];	
	default:
}) {
																	var ` = jArgs[0].def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var n3 = `;
																			if (n3 == tempVar) {
																				sep = jArgs[1];
																			} else {};
																		};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
											} else {};
										};
									} else {};
								} else {};
							};
							if (sep == null) {
								return node;
							};
							var adjustedBinder3 = if ((binderName != null && binderName.length > 0 && binderName.charAt(0) == "_")) {
								binderName.substr(1, null);
							} else {
								binderName;
							};
							mapExpr = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(mapExpr, binderName, adjustedBinder3);
							mapExpr = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(mapExpr, "_" + adjustedBinder3, adjustedBinder3);
							var fnNode = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(adjustedBinder3)], guard : null, body : mapExpr}]), metadata : {}, pos : pos};
							};
							var mapCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "map", [listExpr, fnNode]), metadata : {}, pos : pos};
							};
							var joinCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "join", [mapCall, sep]), metadata : {}, pos : pos};
							};
							{def : joinCall.def, metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function mapConcatEachToMapAssignPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts) if (stmts.length >= 2):
		var temp:Null<String> = null;
		var initIdx = -1;
		for (i  in  0 ... stmts.length) switch (stmts[i].def) {
			case EBinary(Match, left, rhs):
				switch (left.def) {
					case EVar(n):
						switch (rhs.def) {
							case EList(_):
								temp = n;
								initIdx = i;							
							default:
						};					
					default:
				};			
			case EMatch(pat, rhs2):
				switch (pat) {
					case PVar(n2):
						switch (rhs2.def) {
							case EList(_):
								temp = n2;
								initIdx = i;							
							default:
						};					
					default:
				};			
			default:
		};
		if (temp == null) return node;
		var listExpr:Null<ElixirAST> = null;
		var binderName:String = "_elem";
		var exprInside:Null<ElixirAST> = null;
		var eachIdx = -1;
		for (i  in  initIdx + 1 ... stmts.length) switch (stmts[i].def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
				listExpr = args[0];
				eachIdx = i;
				switch (args[1].def) {
					case EFn(clauses) if (clauses.length == 1):
						var cl = clauses[0];
						switch (cl.args.length > 0 ? cl.args[0] : null) {
							case PVar(n):
								binderName = n;							
							default:
						};
						var bodyStmts = switch (cl.body.def) {
							case EBlock(ss):
								ss;							
							default:
								[cl.body];							
						};
						for (bs  in  bodyStmts) switch (bs.def) {
							case EBinary(Match, leftX, rhsX):
								var lhsName:Null<String> = switch (leftX.def) {
									case EVar(nm):
										nm;									
									default:
										null;									
								};
								if (lhsName == temp) switch (rhsX.def) {
									case ERemoteCall({ def : EVar(mn) }, "concat", cargs) if (mn == "Enum" && cargs.length == 2):
										switch (cargs[0].def) {
											case EVar(nv) if (nv == temp):
												switch (cargs[1].def) {
													case EList(items) if (items.length == 1):
														exprInside = items[0];													
													default:
												};											
											default:
										};									
									default:
								};							
							default:
						};					
					default:
				};			
			default:
		};
		if (listExpr == null || exprInside == null || eachIdx == -1) return node;
		var adjusted = safeBinder(binderName);
		exprInside = replaceVarInExpr(exprInside, binderName, adjusted);
		exprInside = replaceVarInExpr(exprInside, "_" + adjusted, adjusted);
		var fn = makeAST(EFn([{ args : [PVar(adjusted)], guard : null, body : exprInside }]));
		var mapCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "map", [listExpr, fn]));
		var newStmts:Array<ElixirAST> = [];
		for (i  in  0 ... stmts.length) {
			if (i == initIdx) {
				newStmts.push(makeAST(EBinary(Match, makeAST(EVar(temp)), mapCall)));
			} else if (i == eachIdx) { } else newStmts.push(stmts[i]);
		};
		makeASTWithMeta(EBlock(newStmts), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length >= 2) {
							var temp = null;
							var initIdx = -1;
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(n):
				switch (rhs.def) {
					case EList(_):
						temp = n;
						initIdx = i;					
					default:
				};			
			default:
		};	
	case EMatch(pat, rhs2):
		switch (pat) {
			case PVar(n2):
				switch (rhs2.def) {
					case EList(_):
						temp = n2;
						initIdx = i;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var pat = `;
													var rhs2 = `;
													{
														@:ast(switch (pat) {
	case PVar(n2):
		switch (rhs2.def) {
			case EList(_):
				temp = n2;
				initIdx = i;			
			default:
		};	
	default:
}) if (enumIndex pat == 0) {
															var ` = pat[0];
															{
																var n2 = `;
																{
																	@:ast(switch (rhs2.def) {
	case EList(_):
		temp = n2;
		initIdx = i;	
	default:
}) {
																		var ` = rhs2.def;
																		if (enumIndex ` == 15) {
																			var ` = `[0];
																			{
																				temp = n2;
																				initIdx = i;
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var rhs = `;
														{
															@:ast(switch (left.def) {
	case EVar(n):
		switch (rhs.def) {
			case EList(_):
				temp = n;
				initIdx = i;			
			default:
		};	
	default:
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var n = `;
																		{
																			@:ast(switch (rhs.def) {
	case EList(_):
		temp = n;
		initIdx = i;	
	default:
}) {
																				var ` = rhs.def;
																				if (enumIndex ` == 15) {
																					var ` = `[0];
																					{
																						temp = n;
																						initIdx = i;
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
								};
							};
							if (temp == null) {
								return node;
							};
							var listExpr = null;
							var binderName = "_elem";
							var exprInside = null;
							var eachIdx = -1;
							{
								var ` = initIdx + 1;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args)):
		listExpr = args[0];
		eachIdx = i;
		switch (args[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				switch (cl.args.length > 0 ? cl.args[0] : null) {
					case PVar(n):
						binderName = n;					
					default:
				};
				var bodyStmts = switch (cl.body.def) {
					case EBlock(ss):
						ss;					
					default:
						[cl.body];					
				};
				for (bs  in  bodyStmts) switch (bs.def) {
					case EBinary(Match, leftX, rhsX):
						var lhsName:Null<String> = switch (leftX.def) {
							case EVar(nm):
								nm;							
							default:
								null;							
						};
						if (lhsName == temp) switch (rhsX.def) {
							case ERemoteCall({ def : EVar(mn) }, "concat", cargs) if (mn == "Enum" && cargs.length == 2):
								switch (cargs[0].def) {
									case EVar(nv) if (nv == temp):
										switch (cargs[1].def) {
											case EList(items) if (items.length == 1):
												exprInside = items[0];											
											default:
										};									
									default:
								};							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										if (enumIndex ` == 24) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var mod = `;
												var func = `;
												var args = `;
												if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
													var ` = mod.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var name = `;
															if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																true;
															} else {
																false;
															};
														};
													} else {
														false;
													};
												}) {
													listExpr = args[0];
													eachIdx = i;
													@:ast(switch (args[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				binderName = n;			
			default:
		};
		var bodyStmts = switch (cl.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[cl.body];			
		};
		for (bs  in  bodyStmts) switch (bs.def) {
			case EBinary(Match, leftX, rhsX):
				var lhsName:Null<String> = switch (leftX.def) {
					case EVar(nm):
						nm;					
					default:
						null;					
				};
				if (lhsName == temp) switch (rhsX.def) {
					case ERemoteCall({ def : EVar(mn) }, "concat", cargs) if (mn == "Enum" && cargs.length == 2):
						switch (cargs[0].def) {
							case EVar(nv) if (nv == temp):
								switch (cargs[1].def) {
									case EList(items) if (items.length == 1):
										exprInside = items[0];									
									default:
								};							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
														var ` = args[1].def;
														if (enumIndex ` == 42) {
															var ` = `[0];
															{
																var clauses = `;
																if (clauses.length == 1) {
																	var cl = clauses[0];
																	@:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		binderName = n;	
	default:
}) {
																		var ` = if (cl.args.length > 0) {
																			cl.args[0];
																		} else {
																			null;
																		};
																		if (` == null) {} else if (enumIndex ` == 0) {
																			var ` = `[0];
																			{
																				var n = `;
																				{
																					binderName = n;
																				};
																			};
																		} else {};
																	};
																	var bodyStmts = @:ast(switch (cl.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[cl.body];	
}) {
																		var ` = cl.body.def;
																		if (enumIndex ` == 53) {
																			var ` = `[0];
																			{
																				var ss = `;
																				{
																					ss;
																				};
																			};
																		} else {
																			[cl.body];
																		};
																	};
																	{
																		var ` = 0;
																		while (` < bodyStmts.length) {
																			var bs = bodyStmts[`];
																			++ `;
																			@:ast(switch (bs.def) {
	case EBinary(Match, leftX, rhsX):
		var lhsName:Null<String> = switch (leftX.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		if (lhsName == temp) switch (rhsX.def) {
			case ERemoteCall({ def : EVar(mn) }, "concat", cargs) if (mn == "Enum" && cargs.length == 2):
				switch (cargs[0].def) {
					case EVar(nv) if (nv == temp):
						switch (cargs[1].def) {
							case EList(items) if (items.length == 1):
								exprInside = items[0];							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
																				var ` = bs.def;
																				if (enumIndex ` == 26) {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					if (enumIndex ` == 27) {
																						{
																							var leftX = `;
																							var rhsX = `;
																							{
																								var lhsName = @:ast(switch (leftX.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
																									var ` = leftX.def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										{
																											var nm = `;
																											{
																												nm;
																											};
																										};
																									} else {
																										null;
																									};
																								};
																								if (lhsName == temp) {
																									@:ast(switch (rhsX.def) {
	case ERemoteCall({ def : EVar(mn) }, "concat", cargs) if (mn == "Enum" && cargs.length == 2):
		switch (cargs[0].def) {
			case EVar(nv) if (nv == temp):
				switch (cargs[1].def) {
					case EList(items) if (items.length == 1):
						exprInside = items[0];					
					default:
				};			
			default:
		};	
	default:
}) {
																										var ` = rhsX.def;
																										if (enumIndex ` == 24) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													if (` == "concat") {
																														{
																															var mn = `;
																															var cargs = `;
																															if (mn == "Enum" && cargs.length == 2) {
																																@:ast(switch (cargs[0].def) {
	case EVar(nv) if (nv == temp):
		switch (cargs[1].def) {
			case EList(items) if (items.length == 1):
				exprInside = items[0];			
			default:
		};	
	default:
}) {
																																	var ` = cargs[0].def;
																																	if (enumIndex ` == 38) {
																																		var ` = `[0];
																																		{
																																			var nv = `;
																																			if (nv == temp) {
																																				@:ast(switch (cargs[1].def) {
	case EList(items) if (items.length == 1):
		exprInside = items[0];	
	default:
}) {
																																					var ` = cargs[1].def;
																																					if (enumIndex ` == 15) {
																																						var ` = `[0];
																																						{
																																							var items = `;
																																							if (items.length == 1) {
																																								exprInside = items[0];
																																							} else {};
																																						};
																																					} else {};
																																				};
																																			} else {};
																																		};
																																	} else {};
																																};
																															} else {};
																														};
																													} else {};
																												} else {};
																											};
																										} else {};
																									};
																								};
																							};
																						};
																					} else {};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									};
								};
							};
							if (listExpr == null || exprInside == null || eachIdx == -1) {
								return node;
							};
							var adjusted = if ((binderName != null && binderName.length > 0 && binderName.charAt(0) == "_")) {
								binderName.substr(1, null);
							} else {
								binderName;
							};
							exprInside = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(exprInside, binderName, adjusted);
							exprInside = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(exprInside, "_" + adjusted, adjusted);
							var fn = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(adjusted)], guard : null, body : exprInside}]), metadata : {}, pos : pos};
							};
							var mapCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "map", [listExpr, fn]), metadata : {}, pos : pos};
							};
							var newStmts = [];
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									if (i == initIdx) {
										newStmts.push({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(temp), metadata : {}, pos : pos};
											}, mapCall), metadata : {}, pos : pos};
										});
									} else {
										if (i == eachIdx) {} else {
											newStmts.push(stmts[i]);
										};
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStmts), metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function concatEachToReducePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts) if (stmts.length >= 3):
		var temp:Null<String> = null;
		var initIdx = -1;
		for (i  in  0 ... stmts.length) switch (stmts[i].def) {
			case EBinary(Match, left, rhs):
				switch (left.def) {
					case EVar(n):
						switch (rhs.def) {
							case EList(items) if (items.length == 0):
								temp = n;
								initIdx = i;							
							default:
						};					
					default:
				};			
			case EMatch(pat, rhs2):
				switch (pat) {
					case PVar(n2):
						switch (rhs2.def) {
							case EList(items2) if (items2.length == 0):
								temp = n2;
								initIdx = i;							
							default:
						};					
					default:
				};			
			default:
		};
		if (temp == null) return node;
		var eachIdx = -1;
		var listExpr:Null<ElixirAST> = null;
		var clause:Null<{ var args : Array<EPattern>; var body : ElixirAST; var guard : Null<ElixirAST>}> = null;
		for (i  in  initIdx + 1 ... stmts.length) switch (stmts[i].def) {
			case ERemoteCall(mod, func, args) if (func == "each" && args.length == 2):
				switch (mod.def) {
					case EVar(m) if (m == "Enum"):
						listExpr = args[0];
						switch (args[1].def) {
							case EFn(clauses) if (clauses.length == 1):
								clause = clauses[0];
								eachIdx = i;							
							default:
						};					
					default:
				};			
			case EBinary(Match, _, rhs) | EMatch(_, rhs):
				switch (rhs.def) {
					case ERemoteCall(mod2, func2, args2) if (func2 == "each" && args2.length == 2):
						switch (mod2.def) {
							case EVar(m2) if (m2 == "Enum"):
								listExpr = args2[0];
								switch (args2[1].def) {
									case EFn(clauses) if (clauses.length == 1):
										clause = clauses[0];
										eachIdx = i;									
									default:
								};							
							default:
						};					
					default:
				};			
			default:
		};
		if (eachIdx == -1 || listExpr == null || clause == null) return node;
		var returnsTemp = switch (stmts[stmts.length - 1].def) {
			case EVar(vn) if (vn == temp):
				true;			
			default:
				false;			
		};
		if (!returnsTemp) return node;
		var binder:String = switch (clause.args.length > 0 ? clause.args[0] : null) {
			case PVar(n):
				n;			
			default:
				"elem";			
		};
		var bodyStmts:Array<ElixirAST> = switch (clause.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[clause.body];			
		};
		var localEntryAlias:Null<String> = null;
		var cleanedStmts:Array<ElixirAST> = [];
		var presenceShape = false;
		var presenceUsesMetas = false;
		for (bs  in  bodyStmts) {
			var drop = false;
			switch (bs.def) {
				case EBinary(Match, left, right):
					switch (right.def) {
						case EAccess(tgt, _):
							switch (tgt.def) {
								case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg]) if (ElixirASTPrinter.print(arg, 0) == ElixirASTPrinter.print(listExpr, 0)):
									drop = true;
									presenceShape = true;								
								default:
							};						
						default:
					};
					if (!drop) switch (left.def) {
						case EVar(aliasName):
							switch (right.def) {
								case ERemoteCall({ def : EVar("Map") }, "get", [m, _key]) if (ElixirASTPrinter.print(m, 0) == ElixirASTPrinter.print(listExpr, 0)):
									localEntryAlias = aliasName;
									drop = true;
									presenceShape = true;								
								default:
							};						
						default:
					};
					switch (right.def) {
						case EAccess(arrX, _):
							switch (arrX.def) {
								case EField(_, fieldX) if (fieldX == "metas"):
									presenceUsesMetas = true;								
								default:
							};						
						default:
					};				
				case EMatch(pat, right2):
					switch (right2.def) {
						case EAccess(tgt2, _):
							switch (tgt2.def) {
								case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg2]) if (ElixirASTPrinter.print(arg2, 0) == ElixirASTPrinter.print(listExpr, 0)):
									drop = true;
									presenceShape = true;								
								default:
							};						
						default:
					};
					if (!drop) switch (pat) {
						case PVar(aliasName2):
							switch (right2.def) {
								case ERemoteCall({ def : EVar("Map") }, "get", [m2, _key2]) if (ElixirASTPrinter.print(m2, 0) == ElixirASTPrinter.print(listExpr, 0)):
									localEntryAlias = aliasName2;
									drop = true;
									presenceShape = true;								
								default:
							};						
						default:
					};
					switch (right2.def) {
						case EAccess(arrY, _):
							switch (arrY.def) {
								case EField(_, fieldY) if (fieldY == "metas"):
									presenceUsesMetas = true;								
								default:
							};						
						default:
					};				
				default:
			};
			if (!drop) cleanedStmts.push(bs);
		};
		if (presenceShape && presenceUsesMetas) {
			var binderSafe = safeBinder(binder);
			var metaExpr = makeAST(EAccess(makeAST(EField(makeAST(EVar(binderSafe)), "metas")), makeAST(EInteger(0))));
			var cond:Null<ElixirAST> = null;
			function isTempAppendAssign(s:ElixirAST, name:String):Bool {
				return switch (s.def) {
					case EBinary(Match, left, rhs):
						switch (left.def) {
							case EVar(v) if (v == name):
								switch (rhs.def) {
									case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, _]):
										switch (a0.def) {
											case EVar(v0) if (v0 == name):
												true;											
											default:
												false;											
										};									
									case EBinary(Concat, llist, _):
										switch (llist.def) {
											case EVar(v1) if (v1 == name):
												true;											
											default:
												false;											
										};									
									default:
										false;									
								};							
							default:
								false;							
						};					
					default:
						false;					
				};
			};
			function presenceAppendsTemp(expr:ElixirAST, name:String):Bool {
				switch (expr?.def) {
					case EBlock(ss):
						for (s  in  ss) if (isTempAppendAssign(s, name)) return true;
						return false;					
					default:
						return isTempAppendAssign(expr, name);					
				};
			};
			function findCond(nodes:Array<ElixirAST>):Null<ElixirAST> {
				if (nodes == null) return null;
				for (n  in  nodes) {
					switch (n.def) {
						case EIf(c, t, e):
							if (presenceAppendsTemp(t, temp)) return c;
							var a = findCond(switch (t.def) {
								case EBlock(ss):
									ss;								
								default:
									[t];								
							});
							if (a != null) return a;
							var b = findCond(switch (e?.def) {
								case EBlock(ss2):
									ss2;								
								default:
									e != null ? [e] : [];								
							});
							if (b != null) return b;						
						default:
					};
				};
				return null;
			};
			cond = findCond(bodyStmts);
			if (localEntryAlias != null) cond = replaceVarInExpr(cond, localEntryAlias, binderSafe);
			cond = replaceVarInExpr(cond, "entry", binderSafe);
			var metaAlias:Null<String> = null;
			for (bs  in  bodyStmts) switch (bs.def) {
				case EBinary(Match, leftX, rightX):
					switch (leftX.def) {
						case EVar(mn):
							switch (rightX.def) {
								case EAccess(arrX, _):
									switch (arrX.def) {
										case EField(_, fieldX) if (fieldX == "metas"):
											metaAlias = mn;										
										default:
									};								
								default:
							};						
						default:
					};				
				default:
			};
			if (metaAlias != null) cond = replaceVarWithExpr(cond, metaAlias, metaExpr);
			var appendMeta = makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([metaExpr]))));
			var outerCond = makeAST(EBinary(Greater, makeAST(ERemoteCall(makeAST(EVar("Kernel")), "length", [makeAST(EField(makeAST(EVar(binderSafe)), "metas"))])), makeAST(EInteger(0))));
			var inner = (cond != null) ? makeAST(EIf(cond, appendMeta, makeAST(EVar("acc")))) : appendMeta;
			var reducer = makeAST(EFn([{ args : [PVar(binderSafe), PVar("acc")], guard : clause.guard, body : makeAST(EIf(outerCond, inner, makeAST(EVar("acc")))) }]));
			var reduceInput = makeAST(ERemoteCall(makeAST(EVar("Map")), "values", [listExpr]));
			var reduceCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "reduce", [reduceInput, makeAST(EList([])), reducer]));
			var out2:Array<ElixirAST> = [];
			for (i  in  0 ... stmts.length) {
				if (i == initIdx) out2.push(reduceCall) else if (i == eachIdx || i == stmts.length - 1) { } else out2.push(stmts[i]);
			};
			return makeASTWithMeta(EBlock(out2), node.metadata, node.pos);
		};
		var normalizedStmts:Array<ElixirAST> = [];
		for (cs  in  cleanedStmts) {
			var cs2 = cs;
			if (localEntryAlias != null) cs2 = replaceVarInExpr(cs2, localEntryAlias, binder);
			normalizedStmts.push(cs2);
		};
		function rewriteAccAssign(s:ElixirAST):Null<ElixirAST> {
			return switch (s.def) {
				case EBinary(Match, left, rhs):
					switch (left.def) {
						case EVar(lhs) if (lhs == temp):
							switch (rhs.def) {
								case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, a1]):
									switch (a0.def) {
										case EVar(v0) if (v0 == temp):
											switch (a1.def) {
												case EList(items) if (items.length == 1):
													makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));												
												default:
													null;												
											};										
										default:
											null;										
									};								
								case EBinary(Concat, llist, rlist):
									switch (llist.def) {
										case EVar(v1) if (v1 == temp):
											makeAST(EBinary(Concat, makeAST(EVar("acc")), rlist));										
										default:
											null;										
									};								
								default:
									null;								
							};						
						default:
							null;						
					};				
				default:
					null;				
			};
		};
		function transformBody(expr:ElixirAST):ElixirAST {
			if (expr == null) return makeAST(EVar("acc"));
			return switch (expr.def) {
				case EIf(cond, thenBr, elseBr):
					var directThenAppend = rewriteAccAssign(thenBr);
					var directElseAppend = (elseBr == null) ? null : rewriteAccAssign(elseBr);
					var thenX = (directThenAppend != null) ? directThenAppend : transformBody(thenBr);
					var elseX = (elseBr == null) ? makeAST(EVar("acc")) : ((directElseAppend != null) ? directElseAppend : transformBody(elseBr));
					var thenAppend = rewriteAccAssign(thenX);
					var elseAppend = rewriteAccAssign(elseX);
					if (thenAppend != null && elseAppend == null) {
						makeAST(EIf(cond, thenAppend, makeAST(EVar("acc"))));
					} else if (thenAppend != null && elseAppend != null) {
						makeAST(EIf(cond, thenAppend, elseAppend));
					} else {
						var keptElse = (elseBr == null) ? makeAST(EVar("acc")) : transformBody(elseBr);
						makeAST(EIf(cond, transformBody(thenBr), keptElse));
					};				
				case EBlock(ss):
					var out:Array<ElixirAST> = [];
					for (s  in  ss) {
						var r = transformBody(s);
						switch (r.def) {
							case EInteger(v) if (v == 0 || v == 1):
							case EFloat(f) if (f == 0.0):
							default:
								out.push(r);							
						};
					};
					makeAST(EBlock(out));				
				default:
					expr;				
			};
		};
		var bodyForTransform:ElixirAST = (normalizedStmts.length == 1) ? normalizedStmts[0] : makeAST(EBlock(normalizedStmts));
		var rewrittenBody = transformBody(bodyForTransform);
		var reducerBody = switch (rewrittenBody.def) {
			case EBlock(ss):
				var needTail = true;
				if (ss.length > 0) switch (ss[ss.length - 1].def) {
					case EVar(nm) if (nm == "acc"):
						needTail = false;					
					default:
				};
				makeAST(needTail ? EBlock(ss.concat([makeAST(EVar("acc"))])) : EBlock(ss));			
			default:
				var lastIsAcc = switch (rewrittenBody.def) {
					case EVar(nm2) if (nm2 == "acc"):
						true;					
					default:
						false;					
				};
				lastIsAcc ? rewrittenBody : makeAST(EBlock([rewrittenBody, makeAST(EVar("acc"))]));			
		};
		reducerBody = ElixirASTTransformer.transformNode(reducerBody, function(t:ElixirAST):ElixirAST {
			return switch (t.def) {
				case EBinary(Match, leftT, rhsT):
					switch (leftT.def) {
						case EVar(lhsT) if (lhsT == temp):
							var repl = rewriteAccAssign(t);
							if (repl != null) makeASTWithMeta(EBinary(Match, makeAST(EVar("acc")), repl), t.metadata, t.pos) else t;						
						default:
							t;						
					};				
				default:
					t;				
			};
		});
		if (localEntryAlias != null) reducerBody = replaceVarInExpr(reducerBody, localEntryAlias, binder);
		var reducer = makeAST(EFn([{ args : [PVar(safeBinder(binder)), PVar("acc")], guard : clause.guard, body : reducerBody }]));
		var reduceInput = (presenceShape && presenceUsesMetas) ? makeAST(ERemoteCall(makeAST(EVar("Map")), "values", [listExpr])) : listExpr;
		var reduceCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "reduce", [reduceInput, makeAST(EList([])), reducer]));
		var out:Array<ElixirAST> = [];
		for (i  in  0 ... stmts.length) {
			if (i == initIdx) {
				out.push(reduceCall);
			} else if (i == eachIdx || i == stmts.length - 1) { } else out.push(stmts[i]);
		};
		makeASTWithMeta(EBlock(out), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length >= 3) {
							var temp = [null];
							var initIdx = -1;
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(n):
				switch (rhs.def) {
					case EList(items) if (items.length == 0):
						temp = n;
						initIdx = i;					
					default:
				};			
			default:
		};	
	case EMatch(pat, rhs2):
		switch (pat) {
			case PVar(n2):
				switch (rhs2.def) {
					case EList(items2) if (items2.length == 0):
						temp = n2;
						initIdx = i;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var pat = `;
													var rhs2 = `;
													{
														@:ast(switch (pat) {
	case PVar(n2):
		switch (rhs2.def) {
			case EList(items2) if (items2.length == 0):
				temp = n2;
				initIdx = i;			
			default:
		};	
	default:
}) if (enumIndex pat == 0) {
															var ` = pat[0];
															{
																var n2 = `;
																{
																	@:ast(switch (rhs2.def) {
	case EList(items2) if (items2.length == 0):
		temp = n2;
		initIdx = i;	
	default:
}) {
																		var ` = rhs2.def;
																		if (enumIndex ` == 15) {
																			var ` = `[0];
																			{
																				var items2 = `;
																				if (items2.length == 0) {
																					temp[0] = n2;
																					initIdx = i;
																				} else {};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var rhs = `;
														{
															@:ast(switch (left.def) {
	case EVar(n):
		switch (rhs.def) {
			case EList(items) if (items.length == 0):
				temp = n;
				initIdx = i;			
			default:
		};	
	default:
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var n = `;
																		{
																			@:ast(switch (rhs.def) {
	case EList(items) if (items.length == 0):
		temp = n;
		initIdx = i;	
	default:
}) {
																				var ` = rhs.def;
																				if (enumIndex ` == 15) {
																					var ` = `[0];
																					{
																						var items = `;
																						if (items.length == 0) {
																							temp[0] = n;
																							initIdx = i;
																						} else {};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
								};
							};
							if (temp[0] == null) {
								return node;
							};
							var eachIdx = -1;
							var listExpr = null;
							var clause = null;
							{
								var ` = initIdx + 1;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case ERemoteCall(mod, func, args) if (func == "each" && args.length == 2):
		switch (mod.def) {
			case EVar(m) if (m == "Enum"):
				listExpr = args[0];
				switch (args[1].def) {
					case EFn(clauses) if (clauses.length == 1):
						clause = clauses[0];
						eachIdx = i;					
					default:
				};			
			default:
		};	
	case EBinary(Match, _, rhs) | EMatch(_, rhs):
		switch (rhs.def) {
			case ERemoteCall(mod2, func2, args2) if (func2 == "each" && args2.length == 2):
				switch (mod2.def) {
					case EVar(m2) if (m2 == "Enum"):
						listExpr = args2[0];
						switch (args2[1].def) {
							case EFn(clauses) if (clauses.length == 1):
								clause = clauses[0];
								eachIdx = i;							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var rhs = `;
													{
														@:ast(switch (rhs.def) {
	case ERemoteCall(mod2, func2, args2) if (func2 == "each" && args2.length == 2):
		switch (mod2.def) {
			case EVar(m2) if (m2 == "Enum"):
				listExpr = args2[0];
				switch (args2[1].def) {
					case EFn(clauses) if (clauses.length == 1):
						clause = clauses[0];
						eachIdx = i;					
					default:
				};			
			default:
		};	
	default:
}) {
															var ` = rhs.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod2 = `;
																	var func2 = `;
																	var args2 = `;
																	if (func2 == "each" && args2.length == 2) {
																		@:ast(switch (mod2.def) {
	case EVar(m2) if (m2 == "Enum"):
		listExpr = args2[0];
		switch (args2[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				clause = clauses[0];
				eachIdx = i;			
			default:
		};	
	default:
}) {
																			var ` = mod2.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var m2 = `;
																					if (m2 == "Enum") {
																						listExpr = args2[0];
																						@:ast(switch (args2[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		clause = clauses[0];
		eachIdx = i;	
	default:
}) {
																							var ` = args2[1].def;
																							if (enumIndex ` == 42) {
																								var ` = `[0];
																								{
																									var clauses = `;
																									if (clauses.length == 1) {
																										clause = clauses[0];
																										eachIdx = i;
																									} else {};
																								};
																							} else {};
																						};
																					} else {};
																				};
																			} else {};
																		};
																	} else {};
																};
															} else {};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													if (func == "each" && args.length == 2) {
														@:ast(switch (mod.def) {
	case EVar(m) if (m == "Enum"):
		listExpr = args[0];
		switch (args[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				clause = clauses[0];
				eachIdx = i;			
			default:
		};	
	default:
}) {
															var ` = mod.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var m = `;
																	if (m == "Enum") {
																		listExpr = args[0];
																		@:ast(switch (args[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		clause = clauses[0];
		eachIdx = i;	
	default:
}) {
																			var ` = args[1].def;
																			if (enumIndex ` == 42) {
																				var ` = `[0];
																				{
																					var clauses = `;
																					if (clauses.length == 1) {
																						clause = clauses[0];
																						eachIdx = i;
																					} else {};
																				};
																			} else {};
																		};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var rhs = `;
														{
															@:ast(switch (rhs.def) {
	case ERemoteCall(mod2, func2, args2) if (func2 == "each" && args2.length == 2):
		switch (mod2.def) {
			case EVar(m2) if (m2 == "Enum"):
				listExpr = args2[0];
				switch (args2[1].def) {
					case EFn(clauses) if (clauses.length == 1):
						clause = clauses[0];
						eachIdx = i;					
					default:
				};			
			default:
		};	
	default:
}) {
																var ` = rhs.def;
																if (enumIndex ` == 24) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod2 = `;
																		var func2 = `;
																		var args2 = `;
																		if (func2 == "each" && args2.length == 2) {
																			@:ast(switch (mod2.def) {
	case EVar(m2) if (m2 == "Enum"):
		listExpr = args2[0];
		switch (args2[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				clause = clauses[0];
				eachIdx = i;			
			default:
		};	
	default:
}) {
																				var ` = mod2.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var m2 = `;
																						if (m2 == "Enum") {
																							listExpr = args2[0];
																							@:ast(switch (args2[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		clause = clauses[0];
		eachIdx = i;	
	default:
}) {
																								var ` = args2[1].def;
																								if (enumIndex ` == 42) {
																									var ` = `[0];
																									{
																										var clauses = `;
																										if (clauses.length == 1) {
																											clause = clauses[0];
																											eachIdx = i;
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
								};
							};
							if (eachIdx == -1 || listExpr == null || clause == null) {
								return node;
							};
							var returnsTemp = @:ast(switch (stmts[stmts.length - 1].def) {
	case EVar(vn) if (vn == temp):
		true;	
	default:
		false;	
}) {
								var ` = stmts[stmts.length - 1].def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var vn = `;
										if (vn == temp[0]) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
							if (! returnsTemp) {
								return node;
							};
							var binder = @:ast(switch (clause.args.length > 0 ? clause.args[0] : null) {
	case PVar(n):
		n;	
	default:
		"elem";	
}) {
								var ` = if (clause.args.length > 0) {
									clause.args[0];
								} else {
									null;
								};
								if (` == null) {
									"elem";
								} else if (enumIndex ` == 0) {
									var ` = `[0];
									{
										var n = `;
										{
											n;
										};
									};
								} else {
									"elem";
								};
							};
							var bodyStmts = @:ast(switch (clause.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[clause.body];	
}) {
								var ` = clause.body.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var ss = `;
										{
											ss;
										};
									};
								} else {
									[clause.body];
								};
							};
							var localEntryAlias = null;
							var cleanedStmts = [];
							var presenceShape = false;
							var presenceUsesMetas = false;
							{
								var ` = 0;
								while (` < bodyStmts.length) {
									var bs = bodyStmts[`];
									++ `;
									var drop = false;
									@:ast(switch (bs.def) {
	case EBinary(Match, left, right):
		switch (right.def) {
			case EAccess(tgt, _):
				switch (tgt.def) {
					case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg]) if (ElixirASTPrinter.print(arg, 0) == ElixirASTPrinter.print(listExpr, 0)):
						drop = true;
						presenceShape = true;					
					default:
				};			
			default:
		};
		if (!drop) switch (left.def) {
			case EVar(aliasName):
				switch (right.def) {
					case ERemoteCall({ def : EVar("Map") }, "get", [m, _key]) if (ElixirASTPrinter.print(m, 0) == ElixirASTPrinter.print(listExpr, 0)):
						localEntryAlias = aliasName;
						drop = true;
						presenceShape = true;					
					default:
				};			
			default:
		};
		switch (right.def) {
			case EAccess(arrX, _):
				switch (arrX.def) {
					case EField(_, fieldX) if (fieldX == "metas"):
						presenceUsesMetas = true;					
					default:
				};			
			default:
		};	
	case EMatch(pat, right2):
		switch (right2.def) {
			case EAccess(tgt2, _):
				switch (tgt2.def) {
					case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg2]) if (ElixirASTPrinter.print(arg2, 0) == ElixirASTPrinter.print(listExpr, 0)):
						drop = true;
						presenceShape = true;					
					default:
				};			
			default:
		};
		if (!drop) switch (pat) {
			case PVar(aliasName2):
				switch (right2.def) {
					case ERemoteCall({ def : EVar("Map") }, "get", [m2, _key2]) if (ElixirASTPrinter.print(m2, 0) == ElixirASTPrinter.print(listExpr, 0)):
						localEntryAlias = aliasName2;
						drop = true;
						presenceShape = true;					
					default:
				};			
			default:
		};
		switch (right2.def) {
			case EAccess(arrY, _):
				switch (arrY.def) {
					case EField(_, fieldY) if (fieldY == "metas"):
						presenceUsesMetas = true;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = bs.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var pat = `;
													var right2 = `;
													{
														@:ast(switch (right2.def) {
	case EAccess(tgt2, _):
		switch (tgt2.def) {
			case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg2]) if (ElixirASTPrinter.print(arg2, 0) == ElixirASTPrinter.print(listExpr, 0)):
				drop = true;
				presenceShape = true;			
			default:
		};	
	default:
}) {
															var ` = right2.def;
															if (enumIndex ` == 29) {
																var ` = `[0];
																var ` = `[1];
																{
																	var tgt2 = `;
																	{
																		@:ast(switch (tgt2.def) {
	case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg2]) if (ElixirASTPrinter.print(arg2, 0) == ElixirASTPrinter.print(listExpr, 0)):
		drop = true;
		presenceShape = true;	
	default:
}) {
																			var ` = tgt2.def;
																			if (enumIndex ` == 24) {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var ` = `.def;
																					var ` = `.metadata;
																					var ` = `.pos;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						if (` == "Reflect") {
																							if (` == "fields") {
																								if (`.length == 1) {
																									var ` = `[0];
																									{
																										var arg2 = `;
																										if (reflaxe.elixir.ast.ElixirASTPrinter.print(arg2, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(listExpr, 0)) {
																											drop = true;
																											presenceShape = true;
																										} else {};
																									};
																								} else {};
																							} else {};
																						} else {};
																					} else {};
																				};
																			} else {};
																		};
																	};
																};
															} else {};
														};
														if (! drop) {
															@:ast(switch (pat) {
	case PVar(aliasName2):
		switch (right2.def) {
			case ERemoteCall({ def : EVar("Map") }, "get", [m2, _key2]) if (ElixirASTPrinter.print(m2, 0) == ElixirASTPrinter.print(listExpr, 0)):
				localEntryAlias = aliasName2;
				drop = true;
				presenceShape = true;			
			default:
		};	
	default:
}) if (enumIndex pat == 0) {
																var ` = pat[0];
																{
																	var aliasName2 = `;
																	{
																		@:ast(switch (right2.def) {
	case ERemoteCall({ def : EVar("Map") }, "get", [m2, _key2]) if (ElixirASTPrinter.print(m2, 0) == ElixirASTPrinter.print(listExpr, 0)):
		localEntryAlias = aliasName2;
		drop = true;
		presenceShape = true;	
	default:
}) {
																			var ` = right2.def;
																			if (enumIndex ` == 24) {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var ` = `.def;
																					var ` = `.metadata;
																					var ` = `.pos;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						if (` == "Map") {
																							if (` == "get") {
																								if (`.length == 2) {
																									var ` = `[0];
																									var ` = `[1];
																									{
																										var m2 = `;
																										var _key2 = `;
																										if (reflaxe.elixir.ast.ElixirASTPrinter.print(m2, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(listExpr, 0)) {
																											localEntryAlias = aliasName2;
																											drop = true;
																											presenceShape = true;
																										} else {};
																									};
																								} else {};
																							} else {};
																						} else {};
																					} else {};
																				};
																			} else {};
																		};
																	};
																};
															} else {};
														};
														@:ast(switch (right2.def) {
	case EAccess(arrY, _):
		switch (arrY.def) {
			case EField(_, fieldY) if (fieldY == "metas"):
				presenceUsesMetas = true;			
			default:
		};	
	default:
}) {
															var ` = right2.def;
															if (enumIndex ` == 29) {
																var ` = `[0];
																var ` = `[1];
																{
																	var arrY = `;
																	{
																		@:ast(switch (arrY.def) {
	case EField(_, fieldY) if (fieldY == "metas"):
		presenceUsesMetas = true;	
	default:
}) {
																			var ` = arrY.def;
																			if (enumIndex ` == 28) {
																				var ` = `[0];
																				var ` = `[1];
																				{
																					var fieldY = `;
																					if (fieldY == "metas") {
																						presenceUsesMetas = true;
																					} else {};
																				};
																			} else {};
																		};
																	};
																};
															} else {};
														};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var right = `;
														{
															@:ast(switch (right.def) {
	case EAccess(tgt, _):
		switch (tgt.def) {
			case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg]) if (ElixirASTPrinter.print(arg, 0) == ElixirASTPrinter.print(listExpr, 0)):
				drop = true;
				presenceShape = true;			
			default:
		};	
	default:
}) {
																var ` = right.def;
																if (enumIndex ` == 29) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var tgt = `;
																		{
																			@:ast(switch (tgt.def) {
	case ERemoteCall({ def : EVar("Reflect") }, "fields", [arg]) if (ElixirASTPrinter.print(arg, 0) == ElixirASTPrinter.print(listExpr, 0)):
		drop = true;
		presenceShape = true;	
	default:
}) {
																				var ` = tgt.def;
																				if (enumIndex ` == 24) {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 38) {
																							var ` = `[0];
																							if (` == "Reflect") {
																								if (` == "fields") {
																									if (`.length == 1) {
																										var ` = `[0];
																										{
																											var arg = `;
																											if (reflaxe.elixir.ast.ElixirASTPrinter.print(arg, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(listExpr, 0)) {
																												drop = true;
																												presenceShape = true;
																											} else {};
																										};
																									} else {};
																								} else {};
																							} else {};
																						} else {};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
															if (! drop) {
																@:ast(switch (left.def) {
	case EVar(aliasName):
		switch (right.def) {
			case ERemoteCall({ def : EVar("Map") }, "get", [m, _key]) if (ElixirASTPrinter.print(m, 0) == ElixirASTPrinter.print(listExpr, 0)):
				localEntryAlias = aliasName;
				drop = true;
				presenceShape = true;			
			default:
		};	
	default:
}) {
																	var ` = left.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var aliasName = `;
																			{
																				@:ast(switch (right.def) {
	case ERemoteCall({ def : EVar("Map") }, "get", [m, _key]) if (ElixirASTPrinter.print(m, 0) == ElixirASTPrinter.print(listExpr, 0)):
		localEntryAlias = aliasName;
		drop = true;
		presenceShape = true;	
	default:
}) {
																					var ` = right.def;
																					if (enumIndex ` == 24) {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var ` = `.def;
																							var ` = `.metadata;
																							var ` = `.pos;
																							if (enumIndex ` == 38) {
																								var ` = `[0];
																								if (` == "Map") {
																									if (` == "get") {
																										if (`.length == 2) {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var m = `;
																												var _key = `;
																												if (reflaxe.elixir.ast.ElixirASTPrinter.print(m, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(listExpr, 0)) {
																													localEntryAlias = aliasName;
																													drop = true;
																													presenceShape = true;
																												} else {};
																											};
																										} else {};
																									} else {};
																								} else {};
																							} else {};
																						};
																					} else {};
																				};
																			};
																		};
																	} else {};
																};
															};
															@:ast(switch (right.def) {
	case EAccess(arrX, _):
		switch (arrX.def) {
			case EField(_, fieldX) if (fieldX == "metas"):
				presenceUsesMetas = true;			
			default:
		};	
	default:
}) {
																var ` = right.def;
																if (enumIndex ` == 29) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var arrX = `;
																		{
																			@:ast(switch (arrX.def) {
	case EField(_, fieldX) if (fieldX == "metas"):
		presenceUsesMetas = true;	
	default:
}) {
																				var ` = arrX.def;
																				if (enumIndex ` == 28) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var fieldX = `;
																						if (fieldX == "metas") {
																							presenceUsesMetas = true;
																						} else {};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									if (! drop) {
										cleanedStmts.push(bs);
									};
								};
							};
							if (presenceShape && presenceUsesMetas) {
								var binderSafe = if ((binder != null && binder.length > 0 && binder.charAt(0) == "_")) {
									binder.substr(1, null);
								} else {
									binder;
								};
								var metaExpr = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAccess({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EField({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderSafe), metadata : {}, pos : pos};
										}, "metas"), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
								var cond = null;
								var isTempAppendAssign = function(s:reflaxe.elixir.ast.ElixirAST, name:String) {
									return @:ast(switch (s.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(v) if (v == name):
				switch (rhs.def) {
					case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, _]):
						switch (a0.def) {
							case EVar(v0) if (v0 == name):
								true;							
							default:
								false;							
						};					
					case EBinary(Concat, llist, _):
						switch (llist.def) {
							case EVar(v1) if (v1 == name):
								true;							
							default:
								false;							
						};					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
										var ` = s.def;
										if (enumIndex ` == 26) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 27) {
												{
													var left = `;
													var rhs = `;
													{
														@:ast(switch (left.def) {
	case EVar(v) if (v == name):
		switch (rhs.def) {
			case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, _]):
				switch (a0.def) {
					case EVar(v0) if (v0 == name):
						true;					
					default:
						false;					
				};			
			case EBinary(Concat, llist, _):
				switch (llist.def) {
					case EVar(v1) if (v1 == name):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
															var ` = left.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var v = `;
																	if (v == name) {
																		@:ast(switch (rhs.def) {
	case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, _]):
		switch (a0.def) {
			case EVar(v0) if (v0 == name):
				true;			
			default:
				false;			
		};	
	case EBinary(Concat, llist, _):
		switch (llist.def) {
			case EVar(v1) if (v1 == name):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
																			var ` = rhs.def;
																			switch (enumIndex `) {
																				case 24: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 38) {
																							var ` = `[0];
																							if (` == "Enum") {
																								if (` == "concat") {
																									if (`.length == 2) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var a0 = `;
																											{
																												@:ast(switch (a0.def) {
	case EVar(v0) if (v0 == name):
		true;	
	default:
		false;	
}) {
																													var ` = a0.def;
																													if (enumIndex ` == 38) {
																														var ` = `[0];
																														{
																															var v0 = `;
																															if (v0 == name) {
																																true;
																															} else {
																																false;
																															};
																														};
																													} else {
																														false;
																													};
																												};
																											};
																										};
																									} else {
																										false;
																									};
																								} else {
																									false;
																								};
																							} else {
																								false;
																							};
																						} else {
																							false;
																						};
																					};
																				};
																				case 26: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					if (enumIndex ` == 23) {
																						{
																							var llist = `;
																							{
																								@:ast(switch (llist.def) {
	case EVar(v1) if (v1 == name):
		true;	
	default:
		false;	
}) {
																									var ` = llist.def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										{
																											var v1 = `;
																											if (v1 == name) {
																												true;
																											} else {
																												false;
																											};
																										};
																									} else {
																										false;
																									};
																								};
																							};
																						};
																					} else {
																						false;
																					};
																				};
																				default: {
																					false;
																				}
																			};
																		};
																	} else {
																		false;
																	};
																};
															} else {
																false;
															};
														};
													};
												};
											} else {
												false;
											};
										} else {
											false;
										};
									};
								};
								var presenceAppendsTemp = function(expr:reflaxe.elixir.ast.ElixirAST, name:String) {
									@:ast(switch (expr?.def) {
	case EBlock(ss):
		for (s  in  ss) if (isTempAppendAssign(s, name)) return true;
		return false;	
	default:
		return isTempAppendAssign(expr, name);	
}) {
										var ` = if (expr != null) expr.def else null;
										if (` == null) {
											return isTempAppendAssign(expr, name);
										} else if (enumIndex ` == 53) {
											var ` = `[0];
											{
												var ss = `;
												{
													{
														var ` = 0;
														while (` < ss.length) {
															var s = ss[`];
															++ `;
															if (isTempAppendAssign(s, name)) {
																return true;
															};
														};
													};
													return false;
												};
											};
										} else {
											return isTempAppendAssign(expr, name);
										};
									};
								};
								var findCond = [null];
								findCond[0] = function(nodes:Array<reflaxe.elixir.ast.ElixirAST>) {
									if (nodes == null) {
										return null;
									};
									{
										var ` = 0;
										while (` < nodes.length) {
											var n = nodes[`];
											++ `;
											@:ast(switch (n.def) {
	case EIf(c, t, e):
		if (presenceAppendsTemp(t, temp)) return c;
		var a = findCond(switch (t.def) {
			case EBlock(ss):
				ss;			
			default:
				[t];			
		});
		if (a != null) return a;
		var b = findCond(switch (e?.def) {
			case EBlock(ss2):
				ss2;			
			default:
				e != null ? [e] : [];			
		});
		if (b != null) return b;	
	default:
}) {
												var ` = n.def;
												if (enumIndex ` == 10) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var c = `;
														var t = `;
														var e = `;
														{
															if (presenceAppendsTemp(t, temp[0])) {
																return c;
															};
															var a = findCond[0](@:ast(switch (t.def) {
	case EBlock(ss):
		ss;	
	default:
		[t];	
}) {
																var ` = t.def;
																if (enumIndex ` == 53) {
																	var ` = `[0];
																	{
																		var ss = `;
																		{
																			ss;
																		};
																	};
																} else {
																	[t];
																};
															});
															if (a != null) {
																return a;
															};
															var b = findCond[0](@:ast(switch (e?.def) {
	case EBlock(ss2):
		ss2;	
	default:
		e != null ? [e] : [];	
}) {
																var ` = if (e != null) e.def else null;
																if (` == null) {
																	if (e != null) {
																		[e];
																	} else {
																		[];
																	};
																} else if (enumIndex ` == 53) {
																	var ` = `[0];
																	{
																		var ss2 = `;
																		{
																			ss2;
																		};
																	};
																} else {
																	if (e != null) {
																		[e];
																	} else {
																		[];
																	};
																};
															});
															if (b != null) {
																return b;
															};
														};
													};
												} else {};
											};
										};
									};
									return null;
								};
								cond = findCond[0](bodyStmts);
								if (localEntryAlias != null) {
									cond = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(cond, localEntryAlias, binderSafe);
								};
								cond = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(cond, "entry", binderSafe);
								var metaAlias = null;
								{
									var ` = 0;
									while (` < bodyStmts.length) {
										var bs = bodyStmts[`];
										++ `;
										@:ast(switch (bs.def) {
	case EBinary(Match, leftX, rightX):
		switch (leftX.def) {
			case EVar(mn):
				switch (rightX.def) {
					case EAccess(arrX, _):
						switch (arrX.def) {
							case EField(_, fieldX) if (fieldX == "metas"):
								metaAlias = mn;							
							default:
						};					
					default:
				};			
			default:
		};	
	default:
}) {
											var ` = bs.def;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var leftX = `;
														var rightX = `;
														{
															@:ast(switch (leftX.def) {
	case EVar(mn):
		switch (rightX.def) {
			case EAccess(arrX, _):
				switch (arrX.def) {
					case EField(_, fieldX) if (fieldX == "metas"):
						metaAlias = mn;					
					default:
				};			
			default:
		};	
	default:
}) {
																var ` = leftX.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var mn = `;
																		{
																			@:ast(switch (rightX.def) {
	case EAccess(arrX, _):
		switch (arrX.def) {
			case EField(_, fieldX) if (fieldX == "metas"):
				metaAlias = mn;			
			default:
		};	
	default:
}) {
																				var ` = rightX.def;
																				if (enumIndex ` == 29) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var arrX = `;
																						{
																							@:ast(switch (arrX.def) {
	case EField(_, fieldX) if (fieldX == "metas"):
		metaAlias = mn;	
	default:
}) {
																								var ` = arrX.def;
																								if (enumIndex ` == 28) {
																									var ` = `[0];
																									var ` = `[1];
																									{
																										var fieldX = `;
																										if (fieldX == "metas") {
																											metaAlias = mn;
																										} else {};
																									};
																								} else {};
																							};
																						};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											} else {};
										};
									};
								};
								if (metaAlias != null) {
									cond = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarWithExpr(cond, metaAlias, metaExpr);
								};
								var appendMeta = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EList([metaExpr]), metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
								var outerCond = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Greater, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
										}, "length", [{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EField({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderSafe), metadata : {}, pos : pos};
											}, "metas"), metadata : {}, pos : pos};
										}]), metadata : {}, pos : pos};
									}, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
								var inner = if ((cond != null)) {
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, appendMeta, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
										}), metadata : {}, pos : pos};
									};
								} else {
									appendMeta;
								};
								var reducer = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(binderSafe), reflaxe.elixir.ast.EPattern.PVar("acc")], guard : clause.guard, body : {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(outerCond, inner, {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
										}), metadata : {}, pos : pos};
									}}]), metadata : {}, pos : pos};
								};
								var reduceInput = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
									}, "values", [listExpr]), metadata : {}, pos : pos};
								};
								var reduceCall = {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
									}, "reduce", [reduceInput, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EList([]), metadata : {}, pos : pos};
									}, reducer]), metadata : {}, pos : pos};
								};
								var out2 = [];
								{
									var ` = 0;
									var ` = stmts.length;
									while (` < `) {
										var i = ` ++;
										if (i == initIdx) {
											out2.push(reduceCall);
										} else {
											if (i == eachIdx || i == stmts.length - 1) {} else {
												out2.push(stmts[i]);
											};
										};
									};
								};
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out2), metadata : node.metadata, pos : node.pos};
							};
							var normalizedStmts = [];
							{
								var ` = 0;
								while (` < cleanedStmts.length) {
									var cs = cleanedStmts[`];
									++ `;
									var cs2 = cs;
									if (localEntryAlias != null) {
										cs2 = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(cs2, localEntryAlias, binder);
									};
									normalizedStmts.push(cs2);
								};
							};
							var rewriteAccAssign = function(s:reflaxe.elixir.ast.ElixirAST) {
								return @:ast(switch (s.def) {
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(lhs) if (lhs == temp):
				switch (rhs.def) {
					case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, a1]):
						switch (a0.def) {
							case EVar(v0) if (v0 == temp):
								switch (a1.def) {
									case EList(items) if (items.length == 1):
										makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));									
									default:
										null;									
								};							
							default:
								null;							
						};					
					case EBinary(Concat, llist, rlist):
						switch (llist.def) {
							case EVar(v1) if (v1 == temp):
								makeAST(EBinary(Concat, makeAST(EVar("acc")), rlist));							
							default:
								null;							
						};					
					default:
						null;					
				};			
			default:
				null;			
		};	
	default:
		null;	
}) {
									var ` = s.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 27) {
											{
												var left = `;
												var rhs = `;
												{
													@:ast(switch (left.def) {
	case EVar(lhs) if (lhs == temp):
		switch (rhs.def) {
			case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, a1]):
				switch (a0.def) {
					case EVar(v0) if (v0 == temp):
						switch (a1.def) {
							case EList(items) if (items.length == 1):
								makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));							
							default:
								null;							
						};					
					default:
						null;					
				};			
			case EBinary(Concat, llist, rlist):
				switch (llist.def) {
					case EVar(v1) if (v1 == temp):
						makeAST(EBinary(Concat, makeAST(EVar("acc")), rlist));					
					default:
						null;					
				};			
			default:
				null;			
		};	
	default:
		null;	
}) {
														var ` = left.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var lhs = `;
																if (lhs == temp[0]) {
																	@:ast(switch (rhs.def) {
	case ERemoteCall({ def : EVar("Enum") }, "concat", [a0, a1]):
		switch (a0.def) {
			case EVar(v0) if (v0 == temp):
				switch (a1.def) {
					case EList(items) if (items.length == 1):
						makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));					
					default:
						null;					
				};			
			default:
				null;			
		};	
	case EBinary(Concat, llist, rlist):
		switch (llist.def) {
			case EVar(v1) if (v1 == temp):
				makeAST(EBinary(Concat, makeAST(EVar("acc")), rlist));			
			default:
				null;			
		};	
	default:
		null;	
}) {
																		var ` = rhs.def;
																		switch (enumIndex `) {
																			case 24: {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var ` = `.def;
																					var ` = `.metadata;
																					var ` = `.pos;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						if (` == "Enum") {
																							if (` == "concat") {
																								if (`.length == 2) {
																									var ` = `[0];
																									var ` = `[1];
																									{
																										var a0 = `;
																										var a1 = `;
																										{
																											@:ast(switch (a0.def) {
	case EVar(v0) if (v0 == temp):
		switch (a1.def) {
			case EList(items) if (items.length == 1):
				makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));			
			default:
				null;			
		};	
	default:
		null;	
}) {
																												var ` = a0.def;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var v0 = `;
																														if (v0 == temp[0]) {
																															@:ast(switch (a1.def) {
	case EList(items) if (items.length == 1):
		makeAST(EBinary(Concat, makeAST(EVar("acc")), makeAST(EList([items[0]]))));	
	default:
		null;	
}) {
																																var ` = a1.def;
																																if (enumIndex ` == 15) {
																																	var ` = `[0];
																																	{
																																		var items = `;
																																		if (items.length == 1) {
																																			{
																																				var pos = null;
																																				{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, {
																																					var pos = null;
																																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
																																				}, {
																																					var pos = null;
																																					{def : reflaxe.elixir.ast.ElixirASTDef.EList([items[0]]), metadata : {}, pos : pos};
																																				}), metadata : {}, pos : pos};
																																			};
																																		} else {
																																			null;
																																		};
																																	};
																																} else {
																																	null;
																																};
																															};
																														} else {
																															null;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										};
																									};
																								} else {
																									null;
																								};
																							} else {
																								null;
																							};
																						} else {
																							null;
																						};
																					} else {
																						null;
																					};
																				};
																			};
																			case 26: {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				if (enumIndex ` == 23) {
																					{
																						var llist = `;
																						var rlist = `;
																						{
																							@:ast(switch (llist.def) {
	case EVar(v1) if (v1 == temp):
		makeAST(EBinary(Concat, makeAST(EVar("acc")), rlist));	
	default:
		null;	
}) {
																								var ` = llist.def;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var v1 = `;
																										if (v1 == temp[0]) {
																											{
																												var pos = null;
																												{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, {
																													var pos = null;
																													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
																												}, rlist), metadata : {}, pos : pos};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						};
																					};
																				} else {
																					null;
																				};
																			};
																			default: {
																				null;
																			}
																		};
																	};
																} else {
																	null;
																};
															};
														} else {
															null;
														};
													};
												};
											};
										} else {
											null;
										};
									} else {
										null;
									};
								};
							};
							var transformBody = [null];
							transformBody[0] = function(expr:reflaxe.elixir.ast.ElixirAST) {
								if (expr == null) {
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
									};
								};
								return @:ast(switch (expr.def) {
	case EIf(cond, thenBr, elseBr):
		var directThenAppend = rewriteAccAssign(thenBr);
		var directElseAppend = (elseBr == null) ? null : rewriteAccAssign(elseBr);
		var thenX = (directThenAppend != null) ? directThenAppend : transformBody(thenBr);
		var elseX = (elseBr == null) ? makeAST(EVar("acc")) : ((directElseAppend != null) ? directElseAppend : transformBody(elseBr));
		var thenAppend = rewriteAccAssign(thenX);
		var elseAppend = rewriteAccAssign(elseX);
		if (thenAppend != null && elseAppend == null) {
			makeAST(EIf(cond, thenAppend, makeAST(EVar("acc"))));
		} else if (thenAppend != null && elseAppend != null) {
			makeAST(EIf(cond, thenAppend, elseAppend));
		} else {
			var keptElse = (elseBr == null) ? makeAST(EVar("acc")) : transformBody(elseBr);
			makeAST(EIf(cond, transformBody(thenBr), keptElse));
		};	
	case EBlock(ss):
		var out:Array<ElixirAST> = [];
		for (s  in  ss) {
			var r = transformBody(s);
			switch (r.def) {
				case EInteger(v) if (v == 0 || v == 1):
				case EFloat(f) if (f == 0.0):
				default:
					out.push(r);				
			};
		};
		makeAST(EBlock(out));	
	default:
		expr;	
}) {
									var ` = expr.def;
									switch (enumIndex `) {
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cond = `;
												var thenBr = `;
												var elseBr = `;
												{
													var directThenAppend = rewriteAccAssign(thenBr);
													var directElseAppend = if ((elseBr == null)) {
														null;
													} else {
														rewriteAccAssign(elseBr);
													};
													var thenX = if ((directThenAppend != null)) {
														directThenAppend;
													} else {
														transformBody[0](thenBr);
													};
													var elseX = if ((elseBr == null)) {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
														};
													} else {
														(if ((directElseAppend != null)) {
															directElseAppend;
														} else {
															transformBody[0](elseBr);
														});
													};
													var thenAppend = rewriteAccAssign(thenX);
													var elseAppend = rewriteAccAssign(elseX);
													if (thenAppend != null && elseAppend == null) {
														{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, thenAppend, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														};
													} else {
														if (thenAppend != null && elseAppend != null) {
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, thenAppend, elseAppend), metadata : {}, pos : pos};
															};
														} else {
															var keptElse = if ((elseBr == null)) {
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
																};
															} else {
																transformBody[0](elseBr);
															};
															{
																var def = reflaxe.elixir.ast.ElixirASTDef.EIf(cond, transformBody[0](thenBr), keptElse);
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															};
														};
													};
												};
											};
										};
										case 53: {
											var ` = `[0];
											{
												var ss = `;
												{
													var out = [];
													{
														var ` = 0;
														while (` < ss.length) {
															var s = ss[`];
															++ `;
															var r = transformBody[0](s);
															@:ast(switch (r.def) {
	case EInteger(v) if (v == 0 || v == 1):
	case EFloat(f) if (f == 0.0):
	default:
		out.push(r);	
}) {
																var ` = r.def;
																switch (enumIndex `) {
																	case 33: {
																		var ` = `[0];
																		{
																			var v = `;
																			if (v == 0 || v == 1) {} else {
																				out.push(r);
																			};
																		};
																	};
																	case 34: {
																		var ` = `[0];
																		{
																			var f = `;
																			if (f == 0.0) {} else {
																				out.push(r);
																			};
																		};
																	};
																	default: {
																		out.push(r);
																	}
																};
															};
														};
													};
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : {}, pos : pos};
													};
												};
											};
										};
										default: {
											expr;
										}
									};
								};
							};
							var bodyForTransform = if ((normalizedStmts.length == 1)) {
								normalizedStmts[0];
							} else {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(normalizedStmts), metadata : {}, pos : pos};
								};
							};
							var rewrittenBody = transformBody[0](bodyForTransform);
							var reducerBody = @:ast(switch (rewrittenBody.def) {
	case EBlock(ss):
		var needTail = true;
		if (ss.length > 0) switch (ss[ss.length - 1].def) {
			case EVar(nm) if (nm == "acc"):
				needTail = false;			
			default:
		};
		makeAST(needTail ? EBlock(ss.concat([makeAST(EVar("acc"))])) : EBlock(ss));	
	default:
		var lastIsAcc = switch (rewrittenBody.def) {
			case EVar(nm2) if (nm2 == "acc"):
				true;			
			default:
				false;			
		};
		lastIsAcc ? rewrittenBody : makeAST(EBlock([rewrittenBody, makeAST(EVar("acc"))]));	
}) {
								var ` = rewrittenBody.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var ss = `;
										{
											var needTail = true;
											if (ss.length > 0) {
												@:ast(switch (ss[ss.length - 1].def) {
	case EVar(nm) if (nm == "acc"):
		needTail = false;	
	default:
}) {
													var ` = ss[ss.length - 1].def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var nm = `;
															if (nm == "acc") {
																needTail = false;
															} else {};
														};
													} else {};
												};
											};
											{
												var def = if ((needTail)) reflaxe.elixir.ast.ElixirASTDef.EBlock(ss.concat([{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
												}])) else reflaxe.elixir.ast.ElixirASTDef.EBlock(ss);
												var pos = null;
												{def : def, metadata : {}, pos : pos};
											};
										};
									};
								} else {
									var lastIsAcc = @:ast(switch (rewrittenBody.def) {
	case EVar(nm2) if (nm2 == "acc"):
		true;	
	default:
		false;	
}) {
										var ` = rewrittenBody.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var nm2 = `;
												if (nm2 == "acc") {
													true;
												} else {
													false;
												};
											};
										} else {
											false;
										};
									};
									if (lastIsAcc) {
										rewrittenBody;
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([rewrittenBody, {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
											}]), metadata : {}, pos : pos};
										};
									};
								};
							};
							reducerBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(reducerBody, function(t:reflaxe.elixir.ast.ElixirAST) {
								return @:ast(switch (t.def) {
	case EBinary(Match, leftT, rhsT):
		switch (leftT.def) {
			case EVar(lhsT) if (lhsT == temp):
				var repl = rewriteAccAssign(t);
				if (repl != null) makeASTWithMeta(EBinary(Match, makeAST(EVar("acc")), repl), t.metadata, t.pos) else t;			
			default:
				t;			
		};	
	default:
		t;	
}) {
									var ` = t.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 27) {
											{
												var leftT = `;
												var rhsT = `;
												{
													@:ast(switch (leftT.def) {
	case EVar(lhsT) if (lhsT == temp):
		var repl = rewriteAccAssign(t);
		if (repl != null) makeASTWithMeta(EBinary(Match, makeAST(EVar("acc")), repl), t.metadata, t.pos) else t;	
	default:
		t;	
}) {
														var ` = leftT.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var lhsT = `;
																if (lhsT == temp[0]) {
																	var repl = rewriteAccAssign(t);
																	if (repl != null) {
																		{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("acc"), metadata : {}, pos : pos};
																		}, repl), metadata : t.metadata, pos : t.pos};
																	} else {
																		t;
																	};
																} else {
																	t;
																};
															};
														} else {
															t;
														};
													};
												};
											};
										} else {
											t;
										};
									} else {
										t;
									};
								};
							});
							if (localEntryAlias != null) {
								reducerBody = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(reducerBody, localEntryAlias, binder);
							};
							var reducer = {
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(if ((binder != null && binder.length > 0 && binder.charAt(0) == "_")) binder.substr(1, null) else binder), reflaxe.elixir.ast.EPattern.PVar("acc")], guard : clause.guard, body : reducerBody}]);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
							var reduceInput = if ((presenceShape && presenceUsesMetas)) {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
									}, "values", [listExpr]), metadata : {}, pos : pos};
								};
							} else {
								listExpr;
							};
							var reduceCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "reduce", [reduceInput, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EList([]), metadata : {}, pos : pos};
								}, reducer]), metadata : {}, pos : pos};
							};
							var out = [];
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									if (i == initIdx) {
										out.push(reduceCall);
									} else {
										if (i == eachIdx || i == stmts.length - 1) {} else {
											out.push(stmts[i]);
										};
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function enumEachLhsDiscardPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts):
		var out = [];
		for (i  in  0 ... stmts.length) {
			var s = stmts[i];
			switch (s.def) {
				case EMatch(pat, rhs):
					var isTuple = switch (pat) {
						case PTuple(_):
							true;						
						default:
							false;						
					};
					switch (rhs.def) {
						case ERemoteCall(mod, func, args) if (isTuple && isEnumEach(mod, func, args)):
							out.push(makeASTWithMeta(ERemoteCall(mod, func, args), s.metadata, s.pos));						
						default:
							out.push(s);						
					};				
				case EBinary(Match, left, rhs2):
					var isTuple2 = switch (left.def) {
						case ETuple(_):
							true;						
						default:
							false;						
					};
					switch (rhs2.def) {
						case ERemoteCall(mod2, func2, args2) if (isTuple2 && isEnumEach(mod2, func2, args2)):
							out.push(makeASTWithMeta(ERemoteCall(mod2, func2, args2), s.metadata, s.pos));						
						default:
							out.push(s);						
					};				
				default:
					out.push(s);				
			};
		};
		makeASTWithMeta(EBlock(out), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							var out = [];
							{
								var ` = 0;
								var ` = stmts.length;
								while (` < `) {
									var i = ` ++;
									var s = stmts[i];
									@:ast(switch (s.def) {
	case EMatch(pat, rhs):
		var isTuple = switch (pat) {
			case PTuple(_):
				true;			
			default:
				false;			
		};
		switch (rhs.def) {
			case ERemoteCall(mod, func, args) if (isTuple && isEnumEach(mod, func, args)):
				out.push(makeASTWithMeta(ERemoteCall(mod, func, args), s.metadata, s.pos));			
			default:
				out.push(s);			
		};	
	case EBinary(Match, left, rhs2):
		var isTuple2 = switch (left.def) {
			case ETuple(_):
				true;			
			default:
				false;			
		};
		switch (rhs2.def) {
			case ERemoteCall(mod2, func2, args2) if (isTuple2 && isEnumEach(mod2, func2, args2)):
				out.push(makeASTWithMeta(ERemoteCall(mod2, func2, args2), s.metadata, s.pos));			
			default:
				out.push(s);			
		};	
	default:
		out.push(s);	
}) {
										var ` = s.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var pat = `;
													var rhs = `;
													{
														var isTuple = @:ast(switch (pat) {
	case PTuple(_):
		true;	
	default:
		false;	
}) if (enumIndex pat == 2) {
															var ` = pat[0];
															{
																true;
															};
														} else {
															false;
														};
														@:ast(switch (rhs.def) {
	case ERemoteCall(mod, func, args) if (isTuple && isEnumEach(mod, func, args)):
		out.push(makeASTWithMeta(ERemoteCall(mod, func, args), s.metadata, s.pos));	
	default:
		out.push(s);	
}) {
															var ` = rhs.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod = `;
																	var func = `;
																	var args = `;
																	if (isTuple && @:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																		var ` = mod.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	}) {
																		out.push({def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, args), metadata : s.metadata, pos : s.pos});
																	} else {
																		out.push(s);
																	};
																};
															} else {
																out.push(s);
															};
														};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var rhs2 = `;
														{
															var isTuple2 = @:ast(switch (left.def) {
	case ETuple(_):
		true;	
	default:
		false;	
}) {
																var ` = left.def;
																if (enumIndex ` == 16) {
																	var ` = `[0];
																	{
																		true;
																	};
																} else {
																	false;
																};
															};
															@:ast(switch (rhs2.def) {
	case ERemoteCall(mod2, func2, args2) if (isTuple2 && isEnumEach(mod2, func2, args2)):
		out.push(makeASTWithMeta(ERemoteCall(mod2, func2, args2), s.metadata, s.pos));	
	default:
		out.push(s);	
}) {
																var ` = rhs2.def;
																if (enumIndex ` == 24) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod2 = `;
																		var func2 = `;
																		var args2 = `;
																		if (isTuple2 && @:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																			var ` = mod2.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var name = `;
																					if ((name == "Enum") && func2 == "each" && args2 != null && args2.length == 2) {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		}) {
																			out.push({def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod2, func2, args2), metadata : s.metadata, pos : s.pos});
																		} else {
																			out.push(s);
																		};
																	};
																} else {
																	out.push(s);
																};
															};
														};
													};
												} else {
													out.push(s);
												};
											};
											default: {
												out.push(s);
											}
										};
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function countBinderNormalizePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(m) }, "count", [list, fnExpr]) if (m == "Enum"):
		switch (fnExpr.def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				if (cl.args.length == 1) {
					switch (cl.args[0]) {
						case PVar(name) if (name != null && name.length > 0):
							var trimmed = safeBinder(name);
							var newBody = cl.body;
							newBody = replaceVarInExpr(newBody, "_" + trimmed, trimmed);
							if (name != trimmed) newBody = replaceVarInExpr(newBody, name, trimmed);
							var newFn = makeAST(EFn([{ args : [PVar(trimmed)], guard : cl.guard, body : newBody }]));
							makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "count", [list, newFn]), n.metadata, n.pos);						
						default:
							n;						
					};
				} else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							if (` == "count") {
								if (`.length == 2) {
									var ` = `[0];
									var ` = `[1];
									{
										var list = `;
										var fnExpr = `;
										var m = `;
										if (m == "Enum") {
											@:ast(switch (fnExpr.def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		if (cl.args.length == 1) {
			switch (cl.args[0]) {
				case PVar(name) if (name != null && name.length > 0):
					var trimmed = safeBinder(name);
					var newBody = cl.body;
					newBody = replaceVarInExpr(newBody, "_" + trimmed, trimmed);
					if (name != trimmed) newBody = replaceVarInExpr(newBody, name, trimmed);
					var newFn = makeAST(EFn([{ args : [PVar(trimmed)], guard : cl.guard, body : newBody }]));
					makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "count", [list, newFn]), n.metadata, n.pos);				
				default:
					n;				
			};
		} else n;	
	default:
		n;	
}) {
												var ` = fnExpr.def;
												if (enumIndex ` == 42) {
													var ` = `[0];
													{
														var clauses = `;
														if (clauses.length == 1) {
															var cl = clauses[0];
															if (cl.args.length == 1) {
																@:ast(switch (cl.args[0]) {
	case PVar(name) if (name != null && name.length > 0):
		var trimmed = safeBinder(name);
		var newBody = cl.body;
		newBody = replaceVarInExpr(newBody, "_" + trimmed, trimmed);
		if (name != trimmed) newBody = replaceVarInExpr(newBody, name, trimmed);
		var newFn = makeAST(EFn([{ args : [PVar(trimmed)], guard : cl.guard, body : newBody }]));
		makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "count", [list, newFn]), n.metadata, n.pos);	
	default:
		n;	
}) {
																	var ` = cl.args[0];
																	if (enumIndex ` == 0) {
																		var ` = `[0];
																		{
																			var name = `;
																			if (name != null && name.length > 0) {
																				var trimmed = if ((name != null && name.length > 0 && name.charAt(0) == "_")) {
																					name.substr(1, null);
																				} else {
																					name;
																				};
																				var newBody = cl.body;
																				newBody = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(newBody, "_" + trimmed, trimmed);
																				if (name != trimmed) {
																					newBody = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(newBody, name, trimmed);
																				};
																				var newFn = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(trimmed)], guard : cl.guard, body : newBody}]), metadata : {}, pos : pos};
																				};
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																				}, "count", [list, newFn]), metadata : n.metadata, pos : n.pos};
																			} else {
																				n;
																			};
																		};
																	} else {
																		n;
																	};
																};
															} else {
																n;
															};
														} else {
															n;
														};
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							} else {
								n;
							};
						} else {
							n;
						};
					};
				} else {
					n;
				};
			};
		});
	}

	public static function findRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EBlock(stmts) if (stmts.length >= 2):
		var lastIsNil = switch (stmts[stmts.length - 1].def) {
			case ENil:
				true;			
			default:
				false;			
		};
		if (!lastIsNil) return node;
		var eachStmt:Null<ElixirAST> = null;
		for (i  in  0 ... stmts.length - 1) switch (stmts[i].def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
				eachStmt = stmts[i];			
			case EMatch(_, rhs):
				switch (rhs.def) {
					case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
						eachStmt = rhs;					
					default:
				};			
			case EBinary(Match, _, rhs2):
				switch (rhs2.def) {
					case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
						eachStmt = rhs2;					
					default:
				};			
			default:
		};
		if (eachStmt == null) return node;
		var listExpr:Null<ElixirAST> = null;
		var binderName:String = "_elem";
		var condExpr:Null<ElixirAST> = null;
		var aliasFromHead:Null<String> = null;
		switch (eachStmt.def) {
			case ERemoteCall(_m, _f, args):
				listExpr = args[0];
				switch (args[1].def) {
					case EFn(clauses) if (clauses.length == 1):
						var cl = clauses[0];
						switch (cl.args.length > 0 ? cl.args[0] : null) {
							case PVar(n):
								binderName = n;							
							default:
						};
						var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
							case EBlock(ss):
								ss;							
							default:
								[cl.body];							
						};
						for (bs  in  bodyStmts) switch (bs.def) {
							case EBinary(Match, leftAlias, rightAlias):
								switch (leftAlias.def) {
									case EVar(an):
										if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;									
									default:
								};							
							case EMatch(patAl, rightAl2):
								switch (patAl) {
									case PVar(an2):
										if (isHeadAccessOf(rightAl2, listExpr)) aliasFromHead = an2;									
									default:
								};							
							case EIf(cond, _thenBr, _elseBr):
								condExpr = cond;							
							default:
						};					
					default:
				};			
			default:
		};
		if (listExpr == null || condExpr == null) return node;
		var pred:ElixirAST = null;
		if (aliasFromHead != null) {
			pred = replaceVarInExpr(condExpr, aliasFromHead, binderName);
		} else {
			var varsUsed = collectVars(condExpr);
			varsUsed.remove(binderName);
			if (varsUsed.exists("id")) varsUsed.remove("id");
			var candidates = [for (k  in  varsUsed.keys()) k];
			if (candidates.length == 1) {
				pred = replaceVarInExpr(condExpr, candidates[0], binderName);
			} else {
				pred = condExpr;
			};
		};
		if (ElixirASTPrinter.print(pred, 0) == ElixirASTPrinter.print(condExpr, 0)) {
			switch (condExpr.def) {
				case EBinary(Equal, l, r):
					switch (l.def) {
						case EField(obj, fieldName):
							switch (obj.def) {
								case EVar(_):
									pred = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldName)), r));								
								default:
							};						
						default:
					};
					switch (r.def) {
						case EField(obj2, fieldName2):
							switch (obj2.def) {
								case EVar(_):
									pred = makeAST(EBinary(Equal, l, makeAST(EField(makeAST(EVar(binderName)), fieldName2))));								
								default:
							};						
						default:
					};				
				default:
			};
		};
		var adjustedBinder = safeBinder(binderName);
		pred = replaceVarInExpr(pred, binderName, adjustedBinder);
		pred = replaceVarInExpr(pred, "_" + adjustedBinder, adjustedBinder);
		pred = normalizePredicateToBinder(pred, adjustedBinder);
		var fnNode = makeAST(EFn([{ args : [PVar(adjustedBinder)], guard : null, body : pred }]));
		var newCall = makeAST(ERemoteCall(makeAST(EVar("Enum")), "find", [listExpr, fnNode]));
		makeASTWithMeta(newCall.def, node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length >= 2) {
							var lastIsNil = @:ast(switch (stmts[stmts.length - 1].def) {
	case ENil:
		true;	
	default:
		false;	
}) {
								var ` = stmts[stmts.length - 1].def;
								if (enumIndex ` == 36) {
									{
										true;
									};
								} else {
									false;
								};
							};
							if (! lastIsNil) {
								return node;
							};
							var eachStmt = null;
							{
								var ` = 0;
								var ` = stmts.length - 1;
								while (` < `) {
									var i = ` ++;
									@:ast(switch (stmts[i].def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachStmt = stmts[i];	
	case EMatch(_, rhs):
		switch (rhs.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
				eachStmt = rhs;			
			default:
		};	
	case EBinary(Match, _, rhs2):
		switch (rhs2.def) {
			case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
				eachStmt = rhs2;			
			default:
		};	
	default:
}) {
										var ` = stmts[i].def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var rhs = `;
													{
														@:ast(switch (rhs.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachStmt = rhs;	
	default:
}) {
															var ` = rhs.def;
															if (enumIndex ` == 24) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var mod = `;
																	var func = `;
																	var args = `;
																	if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																		var ` = mod.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																					true;
																				} else {
																					false;
																				};
																			};
																		} else {
																			false;
																		};
																	} && args.length == 2) {
																		eachStmt = rhs;
																	} else {};
																};
															} else {};
														};
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
														var ` = mod.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var name = `;
																if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																	true;
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													} && args.length == 2) {
														eachStmt = stmts[i];
													} else {};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var rhs2 = `;
														{
															@:ast(switch (rhs2.def) {
	case ERemoteCall(mod, func, args) if (isEnumEach(mod, func, args) && args.length == 2):
		eachStmt = rhs2;	
	default:
}) {
																var ` = rhs2.def;
																if (enumIndex ` == 24) {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var func = `;
																		var args = `;
																		if (@:ast(switch (mod.def) {
	case EVar(name) if ((name == "Enum") && func == "each" && args != null && args.length == 2):
		true;	
	default:
		false;	
}) {
																			var ` = mod.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var name = `;
																					if ((name == "Enum") && func == "each" && args != null && args.length == 2) {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		} && args.length == 2) {
																			eachStmt = rhs2;
																		} else {};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
								};
							};
							if (eachStmt == null) {
								return node;
							};
							var listExpr = null;
							var binderName = "_elem";
							var condExpr = null;
							var aliasFromHead = null;
							@:ast(switch (eachStmt.def) {
	case ERemoteCall(_m, _f, args):
		listExpr = args[0];
		switch (args[1].def) {
			case EFn(clauses) if (clauses.length == 1):
				var cl = clauses[0];
				switch (cl.args.length > 0 ? cl.args[0] : null) {
					case PVar(n):
						binderName = n;					
					default:
				};
				var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
					case EBlock(ss):
						ss;					
					default:
						[cl.body];					
				};
				for (bs  in  bodyStmts) switch (bs.def) {
					case EBinary(Match, leftAlias, rightAlias):
						switch (leftAlias.def) {
							case EVar(an):
								if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;							
							default:
						};					
					case EMatch(patAl, rightAl2):
						switch (patAl) {
							case PVar(an2):
								if (isHeadAccessOf(rightAl2, listExpr)) aliasFromHead = an2;							
							default:
						};					
					case EIf(cond, _thenBr, _elseBr):
						condExpr = cond;					
					default:
				};			
			default:
		};	
	default:
}) {
								var ` = eachStmt.def;
								if (enumIndex ` == 24) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var _m = `;
										var _f = `;
										var args = `;
										{
											listExpr = args[0];
											@:ast(switch (args[1].def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				binderName = n;			
			default:
		};
		var bodyStmts:Array<ElixirAST> = switch (cl.body.def) {
			case EBlock(ss):
				ss;			
			default:
				[cl.body];			
		};
		for (bs  in  bodyStmts) switch (bs.def) {
			case EBinary(Match, leftAlias, rightAlias):
				switch (leftAlias.def) {
					case EVar(an):
						if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;					
					default:
				};			
			case EMatch(patAl, rightAl2):
				switch (patAl) {
					case PVar(an2):
						if (isHeadAccessOf(rightAl2, listExpr)) aliasFromHead = an2;					
					default:
				};			
			case EIf(cond, _thenBr, _elseBr):
				condExpr = cond;			
			default:
		};	
	default:
}) {
												var ` = args[1].def;
												if (enumIndex ` == 42) {
													var ` = `[0];
													{
														var clauses = `;
														if (clauses.length == 1) {
															var cl = clauses[0];
															@:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		binderName = n;	
	default:
}) {
																var ` = if (cl.args.length > 0) {
																	cl.args[0];
																} else {
																	null;
																};
																if (` == null) {} else if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var n = `;
																		{
																			binderName = n;
																		};
																	};
																} else {};
															};
															var bodyStmts = @:ast(switch (cl.body.def) {
	case EBlock(ss):
		ss;	
	default:
		[cl.body];	
}) {
																var ` = cl.body.def;
																if (enumIndex ` == 53) {
																	var ` = `[0];
																	{
																		var ss = `;
																		{
																			ss;
																		};
																	};
																} else {
																	[cl.body];
																};
															};
															{
																var ` = 0;
																while (` < bodyStmts.length) {
																	var bs = bodyStmts[`];
																	++ `;
																	@:ast(switch (bs.def) {
	case EBinary(Match, leftAlias, rightAlias):
		switch (leftAlias.def) {
			case EVar(an):
				if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;			
			default:
		};	
	case EMatch(patAl, rightAl2):
		switch (patAl) {
			case PVar(an2):
				if (isHeadAccessOf(rightAl2, listExpr)) aliasFromHead = an2;			
			default:
		};	
	case EIf(cond, _thenBr, _elseBr):
		condExpr = cond;	
	default:
}) {
																		var ` = bs.def;
																		switch (enumIndex `) {
																			case 8: {
																				var ` = `[0];
																				var ` = `[1];
																				{
																					var patAl = `;
																					var rightAl2 = `;
																					{
																						@:ast(switch (patAl) {
	case PVar(an2):
		if (isHeadAccessOf(rightAl2, listExpr)) aliasFromHead = an2;	
	default:
}) if (enumIndex patAl == 0) {
																							var ` = patAl[0];
																							{
																								var an2 = `;
																								{
																									if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAl2, listExpr)) {
																										aliasFromHead = an2;
																									};
																								};
																							};
																						} else {};
																					};
																				};
																			};
																			case 10: {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				{
																					var cond = `;
																					var _thenBr = `;
																					var _elseBr = `;
																					{
																						condExpr = cond;
																					};
																				};
																			};
																			case 26: {
																				var ` = `[0];
																				var ` = `[1];
																				var ` = `[2];
																				if (enumIndex ` == 27) {
																					{
																						var leftAlias = `;
																						var rightAlias = `;
																						{
																							@:ast(switch (leftAlias.def) {
	case EVar(an):
		if (isHeadAccessOf(rightAlias, listExpr)) aliasFromHead = an;	
	default:
}) {
																								var ` = leftAlias.def;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var an = `;
																										{
																											if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.isHeadAccessOf(rightAlias, listExpr)) {
																												aliasFromHead = an;
																											};
																										};
																									};
																								} else {};
																							};
																						};
																					};
																				} else {};
																			};
																			default: {}
																		};
																	};
																};
															};
														} else {};
													};
												} else {};
											};
										};
									};
								} else {};
							};
							if (listExpr == null || condExpr == null) {
								return node;
							};
							var pred = null;
							if (aliasFromHead != null) {
								pred = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(condExpr, aliasFromHead, binderName);
							} else {
								var varsUsed = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.collectVars(condExpr);
								varsUsed.remove(binderName);
								if (varsUsed.exists("id")) {
									varsUsed.remove("id");
								};
								var candidates = {
									var ` = [];
									for (k in varsUsed.keys()) {
										`.push(k);
									};
									`;
								};
								if (candidates.length == 1) {
									pred = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(condExpr, candidates[0], binderName);
								} else {
									pred = condExpr;
								};
							};
							if (reflaxe.elixir.ast.ElixirASTPrinter.print(pred, 0) == reflaxe.elixir.ast.ElixirASTPrinter.print(condExpr, 0)) {
								@:ast(switch (condExpr.def) {
	case EBinary(Equal, l, r):
		switch (l.def) {
			case EField(obj, fieldName):
				switch (obj.def) {
					case EVar(_):
						pred = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldName)), r));					
					default:
				};			
			default:
		};
		switch (r.def) {
			case EField(obj2, fieldName2):
				switch (obj2.def) {
					case EVar(_):
						pred = makeAST(EBinary(Equal, l, makeAST(EField(makeAST(EVar(binderName)), fieldName2))));					
					default:
				};			
			default:
		};	
	default:
}) {
									var ` = condExpr.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 6) {
											{
												var l = `;
												var r = `;
												{
													@:ast(switch (l.def) {
	case EField(obj, fieldName):
		switch (obj.def) {
			case EVar(_):
				pred = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldName)), r));			
			default:
		};	
	default:
}) {
														var ` = l.def;
														if (enumIndex ` == 28) {
															var ` = `[0];
															var ` = `[1];
															{
																var obj = `;
																var fieldName = `;
																{
																	@:ast(switch (obj.def) {
	case EVar(_):
		pred = makeAST(EBinary(Equal, makeAST(EField(makeAST(EVar(binderName)), fieldName)), r));	
	default:
}) {
																		var ` = obj.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				pred = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderName), metadata : {}, pos : pos};
																						}, fieldName), metadata : {}, pos : pos};
																					}, r), metadata : {}, pos : pos};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
													@:ast(switch (r.def) {
	case EField(obj2, fieldName2):
		switch (obj2.def) {
			case EVar(_):
				pred = makeAST(EBinary(Equal, l, makeAST(EField(makeAST(EVar(binderName)), fieldName2))));			
			default:
		};	
	default:
}) {
														var ` = r.def;
														if (enumIndex ` == 28) {
															var ` = `[0];
															var ` = `[1];
															{
																var obj2 = `;
																var fieldName2 = `;
																{
																	@:ast(switch (obj2.def) {
	case EVar(_):
		pred = makeAST(EBinary(Equal, l, makeAST(EField(makeAST(EVar(binderName)), fieldName2))));	
	default:
}) {
																		var ` = obj2.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				pred = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, l, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EField({
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binderName), metadata : {}, pos : pos};
																						}, fieldName2), metadata : {}, pos : pos};
																					}), metadata : {}, pos : pos};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
											};
										} else {};
									} else {};
								};
							};
							var adjustedBinder = if ((binderName != null && binderName.length > 0 && binderName.charAt(0) == "_")) {
								binderName.substr(1, null);
							} else {
								binderName;
							};
							pred = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(pred, binderName, adjustedBinder);
							pred = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.replaceVarInExpr(pred, "_" + adjustedBinder, adjustedBinder);
							pred = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.normalizePredicateToBinder(pred, adjustedBinder);
							var fnNode = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(adjustedBinder)], guard : null, body : pred}]), metadata : {}, pos : pos};
							};
							var newCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
								}, "find", [listExpr, fnNode]), metadata : {}, pos : pos};
							};
							{def : newCall.def, metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function collectVars(node:reflaxe.elixir.ast.ElixirAST) {
		var used = {
			{};
			new haxe.ds.StringMap();
		};
		var visit = [null];
		visit[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(name):
		if (name != null && name.length > 0) {
			var c = name.charAt(0);
			if (c == c.toLowerCase()) used.set(name, true);
		};	
	case EField(target, _):
		visit(target);	
	case EBinary(_, l, r):
		visit(l);
		visit(r);	
	case EUnary(_, e):
		visit(e);	
	case ECall(t, _, args):
		if (t != null) visit(t);
		for (a  in  args) visit(a);	
	case ERemoteCall(t2, _, args2):
		visit(t2);
		for (a2  in  args2) visit(a2);	
	case EIf(c, t, el):
		visit(c);
		visit(t);
		if (el != null) visit(el);	
	case EBlock(ss):
		for (s  in  ss) visit(s);	
	case ECase(expr, clauses):
		visit(expr);
		for (cl  in  clauses) visit(cl.body);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								visit[0](expr);
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										visit[0](cl.body);
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var el = `;
							{
								visit[0](c);
								visit[0](t);
								if (el != null) {
									visit[0](el);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t = `;
							var args = `;
							{
								if (t != null) {
									visit[0](t);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										visit[0](a);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var t2 = `;
							var args2 = `;
							{
								visit[0](t2);
								{
									var ` = 0;
									while (` < args2.length) {
										var a2 = args2[`];
										++ `;
										visit[0](a2);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								visit[0](l);
								visit[0](r);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var e = `;
							{
								visit[0](e);
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							{
								visit[0](target);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (name != null && name.length > 0) {
									var c = name.charAt(0);
									if (c == c.toLowerCase()) {
										{
											used.set(name, true);
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var s = ss[`];
										++ `;
										visit[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		visit[0](node);
		return used;
	}

	static function normalizePredicateToBinder(node:reflaxe.elixir.ast.ElixirAST, binder:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EField(target, field):
		switch (target.def) {
			case EVar(name) if (name != binder):
				makeASTWithMeta(EField(makeAST(EVar(binder)), field), n.metadata, n.pos);			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 28) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var field = `;
						{
							@:ast(switch (target.def) {
	case EVar(name) if (name != binder):
		makeASTWithMeta(EField(makeAST(EVar(binder)), field), n.metadata, n.pos);	
	default:
		n;	
}) {
								var ` = target.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var name = `;
										if (name != binder) {
											{def : reflaxe.elixir.ast.ElixirASTDef.EField({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
											}, field), metadata : n.metadata, pos : n.pos};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function bodyUsesVar(body:reflaxe.elixir.ast.ElixirAST, name:String) {
		var used = [false];
		var visit = [null];
		visit[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (used[0] || n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(nm) if (nm == name):
		used = true;	
	case EField(target, _):
		visit(target);	
	case EBlock(sts):
		for (s  in  sts) visit(s);	
	case EIf(c, t, e):
		visit(c);
		visit(t);
		if (e != null) visit(e);	
	case EBinary(_, l, r):
		visit(l);
		visit(r);	
	case EUnary(_, e1):
		visit(e1);	
	case ECall(tgt, _, args):
		if (tgt != null) visit(tgt);
		for (a  in  args) visit(a);	
	case ERemoteCall(tgt2, _, args2):
		visit(tgt2);
		for (a  in  args2) visit(a);	
	case ETuple(els):
		for (el  in  els) visit(el);	
	case EMap(pairs):
		for (p  in  pairs) {
			visit(p.key);
			visit(p.value);
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								visit[0](c);
								visit[0](t);
								if (e != null) {
									visit[0](e);
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var els = `;
							{
								{
									var ` = 0;
									while (` < els.length) {
										var el = els[`];
										++ `;
										visit[0](el);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										visit[0](p.key);
										visit[0](p.value);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt = `;
							var args = `;
							{
								if (tgt != null) {
									visit[0](tgt);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										visit[0](a);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt2 = `;
							var args2 = `;
							{
								visit[0](tgt2);
								{
									var ` = 0;
									while (` < args2.length) {
										var a = args2[`];
										++ `;
										visit[0](a);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var l = `;
							var r = `;
							{
								visit[0](l);
								visit[0](r);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var e1 = `;
							{
								visit[0](e1);
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							{
								visit[0](target);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var nm = `;
							if (nm == name) {
								used[0] = true;
							} else {};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var sts = `;
							{
								{
									var ` = 0;
									while (` < sts.length) {
										var s = sts[`];
										++ `;
										visit[0](s);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		visit[0](body);
		return used[0];
	}

	public static function mapSetRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall(target, func, args) if (func == "set" && args != null && args.length == 2):
		switch (target.def) {
			case EVar(name):
				var keyExpr = args[0];
				var atomKey:Null<ElixirAST> = switch (keyExpr.def) {
					case EString(s):
						makeAST(EAtom(s));					
					default:
						null;					
				};
				var finalKey = atomKey != null ? atomKey : keyExpr;
				var putCall = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(name)), finalKey, args[1]]));
				makeAST(EMatch(PVar(name), putCall));			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null && func == "set" && args != null && args.length == 2):
		switch (target.def) {
			case EVar(name):
				var keyExpr = args[0];
				var atomKey:Null<ElixirAST> = switch (keyExpr.def) {
					case EString(s):
						makeAST(EAtom(s));					
					default:
						null;					
				};
				var finalKey = atomKey != null ? atomKey : keyExpr;
				var putCall = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(name)), finalKey, args[1]]));
				makeAST(EMatch(PVar(name), putCall));			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							if (target != null && func == "set" && args != null && args.length == 2) {
								@:ast(switch (target.def) {
	case EVar(name):
		var keyExpr = args[0];
		var atomKey:Null<ElixirAST> = switch (keyExpr.def) {
			case EString(s):
				makeAST(EAtom(s));			
			default:
				null;			
		};
		var finalKey = atomKey != null ? atomKey : keyExpr;
		var putCall = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(name)), finalKey, args[1]]));
		makeAST(EMatch(PVar(name), putCall));	
	default:
		n;	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												var keyExpr = args[0];
												var atomKey = @:ast(switch (keyExpr.def) {
	case EString(s):
		makeAST(EAtom(s));	
	default:
		null;	
}) {
													var ` = keyExpr.def;
													if (enumIndex ` == 32) {
														var ` = `[0];
														{
															var s = `;
															{
																{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																};
															};
														};
													} else {
														null;
													};
												};
												var finalKey = if (atomKey != null) {
													atomKey;
												} else {
													keyExpr;
												};
												var putCall = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
													}, "put", [{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
													}, finalKey, args[1]]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), putCall), metadata : {}, pos : pos};
												};
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							if (func == "set" && args != null && args.length == 2) {
								@:ast(switch (target.def) {
	case EVar(name):
		var keyExpr = args[0];
		var atomKey:Null<ElixirAST> = switch (keyExpr.def) {
			case EString(s):
				makeAST(EAtom(s));			
			default:
				null;			
		};
		var finalKey = atomKey != null ? atomKey : keyExpr;
		var putCall = makeAST(ERemoteCall(makeAST(EVar("Map")), "put", [makeAST(EVar(name)), finalKey, args[1]]));
		makeAST(EMatch(PVar(name), putCall));	
	default:
		n;	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												var keyExpr = args[0];
												var atomKey = @:ast(switch (keyExpr.def) {
	case EString(s):
		makeAST(EAtom(s));	
	default:
		null;	
}) {
													var ` = keyExpr.def;
													if (enumIndex ` == 32) {
														var ` = `[0];
														{
															var s = `;
															{
																{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																};
															};
														};
													} else {
														null;
													};
												};
												var finalKey = if (atomKey != null) {
													atomKey;
												} else {
													keyExpr;
												};
												var putCall = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
													}, "put", [{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
													}, finalKey, args[1]]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), putCall), metadata : {}, pos : pos};
												};
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function mapBuilderCollapsePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(statements):
		var collapsed = tryCollapseMapBuilder(statements, node.metadata, node.pos);
		if (collapsed != null) {
			return collapsed;
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var statements = `;
						{
							var collapsed = reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.tryCollapseMapBuilder(statements, node.metadata, node.pos);
							if (collapsed != null) {
								return collapsed;
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function tryCollapseMapBuilder(statements:Array<reflaxe.elixir.ast.ElixirAST>, metadata:reflaxe.elixir.ast.ElixirMetadata, pos:haxe.macro.Position) {
		if (statements == null || statements.length < 2) {
			return null;
		};
		var tempName = null;
		var pairs = null;
		@:ast(switch (statements[0].def) {
	case EMatch(pattern, initExpr):
		switch pattern {
			case PVar(name):
				tempName = name;			
			default:
				return null;			
		};
		switch (initExpr.def) {
			case EMap(initialPairs):
				pairs = initialPairs.copy();			
			default:
				return null;			
		};	
	default:
		return null;	
}) {
			var ` = statements[0].def;
			if (enumIndex ` == 8) {
				var ` = `[0];
				var ` = `[1];
				{
					var pattern = `;
					var initExpr = `;
					{
						@:ast(switch pattern {
	case PVar(name):
		tempName = name;	
	default:
		return null;	
}) if (enumIndex pattern == 0) {
							var ` = pattern[0];
							{
								var name = `;
								{
									tempName = name;
								};
							};
						} else {
							return null;
						};
						@:ast(switch (initExpr.def) {
	case EMap(initialPairs):
		pairs = initialPairs.copy();	
	default:
		return null;	
}) {
							var ` = initExpr.def;
							if (enumIndex ` == 17) {
								var ` = `[0];
								{
									var initialPairs = `;
									{
										pairs = initialPairs.copy();
									};
								};
							} else {
								return null;
							};
						};
					};
				};
			} else {
				return null;
			};
		};
		if (tempName == null) {
			return null;
		};
		{
			var ` = 1;
			var ` = statements.length - 1;
			while (` < `) {
				var i = ` ++;
				var stmt = statements[i];
				@:ast(switch (stmt.def) {
	case EBinary(Match, leftExpr, rightExpr):
		switch (leftExpr.def) {
			case EVar(varName) if (varName == tempName):
			default:
				return null;			
		};
		switch (rightExpr.def) {
			case ERemoteCall(moduleExpr, funcName, args) if (funcName == "put" && args.length == 3):
				switch (moduleExpr.def) {
					case EVar(moduleName) if (moduleName == "Map"):
					default:
						return null;					
				};
				switch (args[0].def) {
					case EVar(varName) if (varName == tempName):
					default:
						return null;					
				};
				pairs.push({ key : args[1], value : args[2] });			
			default:
				return null;			
		};	
	default:
		return null;	
}) {
					var ` = stmt.def;
					if (enumIndex ` == 26) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var leftExpr = `;
								var rightExpr = `;
								{
									@:ast(switch (leftExpr.def) {
	case EVar(varName) if (varName == tempName):
	default:
		return null;	
}) {
										var ` = leftExpr.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var varName = `;
												if (varName == tempName) {} else {
													return null;
												};
											};
										} else {
											return null;
										};
									};
									@:ast(switch (rightExpr.def) {
	case ERemoteCall(moduleExpr, funcName, args) if (funcName == "put" && args.length == 3):
		switch (moduleExpr.def) {
			case EVar(moduleName) if (moduleName == "Map"):
			default:
				return null;			
		};
		switch (args[0].def) {
			case EVar(varName) if (varName == tempName):
			default:
				return null;			
		};
		pairs.push({ key : args[1], value : args[2] });	
	default:
		return null;	
}) {
										var ` = rightExpr.def;
										if (enumIndex ` == 24) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var moduleExpr = `;
												var funcName = `;
												var args = `;
												if (funcName == "put" && args.length == 3) {
													@:ast(switch (moduleExpr.def) {
	case EVar(moduleName) if (moduleName == "Map"):
	default:
		return null;	
}) {
														var ` = moduleExpr.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var moduleName = `;
																if (moduleName == "Map") {} else {
																	return null;
																};
															};
														} else {
															return null;
														};
													};
													@:ast(switch (args[0].def) {
	case EVar(varName) if (varName == tempName):
	default:
		return null;	
}) {
														var ` = args[0].def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var varName = `;
																if (varName == tempName) {} else {
																	return null;
																};
															};
														} else {
															return null;
														};
													};
													pairs.push({key : args[1], value : args[2]});
												} else {
													return null;
												};
											};
										} else {
											return null;
										};
									};
								};
							};
						} else {
							return null;
						};
					} else {
						return null;
					};
				};
			};
		};
		@:ast(switch (statements[statements.length - 1].def) {
	case EVar(varName) if (varName == tempName):
		return makeASTWithMeta(EMap(pairs), metadata, pos);	
	default:
		return null;	
}) {
			var ` = statements[statements.length - 1].def;
			if (enumIndex ` == 38) {
				var ` = `[0];
				{
					var varName = `;
					if (varName == tempName) {
						return {def : reflaxe.elixir.ast.ElixirASTDef.EMap(pairs), metadata : metadata, pos : pos};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
	}

	public static function listEffectLiftingPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EList(items):
		var needsLifting = false;
		for (item  in  items) {
			if (hasComplexExpression(item)) {
				needsLifting = true;
				break;
			};
		};
		if (needsLifting) {
			var statements:Array<ElixirAST> = [];
			var newItems:Array<ElixirAST> = [];
			var tempCounter = 0;
			for (item  in  items) {
				if (hasComplexExpression(item)) {
					var tempVar = "tmp_list_" + tempCounter++;
					statements.push(makeAST(EMatch(PVar(tempVar), item)));
					newItems.push(makeAST(EVar(tempVar)));
				} else {
					newItems.push(item);
				};
			};
			statements.push(makeAST(EList(newItems)));
			return makeAST(EBlock(statements));
		};
		return node;	
	default:
		return node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 15) {
					var ` = `[0];
					{
						var items = `;
						{
							var needsLifting = false;
							{
								var ` = 0;
								while (` < items.length) {
									var item = items[`];
									++ `;
									if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.hasComplexExpression(item)) {
										needsLifting = true;
										break;
									};
								};
							};
							if (needsLifting) {
								var statements = [];
								var newItems = [];
								var tempCounter = 0;
								{
									var ` = 0;
									while (` < items.length) {
										var item = items[`];
										++ `;
										if (reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.hasComplexExpression(item)) {
											var tempVar = "tmp_list_" + tempCounter ++;
											statements.push({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tempVar), item), metadata : {}, pos : pos};
											});
											newItems.push({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVar), metadata : {}, pos : pos};
											});
										} else {
											newItems.push(item);
										};
									};
								};
								statements.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EList(newItems), metadata : {}, pos : pos};
								});
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : pos};
								};
							};
							return node;
						};
					};
				} else {
					return node;
				};
			};
		});
	}

	static function hasComplexExpression(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case ECall(_, _, _):
		true;	
	case ERemoteCall(_, _, _):
		true;	
	case EBinary(_, _, _):
		true;	
	case EUnary(_, _):
		true;	
	case ECase(_, _):
		true;	
	case EIf(_, _, _):
		true;	
	case ECond(_):
		true;	
	case EBlock(_):
		true;	
	default:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 7: {
					var ` = `[0];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 53: {
					var ` = `[0];
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	public static function mapIteratorTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return null;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall(module, funcName, args):
		switch (module.def) {
			case EVar(modName) if (modName == "Enum" && funcName == "reduce_while" && args != null && args.length >= 3):
				var loopFunc = args[2];
				function hasMapIteratorCalls(ast:ElixirAST):Bool {
					if (ast == null) return false;
					var found = false;
					var depth = 0;
					function scan(n:ElixirAST):Void {
						if (n == null || n.def == null) return;
						depth++;
						switch (n.def) {
							case EField(obj, field):
								if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
									found = true;
								};
								scan(obj);							
							case ECall(target, funcName, args):
								if (target != null) {
									switch (target.def) {
										case EField(_, field):
											if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
												found = true;
											};										
										default:
									};
									scan(target);
								};
								if (args != null) for (arg  in  args) scan(arg);							
							case EFn(clauses):
								for (c  in  clauses) if (c.body != null) scan(c.body);							
							case EBlock(exprs):
								for (e  in  exprs) scan(e);							
							case EIf(cond, t, e):
								scan(cond);
								scan(t);
								if (e != null) scan(e);							
							case EMatch(_, value):
								scan(value);							
							case ETuple(items):
								for (item  in  items) scan(item);							
							default:
						};
						depth--;
					};
					scan(ast);
					return found;
				};
				if (hasMapIteratorCalls(loopFunc)) {
					var mapVar = switch (args[1].def) {
						case ETuple([mapExpr, _]) | ETuple([mapExpr]):
							switch (mapExpr.def) {
								case EVar(name):
									name;								
								default:
									null;								
							};						
						case EVar(name):
							name;						
						default:
							null;						
					};
					if (mapVar == null) mapVar = "colors";
					var keyVarName = "name";
					var valueVarName = "hex";
					var loopBody:ElixirAST = null;
					switch (loopFunc.def) {
						case EFn(clauses) if (clauses.length > 0):
							var body = clauses[0].body;
							switch (body.def) {
								case EIf(_, thenBranch, _):
									var allExprs = ASTUtils.flattenBlocks(thenBranch);
									for (expr  in  allExprs) {
										switch (expr.def) {
											case EMatch(PVar(varName), rhs):
												if (ASTUtils.containsIteratorPattern(rhs)) {
													switch (rhs.def) {
														case EField(_, "key"):
															keyVarName = varName;														
														case EField(_, "value"):
															valueVarName = varName;														
														default:
															var fieldChain = [];
															var current = rhs;
															while (current != null) {
																switch (current.def) {
																	case EField(obj, field):
																		fieldChain.push(field);
																		current = obj;																	
																	case ECall(func, _, _):
																		current = func;																	
																	default:
																		current = null;																	
																};
															};
															if (fieldChain.length > 0) {
																if (fieldChain[0] == "key") {
																	keyVarName = varName;
																} else if (fieldChain[0] == "value") {
																	valueVarName = varName;
																};
															};														
													};
												};											
											default:
										};
									};
									var cleanExprs = ASTUtils.filterIteratorAssignments(allExprs);
									var bodyExprs = [];
									for (expr  in  cleanExprs) {
										switch (expr.def) {
											case ETuple(elements):
												var isCont = elements.length > 0 && switch (elements[0].def) {
													case EAtom(atom):
														atom == "cont";													
													default:
														false;													
												};
												if (!isCont) bodyExprs.push(expr);											
											default:
												bodyExprs.push(expr);											
										};
									};
									loopBody = if (bodyExprs.length == 1) bodyExprs[0] else if (bodyExprs.length > 1) makeAST(EBlock(bodyExprs)) else null;								
								default:
							};						
						default:
					};
					if (loopBody != null) {
						var transformedAST = makeAST(ERemoteCall(makeAST(EVar("Enum")), "each", [makeAST(EVar(mapVar)), makeAST(EFn([{ args : [PTuple([PVar(keyVarName), PVar(valueVarName)])], guard : null, body : loopBody }]))]));
						return transformedAST;
					};
				};			
			default:
		};	
	default:
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							@:ast(switch (module.def) {
	case EVar(modName) if (modName == "Enum" && funcName == "reduce_while" && args != null && args.length >= 3):
		var loopFunc = args[2];
		function hasMapIteratorCalls(ast:ElixirAST):Bool {
			if (ast == null) return false;
			var found = false;
			var depth = 0;
			function scan(n:ElixirAST):Void {
				if (n == null || n.def == null) return;
				depth++;
				switch (n.def) {
					case EField(obj, field):
						if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
							found = true;
						};
						scan(obj);					
					case ECall(target, funcName, args):
						if (target != null) {
							switch (target.def) {
								case EField(_, field):
									if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
										found = true;
									};								
								default:
							};
							scan(target);
						};
						if (args != null) for (arg  in  args) scan(arg);					
					case EFn(clauses):
						for (c  in  clauses) if (c.body != null) scan(c.body);					
					case EBlock(exprs):
						for (e  in  exprs) scan(e);					
					case EIf(cond, t, e):
						scan(cond);
						scan(t);
						if (e != null) scan(e);					
					case EMatch(_, value):
						scan(value);					
					case ETuple(items):
						for (item  in  items) scan(item);					
					default:
				};
				depth--;
			};
			scan(ast);
			return found;
		};
		if (hasMapIteratorCalls(loopFunc)) {
			var mapVar = switch (args[1].def) {
				case ETuple([mapExpr, _]) | ETuple([mapExpr]):
					switch (mapExpr.def) {
						case EVar(name):
							name;						
						default:
							null;						
					};				
				case EVar(name):
					name;				
				default:
					null;				
			};
			if (mapVar == null) mapVar = "colors";
			var keyVarName = "name";
			var valueVarName = "hex";
			var loopBody:ElixirAST = null;
			switch (loopFunc.def) {
				case EFn(clauses) if (clauses.length > 0):
					var body = clauses[0].body;
					switch (body.def) {
						case EIf(_, thenBranch, _):
							var allExprs = ASTUtils.flattenBlocks(thenBranch);
							for (expr  in  allExprs) {
								switch (expr.def) {
									case EMatch(PVar(varName), rhs):
										if (ASTUtils.containsIteratorPattern(rhs)) {
											switch (rhs.def) {
												case EField(_, "key"):
													keyVarName = varName;												
												case EField(_, "value"):
													valueVarName = varName;												
												default:
													var fieldChain = [];
													var current = rhs;
													while (current != null) {
														switch (current.def) {
															case EField(obj, field):
																fieldChain.push(field);
																current = obj;															
															case ECall(func, _, _):
																current = func;															
															default:
																current = null;															
														};
													};
													if (fieldChain.length > 0) {
														if (fieldChain[0] == "key") {
															keyVarName = varName;
														} else if (fieldChain[0] == "value") {
															valueVarName = varName;
														};
													};												
											};
										};									
									default:
								};
							};
							var cleanExprs = ASTUtils.filterIteratorAssignments(allExprs);
							var bodyExprs = [];
							for (expr  in  cleanExprs) {
								switch (expr.def) {
									case ETuple(elements):
										var isCont = elements.length > 0 && switch (elements[0].def) {
											case EAtom(atom):
												atom == "cont";											
											default:
												false;											
										};
										if (!isCont) bodyExprs.push(expr);									
									default:
										bodyExprs.push(expr);									
								};
							};
							loopBody = if (bodyExprs.length == 1) bodyExprs[0] else if (bodyExprs.length > 1) makeAST(EBlock(bodyExprs)) else null;						
						default:
					};				
				default:
			};
			if (loopBody != null) {
				var transformedAST = makeAST(ERemoteCall(makeAST(EVar("Enum")), "each", [makeAST(EVar(mapVar)), makeAST(EFn([{ args : [PTuple([PVar(keyVarName), PVar(valueVarName)])], guard : null, body : loopBody }]))]));
				return transformedAST;
			};
		};	
	default:
}) {
								var ` = module.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var modName = `;
										if (modName == "Enum" && funcName == "reduce_while" && args != null && args.length >= 3) {
											var loopFunc = args[2];
											var hasMapIteratorCalls = function(ast:reflaxe.elixir.ast.ElixirAST) {
												if (ast == null) {
													return false;
												};
												var found = [false];
												var depth = [0];
												var scan = [null];
												scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
													if (n == null || n.def == null) {
														return;
													};
													depth[0] ++;
													@:ast(switch (n.def) {
	case EField(obj, field):
		if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
			found = true;
		};
		scan(obj);	
	case ECall(target, funcName, args):
		if (target != null) {
			switch (target.def) {
				case EField(_, field):
					if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
						found = true;
					};				
				default:
			};
			scan(target);
		};
		if (args != null) for (arg  in  args) scan(arg);	
	case EFn(clauses):
		for (c  in  clauses) if (c.body != null) scan(c.body);	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case EIf(cond, t, e):
		scan(cond);
		scan(t);
		if (e != null) scan(e);	
	case EMatch(_, value):
		scan(value);	
	case ETuple(items):
		for (item  in  items) scan(item);	
	default:
}) {
														var ` = n.def;
														switch (enumIndex `) {
															case 8: {
																var ` = `[0];
																var ` = `[1];
																{
																	var value = `;
																	{
																		scan[0](value);
																	};
																};
															};
															case 10: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var cond = `;
																	var t = `;
																	var e = `;
																	{
																		scan[0](cond);
																		scan[0](t);
																		if (e != null) {
																			scan[0](e);
																		};
																	};
																};
															};
															case 16: {
																var ` = `[0];
																{
																	var items = `;
																	{
																		{
																			var ` = 0;
																			while (` < items.length) {
																				var item = items[`];
																				++ `;
																				scan[0](item);
																			};
																		};
																	};
																};
															};
															case 22: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var target = `;
																	var funcName = `;
																	var args = `;
																	{
																		if (target != null) {
																			@:ast(switch (target.def) {
	case EField(_, field):
		if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
			found = true;
		};	
	default:
}) {
																				var ` = target.def;
																				if (enumIndex ` == 28) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var field = `;
																						{
																							if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
																								found[0] = true;
																							};
																						};
																					};
																				} else {};
																			};
																			scan[0](target);
																		};
																		if (args != null) {
																			{
																				var ` = 0;
																				while (` < args.length) {
																					var arg = args[`];
																					++ `;
																					scan[0](arg);
																				};
																			};
																		};
																	};
																};
															};
															case 28: {
																var ` = `[0];
																var ` = `[1];
																{
																	var obj = `;
																	var field = `;
																	{
																		if (field == "key_value_iterator" || field == "has_next" || field == "next" || field == "key" || field == "value") {
																			found[0] = true;
																		};
																		scan[0](obj);
																	};
																};
															};
															case 42: {
																var ` = `[0];
																{
																	var clauses = `;
																	{
																		{
																			var ` = 0;
																			while (` < clauses.length) {
																				var c = clauses[`];
																				++ `;
																				if (c.body != null) {
																					scan[0](c.body);
																				};
																			};
																		};
																	};
																};
															};
															case 53: {
																var ` = `[0];
																{
																	var exprs = `;
																	{
																		{
																			var ` = 0;
																			while (` < exprs.length) {
																				var e = exprs[`];
																				++ `;
																				scan[0](e);
																			};
																		};
																	};
																};
															};
															default: {}
														};
													};
													depth[0] --;
												};
												scan[0](ast);
												return found[0];
											};
											if (hasMapIteratorCalls(loopFunc)) {
												var mapVar = @:ast(switch (args[1].def) {
	case ETuple([mapExpr, _]) | ETuple([mapExpr]):
		switch (mapExpr.def) {
			case EVar(name):
				name;			
			default:
				null;			
		};	
	case EVar(name):
		name;	
	default:
		null;	
}) {
													var ` = args[1].def;
													switch (enumIndex `) {
														case 16: {
															var ` = `[0];
															switch (`.length) {
																case 1: {
																	var ` = `[0];
																	{
																		var mapExpr = `;
																		{
																			@:ast(switch (mapExpr.def) {
	case EVar(name):
		name;	
	default:
		null;	
}) {
																				var ` = mapExpr.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var name = `;
																						{
																							name;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		};
																	};
																};
																case 2: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var mapExpr = `;
																		{
																			@:ast(switch (mapExpr.def) {
	case EVar(name):
		name;	
	default:
		null;	
}) {
																				var ` = mapExpr.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var name = `;
																						{
																							name;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		};
																	};
																};
																default: {
																	null;
																}
															};
														};
														case 38: {
															var ` = `[0];
															{
																var name = `;
																{
																	name;
																};
															};
														};
														default: {
															null;
														}
													};
												};
												if (mapVar == null) {
													mapVar = "colors";
												};
												var keyVarName = "name";
												var valueVarName = "hex";
												var loopBody = null;
												@:ast(switch (loopFunc.def) {
	case EFn(clauses) if (clauses.length > 0):
		var body = clauses[0].body;
		switch (body.def) {
			case EIf(_, thenBranch, _):
				var allExprs = ASTUtils.flattenBlocks(thenBranch);
				for (expr  in  allExprs) {
					switch (expr.def) {
						case EMatch(PVar(varName), rhs):
							if (ASTUtils.containsIteratorPattern(rhs)) {
								switch (rhs.def) {
									case EField(_, "key"):
										keyVarName = varName;									
									case EField(_, "value"):
										valueVarName = varName;									
									default:
										var fieldChain = [];
										var current = rhs;
										while (current != null) {
											switch (current.def) {
												case EField(obj, field):
													fieldChain.push(field);
													current = obj;												
												case ECall(func, _, _):
													current = func;												
												default:
													current = null;												
											};
										};
										if (fieldChain.length > 0) {
											if (fieldChain[0] == "key") {
												keyVarName = varName;
											} else if (fieldChain[0] == "value") {
												valueVarName = varName;
											};
										};									
								};
							};						
						default:
					};
				};
				var cleanExprs = ASTUtils.filterIteratorAssignments(allExprs);
				var bodyExprs = [];
				for (expr  in  cleanExprs) {
					switch (expr.def) {
						case ETuple(elements):
							var isCont = elements.length > 0 && switch (elements[0].def) {
								case EAtom(atom):
									atom == "cont";								
								default:
									false;								
							};
							if (!isCont) bodyExprs.push(expr);						
						default:
							bodyExprs.push(expr);						
					};
				};
				loopBody = if (bodyExprs.length == 1) bodyExprs[0] else if (bodyExprs.length > 1) makeAST(EBlock(bodyExprs)) else null;			
			default:
		};	
	default:
}) {
													var ` = loopFunc.def;
													if (enumIndex ` == 42) {
														var ` = `[0];
														{
															var clauses = `;
															if (clauses.length > 0) {
																var body = clauses[0].body;
																@:ast(switch (body.def) {
	case EIf(_, thenBranch, _):
		var allExprs = ASTUtils.flattenBlocks(thenBranch);
		for (expr  in  allExprs) {
			switch (expr.def) {
				case EMatch(PVar(varName), rhs):
					if (ASTUtils.containsIteratorPattern(rhs)) {
						switch (rhs.def) {
							case EField(_, "key"):
								keyVarName = varName;							
							case EField(_, "value"):
								valueVarName = varName;							
							default:
								var fieldChain = [];
								var current = rhs;
								while (current != null) {
									switch (current.def) {
										case EField(obj, field):
											fieldChain.push(field);
											current = obj;										
										case ECall(func, _, _):
											current = func;										
										default:
											current = null;										
									};
								};
								if (fieldChain.length > 0) {
									if (fieldChain[0] == "key") {
										keyVarName = varName;
									} else if (fieldChain[0] == "value") {
										valueVarName = varName;
									};
								};							
						};
					};				
				default:
			};
		};
		var cleanExprs = ASTUtils.filterIteratorAssignments(allExprs);
		var bodyExprs = [];
		for (expr  in  cleanExprs) {
			switch (expr.def) {
				case ETuple(elements):
					var isCont = elements.length > 0 && switch (elements[0].def) {
						case EAtom(atom):
							atom == "cont";						
						default:
							false;						
					};
					if (!isCont) bodyExprs.push(expr);				
				default:
					bodyExprs.push(expr);				
			};
		};
		loopBody = if (bodyExprs.length == 1) bodyExprs[0] else if (bodyExprs.length > 1) makeAST(EBlock(bodyExprs)) else null;	
	default:
}) {
																	var ` = body.def;
																	if (enumIndex ` == 10) {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var thenBranch = `;
																			{
																				var allExprs = reflaxe.elixir.ast.ASTUtils.flattenBlocks(thenBranch);
																				{
																					var ` = 0;
																					while (` < allExprs.length) {
																						var expr = allExprs[`];
																						++ `;
																						@:ast(switch (expr.def) {
	case EMatch(PVar(varName), rhs):
		if (ASTUtils.containsIteratorPattern(rhs)) {
			switch (rhs.def) {
				case EField(_, "key"):
					keyVarName = varName;				
				case EField(_, "value"):
					valueVarName = varName;				
				default:
					var fieldChain = [];
					var current = rhs;
					while (current != null) {
						switch (current.def) {
							case EField(obj, field):
								fieldChain.push(field);
								current = obj;							
							case ECall(func, _, _):
								current = func;							
							default:
								current = null;							
						};
					};
					if (fieldChain.length > 0) {
						if (fieldChain[0] == "key") {
							keyVarName = varName;
						} else if (fieldChain[0] == "value") {
							valueVarName = varName;
						};
					};				
			};
		};	
	default:
}) {
																							var ` = expr.def;
																							if (enumIndex ` == 8) {
																								var ` = `[0];
																								var ` = `[1];
																								if (enumIndex ` == 0) {
																									var ` = `[0];
																									{
																										var varName = `;
																										var rhs = `;
																										{
																											if (reflaxe.elixir.ast.ASTUtils.containsIteratorPattern(rhs)) {
																												@:ast(switch (rhs.def) {
	case EField(_, "key"):
		keyVarName = varName;	
	case EField(_, "value"):
		valueVarName = varName;	
	default:
		var fieldChain = [];
		var current = rhs;
		while (current != null) {
			switch (current.def) {
				case EField(obj, field):
					fieldChain.push(field);
					current = obj;				
				case ECall(func, _, _):
					current = func;				
				default:
					current = null;				
			};
		};
		if (fieldChain.length > 0) {
			if (fieldChain[0] == "key") {
				keyVarName = varName;
			} else if (fieldChain[0] == "value") {
				valueVarName = varName;
			};
		};	
}) {
																													var ` = rhs.def;
																													if (enumIndex ` == 28) {
																														var ` = `[0];
																														var ` = `[1];
																														switch (`) {
																															case "key": {
																																{
																																	keyVarName = varName;
																																};
																															};
																															case "value": {
																																{
																																	valueVarName = varName;
																																};
																															};
																															default: {
																																var fieldChain = [];
																																var current = rhs;
																																while (current != null) {
																																	@:ast(switch (current.def) {
	case EField(obj, field):
		fieldChain.push(field);
		current = obj;	
	case ECall(func, _, _):
		current = func;	
	default:
		current = null;	
}) {
																																		var ` = current.def;
																																		switch (enumIndex `) {
																																			case 22: {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				{
																																					var func = `;
																																					{
																																						current = func;
																																					};
																																				};
																																			};
																																			case 28: {
																																				var ` = `[0];
																																				var ` = `[1];
																																				{
																																					var obj = `;
																																					var field = `;
																																					{
																																						fieldChain.push(field);
																																						current = obj;
																																					};
																																				};
																																			};
																																			default: {
																																				current = null;
																																			}
																																		};
																																	};
																																};
																																if (fieldChain.length > 0) {
																																	if (fieldChain[0] == "key") {
																																		keyVarName = varName;
																																	} else {
																																		if (fieldChain[0] == "value") {
																																			valueVarName = varName;
																																		};
																																	};
																																};
																															}
																														};
																													} else {
																														var fieldChain = [];
																														var current = rhs;
																														while (current != null) {
																															@:ast(switch (current.def) {
	case EField(obj, field):
		fieldChain.push(field);
		current = obj;	
	case ECall(func, _, _):
		current = func;	
	default:
		current = null;	
}) {
																																var ` = current.def;
																																switch (enumIndex `) {
																																	case 22: {
																																		var ` = `[0];
																																		var ` = `[1];
																																		var ` = `[2];
																																		{
																																			var func = `;
																																			{
																																				current = func;
																																			};
																																		};
																																	};
																																	case 28: {
																																		var ` = `[0];
																																		var ` = `[1];
																																		{
																																			var obj = `;
																																			var field = `;
																																			{
																																				fieldChain.push(field);
																																				current = obj;
																																			};
																																		};
																																	};
																																	default: {
																																		current = null;
																																	}
																																};
																															};
																														};
																														if (fieldChain.length > 0) {
																															if (fieldChain[0] == "key") {
																																keyVarName = varName;
																															} else {
																																if (fieldChain[0] == "value") {
																																	valueVarName = varName;
																																};
																															};
																														};
																													};
																												};
																											};
																										};
																									};
																								} else {};
																							} else {};
																						};
																					};
																				};
																				var cleanExprs = reflaxe.elixir.ast.ASTUtils.filterIteratorAssignments(allExprs);
																				var bodyExprs = [];
																				{
																					var ` = 0;
																					while (` < cleanExprs.length) {
																						var expr = cleanExprs[`];
																						++ `;
																						@:ast(switch (expr.def) {
	case ETuple(elements):
		var isCont = elements.length > 0 && switch (elements[0].def) {
			case EAtom(atom):
				atom == "cont";			
			default:
				false;			
		};
		if (!isCont) bodyExprs.push(expr);	
	default:
		bodyExprs.push(expr);	
}) {
																							var ` = expr.def;
																							if (enumIndex ` == 16) {
																								var ` = `[0];
																								{
																									var elements = `;
																									{
																										var isCont = elements.length > 0 && @:ast(switch (elements[0].def) {
	case EAtom(atom):
		atom == "cont";	
	default:
		false;	
}) {
																											var ` = elements[0].def;
																											if (enumIndex ` == 31) {
																												var ` = `[0];
																												{
																													var atom = `;
																													{
																														atom == "cont";
																													};
																												};
																											} else {
																												false;
																											};
																										};
																										if (! isCont) {
																											bodyExprs.push(expr);
																										};
																									};
																								};
																							} else {
																								bodyExprs.push(expr);
																							};
																						};
																					};
																				};
																				loopBody = if (bodyExprs.length == 1) {
																					bodyExprs[0];
																				} else {
																					if (bodyExprs.length > 1) {
																						{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(bodyExprs), metadata : {}, pos : pos};
																						};
																					} else {
																						null;
																					};
																				};
																			};
																		};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
												if (loopBody != null) {
													var transformedAST = {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
														}, "each", [{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mapVar), metadata : {}, pos : pos};
														}, {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PVar(keyVarName), reflaxe.elixir.ast.EPattern.PVar(valueVarName)])], guard : null, body : loopBody}]), metadata : {}, pos : pos};
														}]), metadata : {}, pos : pos};
													};
													return transformedAST;
												};
											};
										} else {};
									};
								} else {};
							};
						};
					};
				} else {};
			};
			return node;
		});
	}

	static function containsIteratorPatterns(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null || ast.def == null) {
			return false;
		};
		var hasKeyValueIterator = [false];
		var hasHasNext = [false];
		var hasNext = [false];
		var scan = [null];
		scan[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EField(obj, field):
		if (field == "key_value_iterator") {
			hasKeyValueIterator = true;
		} else if (field == "has_next") {
			hasHasNext = true;
		} else if (field == "next") {
			hasNext = true;
		};
		scan(obj);	
	case ECall(func, _, args):
		switch (func.def) {
			case EField(obj, field):
				if (field == "key_value_iterator" || field == "has_next" || field == "next") {
					if (field == "key_value_iterator") hasKeyValueIterator = true;
					if (field == "has_next") hasHasNext = true;
					if (field == "next") hasNext = true;
				};
				scan(obj);			
			default:
				scan(func);			
		};
		if (args != null) for (arg  in  args) scan(arg);	
	case EFn(clauses):
		for (clause  in  clauses) if (clause.body != null) scan(clause.body);	
	case EBlock(exprs):
		for (expr  in  exprs) scan(expr);	
	case EIf(cond, thenBranch, elseBranch):
		scan(cond);
		scan(thenBranch);
		if (elseBranch != null) scan(elseBranch);	
	case ETuple(elements):
		for (elem  in  elements) scan(elem);	
	case ERemoteCall(module, _, args):
		scan(module);
		if (args != null) for (arg  in  args) scan(arg);	
	case EVar(_), EAtom(_), EString(_):
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								scan[0](cond);
								scan[0](thenBranch);
								if (elseBranch != null) {
									scan[0](elseBranch);
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var elements = `;
							{
								{
									var ` = 0;
									while (` < elements.length) {
										var elem = elements[`];
										++ `;
										scan[0](elem);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var func = `;
							var args = `;
							{
								@:ast(switch (func.def) {
	case EField(obj, field):
		if (field == "key_value_iterator" || field == "has_next" || field == "next") {
			if (field == "key_value_iterator") hasKeyValueIterator = true;
			if (field == "has_next") hasHasNext = true;
			if (field == "next") hasNext = true;
		};
		scan(obj);	
	default:
		scan(func);	
}) {
									var ` = func.def;
									if (enumIndex ` == 28) {
										var ` = `[0];
										var ` = `[1];
										{
											var obj = `;
											var field = `;
											{
												if (field == "key_value_iterator" || field == "has_next" || field == "next") {
													if (field == "key_value_iterator") {
														hasKeyValueIterator[0] = true;
													};
													if (field == "has_next") {
														hasHasNext[0] = true;
													};
													if (field == "next") {
														hasNext[0] = true;
													};
												};
												scan[0](obj);
											};
										};
									} else {
										scan[0](func);
									};
								};
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											scan[0](arg);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var args = `;
							{
								scan[0](module);
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											scan[0](arg);
										};
									};
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var obj = `;
							var field = `;
							{
								if (field == "key_value_iterator") {
									hasKeyValueIterator[0] = true;
								} else {
									if (field == "has_next") {
										hasHasNext[0] = true;
									} else {
										if (field == "next") {
											hasNext[0] = true;
										};
									};
								};
								scan[0](obj);
							};
						};
					};
					case 31: {
						var ` = `[0];
						{};
					};
					case 32: {
						var ` = `[0];
						{};
					};
					case 38: {
						var ` = `[0];
						{};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										if (clause.body != null) {
											scan[0](clause.body);
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var expr = exprs[`];
										++ `;
										scan[0](expr);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](ast);
		var result = hasKeyValueIterator[0];
		return result;
	}
}