class reflaxe.elixir.ast.transformers.StdHaxeRuntimeOverrideTransforms {

	public static function transformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDefmodule(name, _):
		if (name == "ArrayIterator") arrayIteratorDef(n) else if (name == "PosException") posExceptionDef(n) else if (name == "StringTools") stringToolsDef(n) else if (name == "Log") logDef(n) else n;	
	case EModule(name, attrs, _):
		if (name == "ArrayIterator") {
			var blk = arrayIteratorBlock(n.metadata, n.pos);
			makeASTWithMeta(EModule(name, attrs, [blk]), n.metadata, n.pos);
		} else if (name == "PosException") {
			var blk2 = posExceptionBlock(n.metadata, n.pos);
			makeASTWithMeta(EModule(name, attrs, [blk2]), n.metadata, n.pos);
		} else if (name == "StringTools") {
			var blk3 = stringToolsBlock(n.metadata, n.pos);
			makeASTWithMeta(EModule(name, attrs, [blk3]), n.metadata, n.pos);
		} else if (name == "Log") {
			var blk4 = logBlock(n.metadata, n.pos);
			makeASTWithMeta(EModule(name, attrs, [blk4]), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							{
								if (name == "ArrayIterator") {
									var blk = {
										var meta = cast n.metadata;
										var pos = n.pos;
										var raw = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def has_next(struct), do: struct.current < length(struct.array)\n" + "  def next(struct), do: struct.array[struct.current + 1]\n"), metadata : {}, pos : pos};
										};
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
									};
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, [blk]), metadata : n.metadata, pos : n.pos};
								} else {
									if (name == "PosException") {
										var blk2 = {
											var meta = cast n.metadata;
											var pos = n.pos;
											var raw = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def to_string(struct), do: \"#{Kernel.to_string(struct.message)} in #{struct.posInfos.className}.#{struct.posInfos.methodName} at #{struct.posInfos.fileName}:#{struct.posInfos.lineNumber}\"\n"), metadata : {}, pos : pos};
											};
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
										};
										{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, [blk2]), metadata : n.metadata, pos : n.pos};
									} else {
										if (name == "StringTools") {
											var blk3 = {
												var meta = cast n.metadata;
												var pos = n.pos;
												var raw = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def is_space(s, pos), do: (:binary.at(s, pos) > 8 and :binary.at(s, pos) < 14) or :binary.at(s, pos) == 32\n" + "  def ltrim(s), do: String.trim_leading(s)\n" + "  def rtrim(s), do: String.trim_trailing(s)\n"), metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
											};
											{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, [blk3]), metadata : n.metadata, pos : n.pos};
										} else {
											if (name == "Log") {
												var blk4 = {
													var meta = cast n.metadata;
													var pos = n.pos;
													var raw = {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def format_output(v, infos) do\n" + "    str = inspect(v)\n" + "    if Kernel.is_nil(infos), do: str\n" + "    str\n" + "  end\n" + "  def trace(v, infos) do\n" + "    (\n\n            case infos do\n              nil -> IO.inspect(v)\n              infos ->\n                file = Map.get(infos, :fileName)\n                line = Map.get(infos, :lineNumber)\n                base = if file != nil and line != nil, do: \"#{file}:#{line}\", else: nil\n                class = Map.get(infos, :className)\n                method = Map.get(infos, :methodName)\n                label = cond do\n                  class != nil and method != nil and base != nil -> \"#{class}.#{method} - #{base}\"\n                  base != nil -> base\n                  true -> nil\n                end\n                if label != nil, do: IO.inspect(v, label: label), else: IO.inspect(v)\n            end\n            \n)\n" + "  end\n"), metadata : {}, pos : pos};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, [blk4]), metadata : n.metadata, pos : n.pos};
											} else {
												n;
											};
										};
									};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							{
								if (name == "ArrayIterator") {
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("ArrayIterator", {
										var meta = cast n.metadata;
										var pos = n.pos;
										var raw = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def has_next(struct), do: struct.current < length(struct.array)\n" + "  def next(struct), do: struct.array[struct.current + 1]\n"), metadata : {}, pos : pos};
										};
										{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
									}), metadata : n.metadata, pos : n.pos};
								} else {
									if (name == "PosException") {
										{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("PosException", {
											var meta = cast n.metadata;
											var pos = n.pos;
											var raw = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def to_string(struct), do: \"#{Kernel.to_string(struct.message)} in #{struct.posInfos.className}.#{struct.posInfos.methodName} at #{struct.posInfos.fileName}:#{struct.posInfos.lineNumber}\"\n"), metadata : {}, pos : pos};
											};
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
										}), metadata : n.metadata, pos : n.pos};
									} else {
										if (name == "StringTools") {
											{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("StringTools", {
												var meta = cast n.metadata;
												var pos = n.pos;
												var raw = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def is_space(s, pos), do: (:binary.at(s, pos) > 8 and :binary.at(s, pos) < 14) or :binary.at(s, pos) == 32\n" + "  def ltrim(s), do: String.trim_leading(s)\n" + "  def rtrim(s), do: String.trim_trailing(s)\n"), metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
											}), metadata : n.metadata, pos : n.pos};
										} else {
											if (name == "Log") {
												{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("Log", {
													var meta = cast n.metadata;
													var pos = n.pos;
													var raw = {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def format_output(v, infos) do\n" + "    str = inspect(v)\n" + "    if Kernel.is_nil(infos), do: str\n" + "    str\n" + "  end\n" + "  def trace(v, infos) do\n" + "    (\n\n            case infos do\n              nil -> IO.inspect(v)\n              infos ->\n                file = Map.get(infos, :fileName)\n                line = Map.get(infos, :lineNumber)\n                base = if file != nil and line != nil, do: \"#{file}:#{line}\", else: nil\n                class = Map.get(infos, :className)\n                method = Map.get(infos, :methodName)\n                label = cond do\n                  class != nil and method != nil and base != nil -> \"#{class}.#{method} - #{base}\"\n                  base != nil -> base\n                  true -> nil\n                end\n                if label != nil, do: IO.inspect(v, label: label), else: IO.inspect(v)\n            end\n            \n)\n" + "  end\n"), metadata : {}, pos : pos};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
												}), metadata : n.metadata, pos : n.pos};
											} else {
												n;
											};
										};
									};
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static inline function logDef(orig:reflaxe.elixir.ast.ElixirAST) {
		return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("Log", {
			var meta = cast orig.metadata;
			var pos = orig.pos;
			var raw = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def format_output(v, infos) do\n" + "    str = inspect(v)\n" + "    if Kernel.is_nil(infos), do: str\n" + "    str\n" + "  end\n" + "  def trace(v, infos) do\n" + "    (\n\n            case infos do\n              nil -> IO.inspect(v)\n              infos ->\n                file = Map.get(infos, :fileName)\n                line = Map.get(infos, :lineNumber)\n                base = if file != nil and line != nil, do: \"#{file}:#{line}\", else: nil\n                class = Map.get(infos, :className)\n                method = Map.get(infos, :methodName)\n                label = cond do\n                  class != nil and method != nil and base != nil -> \"#{class}.#{method} - #{base}\"\n                  base != nil -> base\n                  true -> nil\n                end\n                if label != nil, do: IO.inspect(v, label: label), else: IO.inspect(v)\n            end\n            \n)\n" + "  end\n"), metadata : {}, pos : pos};
			};
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
		}), metadata : orig.metadata, pos : orig.pos};
	}

	static inline function logBlock(meta:Dynamic, pos:haxe.macro.Position) {
		var raw = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def format_output(v, infos) do\n" + "    str = inspect(v)\n" + "    if Kernel.is_nil(infos), do: str\n" + "    str\n" + "  end\n" + "  def trace(v, infos) do\n" + "    (\n\n            case infos do\n              nil -> IO.inspect(v)\n              infos ->\n                file = Map.get(infos, :fileName)\n                line = Map.get(infos, :lineNumber)\n                base = if file != nil and line != nil, do: \"#{file}:#{line}\", else: nil\n                class = Map.get(infos, :className)\n                method = Map.get(infos, :methodName)\n                label = cond do\n                  class != nil and method != nil and base != nil -> \"#{class}.#{method} - #{base}\"\n                  base != nil -> base\n                  true -> nil\n                end\n                if label != nil, do: IO.inspect(v, label: label), else: IO.inspect(v)\n            end\n            \n)\n" + "  end\n"), metadata : {}, pos : pos};
		};
		return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
	}

	static inline function arrayIteratorDef(orig:reflaxe.elixir.ast.ElixirAST) {
		return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("ArrayIterator", {
			var meta = cast orig.metadata;
			var pos = orig.pos;
			var raw = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def has_next(struct), do: struct.current < length(struct.array)\n" + "  def next(struct), do: struct.array[struct.current + 1]\n"), metadata : {}, pos : pos};
			};
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
		}), metadata : orig.metadata, pos : orig.pos};
	}

	static inline function arrayIteratorBlock(meta:Dynamic, pos:haxe.macro.Position) {
		var raw = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def has_next(struct), do: struct.current < length(struct.array)\n" + "  def next(struct), do: struct.array[struct.current + 1]\n"), metadata : {}, pos : pos};
		};
		return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
	}

	static inline function posExceptionDef(orig:reflaxe.elixir.ast.ElixirAST) {
		return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("PosException", {
			var meta = cast orig.metadata;
			var pos = orig.pos;
			var raw = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def to_string(struct), do: \"#{Kernel.to_string(struct.message)} in #{struct.posInfos.className}.#{struct.posInfos.methodName} at #{struct.posInfos.fileName}:#{struct.posInfos.lineNumber}\"\n"), metadata : {}, pos : pos};
			};
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
		}), metadata : orig.metadata, pos : orig.pos};
	}

	static inline function posExceptionBlock(meta:Dynamic, pos:haxe.macro.Position) {
		var raw = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def to_string(struct), do: \"#{Kernel.to_string(struct.message)} in #{struct.posInfos.className}.#{struct.posInfos.methodName} at #{struct.posInfos.fileName}:#{struct.posInfos.lineNumber}\"\n"), metadata : {}, pos : pos};
		};
		return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
	}

	static inline function stringToolsDef(orig:reflaxe.elixir.ast.ElixirAST) {
		return {def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule("StringTools", {
			var meta = cast orig.metadata;
			var pos = orig.pos;
			var raw = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def is_space(s, pos), do: (:binary.at(s, pos) > 8 and :binary.at(s, pos) < 14) or :binary.at(s, pos) == 32\n" + "  def ltrim(s), do: String.trim_leading(s)\n" + "  def rtrim(s), do: String.trim_trailing(s)\n"), metadata : {}, pos : pos};
			};
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
		}), metadata : orig.metadata, pos : orig.pos};
	}

	static inline function stringToolsBlock(meta:Dynamic, pos:haxe.macro.Position) {
		var raw = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("  def is_space(s, pos), do: (:binary.at(s, pos) > 8 and :binary.at(s, pos) < 14) or :binary.at(s, pos) == 32\n" + "  def ltrim(s), do: String.trim_leading(s)\n" + "  def rtrim(s), do: String.trim_trailing(s)\n"), metadata : {}, pos : pos};
		};
		return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock([raw]), metadata : cast meta, pos : pos};
	}
}