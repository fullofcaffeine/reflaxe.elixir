class reflaxe.elixir.ast.transformers.ReduceInputValuesCleanupTransforms {

	static inline function reducerUsesPresenceMetas(fnNode:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (fnNode.def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		var binderName:Null<String> = switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				n;			
			default:
				null;			
		};
		if (binderName == null) return false;
		var uses = false;
		function walk(n:ElixirAST):Void {
			if (uses || n == null) return;
			switch (n.def) {
				case EField({ def : EVar(v) }, field) if (v == binderName && field == "metas"):
					uses = true;				
				case EAccess({ def : EField({ def : EVar(v2) }, f2) }, _) if (v2 == binderName && f2 == "metas"):
					uses = true;				
				case EBlock(ss):
					for (s  in  ss) walk(s);				
				case EDo(ss2):
					for (s  in  ss2) walk(s);				
				case EIf(c, t, e):
					walk(c);
					walk(t);
					if (e != null) walk(e);				
				case EBinary(_, l, r):
					walk(l);
					walk(r);				
				case EMatch(_, rhs):
					walk(rhs);				
				case ECall(t, _, args):
					if (t != null) walk(t);
					for (a  in  args) walk(a);				
				case ERemoteCall(t2, _, args2):
					walk(t2);
					for (a2  in  args2) walk(a2);				
				case EKeywordList(pairs):
					for (p  in  pairs) walk(p.value);				
				case EMap(pairs2):
					for (p2  in  pairs2) {
						walk(p2.key);
						walk(p2.value);
					};				
				case EList(els):
					for (el  in  els) walk(el);				
				case ETuple(els2):
					for (el2  in  els2) walk(el2);				
				default:
			};
		};
		walk(cl.body);
		uses;	
	default:
		false;	
}) {
			var ` = fnNode.def;
			if (enumIndex ` == 42) {
				var ` = `[0];
				{
					var clauses = `;
					if (clauses.length == 1) {
						var cl = clauses[0];
						var binderName = @:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
							var ` = if (cl.args.length > 0) {
								cl.args[0];
							} else {
								null;
							};
							if (` == null) {
								null;
							} else if (enumIndex ` == 0) {
								var ` = `[0];
								{
									var n = `;
									{
										n;
									};
								};
							} else {
								null;
							};
						};
						if (binderName == null) {
							return false;
						};
						var uses = [false];
						var walk = [null];
						walk[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
							if (uses[0] || n == null) {
								return;
							};
							@:ast(switch (n.def) {
	case EField({ def : EVar(v) }, field) if (v == binderName && field == "metas"):
		uses = true;	
	case EAccess({ def : EField({ def : EVar(v2) }, f2) }, _) if (v2 == binderName && f2 == "metas"):
		uses = true;	
	case EBlock(ss):
		for (s  in  ss) walk(s);	
	case EDo(ss2):
		for (s  in  ss2) walk(s);	
	case EIf(c, t, e):
		walk(c);
		walk(t);
		if (e != null) walk(e);	
	case EBinary(_, l, r):
		walk(l);
		walk(r);	
	case EMatch(_, rhs):
		walk(rhs);	
	case ECall(t, _, args):
		if (t != null) walk(t);
		for (a  in  args) walk(a);	
	case ERemoteCall(t2, _, args2):
		walk(t2);
		for (a2  in  args2) walk(a2);	
	case EKeywordList(pairs):
		for (p  in  pairs) walk(p.value);	
	case EMap(pairs2):
		for (p2  in  pairs2) {
			walk(p2.key);
			walk(p2.value);
		};	
	case EList(els):
		for (el  in  els) walk(el);	
	case ETuple(els2):
		for (el2  in  els2) walk(el2);	
	default:
}) {
								var ` = n.def;
								switch (enumIndex `) {
									case 8: {
										var ` = `[0];
										var ` = `[1];
										{
											var rhs = `;
											{
												walk[0](rhs);
											};
										};
									};
									case 10: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var c = `;
											var t = `;
											var e = `;
											{
												walk[0](c);
												walk[0](t);
												if (e != null) {
													walk[0](e);
												};
											};
										};
									};
									case 15: {
										var ` = `[0];
										{
											var els = `;
											{
												{
													var ` = 0;
													while (` < els.length) {
														var el = els[`];
														++ `;
														walk[0](el);
													};
												};
											};
										};
									};
									case 16: {
										var ` = `[0];
										{
											var els2 = `;
											{
												{
													var ` = 0;
													while (` < els2.length) {
														var el2 = els2[`];
														++ `;
														walk[0](el2);
													};
												};
											};
										};
									};
									case 17: {
										var ` = `[0];
										{
											var pairs2 = `;
											{
												{
													var ` = 0;
													while (` < pairs2.length) {
														var p2 = pairs2[`];
														++ `;
														walk[0](p2.key);
														walk[0](p2.value);
													};
												};
											};
										};
									};
									case 20: {
										var ` = `[0];
										{
											var pairs = `;
											{
												{
													var ` = 0;
													while (` < pairs.length) {
														var p = pairs[`];
														++ `;
														walk[0](p.value);
													};
												};
											};
										};
									};
									case 22: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var t = `;
											var args = `;
											{
												if (t != null) {
													walk[0](t);
												};
												{
													var ` = 0;
													while (` < args.length) {
														var a = args[`];
														++ `;
														walk[0](a);
													};
												};
											};
										};
									};
									case 24: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var t2 = `;
											var args2 = `;
											{
												walk[0](t2);
												{
													var ` = 0;
													while (` < args2.length) {
														var a2 = args2[`];
														++ `;
														walk[0](a2);
													};
												};
											};
										};
									};
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var l = `;
											var r = `;
											{
												walk[0](l);
												walk[0](r);
											};
										};
									};
									case 28: {
										var ` = `[0];
										var ` = `[1];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var v = `;
													var field = `;
													if (v == binderName && field == "metas") {
														uses[0] = true;
													} else {};
												};
											} else {};
										};
									};
									case 29: {
										var ` = `[0];
										var ` = `[1];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											if (enumIndex ` == 28) {
												var ` = `[0];
												var ` = `[1];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v2 = `;
															var f2 = `;
															if (v2 == binderName && f2 == "metas") {
																uses[0] = true;
															} else {};
														};
													} else {};
												};
											} else {};
										};
									};
									case 53: {
										var ` = `[0];
										{
											var ss = `;
											{
												{
													var ` = 0;
													while (` < ss.length) {
														var s = ss[`];
														++ `;
														walk[0](s);
													};
												};
											};
										};
									};
									case 55: {
										var ` = `[0];
										{
											var ss2 = `;
											{
												{
													var ` = 0;
													while (` < ss2.length) {
														var s = ss2[`];
														++ `;
														walk[0](s);
													};
												};
											};
										};
									};
									default: {}
								};
							};
						};
						walk[0](cl.body);
						uses[0];
					} else {
						false;
					};
				};
			} else {
				false;
			};
		};
	}

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(enumMod) }, "reduce", args) if (enumMod == "Enum" && args != null && args.length == 3):
		switch (args[0].def) {
			case ERemoteCall({ def : EVar(mapMod) }, "values", [coll]) if (mapMod == "Map"):
				var usesMetas = reducerUsesPresenceMetas(args[2]);
				if (!usesMetas) makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "reduce", [coll, args[1], args[2]]), n.metadata, n.pos) else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							if (` == "reduce") {
								{
									var enumMod = `;
									var args = `;
									if (enumMod == "Enum" && args != null && args.length == 3) {
										@:ast(switch (args[0].def) {
	case ERemoteCall({ def : EVar(mapMod) }, "values", [coll]) if (mapMod == "Map"):
		var usesMetas = reducerUsesPresenceMetas(args[2]);
		if (!usesMetas) makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "reduce", [coll, args[1], args[2]]), n.metadata, n.pos) else n;	
	default:
		n;	
}) {
											var ` = args[0].def;
											if (enumIndex ` == 24) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														if (` == "values") {
															if (`.length == 1) {
																var ` = `[0];
																{
																	var coll = `;
																	var mapMod = `;
																	if (mapMod == "Map") {
																		var usesMetas = @:ast(switch (fnNode.def) {
	case EFn(clauses) if (clauses.length == 1):
		var cl = clauses[0];
		var binderName:Null<String> = switch (cl.args.length > 0 ? cl.args[0] : null) {
			case PVar(n):
				n;			
			default:
				null;			
		};
		if (binderName == null) return false;
		var uses = false;
		function walk(n:ElixirAST):Void {
			if (uses || n == null) return;
			switch (n.def) {
				case EField({ def : EVar(v) }, field) if (v == binderName && field == "metas"):
					uses = true;				
				case EAccess({ def : EField({ def : EVar(v2) }, f2) }, _) if (v2 == binderName && f2 == "metas"):
					uses = true;				
				case EBlock(ss):
					for (s  in  ss) walk(s);				
				case EDo(ss2):
					for (s  in  ss2) walk(s);				
				case EIf(c, t, e):
					walk(c);
					walk(t);
					if (e != null) walk(e);				
				case EBinary(_, l, r):
					walk(l);
					walk(r);				
				case EMatch(_, rhs):
					walk(rhs);				
				case ECall(t, _, args):
					if (t != null) walk(t);
					for (a  in  args) walk(a);				
				case ERemoteCall(t2, _, args2):
					walk(t2);
					for (a2  in  args2) walk(a2);				
				case EKeywordList(pairs):
					for (p  in  pairs) walk(p.value);				
				case EMap(pairs2):
					for (p2  in  pairs2) {
						walk(p2.key);
						walk(p2.value);
					};				
				case EList(els):
					for (el  in  els) walk(el);				
				case ETuple(els2):
					for (el2  in  els2) walk(el2);				
				default:
			};
		};
		walk(cl.body);
		uses;	
	default:
		false;	
}) {
																			var ` = args[2].def;
																			if (enumIndex ` == 42) {
																				var ` = `[0];
																				{
																					var clauses = `;
																					if (clauses.length == 1) {
																						var cl = clauses[0];
																						var binderName = @:ast(switch (cl.args.length > 0 ? cl.args[0] : null) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
																							var ` = if (cl.args.length > 0) {
																								cl.args[0];
																							} else {
																								null;
																							};
																							if (` == null) {
																								null;
																							} else if (enumIndex ` == 0) {
																								var ` = `[0];
																								{
																									var n = `;
																									{
																										n;
																									};
																								};
																							} else {
																								null;
																							};
																						};
																						if (binderName == null) {
																							false;
																						} else {
																							var uses = [false];
																							var walk = [null];
																							walk[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																								if (uses[0] || n == null) {
																									return;
																								};
																								@:ast(switch (n.def) {
	case EField({ def : EVar(v) }, field) if (v == binderName && field == "metas"):
		uses = true;	
	case EAccess({ def : EField({ def : EVar(v2) }, f2) }, _) if (v2 == binderName && f2 == "metas"):
		uses = true;	
	case EBlock(ss):
		for (s  in  ss) walk(s);	
	case EDo(ss2):
		for (s  in  ss2) walk(s);	
	case EIf(c, t, e):
		walk(c);
		walk(t);
		if (e != null) walk(e);	
	case EBinary(_, l, r):
		walk(l);
		walk(r);	
	case EMatch(_, rhs):
		walk(rhs);	
	case ECall(t, _, args):
		if (t != null) walk(t);
		for (a  in  args) walk(a);	
	case ERemoteCall(t2, _, args2):
		walk(t2);
		for (a2  in  args2) walk(a2);	
	case EKeywordList(pairs):
		for (p  in  pairs) walk(p.value);	
	case EMap(pairs2):
		for (p2  in  pairs2) {
			walk(p2.key);
			walk(p2.value);
		};	
	case EList(els):
		for (el  in  els) walk(el);	
	case ETuple(els2):
		for (el2  in  els2) walk(el2);	
	default:
}) {
																									var ` = n.def;
																									switch (enumIndex `) {
																										case 8: {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var rhs = `;
																												{
																													walk[0](rhs);
																												};
																											};
																										};
																										case 10: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var c = `;
																												var t = `;
																												var e = `;
																												{
																													walk[0](c);
																													walk[0](t);
																													if (e != null) {
																														walk[0](e);
																													};
																												};
																											};
																										};
																										case 15: {
																											var ` = `[0];
																											{
																												var els = `;
																												{
																													{
																														var ` = 0;
																														while (` < els.length) {
																															var el = els[`];
																															++ `;
																															walk[0](el);
																														};
																													};
																												};
																											};
																										};
																										case 16: {
																											var ` = `[0];
																											{
																												var els2 = `;
																												{
																													{
																														var ` = 0;
																														while (` < els2.length) {
																															var el2 = els2[`];
																															++ `;
																															walk[0](el2);
																														};
																													};
																												};
																											};
																										};
																										case 17: {
																											var ` = `[0];
																											{
																												var pairs2 = `;
																												{
																													{
																														var ` = 0;
																														while (` < pairs2.length) {
																															var p2 = pairs2[`];
																															++ `;
																															walk[0](p2.key);
																															walk[0](p2.value);
																														};
																													};
																												};
																											};
																										};
																										case 20: {
																											var ` = `[0];
																											{
																												var pairs = `;
																												{
																													{
																														var ` = 0;
																														while (` < pairs.length) {
																															var p = pairs[`];
																															++ `;
																															walk[0](p.value);
																														};
																													};
																												};
																											};
																										};
																										case 22: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var t = `;
																												var args = `;
																												{
																													if (t != null) {
																														walk[0](t);
																													};
																													{
																														var ` = 0;
																														while (` < args.length) {
																															var a = args[`];
																															++ `;
																															walk[0](a);
																														};
																													};
																												};
																											};
																										};
																										case 24: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var t2 = `;
																												var args2 = `;
																												{
																													walk[0](t2);
																													{
																														var ` = 0;
																														while (` < args2.length) {
																															var a2 = args2[`];
																															++ `;
																															walk[0](a2);
																														};
																													};
																												};
																											};
																										};
																										case 26: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											{
																												var l = `;
																												var r = `;
																												{
																													walk[0](l);
																													walk[0](r);
																												};
																											};
																										};
																										case 28: {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 38) {
																													var ` = `[0];
																													{
																														var v = `;
																														var field = `;
																														if (v == binderName && field == "metas") {
																															uses[0] = true;
																														} else {};
																													};
																												} else {};
																											};
																										};
																										case 29: {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 28) {
																													var ` = `[0];
																													var ` = `[1];
																													{
																														var ` = `.def;
																														var ` = `.metadata;
																														var ` = `.pos;
																														if (enumIndex ` == 38) {
																															var ` = `[0];
																															{
																																var v2 = `;
																																var f2 = `;
																																if (v2 == binderName && f2 == "metas") {
																																	uses[0] = true;
																																} else {};
																															};
																														} else {};
																													};
																												} else {};
																											};
																										};
																										case 53: {
																											var ` = `[0];
																											{
																												var ss = `;
																												{
																													{
																														var ` = 0;
																														while (` < ss.length) {
																															var s = ss[`];
																															++ `;
																															walk[0](s);
																														};
																													};
																												};
																											};
																										};
																										case 55: {
																											var ` = `[0];
																											{
																												var ss2 = `;
																												{
																													{
																														var ` = 0;
																														while (` < ss2.length) {
																															var s = ss2[`];
																															++ `;
																															walk[0](s);
																														};
																													};
																												};
																											};
																										};
																										default: {}
																									};
																								};
																							};
																							walk[0](cl.body);
																							uses[0];
																						};
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		};
																		if (! usesMetas) {
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
																			}, "reduce", [coll, args[1], args[2]]), metadata : n.metadata, pos : n.pos};
																		} else {
																			n;
																		};
																	} else {
																		n;
																	};
																};
															} else {
																n;
															};
														} else {
															n;
														};
													} else {
														n;
													};
												};
											} else {
												n;
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						} else {
							n;
						};
					};
				} else {
					n;
				};
			};
		});
	}
}