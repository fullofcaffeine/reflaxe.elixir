class reflaxe.elixir.ast.transformers.EctoWhereWildcardAssignCleanupTransforms {

	static inline function isEctoWhereCall(e:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (e.def) {
	case ERemoteCall(mod, func, _):
		if (func != "where") return false;
		switch (mod.def) {
			case EVar(m) if (m == "Ecto.Query"):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = e.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var mod = `;
					var func = `;
					{
						if (func != "where") {
							return false;
						};
						@:ast(switch (mod.def) {
	case EVar(m) if (m == "Ecto.Query"):
		true;	
	default:
		false;	
}) {
							var ` = mod.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var m = `;
									if (m == "Ecto.Query") {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						};
					};
				};
			} else {
				false;
			};
		};
	}

	public static function transformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EIf(cond, thenBr, elseBr):
		var newThen = switch (thenBr.def) {
			case EMatch(_, rhs) if (isEctoWhereCall(rhs)):
				rhs;			
			case EBinary(Match, left, rhs2):
				var isWild = switch (left.def) {
					case EVar(v) if (v == "_"):
						true;					
					case EUnderscore:
						true;					
					default:
						false;					
				};
				(isWild && isEctoWhereCall(rhs2)) ? rhs2 : thenBr;			
			default:
				thenBr;			
		};
		if (newThen != thenBr) {
			makeASTWithMeta(EIf(cond, newThen, elseBr), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 10) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBr = `;
						var elseBr = `;
						{
							var newThen = @:ast(switch (thenBr.def) {
	case EMatch(_, rhs) if (isEctoWhereCall(rhs)):
		rhs;	
	case EBinary(Match, left, rhs2):
		var isWild = switch (left.def) {
			case EVar(v) if (v == "_"):
				true;			
			case EUnderscore:
				true;			
			default:
				false;			
		};
		(isWild && isEctoWhereCall(rhs2)) ? rhs2 : thenBr;	
	default:
		thenBr;	
}) {
								var ` = thenBr.def;
								switch (enumIndex `) {
									case 8: {
										var ` = `[0];
										var ` = `[1];
										{
											var rhs = `;
											if (@:ast(switch (e.def) {
	case ERemoteCall(mod, func, _):
		if (func != "where") return false;
		switch (mod.def) {
			case EVar(m) if (m == "Ecto.Query"):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
												var ` = rhs.def;
												if (enumIndex ` == 24) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var mod = `;
														var func = `;
														{
															if (func != "where") {
																false;
															} else {
																@:ast(switch (mod.def) {
	case EVar(m) if (m == "Ecto.Query"):
		true;	
	default:
		false;	
}) {
																	var ` = mod.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var m = `;
																			if (m == "Ecto.Query") {
																				true;
																			} else {
																				false;
																			};
																		};
																	} else {
																		false;
																	};
																};
															};
														};
													};
												} else {
													false;
												};
											}) {
												rhs;
											} else {
												thenBr;
											};
										};
									};
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 27) {
											{
												var left = `;
												var rhs2 = `;
												{
													var isWild = @:ast(switch (left.def) {
	case EVar(v) if (v == "_"):
		true;	
	case EUnderscore:
		true;	
	default:
		false;	
}) {
														var ` = left.def;
														switch (enumIndex `) {
															case 38: {
																var ` = `[0];
																{
																	var v = `;
																	if (v == "_") {
																		true;
																	} else {
																		false;
																	};
																};
															};
															case 40: {
																{
																	true;
																};
															};
															default: {
																false;
															}
														};
													};
													if ((isWild && @:ast(switch (e.def) {
	case ERemoteCall(mod, func, _):
		if (func != "where") return false;
		switch (mod.def) {
			case EVar(m) if (m == "Ecto.Query"):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
														var ` = rhs2.def;
														if (enumIndex ` == 24) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var mod = `;
																var func = `;
																{
																	if (func != "where") {
																		false;
																	} else {
																		@:ast(switch (mod.def) {
	case EVar(m) if (m == "Ecto.Query"):
		true;	
	default:
		false;	
}) {
																			var ` = mod.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var m = `;
																					if (m == "Ecto.Query") {
																						true;
																					} else {
																						false;
																					};
																				};
																			} else {
																				false;
																			};
																		};
																	};
																};
															};
														} else {
															false;
														};
													})) {
														rhs2;
													} else {
														thenBr;
													};
												};
											};
										} else {
											thenBr;
										};
									};
									default: {
										thenBr;
									}
								};
							};
							if (newThen != thenBr) {
								{def : reflaxe.elixir.ast.ElixirASTDef.EIf(cond, newThen, elseBr), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}
}