class reflaxe.elixir.ast.ElixirASTPatterns {

	public static function detectPattern(node:reflaxe.elixir.ast.ElixirAST) {
		if (reflaxe.elixir.ast.ElixirASTPatterns.isMapIterationPattern(node)) {
			var data = reflaxe.elixir.ast.ElixirASTPatterns.extractMapIterationData(node);
			if (data != null) {
				return {type : reflaxe.elixir.ast.ASTPatternType.MapKeyValueIteration(data.mapVar, "key", "value"), node : node, metadata : cast data};
			};
		};
		if (reflaxe.elixir.ast.ElixirASTPatterns.isYCombinatorPattern(node)) {
			return {type : reflaxe.elixir.ast.ASTPatternType.YCombinatorLoop("_", "acc"), node : node, metadata : null};
		};
		return null;
	}

	static function isYCombinatorPattern(node:reflaxe.elixir.ast.ElixirAST) {
		if (node == null || node.def == null) {
			return false;
		};
		return @:ast(switch (node.def) {
	case ERemoteCall(module, funcName, args):
		var isReduceWhile = switch (module.def) {
			case EVar(modName):
				modName == "Enum" && funcName == "reduce_while";			
			default:
				false;			
		};
		if (!isReduceWhile || args == null || args.length < 1) return false;
		return switch (args[0].def) {
			case ERemoteCall(streamModule, streamFunc, _):
				switch (streamModule.def) {
					case EVar(modName):
						modName == "Stream" && streamFunc == "iterate";					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = node.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var module = `;
					var funcName = `;
					var args = `;
					{
						var isReduceWhile = @:ast(switch (module.def) {
	case EVar(modName):
		modName == "Enum" && funcName == "reduce_while";	
	default:
		false;	
}) {
							var ` = module.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var modName = `;
									{
										modName == "Enum" && funcName == "reduce_while";
									};
								};
							} else {
								false;
							};
						};
						if (! isReduceWhile || args == null || args.length < 1) {
							return false;
						};
						return @:ast(switch (args[0].def) {
	case ERemoteCall(streamModule, streamFunc, _):
		switch (streamModule.def) {
			case EVar(modName):
				modName == "Stream" && streamFunc == "iterate";			
			default:
				false;			
		};	
	default:
		false;	
}) {
							var ` = args[0].def;
							if (enumIndex ` == 24) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								{
									var streamModule = `;
									var streamFunc = `;
									{
										@:ast(switch (streamModule.def) {
	case EVar(modName):
		modName == "Stream" && streamFunc == "iterate";	
	default:
		false;	
}) {
											var ` = streamModule.def;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var modName = `;
													{
														modName == "Stream" && streamFunc == "iterate";
													};
												};
											} else {
												false;
											};
										};
									};
								};
							} else {
								false;
							};
						};
					};
				};
			} else {
				false;
			};
		};
	}

	public static function transformPattern(pattern:reflaxe.elixir.ast.PatternData) {
		return @:ast(switch (pattern.type) {
	case MapKeyValueIteration(mapVar, keyVar, valueVar):
		var loopBody = pattern.metadata != null ? pattern.metadata.loopBody : null;
		if (loopBody == null) {
			return makeAST(EString("# TODO: Transform Map iteration to Enum.each"), pattern.node.pos);
		};
		return makeAST(ERemoteCall(makeAST(EVar("Enum")), pattern.metadata.isCollecting ? "map" : "each", [makeAST(EVar(mapVar)), makeAST(EFn([{ args : [PTuple([PVar(keyVar), PVar(valueVar)])], guard : null, body : loopBody }]))]), pattern.node.pos);	
	case YCombinatorLoop(iterVar, accumulator):
		return makeAST(EString("# TODO: Eliminate Y-combinator pattern"), pattern.node.pos);	
	case InlineExpansion(tmpVar, init, nullBranch, nonNullBranch):
		makeAST(EIf(makeAST(EBinary(Equal, makeAST(EMatch(PVar(tmpVar), init)), makeAST(ENil))), nullBranch, nonNullBranch), pattern.node.pos);	
	default:
		pattern.node;	
}) {
			var ` = pattern.type;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var mapVar = `;
						var keyVar = `;
						var valueVar = `;
						{
							var loopBody = if (pattern.metadata != null) {
								pattern.metadata.loopBody;
							} else {
								null;
							};
							if (loopBody == null) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EString("# TODO: Transform Map iteration to Enum.each"), metadata : {}, pos : pattern.node.pos};
							};
							return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
							}, if ((pattern.metadata.isCollecting)) "map" else "each", [{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(mapVar), metadata : {}, pos : pos};
							}, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PTuple([reflaxe.elixir.ast.EPattern.PVar(keyVar), reflaxe.elixir.ast.EPattern.PVar(valueVar)])], guard : null, body : loopBody}]), metadata : {}, pos : pos};
							}]), metadata : {}, pos : pattern.node.pos};
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					{
						var iterVar = `;
						var accumulator = `;
						{
							return {def : reflaxe.elixir.ast.ElixirASTDef.EString("# TODO: Eliminate Y-combinator pattern"), metadata : {}, pos : pattern.node.pos};
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var tmpVar = `;
						var init = `;
						var nullBranch = `;
						var nonNullBranch = `;
						{
							{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVar), init), metadata : {}, pos : pos};
								}, {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
								}), metadata : {}, pos : pos};
							}, nullBranch, nonNullBranch), metadata : {}, pos : pattern.node.pos};
						};
					};
				};
				default: {
					pattern.node;
				}
			};
		};
	}

	public static function isInlineExpansionBlock(block:Array<haxe.macro.TypedExpr>) {
		if (block.length == 2) {
			return @:ast(switch ([block[0].expr, block[1].expr]) {
	case [TVar(tmpVar, init), TIf(cond, _, elseExpr)] if (init != null && elseExpr != null):
		isNullCheckCondition(cond, tmpVar.id);	
	case _:
		false;	
}) {
				var ` = block[0].expr;
				var ` = block[1].expr;
				if (enumIndex ` == 13) {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 16) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var elseExpr = `;
							var init = `;
							var tmpVar = `;
							if (init != null && elseExpr != null) {
								reflaxe.elixir.ast.ElixirASTPatterns.isNullCheckCondition(cond, tmpVar.id);
							} else {
								false;
							};
						};
					} else {
						false;
					};
				} else {
					false;
				};
			};
		} else {
			if (block.length >= 3) {
				return reflaxe.elixir.ast.ElixirASTPatterns.isComplexInlineExpansionBlock(block);
			};
		};
		return false;
	}

	static function isComplexInlineExpansionBlock(block:Array<haxe.macro.TypedExpr>) {
		return false;
	}

	static function containsBinaryOp(expr:haxe.macro.TypedExpr) {
		if (expr == null) {
			return false;
		};
		return @:ast(switch (expr.expr) {
	case TBinop(_, _, _):
		true;	
	case TParenthesis(e):
		containsBinaryOp(e);	
	case _:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTPatterns.containsBinaryOp(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	public static function transformInlineExpansion(block:Array<haxe.macro.TypedExpr>, buildFromTypedExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toElixirVarName:String -> String) {
		if (block.length >= 3 && reflaxe.elixir.ast.ElixirASTPatterns.isComplexInlineExpansionBlock(block)) {
			return reflaxe.elixir.ast.ElixirASTPatterns.transformComplexInlineExpansion(block, buildFromTypedExpr, toElixirVarName);
		};
		var pattern = reflaxe.elixir.ast.ElixirASTPatterns.extractInlineExpansionPattern(block);
		if (pattern == null) {
			throw "Invalid inline expansion pattern";
		};
		var initAst = buildFromTypedExpr(pattern.init);
		var tmpVarName = toElixirVarName(if (pattern.tmpVar.name.charAt(0) == "_") {
			pattern.tmpVar.name.substr(1, null);
		} else {
			pattern.tmpVar.name;
		});
		var isEqNull = @:ast(switch (pattern.cond.expr) {
	case TBinop(OpEq, _, _):
		true;	
	case _:
		false;	
}) {
			var ` = pattern.cond.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 5) {
					{
						true;
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
		var nullBranch = if (isEqNull) {
			pattern.thenExpr;
		} else {
			pattern.elseExpr;
		};
		var nonNullBranch = if (isEqNull) {
			pattern.elseExpr;
		} else {
			pattern.thenExpr;
		};
		var ifExpr = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EIf({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Equal, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
				}, {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
				}), metadata : {}, pos : pos};
			}, buildFromTypedExpr(nullBranch), buildFromTypedExpr(nonNullBranch));
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		if (ifExpr.metadata == null) {
			ifExpr.metadata = {};
		};
		ifExpr.metadata.keepInlineInAssignment = true;
		return ifExpr.def;
	}

	static function extractInlineExpansionPattern(block:Array<haxe.macro.TypedExpr>) {
		if (block.length != 2) {
			return null;
		};
		return @:ast(switch ([block[0].expr, block[1].expr]) {
	case [TVar(tmpVar, init), TIf(cond, thenExpr, elseExpr)] if (init != null && elseExpr != null && isNullCheckCondition(cond, tmpVar.id)):
		{ tmpVar : tmpVar, init : init, cond : cond, thenExpr : thenExpr, elseExpr : elseExpr };	
	case _:
		null;	
}) {
			var ` = block[0].expr;
			var ` = block[1].expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 16) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenExpr = `;
						var elseExpr = `;
						var init = `;
						var tmpVar = `;
						if (init != null && elseExpr != null && reflaxe.elixir.ast.ElixirASTPatterns.isNullCheckCondition(cond, tmpVar.id)) {
							{tmpVar : tmpVar, init : init, cond : cond, thenExpr : thenExpr, elseExpr : elseExpr};
						} else {
							null;
						};
					};
				} else {
					null;
				};
			} else {
				null;
			};
		};
	}

	static function isNullCheckCondition(cond:haxe.macro.TypedExpr, varId:Int) {
		return @:ast(switch (cond.expr) {
	case TBinop(OpEq | OpNotEq, { expr : TLocal(v) }, { expr : TConst(TNull) }):
		v.id == varId;	
	case _:
		false;	
}) {
			var ` = cond.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				switch (enumIndex `) {
					case 5: {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 4) {
											{
												var v = `;
												{
													v.id == varId;
												};
											};
										} else {
											false;
										};
									} else {
										false;
									};
								};
							} else {
								false;
							};
						};
					};
					case 6: {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 0) {
										var ` = `[0];
										if (enumIndex ` == 4) {
											{
												var v = `;
												{
													v.id == varId;
												};
											};
										} else {
											false;
										};
									} else {
										false;
									};
								};
							} else {
								false;
							};
						};
					};
					default: {
						false;
					}
				};
			} else {
				false;
			};
		};
	}

	static function transformComplexInlineExpansion(block:Array<haxe.macro.TypedExpr>, buildFromTypedExpr:haxe.macro.TypedExpr -> reflaxe.elixir.ast.ElixirAST, toElixirVarName:String -> String) {
		var lastExpr = block[block.length - 1];
		return buildFromTypedExpr(lastExpr).def;
	}

	public static function isNullCoalescingBlock(block:Array<haxe.macro.TypedExpr>) {
		if (block.length != 2) {
			return false;
		};
		return @:ast(switch ([block[0].expr, block[1].expr]) {
	case [TVar(tmpVar, init), TBinop(OpNullCoal, { expr : TLocal(v) }, _)] if (v.id == tmpVar.id && init != null):
		true;	
	case _:
		false;	
}) {
			var ` = block[0].expr;
			var ` = block[1].expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 3) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 24) {
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var v = `;
									var init = `;
									var tmpVar = `;
									if (v.id == tmpVar.id && init != null) {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						};
					} else {
						false;
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	public static function detectArrayOperationPattern(body:haxe.macro.TypedExpr) {
		@:ast(switch (body.expr) {
	case TBlock(exprs) if (exprs.length >= 3):
		var hasArrayAccess = false;
		var hasIncrement = false;
		var hasPush = false;
		var isFilter = false;
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, init):
					if (init != null) {
						switch (init.expr) {
							case TArray(_, _):
								hasArrayAccess = true;							
							case _:
						};
					};				
				case TUnop(OpIncrement | OpDecrement, _, _):
					hasIncrement = true;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
					hasPush = true;				
				case TIf(_, thenExpr, _):
					switch (thenExpr.expr) {
						case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
							hasPush = true;
							isFilter = true;						
						case _:
					};				
				case _:
			};
		};
		if (hasArrayAccess && hasIncrement && hasPush) {
			return isFilter ? "filter" : "map";
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length >= 3) {
						var hasArrayAccess = false;
						var hasIncrement = false;
						var hasPush = false;
						var isFilter = false;
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, init):
		if (init != null) {
			switch (init.expr) {
				case TArray(_, _):
					hasArrayAccess = true;				
				case _:
			};
		};	
	case TUnop(OpIncrement | OpDecrement, _, _):
		hasIncrement = true;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, args) if (cf.get().name == "push"):
		hasPush = true;	
	case TIf(_, thenExpr, _):
		switch (thenExpr.expr) {
			case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
				hasPush = true;
				isFilter = true;			
			case _:
		};	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var args = `;
															if (cf.get().name == "push") {
																hasPush = true;
															} else {};
														};
													} else {};
												} else {};
											};
										};
										case 11: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											switch (enumIndex `) {
												case 0, 1: {
													{
														hasIncrement = true;
													};
												};
												default: {}
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												var init = `;
												{
													if (init != null) {
														@:ast(switch (init.expr) {
	case TArray(_, _):
		hasArrayAccess = true;	
	case _:
}) {
															var ` = init.expr;
															if (enumIndex ` == 2) {
																var ` = `[0];
																var ` = `[1];
																{
																	hasArrayAccess = true;
																};
															} else {};
														};
													};
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var thenExpr = `;
												{
													@:ast(switch (thenExpr.expr) {
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case TBlock([{ expr : TCall({ expr : TField(_, FInstance(_, _, cf)) }, _) }]) if (cf.get().name == "push"):
		hasPush = true;
		isFilter = true;	
	case _:
}) {
														var ` = thenExpr.expr;
														switch (enumIndex `) {
															case 9: {
																var ` = `[0];
																var ` = `[1];
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 4) {
																		var ` = `[0];
																		var ` = `[1];
																		if (enumIndex ` == 0) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			{
																				var cf = `;
																				if (cf.get().name == "push") {
																					hasPush = true;
																					isFilter = true;
																				} else {};
																			};
																		} else {};
																	} else {};
																};
															};
															case 14: {
																var ` = `[0];
																if (`.length == 1) {
																	var ` = `[0];
																	{
																		var ` = `.expr;
																		var ` = `.pos;
																		var ` = `.t;
																		if (enumIndex ` == 9) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var ` = `.expr;
																				var ` = `.pos;
																				var ` = `.t;
																				if (enumIndex ` == 4) {
																					var ` = `[0];
																					var ` = `[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						{
																							var cf = `;
																							if (cf.get().name == "push") {
																								hasPush = true;
																								isFilter = true;
																							} else {};
																						};
																					} else {};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
															default: {}
														};
													};
												};
											};
										};
										default: {}
									};
								};
							};
						};
						if (hasArrayAccess && hasIncrement && hasPush) {
							return if (isFilter) {
								"filter";
							} else {
								"map";
							};
						};
					} else {};
				};
			} else {};
		};
		return null;
	}

	public static function isMapIterationPattern(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null || ast.def == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case ERemoteCall(module, funcName, args):
		var isReduceWhile = switch (module.def) {
			case EVar(modName):
				modName == "Enum" && funcName == "reduce_while";			
			default:
				false;			
		};
		if (!isReduceWhile || args == null || args.length < 3) return false;
		var loopFunc = args[2];
		return containsMapIteratorCalls(loopFunc);	
	case ECall(func, _, args) if (args != null && args.length >= 3):
		var isReduceWhile = switch (func.def) {
			case ERemoteCall(module, funcName, _):
				switch (module.def) {
					case EVar(modName):
						modName == "Enum" && funcName == "reduce_while";					
					default:
						false;					
				};			
			default:
				false;			
		};
		if (!isReduceWhile) return false;
		var loopFunc = args[2];
		return containsMapIteratorCalls(loopFunc);	
	default:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var func = `;
						var args = `;
						if (args != null && args.length >= 3) {
							var isReduceWhile = @:ast(switch (func.def) {
	case ERemoteCall(module, funcName, _):
		switch (module.def) {
			case EVar(modName):
				modName == "Enum" && funcName == "reduce_while";			
			default:
				false;			
		};	
	default:
		false;	
}) {
								var ` = func.def;
								if (enumIndex ` == 24) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var module = `;
										var funcName = `;
										{
											@:ast(switch (module.def) {
	case EVar(modName):
		modName == "Enum" && funcName == "reduce_while";	
	default:
		false;	
}) {
												var ` = module.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var modName = `;
														{
															modName == "Enum" && funcName == "reduce_while";
														};
													};
												} else {
													false;
												};
											};
										};
									};
								} else {
									false;
								};
							};
							if (! isReduceWhile) {
								return false;
							};
							var loopFunc = args[2];
							return reflaxe.elixir.ast.ElixirASTPatterns.containsMapIteratorCalls(loopFunc);
						} else {
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							var isReduceWhile = @:ast(switch (module.def) {
	case EVar(modName):
		modName == "Enum" && funcName == "reduce_while";	
	default:
		false;	
}) {
								var ` = module.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var modName = `;
										{
											modName == "Enum" && funcName == "reduce_while";
										};
									};
								} else {
									false;
								};
							};
							if (! isReduceWhile || args == null || args.length < 3) {
								return false;
							};
							var loopFunc = args[2];
							return reflaxe.elixir.ast.ElixirASTPatterns.containsMapIteratorCalls(loopFunc);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function containsMapIteratorCalls(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null || ast.def == null) {
			return false;
		};
		var hasIteratorCalls = [false];
		var hasKeyValueAccess = [false];
		var scan = [null];
		scan[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EField(obj, field):
		if (field == "key_value_iterator" || field == "has_next" || field == "next") {
			hasIteratorCalls = true;
		};
		if (field == "key" || field == "value") {
			hasKeyValueAccess = true;
		};
		scan(obj);	
	case ECall(func, _, args):
		scan(func);
		if (args != null) {
			for (arg  in  args) scan(arg);
		};	
	case EFn(clauses):
		for (clause  in  clauses) {
			if (clause.body != null) scan(clause.body);
		};	
	case EBlock(exprs):
		for (expr  in  exprs) scan(expr);	
	case EIf(cond, thenBranch, elseBranch):
		scan(cond);
		scan(thenBranch);
		if (elseBranch != null) scan(elseBranch);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								scan[0](cond);
								scan[0](thenBranch);
								if (elseBranch != null) {
									scan[0](elseBranch);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var func = `;
							var args = `;
							{
								scan[0](func);
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											scan[0](arg);
										};
									};
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var obj = `;
							var field = `;
							{
								if (field == "key_value_iterator" || field == "has_next" || field == "next") {
									hasIteratorCalls[0] = true;
								};
								if (field == "key" || field == "value") {
									hasKeyValueAccess[0] = true;
								};
								scan[0](obj);
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										if (clause.body != null) {
											scan[0](clause.body);
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var expr = exprs[`];
										++ `;
										scan[0](expr);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](ast);
		return hasIteratorCalls[0] && hasKeyValueAccess[0];
	}

	public static function extractMapIterationData(ast:reflaxe.elixir.ast.ElixirAST) {
		if (! reflaxe.elixir.ast.ElixirASTPatterns.isMapIterationPattern(ast)) {
			return null;
		};
		var args = @:ast(switch (ast.def) {
	case ERemoteCall(_, _, a):
		a;	
	case ECall(_, _, a):
		a;	
	default:
		null;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var a = `;
						{
							a;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var a = `;
						{
							a;
						};
					};
				};
				default: {
					null;
				}
			};
		};
		if (args == null || args.length < 3) {
			return null;
		};
		var initial = args[1];
		var loopFunc = args[2];
		var mapVar = null;
		if (initial != null) {
			@:ast(switch (initial.def) {
	case ETuple(elements) if (elements.length >= 1):
		switch (elements[0].def) {
			case EVar(name):
				mapVar = name;			
			default:
		};	
	case EVar(name):
		mapVar = name;	
	default:
}) {
				var ` = initial.def;
				switch (enumIndex `) {
					case 16: {
						var ` = `[0];
						{
							var elements = `;
							if (elements.length >= 1) {
								@:ast(switch (elements[0].def) {
	case EVar(name):
		mapVar = name;	
	default:
}) {
									var ` = elements[0].def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											{
												mapVar = name;
											};
										};
									} else {};
								};
							} else {};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								mapVar = name;
							};
						};
					};
					default: {}
				};
			};
		};
		if (mapVar == null) {
			return null;
		};
		var loopBody = null;
		var isCollecting = false;
		@:ast(switch (loopFunc.def) {
	case EFn(clauses) if (clauses.length > 0):
		var firstClause = clauses[0];
		if (firstClause.body != null) {
			loopBody = extractCleanLoopBody(firstClause.body, mapVar);
			isCollecting = detectResultCollection(firstClause.body);
		};	
	default:
}) {
			var ` = loopFunc.def;
			if (enumIndex ` == 42) {
				var ` = `[0];
				{
					var clauses = `;
					if (clauses.length > 0) {
						var firstClause = clauses[0];
						if (firstClause.body != null) {
							loopBody = reflaxe.elixir.ast.ElixirASTPatterns.extractCleanLoopBody(firstClause.body, mapVar);
							isCollecting = reflaxe.elixir.ast.ElixirASTPatterns.detectResultCollection(firstClause.body);
						};
					} else {};
				};
			} else {};
		};
		if (loopBody == null) {
			return null;
		};
		var keyVar = "key";
		var valueVar = "value";
		if (loopBody != null) {
			@:ast(switch (loopBody.def) {
	case EBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.def) {
				case EMatch(PVar(varName), value):
					if (isFieldAccess(value, "key")) keyVar = varName;
					if (isFieldAccess(value, "value")) valueVar = varName;				
				default:
			};
		};	
	default:
}) {
				var ` = loopBody.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var expr = exprs[`];
									++ `;
									@:ast(switch (expr.def) {
	case EMatch(PVar(varName), value):
		if (isFieldAccess(value, "key")) keyVar = varName;
		if (isFieldAccess(value, "value")) valueVar = varName;	
	default:
}) {
										var ` = expr.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var varName = `;
													var value = `;
													{
														if (reflaxe.elixir.ast.ElixirASTPatterns.isFieldAccess(value, "key")) {
															keyVar = varName;
														};
														if (reflaxe.elixir.ast.ElixirASTPatterns.isFieldAccess(value, "value")) {
															valueVar = varName;
														};
													};
												};
											} else {};
										} else {};
									};
								};
							};
						};
					};
				} else {};
			};
		};
		return {mapVar : mapVar, keyVar : keyVar, valueVar : valueVar, loopBody : loopBody, isCollecting : isCollecting};
	}

	static function extractCleanLoopBody(body:reflaxe.elixir.ast.ElixirAST, mapVar:String) {
		@:ast(switch (body.def) {
	case EIf(_, thenBranch, _):
		return cleanupIteratorInfrastructure(thenBranch, mapVar);	
	case EBlock(exprs):
		for (expr  in  exprs) {
			var extracted = extractCleanLoopBody(expr, mapVar);
			if (extracted != null) return extracted;
		};	
	default:
}) {
			var ` = body.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var thenBranch = `;
						{
							return reflaxe.elixir.ast.ElixirASTPatterns.cleanupIteratorInfrastructure(thenBranch, mapVar);
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var expr = exprs[`];
									++ `;
									var extracted = reflaxe.elixir.ast.ElixirASTPatterns.extractCleanLoopBody(expr, mapVar);
									if (extracted != null) {
										return extracted;
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	public static function cleanupIteratorInfrastructure(body:reflaxe.elixir.ast.ElixirAST, mapVar:String) {
		@:ast(switch (body.def) {
	case EBlock(exprs):
		var cleaned = [];
		for (expr  in  exprs) {
			var skip = false;
			switch (expr.def) {
				case EMatch(pattern, value):
					switch (pattern) {
						case PVar(name) if (name == "key" || name == "value"):
							if (isIteratorMethodChain(value)) skip = true;						
						default:
					};				
				case ETuple(elements) if (elements.length == 2):
					switch (elements[0].def) {
						case EAtom(atom) if (atom == "cont" || atom == "halt"):
							skip = true;						
						default:
					};				
				default:
			};
			if (!skip) {
				cleaned.push(expr);
			};
		};
		if (cleaned.length == 1) {
			return cleaned[0];
		} else if (cleaned.length > 0) {
			return { def : EBlock(cleaned), pos : body.pos, metadata : body.metadata };
		};	
	default:
		return body;	
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						var cleaned = [];
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								var skip = false;
								@:ast(switch (expr.def) {
	case EMatch(pattern, value):
		switch (pattern) {
			case PVar(name) if (name == "key" || name == "value"):
				if (isIteratorMethodChain(value)) skip = true;			
			default:
		};	
	case ETuple(elements) if (elements.length == 2):
		switch (elements[0].def) {
			case EAtom(atom) if (atom == "cont" || atom == "halt"):
				skip = true;			
			default:
		};	
	default:
}) {
									var ` = expr.def;
									switch (enumIndex `) {
										case 8: {
											var ` = `[0];
											var ` = `[1];
											{
												var pattern = `;
												var value = `;
												{
													@:ast(switch (pattern) {
	case PVar(name) if (name == "key" || name == "value"):
		if (isIteratorMethodChain(value)) skip = true;	
	default:
}) if (enumIndex pattern == 0) {
														var ` = pattern[0];
														{
															var name = `;
															if (name == "key" || name == "value") {
																if (reflaxe.elixir.ast.ElixirASTPatterns.isIteratorMethodChain(value)) {
																	skip = true;
																};
															} else {};
														};
													} else {};
												};
											};
										};
										case 16: {
											var ` = `[0];
											{
												var elements = `;
												if (elements.length == 2) {
													@:ast(switch (elements[0].def) {
	case EAtom(atom) if (atom == "cont" || atom == "halt"):
		skip = true;	
	default:
}) {
														var ` = elements[0].def;
														if (enumIndex ` == 31) {
															var ` = `[0];
															{
																var atom = `;
																if (atom == "cont" || atom == "halt") {
																	skip = true;
																} else {};
															};
														} else {};
													};
												} else {};
											};
										};
										default: {}
									};
								};
								if (! skip) {
									cleaned.push(expr);
								};
							};
						};
						if (cleaned.length == 1) {
							return cleaned[0];
						} else {
							if (cleaned.length > 0) {
								return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(cleaned), pos : body.pos, metadata : body.metadata};
							};
						};
					};
				};
			} else {
				return body;
			};
		};
		return null;
	}

	static function isFieldAccess(expr:reflaxe.elixir.ast.ElixirAST, fieldName:String) {
		if (expr == null || expr.def == null) {
			return false;
		};
		return @:ast(switch (expr.def) {
	case EField(_, field):
		field == fieldName;	
	default:
		false;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 28) {
				var ` = `[0];
				var ` = `[1];
				{
					var field = `;
					{
						field == fieldName;
					};
				};
			} else {
				false;
			};
		};
	}

	static function isIteratorMethodChain(expr:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null || expr.def == null) {
			return false;
		};
		@:ast(switch (expr.def) {
	case EField(obj, field):
		if (field == "key" || field == "value") {
			return isIteratorCall(obj);
		};	
	default:
}) {
			var ` = expr.def;
			if (enumIndex ` == 28) {
				var ` = `[0];
				var ` = `[1];
				{
					var obj = `;
					var field = `;
					{
						if (field == "key" || field == "value") {
							return reflaxe.elixir.ast.ElixirASTPatterns.isIteratorCall(obj);
						};
					};
				};
			} else {};
		};
		return false;
	}

	static function isIteratorCall(expr:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null || expr.def == null) {
			return false;
		};
		@:ast(switch (expr.def) {
	case ECall(func, _):
		switch (func.def) {
			case EField(_, field):
				return field == "next" || field == "key_value_iterator" || field == "has_next";			
			default:
		};	
	case EField(_, field):
		return field == "next" || field == "key_value_iterator" || field == "has_next";	
	default:
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var func = `;
						{
							@:ast(switch (func.def) {
	case EField(_, field):
		return field == "next" || field == "key_value_iterator" || field == "has_next";	
	default:
}) {
								var ` = func.def;
								if (enumIndex ` == 28) {
									var ` = `[0];
									var ` = `[1];
									{
										var field = `;
										{
											return field == "next" || field == "key_value_iterator" || field == "has_next";
										};
									};
								} else {};
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var field = `;
						{
							return field == "next" || field == "key_value_iterator" || field == "has_next";
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	static function detectResultCollection(body:reflaxe.elixir.ast.ElixirAST) {
		if (body == null || body.def == null) {
			return false;
		};
		var hasCollection = [false];
		var scan = [null];
		scan[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return;
			};
			@:ast(switch (node.def) {
	case ECall(func, _, args):
		switch (func.def) {
			case ERemoteCall(module, funcName, _):
				switch (module.def) {
					case EVar(modName) if (modName == "Array" && funcName == "push"):
						hasCollection = true;					
					default:
				};			
			default:
		};
		scan(func);
		if (args != null) {
			for (arg  in  args) scan(arg);
		};	
	case EBlock(exprs):
		for (expr  in  exprs) scan(expr);	
	case EIf(_, thenBranch, elseBranch):
		scan(thenBranch);
		if (elseBranch != null) scan(elseBranch);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var thenBranch = `;
							var elseBranch = `;
							{
								scan[0](thenBranch);
								if (elseBranch != null) {
									scan[0](elseBranch);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var func = `;
							var args = `;
							{
								@:ast(switch (func.def) {
	case ERemoteCall(module, funcName, _):
		switch (module.def) {
			case EVar(modName) if (modName == "Array" && funcName == "push"):
				hasCollection = true;			
			default:
		};	
	default:
}) {
									var ` = func.def;
									if (enumIndex ` == 24) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var module = `;
											var funcName = `;
											{
												@:ast(switch (module.def) {
	case EVar(modName) if (modName == "Array" && funcName == "push"):
		hasCollection = true;	
	default:
}) {
													var ` = module.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var modName = `;
															if (modName == "Array" && funcName == "push") {
																hasCollection[0] = true;
															} else {};
														};
													} else {};
												};
											};
										};
									} else {};
								};
								scan[0](func);
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var arg = args[`];
											++ `;
											scan[0](arg);
										};
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var expr = exprs[`];
										++ `;
										scan[0](expr);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](body);
		return hasCollection[0];
	}
}