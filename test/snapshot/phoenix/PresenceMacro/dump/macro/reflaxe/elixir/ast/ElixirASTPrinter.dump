class reflaxe.elixir.ast.ElixirASTPrinter {

	@:value(0)
	static var loopIdCounter:Int = 0;

	@:value(null)
	static var currentUnusedFunctions:Null<Array<String>> = null;

	public static function printAST(ast:reflaxe.elixir.ast.ElixirAST, context:Null<reflaxe.elixir.CompilationContext> = null) {
		return reflaxe.elixir.ast.ElixirASTPrinter.print(ast, 0);
	}

	@:value(null)
	static var currentModuleName:Null<String> = null;

	@:value(null)
	static var observedAppPrefix:Null<String> = null;

	@:value({ indent : 0 })
	public static function print(ast:reflaxe.elixir.ast.ElixirAST, indent:Int = 0) {
		if (ast == null) {
			return "";
		};
		var result = @:ast(switch (ast.def) {
	case EDefmodule(name, doBlock):
		if (ast.metadata != null && ast.metadata.unusedPrivateFunctions != null) {
			currentUnusedFunctions = ast.metadata.unusedPrivateFunctions;
		};
		var moduleContent = "";
		var nowarnList:Array<String> = [];
		var doBlockUnwrapped = switch (doBlock.def) {
			case EParen(inner):
				inner;			
			default:
				doBlock;			
		};
		switch (doBlockUnwrapped.def) {
			case EBlock(stmts):
				for (s  in  stmts) switch (s.def) {
					case EDefp(fnName, fnArgs, _, _):
						var arity = fnArgs.length;
						nowarnList.push(fnName + ": " + arity);					
					default:
				};			
			default:
		};
		var prevModule = currentModuleName;
		currentModuleName = name;
		if (observedAppPrefix == null) {
			var idxCap = name.indexOf(".Repo");
			if (idxCap > 0) observedAppPrefix = name.substring(0, idxCap);
			var idxWeb = name.indexOf("Web");
			if (idxWeb > 0) observedAppPrefix = name.substring(0, idxWeb);
		};
		inline function needsRepoAliasInBlock(block:ElixirAST):Bool {
			var hasAlias = false;
			var hasBare = false;
			switch (block.def) {
				case EBlock(stmts):
					for (s  in  stmts) switch (s.def) {
						case EAlias(module, as) if ((as == null || as == "Repo")):
							if (module != null && module.indexOf(".Repo") > 0) hasAlias = true;						
						default:
					};
					function scan(n:ElixirAST):Void {
						if (n == null || n.def == null || hasBare) return;
						switch (n.def) {
							case ERemoteCall({ def : EVar(m) }, _, _):
								if (m == "Repo") hasBare = true;							
							case ECall({ def : EVar(m) }, _, _):
								if (m == "Repo") hasBare = true;							
							case EBlock(es):
								for (e  in  es) scan(e);							
							case EIf(c, t, e):
								scan(c);
								scan(t);
								if (e != null) scan(e);							
							case ECase(e, cs):
								scan(e);
								for (cl  in  cs) {
									if (cl.guard != null) scan(cl.guard);
									scan(cl.body);
								};							
							case ECond(cs):
								for (cl  in  cs) {
									scan(cl.condition);
									scan(cl.body);
								};							
							case EMatch(_, rhs):
								scan(rhs);							
							case EBinary(_, l, r):
								scan(l);
								scan(r);							
							case ERemoteCall(m, _, args):
								scan(m);
								for (a  in  args) scan(a);							
							case ECall(t, _, args):
								if (t != null) scan(t);
								for (a  in  args) scan(a);							
							default:
						};
					};
					for (s  in  stmts) scan(s);				
				default:
			};
			return (hasBare && !hasAlias);
		};
		inline function needsSafePubSubAliasInBlock(block:ElixirAST):Bool {
			var hasAlias = false;
			var needs = false;
			switch (block.def) {
				case EBlock(stmts) | EDo(stmts):
					for (s  in  stmts) switch (s.def) {
						case EAlias(module, as) if (as == "SafePubSub" || module == "Phoenix.SafePubSub"):
							hasAlias = true;						
						default:
					};
					function scan(n:ElixirAST):Void {
						if (n == null || n.def == null || needs) return;
						switch (n.def) {
							case ERemoteCall({ def : EVar(m) }, _, _) if (m == "SafePubSub"):
								needs = true;							
							case ECall({ def : EVar(m2) }, _, _) if (m2 == "SafePubSub"):
								needs = true;							
							case EVar(v) if (v == "SafePubSub"):
								needs = true;							
							case ERaw(code):
								if (code != null && code.indexOf("SafePubSub.") != -1) needs = true;							
							case EDef(_, _, _, b):
								scan(b);							
							case EDefp(_, _, _, privateBody):
								scan(privateBody);							
							case EBlock(es):
								for (e  in  es) scan(e);							
							case EIf(c, t, e):
								scan(c);
								scan(t);
								if (e != null) scan(e);							
							case ECase(e, cs):
								scan(e);
								for (cl  in  cs) {
									if (cl.guard != null) scan(cl.guard);
									scan(cl.body);
								};							
							case EBinary(_, l, r):
								scan(l);
								scan(r);							
							case ERemoteCall(m, _, as):
								scan(m);
								if (as != null) for (a  in  as) scan(a);							
							case ECall(t, _, argsList):
								if (t != null) scan(t);
								if (argsList != null) for (a  in  argsList) scan(a);							
							default:
						};
					};
					for (s  in  stmts) scan(s);				
				default:
			};
			return needs && !hasAlias;
		};
		inline function needsEctoRequireInBlock(block:ElixirAST):Bool {
			var needs = false;
			var has = false;
			switch (block.def) {
				case EBlock(stmts) | EDo(stmts):
					for (s  in  stmts) switch (s.def) {
						case ERequire(mod, _):
							if (mod == "Ecto.Query") has = true;						
						default:
					};
					function scan(n:ElixirAST):Void {
						if (n == null || n.def == null || needs) return;
						switch (n.def) {
							case ERemoteCall({ def : EVar(m) }, _, _):
								if (m == "Ecto.Query") needs = true;							
							case ECall(t, _, args):
								if (t != null) scan(t);
								for (a  in  args) scan(a);							
							case EDef(_, _, _, body):
								scan(body);							
							case EDefp(_, _, _, body):
								scan(body);							
							case EBlock(es):
								for (e  in  es) scan(e);							
							case EIf(c, t, e):
								scan(c);
								scan(t);
								if (e != null) scan(e);							
							case ECase(e, cs):
								scan(e);
								for (cl  in  cs) {
									if (cl.guard != null) scan(cl.guard);
									scan(cl.body);
								};							
							case EBinary(_, l, r):
								scan(l);
								scan(r);							
							case EFn(cs):
								for (cl  in  cs) scan(cl.body);							
							default:
						};
					};
					for (s  in  stmts) scan(s);				
				default:
			};
			return needs && !has;
		};
		if (needsEctoRequireInBlock(doBlockUnwrapped)) {
			moduleContent += indentStr(indent + 1) + "require Ecto.Query\n";
		};
		moduleContent += (switch (doBlockUnwrapped.def) {
			case EBlock(stmts) if (stmts.length == 1):
				switch (stmts[0].def) {
					case ERaw(code):
						var c = code;
						if (!StringTools.endsWith(c, "\n")) c += "\n";
						c;					
					default:
						indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);					
				};			
			default:
				indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);			
		});
		currentModuleName = prevModule;
		var moduleResult = "defmodule ${name} do\n" + moduleContent + "\n" + indentStr(indent) + "end\n";
		currentUnusedFunctions = null;
		moduleResult;	
	case EModule(name, attributes, body):
		var isException = ast.metadata != null && ast.metadata.isException == true;
		if (isException) {
			var result = "defmodule ${name} do\n";
			result += indentStr(indent + 1) + "defexception [:message]\n";
			var prevModuleCtx = currentModuleName;
			currentModuleName = name;
			for (expr  in  body) {
				var exprStr = print(expr, indent + 1);
				if (!exprStr.startsWith("defstruct")) {
					result += "\n" + indentStr(indent + 1) + exprStr + "\n";
				};
			};
			currentModuleName = prevModuleCtx;
			result += indentStr(indent) + "end\n";
			result;
		} else {
			var result = "defmodule ${name} do\n";
			var prevModuleCtx = currentModuleName;
			currentModuleName = name;
			inline function moduleNeedsSafePubSubAlias(stmts:Array<ElixirAST>):Bool {
				var hasAlias = false;
				var needs = false;
				for (s  in  stmts) switch (s.def) {
					case EAlias(module, as) if (as == "SafePubSub" || module == "Phoenix.SafePubSub"):
						hasAlias = true;					
					default:
				};
				function scan(n:ElixirAST):Void {
					if (needs || n == null || n.def == null) return;
					switch (n.def) {
						case ERemoteCall({ def : EVar(m) }, _, _) if (m == "SafePubSub"):
							needs = true;						
						case ECall({ def : EVar(m2) }, _, _) if (m2 == "SafePubSub"):
							needs = true;						
						case EVar(v) if (v == "SafePubSub"):
							needs = true;						
						case ERaw(code):
							if (code != null && code.indexOf("SafePubSub.") != -1) needs = true;						
						case EDef(_, _, _, b):
							scan(b);						
						case EDefp(_, _, _, privateBody):
							scan(privateBody);						
						case EBlock(es):
							for (e  in  es) scan(e);						
						case EIf(c, t, e):
							scan(c);
							scan(t);
							if (e != null) scan(e);						
						case ECase(e, cs):
							scan(e);
							for (cl  in  cs) {
								if (cl.guard != null) scan(cl.guard);
								scan(cl.body);
							};						
						case EBinary(_, l, r):
							scan(l);
							scan(r);						
						case ERemoteCall(m, _, as):
							scan(m);
							if (as != null) for (a  in  as) scan(a);						
						case ECall(t, _, argsList):
							if (t != null) scan(t);
							if (argsList != null) for (a  in  argsList) scan(a);						
						default:
					};
				};
				for (s  in  stmts) scan(s);
				return needs && !hasAlias;
			};
			for (attr  in  attributes) {
				result += indentStr(indent + 1) + printAttribute(attr) + "\n";
			};
			if (attributes.length > 0 && body.length > 0) {
				result += "\n";
			};
			if (observedAppPrefix == null) {
				var idxCap2 = name.indexOf(".Repo");
				if (idxCap2 > 0) observedAppPrefix = name.substring(0, idxCap2);
				var idxWeb2 = name.indexOf("Web");
				if (idxWeb2 > 0) observedAppPrefix = name.substring(0, idxWeb2);
			};
			var needsEcto = (function():Bool {
				inline function bodyHasEctoRemote(stmts:Array<ElixirAST>):Bool {
					var found = false;
					function scan(n:ElixirAST):Void {
						if (found || n == null || n.def == null) return;
						switch (n.def) {
							case ERequire(mod, _):
							case ERemoteCall(mod, _, args):
								switch (mod.def) {
									case EVar(m) if (m == "Ecto.Query"):
										found = true;									
									default:
								};
								if (args != null) for (a  in  args) scan(a);							
							case ERaw(code):
								if (code != null && code.indexOf("Ecto.Query.") != -1) found = true;							
							case ECall(t, _, as):
								if (t != null) scan(t);
								if (as != null) for (a  in  as) scan(a);							
							case EBlock(es):
								for (e  in  es) scan(e);							
							case EDo(es2):
								for (e  in  es2) scan(e);							
							case EIf(c, t, e):
								scan(c);
								scan(t);
								if (e != null) scan(e);							
							case ECase(e, cs):
								scan(e);
								for (cl  in  cs) {
									if (cl.guard != null) scan(cl.guard);
									scan(cl.body);
								};							
							case EBinary(_, l, r):
								scan(l);
								scan(r);							
							case EFn(cs):
								for (cl  in  cs) scan(cl.body);							
							case EDef(_, _, _, b):
								scan(b);							
							case EDefp(_, _, _, privateBody):
								scan(privateBody);							
							default:
						};
					};
					for (s  in  stmts) scan(s);
					return found;
				};
				return bodyHasEctoRemote(body);
			})();
			if (needsEcto) {
				result += indentStr(indent + 1) + "require Ecto.Query\n";
			};
			for (expr  in  body) {
				switch (expr.def) {
					case EBlock(stmts) if (stmts.length == 1):
						switch (stmts[0].def) {
							case ERaw(code):
								var c = code;
								if (!StringTools.endsWith(c, "\n")) c += "\n";
								result += c;							
							default:
								result += indentStr(indent + 1) + print(expr, indent + 1) + "\n";							
						};					
					default:
						result += indentStr(indent + 1) + print(expr, indent + 1) + "\n";					
				};
			};
			currentModuleName = prevModuleCtx;
			result += indentStr(indent) + "end\n";
			result;
		};	
	default:
		printNode(ast.def, indent);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attributes = `;
						var body = `;
						{
							var isException = ast.metadata != null && ast.metadata.isException == true;
							if (isException) {
								var result = "defmodule " + name + " do\n";
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + "defexception [:message]\n";
								var prevModuleCtx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName;
								reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = name;
								{
									var ` = 0;
									while (` < body.length) {
										var expr = body[`];
										++ `;
										var exprStr = reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1);
										if (! StringTools.startsWith(exprStr, "defstruct")) {
											result += "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + exprStr + "\n";
										};
									};
								};
								reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = prevModuleCtx;
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end\n";
								result;
							} else {
								var result = "defmodule " + name + " do\n";
								var prevModuleCtx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName;
								reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = name;
								{};
								{
									var ` = 0;
									while (` < attributes.length) {
										var attr = attributes[`];
										++ `;
										result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printAttribute(attr) + "\n";
									};
								};
								if (attributes.length > 0 && body.length > 0) {
									result += "\n";
								};
								if (reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix == null) {
									var idxCap2 = name.indexOf(".Repo", null);
									if (idxCap2 > 0) {
										reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix = name.substring(0, idxCap2);
									};
									var idxWeb2 = name.indexOf("Web", null);
									if (idxWeb2 > 0) {
										reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix = name.substring(0, idxWeb2);
									};
								};
								var needsEcto = (function() {
									{};
									return {
										var found = [false];
										var scan = [null];
										scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
											if (found[0] || n == null || n.def == null) {
												return;
											};
											@:ast(switch (n.def) {
	case ERequire(mod, _):
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Ecto.Query"):
				found = true;			
			default:
		};
		if (args != null) for (a  in  args) scan(a);	
	case ERaw(code):
		if (code != null && code.indexOf("Ecto.Query.") != -1) found = true;	
	case ECall(t, _, as):
		if (t != null) scan(t);
		if (as != null) for (a  in  as) scan(a);	
	case EBlock(es):
		for (e  in  es) scan(e);	
	case EDo(es2):
		for (e  in  es2) scan(e);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(e, cs):
		scan(e);
		for (cl  in  cs) {
			if (cl.guard != null) scan(cl.guard);
			scan(cl.body);
		};	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EFn(cs):
		for (cl  in  cs) scan(cl.body);	
	case EDef(_, _, _, b):
		scan(b);	
	case EDefp(_, _, _, privateBody):
		scan(privateBody);	
	default:
}) {
												var ` = n.def;
												switch (enumIndex `) {
													case 2: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														var ` = `[3];
														{
															var b = `;
															{
																scan[0](b);
															};
														};
													};
													case 3: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														var ` = `[3];
														{
															var privateBody = `;
															{
																scan[0](privateBody);
															};
														};
													};
													case 6: {
														var ` = `[0];
														var ` = `[1];
														{
															var e = `;
															var cs = `;
															{
																scan[0](e);
																{
																	var ` = 0;
																	while (` < cs.length) {
																		var cl = cs[`];
																		++ `;
																		if (cl.guard != null) {
																			scan[0](cl.guard);
																		};
																		scan[0](cl.body);
																	};
																};
															};
														};
													};
													case 10: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var c = `;
															var t = `;
															var e = `;
															{
																scan[0](c);
																scan[0](t);
																if (e != null) {
																	scan[0](e);
																};
															};
														};
													};
													case 22: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var t = `;
															var as = `;
															{
																if (t != null) {
																	scan[0](t);
																};
																if (as != null) {
																	{
																		var ` = 0;
																		while (` < as.length) {
																			var a = as[`];
																			++ `;
																			scan[0](a);
																		};
																	};
																};
															};
														};
													};
													case 24: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var mod = `;
															var args = `;
															{
																@:ast(switch (mod.def) {
	case EVar(m) if (m == "Ecto.Query"):
		found = true;	
	default:
}) {
																	var ` = mod.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var m = `;
																			if (m == "Ecto.Query") {
																				found[0] = true;
																			} else {};
																		};
																	} else {};
																};
																if (args != null) {
																	{
																		var ` = 0;
																		while (` < args.length) {
																			var a = args[`];
																			++ `;
																			scan[0](a);
																		};
																	};
																};
															};
														};
													};
													case 26: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var l = `;
															var r = `;
															{
																scan[0](l);
																scan[0](r);
															};
														};
													};
													case 42: {
														var ` = `[0];
														{
															var cs = `;
															{
																{
																	var ` = 0;
																	while (` < cs.length) {
																		var cl = cs[`];
																		++ `;
																		scan[0](cl.body);
																	};
																};
															};
														};
													};
													case 47: {
														var ` = `[0];
														var ` = `[1];
														{
															var mod = `;
															{};
														};
													};
													case 53: {
														var ` = `[0];
														{
															var es = `;
															{
																{
																	var ` = 0;
																	while (` < es.length) {
																		var e = es[`];
																		++ `;
																		scan[0](e);
																	};
																};
															};
														};
													};
													case 55: {
														var ` = `[0];
														{
															var es2 = `;
															{
																{
																	var ` = 0;
																	while (` < es2.length) {
																		var e = es2[`];
																		++ `;
																		scan[0](e);
																	};
																};
															};
														};
													};
													case 62: {
														var ` = `[0];
														{
															var code = `;
															{
																if (code != null && code.indexOf("Ecto.Query.", null) != -1) {
																	found[0] = true;
																};
															};
														};
													};
													default: {}
												};
											};
										};
										{
											var ` = 0;
											while (` < body.length) {
												var s = body[`];
												++ `;
												scan[0](s);
											};
										};
										found[0];
									};
								})();
								if (needsEcto) {
									result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + "require Ecto.Query\n";
								};
								{
									var ` = 0;
									while (` < body.length) {
										var expr = body[`];
										++ `;
										@:ast(switch (expr.def) {
	case EBlock(stmts) if (stmts.length == 1):
		switch (stmts[0].def) {
			case ERaw(code):
				var c = code;
				if (!StringTools.endsWith(c, "\n")) c += "\n";
				result += c;			
			default:
				result += indentStr(indent + 1) + print(expr, indent + 1) + "\n";			
		};	
	default:
		result += indentStr(indent + 1) + print(expr, indent + 1) + "\n";	
}) {
											var ` = expr.def;
											if (enumIndex ` == 53) {
												var ` = `[0];
												{
													var stmts = `;
													if (stmts.length == 1) {
														@:ast(switch (stmts[0].def) {
	case ERaw(code):
		var c = code;
		if (!StringTools.endsWith(c, "\n")) c += "\n";
		result += c;	
	default:
		result += indentStr(indent + 1) + print(expr, indent + 1) + "\n";	
}) {
															var ` = stmts[0].def;
															if (enumIndex ` == 62) {
																var ` = `[0];
																{
																	var code = `;
																	{
																		var c = code;
																		if (! StringTools.endsWith(c, "\n")) {
																			c += "\n";
																		};
																		result += c;
																	};
																};
															} else {
																result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1) + "\n";
															};
														};
													} else {
														result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1) + "\n";
													};
												};
											} else {
												result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1) + "\n";
											};
										};
									};
								};
								reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = prevModuleCtx;
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end\n";
								result;
							};
						};
					};
				};
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var doBlock = `;
						{
							if (ast.metadata != null && ast.metadata.unusedPrivateFunctions != null) {
								reflaxe.elixir.ast.ElixirASTPrinter.currentUnusedFunctions = ast.metadata.unusedPrivateFunctions;
							};
							var moduleContent = "";
							var nowarnList = [];
							var doBlockUnwrapped = @:ast(switch (doBlock.def) {
	case EParen(inner):
		inner;	
	default:
		doBlock;	
}) {
								var ` = doBlock.def;
								if (enumIndex ` == 54) {
									var ` = `[0];
									{
										var inner = `;
										{
											inner;
										};
									};
								} else {
									doBlock;
								};
							};
							@:ast(switch (doBlockUnwrapped.def) {
	case EBlock(stmts):
		for (s  in  stmts) switch (s.def) {
			case EDefp(fnName, fnArgs, _, _):
				var arity = fnArgs.length;
				nowarnList.push(fnName + ": " + arity);			
			default:
		};	
	default:
}) {
								var ` = doBlockUnwrapped.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var stmts = `;
										{
											{
												var ` = 0;
												while (` < stmts.length) {
													var s = stmts[`];
													++ `;
													@:ast(switch (s.def) {
	case EDefp(fnName, fnArgs, _, _):
		var arity = fnArgs.length;
		nowarnList.push(fnName + ": " + arity);	
	default:
}) {
														var ` = s.def;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															var ` = `[3];
															{
																var fnName = `;
																var fnArgs = `;
																{
																	var arity = fnArgs.length;
																	nowarnList.push(fnName + ": " + arity);
																};
															};
														} else {};
													};
												};
											};
										};
									};
								} else {};
							};
							var prevModule = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName;
							reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = name;
							if (reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix == null) {
								var idxCap = name.indexOf(".Repo", null);
								if (idxCap > 0) {
									reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix = name.substring(0, idxCap);
								};
								var idxWeb = name.indexOf("Web", null);
								if (idxWeb > 0) {
									reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix = name.substring(0, idxWeb);
								};
							};
							{};
							{};
							{};
							if ({
								var needs = [false];
								var has = false;
								@:ast(switch (block.def) {
	case EBlock(stmts) | EDo(stmts):
		for (s  in  stmts) switch (s.def) {
			case ERequire(mod, _):
				if (mod == "Ecto.Query") has = true;			
			default:
		};
		function scan(n:ElixirAST):Void {
			if (n == null || n.def == null || needs) return;
			switch (n.def) {
				case ERemoteCall({ def : EVar(m) }, _, _):
					if (m == "Ecto.Query") needs = true;				
				case ECall(t, _, args):
					if (t != null) scan(t);
					for (a  in  args) scan(a);				
				case EDef(_, _, _, body):
					scan(body);				
				case EDefp(_, _, _, body):
					scan(body);				
				case EBlock(es):
					for (e  in  es) scan(e);				
				case EIf(c, t, e):
					scan(c);
					scan(t);
					if (e != null) scan(e);				
				case ECase(e, cs):
					scan(e);
					for (cl  in  cs) {
						if (cl.guard != null) scan(cl.guard);
						scan(cl.body);
					};				
				case EBinary(_, l, r):
					scan(l);
					scan(r);				
				case EFn(cs):
					for (cl  in  cs) scan(cl.body);				
				default:
			};
		};
		for (s  in  stmts) scan(s);	
	default:
}) {
									var ` = doBlockUnwrapped.def;
									switch (enumIndex `) {
										case 53: {
											var ` = `[0];
											{
												var stmts = `;
												{
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															@:ast(switch (s.def) {
	case ERequire(mod, _):
		if (mod == "Ecto.Query") has = true;	
	default:
}) {
																var ` = s.def;
																if (enumIndex ` == 47) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var mod = `;
																		{
																			if (mod == "Ecto.Query") {
																				has = true;
																			};
																		};
																	};
																} else {};
															};
														};
													};
													var scan = [null];
													scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
														if (n == null || n.def == null || needs[0]) {
															return;
														};
														@:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(m) }, _, _):
		if (m == "Ecto.Query") needs = true;	
	case ECall(t, _, args):
		if (t != null) scan(t);
		for (a  in  args) scan(a);	
	case EDef(_, _, _, body):
		scan(body);	
	case EDefp(_, _, _, body):
		scan(body);	
	case EBlock(es):
		for (e  in  es) scan(e);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(e, cs):
		scan(e);
		for (cl  in  cs) {
			if (cl.guard != null) scan(cl.guard);
			scan(cl.body);
		};	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EFn(cs):
		for (cl  in  cs) scan(cl.body);	
	default:
}) {
															var ` = n.def;
															switch (enumIndex `) {
																case 2: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	var ` = `[3];
																	{
																		var body = `;
																		{
																			scan[0](body);
																		};
																	};
																};
																case 3: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	var ` = `[3];
																	{
																		var body = `;
																		{
																			scan[0](body);
																		};
																	};
																};
																case 6: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var e = `;
																		var cs = `;
																		{
																			scan[0](e);
																			{
																				var ` = 0;
																				while (` < cs.length) {
																					var cl = cs[`];
																					++ `;
																					if (cl.guard != null) {
																						scan[0](cl.guard);
																					};
																					scan[0](cl.body);
																				};
																			};
																		};
																	};
																};
																case 10: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var c = `;
																		var t = `;
																		var e = `;
																		{
																			scan[0](c);
																			scan[0](t);
																			if (e != null) {
																				scan[0](e);
																			};
																		};
																	};
																};
																case 22: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var t = `;
																		var args = `;
																		{
																			if (t != null) {
																				scan[0](t);
																			};
																			{
																				var ` = 0;
																				while (` < args.length) {
																					var a = args[`];
																					++ `;
																					scan[0](a);
																				};
																			};
																		};
																	};
																};
																case 24: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var ` = `.def;
																		var ` = `.metadata;
																		var ` = `.pos;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var m = `;
																				{
																					if (m == "Ecto.Query") {
																						needs[0] = true;
																					};
																				};
																			};
																		} else {};
																	};
																};
																case 26: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var l = `;
																		var r = `;
																		{
																			scan[0](l);
																			scan[0](r);
																		};
																	};
																};
																case 42: {
																	var ` = `[0];
																	{
																		var cs = `;
																		{
																			{
																				var ` = 0;
																				while (` < cs.length) {
																					var cl = cs[`];
																					++ `;
																					scan[0](cl.body);
																				};
																			};
																		};
																	};
																};
																case 53: {
																	var ` = `[0];
																	{
																		var es = `;
																		{
																			{
																				var ` = 0;
																				while (` < es.length) {
																					var e = es[`];
																					++ `;
																					scan[0](e);
																				};
																			};
																		};
																	};
																};
																default: {}
															};
														};
													};
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															scan[0](s);
														};
													};
												};
											};
										};
										case 55: {
											var ` = `[0];
											{
												var stmts = `;
												{
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															@:ast(switch (s.def) {
	case ERequire(mod, _):
		if (mod == "Ecto.Query") has = true;	
	default:
}) {
																var ` = s.def;
																if (enumIndex ` == 47) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var mod = `;
																		{
																			if (mod == "Ecto.Query") {
																				has = true;
																			};
																		};
																	};
																} else {};
															};
														};
													};
													var scan = [null];
													scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
														if (n == null || n.def == null || needs[0]) {
															return;
														};
														@:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(m) }, _, _):
		if (m == "Ecto.Query") needs = true;	
	case ECall(t, _, args):
		if (t != null) scan(t);
		for (a  in  args) scan(a);	
	case EDef(_, _, _, body):
		scan(body);	
	case EDefp(_, _, _, body):
		scan(body);	
	case EBlock(es):
		for (e  in  es) scan(e);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(e, cs):
		scan(e);
		for (cl  in  cs) {
			if (cl.guard != null) scan(cl.guard);
			scan(cl.body);
		};	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EFn(cs):
		for (cl  in  cs) scan(cl.body);	
	default:
}) {
															var ` = n.def;
															switch (enumIndex `) {
																case 2: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	var ` = `[3];
																	{
																		var body = `;
																		{
																			scan[0](body);
																		};
																	};
																};
																case 3: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	var ` = `[3];
																	{
																		var body = `;
																		{
																			scan[0](body);
																		};
																	};
																};
																case 6: {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var e = `;
																		var cs = `;
																		{
																			scan[0](e);
																			{
																				var ` = 0;
																				while (` < cs.length) {
																					var cl = cs[`];
																					++ `;
																					if (cl.guard != null) {
																						scan[0](cl.guard);
																					};
																					scan[0](cl.body);
																				};
																			};
																		};
																	};
																};
																case 10: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var c = `;
																		var t = `;
																		var e = `;
																		{
																			scan[0](c);
																			scan[0](t);
																			if (e != null) {
																				scan[0](e);
																			};
																		};
																	};
																};
																case 22: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var t = `;
																		var args = `;
																		{
																			if (t != null) {
																				scan[0](t);
																			};
																			{
																				var ` = 0;
																				while (` < args.length) {
																					var a = args[`];
																					++ `;
																					scan[0](a);
																				};
																			};
																		};
																	};
																};
																case 24: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var ` = `.def;
																		var ` = `.metadata;
																		var ` = `.pos;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var m = `;
																				{
																					if (m == "Ecto.Query") {
																						needs[0] = true;
																					};
																				};
																			};
																		} else {};
																	};
																};
																case 26: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var l = `;
																		var r = `;
																		{
																			scan[0](l);
																			scan[0](r);
																		};
																	};
																};
																case 42: {
																	var ` = `[0];
																	{
																		var cs = `;
																		{
																			{
																				var ` = 0;
																				while (` < cs.length) {
																					var cl = cs[`];
																					++ `;
																					scan[0](cl.body);
																				};
																			};
																		};
																	};
																};
																case 53: {
																	var ` = `[0];
																	{
																		var es = `;
																		{
																			{
																				var ` = 0;
																				while (` < es.length) {
																					var e = es[`];
																					++ `;
																					scan[0](e);
																				};
																			};
																		};
																	};
																};
																default: {}
															};
														};
													};
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															scan[0](s);
														};
													};
												};
											};
										};
										default: {}
									};
								};
								needs[0] && ! has;
							}) {
								moduleContent += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + "require Ecto.Query\n";
							};
							moduleContent += (@:ast(switch (doBlockUnwrapped.def) {
	case EBlock(stmts) if (stmts.length == 1):
		switch (stmts[0].def) {
			case ERaw(code):
				var c = code;
				if (!StringTools.endsWith(c, "\n")) c += "\n";
				c;			
			default:
				indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);			
		};	
	default:
		indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);	
}) {
								var ` = doBlockUnwrapped.def;
								if (enumIndex ` == 53) {
									var ` = `[0];
									{
										var stmts = `;
										if (stmts.length == 1) {
											@:ast(switch (stmts[0].def) {
	case ERaw(code):
		var c = code;
		if (!StringTools.endsWith(c, "\n")) c += "\n";
		c;	
	default:
		indentStr(indent + 1) + print(doBlockUnwrapped, indent + 1);	
}) {
												var ` = stmts[0].def;
												if (enumIndex ` == 62) {
													var ` = `[0];
													{
														var code = `;
														{
															var c = code;
															if (! StringTools.endsWith(c, "\n")) {
																c += "\n";
															};
															c;
														};
													};
												} else {
													reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(doBlockUnwrapped, indent + 1);
												};
											};
										} else {
											reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(doBlockUnwrapped, indent + 1);
										};
									};
								} else {
									reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(doBlockUnwrapped, indent + 1);
								};
							});
							reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = prevModule;
							var moduleResult = "defmodule " + name + " do\n" + moduleContent + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end\n";
							reflaxe.elixir.ast.ElixirASTPrinter.currentUnusedFunctions = null;
							moduleResult;
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTPrinter.printNode(ast.def, indent);
				}
			};
		};
		return result;
	}

	static function printNode(node:reflaxe.elixir.ast.ElixirASTDef, indent:Int) {
		return @:ast(switch (node) {
	case EModule(name, attributes, body):
		var result = "defmodule ${name} do\n";
		var prevModuleCtx = currentModuleName;
		currentModuleName = name;
		for (attr  in  attributes) {
			result += indentStr(indent + 1) + printAttribute(attr) + "\n";
		};
		if (attributes.length > 0 && body.length > 0) {
			result += "\n";
		};
		inline function needsRepoAlias(stmts:Array<ElixirAST>):Bool {
			var hasAlias = false;
			var hasBare = false;
			for (s  in  stmts) switch (s.def) {
				case EAlias(module, as) if ((as == null || as == "Repo")):
					if (module != null && module.indexOf(".Repo") > 0) hasAlias = true;				
				default:
			};
			function scan(n:ElixirAST):Void {
				if (n == null || n.def == null || hasBare) return;
				switch (n.def) {
					case ERemoteCall({ def : EVar(m) }, _, _):
						if (m == "Repo") hasBare = true;					
					case ECall({ def : EVar(m) }, _, _):
						if (m == "Repo") hasBare = true;					
					case EDef(_, _, _, body):
						scan(body);					
					case EDefp(_, _, _, body):
						scan(body);					
					case EBlock(es):
						for (e  in  es) scan(e);					
					case EIf(c, t, e):
						scan(c);
						scan(t);
						if (e != null) scan(e);					
					case ECase(e, cs):
						scan(e);
						for (cl  in  cs) {
							if (cl.guard != null) scan(cl.guard);
							scan(cl.body);
						};					
					case ECond(cs):
						for (cl  in  cs) {
							scan(cl.condition);
							scan(cl.body);
						};					
					case EMatch(pat, rhs):
						scan(rhs);					
					case EBinary(_, l, r):
						scan(l);
						scan(r);					
					case ERemoteCall(m, _, args):
						scan(m);
						for (a  in  args) scan(a);					
					case ECall(t, _, args):
						if (t != null) scan(t);
						for (a  in  args) scan(a);					
					case ETuple(elts):
						for (e  in  elts) scan(e);					
					case EMap(pairs):
						for (p  in  pairs) {
							scan(p.key);
							scan(p.value);
						};					
					case EKeywordList(pairs):
						for (p  in  pairs) {
							scan(p.value);
						};					
					case EStructUpdate(st, fields):
						scan(st);
						for (f  in  fields) scan(f.value);					
					default:
				};
			};
			for (s  in  stmts) scan(s);
			return (hasBare && !hasAlias);
		};
		for (expr  in  body) {
			var e2 = switch (expr.def) {
				case EParen(inner):
					inner;				
				default:
					expr;				
			};
			result += indentStr(indent + 1) + print(e2, indent + 1) + "\n";
		};
		currentModuleName = prevModuleCtx;
		result += indentStr(indent) + "end\n";
		result;	
	case EDefmodule(name, doBlock):
		"defmodule ${name} do\n" + indentStr(indent + 1) + print(doBlock, indent + 1) + "\n" + indentStr(indent) + "end";	
	case EDef(name, args, guards, body):
		var argStr = printPatterns(args);
		var guardStr = guards != null ? " when " + print(guards, 0) : "";
		"def ${name}(${argStr})${guardStr} do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "end";	
	case EDefp(name, args, guards, body):
		var funcName = name;
		var argStr = printPatterns(args);
		var guardStr = guards != null ? " when " + print(guards, 0) : "";
		"defp ${funcName}(${argStr})${guardStr} do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "end";	
	case EDefmacro(name, args, guards, body):
		var argStr = printPatterns(args);
		var guardStr = guards != null ? " when " + print(guards, 0) : "";
		"defmacro ${name}(${argStr})${guardStr} do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "end";	
	case EDefmacrop(name, args, guards, body):
		var argStr = printPatterns(args);
		var guardStr = guards != null ? " when " + print(guards, 0) : "";
		"defmacrop ${name}(${argStr})${guardStr} do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "end";	
	case ECase(expr, clauses):
		"(" + ("case " + print(expr, 0) + " do\n" + [for (clause  in  clauses) indentStr(indent + 1) + printCaseClause(clause, indent + 1)].join("\n") + "\n" + indentStr(indent) + "end") + ")";	
	case ECond(clauses):
		var clauseStrs = [];
		for (clause  in  clauses) {
			var conditionStr = print(clause.condition, 0);
			var bodyStr = print(clause.body, indent + 2);
			var isMultiLine = switch (clause.body.def) {
				case EIf(_, _, _):
					true;				
				case ECase(_, _):
					true;				
				case ECond(_):
					true;				
				case EWith(_, _, _):
					true;				
				case EBlock(exprs) if (exprs.length > 1):
					true;				
				case _:
					bodyStr.indexOf("\n") >= 0;				
			};
			if (isMultiLine) {
				clauseStrs.push(indentStr(indent + 1) + conditionStr + " ->\n" + indentStr(indent + 2) + bodyStr);
			} else {
				clauseStrs.push(indentStr(indent + 1) + conditionStr + " -> " + bodyStr);
			};
		};
		"cond do\n" + clauseStrs.join("\n") + "\n" + indentStr(indent) + "end";	
	case EMatch(pattern, expr):
		var patternStr = printPattern(pattern);
		var keepInline = expr != null && expr.metadata != null && expr.metadata.keepInlineInAssignment == true;
		var isZeroPat = switch (pattern) {
			case PLiteral({ def : EInteger(v) }) if (v == 0):
				true;			
			default:
				false;			
		};
		if (isZeroPat && expr != null) {
			switch (expr.def) {
				case ECall(_, _, _) | ERemoteCall(_, _, _):
					return print(expr, 0);				
				case EParen(inner):
					switch (inner.def) {
						case ECall(_, _, _) | ERemoteCall(_, _, _):
							return print(inner, 0);						
						default:
					};				
				default:
			};
		};
		switch (pattern) {
			case PVar(name):
				var rhsName = switch (expr != null ? expr.def : null) {
					case EVar(varName):
						varName;					
					default:
						null;					
				};
				if (rhsName != null && rhsName == name && !ElixirASTBuilder.isTempPatternVarName(name)) {
					return "";
				};			
			default:
		};
		switch (pattern) {
			case PVar(name):
				if (expr != null) {
					switch (expr.def) {
						case EBinary(Match, innerLeft, rhsExpr):
							var innerLeftStr = print(innerLeft, 0);
							if (innerLeftStr == name) {
								return name + " = " + print(rhsExpr, indent);
							};						
						case EMatch(innerPattern, rhsExpr2):
							switch (innerPattern) {
								case PVar(innerName) if (innerName == name):
									return name + " = " + print(rhsExpr2, indent);								
								default:
							};						
						default:
					};
					var rhsPrinted = print(expr, indent);
					if (rhsPrinted != null) {
						var trimmed = StringTools.trim(rhsPrinted);
						var prefix = name + " = ";
						if (StringTools.startsWith(trimmed, prefix)) {
							var rest = StringTools.trim(trimmed.substr(prefix.length));
							return name + " = " + rest;
						};
					};
				};			
			default:
		};
		var isZeroPat = switch (pattern) {
			case PLiteral({ def : EInteger(v) }) if (v == 0):
				true;			
			default:
				false;			
		};
		if (isZeroPat && expr != null) {
			switch (expr.def) {
				case ECall(_, _, _) | ERemoteCall(_, _, _):
					return print(expr, 0);				
				case EParen(inner):
					switch (inner.def) {
						case ECall(_, _, _) | ERemoteCall(_, _, _):
							return print(inner, 0);						
						default:
					};				
				default:
			};
		};
		if (keepInline) {
			patternStr + " = " + print(expr, 0);
		} else {
			patternStr + " = " + print(expr, indent);
		};	
	case EWith(clauses, doBlock, elseBlock):
		var withClauses = [for (clause  in  clauses) printPattern(clause.pattern) + " <- " + print(clause.expr, 0)].join(",\n" + indentStr(indent + 1));
		var result = "with " + withClauses + " do\n" + indentStr(indent + 1) + print(doBlock, indent + 1) + "\n";
		if (elseBlock != null) {
			result += indentStr(indent) + "else\n" + indentStr(indent + 1) + print(elseBlock, indent + 1) + "\n";
		};
		result + indentStr(indent) + "end";	
	case EIf(condition, thenBranch, elseBranch):
		var isInline = isSimpleExpression(thenBranch) && (elseBranch == null || isSimpleExpression(elseBranch));
		var conditionStr = printIfCondition(condition);
		if (isInline && elseBranch != null) {
			"if " + conditionStr + ", do: " + print(thenBranch, 0) + ", else: " + print(elseBranch, 0);
		} else if (elseBranch != null) {
			"if " + conditionStr + " do\n" + indentStr(indent + 1) + print(thenBranch, indent + 1) + "\n" + indentStr(indent) + "else\n" + indentStr(indent + 1) + print(elseBranch, indent + 1) + "\n" + indentStr(indent) + "end";
		} else if (isInline) {
			var thenStr = switch (thenBranch.def) {
				case EBinary(Add, { def : EVar(v) }, rhs):
					v + " = " + v + " + " + print(rhs, 0);				
				default:
					print(thenBranch, 0);				
			};
			"if " + conditionStr + ", do: " + thenStr;
		} else {
			"if " + conditionStr + " do\n" + indentStr(indent + 1) + print(thenBranch, indent + 1) + "\n" + indentStr(indent) + "end";
		};	
	case EUnless(condition, body, elseBranch):
		if (elseBranch != null) {
			"unless " + print(condition, 0) + " do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "else\n" + indentStr(indent + 1) + print(elseBranch, indent + 1) + "\n" + indentStr(indent) + "end";
		} else {
			"unless " + print(condition, 0) + " do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n" + indentStr(indent) + "end";
		};	
	case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
		var result = "try do\n" + indentStr(indent + 1) + print(body, indent + 1) + "\n";
		if (rescue.length > 0) {
			result += indentStr(indent) + "rescue\n";
			for (r  in  rescue) {
				result += indentStr(indent + 1) + printRescueClause(r, indent + 1) + "\n";
			};
		};
		if (catchClauses.length > 0) {
			result += indentStr(indent) + "catch\n";
			for (c  in  catchClauses) {
				result += indentStr(indent + 1) + printCatchClause(c, indent + 1) + "\n";
			};
		};
		if (elseBlock != null) {
			result += indentStr(indent) + "else\n" + indentStr(indent + 1) + print(elseBlock, indent + 1) + "\n";
		};
		if (afterBlock != null) {
			result += indentStr(indent) + "after\n" + indentStr(indent + 1) + print(afterBlock, indent + 1) + "\n";
		};
		result + indentStr(indent) + "end";	
	case ERaise(exception, attributes):
		if (attributes != null) {
			"raise " + print(exception, 0) + ", " + print(attributes, 0);
		} else {
			"raise " + print(exception, 0);
		};	
	case EThrow(value):
		var valueStr = switch (value.def) {
			case EBinary(StringConcat, left, right):
				var leftStr = print(left, 0);
				var rightStr = print(right, 0);
				leftStr = leftStr.split("\n").join(" ");
				rightStr = rightStr.split("\n").join(" ");
				leftStr + " <> " + rightStr;			
			default:
				var result = print(value, 0);
				result.split("\n").join(" ");			
		};
		"throw(" + valueStr + ")";	
	case EList(elements):
		inline function tryListFromBlock(block:ElixirAST):Null<Array<ElixirAST>> {
			inline function normalizeName(n:String):String {
				var i = 0;
				while (i < n.length && n.charAt(i) == "_") i++;
				return i > 0 ? n.substr(i) : n;
			};
			return switch (block.def) {
				case EBlock(stmts) if (stmts.length >= 2):
					var accName:Null<String> = null;
					switch (stmts[0].def) {
						case EBinary(Match, { def : EVar(v) }, { def : EList(initEls) }) if (initEls.length == 0):
							accName = v;						
						case EMatch(PVar(varName), { def : EList(initElems) }) if (initElems.length == 0):
							accName = varName;						
						default:
					};
					if (accName == null) return null;
					var accNorm = normalizeName(accName);
					var outVals:Array<ElixirAST> = [];
					for (i  in  1 ... stmts.length) {
						switch (stmts[i].def) {
							case EBinary(Match, { def : EVar(lhs) }, rhs) if (normalizeName(lhs) == accNorm):
								switch (rhs.def) {
									case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
										switch (cargs[0].def) {
											case EVar(v) if (normalizeName(v) == accNorm):
												switch (cargs[1].def) {
													case EList(listElts) if (listElts.length == 1):
														outVals.push(listElts[0]);													
													default:
												};											
											default:
										};									
									case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
										switch (rhsExpr.def) {
											case EList(listElements) if (listElements.length == 1):
												outVals.push(listElements[0]);											
											default:
										};									
									default:
								};							
							default:
						};
					};
					return outVals.length > 0 ? outVals : null;				
				default:
					null;				
			};
		};
		"[" + [for (e  in  elements) {
			switch (e.def) {
				case EFor(_, _, _, _, _):
					"(" + print(e, 0) + ")";				
				case EBlock(exprs) if (exprs.length > 1):
					var recovered = tryListFromBlock(e);
					if (recovered != null) {
						"[" + [for (v  in  recovered) print(v, 0)].join(", ") + "]";
					} else {
						"(fn -> " + print(e, 0).rtrim() + " end).()";
					};				
				case EParen(inner) if (switch (inner.def) {
				case EBlock(es) if (es.length > 1):
					true;				
				default:
					false;				
			}):
					var recovered2 = tryListFromBlock(inner);
					if (recovered2 != null) {
						"[" + [for (v  in  recovered2) print(v, 0)].join(", ") + "]";
					} else {
						var innerStr = print(inner, 0).rtrim();
						if (StringTools.startsWith(innerStr, "(") && StringTools.endsWith(innerStr, ")")) {
							innerStr = innerStr.substr(1, innerStr.length - 2);
						};
						"(fn -> " + innerStr + " end).()";
					};				
				case EBlock(_):
					print(e, 0);				
				default:
					print(e, 0);				
			};
		}].join(", ") + "]";	
	case ETuple(elements):
		"{" + [for (e  in  elements) print(e, 0)].join(", ") + "}";	
	case EMap(pairs):
		"%{" + [for (p  in  pairs) {
			var key = print(p.key, 0);
			var value = p.value;
			var valueStr = switch (value.def) {
				case EBlock(exprs) if (exprs.length > 1):
					"(fn -> " + print(value, 0).rtrim() + " end).()";				
				case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
					"(" + print(value, 0) + ")";				
				case _:
					print(value, 0);				
			};
			key + " => " + valueStr;
		}].join(", ") + "}";	
	case EStruct(module, fields):
		var qualifiedModule = (function() {
			if (module.indexOf(".") != -1) return module;
			inline function appPrefix():Null<String> {
				if (currentModuleName == null) return observedAppPrefix;
				var idx = currentModuleName.indexOf("Web");
				return idx > 0 ? currentModuleName.substring(0, idx) : observedAppPrefix;
			};
			var p = appPrefix();
			return (p != null ? p + "." + module : module);
		})();
		"%" + qualifiedModule + "{" + [for (f  in  fields) {
			var value = f.value;
			var valueStr = switch (value.def) {
				case EBlock(exprs) if (exprs.length > 1):
					"(fn -> " + print(value, 0).rtrim() + " end).()";				
				case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
					"(" + print(value, 0) + ")";				
				case _:
					print(value, 0);				
			};
			f.key + ": " + valueStr;
		}].join(", ") + "}";	
	case EStructUpdate(struct, fields):
		"%{" + print(struct, 0) + " | " + [for (f  in  fields) {
			var value = f.value;
			var valueStr = switch (value.def) {
				case EBlock(exprs) if (exprs.length > 1):
					"(fn -> " + print(value, 0).rtrim() + " end).()";				
				case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
					"(" + print(value, 0) + ")";				
				case _:
					print(value, 0);				
			};
			f.key + ": " + valueStr;
		}].join(", ") + "}";	
	case EKeywordList(pairs):
		"[" + [for (p  in  pairs) {
			var value = p.value;
			var valueStr = switch (value.def) {
				case EBlock(exprs) if (exprs.length > 1):
					"(fn -> " + print(value, 0).rtrim() + " end).()";				
				case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
					"(" + print(value, 0) + ")";				
				case _:
					print(value, 0);				
			};
			p.key + ": " + valueStr;
		}].join(", ") + "]";	
	case EBitstring(segments):
		"<<" + [for (s  in  segments) printBinarySegment(s)].join(", ") + ">>";	
	case ECall(target, funcName, args):
		if (funcName == "assign_multiple" && target == null) {
			funcName = "assign";
		};
		if (funcName == "while_loop" && target == null && args.length == 2) {
			var condition = args[0];
			var body = args[1];
			var loopFuncName = "loop_" + (loopIdCounter++);
			var lines = [];
			lines.push("(fn ->");
			lines.push("  " + loopFuncName + " = fn " + loopFuncName + " ->");
			lines.push("    if " + print(condition, 0) + " do");
			lines.push("      " + print(body, 3));
			lines.push("      " + loopFuncName + ".(" + loopFuncName + ")");
			lines.push("    else");
			lines.push("      :ok");
			lines.push("    end");
			lines.push("  end");
			lines.push("  " + loopFuncName + ".(" + loopFuncName + ")");
			lines.push("end).()");
			lines.join("\n" + indentStr(indent));
		} else {
			var argStr = (function() {
				var parts:Array<String> = [];
				for (a  in  args) {
					var printed = printFunctionArg(a, indent + 1);
					parts.push(sanitizeArgPrinted(printed, indent + 1));
				};
				return parts.join(", ");
			})();
			if (target != null) {
				if (funcName == "new" && args.length == 0) {
					inline function appPrefix():Null<String> {
						if (currentModuleName == null) return observedAppPrefix;
						var idx = currentModuleName.indexOf("Web");
						return idx > 0 ? currentModuleName.substring(0, idx) : observedAppPrefix;
					};
					switch (target.def) {
						case EVar(n):
							var modStr = (function() {
								if (n.indexOf(".") == -1) {
									var p = appPrefix();
									return (p != null ? p + "." + n : n);
								} else {
									return n;
								};
							})();
							return "%" + modStr + "{}";						
						default:
					};
				};
				if (funcName == "") {
					var tStr = switch (target.def) {
						case EFn(_):
							"(" + print(target, indent) + ")";						
						case EParen(_):
							print(target, indent);						
						default:
							print(target, indent);						
					};
					tStr + ".(" + argStr + ")";
				} else {
					var isEnumMethod = switch (funcName) {
						case "map" | "filter" | "reduce" | "each" | "find" | "reject" | "take" | "drop" | "any" | "all" | "count" | "member" | "sort" | "reverse" | "zip" | "concat" | "flat_map" | "group_by" | "split" | "join" | "at" | "fetch" | "empty" | "sum" | "min" | "max" | "uniq" | "with_index":
							true;						
						default:
							false;						
					};
					if (isEnumMethod) {
						var receiverPrinted = print(target, indent);
						var firstArgStr = (function() {
							if (funcName == "join") {
								var trimmed = StringTools.trim(receiverPrinted);
								return StringTools.startsWith(trimmed, "(fn ->") ? receiverPrinted : "(fn -> " + receiverPrinted + " end).()";
							} else {
								return receiverPrinted;
							};
						})();
						var enumCall = "Enum." + funcName + "(" + firstArgStr;
						if (argStr.length > 0) {
							enumCall + ", " + argStr + ")";
						} else {
							enumCall + ")";
						};
					} else {
						if (funcName == "to_iso8601") {
							var tstr = print(target, indent);
							return "DateTime.to_iso8601(" + tstr + ")";
						};
						if (funcName == "push") {
							switch (target.def) {
								case EVar(varName):
									var first = varName.charAt(0);
									if (first == first.toLowerCase()) {
										var printedArg = args.length > 0 ? printFunctionArg(args[0]) : "";
										return varName + " = Enum.concat(" + varName + ", [" + printedArg + "])";
									};								
								default:
							};
						};
						var targetStr = switch (target.def) {
							case ECase(_, _) | ECond(_) | EWith(_, _, _):
								"(" + print(target, indent) + ") |> Kernel." + funcName;							
							case EIf(_, _, elseBranch) if (elseBranch != null):
								"(" + print(target, indent) + ") |> Kernel." + funcName;							
							default:
								var modStr = switch (target.def) {
									case EVar(name) if (name == "Repo"):
										var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
										if (idx > 0) currentModuleName.substring(0, idx) + ".Repo" else {
											if (observedAppPrefix != null) observedAppPrefix + ".Repo" else {
												try {
													var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
													if (app != null && app.length > 0) app + ".Repo" else name;
												} catch(e:Dynamic) {
													name;
												};
											};
										};									
									case EVar(name):
										var first = name.charAt(0);
										var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
										var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
										inline function isStdModule(n:String):Bool {
											return switch (n) {
												case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
													true;												
												default:
													false;												
											};
										};
										if (isUpper && idx > 0 && !isStdModule(name)) currentModuleName.substring(0, idx) + "." + name else name;									
									default:
										print(target, indent);									
								};
								modStr + "." + funcName;							
						};
						targetStr + "(" + argStr + ")";
					};
				};
			} else {
				funcName + "(" + argStr + ")";
			};
		};	
	case EMacroCall(macroName, args, doBlock):
		var argStr = [for (a  in  args) print(a, 0)].join(", ");
		var unwrappedDo = switch (doBlock.def) {
			case EParen(inner):
				inner;			
			default:
				doBlock;			
		};
		macroName + (args.length > 0 ? " " + argStr : "") + " do\n" + indentStr(indent + 1) + print(unwrappedDo, indent + 1) + "\n" + indentStr(indent) + "end";	
	case ERemoteCall(module, funcName, args):
		switch (module.def) {
			case EVar(m) if (m == "Date_Impl_"):
				if (funcName == "get_time" && args.length == 1) {
					return "DateTime.to_unix(" + printFunctionArg(args[0], indent) + ", :millisecond)";
				};
				if (funcName == "from_string" && args.length == 1) {
					return printFunctionArg(args[0], indent);
				};			
			default:
		};
		var argStr = (function() {
			switch (module.def) {
				case EVar(m) if (m == "Assert" && (funcName == "is_true" || funcName == "is_false") && args.length >= 1):
					var parts:Array<String> = [];
					var firstPrinted = "(fn -> " + print(args[0], indent) + " end).()";
					parts.push(firstPrinted);
					for (i  in  1 ... args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
					return parts.join(", ");				
				default:
			};
			if (funcName == "changeset" && args.length >= 1) {
				var parts:Array<String> = [];
				var firstPrinted = print(args[0], 0);
				var needsQual = false;
				if (StringTools.startsWith(firstPrinted, "%")) {
					var open = firstPrinted.indexOf("{");
					var closeDot = firstPrinted.indexOf(".");
					needsQual = (open > 1 && (closeDot == -1 || closeDot > open));
				};
				if (needsQual) {
					var remote = printQualifiedModule(module);
					parts.push("%" + remote + "{}");
				} else {
					parts.push(firstPrinted);
				};
				for (i  in  1 ... args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
				return parts.join(", ");
			} else {
				var s:String;
				var mstrTmp = printQualifiedModule(module);
				if (mstrTmp == "Enum" && funcName == "join" && args.length >= 1) {
					var parts:Array<String> = [];
					var firstPrintedRaw = print(args[0], indent);
					var trimmed = StringTools.trim(firstPrintedRaw);
					var firstPrinted = StringTools.startsWith(trimmed, "(fn ->") ? firstPrintedRaw : "(fn -> " + firstPrintedRaw + " end).()";
					parts.push(firstPrinted);
					for (i  in  1 ... args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
					s = parts.join(", ");
				} else {
					s = [for (a  in  args) sanitizeArgPrinted(printFunctionArg(a, indent), indent)].join(", ");
				};
				var mstr = printQualifiedModule(module);
				if (mstr == "Ecto.Query" && funcName == "from") {
					inline function camelize(x:String):String {
						var parts = x.split("_");
						var out = [];
						for (p  in  parts) if (p.length > 0) out.push(p.charAt(0).toUpperCase() + p.substr(1));
						return out.join("");
					};
					var idxIn = s.indexOf(" in :");
					if (idxIn != -1) {
						var start = idxIn + 6;
						var j = start;
						while (j < s.length) {
							var ch = s.charAt(j);
							var isAlnum = ~/^[A-Za-z0-9_]$/.match(ch);
							if (!isAlnum) break;
							j++;
						};
						var raw = s.substr(start, j - start);
						if (raw.length > 0) {
							var app = (function() {
								var pfx:Null<String> = null;
								if (currentModuleName != null) {
									var w = currentModuleName.indexOf("Web");
									if (w > 0) pfx = currentModuleName.substring(0, w);
								};
								if (pfx == null) pfx = observedAppPrefix;
								if (pfx == null) {
									try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch(e:Dynamic) { };
								};
								return pfx;
							})();
							if (app != null && app.length > 0) {
								s = s.substr(0, idxIn + 4) + " " + app + "." + camelize(raw) + s.substr(j);
							};
						};
					};
				};
				if ((mstr == reflaxe.elixir.PhoenixMapper.getAppModuleName() + ".Repo" || StringTools.endsWith(mstr, ".Repo")) && (funcName == "get" || funcName == "one")) {
					var comma = s.indexOf(",");
					var firstArg = comma != -1 ? s.substr(0, comma) : s;
					var trimmed = StringTools.trim(firstArg);
					inline function isBareModule(name:String):Bool {
						return name.length > 0 && name.indexOf(".") == -1 && ~/^[A-Z][A-Za-z0-9_]*$/.match(name);
					};
					var app = (function() {
						var pfx:Null<String> = null;
						if (currentModuleName != null) {
							var w = currentModuleName.indexOf("Web");
							if (w > 0) pfx = currentModuleName.substring(0, w);
						};
						if (pfx == null) pfx = observedAppPrefix;
						if (pfx == null) {
							try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch(e:Dynamic) { };
						};
						return pfx;
					})();
					if (app != null && isBareModule(trimmed)) {
						var rest = comma != -1 ? s.substr(comma) : "";
						s = app + "." + trimmed + rest;
					};
				};
				return s;
			};
		})();
		var moduleStr = printQualifiedModule(module);
		moduleStr + "." + funcName + "(" + argStr + ")";	
	case EPipe(left, right):
		print(left, 0) + " |> " + print(right, 0);	
	case EBinary(op, left, right):
		if (op == Remainder) {
			var leftStr = print(left, 0);
			var rightStr = print(right, 0);
			"rem(" + leftStr + ", " + rightStr + ")";
		} else if (isBitwiseOp(op)) {
			var funcName = bitwiseOpToFunction(op);
			var leftStr = print(left, 0);
			var rightStr = print(right, 0);
			"Bitwise." + funcName + "(" + leftStr + ", " + rightStr + ")";
		} else {
			if (op == Match) {
				var isZeroLhs = switch (left.def) {
					case EInteger(v) if (v == 0):
						true;					
					default:
						false;					
				};
				if (isZeroLhs) {
					switch (right.def) {
						case ECall(_, _, _) | ERemoteCall(_, _, _):
							return print(right, 0);						
						case EParen(innerP):
							switch (innerP.def) {
								case ECall(_, _, _) | ERemoteCall(_, _, _):
									return print(innerP, 0);								
								default:
							};						
						default:
					};
				};
				var leftStr0 = print(left, 0);
				if (leftStr0 == null || StringTools.trim(leftStr0).length == 0) leftStr0 = "_";
				switch (right.def) {
					case EBinary(Match, innerLeft, rhsExpr):
						var innerLeftStr = print(innerLeft, 0);
						if (innerLeftStr == leftStr0) {
							return leftStr0 + " = " + print(rhsExpr, 0);
						};					
					case EMatch(innerPattern, rhsExpr2):
						var lhsName:Null<String> = switch (innerPattern) {
							case PVar(nm):
								nm;							
							default:
								null;							
						};
						if (lhsName != null && lhsName == leftStr0) {
							return leftStr0 + " = " + print(rhsExpr2, 0);
						};					
					default:
				};
				var rightPrinted0 = print(right, 0);
				if (rightPrinted0 != null) {
					var trimmed = StringTools.trim(rightPrinted0);
					var prefix = leftStr0 + " = ";
					if (StringTools.startsWith(trimmed, prefix)) {
						var rest = StringTools.trim(trimmed.substr(prefix.length));
						return leftStr0 + " = " + rest;
					};
				};
			};
			if (op == Add) {
				switch (left.def) {
					case EInteger(a):
						switch (right.def) {
							case EInteger(b):
								return Std.string(a + b);							
							default:
						};					
					default:
				};
			};
			var needsParens = needsParentheses(node);
			var opStr = binaryOpToString(op);
			var leftStr = switch (left.def) {
				case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
					"(" + print(left, 0) + ")";				
				default:
					print(left, 0);				
			};
			var rightStr = switch (right) {
				case null:
					"0";				
				case _:
					switch (right.def) {
						case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
							if (op == Match) print(right, 0) else "(" + print(right, 0) + ")";						
						default:
							print(right, 0);						
					};				
			};
			if (leftStr == null || leftStr.length == 0 || StringTools.trim(leftStr).length == 0) {
				if (op == Match) leftStr = "_" else leftStr = "0";
			};
			if (rightStr == null || rightStr.length == 0) rightStr = "0";
			var result = leftStr + " " + opStr + " " + rightStr;
			needsParens ? "(" + result + ")" : result;
		};	
	case EUnary(op, expr):
		unaryOpToString(op) + print(expr, 0);	
	case EField(target, field):
		if (field == "length") {
			return "length(" + print(target, 0) + ")";
		};
		if (field == "to_iso8601") {
			return "DateTime.to_iso8601(" + print(target, 0) + ")";
		};
		switch (target.def) {
			case EAtom(atomBase):
				var combined = atomBase + "." + field;
				var tmp = makeAST(EAtom(combined));
				print(tmp, 0);			
			default:
				print(target, 0) + "." + field;			
		};	
	case EAccess(target, key):
		print(target, 0) + "[" + print(key, 0) + "]";	
	case ERange(start, end, exclusive):
		print(start, 0) + (exclusive ? "..." : "..") + print(end, 0);	
	case EAtom(value):
		var atomStr:String = value;
		if (atomStr != null && atomStr.length > 0 && atomStr.charAt(0) == ":") {
			atomStr = atomStr.substr(1);
		};
		var needsQuotes = false;
		if (atomStr.length == 0) {
			needsQuotes = true;
		} else {
			var firstChar = atomStr.charAt(0);
			if (!isLetter(firstChar) && firstChar != "_") {
				needsQuotes = true;
			} else {
				var i = 1;
				var len = atomStr.length;
				var lastChar = atomStr.charAt(len - 1);
				var endsWithBangOrQuestion = (lastChar == "!" || lastChar == "?");
				var checkUntil = endsWithBangOrQuestion ? len - 1 : len;
				while (i < checkUntil && !needsQuotes) {
					var c = atomStr.charAt(i);
					if (!isLetter(c) && !isDigit(c) && c != "_") {
						needsQuotes = true;
					};
					i++;
				};
			};
		};
		if (needsQuotes) {
			":\"" + atomStr + "\"";
		} else {
			":" + atomStr;
		};	
	case EString(value):
		inline function sanitizeJoinArgInInterpolatedString(s:String):String {
			if (s == null || s.indexOf("#{") == -1 || s.indexOf("Enum.join(") == -1) return s;
			var out = new StringBuf();
			var i = 0;
			while (i < s.length) {
				var open = s.indexOf("#{", i);
				if (open == -1) {
					out.add(s.substr(i));
					break;
				};
				out.add(s.substr(i, open - i));
				var k = open + 2;
				var depth = 1;
				while (k < s.length && depth > 0) {
					var ch = s.charAt(k);
					if (ch == "{") depth++ else if (ch == "}") depth--;
					k++;
				};
				var inner = s.substr(open + 2, (k - 1) - (open + 2));
				var innerTrim = StringTools.trim(inner);
				var needsWrap = (inner.indexOf("\n") != -1) || (inner.indexOf("=") != -1 && inner.indexOf("==") == -1);
				if (needsWrap && !StringTools.startsWith(innerTrim, "(fn ->")) {
					inner = "(fn -> " + inner + " end).()";
				};
				out.add("#{" + inner + "}");
				i = k;
			};
			return out.toString();
		};
		inline function sanitizeInterpolationsInString(src:String):String {
			if (src == null || src.indexOf("#{") == -1) return src;
			var buf = new StringBuf();
			var i0 = 0;
			while (i0 < src.length) {
				var o = src.indexOf("#{", i0);
				if (o == -1) {
					buf.add(src.substr(i0));
					break;
				};
				buf.add(src.substr(i0, o - i0));
				var k0 = o + 2;
				var dep = 1;
				while (k0 < src.length && dep > 0) {
					var ch2 = src.charAt(k0);
					if (ch2 == "{") dep++ else if (ch2 == "}") dep--;
					k0++;
				};
				var inner2 = src.substr(o + 2, (k0 - 1) - (o + 2));
				var trimmed2 = StringTools.trim(inner2);
				var already = StringTools.startsWith(trimmed2, "(fn ->");
				var outInner = already ? inner2 : "(fn -> " + inner2 + " end).()";
				buf.add("#{" + outInner + "}");
				i0 = k0;
			};
			return buf.toString();
		};
		var strVal = sanitizeJoinArgInInterpolatedString(value);
		strVal = sanitizeInterpolationsInString(strVal);
		"\"" + escapeString(strVal) + "\"";	
	case EInteger(value):
		Std.string(value);	
	case EFloat(value):
		Std.string(value);	
	case EBoolean(value):
		value ? "true" : "false";	
	case ENil:
		"nil";	
	case ECharlist(value):
		"'" + escapeString(value) + "'";	
	case EVar(name):
		inline function safeIdent(nm:String):String {
			return switch (nm) {
				case "fn" | "do" | "end" | "case" | "cond" | "try" | "rescue" | "catch" | "after" | "receive" | "quote" | "unquote" | "when" | "and" | "or" | "not":
					nm + "_";				
				default:
					nm;				
			};
		};
		var printed = safeIdent(name);
		if (name != null && name.length >= 23 && name.substr(0, 23) == "__elixir_switch_result_") {
			printed = "switch_result_" + name.substr(23);
		};
		printed;	
	case EPin(expr):
		"^" + print(expr, 0);	
	case EUnderscore:
		"_";	
	case EFor(generators, filters, body, into, uniq):
		var genStr = [for (g  in  generators) printPattern(g.pattern) + " <- " + print(g.expr, 0)].join(", ");
		var filterStr = filters.length > 0 ? ", " + [for (f  in  filters) print(f, 0)].join(", ") : "";
		var options = [];
		if (into != null) options.push("into: " + print(into, 0));
		if (uniq) options.push("uniq: true");
		var optStr = options.length > 0 ? ", " + options.join(", ") : "";
		"for " + genStr + filterStr + optStr + ", do: " + print(body, 0);	
	case EFn(clauses):
		if (clauses.length == 1 && clauses[0].guard == null) {
			var clause = clauses[0];
			var argStr = printPatterns(clause.args);
			var paramPart = clause.args.length == 0 ? "" : " " + argStr;
			var bodyStr = print(clause.body, indent + 1);
			inline function stripBareNumericLines(s:String):String {
				if (s == null || s.length == 0) return s;
				var lines = s.split("\n");
				var cleaned:Array<String> = [];
				for (ln  in  lines) {
					var t = StringTools.trim(ln);
					if (t == "1" || t == "0") continue;
					cleaned.push(ln);
				};
				return cleaned.join("\n");
			};
			bodyStr = stripBareNumericLines(bodyStr);
			var isMultiLine = switch (clause.body.def) {
				case EIf(_, _, _):
					true;				
				case ECase(_, _):
					true;				
				case ECond(_):
					true;				
				case EBlock(exprs) if (exprs.length > 1):
					true;				
				case _:
					bodyStr.indexOf("\n") >= 0;				
			};
			if (isMultiLine) {
				"fn" + paramPart + " ->\n" + indentStr(indent + 1) + bodyStr + "\n" + indentStr(indent) + "end";
			} else {
				"fn" + paramPart + " -> " + bodyStr + " end";
			};
		} else {
			"fn\n" + [for (clause  in  clauses) indentStr(indent + 1) + printPatterns(clause.args) + (clause.guard != null ? " when " + print(clause.guard, 0) : "") + " ->\n" + indentStr(indent + 2) + print(clause.body, indent + 2)].join("\n") + "\n" + indentStr(indent) + "end";
		};	
	case ECapture(expr, arity):
		if (arity != null) {
			"&" + print(expr, 0) + "/" + arity;
		} else {
			"&" + print(expr, 0);
		};	
	case EAlias(module, as):
		if (as != null) {
			"alias " + module + ", as: " + as;
		} else {
			"alias " + module;
		};	
	case EImport(module, only, except):
		var result = "import " + module;
		if (only != null) {
			result += ", only: [" + [for (o  in  only) o.name + ": " + o.arity].join(", ") + "]";
		} else if (except != null) {
			result += ", except: [" + [for (e  in  except) e.name + ": " + e.arity].join(", ") + "]";
		};
		result;	
	case EUse(module, options):
		if (options.length == 1) {
			switch (options[0].def) {
				case EKeywordList(pairs):
					"use " + module + ", " + [for (p  in  pairs) {
						var value = switch (p.value.def) {
							case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
								"(" + print(p.value, 0) + ")";							
							case _:
								print(p.value, 0);							
						};
						p.key + ": " + value;
					}].join(", ");				
				case _:
					"use " + module + ", " + print(options[0], 0);				
			};
		} else if (options.length > 0) {
			"use " + module + ", " + [for (o  in  options) print(o, 0)].join(", ");
		} else {
			"use " + module;
		};	
	case ERequire(module, as):
		if (as != null) {
			"require " + module + ", as: " + as;
		} else {
			"require " + module;
		};	
	case EQuote(options, expr):
		var optStr = options.length > 0 ? " " + [for (o  in  options) print(o, 0)].join(", ") + "," : "";
		switch (expr.def) {
			case EBlock(_):
				"quote" + optStr + " do\n" + indentStr(indent + 1) + print(expr, indent + 1) + "\n" + indentStr(indent) + "end";			
			case _:
				"quote" + optStr + " do: " + print(expr, 0);			
		};	
	case EUnquote(expr):
		"unquote(" + print(expr, 0) + ")";	
	case EUnquoteSplicing(expr):
		"unquote_splicing(" + print(expr, 0) + ")";	
	case EReceive(clauses, after):
		var result = "receive do\n";
		for (clause  in  clauses) {
			result += indentStr(indent + 1) + printCaseClause(clause, indent + 1) + "\n";
		};
		if (after != null) {
			result += indentStr(indent) + "after\n" + indentStr(indent + 1) + print(after.timeout, 0) + " ->\n" + indentStr(indent + 2) + print(after.body, indent + 2) + "\n";
		};
		result + indentStr(indent) + "end";	
	case ESend(target, message):
		"send(" + print(target, 0) + ", " + print(message, 0) + ")";	
	case EBlock(expressions):
		inline function isBareNumericSentinel(e:ElixirAST):Bool {
			return switch (e.def) {
				case EInteger(v) if (v == 0 || v == 1):
					true;				
				case EFloat(f) if (f == 0.0):
					true;				
				case ERaw(code) if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")):
					true;				
				default:
					false;				
			};
		};
		var statements = [for (e  in  expressions) if (!isBareNumericSentinel(e)) e];
		if (statements.length == 0) {
			"";
		} else if (statements.length == 1) {
			print(statements[0], indent);
		} else {
			var parts = [];
			var printed:Array<String> = [];
			for (expr  in  statements) {
				var str = print(expr, indent);
				if (str != null && str.trim().length > 0) {
					printed.push(str);
				};
			};
			for (i  in  0 ... printed.length) {
				parts.push(printed[i]);
				if (i < printed.length - 1) {
					parts.push("\n" + indentStr(indent));
				};
			};
			parts.join("");
		};	
	case EParen(expr):
		"(" + print(expr, 0) + ")";	
	case EDo(body):
		inline function isBareNumericSentinelInDo(e:ElixirAST):Bool {
			return switch (e.def) {
				case EInteger(v) if (v == 0 || v == 1):
					true;				
				case EFloat(f) if (f == 0.0):
					true;				
				case ERaw(code) if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")):
					true;				
				default:
					false;				
			};
		};
		var bodyStmts = [for (e  in  body) if (!isBareNumericSentinelInDo(e)) e];
		"do\n" + [for (expr  in  bodyStmts) indentStr(indent + 1) + print(expr, indent + 1)].join("\n") + "\n" + indentStr(indent) + "end";	
	case EModuleAttribute(name, value):
		"@" + name + " " + print(value, indent);	
	case EModuledoc(content):
		"@moduledoc \"\"\"" + "\n" + content + "\n" + "\"\"\"";	
	case EDoc(content):
		"@doc \"\"\"" + "\n" + content + "\n" + "\"\"\"";	
	case ESpec(signature):
		"@spec " + signature;	
	case ETypeDef(name, definition):
		"@type " + name + " :: " + definition;	
	case ESigil(type, content, modifiers):
		inline function normalizeHeexIndent(s:String):String {
			if (s == null || s.length == 0) return s;
			var lines = s.split("\n");
			var start = 0;
			while (start < lines.length && StringTools.trim(lines[start]) == "") start++;
			var endIdx = lines.length - 1;
			while (endIdx >= start && StringTools.trim(lines[endIdx]) == "") endIdx--;
			if (start > endIdx) return "";
			var slice = lines.slice(start, endIdx + 1);
			var minIndent = 1000000;
			for (ln  in  slice) {
				if (StringTools.trim(ln) == "") continue;
				var i = 0;
				while (i < ln.length && ln.charAt(i) == " ") i++;
				if (i < minIndent) minIndent = i;
			};
			if (minIndent == 1000000) minIndent = 0;
			var out = new StringBuf();
			for (i  in  0 ... slice.length) {
				var ln = slice[i];
				if (minIndent > 0 && ln.length >= minIndent) ln = ln.substr(minIndent);
				out.add(ln);
				if (i < slice.length - 1) out.add("\n");
			};
			return out.toString();
		};
		inline function flattenNestedHeex(s:String):String {
			if (s == null || s.indexOf("<%=") == -1) return s;
			var out = new StringBuf();
			var i = 0;
			while (i < s.length) {
				var o = s.indexOf("<% =".replace(" ", ""), i);
				if (o == -1) {
					out.add(s.substr(i));
					break;
				};
				out.add(s.substr(i, o - i));
				var c = s.indexOf("%>", o + 3);
				if (c == -1) {
					out.add(s.substr(o));
					break;
				};
				var inner = StringTools.trim(s.substr(o + 3, c - (o + 3)));
				if (StringTools.startsWith(inner, "~H\"\"\"")) {
					var st = inner.indexOf("\"\"\"");
					if (st != -1) {
						var bs = st + 3;
						var be = inner.indexOf("\"\"\"", bs);
						if (be != -1) {
							out.add(inner.substr(bs, be - bs));
							i = c + 2;
							continue;
						};
					};
				};
				out.add(s.substr(o, (c + 2) - o));
				i = c + 2;
			};
			var flattened = out.toString();
			if (flattened.indexOf("<%= ~H\"\"\"") != -1) {
				flattened = flattened.split("<%= ~H\"\"\"").join("");
				flattened = flattened.split("\"\"\" %>").join("");
			};
			return flattened;
		};
		inline function rewriteInlineIfDoToBlock(s:String):String {
			if (s == null || s.indexOf(", do:") == -1) return s;
			var i = 0;
			var out = new StringBuf();
			while (i < s.length) {
				var o = s.indexOf("<% =".replace(" ", ""), i);
				if (o == -1) {
					out.add(s.substr(i));
					break;
				};
				out.add(s.substr(i, o - i));
				var c = s.indexOf("%>", o + 3);
				if (c == -1) {
					out.add(s.substr(o));
					break;
				};
				var inner = StringTools.trim(s.substr(o + 3, c - (o + 3)));
				if (StringTools.startsWith(inner, "if ")) {
					var rest = StringTools.trim(inner.substr(3));
					var idx = rest.indexOf(", do: \"");
					var q = "\"";
					if (idx == -1) {
						idx = rest.indexOf(", do: ''");
						q = "'";
					};
					if (idx != -1) {
						var cond = StringTools.trim(rest.substr(0, idx));
						var after = rest.substr(idx + 7);
						if (q == "'") after = rest.substr(idx + 7);
						var endMark = (q == "\"") ? "\"" + ", else:" : "'" + ", else:";
						var ei = after.indexOf(endMark);
						if (ei != -1) {
							var th = after.substr(0, ei);
							var rem = after.substr(ei + endMark.length);
							var el:String = null;
							if (rem.length >= 1 && rem.charAt(0) == q) {
								rem = rem.substr(1);
								var e2 = rem.indexOf((q == "\"") ? "\"" : "'");
								if (e2 != -1) el = rem.substr(0, e2);
							};
							out.add("<%= if " + cond + " do %>");
							out.add(th);
							if (el != null && el != "") {
								out.add("<% else %>" + el);
							};
							out.add("<% end %>");
							i = c + 2;
							continue;
						};
					};
				};
				out.add(s.substr(o, (c + 2) - o));
				i = c + 2;
			};
			return out.toString();
		};
		var normalized = normalizeHeexIndent(content);
		normalized = flattenNestedHeex(normalized);
		"~" + type + "\"\"\"" + "\n" + normalized + "\n" + "\"\"\"" + modifiers;	
	case ERaw(code):
		inline function camelize(s:String):String {
			var parts = s.split("_");
			var out = [];
			for (p  in  parts) if (p.length > 0) out.push(p.charAt(0).toUpperCase() + p.substr(1));
			return out.join("");
		};
		var out = code;
		if (out.indexOf("Ecto.Query.from(") != -1) {
			var pfx:Null<String> = null;
			if (currentModuleName != null) {
				var idxA = currentModuleName.indexOf("Web");
				if (idxA > 0) pfx = currentModuleName.substring(0, idxA) else {
					var idxB = currentModuleName.indexOf(".Repo");
					if (idxB > 0) pfx = currentModuleName.substring(0, idxB);
				};
			};
			if (pfx == null && observedAppPrefix != null) pfx = observedAppPrefix;
			if (pfx == null) {
				try pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch(e:Dynamic) { };
			};
			if (pfx != null && pfx.length > 0) {
				var buf = new StringBuf();
				var i = 0;
				while (i < out.length) {
					if (i + 5 < out.length && out.substr(i, 5) == " in :") {
						var j = i + 5;
						var name = new StringBuf();
						while (j < out.length) {
							var ch = out.charAt(j);
							var isAlnum = ~/^[A-Za-z0-9_]$/.match(ch);
							if (!isAlnum) break;
							name.add(ch);
							j++;
						};
						var raw = name.toString();
						if (raw.length > 0) {
							buf.add(" in ");
							buf.add(pfx);
							buf.add(".");
							buf.add(camelize(raw));
							i = j;
							continue;
						};
					};
					buf.add(out.charAt(i));
					i++;
				};
				out = buf.toString();
			};
		};
		inline function sanitizeInterpolationsInRawString(src:String):String {
			if (src == null || src.indexOf("#{") == -1) return src;
			var buf = new StringBuf();
			var i0 = 0;
			while (i0 < src.length) {
				var o = src.indexOf("#{", i0);
				if (o == -1) {
					buf.add(src.substr(i0));
					break;
				};
				buf.add(src.substr(i0, o - i0));
				var k0 = o + 2;
				var dep = 1;
				while (k0 < src.length && dep > 0) {
					var ch = src.charAt(k0);
					if (ch == "{") dep++ else if (ch == "}") dep--;
					k0++;
				};
				var inner = src.substr(o + 2, (k0 - 1) - (o + 2));
				var trimmed = StringTools.trim(inner);
				var alreadyIife = StringTools.startsWith(trimmed, "(fn ->");
				var needsWrap = !alreadyIife;
				var innerOut = needsWrap ? "(fn -> " + inner + " end).()" : inner;
				buf.add("#{" + innerOut + "}");
				i0 = k0;
			};
			return buf.toString();
		};
		out = sanitizeInterpolationsInRawString(out);
		out;	
	case EAssign(name):
		"@" + name;	
	case EFragment(tag, attributes, children):
		"<" + tag + printAttributes(attributes) + ">" + [for (c  in  children) print(c, 0)].join("") + "</" + tag + ">";	
}) switch (@:exhaustive enumIndex node) {
			case 0: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var name = `;
					var attributes = `;
					var body = `;
					{
						var result = "defmodule " + name + " do\n";
						var prevModuleCtx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName;
						reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = name;
						{
							var ` = 0;
							while (` < attributes.length) {
								var attr = attributes[`];
								++ `;
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printAttribute(attr) + "\n";
							};
						};
						if (attributes.length > 0 && body.length > 0) {
							result += "\n";
						};
						{};
						{
							var ` = 0;
							while (` < body.length) {
								var expr = body[`];
								++ `;
								var e2 = @:ast(switch (expr.def) {
	case EParen(inner):
		inner;	
	default:
		expr;	
}) {
									var ` = expr.def;
									if (enumIndex ` == 54) {
										var ` = `[0];
										{
											var inner = `;
											{
												inner;
											};
										};
									} else {
										expr;
									};
								};
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(e2, indent + 1) + "\n";
							};
						};
						reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName = prevModuleCtx;
						result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end\n";
						result;
					};
				};
			};
			case 1: {
				var ` = node[0];
				var ` = node[1];
				{
					var name = `;
					var doBlock = `;
					{
						"defmodule " + name + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(doBlock, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 2: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				{
					var name = `;
					var args = `;
					var guards = `;
					var body = `;
					{
						var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(args);
						var guardStr = if (guards != null) {
							" when " + reflaxe.elixir.ast.ElixirASTPrinter.print(guards, 0);
						} else {
							"";
						};
						"def " + name + "(" + argStr + ")" + guardStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 3: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				{
					var name = `;
					var args = `;
					var guards = `;
					var body = `;
					{
						var funcName = name;
						var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(args);
						var guardStr = if (guards != null) {
							" when " + reflaxe.elixir.ast.ElixirASTPrinter.print(guards, 0);
						} else {
							"";
						};
						"defp " + funcName + "(" + argStr + ")" + guardStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 4: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				{
					var name = `;
					var args = `;
					var guards = `;
					var body = `;
					{
						var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(args);
						var guardStr = if (guards != null) {
							" when " + reflaxe.elixir.ast.ElixirASTPrinter.print(guards, 0);
						} else {
							"";
						};
						"defmacro " + name + "(" + argStr + ")" + guardStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 5: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				{
					var name = `;
					var args = `;
					var guards = `;
					var body = `;
					{
						var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(args);
						var guardStr = if (guards != null) {
							" when " + reflaxe.elixir.ast.ElixirASTPrinter.print(guards, 0);
						} else {
							"";
						};
						"defmacrop " + name + "(" + argStr + ")" + guardStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 6: {
				var ` = node[0];
				var ` = node[1];
				{
					var expr = `;
					var clauses = `;
					{
						"(" + ("case " + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0) + " do\n" + {
							var ` = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printCaseClause(clause, indent + 1));
								};
							};
							`;
						}.join("\n") + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end") + ")";
					};
				};
			};
			case 7: {
				var ` = node[0];
				{
					var clauses = `;
					{
						var clauseStrs = [];
						{
							var ` = 0;
							while (` < clauses.length) {
								var clause = clauses[`];
								++ `;
								var conditionStr = reflaxe.elixir.ast.ElixirASTPrinter.print(clause.condition, 0);
								var bodyStr = reflaxe.elixir.ast.ElixirASTPrinter.print(clause.body, indent + 2);
								var isMultiLine = @:ast(switch (clause.body.def) {
	case EIf(_, _, _):
		true;	
	case ECase(_, _):
		true;	
	case ECond(_):
		true;	
	case EWith(_, _, _):
		true;	
	case EBlock(exprs) if (exprs.length > 1):
		true;	
	case _:
		bodyStr.indexOf("\n") >= 0;	
}) {
									var ` = clause.body.def;
									switch (enumIndex `) {
										case 6: {
											var ` = `[0];
											var ` = `[1];
											{
												true;
											};
										};
										case 7: {
											var ` = `[0];
											{
												true;
											};
										};
										case 9: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												true;
											};
										};
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												true;
											};
										};
										case 53: {
											var ` = `[0];
											{
												var exprs = `;
												if (exprs.length > 1) {
													true;
												} else {
													bodyStr.indexOf("\n", null) >= 0;
												};
											};
										};
										default: {
											bodyStr.indexOf("\n", null) >= 0;
										}
									};
								};
								if (isMultiLine) {
									clauseStrs.push(reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + conditionStr + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 2) + bodyStr);
								} else {
									clauseStrs.push(reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + conditionStr + " -> " + bodyStr);
								};
							};
						};
						"cond do\n" + clauseStrs.join("\n") + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 8: {
				var ` = node[0];
				var ` = node[1];
				{
					var pattern = `;
					var expr = `;
					{
						var patternStr = reflaxe.elixir.ast.ElixirASTPrinter.printPattern(pattern);
						var keepInline = expr != null && expr.metadata != null && expr.metadata.keepInlineInAssignment == true;
						var isZeroPat = @:ast(switch (pattern) {
	case PLiteral({ def : EInteger(v) }) if (v == 0):
		true;	
	default:
		false;	
}) if (enumIndex pattern == 1) {
							var ` = pattern[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 33) {
									var ` = `[0];
									{
										var v = `;
										if (v == 0) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
						} else {
							false;
						};
						if (isZeroPat && expr != null) {
							@:ast(switch (expr.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(expr, 0);	
	case EParen(inner):
		switch (inner.def) {
			case ECall(_, _, _) | ERemoteCall(_, _, _):
				return print(inner, 0);			
			default:
		};	
	default:
}) {
								var ` = expr.def;
								switch (enumIndex `) {
									case 22: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											return reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
										};
									};
									case 24: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											return reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
										};
									};
									case 54: {
										var ` = `[0];
										{
											var inner = `;
											{
												@:ast(switch (inner.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(inner, 0);	
	default:
}) {
													var ` = inner.def;
													switch (enumIndex `) {
														case 22: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																return reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0);
															};
														};
														case 24: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																return reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0);
															};
														};
														default: {}
													};
												};
											};
										};
									};
									default: {}
								};
							};
						};
						@:ast(switch (pattern) {
	case PVar(name):
		var rhsName = switch (expr != null ? expr.def : null) {
			case EVar(varName):
				varName;			
			default:
				null;			
		};
		if (rhsName != null && rhsName == name && !ElixirASTBuilder.isTempPatternVarName(name)) {
			return "";
		};	
	default:
}) if (enumIndex pattern == 0) {
							var ` = pattern[0];
							{
								var name = `;
								{
									var rhsName = @:ast(switch (expr != null ? expr.def : null) {
	case EVar(varName):
		varName;	
	default:
		null;	
}) {
										var ` = if (expr != null) {
											expr.def;
										} else {
											null;
										};
										if (` == null) {
											null;
										} else if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var varName = `;
												{
													varName;
												};
											};
										} else {
											null;
										};
									};
									if (rhsName != null && rhsName == name && ! reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(name)) {
										return "";
									};
								};
							};
						} else {};
						@:ast(switch (pattern) {
	case PVar(name):
		if (expr != null) {
			switch (expr.def) {
				case EBinary(Match, innerLeft, rhsExpr):
					var innerLeftStr = print(innerLeft, 0);
					if (innerLeftStr == name) {
						return name + " = " + print(rhsExpr, indent);
					};				
				case EMatch(innerPattern, rhsExpr2):
					switch (innerPattern) {
						case PVar(innerName) if (innerName == name):
							return name + " = " + print(rhsExpr2, indent);						
						default:
					};				
				default:
			};
			var rhsPrinted = print(expr, indent);
			if (rhsPrinted != null) {
				var trimmed = StringTools.trim(rhsPrinted);
				var prefix = name + " = ";
				if (StringTools.startsWith(trimmed, prefix)) {
					var rest = StringTools.trim(trimmed.substr(prefix.length));
					return name + " = " + rest;
				};
			};
		};	
	default:
}) if (enumIndex pattern == 0) {
							var ` = pattern[0];
							{
								var name = `;
								{
									if (expr != null) {
										@:ast(switch (expr.def) {
	case EBinary(Match, innerLeft, rhsExpr):
		var innerLeftStr = print(innerLeft, 0);
		if (innerLeftStr == name) {
			return name + " = " + print(rhsExpr, indent);
		};	
	case EMatch(innerPattern, rhsExpr2):
		switch (innerPattern) {
			case PVar(innerName) if (innerName == name):
				return name + " = " + print(rhsExpr2, indent);			
			default:
		};	
	default:
}) {
											var ` = expr.def;
											switch (enumIndex `) {
												case 8: {
													var ` = `[0];
													var ` = `[1];
													{
														var innerPattern = `;
														var rhsExpr2 = `;
														{
															@:ast(switch (innerPattern) {
	case PVar(innerName) if (innerName == name):
		return name + " = " + print(rhsExpr2, indent);	
	default:
}) if (enumIndex innerPattern == 0) {
																var ` = innerPattern[0];
																{
																	var innerName = `;
																	if (innerName == name) {
																		return name + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(rhsExpr2, indent);
																	} else {};
																};
															} else {};
														};
													};
												};
												case 26: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													if (enumIndex ` == 27) {
														{
															var innerLeft = `;
															var rhsExpr = `;
															{
																var innerLeftStr = reflaxe.elixir.ast.ElixirASTPrinter.print(innerLeft, 0);
																if (innerLeftStr == name) {
																	return name + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(rhsExpr, indent);
																};
															};
														};
													} else {};
												};
												default: {}
											};
										};
										var rhsPrinted = reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent);
										if (rhsPrinted != null) {
											var trimmed = StringTools.trim(rhsPrinted);
											var prefix = name + " = ";
											if (StringTools.startsWith(trimmed, prefix)) {
												var rest = StringTools.trim(trimmed.substr(prefix.length, null));
												return name + " = " + rest;
											};
										};
									};
								};
							};
						} else {};
						var isZeroPat = @:ast(switch (pattern) {
	case PLiteral({ def : EInteger(v) }) if (v == 0):
		true;	
	default:
		false;	
}) if (enumIndex pattern == 1) {
							var ` = pattern[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 33) {
									var ` = `[0];
									{
										var v = `;
										if (v == 0) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
						} else {
							false;
						};
						if (isZeroPat && expr != null) {
							@:ast(switch (expr.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(expr, 0);	
	case EParen(inner):
		switch (inner.def) {
			case ECall(_, _, _) | ERemoteCall(_, _, _):
				return print(inner, 0);			
			default:
		};	
	default:
}) {
								var ` = expr.def;
								switch (enumIndex `) {
									case 22: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											return reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
										};
									};
									case 24: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											return reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
										};
									};
									case 54: {
										var ` = `[0];
										{
											var inner = `;
											{
												@:ast(switch (inner.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(inner, 0);	
	default:
}) {
													var ` = inner.def;
													switch (enumIndex `) {
														case 22: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																return reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0);
															};
														};
														case 24: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																return reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0);
															};
														};
														default: {}
													};
												};
											};
										};
									};
									default: {}
								};
							};
						};
						if (keepInline) {
							patternStr + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
						} else {
							patternStr + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent);
						};
					};
				};
			};
			case 9: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var clauses = `;
					var doBlock = `;
					var elseBlock = `;
					{
						var withClauses = {
							var ` = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.printPattern(clause.pattern) + " <- " + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.expr, 0));
								};
							};
							`;
						}.join(",\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1));
						var result = "with " + withClauses + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(doBlock, indent + 1) + "\n";
						if (elseBlock != null) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "else\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(elseBlock, indent + 1) + "\n";
						};
						result + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 10: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var condition = `;
					var thenBranch = `;
					var elseBranch = `;
					{
						var isInline = reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && (elseBranch == null || reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch));
						var conditionStr = reflaxe.elixir.ast.ElixirASTPrinter.printIfCondition(condition);
						if (isInline && elseBranch != null) {
							"if " + conditionStr + ", do: " + reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, 0) + ", else: " + reflaxe.elixir.ast.ElixirASTPrinter.print(elseBranch, 0);
						} else {
							if (elseBranch != null) {
								"if " + conditionStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "else\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(elseBranch, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
							} else {
								if (isInline) {
									var thenStr = @:ast(switch (thenBranch.def) {
	case EBinary(Add, { def : EVar(v) }, rhs):
		v + " = " + v + " + " + print(rhs, 0);	
	default:
		print(thenBranch, 0);	
}) {
										var ` = thenBranch.def;
										if (enumIndex ` == 26) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 0) {
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var v = `;
															var rhs = `;
															{
																v + " = " + v + " + " + reflaxe.elixir.ast.ElixirASTPrinter.print(rhs, 0);
															};
														};
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, 0);
													};
												};
											} else {
												reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, 0);
											};
										} else {
											reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, 0);
										};
									};
									"if " + conditionStr + ", do: " + thenStr;
								} else {
									"if " + conditionStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(thenBranch, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
								};
							};
						};
					};
				};
			};
			case 11: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var condition = `;
					var body = `;
					var elseBranch = `;
					{
						if (elseBranch != null) {
							"unless " + reflaxe.elixir.ast.ElixirASTPrinter.print(condition, 0) + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "else\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(elseBranch, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
						} else {
							"unless " + reflaxe.elixir.ast.ElixirASTPrinter.print(condition, 0) + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
						};
					};
				};
			};
			case 12: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				var ` = node[4];
				{
					var body = `;
					var rescue = `;
					var catchClauses = `;
					var afterBlock = `;
					var elseBlock = `;
					{
						var result = "try do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1) + "\n";
						if (rescue.length > 0) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "rescue\n";
							{
								var ` = 0;
								while (` < rescue.length) {
									var r = rescue[`];
									++ `;
									result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printRescueClause(r, indent + 1) + "\n";
								};
							};
						};
						if (catchClauses.length > 0) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "catch\n";
							{
								var ` = 0;
								while (` < catchClauses.length) {
									var c = catchClauses[`];
									++ `;
									result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printCatchClause(c, indent + 1) + "\n";
								};
							};
						};
						if (elseBlock != null) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "else\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(elseBlock, indent + 1) + "\n";
						};
						if (afterBlock != null) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "after\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(afterBlock, indent + 1) + "\n";
						};
						result + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 13: {
				var ` = node[0];
				var ` = node[1];
				{
					var exception = `;
					var attributes = `;
					{
						if (attributes != null) {
							"raise " + reflaxe.elixir.ast.ElixirASTPrinter.print(exception, 0) + ", " + reflaxe.elixir.ast.ElixirASTPrinter.print(attributes, 0);
						} else {
							"raise " + reflaxe.elixir.ast.ElixirASTPrinter.print(exception, 0);
						};
					};
				};
			};
			case 14: {
				var ` = node[0];
				{
					var value = `;
					{
						var valueStr = @:ast(switch (value.def) {
	case EBinary(StringConcat, left, right):
		var leftStr = print(left, 0);
		var rightStr = print(right, 0);
		leftStr = leftStr.split("\n").join(" ");
		rightStr = rightStr.split("\n").join(" ");
		leftStr + " <> " + rightStr;	
	default:
		var result = print(value, 0);
		result.split("\n").join(" ");	
}) {
							var ` = value.def;
							if (enumIndex ` == 26) {
								var ` = `[0];
								var ` = `[1];
								var ` = `[2];
								if (enumIndex ` == 25) {
									{
										var left = `;
										var right = `;
										{
											var leftStr = reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
											var rightStr = reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
											leftStr = leftStr.split("\n").join(" ");
											rightStr = rightStr.split("\n").join(" ");
											leftStr + " <> " + rightStr;
										};
									};
								} else {
									var result = reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
									result.split("\n").join(" ");
								};
							} else {
								var result = reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
								result.split("\n").join(" ");
							};
						};
						"throw(" + valueStr + ")";
					};
				};
			};
			case 15: {
				var ` = node[0];
				{
					var elements = `;
					{
						{};
						"[" + {
							var ` = [];
							{
								var ` = 0;
								while (` < elements.length) {
									var e = elements[`];
									++ `;
									`.push(@:ast(switch (e.def) {
	case EFor(_, _, _, _, _):
		"(" + print(e, 0) + ")";	
	case EBlock(exprs) if (exprs.length > 1):
		var recovered = tryListFromBlock(e);
		if (recovered != null) {
			"[" + [for (v  in  recovered) print(v, 0)].join(", ") + "]";
		} else {
			"(fn -> " + print(e, 0).rtrim() + " end).()";
		};	
	case EParen(inner) if (switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}):
		var recovered2 = tryListFromBlock(inner);
		if (recovered2 != null) {
			"[" + [for (v  in  recovered2) print(v, 0)].join(", ") + "]";
		} else {
			var innerStr = print(inner, 0).rtrim();
			if (StringTools.startsWith(innerStr, "(") && StringTools.endsWith(innerStr, ")")) {
				innerStr = innerStr.substr(1, innerStr.length - 2);
			};
			"(fn -> " + innerStr + " end).()";
		};	
	case EBlock(_):
		print(e, 0);	
	default:
		print(e, 0);	
}) {
										var ` = e.def;
										switch (enumIndex `) {
											case 41: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												var ` = `[3];
												var ` = `[4];
												{
													"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0) + ")";
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 1) {
														var recovered = {
															{};
															@:ast(switch (block.def) {
	case EBlock(stmts) if (stmts.length >= 2):
		var accName:Null<String> = null;
		switch (stmts[0].def) {
			case EBinary(Match, { def : EVar(v) }, { def : EList(initEls) }) if (initEls.length == 0):
				accName = v;			
			case EMatch(PVar(varName), { def : EList(initElems) }) if (initElems.length == 0):
				accName = varName;			
			default:
		};
		if (accName == null) return null;
		var accNorm = normalizeName(accName);
		var outVals:Array<ElixirAST> = [];
		for (i  in  1 ... stmts.length) {
			switch (stmts[i].def) {
				case EBinary(Match, { def : EVar(lhs) }, rhs) if (normalizeName(lhs) == accNorm):
					switch (rhs.def) {
						case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
							switch (cargs[0].def) {
								case EVar(v) if (normalizeName(v) == accNorm):
									switch (cargs[1].def) {
										case EList(listElts) if (listElts.length == 1):
											outVals.push(listElts[0]);										
										default:
									};								
								default:
							};						
						case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
							switch (rhsExpr.def) {
								case EList(listElements) if (listElements.length == 1):
									outVals.push(listElements[0]);								
								default:
							};						
						default:
					};				
				default:
			};
		};
		return outVals.length > 0 ? outVals : null;	
	default:
		null;	
}) {
																var ` = e.def;
																if (enumIndex ` == 53) {
																	var ` = `[0];
																	{
																		var stmts = `;
																		if (stmts.length >= 2) {
																			var accName = null;
																			@:ast(switch (stmts[0].def) {
	case EBinary(Match, { def : EVar(v) }, { def : EList(initEls) }) if (initEls.length == 0):
		accName = v;	
	case EMatch(PVar(varName), { def : EList(initElems) }) if (initElems.length == 0):
		accName = varName;	
	default:
}) {
																				var ` = stmts[0].def;
																				switch (enumIndex `) {
																					case 8: {
																						var ` = `[0];
																						var ` = `[1];
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 15) {
																									var ` = `[0];
																									{
																										var initElems = `;
																										var varName = `;
																										if (initElems.length == 0) {
																											accName = varName;
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					case 26: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						if (enumIndex ` == 27) {
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var ` = `.def;
																										var ` = `.metadata;
																										var ` = `.pos;
																										if (enumIndex ` == 15) {
																											var ` = `[0];
																											{
																												var initEls = `;
																												var v = `;
																												if (initEls.length == 0) {
																													accName = v;
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					default: {}
																				};
																			};
																			if (accName == null) {
																				null;
																			} else {
																				var accNorm = {
																					var i = 0;
																					while (i < accName.length && accName.charAt(i) == "_") {
																						i ++;
																					};
																					if (i > 0) {
																						accName.substr(i, null);
																					} else {
																						accName;
																					};
																				};
																				var outVals = [];
																				{
																					var ` = 1;
																					var ` = stmts.length;
																					while (` < `) {
																						var i = ` ++;
																						@:ast(switch (stmts[i].def) {
	case EBinary(Match, { def : EVar(lhs) }, rhs) if (normalizeName(lhs) == accNorm):
		switch (rhs.def) {
			case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
				switch (cargs[0].def) {
					case EVar(v) if (normalizeName(v) == accNorm):
						switch (cargs[1].def) {
							case EList(listElts) if (listElts.length == 1):
								outVals.push(listElts[0]);							
							default:
						};					
					default:
				};			
			case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
				switch (rhsExpr.def) {
					case EList(listElements) if (listElements.length == 1):
						outVals.push(listElements[0]);					
					default:
				};			
			default:
		};	
	default:
}) {
																							var ` = stmts[i].def;
																							if (enumIndex ` == 26) {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 27) {
																									{
																										var ` = `.def;
																										var ` = `.metadata;
																										var ` = `.pos;
																										if (enumIndex ` == 38) {
																											var ` = `[0];
																											{
																												var lhs = `;
																												var rhs = `;
																												if ({
																													var i = 0;
																													while (i < lhs.length && lhs.charAt(i) == "_") {
																														i ++;
																													};
																													if (i > 0) {
																														lhs.substr(i, null);
																													} else {
																														lhs;
																													};
																												} == accNorm) {
																													@:ast(switch (rhs.def) {
	case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
		switch (cargs[0].def) {
			case EVar(v) if (normalizeName(v) == accNorm):
				switch (cargs[1].def) {
					case EList(listElts) if (listElts.length == 1):
						outVals.push(listElts[0]);					
					default:
				};			
			default:
		};	
	case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
		switch (rhsExpr.def) {
			case EList(listElements) if (listElements.length == 1):
				outVals.push(listElements[0]);			
			default:
		};	
	default:
}) {
																														var ` = rhs.def;
																														switch (enumIndex `) {
																															case 24: {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																{
																																	var ` = `.def;
																																	var ` = `.metadata;
																																	var ` = `.pos;
																																	if (enumIndex ` == 38) {
																																		var ` = `[0];
																																		if (` == "concat") {
																																			{
																																				var m = `;
																																				var cargs = `;
																																				if (m == "Enum" && cargs.length == 2) {
																																					@:ast(switch (cargs[0].def) {
	case EVar(v) if (normalizeName(v) == accNorm):
		switch (cargs[1].def) {
			case EList(listElts) if (listElts.length == 1):
				outVals.push(listElts[0]);			
			default:
		};	
	default:
}) {
																																						var ` = cargs[0].def;
																																						if (enumIndex ` == 38) {
																																							var ` = `[0];
																																							{
																																								var v = `;
																																								if ({
																																									var i = 0;
																																									while (i < v.length && v.charAt(i) == "_") {
																																										i ++;
																																									};
																																									if (i > 0) {
																																										v.substr(i, null);
																																									} else {
																																										v;
																																									};
																																								} == accNorm) {
																																									@:ast(switch (cargs[1].def) {
	case EList(listElts) if (listElts.length == 1):
		outVals.push(listElts[0]);	
	default:
}) {
																																										var ` = cargs[1].def;
																																										if (enumIndex ` == 15) {
																																											var ` = `[0];
																																											{
																																												var listElts = `;
																																												if (listElts.length == 1) {
																																													outVals.push(listElts[0]);
																																												} else {};
																																											};
																																										} else {};
																																									};
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															};
																															case 26: {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (enumIndex ` == 0) {
																																	{
																																		var ` = `.def;
																																		var ` = `.metadata;
																																		var ` = `.pos;
																																		if (enumIndex ` == 38) {
																																			var ` = `[0];
																																			{
																																				var accVar = `;
																																				var rhsExpr = `;
																																				if ({
																																					var i = 0;
																																					while (i < accVar.length && accVar.charAt(i) == "_") {
																																						i ++;
																																					};
																																					if (i > 0) {
																																						accVar.substr(i, null);
																																					} else {
																																						accVar;
																																					};
																																				} == accNorm) {
																																					@:ast(switch (rhsExpr.def) {
	case EList(listElements) if (listElements.length == 1):
		outVals.push(listElements[0]);	
	default:
}) {
																																						var ` = rhsExpr.def;
																																						if (enumIndex ` == 15) {
																																							var ` = `[0];
																																							{
																																								var listElements = `;
																																								if (listElements.length == 1) {
																																									outVals.push(listElements[0]);
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	};
																																} else {};
																															};
																															default: {}
																														};
																													};
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							} else {};
																						};
																					};
																				};
																				if (outVals.length > 0) {
																					outVals;
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
														};
														if (recovered != null) {
															"[" + {
																var ` = [];
																{
																	var ` = 0;
																	while (` < recovered.length) {
																		var v = recovered[`];
																		++ `;
																		`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(v, 0));
																	};
																};
																`;
															}.join(", ") + "]";
														} else {
															"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0)) + " end).()";
														};
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0);
													};
												};
											};
											case 54: {
												var ` = `[0];
												{
													var inner = `;
													if (@:ast(switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}) {
														var ` = inner.def;
														if (enumIndex ` == 53) {
															var ` = `[0];
															{
																var es = `;
																if (es.length > 1) {
																	true;
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													}) {
														var recovered2 = {
															{};
															@:ast(switch (block.def) {
	case EBlock(stmts) if (stmts.length >= 2):
		var accName:Null<String> = null;
		switch (stmts[0].def) {
			case EBinary(Match, { def : EVar(v) }, { def : EList(initEls) }) if (initEls.length == 0):
				accName = v;			
			case EMatch(PVar(varName), { def : EList(initElems) }) if (initElems.length == 0):
				accName = varName;			
			default:
		};
		if (accName == null) return null;
		var accNorm = normalizeName(accName);
		var outVals:Array<ElixirAST> = [];
		for (i  in  1 ... stmts.length) {
			switch (stmts[i].def) {
				case EBinary(Match, { def : EVar(lhs) }, rhs) if (normalizeName(lhs) == accNorm):
					switch (rhs.def) {
						case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
							switch (cargs[0].def) {
								case EVar(v) if (normalizeName(v) == accNorm):
									switch (cargs[1].def) {
										case EList(listElts) if (listElts.length == 1):
											outVals.push(listElts[0]);										
										default:
									};								
								default:
							};						
						case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
							switch (rhsExpr.def) {
								case EList(listElements) if (listElements.length == 1):
									outVals.push(listElements[0]);								
								default:
							};						
						default:
					};				
				default:
			};
		};
		return outVals.length > 0 ? outVals : null;	
	default:
		null;	
}) {
																var ` = inner.def;
																if (enumIndex ` == 53) {
																	var ` = `[0];
																	{
																		var stmts = `;
																		if (stmts.length >= 2) {
																			var accName = null;
																			@:ast(switch (stmts[0].def) {
	case EBinary(Match, { def : EVar(v) }, { def : EList(initEls) }) if (initEls.length == 0):
		accName = v;	
	case EMatch(PVar(varName), { def : EList(initElems) }) if (initElems.length == 0):
		accName = varName;	
	default:
}) {
																				var ` = stmts[0].def;
																				switch (enumIndex `) {
																					case 8: {
																						var ` = `[0];
																						var ` = `[1];
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 15) {
																									var ` = `[0];
																									{
																										var initElems = `;
																										var varName = `;
																										if (initElems.length == 0) {
																											accName = varName;
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					case 26: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						if (enumIndex ` == 27) {
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var ` = `.def;
																										var ` = `.metadata;
																										var ` = `.pos;
																										if (enumIndex ` == 15) {
																											var ` = `[0];
																											{
																												var initEls = `;
																												var v = `;
																												if (initEls.length == 0) {
																													accName = v;
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					default: {}
																				};
																			};
																			if (accName == null) {
																				null;
																			} else {
																				var accNorm = {
																					var i = 0;
																					while (i < accName.length && accName.charAt(i) == "_") {
																						i ++;
																					};
																					if (i > 0) {
																						accName.substr(i, null);
																					} else {
																						accName;
																					};
																				};
																				var outVals = [];
																				{
																					var ` = 1;
																					var ` = stmts.length;
																					while (` < `) {
																						var i = ` ++;
																						@:ast(switch (stmts[i].def) {
	case EBinary(Match, { def : EVar(lhs) }, rhs) if (normalizeName(lhs) == accNorm):
		switch (rhs.def) {
			case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
				switch (cargs[0].def) {
					case EVar(v) if (normalizeName(v) == accNorm):
						switch (cargs[1].def) {
							case EList(listElts) if (listElts.length == 1):
								outVals.push(listElts[0]);							
							default:
						};					
					default:
				};			
			case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
				switch (rhsExpr.def) {
					case EList(listElements) if (listElements.length == 1):
						outVals.push(listElements[0]);					
					default:
				};			
			default:
		};	
	default:
}) {
																							var ` = stmts[i].def;
																							if (enumIndex ` == 26) {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 27) {
																									{
																										var ` = `.def;
																										var ` = `.metadata;
																										var ` = `.pos;
																										if (enumIndex ` == 38) {
																											var ` = `[0];
																											{
																												var lhs = `;
																												var rhs = `;
																												if ({
																													var i = 0;
																													while (i < lhs.length && lhs.charAt(i) == "_") {
																														i ++;
																													};
																													if (i > 0) {
																														lhs.substr(i, null);
																													} else {
																														lhs;
																													};
																												} == accNorm) {
																													@:ast(switch (rhs.def) {
	case ERemoteCall({ def : EVar(m) }, "concat", cargs) if (m == "Enum" && cargs.length == 2):
		switch (cargs[0].def) {
			case EVar(v) if (normalizeName(v) == accNorm):
				switch (cargs[1].def) {
					case EList(listElts) if (listElts.length == 1):
						outVals.push(listElts[0]);					
					default:
				};			
			default:
		};	
	case EBinary(Add, { def : EVar(accVar) }, rhsExpr) if (normalizeName(accVar) == accNorm):
		switch (rhsExpr.def) {
			case EList(listElements) if (listElements.length == 1):
				outVals.push(listElements[0]);			
			default:
		};	
	default:
}) {
																														var ` = rhs.def;
																														switch (enumIndex `) {
																															case 24: {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																{
																																	var ` = `.def;
																																	var ` = `.metadata;
																																	var ` = `.pos;
																																	if (enumIndex ` == 38) {
																																		var ` = `[0];
																																		if (` == "concat") {
																																			{
																																				var m = `;
																																				var cargs = `;
																																				if (m == "Enum" && cargs.length == 2) {
																																					@:ast(switch (cargs[0].def) {
	case EVar(v) if (normalizeName(v) == accNorm):
		switch (cargs[1].def) {
			case EList(listElts) if (listElts.length == 1):
				outVals.push(listElts[0]);			
			default:
		};	
	default:
}) {
																																						var ` = cargs[0].def;
																																						if (enumIndex ` == 38) {
																																							var ` = `[0];
																																							{
																																								var v = `;
																																								if ({
																																									var i = 0;
																																									while (i < v.length && v.charAt(i) == "_") {
																																										i ++;
																																									};
																																									if (i > 0) {
																																										v.substr(i, null);
																																									} else {
																																										v;
																																									};
																																								} == accNorm) {
																																									@:ast(switch (cargs[1].def) {
	case EList(listElts) if (listElts.length == 1):
		outVals.push(listElts[0]);	
	default:
}) {
																																										var ` = cargs[1].def;
																																										if (enumIndex ` == 15) {
																																											var ` = `[0];
																																											{
																																												var listElts = `;
																																												if (listElts.length == 1) {
																																													outVals.push(listElts[0]);
																																												} else {};
																																											};
																																										} else {};
																																									};
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															};
																															case 26: {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (enumIndex ` == 0) {
																																	{
																																		var ` = `.def;
																																		var ` = `.metadata;
																																		var ` = `.pos;
																																		if (enumIndex ` == 38) {
																																			var ` = `[0];
																																			{
																																				var accVar = `;
																																				var rhsExpr = `;
																																				if ({
																																					var i = 0;
																																					while (i < accVar.length && accVar.charAt(i) == "_") {
																																						i ++;
																																					};
																																					if (i > 0) {
																																						accVar.substr(i, null);
																																					} else {
																																						accVar;
																																					};
																																				} == accNorm) {
																																					@:ast(switch (rhsExpr.def) {
	case EList(listElements) if (listElements.length == 1):
		outVals.push(listElements[0]);	
	default:
}) {
																																						var ` = rhsExpr.def;
																																						if (enumIndex ` == 15) {
																																							var ` = `[0];
																																							{
																																								var listElements = `;
																																								if (listElements.length == 1) {
																																									outVals.push(listElements[0]);
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	};
																																} else {};
																															};
																															default: {}
																														};
																													};
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							} else {};
																						};
																					};
																				};
																				if (outVals.length > 0) {
																					outVals;
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
														};
														if (recovered2 != null) {
															"[" + {
																var ` = [];
																{
																	var ` = 0;
																	while (` < recovered2.length) {
																		var v = recovered2[`];
																		++ `;
																		`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(v, 0));
																	};
																};
																`;
															}.join(", ") + "]";
														} else {
															var innerStr = StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0));
															if (StringTools.startsWith(innerStr, "(") && StringTools.endsWith(innerStr, ")")) {
																innerStr = innerStr.substr(1, innerStr.length - 2);
															};
															"(fn -> " + innerStr + " end).()";
														};
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0);
											}
										};
									});
								};
							};
							`;
						}.join(", ") + "]";
					};
				};
			};
			case 16: {
				var ` = node[0];
				{
					var elements = `;
					{
						"{" + {
							var ` = [];
							{
								var ` = 0;
								while (` < elements.length) {
									var e = elements[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(e, 0));
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 17: {
				var ` = node[0];
				{
					var pairs = `;
					{
						"%{" + {
							var ` = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									var key = reflaxe.elixir.ast.ElixirASTPrinter.print(p.key, 0);
									var value = p.value;
									var valueStr = @:ast(switch (value.def) {
	case EBlock(exprs) if (exprs.length > 1):
		"(fn -> " + print(value, 0).rtrim() + " end).()";	
	case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
		"(" + print(value, 0) + ")";	
	case _:
		print(value, 0);	
}) {
										var ` = value.def;
										switch (enumIndex `) {
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cond = `;
													var thenBranch = `;
													var elseBranch = `;
													if (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch)) {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0) + ")";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 1) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
											}
										};
									};
									`.push(key + " => " + valueStr);
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 18: {
				var ` = node[0];
				var ` = node[1];
				{
					var module = `;
					var fields = `;
					{
						var qualifiedModule = (function() {
							if (module.indexOf(".", null) != -1) {
								return module;
							};
							{};
							var p = if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName == null) {
								reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
							} else {
								var idx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
								if (idx > 0) {
									reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx);
								} else {
									reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
								};
							};
							return (if (p != null) {
								p + "." + module;
							} else {
								module;
							});
						})();
						"%" + qualifiedModule + "{" + {
							var ` = [];
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									var value = f.value;
									var valueStr = @:ast(switch (value.def) {
	case EBlock(exprs) if (exprs.length > 1):
		"(fn -> " + print(value, 0).rtrim() + " end).()";	
	case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
		"(" + print(value, 0) + ")";	
	case _:
		print(value, 0);	
}) {
										var ` = value.def;
										switch (enumIndex `) {
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cond = `;
													var thenBranch = `;
													var elseBranch = `;
													if (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch)) {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0) + ")";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 1) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
											}
										};
									};
									`.push(f.key + ": " + valueStr);
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 19: {
				var ` = node[0];
				var ` = node[1];
				{
					var struct = `;
					var fields = `;
					{
						"%{" + reflaxe.elixir.ast.ElixirASTPrinter.print(struct, 0) + " | " + {
							var ` = [];
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									var value = f.value;
									var valueStr = @:ast(switch (value.def) {
	case EBlock(exprs) if (exprs.length > 1):
		"(fn -> " + print(value, 0).rtrim() + " end).()";	
	case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
		"(" + print(value, 0) + ")";	
	case _:
		print(value, 0);	
}) {
										var ` = value.def;
										switch (enumIndex `) {
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cond = `;
													var thenBranch = `;
													var elseBranch = `;
													if (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch)) {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0) + ")";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 1) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
											}
										};
									};
									`.push(f.key + ": " + valueStr);
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 20: {
				var ` = node[0];
				{
					var pairs = `;
					{
						"[" + {
							var ` = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									var value = p.value;
									var valueStr = @:ast(switch (value.def) {
	case EBlock(exprs) if (exprs.length > 1):
		"(fn -> " + print(value, 0).rtrim() + " end).()";	
	case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
		"(" + print(value, 0) + ")";	
	case _:
		print(value, 0);	
}) {
										var ` = value.def;
										switch (enumIndex `) {
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cond = `;
													var thenBranch = `;
													var elseBranch = `;
													if (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch)) {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0) + ")";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											case 53: {
												var ` = `[0];
												{
													var exprs = `;
													if (exprs.length > 1) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
											}
										};
									};
									`.push(p.key + ": " + valueStr);
								};
							};
							`;
						}.join(", ") + "]";
					};
				};
			};
			case 21: {
				var ` = node[0];
				{
					var segments = `;
					{
						"<<" + {
							var ` = [];
							{
								var ` = 0;
								while (` < segments.length) {
									var s = segments[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.printBinarySegment(s));
								};
							};
							`;
						}.join(", ") + ">>";
					};
				};
			};
			case 22: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var target = `;
					var funcName = [`];
					var args = `;
					{
						if (funcName[0] == "assign_multiple" && target == null) {
							funcName[0] = "assign";
						};
						if (funcName[0] == "while_loop" && target == null && args.length == 2) {
							var condition = args[0];
							var body = args[1];
							var loopFuncName = "loop_" + (reflaxe.elixir.ast.ElixirASTPrinter.loopIdCounter ++);
							var lines = [];
							lines.push("(fn ->");
							lines.push("  " + loopFuncName + " = fn " + loopFuncName + " ->");
							lines.push("    if " + reflaxe.elixir.ast.ElixirASTPrinter.print(condition, 0) + " do");
							lines.push("      " + reflaxe.elixir.ast.ElixirASTPrinter.print(body, 3));
							lines.push("      " + loopFuncName + ".(" + loopFuncName + ")");
							lines.push("    else");
							lines.push("      :ok");
							lines.push("    end");
							lines.push("  end");
							lines.push("  " + loopFuncName + ".(" + loopFuncName + ")");
							lines.push("end).()");
							lines.join("\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent));
						} else {
							var argStr = (function() {
								var parts = [];
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										var printed = reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(a, indent + 1);
										parts.push(reflaxe.elixir.ast.ElixirASTPrinter.sanitizeArgPrinted(printed, indent + 1));
									};
								};
								return parts.join(", ");
							})();
							if (target != null) {
								if (funcName[0] == "new" && args.length == 0) {
									{};
									@:ast(switch (target.def) {
	case EVar(n):
		var modStr = (function() {
			if (n.indexOf(".") == -1) {
				var p = appPrefix();
				return (p != null ? p + "." + n : n);
			} else {
				return n;
			};
		})();
		return "%" + modStr + "{}";	
	default:
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var n = `;
												{
													var modStr = (function() {
														if (n.indexOf(".", null) == -1) {
															var p = if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName == null) {
																reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
															} else {
																var idx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
																if (idx > 0) {
																	reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx);
																} else {
																	reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
																};
															};
															return (if (p != null) {
																p + "." + n;
															} else {
																n;
															});
														} else {
															return n;
														};
													})();
													return "%" + modStr + "{}";
												};
											};
										} else {};
									};
								};
								if (funcName[0] == "") {
									var tStr = @:ast(switch (target.def) {
	case EFn(_):
		"(" + print(target, indent) + ")";	
	case EParen(_):
		print(target, indent);	
	default:
		print(target, indent);	
}) {
										var ` = target.def;
										switch (enumIndex `) {
											case 42: {
												var ` = `[0];
												{
													"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent) + ")";
												};
											};
											case 54: {
												var ` = `[0];
												{
													reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
											}
										};
									};
									tStr + ".(" + argStr + ")";
								} else {
									var isEnumMethod = @:ast(switch (funcName) {
	case "map" | "filter" | "reduce" | "each" | "find" | "reject" | "take" | "drop" | "any" | "all" | "count" | "member" | "sort" | "reverse" | "zip" | "concat" | "flat_map" | "group_by" | "split" | "join" | "at" | "fetch" | "empty" | "sum" | "min" | "max" | "uniq" | "with_index":
		true;	
	default:
		false;	
}) switch (funcName[0]) {
										case "all", "any", "at", "concat", "count", "drop", "each", "empty", "fetch", "filter", "find", "flat_map", "group_by", "join", "map", "max", "member", "min", "reduce", "reject", "reverse", "sort", "split", "sum", "take", "uniq", "with_index", "zip": {
											{
												true;
											};
										};
										default: {
											false;
										}
									};
									if (isEnumMethod) {
										var receiverPrinted = reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
										var firstArgStr = (function() {
											if (funcName[0] == "join") {
												var trimmed = StringTools.trim(receiverPrinted);
												return if (StringTools.startsWith(trimmed, "(fn ->")) {
													receiverPrinted;
												} else {
													"(fn -> " + receiverPrinted + " end).()";
												};
											} else {
												return receiverPrinted;
											};
										})();
										var enumCall = "Enum." + funcName[0] + "(" + firstArgStr;
										if (argStr.length > 0) {
											enumCall + ", " + argStr + ")";
										} else {
											enumCall + ")";
										};
									} else {
										if (funcName[0] == "to_iso8601") {
											var tstr = reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
											return "DateTime.to_iso8601(" + tstr + ")";
										};
										if (funcName[0] == "push") {
											@:ast(switch (target.def) {
	case EVar(varName):
		var first = varName.charAt(0);
		if (first == first.toLowerCase()) {
			var printedArg = args.length > 0 ? printFunctionArg(args[0]) : "";
			return varName + " = Enum.concat(" + varName + ", [" + printedArg + "])";
		};	
	default:
}) {
												var ` = target.def;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var varName = `;
														{
															var first = varName.charAt(0);
															if (first == first.toLowerCase()) {
																var printedArg = if (args.length > 0) {
																	reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[0], null);
																} else {
																	"";
																};
																return varName + " = Enum.concat(" + varName + ", [" + printedArg + "])";
															};
														};
													};
												} else {};
											};
										};
										var targetStr = @:ast(switch (target.def) {
	case ECase(_, _) | ECond(_) | EWith(_, _, _):
		"(" + print(target, indent) + ") |> Kernel." + funcName;	
	case EIf(_, _, elseBranch) if (elseBranch != null):
		"(" + print(target, indent) + ") |> Kernel." + funcName;	
	default:
		var modStr = switch (target.def) {
			case EVar(name) if (name == "Repo"):
				var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
				if (idx > 0) currentModuleName.substring(0, idx) + ".Repo" else {
					if (observedAppPrefix != null) observedAppPrefix + ".Repo" else {
						try {
							var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
							if (app != null && app.length > 0) app + ".Repo" else name;
						} catch(e:Dynamic) {
							name;
						};
					};
				};			
			case EVar(name):
				var first = name.charAt(0);
				var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
				var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
				inline function isStdModule(n:String):Bool {
					return switch (n) {
						case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
							true;						
						default:
							false;						
					};
				};
				if (isUpper && idx > 0 && !isStdModule(name)) currentModuleName.substring(0, idx) + "." + name else name;			
			default:
				print(target, indent);			
		};
		modStr + "." + funcName;	
}) {
											var ` = target.def;
											switch (enumIndex `) {
												case 6: {
													var ` = `[0];
													var ` = `[1];
													{
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent) + ") |> Kernel." + funcName[0];
													};
												};
												case 7: {
													var ` = `[0];
													{
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent) + ") |> Kernel." + funcName[0];
													};
												};
												case 9: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent) + ") |> Kernel." + funcName[0];
													};
												};
												case 10: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var elseBranch = `;
														if (elseBranch != null) {
															"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent) + ") |> Kernel." + funcName[0];
														} else {
															var modStr = @:ast(switch (target.def) {
	case EVar(name) if (name == "Repo"):
		var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
		if (idx > 0) currentModuleName.substring(0, idx) + ".Repo" else {
			if (observedAppPrefix != null) observedAppPrefix + ".Repo" else {
				try {
					var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
					if (app != null && app.length > 0) app + ".Repo" else name;
				} catch(e:Dynamic) {
					name;
				};
			};
		};	
	case EVar(name):
		var first = name.charAt(0);
		var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
		var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
		inline function isStdModule(n:String):Bool {
			return switch (n) {
				case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
					true;				
				default:
					false;				
			};
		};
		if (isUpper && idx > 0 && !isStdModule(name)) currentModuleName.substring(0, idx) + "." + name else name;	
	default:
		print(target, indent);	
}) {
																var ` = target.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var name = `;
																		if (name == "Repo") {
																			var idx = if ((reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null)) {
																				reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
																			} else {
																				-1;
																			};
																			if (idx > 0) {
																				reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx) + ".Repo";
																			} else {
																				if (reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix != null) {
																					reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix + ".Repo";
																				} else {
																					try {
																						var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
																						if (app != null && app.length > 0) {
																							app + ".Repo";
																						} else {
																							name;
																						};
																					} catch (`:Dynamic) {
																						{};
																						{};
																						if (true) {
																							{};
																							{
																								name;
																							};
																						} else throw `;
																					};
																				};
																			};
																		} else {
																			var name = `;
																			{
																				var first = name.charAt(0);
																				var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
																				var idx = if ((reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null)) {
																					reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
																				} else {
																					-1;
																				};
																				{};
																				if (isUpper && idx > 0 && ! @:ast(switch (n) {
	case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
		true;	
	default:
		false;	
}) switch (name) {
																					case "Access", "Agent", "Application", "Bitwise", "DateTime", "Ecto", "Ecto.Query", "Enum", "File", "GenServer", "IO", "Kernel", "Keyword", "List", "Logger", "Map", "Path", "Phoenix", "Phoenix.Component", "Phoenix.Controller", "Phoenix.LiveView", "Process", "Regex", "Stream", "String", "System", "Task", "Tuple": {
																						{
																							true;
																						};
																					};
																					default: {
																						false;
																					}
																				}) {
																					reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx) + "." + name;
																				} else {
																					name;
																				};
																			};
																		};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
																};
															};
															modStr + "." + funcName[0];
														};
													};
												};
												default: {
													var modStr = @:ast(switch (target.def) {
	case EVar(name) if (name == "Repo"):
		var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
		if (idx > 0) currentModuleName.substring(0, idx) + ".Repo" else {
			if (observedAppPrefix != null) observedAppPrefix + ".Repo" else {
				try {
					var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
					if (app != null && app.length > 0) app + ".Repo" else name;
				} catch(e:Dynamic) {
					name;
				};
			};
		};	
	case EVar(name):
		var first = name.charAt(0);
		var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
		var idx = (currentModuleName != null) ? currentModuleName.indexOf("Web") : -1;
		inline function isStdModule(n:String):Bool {
			return switch (n) {
				case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
					true;				
				default:
					false;				
			};
		};
		if (isUpper && idx > 0 && !isStdModule(name)) currentModuleName.substring(0, idx) + "." + name else name;	
	default:
		print(target, indent);	
}) {
														var ` = target.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var name = `;
																if (name == "Repo") {
																	var idx = if ((reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null)) {
																		reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
																	} else {
																		-1;
																	};
																	if (idx > 0) {
																		reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx) + ".Repo";
																	} else {
																		if (reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix != null) {
																			reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix + ".Repo";
																		} else {
																			try {
																				var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
																				if (app != null && app.length > 0) {
																					app + ".Repo";
																				} else {
																					name;
																				};
																			} catch (`:Dynamic) {
																				{};
																				{};
																				if (true) {
																					{};
																					{
																						name;
																					};
																				} else throw `;
																			};
																		};
																	};
																} else {
																	var name = `;
																	{
																		var first = name.charAt(0);
																		var isUpper = first == first.toUpperCase() && first != first.toLowerCase();
																		var idx = if ((reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null)) {
																			reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
																		} else {
																			-1;
																		};
																		{};
																		if (isUpper && idx > 0 && ! @:ast(switch (n) {
	case "Enum" | "String" | "Map" | "List" | "Tuple" | "DateTime" | "Bitwise" | "Kernel" | "IO" | "File" | "Regex" | "Process" | "Task" | "Agent" | "GenServer" | "Stream" | "Keyword" | "Access" | "Path" | "System" | "Application" | "Logger" | "Ecto" | "Ecto.Query" | "Phoenix" | "Phoenix.LiveView" | "Phoenix.Component" | "Phoenix.Controller":
		true;	
	default:
		false;	
}) switch (name) {
																			case "Access", "Agent", "Application", "Bitwise", "DateTime", "Ecto", "Ecto.Query", "Enum", "File", "GenServer", "IO", "Kernel", "Keyword", "List", "Logger", "Map", "Path", "Phoenix", "Phoenix.Component", "Phoenix.Controller", "Phoenix.LiveView", "Process", "Regex", "Stream", "String", "System", "Task", "Tuple": {
																				{
																					true;
																				};
																			};
																			default: {
																				false;
																			}
																		}) {
																			reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx) + "." + name;
																		} else {
																			name;
																		};
																	};
																};
															};
														} else {
															reflaxe.elixir.ast.ElixirASTPrinter.print(target, indent);
														};
													};
													modStr + "." + funcName[0];
												}
											};
										};
										targetStr + "(" + argStr + ")";
									};
								};
							} else {
								funcName[0] + "(" + argStr + ")";
							};
						};
					};
				};
			};
			case 23: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var macroName = `;
					var args = `;
					var doBlock = `;
					{
						var argStr = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(a, 0));
								};
							};
							`;
						}.join(", ");
						var unwrappedDo = @:ast(switch (doBlock.def) {
	case EParen(inner):
		inner;	
	default:
		doBlock;	
}) {
							var ` = doBlock.def;
							if (enumIndex ` == 54) {
								var ` = `[0];
								{
									var inner = `;
									{
										inner;
									};
								};
							} else {
								doBlock;
							};
						};
						macroName + (if (args.length > 0) {
							" " + argStr;
						} else {
							"";
						}) + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(unwrappedDo, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 24: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var module = `;
					var funcName = `;
					var args = `;
					{
						@:ast(switch (module.def) {
	case EVar(m) if (m == "Date_Impl_"):
		if (funcName == "get_time" && args.length == 1) {
			return "DateTime.to_unix(" + printFunctionArg(args[0], indent) + ", :millisecond)";
		};
		if (funcName == "from_string" && args.length == 1) {
			return printFunctionArg(args[0], indent);
		};	
	default:
}) {
							var ` = module.def;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var m = `;
									if (m == "Date_Impl_") {
										if (funcName == "get_time" && args.length == 1) {
											return "DateTime.to_unix(" + reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[0], indent) + ", :millisecond)";
										};
										if (funcName == "from_string" && args.length == 1) {
											return reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[0], indent);
										};
									} else {};
								};
							} else {};
						};
						var argStr = (function() {
							@:ast(switch (module.def) {
	case EVar(m) if (m == "Assert" && (funcName == "is_true" || funcName == "is_false") && args.length >= 1):
		var parts:Array<String> = [];
		var firstPrinted = "(fn -> " + print(args[0], indent) + " end).()";
		parts.push(firstPrinted);
		for (i  in  1 ... args.length) parts.push(sanitizeArgPrinted(printFunctionArg(args[i], indent), indent));
		return parts.join(", ");	
	default:
}) {
								var ` = module.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var m = `;
										if (m == "Assert" && (funcName == "is_true" || funcName == "is_false") && args.length >= 1) {
											var parts = [];
											var firstPrinted = "(fn -> " + reflaxe.elixir.ast.ElixirASTPrinter.print(args[0], indent) + " end).()";
											parts.push(firstPrinted);
											{
												var ` = 1;
												var ` = args.length;
												while (` < `) {
													var i = ` ++;
													parts.push(reflaxe.elixir.ast.ElixirASTPrinter.sanitizeArgPrinted(reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[i], indent), indent));
												};
											};
											return parts.join(", ");
										} else {};
									};
								} else {};
							};
							if (funcName == "changeset" && args.length >= 1) {
								var parts = [];
								var firstPrinted = reflaxe.elixir.ast.ElixirASTPrinter.print(args[0], 0);
								var needsQual = false;
								if (StringTools.startsWith(firstPrinted, "%")) {
									var open = firstPrinted.indexOf("{", null);
									var closeDot = firstPrinted.indexOf(".", null);
									needsQual = (open > 1 && (closeDot == -1 || closeDot > open));
								};
								if (needsQual) {
									var remote = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
									parts.push("%" + remote + "{}");
								} else {
									parts.push(firstPrinted);
								};
								{
									var ` = 1;
									var ` = args.length;
									while (` < `) {
										var i = ` ++;
										parts.push(reflaxe.elixir.ast.ElixirASTPrinter.sanitizeArgPrinted(reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[i], indent), indent));
									};
								};
								return parts.join(", ");
							} else {
								var s;
								var mstrTmp = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
								if (mstrTmp == "Enum" && funcName == "join" && args.length >= 1) {
									var parts = [];
									var firstPrintedRaw = reflaxe.elixir.ast.ElixirASTPrinter.print(args[0], indent);
									var trimmed = StringTools.trim(firstPrintedRaw);
									var firstPrinted = if (StringTools.startsWith(trimmed, "(fn ->")) {
										firstPrintedRaw;
									} else {
										"(fn -> " + firstPrintedRaw + " end).()";
									};
									parts.push(firstPrinted);
									{
										var ` = 1;
										var ` = args.length;
										while (` < `) {
											var i = ` ++;
											parts.push(reflaxe.elixir.ast.ElixirASTPrinter.sanitizeArgPrinted(reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(args[i], indent), indent));
										};
									};
									s = parts.join(", ");
								} else {
									s = {
										var ` = [];
										{
											var ` = 0;
											while (` < args.length) {
												var a = args[`];
												++ `;
												`.push(reflaxe.elixir.ast.ElixirASTPrinter.sanitizeArgPrinted(reflaxe.elixir.ast.ElixirASTPrinter.printFunctionArg(a, indent), indent));
											};
										};
										`;
									}.join(", ");
								};
								var mstr = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
								if (mstr == "Ecto.Query" && funcName == "from") {
									{};
									var idxIn = s.indexOf(" in :", null);
									if (idxIn != -1) {
										var start = idxIn + 6;
										var j = start;
										while (j < s.length) {
											var ch = s.charAt(j);
											var isAlnum = new EReg("^[A-Za-z0-9_]$", "").match(ch);
											if (! isAlnum) {
												break;
											};
											j ++;
										};
										var raw = s.substr(start, j - start);
										if (raw.length > 0) {
											var app = (function() {
												var pfx = null;
												if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null) {
													var w = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
													if (w > 0) {
														pfx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, w);
													};
												};
												if (pfx == null) {
													pfx = reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
												};
												if (pfx == null) {
													try {
														pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName();
													} catch (`:Dynamic) {
														{};
														{};
														if (true) {
															{};
															{};
														} else throw `;
													};
												};
												return pfx;
											})();
											if (app != null && app.length > 0) {
												s = s.substr(0, idxIn + 4) + " " + app + "." + {
													var parts = raw.split("_");
													var out = [];
													{
														var ` = 0;
														while (` < parts.length) {
															var p = parts[`];
															++ `;
															if (p.length > 0) {
																out.push(p.charAt(0).toUpperCase() + p.substr(1, null));
															};
														};
													};
													out.join("");
												} + s.substr(j, null);
											};
										};
									};
								};
								if ((mstr == reflaxe.elixir.PhoenixMapper.getAppModuleName() + ".Repo" || StringTools.endsWith(mstr, ".Repo")) && (funcName == "get" || funcName == "one")) {
									var comma = s.indexOf(",", null);
									var firstArg = if (comma != -1) {
										s.substr(0, comma);
									} else {
										s;
									};
									var trimmed = StringTools.trim(firstArg);
									{};
									var app = (function() {
										var pfx = null;
										if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null) {
											var w = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
											if (w > 0) {
												pfx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, w);
											};
										};
										if (pfx == null) {
											pfx = reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
										};
										if (pfx == null) {
											try {
												pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName();
											} catch (`:Dynamic) {
												{};
												{};
												if (true) {
													{};
													{};
												} else throw `;
											};
										};
										return pfx;
									})();
									if (app != null && trimmed.length > 0 && trimmed.indexOf(".", null) == -1 && new EReg("^[A-Z][A-Za-z0-9_]*$", "").match(trimmed)) {
										var rest = if (comma != -1) {
											s.substr(comma, null);
										} else {
											"";
										};
										s = app + "." + trimmed + rest;
									};
								};
								return s;
							};
						})();
						var moduleStr = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
						moduleStr + "." + funcName + "(" + argStr + ")";
					};
				};
			};
			case 25: {
				var ` = node[0];
				var ` = node[1];
				{
					var left = `;
					var right = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + " |> " + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
					};
				};
			};
			case 26: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var op = `;
					var left = `;
					var right = `;
					{
						if (op == reflaxe.elixir.ast.EBinaryOp.Remainder) {
							var leftStr = reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
							var rightStr = reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
							"rem(" + leftStr + ", " + rightStr + ")";
						} else {
							if (reflaxe.elixir.ast.ElixirASTPrinter.isBitwiseOp(op)) {
								var funcName = reflaxe.elixir.ast.ElixirASTPrinter.bitwiseOpToFunction(op);
								var leftStr = reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
								var rightStr = reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
								"Bitwise." + funcName + "(" + leftStr + ", " + rightStr + ")";
							} else {
								if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
									var isZeroLhs = @:ast(switch (left.def) {
	case EInteger(v) if (v == 0):
		true;	
	default:
		false;	
}) {
										var ` = left.def;
										if (enumIndex ` == 33) {
											var ` = `[0];
											{
												var v = `;
												if (v == 0) {
													true;
												} else {
													false;
												};
											};
										} else {
											false;
										};
									};
									if (isZeroLhs) {
										@:ast(switch (right.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(right, 0);	
	case EParen(innerP):
		switch (innerP.def) {
			case ECall(_, _, _) | ERemoteCall(_, _, _):
				return print(innerP, 0);			
			default:
		};	
	default:
}) {
											var ` = right.def;
											switch (enumIndex `) {
												case 22: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														return reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													};
												};
												case 24: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														return reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													};
												};
												case 54: {
													var ` = `[0];
													{
														var innerP = `;
														{
															@:ast(switch (innerP.def) {
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		return print(innerP, 0);	
	default:
}) {
																var ` = innerP.def;
																switch (enumIndex `) {
																	case 22: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			return reflaxe.elixir.ast.ElixirASTPrinter.print(innerP, 0);
																		};
																	};
																	case 24: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			return reflaxe.elixir.ast.ElixirASTPrinter.print(innerP, 0);
																		};
																	};
																	default: {}
																};
															};
														};
													};
												};
												default: {}
											};
										};
									};
									var leftStr0 = reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
									if (leftStr0 == null || StringTools.trim(leftStr0).length == 0) {
										leftStr0 = "_";
									};
									@:ast(switch (right.def) {
	case EBinary(Match, innerLeft, rhsExpr):
		var innerLeftStr = print(innerLeft, 0);
		if (innerLeftStr == leftStr0) {
			return leftStr0 + " = " + print(rhsExpr, 0);
		};	
	case EMatch(innerPattern, rhsExpr2):
		var lhsName:Null<String> = switch (innerPattern) {
			case PVar(nm):
				nm;			
			default:
				null;			
		};
		if (lhsName != null && lhsName == leftStr0) {
			return leftStr0 + " = " + print(rhsExpr2, 0);
		};	
	default:
}) {
										var ` = right.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var innerPattern = `;
													var rhsExpr2 = `;
													{
														var lhsName = @:ast(switch (innerPattern) {
	case PVar(nm):
		nm;	
	default:
		null;	
}) if (enumIndex innerPattern == 0) {
															var ` = innerPattern[0];
															{
																var nm = `;
																{
																	nm;
																};
															};
														} else {
															null;
														};
														if (lhsName != null && lhsName == leftStr0) {
															return leftStr0 + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(rhsExpr2, 0);
														};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var innerLeft = `;
														var rhsExpr = `;
														{
															var innerLeftStr = reflaxe.elixir.ast.ElixirASTPrinter.print(innerLeft, 0);
															if (innerLeftStr == leftStr0) {
																return leftStr0 + " = " + reflaxe.elixir.ast.ElixirASTPrinter.print(rhsExpr, 0);
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									var rightPrinted0 = reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
									if (rightPrinted0 != null) {
										var trimmed = StringTools.trim(rightPrinted0);
										var prefix = leftStr0 + " = ";
										if (StringTools.startsWith(trimmed, prefix)) {
											var rest = StringTools.trim(trimmed.substr(prefix.length, null));
											return leftStr0 + " = " + rest;
										};
									};
								};
								if (op == reflaxe.elixir.ast.EBinaryOp.Add) {
									@:ast(switch (left.def) {
	case EInteger(a):
		switch (right.def) {
			case EInteger(b):
				return Std.string(a + b);			
			default:
		};	
	default:
}) {
										var ` = left.def;
										if (enumIndex ` == 33) {
											var ` = `[0];
											{
												var a = `;
												{
													@:ast(switch (right.def) {
	case EInteger(b):
		return Std.string(a + b);	
	default:
}) {
														var ` = right.def;
														if (enumIndex ` == 33) {
															var ` = `[0];
															{
																var b = `;
																{
																	return Std.string(a + b);
																};
															};
														} else {};
													};
												};
											};
										} else {};
									};
								};
								var needsParens = reflaxe.elixir.ast.ElixirASTPrinter.needsParentheses(node);
								var opStr = reflaxe.elixir.ast.ElixirASTPrinter.binaryOpToString(op);
								var leftStr = @:ast(switch (left.def) {
	case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
		"(" + print(left, 0) + ")";	
	default:
		print(left, 0);	
}) {
									var ` = left.def;
									switch (enumIndex `) {
										case 6: {
											var ` = `[0];
											var ` = `[1];
											{
												"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + ")";
											};
										};
										case 7: {
											var ` = `[0];
											{
												"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + ")";
											};
										};
										case 9: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + ")";
											};
										};
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + ")";
											};
										};
										default: {
											reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
										}
									};
								};
								var rightStr = @:ast(switch (right) {
	case null:
		"0";	
	case _:
		switch (right.def) {
			case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
				if (op == Match) print(right, 0) else "(" + print(right, 0) + ")";			
			default:
				print(right, 0);			
		};	
}) if (right == null) {
									"0";
								} else {
									@:ast(switch (right.def) {
	case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
		if (op == Match) print(right, 0) else "(" + print(right, 0) + ")";	
	default:
		print(right, 0);	
}) {
										var ` = right.def;
										switch (enumIndex `) {
											case 6: {
												var ` = `[0];
												var ` = `[1];
												{
													if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
														reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													} else {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0) + ")";
													};
												};
											};
											case 7: {
												var ` = `[0];
												{
													if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
														reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													} else {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0) + ")";
													};
												};
											};
											case 9: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
														reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													} else {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0) + ")";
													};
												};
											};
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
														reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
													} else {
														"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0) + ")";
													};
												};
											};
											default: {
												reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
											}
										};
									};
								};
								if (leftStr == null || leftStr.length == 0 || StringTools.trim(leftStr).length == 0) {
									if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
										leftStr = "_";
									} else {
										leftStr = "0";
									};
								};
								if (rightStr == null || rightStr.length == 0) {
									rightStr = "0";
								};
								var result = leftStr + " " + opStr + " " + rightStr;
								if (needsParens) {
									"(" + result + ")";
								} else {
									result;
								};
							};
						};
					};
				};
			};
			case 27: {
				var ` = node[0];
				var ` = node[1];
				{
					var op = `;
					var expr = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.unaryOpToString(op) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
					};
				};
			};
			case 28: {
				var ` = node[0];
				var ` = node[1];
				{
					var target = `;
					var field = `;
					{
						if (field == "length") {
							return "length(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0) + ")";
						};
						if (field == "to_iso8601") {
							return "DateTime.to_iso8601(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0) + ")";
						};
						@:ast(switch (target.def) {
	case EAtom(atomBase):
		var combined = atomBase + "." + field;
		var tmp = makeAST(EAtom(combined));
		print(tmp, 0);	
	default:
		print(target, 0) + "." + field;	
}) {
							var ` = target.def;
							if (enumIndex ` == 31) {
								var ` = `[0];
								{
									var atomBase = `;
									{
										var combined = atomBase + "." + field;
										var tmp = {
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase(combined);
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										};
										reflaxe.elixir.ast.ElixirASTPrinter.print(tmp, 0);
									};
								};
							} else {
								reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0) + "." + field;
							};
						};
					};
				};
			};
			case 29: {
				var ` = node[0];
				var ` = node[1];
				{
					var target = `;
					var key = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0) + "[" + reflaxe.elixir.ast.ElixirASTPrinter.print(key, 0) + "]";
					};
				};
			};
			case 30: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var start = `;
					var end = `;
					var exclusive = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.print(start, 0) + (if (exclusive) {
							"...";
						} else {
							"..";
						}) + reflaxe.elixir.ast.ElixirASTPrinter.print(end, 0);
					};
				};
			};
			case 31: {
				var ` = node[0];
				{
					var value = `;
					{
						var atomStr = value;
						if (atomStr != null && atomStr.length > 0 && atomStr.charAt(0) == ":") {
							atomStr = atomStr.substr(1, null);
						};
						var needsQuotes = false;
						if (atomStr.length == 0) {
							needsQuotes = true;
						} else {
							var firstChar = atomStr.charAt(0);
							if (! reflaxe.elixir.ast.ElixirASTPrinter.isLetter(firstChar) && firstChar != "_") {
								needsQuotes = true;
							} else {
								var i = 1;
								var len = atomStr.length;
								var lastChar = atomStr.charAt(len - 1);
								var endsWithBangOrQuestion = (lastChar == "!" || lastChar == "?");
								var checkUntil = if (endsWithBangOrQuestion) {
									len - 1;
								} else {
									len;
								};
								while (i < checkUntil && ! needsQuotes) {
									var c = atomStr.charAt(i);
									if (! reflaxe.elixir.ast.ElixirASTPrinter.isLetter(c) && ! reflaxe.elixir.ast.ElixirASTPrinter.isDigit(c) && c != "_") {
										needsQuotes = true;
									};
									i ++;
								};
							};
						};
						if (needsQuotes) {
							":\"" + atomStr + "\"";
						} else {
							":" + atomStr;
						};
					};
				};
			};
			case 32: {
				var ` = node[0];
				{
					var value = `;
					{
						{};
						{};
						var strVal = if (value == null || value.indexOf("#{", null) == -1 || value.indexOf("Enum.join(", null) == -1) {
							value;
						} else {
							var out = new StringBuf();
							var i = 0;
							while (i < value.length) {
								var open = value.indexOf("#{", i);
								if (open == -1) {
									out.add(value.substr(i, null));
									break;
								};
								out.add(value.substr(i, open - i));
								var k = open + 2;
								var depth = 1;
								while (k < value.length && depth > 0) {
									var ch = value.charAt(k);
									if (ch == "{") {
										depth ++;
									} else {
										if (ch == "}") {
											depth --;
										};
									};
									k ++;
								};
								var inner = value.substr(open + 2, (k - 1) - (open + 2));
								var innerTrim = StringTools.trim(inner);
								var needsWrap = (inner.indexOf("\n", null) != -1) || (inner.indexOf("=", null) != -1 && inner.indexOf("==", null) == -1);
								if (needsWrap && ! StringTools.startsWith(innerTrim, "(fn ->")) {
									inner = "(fn -> " + inner + " end).()";
								};
								out.add("#{" + inner + "}");
								i = k;
							};
							out.toString();
						};
						strVal = if (strVal == null || strVal.indexOf("#{", null) == -1) {
							strVal;
						} else {
							var buf = new StringBuf();
							var i0 = 0;
							while (i0 < strVal.length) {
								var o = strVal.indexOf("#{", i0);
								if (o == -1) {
									buf.add(strVal.substr(i0, null));
									break;
								};
								buf.add(strVal.substr(i0, o - i0));
								var k0 = o + 2;
								var dep = 1;
								while (k0 < strVal.length && dep > 0) {
									var ch2 = strVal.charAt(k0);
									if (ch2 == "{") {
										dep ++;
									} else {
										if (ch2 == "}") {
											dep --;
										};
									};
									k0 ++;
								};
								var inner2 = strVal.substr(o + 2, (k0 - 1) - (o + 2));
								var trimmed2 = StringTools.trim(inner2);
								var already = StringTools.startsWith(trimmed2, "(fn ->");
								var outInner = if (already) {
									inner2;
								} else {
									"(fn -> " + inner2 + " end).()";
								};
								buf.add("#{" + outInner + "}");
								i0 = k0;
							};
							buf.toString();
						};
						"\"" + reflaxe.elixir.ast.ElixirASTPrinter.escapeString(strVal) + "\"";
					};
				};
			};
			case 33: {
				var ` = node[0];
				{
					var value = `;
					{
						Std.string(value);
					};
				};
			};
			case 34: {
				var ` = node[0];
				{
					var value = `;
					{
						Std.string(value);
					};
				};
			};
			case 35: {
				var ` = node[0];
				{
					var value = `;
					{
						if (value) {
							"true";
						} else {
							"false";
						};
					};
				};
			};
			case 36: {
				{
					"nil";
				};
			};
			case 37: {
				var ` = node[0];
				{
					var value = `;
					{
						"'" + reflaxe.elixir.ast.ElixirASTPrinter.escapeString(value) + "'";
					};
				};
			};
			case 38: {
				var ` = node[0];
				{
					var name = `;
					{
						{};
						var printed = @:ast(switch (nm) {
	case "fn" | "do" | "end" | "case" | "cond" | "try" | "rescue" | "catch" | "after" | "receive" | "quote" | "unquote" | "when" | "and" | "or" | "not":
		nm + "_";	
	default:
		nm;	
}) switch (name) {
							case "after", "and", "case", "catch", "cond", "do", "end", "fn", "not", "or", "quote", "receive", "rescue", "try", "unquote", "when": {
								{
									name + "_";
								};
							};
							default: {
								name;
							}
						};
						if (name != null && name.length >= 23 && name.substr(0, 23) == "__elixir_switch_result_") {
							printed = "switch_result_" + name.substr(23, null);
						};
						printed;
					};
				};
			};
			case 39: {
				var ` = node[0];
				{
					var expr = `;
					{
						"^" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
					};
				};
			};
			case 40: {
				{
					"_";
				};
			};
			case 41: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				var ` = node[3];
				var ` = node[4];
				{
					var generators = `;
					var filters = `;
					var body = `;
					var into = `;
					var uniq = `;
					{
						var genStr = {
							var ` = [];
							{
								var ` = 0;
								while (` < generators.length) {
									var g = generators[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.printPattern(g.pattern) + " <- " + reflaxe.elixir.ast.ElixirASTPrinter.print(g.expr, 0));
								};
							};
							`;
						}.join(", ");
						var filterStr = if (filters.length > 0) {
							", " + {
								var ` = [];
								{
									var ` = 0;
									while (` < filters.length) {
										var f = filters[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(f, 0));
									};
								};
								`;
							}.join(", ");
						} else {
							"";
						};
						var options = [];
						if (into != null) {
							options.push("into: " + reflaxe.elixir.ast.ElixirASTPrinter.print(into, 0));
						};
						if (uniq) {
							options.push("uniq: true");
						};
						var optStr = if (options.length > 0) {
							", " + options.join(", ");
						} else {
							"";
						};
						"for " + genStr + filterStr + optStr + ", do: " + reflaxe.elixir.ast.ElixirASTPrinter.print(body, 0);
					};
				};
			};
			case 42: {
				var ` = node[0];
				{
					var clauses = `;
					{
						if (clauses.length == 1 && clauses[0].guard == null) {
							var clause = clauses[0];
							var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(clause.args);
							var paramPart = if (clause.args.length == 0) {
								"";
							} else {
								" " + argStr;
							};
							var bodyStr = reflaxe.elixir.ast.ElixirASTPrinter.print(clause.body, indent + 1);
							{};
							bodyStr = if (bodyStr == null || bodyStr.length == 0) {
								bodyStr;
							} else {
								var lines = bodyStr.split("\n");
								var cleaned = [];
								{
									var ` = 0;
									while (` < lines.length) {
										var ln = lines[`];
										++ `;
										var t = StringTools.trim(ln);
										if (t == "1" || t == "0") {
											continue;
										};
										cleaned.push(ln);
									};
								};
								cleaned.join("\n");
							};
							var isMultiLine = @:ast(switch (clause.body.def) {
	case EIf(_, _, _):
		true;	
	case ECase(_, _):
		true;	
	case ECond(_):
		true;	
	case EBlock(exprs) if (exprs.length > 1):
		true;	
	case _:
		bodyStr.indexOf("\n") >= 0;	
}) {
								var ` = clause.body.def;
								switch (enumIndex `) {
									case 6: {
										var ` = `[0];
										var ` = `[1];
										{
											true;
										};
									};
									case 7: {
										var ` = `[0];
										{
											true;
										};
									};
									case 10: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											true;
										};
									};
									case 53: {
										var ` = `[0];
										{
											var exprs = `;
											if (exprs.length > 1) {
												true;
											} else {
												bodyStr.indexOf("\n", null) >= 0;
											};
										};
									};
									default: {
										bodyStr.indexOf("\n", null) >= 0;
									}
								};
							};
							if (isMultiLine) {
								"fn" + paramPart + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + bodyStr + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
							} else {
								"fn" + paramPart + " -> " + bodyStr + " end";
							};
						} else {
							"fn\n" + {
								var ` = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(clause.args) + (if (clause.guard != null) {
											" when " + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.guard, 0);
										} else {
											"";
										}) + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 2) + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.body, indent + 2));
									};
								};
								`;
							}.join("\n") + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
						};
					};
				};
			};
			case 43: {
				var ` = node[0];
				var ` = node[1];
				{
					var expr = `;
					var arity = `;
					{
						if (arity != null) {
							"&" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0) + "/" + arity;
						} else {
							"&" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
						};
					};
				};
			};
			case 44: {
				var ` = node[0];
				var ` = node[1];
				{
					var module = `;
					var as = `;
					{
						if (as != null) {
							"alias " + module + ", as: " + as;
						} else {
							"alias " + module;
						};
					};
				};
			};
			case 45: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var module = `;
					var only = `;
					var except = `;
					{
						var result = "import " + module;
						if (only != null) {
							result += ", only: [" + {
								var ` = [];
								{
									var ` = 0;
									while (` < only.length) {
										var o = only[`];
										++ `;
										`.push(o.name + ": " + o.arity);
									};
								};
								`;
							}.join(", ") + "]";
						} else {
							if (except != null) {
								result += ", except: [" + {
									var ` = [];
									{
										var ` = 0;
										while (` < except.length) {
											var e = except[`];
											++ `;
											`.push(e.name + ": " + e.arity);
										};
									};
									`;
								}.join(", ") + "]";
							};
						};
						result;
					};
				};
			};
			case 46: {
				var ` = node[0];
				var ` = node[1];
				{
					var module = `;
					var options = `;
					{
						if (options.length == 1) {
							@:ast(switch (options[0].def) {
	case EKeywordList(pairs):
		"use " + module + ", " + [for (p  in  pairs) {
			var value = switch (p.value.def) {
				case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
					"(" + print(p.value, 0) + ")";				
				case _:
					print(p.value, 0);				
			};
			p.key + ": " + value;
		}].join(", ");	
	case _:
		"use " + module + ", " + print(options[0], 0);	
}) {
								var ` = options[0].def;
								if (enumIndex ` == 20) {
									var ` = `[0];
									{
										var pairs = `;
										{
											"use " + module + ", " + {
												var ` = [];
												{
													var ` = 0;
													while (` < pairs.length) {
														var p = pairs[`];
														++ `;
														var value = @:ast(switch (p.value.def) {
	case EIf(cond, thenBranch, elseBranch) if (elseBranch != null && isSimpleExpression(thenBranch) && isSimpleExpression(elseBranch)):
		"(" + print(p.value, 0) + ")";	
	case _:
		print(p.value, 0);	
}) {
															var ` = p.value.def;
															if (enumIndex ` == 10) {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var cond = `;
																	var thenBranch = `;
																	var elseBranch = `;
																	if (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch)) {
																		"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(p.value, 0) + ")";
																	} else {
																		reflaxe.elixir.ast.ElixirASTPrinter.print(p.value, 0);
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTPrinter.print(p.value, 0);
															};
														};
														`.push(p.key + ": " + value);
													};
												};
												`;
											}.join(", ");
										};
									};
								} else {
									"use " + module + ", " + reflaxe.elixir.ast.ElixirASTPrinter.print(options[0], 0);
								};
							};
						} else {
							if (options.length > 0) {
								"use " + module + ", " + {
									var ` = [];
									{
										var ` = 0;
										while (` < options.length) {
											var o = options[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(o, 0));
										};
									};
									`;
								}.join(", ");
							} else {
								"use " + module;
							};
						};
					};
				};
			};
			case 47: {
				var ` = node[0];
				var ` = node[1];
				{
					var module = `;
					var as = `;
					{
						if (as != null) {
							"require " + module + ", as: " + as;
						} else {
							"require " + module;
						};
					};
				};
			};
			case 48: {
				var ` = node[0];
				var ` = node[1];
				{
					var options = `;
					var expr = `;
					{
						var optStr = if (options.length > 0) {
							" " + {
								var ` = [];
								{
									var ` = 0;
									while (` < options.length) {
										var o = options[`];
										++ `;
										`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(o, 0));
									};
								};
								`;
							}.join(", ") + ",";
						} else {
							"";
						};
						@:ast(switch (expr.def) {
	case EBlock(_):
		"quote" + optStr + " do\n" + indentStr(indent + 1) + print(expr, indent + 1) + "\n" + indentStr(indent) + "end";	
	case _:
		"quote" + optStr + " do: " + print(expr, 0);	
}) {
							var ` = expr.def;
							if (enumIndex ` == 53) {
								var ` = `[0];
								{
									"quote" + optStr + " do\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1) + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
								};
							} else {
								"quote" + optStr + " do: " + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0);
							};
						};
					};
				};
			};
			case 49: {
				var ` = node[0];
				{
					var expr = `;
					{
						"unquote(" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0) + ")";
					};
				};
			};
			case 50: {
				var ` = node[0];
				{
					var expr = `;
					{
						"unquote_splicing(" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0) + ")";
					};
				};
			};
			case 51: {
				var ` = node[0];
				var ` = node[1];
				{
					var clauses = `;
					var after = `;
					{
						var result = "receive do\n";
						{
							var ` = 0;
							while (` < clauses.length) {
								var clause = clauses[`];
								++ `;
								result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.printCaseClause(clause, indent + 1) + "\n";
							};
						};
						if (after != null) {
							result += reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "after\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(after.timeout, 0) + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 2) + reflaxe.elixir.ast.ElixirASTPrinter.print(after.body, indent + 2) + "\n";
						};
						result + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 52: {
				var ` = node[0];
				var ` = node[1];
				{
					var target = `;
					var message = `;
					{
						"send(" + reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0) + ", " + reflaxe.elixir.ast.ElixirASTPrinter.print(message, 0) + ")";
					};
				};
			};
			case 53: {
				var ` = node[0];
				{
					var expressions = `;
					{
						{};
						var statements = {
							var ` = [];
							{
								var ` = 0;
								while (` < expressions.length) {
									var e = expressions[`];
									++ `;
									if (! @:ast(switch (e.def) {
	case EInteger(v) if (v == 0 || v == 1):
		true;	
	case EFloat(f) if (f == 0.0):
		true;	
	case ERaw(code) if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")):
		true;	
	default:
		false;	
}) {
										var ` = e.def;
										switch (enumIndex `) {
											case 33: {
												var ` = `[0];
												{
													var v = `;
													if (v == 0 || v == 1) {
														true;
													} else {
														false;
													};
												};
											};
											case 34: {
												var ` = `[0];
												{
													var f = `;
													if (f == 0.0) {
														true;
													} else {
														false;
													};
												};
											};
											case 62: {
												var ` = `[0];
												{
													var code = `;
													if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")) {
														true;
													} else {
														false;
													};
												};
											};
											default: {
												false;
											}
										};
									}) {
										`.push(e);
									};
								};
							};
							`;
						};
						if (statements.length == 0) {
							"";
						} else {
							if (statements.length == 1) {
								reflaxe.elixir.ast.ElixirASTPrinter.print(statements[0], indent);
							} else {
								var parts = [];
								var printed = [];
								{
									var ` = 0;
									while (` < statements.length) {
										var expr = statements[`];
										++ `;
										var str = reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent);
										if (str != null && StringTools.trim(str).length > 0) {
											printed.push(str);
										};
									};
								};
								{
									var ` = 0;
									var ` = printed.length;
									while (` < `) {
										var i = ` ++;
										parts.push(printed[i]);
										if (i < printed.length - 1) {
											parts.push("\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent));
										};
									};
								};
								parts.join("");
							};
						};
					};
				};
			};
			case 54: {
				var ` = node[0];
				{
					var expr = `;
					{
						"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, 0) + ")";
					};
				};
			};
			case 55: {
				var ` = node[0];
				{
					var body = `;
					{
						{};
						var bodyStmts = {
							var ` = [];
							{
								var ` = 0;
								while (` < body.length) {
									var e = body[`];
									++ `;
									if (! @:ast(switch (e.def) {
	case EInteger(v) if (v == 0 || v == 1):
		true;	
	case EFloat(f) if (f == 0.0):
		true;	
	case ERaw(code) if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")):
		true;	
	default:
		false;	
}) {
										var ` = e.def;
										switch (enumIndex `) {
											case 33: {
												var ` = `[0];
												{
													var v = `;
													if (v == 0 || v == 1) {
														true;
													} else {
														false;
													};
												};
											};
											case 34: {
												var ` = `[0];
												{
													var f = `;
													if (f == 0.0) {
														true;
													} else {
														false;
													};
												};
											};
											case 62: {
												var ` = `[0];
												{
													var code = `;
													if (code != null && (StringTools.trim(code) == "1" || StringTools.trim(code) == "0")) {
														true;
													} else {
														false;
													};
												};
											};
											default: {
												false;
											}
										};
									}) {
										`.push(e);
									};
								};
							};
							`;
						};
						"do\n" + {
							var ` = [];
							{
								var ` = 0;
								while (` < bodyStmts.length) {
									var expr = bodyStmts[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(expr, indent + 1));
								};
							};
							`;
						}.join("\n") + "\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent) + "end";
					};
				};
			};
			case 56: {
				var ` = node[0];
				var ` = node[1];
				{
					var name = `;
					var value = `;
					{
						"@" + name + " " + reflaxe.elixir.ast.ElixirASTPrinter.print(value, indent);
					};
				};
			};
			case 57: {
				var ` = node[0];
				{
					var content = `;
					{
						"@moduledoc \"\"\"" + "\n" + content + "\n" + "\"\"\"";
					};
				};
			};
			case 58: {
				var ` = node[0];
				{
					var content = `;
					{
						"@doc \"\"\"" + "\n" + content + "\n" + "\"\"\"";
					};
				};
			};
			case 59: {
				var ` = node[0];
				{
					var signature = `;
					{
						"@spec " + signature;
					};
				};
			};
			case 60: {
				var ` = node[0];
				var ` = node[1];
				{
					var name = `;
					var definition = `;
					{
						"@type " + name + " :: " + definition;
					};
				};
			};
			case 61: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var type = `;
					var content = `;
					var modifiers = `;
					{
						{};
						{};
						{};
						var normalized = if (content == null || content.length == 0) {
							content;
						} else {
							var lines = content.split("\n");
							var start = 0;
							while (start < lines.length && StringTools.trim(lines[start]) == "") {
								start ++;
							};
							var endIdx = lines.length - 1;
							while (endIdx >= start && StringTools.trim(lines[endIdx]) == "") {
								endIdx --;
							};
							if (start > endIdx) {
								"";
							} else {
								var slice = lines.slice(start, endIdx + 1);
								var minIndent = 1000000;
								{
									var ` = 0;
									while (` < slice.length) {
										var ln = slice[`];
										++ `;
										if (StringTools.trim(ln) == "") {
											continue;
										};
										var i = 0;
										while (i < ln.length && ln.charAt(i) == " ") {
											i ++;
										};
										if (i < minIndent) {
											minIndent = i;
										};
									};
								};
								if (minIndent == 1000000) {
									minIndent = 0;
								};
								var out = new StringBuf();
								{
									var ` = 0;
									var ` = slice.length;
									while (` < `) {
										var i = ` ++;
										var ln = slice[i];
										if (minIndent > 0 && ln.length >= minIndent) {
											ln = ln.substr(minIndent, null);
										};
										out.add(ln);
										if (i < slice.length - 1) {
											out.add("\n");
										};
									};
								};
								out.toString();
							};
						};
						normalized = if (normalized == null || normalized.indexOf("<%=", null) == -1) {
							normalized;
						} else {
							var out = new StringBuf();
							var i = 0;
							while (i < normalized.length) {
								var o = normalized.indexOf(StringTools.replace("<% =", " ", ""), i);
								if (o == -1) {
									out.add(normalized.substr(i, null));
									break;
								};
								out.add(normalized.substr(i, o - i));
								var c = normalized.indexOf("%>", o + 3);
								if (c == -1) {
									out.add(normalized.substr(o, null));
									break;
								};
								var inner = StringTools.trim(normalized.substr(o + 3, c - (o + 3)));
								if (StringTools.startsWith(inner, "~H\"\"\"")) {
									var st = inner.indexOf("\"\"\"", null);
									if (st != -1) {
										var bs = st + 3;
										var be = inner.indexOf("\"\"\"", bs);
										if (be != -1) {
											out.add(inner.substr(bs, be - bs));
											i = c + 2;
											continue;
										};
									};
								};
								out.add(normalized.substr(o, (c + 2) - o));
								i = c + 2;
							};
							var flattened = out.toString();
							if (flattened.indexOf("<%= ~H\"\"\"", null) != -1) {
								flattened = flattened.split("<%= ~H\"\"\"").join("");
								flattened = flattened.split("\"\"\" %>").join("");
							};
							flattened;
						};
						"~" + type + "\"\"\"" + "\n" + normalized + "\n" + "\"\"\"" + modifiers;
					};
				};
			};
			case 62: {
				var ` = node[0];
				{
					var code = `;
					{
						{};
						var out = code;
						if (out.indexOf("Ecto.Query.from(", null) != -1) {
							var pfx = null;
							if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null) {
								var idxA = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
								if (idxA > 0) {
									pfx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idxA);
								} else {
									var idxB = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf(".Repo", null);
									if (idxB > 0) {
										pfx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idxB);
									};
								};
							};
							if (pfx == null && reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix != null) {
								pfx = reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
							};
							if (pfx == null) {
								try {
									pfx = reflaxe.elixir.PhoenixMapper.getAppModuleName();
								} catch (`:Dynamic) {
									{};
									{};
									if (true) {
										{};
										{};
									} else throw `;
								};
							};
							if (pfx != null && pfx.length > 0) {
								var buf = new StringBuf();
								var i = 0;
								while (i < out.length) {
									if (i + 5 < out.length && out.substr(i, 5) == " in :") {
										var j = i + 5;
										var name = new StringBuf();
										while (j < out.length) {
											var ch = out.charAt(j);
											var isAlnum = new EReg("^[A-Za-z0-9_]$", "").match(ch);
											if (! isAlnum) {
												break;
											};
											name.add(ch);
											j ++;
										};
										var raw = name.toString();
										if (raw.length > 0) {
											buf.add(" in ");
											buf.add(pfx);
											buf.add(".");
											buf.add({
												var parts = raw.split("_");
												var out = [];
												{
													var ` = 0;
													while (` < parts.length) {
														var p = parts[`];
														++ `;
														if (p.length > 0) {
															out.push(p.charAt(0).toUpperCase() + p.substr(1, null));
														};
													};
												};
												out.join("");
											});
											i = j;
											continue;
										};
									};
									buf.add(out.charAt(i));
									i ++;
								};
								out = buf.toString();
							};
						};
						{};
						out = if (out == null || out.indexOf("#{", null) == -1) {
							out;
						} else {
							var buf = new StringBuf();
							var i0 = 0;
							while (i0 < out.length) {
								var o = out.indexOf("#{", i0);
								if (o == -1) {
									buf.add(out.substr(i0, null));
									break;
								};
								buf.add(out.substr(i0, o - i0));
								var k0 = o + 2;
								var dep = 1;
								while (k0 < out.length && dep > 0) {
									var ch = out.charAt(k0);
									if (ch == "{") {
										dep ++;
									} else {
										if (ch == "}") {
											dep --;
										};
									};
									k0 ++;
								};
								var inner = out.substr(o + 2, (k0 - 1) - (o + 2));
								var trimmed = StringTools.trim(inner);
								var alreadyIife = StringTools.startsWith(trimmed, "(fn ->");
								var needsWrap = ! alreadyIife;
								var innerOut = if (needsWrap) {
									"(fn -> " + inner + " end).()";
								} else {
									inner;
								};
								buf.add("#{" + innerOut + "}");
								i0 = k0;
							};
							buf.toString();
						};
						out;
					};
				};
			};
			case 63: {
				var ` = node[0];
				{
					var name = `;
					{
						"@" + name;
					};
				};
			};
			case 64: {
				var ` = node[0];
				var ` = node[1];
				var ` = node[2];
				{
					var tag = `;
					var attributes = `;
					var children = `;
					{
						"<" + tag + reflaxe.elixir.ast.ElixirASTPrinter.printAttributes(attributes) + ">" + {
							var ` = [];
							{
								var ` = 0;
								while (` < children.length) {
									var c = children[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(c, 0));
								};
							};
							`;
						}.join("") + "</" + tag + ">";
					};
				};
			};
		};
	}

	static function printPattern(pattern:reflaxe.elixir.ast.EPattern) {
		return @:ast(switch (pattern) {
	case PVar(name):
		var nm = name;
		if (nm == null || StringTools.trim(nm).length == 0) nm = "_";
		nm;	
	case PLiteral(value):
		print(value, 0);	
	case PTuple(elements):
		"{" + printPatterns(elements) + "}";	
	case PList(elements):
		"[" + printPatterns(elements) + "]";	
	case PCons(head, tail):
		"[" + printPattern(head) + " | " + printPattern(tail) + "]";	
	case PMap(pairs):
		"%{" + [for (p  in  pairs) print(p.key, 0) + " => " + printPattern(p.value)].join(", ") + "}";	
	case PStruct(module, fields):
		"%" + module + "{" + [for (f  in  fields) f.key + ": " + printPattern(f.value)].join(", ") + "}";	
	case PPin(pattern):
		"^" + printPattern(pattern);	
	case PWildcard:
		"_";	
	case PAlias(varName, pattern):
		printPattern(pattern) + " = " + varName;	
	case PBinary(segments):
		"<<" + [for (s  in  segments) printPatternBinarySegment(s)].join(", ") + ">>";	
}) switch (@:exhaustive enumIndex pattern) {
			case 0: {
				var ` = pattern[0];
				{
					var name = `;
					{
						var nm = name;
						if (nm == null || StringTools.trim(nm).length == 0) {
							nm = "_";
						};
						nm;
					};
				};
			};
			case 1: {
				var ` = pattern[0];
				{
					var value = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.print(value, 0);
					};
				};
			};
			case 2: {
				var ` = pattern[0];
				{
					var elements = `;
					{
						"{" + reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(elements) + "}";
					};
				};
			};
			case 3: {
				var ` = pattern[0];
				{
					var elements = `;
					{
						"[" + reflaxe.elixir.ast.ElixirASTPrinter.printPatterns(elements) + "]";
					};
				};
			};
			case 4: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var head = `;
					var tail = `;
					{
						"[" + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(head) + " | " + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(tail) + "]";
					};
				};
			};
			case 5: {
				var ` = pattern[0];
				{
					var pairs = `;
					{
						"%{" + {
							var ` = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.print(p.key, 0) + " => " + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(p.value));
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 6: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var module = `;
					var fields = `;
					{
						"%" + module + "{" + {
							var ` = [];
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									`.push(f.key + ": " + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(f.value));
								};
							};
							`;
						}.join(", ") + "}";
					};
				};
			};
			case 7: {
				var ` = pattern[0];
				{
					var pattern = `;
					{
						"^" + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(pattern);
					};
				};
			};
			case 8: {
				{
					"_";
				};
			};
			case 9: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var varName = `;
					var pattern = `;
					{
						reflaxe.elixir.ast.ElixirASTPrinter.printPattern(pattern) + " = " + varName;
					};
				};
			};
			case 10: {
				var ` = pattern[0];
				{
					var segments = `;
					{
						"<<" + {
							var ` = [];
							{
								var ` = 0;
								while (` < segments.length) {
									var s = segments[`];
									++ `;
									`.push(reflaxe.elixir.ast.ElixirASTPrinter.printPatternBinarySegment(s));
								};
							};
							`;
						}.join(", ") + ">>";
					};
				};
			};
		};
	}

	static function printPatterns(patterns:Array<reflaxe.elixir.ast.EPattern>) {
		return {
			var ` = [];
			{
				var ` = 0;
				while (` < patterns.length) {
					var p = patterns[`];
					++ `;
					`.push(reflaxe.elixir.ast.ElixirASTPrinter.printPattern(p));
				};
			};
			`;
		}.join(", ");
	}

	static function printCaseClause(clause:reflaxe.elixir.ast.ECaseClause, indent:Int) {
		var head = reflaxe.elixir.ast.ElixirASTPrinter.printPattern(clause.pattern);
		if (clause.guard != null) {
			head += " when " + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.guard, 0);
		};
		var body = clause.body;
		var bodyStr = reflaxe.elixir.ast.ElixirASTPrinter.print(body, indent + 1);
		if (StringTools.trim(bodyStr) == "") {
			bodyStr = "nil";
		};
		var isBlock = @:ast(switch (body.def) {
	case EBlock(_):
		true;	
	default:
		false;	
}) {
			var ` = body.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
		var isMulti = @:ast(switch (body.def) {
	case EIf(_, _, _) | ECase(_, _) | ECond(_) | EWith(_, _, _):
		true;	
	case ECall(_, _, _) | ERemoteCall(_, _, _):
		true;	
	case EBlock(exprs) if (exprs.length > 1):
		true;	
	case _:
		bodyStr.indexOf("\n") >= 0;	
}) {
			var ` = body.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 7: {
					var ` = `[0];
					{
						true;
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length > 1) {
							true;
						} else {
							bodyStr.indexOf("\n", null) >= 0;
						};
					};
				};
				default: {
					bodyStr.indexOf("\n", null) >= 0;
				}
			};
		};
		var preferSingle = ! isBlock && ! isMulti && (bodyStr.length <= 120);
		if (! preferSingle && isMulti) {
			return head + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + bodyStr;
		} else {
			return head + " -> " + bodyStr;
		};
	}

	static function printRescueClause(clause:reflaxe.elixir.ast.ERescueClause, indent:Int) {
		var result = reflaxe.elixir.ast.ElixirASTPrinter.printPattern(clause.pattern);
		if (clause.varName != null) {
			result += " -> " + clause.varName;
		};
		result += " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.body, indent + 1);
		return result;
	}

	static function printCatchClause(clause:reflaxe.elixir.ast.ECatchClause, indent:Int) {
		var kindStr = @:ast(switch (clause.kind) {
	case Error:
		":error";	
	case Exit:
		":exit";	
	case Throw:
		":throw";	
	case Any:
		"_";	
}) {
			var ` = clause.kind;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					{
						":error";
					};
				};
				case 1: {
					{
						":exit";
					};
				};
				case 2: {
					{
						":throw";
					};
				};
				case 3: {
					{
						"_";
					};
				};
			};
		};
		return kindStr + ", " + reflaxe.elixir.ast.ElixirASTPrinter.printPattern(clause.pattern) + " ->\n" + reflaxe.elixir.ast.ElixirASTPrinter.indentStr(indent + 1) + reflaxe.elixir.ast.ElixirASTPrinter.print(clause.body, indent + 1);
	}

	static function printAttribute(attr:reflaxe.elixir.ast.EAttribute) {
		return "@" + attr.name + " " + reflaxe.elixir.ast.ElixirASTPrinter.print(attr.value, 0);
	}

	static function printAttributes(attrs:Array<reflaxe.elixir.ast.EAttribute>) {
		if (attrs.length == 0) {
			return "";
		};
		var parts = [];
		{
			var ` = 0;
			while (` < attrs.length) {
				var a = attrs[`];
				++ `;
				var rendered = @:ast(switch (a.value.def) {
	case EString(v):
		"\"" + v + "\"";	
	default:
		"{" + print(a.value, 0) + "}";	
}) {
					var ` = a.value.def;
					if (enumIndex ` == 32) {
						var ` = `[0];
						{
							var v = `;
							{
								"\"" + v + "\"";
							};
						};
					} else {
						"{" + reflaxe.elixir.ast.ElixirASTPrinter.print(a.value, 0) + "}";
					};
				};
				parts.push(a.name + "=" + rendered);
			};
		};
		return " " + parts.join(" ");
	}

	static function printBinarySegment(segment:reflaxe.elixir.ast.EBinarySegment) {
		var result = reflaxe.elixir.ast.ElixirASTPrinter.print(segment.value, 0);
		var specs = [];
		if (segment.size != null) {
			specs.push("size(" + reflaxe.elixir.ast.ElixirASTPrinter.print(segment.size, 0) + ")");
		};
		if (segment.type != null) {
			specs.push(segment.type);
		};
		if (segment.modifiers != null) {
			specs = specs.concat(segment.modifiers);
		};
		if (specs.length > 0) {
			result += "::" + specs.join("-");
		};
		return result;
	}

	static function printPatternBinarySegment(segment:reflaxe.elixir.ast.PBinarySegment) {
		var result = reflaxe.elixir.ast.ElixirASTPrinter.printPattern(segment.pattern);
		var specs = [];
		if (segment.size != null) {
			specs.push("size(" + reflaxe.elixir.ast.ElixirASTPrinter.print(segment.size, 0) + ")");
		};
		if (segment.type != null) {
			specs.push(segment.type);
		};
		if (segment.modifiers != null) {
			specs = specs.concat(segment.modifiers);
		};
		if (specs.length > 0) {
			result += "::" + specs.join("-");
		};
		return result;
	}

	static function binaryOpToString(op:reflaxe.elixir.ast.EBinaryOp) {
		return @:ast(switch (op) {
	case Add:
		"+";	
	case Subtract:
		"-";	
	case Multiply:
		"*";	
	case Divide:
		"/";	
	case Remainder:
		"rem";	
	case Power:
		"**";	
	case Equal:
		"==";	
	case NotEqual:
		"!=";	
	case StrictEqual:
		"===";	
	case StrictNotEqual:
		"!==";	
	case Less:
		"<";	
	case Greater:
		">";	
	case LessEqual:
		"<=";	
	case GreaterEqual:
		">=";	
	case And:
		"and";	
	case Or:
		"or";	
	case AndAlso:
		"&&";	
	case OrElse:
		"||";	
	case BitwiseAnd:
		"&&&";	
	case BitwiseOr:
		"|||";	
	case BitwiseXor:
		"^^^";	
	case ShiftLeft:
		"<<<";	
	case ShiftRight:
		">>>";	
	case Concat:
		"++";	
	case ListSubtract:
		"--";	
	case In:
		"in";	
	case StringConcat:
		"<>";	
	case Match:
		"=";	
	case Pipe:
		"|>";	
	case TypeCheck:
		"::";	
	case When:
		"when";	
}) switch (@:exhaustive enumIndex op) {
			case 0: {
				{
					"+";
				};
			};
			case 1: {
				{
					"-";
				};
			};
			case 2: {
				{
					"*";
				};
			};
			case 3: {
				{
					"/";
				};
			};
			case 4: {
				{
					"rem";
				};
			};
			case 5: {
				{
					"**";
				};
			};
			case 6: {
				{
					"==";
				};
			};
			case 7: {
				{
					"!=";
				};
			};
			case 8: {
				{
					"===";
				};
			};
			case 9: {
				{
					"!==";
				};
			};
			case 10: {
				{
					"<";
				};
			};
			case 11: {
				{
					">";
				};
			};
			case 12: {
				{
					"<=";
				};
			};
			case 13: {
				{
					">=";
				};
			};
			case 14: {
				{
					"and";
				};
			};
			case 15: {
				{
					"or";
				};
			};
			case 16: {
				{
					"&&";
				};
			};
			case 17: {
				{
					"||";
				};
			};
			case 18: {
				{
					"&&&";
				};
			};
			case 19: {
				{
					"|||";
				};
			};
			case 20: {
				{
					"^^^";
				};
			};
			case 21: {
				{
					"<<<";
				};
			};
			case 22: {
				{
					">>>";
				};
			};
			case 23: {
				{
					"++";
				};
			};
			case 24: {
				{
					"--";
				};
			};
			case 25: {
				{
					"<>";
				};
			};
			case 26: {
				{
					"in";
				};
			};
			case 27: {
				{
					"=";
				};
			};
			case 28: {
				{
					"|>";
				};
			};
			case 29: {
				{
					"::";
				};
			};
			case 30: {
				{
					"when";
				};
			};
		};
	}

	static function isBitwiseOp(op:reflaxe.elixir.ast.EBinaryOp) {
		return @:ast(switch (op) {
	case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
		true;	
	default:
		false;	
}) switch (enumIndex op) {
			case 18, 19, 20, 21, 22: {
				{
					true;
				};
			};
			default: {
				false;
			}
		};
	}

	static function bitwiseOpToFunction(op:reflaxe.elixir.ast.EBinaryOp) {
		return @:ast(switch (op) {
	case BitwiseAnd:
		"band";	
	case BitwiseOr:
		"bor";	
	case BitwiseXor:
		"bxor";	
	case ShiftLeft:
		"bsl";	
	case ShiftRight:
		"bsr";	
	default:
		throw "Not a bitwise operator: $op";	
}) switch (enumIndex op) {
			case 18: {
				{
					"band";
				};
			};
			case 19: {
				{
					"bor";
				};
			};
			case 20: {
				{
					"bxor";
				};
			};
			case 21: {
				{
					"bsl";
				};
			};
			case 22: {
				{
					"bsr";
				};
			};
			default: {
				throw "Not a bitwise operator: " + Std.string(op);
			}
		};
	}

	static function unaryOpToString(op:reflaxe.elixir.ast.EUnaryOp) {
		return @:ast(switch (op) {
	case Not:
		"not ";	
	case Negate:
		"-";	
	case Positive:
		"+";	
	case BitwiseNot:
		"~~~";	
	case Bang:
		"!";	
}) switch (@:exhaustive enumIndex op) {
			case 0: {
				{
					"not ";
				};
			};
			case 1: {
				{
					"-";
				};
			};
			case 2: {
				{
					"+";
				};
			};
			case 3: {
				{
					"~~~";
				};
			};
			case 4: {
				{
					"!";
				};
			};
		};
	}

	static function needsParentheses(node:reflaxe.elixir.ast.ElixirASTDef) {
		return @:ast(switch (node) {
	case EBinary(Subtract, _, _):
		true;	
	case EBinary(op, _, _):
		false;	
	default:
		false;	
}) if (enumIndex node == 26) {
			var ` = node[0];
			var ` = node[1];
			var ` = node[2];
			if (enumIndex ` == 1) {
				{
					true;
				};
			} else {
				var op = `;
				{
					false;
				};
			};
		} else {
			false;
		};
	}

	static function escapeString(s:String) {
		return StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(s, "\\", "\\\\"), "\"", "\\\""), "\n", "\\n"), "\r", "\\r"), "\t", "\\t");
	}

	static function indentStr(level:Int) {
		var result = "";
		{
			var ` = 0;
			var ` = level;
			while (` < `) {
				var i = ` ++;
				result += "  ";
			};
		};
		return result;
	}

	static function isSimpleExpression(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EVar(_) | EAtom(_) | ENil | EString(_) | EInteger(_) | EFloat(_) | EBoolean(_) | EField(_, _) | ETuple(_) | EList(_) | EMap(_):
		true;	
	case ECall(_, _, args):
		args.length <= 2;	
	case EBinary(op, left, right):
		if (op == Match) {
			false;
		} else {
			isSimpleExpression(left) && isSimpleExpression(right);
		};	
	case EMatch(_, _):
		false;	
	case EBlock(expressions):
		if (expressions.length == 0) {
			return false;
		};
		for (expr  in  expressions) {
			if (containsAssignment(expr)) {
				return false;
			};
		};
		expressions.length == 1 && isSimpleExpression(expressions[0]);	
	case _:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						false;
					};
				};
				case 15: {
					var ` = `[0];
					{
						true;
					};
				};
				case 16: {
					var ` = `[0];
					{
						true;
					};
				};
				case 17: {
					var ` = `[0];
					{
						true;
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var args = `;
						{
							args.length <= 2;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
								false;
							} else {
								reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(left) && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(right);
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 31: {
					var ` = `[0];
					{
						true;
					};
				};
				case 32: {
					var ` = `[0];
					{
						true;
					};
				};
				case 33: {
					var ` = `[0];
					{
						true;
					};
				};
				case 34: {
					var ` = `[0];
					{
						true;
					};
				};
				case 35: {
					var ` = `[0];
					{
						true;
					};
				};
				case 36: {
					{
						true;
					};
				};
				case 38: {
					var ` = `[0];
					{
						true;
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							if (expressions.length == 0) {
								return false;
							};
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTPrinter.containsAssignment(expr)) {
										return false;
									};
								};
							};
							expressions.length == 1 && reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(expressions[0]);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function containsAssignment(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EMatch(_, _):
		true;	
	case EBinary(op, _, _) if (op == Match):
		true;	
	case EBlock(expressions):
		for (expr  in  expressions) {
			if (containsAssignment(expr)) return true;
		};
		false;	
	case EIf(_, thenBranch, elseBranch):
		containsAssignment(thenBranch) || (elseBranch != null && containsAssignment(elseBranch));	
	case _:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var thenBranch = `;
						var elseBranch = `;
						{
							reflaxe.elixir.ast.ElixirASTPrinter.containsAssignment(thenBranch) || (elseBranch != null && reflaxe.elixir.ast.ElixirASTPrinter.containsAssignment(elseBranch));
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						if (op == reflaxe.elixir.ast.EBinaryOp.Match) {
							true;
						} else {
							false;
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						{
							{
								var ` = 0;
								while (` < expressions.length) {
									var expr = expressions[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTPrinter.containsAssignment(expr)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function printIfCondition(condition:reflaxe.elixir.ast.ElixirAST) {
		if (condition == null) {
			return "";
		};
		@:ast(switch (condition.def) {
	case EBinary(_, left, right):
		var needsLeft = switch (left.def) {
			case ECase(_, _) | ECond(_) | EWith(_, _, _) | EIf(_, _, _):
				true;			
			default:
				false;			
		};
		var needsRight = switch (right) {
			case null:
				false;			
			case _:
				switch (right.def) {
					case ECase(_, _) | ECond(_) | EWith(_, _, _) | EIf(_, _, _):
						true;					
					default:
						false;					
				};			
		};
		var leftStr = needsLeft ? "(" + print(left, 0) + ")" : print(left, 0);
		var opStr = binaryOpToString(switch (condition.def) {
			case EBinary(op, _, _):
				op;			
			default:
				Add;			
		});
		var rightStr = (right == null) ? "0" : (needsRight ? "(" + print(right, 0) + ")" : print(right, 0));
		var exprStr = leftStr + " " + opStr + " " + rightStr;
		return exprStr;	
	case EParen(inner):
		if (isSimpleVariable(inner)) {
			return print(inner, 0);
		};
		return "(" + print(inner, 0) + ")";	
	default:
		var s = print(condition, 0);
		var hasComplex = (s.indexOf("case ") != -1 || s.indexOf("cond ") != -1 || s.indexOf("with ") != -1);
		var hasCmpLoose = (s.indexOf(">") != -1 || s.indexOf("<") != -1 || s.indexOf("==") != -1 || s.indexOf("!=") != -1);
		if (hasComplex && hasCmpLoose && !StringTools.startsWith(StringTools.trim(s), "(")) {
			return "(" + s + ")";
		};
		return s;	
}) {
			var ` = condition.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							var needsLeft = @:ast(switch (left.def) {
	case ECase(_, _) | ECond(_) | EWith(_, _, _) | EIf(_, _, _):
		true;	
	default:
		false;	
}) {
								var ` = left.def;
								switch (enumIndex `) {
									case 6: {
										var ` = `[0];
										var ` = `[1];
										{
											true;
										};
									};
									case 7: {
										var ` = `[0];
										{
											true;
										};
									};
									case 9: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											true;
										};
									};
									case 10: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											true;
										};
									};
									default: {
										false;
									}
								};
							};
							var needsRight = @:ast(switch (right) {
	case null:
		false;	
	case _:
		switch (right.def) {
			case ECase(_, _) | ECond(_) | EWith(_, _, _) | EIf(_, _, _):
				true;			
			default:
				false;			
		};	
}) if (right == null) {
								false;
							} else {
								@:ast(switch (right.def) {
	case ECase(_, _) | ECond(_) | EWith(_, _, _) | EIf(_, _, _):
		true;	
	default:
		false;	
}) {
									var ` = right.def;
									switch (enumIndex `) {
										case 6: {
											var ` = `[0];
											var ` = `[1];
											{
												true;
											};
										};
										case 7: {
											var ` = `[0];
											{
												true;
											};
										};
										case 9: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												true;
											};
										};
										case 10: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												true;
											};
										};
										default: {
											false;
										}
									};
								};
							};
							var leftStr = if (needsLeft) {
								"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0) + ")";
							} else {
								reflaxe.elixir.ast.ElixirASTPrinter.print(left, 0);
							};
							var opStr = reflaxe.elixir.ast.ElixirASTPrinter.binaryOpToString(@:ast(switch (condition.def) {
	case EBinary(op, _, _):
		op;	
	default:
		Add;	
}) {
								var ` = condition.def;
								if (enumIndex ` == 26) {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var op = `;
										{
											op;
										};
									};
								} else {
									reflaxe.elixir.ast.EBinaryOp.Add;
								};
							});
							var rightStr = if ((right == null)) {
								"0";
							} else {
								(if (needsRight) {
									"(" + reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0) + ")";
								} else {
									reflaxe.elixir.ast.ElixirASTPrinter.print(right, 0);
								});
							};
							var exprStr = leftStr + " " + opStr + " " + rightStr;
							return exprStr;
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							if (reflaxe.elixir.ast.ElixirASTPrinter.isSimpleVariable(inner)) {
								return reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0);
							};
							return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0) + ")";
						};
					};
				};
				default: {
					var s = reflaxe.elixir.ast.ElixirASTPrinter.print(condition, 0);
					var hasComplex = (s.indexOf("case ", null) != -1 || s.indexOf("cond ", null) != -1 || s.indexOf("with ", null) != -1);
					var hasCmpLoose = (s.indexOf(">", null) != -1 || s.indexOf("<", null) != -1 || s.indexOf("==", null) != -1 || s.indexOf("!=", null) != -1);
					if (hasComplex && hasCmpLoose && ! StringTools.startsWith(StringTools.trim(s), "(")) {
						return "(" + s + ")";
					};
					return s;
				}
			};
		};
	}

	static function isSimpleVariable(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EVar(_) | ENil | EBoolean(_):
		true;	
	default:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 35: {
					var ` = `[0];
					{
						true;
					};
				};
				case 36: {
					{
						true;
					};
				};
				case 38: {
					var ` = `[0];
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	@:value({ indentLevel : 0 })
	static function printFunctionArg(arg:reflaxe.elixir.ast.ElixirAST, indentLevel:Int = 0) {
		if (arg == null) {
			return "";
		};
		@:ast(switch (arg.def) {
	case ERemoteCall(module, funcName, args) if (funcName == "new" && args.length == 0):
		var moduleStr = printQualifiedModule(module);
		return "%" + moduleStr + "{}";	
	case ECall(module, funcName, args) if (module != null && funcName == "new" && args.length == 0):
		var moduleStr = printQualifiedModule(module);
		return "%" + moduleStr + "{}";	
	case EIf(condition, thenBranch, elseBranch):
		var needsParens = if (arg.metadata != null && arg.metadata.keepInlineInAssignment == true) {
			true;
		} else {
			var thenSimple = isSimpleExpression(thenBranch);
			var elseSimple = elseBranch != null ? isSimpleExpression(elseBranch) : true;
			thenSimple && elseSimple;
		};
		if (needsParens) {
			return "(" + print(arg, indentLevel) + ")";
		} else {
			return print(arg, indentLevel);
		};	
	case ECase(_, _) | ECond(_) | EWith(_, _, _):
		return "(" + print(arg, indentLevel) + ")";	
	case EBinary(Match, _, _):
		return "(" + print(arg, indentLevel) + ")";	
	case EBlock(expressions) if (expressions.length > 1):
		return "(fn -> " + print(arg, indentLevel).rtrim() + " end).()";	
	case EDo(stmts) if (stmts.length > 1):
		return "(fn -> " + print(arg, indentLevel).rtrim() + " end).()";	
	case EParen(inner) if (switch (inner.def) {
	case EBlock(exprs) if (exprs.length > 1):
		true;	
	default:
		false;	
}):
		return "(fn -> " + print(inner, indentLevel).rtrim() + " end).()";	
	default:
		return print(arg, indentLevel);	
}) {
			var ` = arg.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel) + ")";
					};
				};
				case 7: {
					var ` = `[0];
					{
						return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel) + ")";
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel) + ")";
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var needsParens = if (arg.metadata != null && arg.metadata.keepInlineInAssignment == true) {
								true;
							} else {
								var thenSimple = reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(thenBranch);
								var elseSimple = if (elseBranch != null) {
									reflaxe.elixir.ast.ElixirASTPrinter.isSimpleExpression(elseBranch);
								} else {
									true;
								};
								thenSimple && elseSimple;
							};
							if (needsParens) {
								return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel) + ")";
							} else {
								return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						if (module != null && funcName == "new" && args.length == 0) {
							var moduleStr = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
							return "%" + moduleStr + "{}";
						} else {
							return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						if (funcName == "new" && args.length == 0) {
							var moduleStr = reflaxe.elixir.ast.ElixirASTPrinter.printQualifiedModule(module);
							return "%" + moduleStr + "{}";
						} else {
							return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							return "(" + reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel) + ")";
						};
					} else {
						return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
					};
				};
				case 53: {
					var ` = `[0];
					{
						var expressions = `;
						if (expressions.length > 1) {
							return "(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel)) + " end).()";
						} else {
							return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						if (@:ast(switch (inner.def) {
	case EBlock(exprs) if (exprs.length > 1):
		true;	
	default:
		false;	
}) {
							var ` = inner.def;
							if (enumIndex ` == 53) {
								var ` = `[0];
								{
									var exprs = `;
									if (exprs.length > 1) {
										true;
									} else {
										false;
									};
								};
							} else {
								false;
							};
						}) {
							return "(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(inner, indentLevel)) + " end).()";
						} else {
							return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var stmts = `;
						if (stmts.length > 1) {
							return "(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel)) + " end).()";
						} else {
							return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
						};
					};
				};
				default: {
					return reflaxe.elixir.ast.ElixirASTPrinter.print(arg, indentLevel);
				}
			};
		};
	}

	static function sanitizeArgPrinted(s:String, indent:Int) {
		if (s == null) {
			return "";
		};
		var trimmed = StringTools.trim(s);
		if (trimmed.length == 0) {
			return s;
		};
		var hasBreak = (s.indexOf("\n", null) != -1);
		var alreadyIIFE = StringTools.startsWith(trimmed, "(fn ->");
		var isStringLiteral = StringTools.startsWith(trimmed, "\"");
		if (hasBreak && ! alreadyIIFE && ! isStringLiteral) {
			return "(fn -> " + s + " end).()";
		};
		return s;
	}

	static function printQualifiedModule(module:reflaxe.elixir.ast.ElixirAST) {
		{};
		@:ast(switch (module.def) {
	case EVar(name) if (name == "Repo"):
		var prefix = currentAppPrefix();
		if (prefix != null) return prefix + ".Repo";
		if (observedAppPrefix != null) return observedAppPrefix + ".Repo";
		try {
			var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			if (app != null && app.length > 0) return app + ".Repo";
		} catch(e:Dynamic) { };
		return name;	
	case EVar(name) if (name == "Presence"):
		var prefix = currentAppPrefix();
		if (prefix != null) return prefix + "Web.Presence" else return name;	
	case EVar(n):
		if (reflaxe.elixir.ast.StdModuleWhitelist.isWhitelistedQualified(n)) {
			return print(module, 0);
		};
		if (currentModuleName != null && currentModuleName.indexOf("Web") != -1) {
			var idx = currentModuleName.indexOf("Web");
			var app = idx > 0 ? currentModuleName.substring(0, idx) : null;
			inline function isSingleSegmentCamel(name:String):Bool {
				if (name == null || name.length == 0) return false;
				return name.indexOf(".") == -1 && name.charAt(0).toUpperCase() == name.charAt(0) && name.charAt(0).toLowerCase() != name.charAt(0);
			};
			if (app != null && (n == app + "Web")) {
				return n;
			};
			if (app != null && isSingleSegmentCamel(n)) {
				return app + "." + n;
			};
		};
		inline function isSingleSegmentCamel(name:String):Bool {
			if (name == null || name.length == 0) return false;
			return name.indexOf(".") == -1 && name.charAt(0).toUpperCase() == name.charAt(0) && name.charAt(0).toLowerCase() != name.charAt(0);
		};
		inline function isPhoenixWebRoot(name:String):Bool {
			return name == "Routes" || name == "Gettext" || name == "HTML" || name == "CoreComponents" || name == "Components" || name == "Layouts" || StringTools.endsWith(name, "Live");
		};
		var appPrefix = observedAppPrefix;
		if (appPrefix == null && currentModuleName != null) {
			var idx2 = currentModuleName.indexOf("Web");
			if (idx2 > 0) appPrefix = currentModuleName.substring(0, idx2);
		};
		if (appPrefix != null && isSingleSegmentCamel(n) && isPhoenixWebRoot(n)) {
			return appPrefix + "Web." + n;
		};
		return print(module, 0);	
	default:
		return print(module, 0);	
}) {
			var ` = module.def;
			if (enumIndex ` == 38) {
				var ` = `[0];
				{
					var name = `;
					if (name == "Repo") {
						var prefix = if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName == null) {
							null;
						} else {
							var idx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
							if (idx > 0) {
								reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx);
							} else {
								null;
							};
						};
						if (prefix != null) {
							return prefix + ".Repo";
						};
						if (reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix != null) {
							return reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix + ".Repo";
						};
						try {
							var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
							if (app != null && app.length > 0) {
								return app + ".Repo";
							};
						} catch (`:Dynamic) {
							{};
							{};
							if (true) {
								{};
								{};
							} else throw `;
						};
						return name;
					} else {
						var name = `;
						if (name == "Presence") {
							var prefix = if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName == null) {
								null;
							} else {
								var idx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
								if (idx > 0) {
									reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx);
								} else {
									null;
								};
							};
							if (prefix != null) {
								return prefix + "Web.Presence";
							} else {
								return name;
							};
						} else {
							var n = `;
							{
								if (if (n == null) {
									false;
								} else {
									var idx = n.indexOf(".", null);
									if (idx <= 0) {
										n != null && {
											var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
											cast this.exists(n);
										};
									} else {
										var root = n.substring(0, idx);
										root != null && {
											var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
											cast this.exists(root);
										};
									};
								}) {
									return reflaxe.elixir.ast.ElixirASTPrinter.print(module, 0);
								};
								if (reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null && reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null) != -1) {
									var idx = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
									var app = if (idx > 0) {
										reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx);
									} else {
										null;
									};
									{};
									if (app != null && (n == app + "Web")) {
										return n;
									};
									if (app != null && if (n == null || n.length == 0) {
										false;
									} else {
										n.indexOf(".", null) == -1 && n.charAt(0).toUpperCase() == n.charAt(0) && n.charAt(0).toLowerCase() != n.charAt(0);
									}) {
										return app + "." + n;
									};
								};
								{};
								{};
								var appPrefix = reflaxe.elixir.ast.ElixirASTPrinter.observedAppPrefix;
								if (appPrefix == null && reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName != null) {
									var idx2 = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.indexOf("Web", null);
									if (idx2 > 0) {
										appPrefix = reflaxe.elixir.ast.ElixirASTPrinter.currentModuleName.substring(0, idx2);
									};
								};
								if (appPrefix != null && if (n == null || n.length == 0) {
									false;
								} else {
									n.indexOf(".", null) == -1 && n.charAt(0).toUpperCase() == n.charAt(0) && n.charAt(0).toLowerCase() != n.charAt(0);
								} && n == "Routes" || n == "Gettext" || n == "HTML" || n == "CoreComponents" || n == "Components" || n == "Layouts" || StringTools.endsWith(n, "Live")) {
									return appPrefix + "Web." + n;
								};
								return reflaxe.elixir.ast.ElixirASTPrinter.print(module, 0);
							};
						};
					};
				};
			} else {
				return reflaxe.elixir.ast.ElixirASTPrinter.print(module, 0);
			};
		};
	}

	static function isModuleName(s:String) {
		if (s.length == 0) {
			return false;
		};
		var firstChar = s.charAt(0);
		if (firstChar != firstChar.toUpperCase()) {
			return false;
		};
		var parts = s.split(".");
		{
			var ` = 0;
			while (` < parts.length) {
				var part = parts[`];
				++ `;
				if (part.length == 0) {
					return false;
				};
				var first = part.charAt(0);
				if (first != first.toUpperCase() || ! new EReg("^[A-Z]", "").match(first)) {
					return false;
				};
			};
		};
		return true;
	}

	static function isAppModuleName(s:String) {
		if (! reflaxe.elixir.ast.ElixirASTPrinter.isModuleName(s)) {
			return false;
		};
		return s.indexOf("App", null) != -1 || StringTools.endsWith(s, ".PubSub") || StringTools.endsWith(s, ".Repo") || StringTools.endsWith(s, ".Endpoint") || StringTools.endsWith(s, ".Telemetry") || StringTools.endsWith(s, ".Supervisor") || StringTools.endsWith(s, ".Application") || StringTools.endsWith(s, "Web");
	}

	static function isLetter(c:String) {
		if (c.length != 1) {
			return false;
		};
		var code = c.charCodeAt(0);
		return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
	}

	static function isDigit(c:String) {
		if (c.length != 1) {
			return false;
		};
		var code = c.charCodeAt(0);
		return code >= 48 && code <= 57;
	}
}