class reflaxe.elixir.ast.TemplateHelpers {

	static function renderExpr(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		"\"" + s + "\"";	
	case EInteger(i):
		Std.string(i);	
	case EFloat(f):
		Std.string(f);	
	case EBoolean(b):
		b ? "true" : "false";	
	case ENil:
		"nil";	
	case EAtom(a):
		":" + Std.string(a);	
	case EVar(name):
		name;	
	case EField(obj, field):
		var base = renderExpr(obj);
		if (StringTools.startsWith(base, "assigns.")) {
			"@" + base.substr("assigns.".length) + "." + field;
		} else if (base == "assigns") {
			"@" + field;
		} else {
			base + "." + field;
		};	
	case EAccess(target, key):
		var t = renderExpr(target);
		var k = renderExpr(key);
		t + "[" + k + "]";	
	case ECall(module, func, args):
		var callStr = if (module != null) {
			switch (module.def) {
				case EVar(m):
					m + "." + func;				
				case EField(_, _):
					renderExpr(module) + "." + func;				
				default:
					func;				
			};
		} else {
			func;
		};
		if (args.length > 0) {
			var argStrs = [];
			for (arg  in  args) argStrs.push(renderExpr(arg));
			callStr + "(" + argStrs.join(", ") + ")";
		} else {
			callStr + "()";
		};	
	case EBinary(op, left, right):
		var l = renderExpr(left);
		var r = renderExpr(right);
		var opStr = switch (op) {
			case Add:
				"+";			
			case Subtract:
				"-";			
			case Multiply:
				"*";			
			case Divide:
				"/";			
			case Remainder:
				"rem";			
			case Power:
				"**";			
			case Equal:
				"==";			
			case NotEqual:
				"!=";			
			case StrictEqual:
				"===";			
			case StrictNotEqual:
				"!==";			
			case Less:
				"<";			
			case Greater:
				">";			
			case LessEqual:
				"<=";			
			case GreaterEqual:
				">=";			
			case And:
				"and";			
			case Or:
				"or";			
			case AndAlso:
				"&&";			
			case OrElse:
				"||";			
			case BitwiseAnd:
				"&&&";			
			case BitwiseOr:
				"|||";			
			case BitwiseXor:
				"^^^";			
			case ShiftLeft:
				"<<<";			
			case ShiftRight:
				">>>";			
			case Concat:
				"++";			
			case ListSubtract:
				"--";			
			case StringConcat:
				"<>";			
			case In:
				"in";			
			case Match:
				"=";			
			case Pipe:
				"|>";			
			case TypeCheck:
				"::";			
			case When:
				"when";			
		};
		"(" + l + " " + opStr + " " + r + ")";	
	case EIf(condition, thenBranch, elseBranch):
		var c = renderExpr(condition);
		var t = renderExpr(thenBranch);
		var e = elseBranch != null ? renderExpr(elseBranch) : "nil";
		"if " + c + ", do: " + t + ", else: " + e;	
	case EParen(inner):
		"(" + renderExpr(inner) + ")";	
	default:
		ElixirASTPrinter.print(ast, 0);	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var c = reflaxe.elixir.ast.TemplateHelpers.renderExpr(condition);
							var t = reflaxe.elixir.ast.TemplateHelpers.renderExpr(thenBranch);
							var e = if (elseBranch != null) {
								reflaxe.elixir.ast.TemplateHelpers.renderExpr(elseBranch);
							} else {
								"nil";
							};
							"if " + c + ", do: " + t + ", else: " + e;
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var callStr = if (module != null) {
								@:ast(switch (module.def) {
	case EVar(m):
		m + "." + func;	
	case EField(_, _):
		renderExpr(module) + "." + func;	
	default:
		func;	
}) {
									var ` = module.def;
									switch (enumIndex `) {
										case 28: {
											var ` = `[0];
											var ` = `[1];
											{
												reflaxe.elixir.ast.TemplateHelpers.renderExpr(module) + "." + func;
											};
										};
										case 38: {
											var ` = `[0];
											{
												var m = `;
												{
													m + "." + func;
												};
											};
										};
										default: {
											func;
										}
									};
								};
							} else {
								func;
							};
							if (args.length > 0) {
								var argStrs = [];
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										argStrs.push(reflaxe.elixir.ast.TemplateHelpers.renderExpr(arg));
									};
								};
								callStr + "(" + argStrs.join(", ") + ")";
							} else {
								callStr + "()";
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							var l = reflaxe.elixir.ast.TemplateHelpers.renderExpr(left);
							var r = reflaxe.elixir.ast.TemplateHelpers.renderExpr(right);
							var opStr = @:ast(switch (op) {
	case Add:
		"+";	
	case Subtract:
		"-";	
	case Multiply:
		"*";	
	case Divide:
		"/";	
	case Remainder:
		"rem";	
	case Power:
		"**";	
	case Equal:
		"==";	
	case NotEqual:
		"!=";	
	case StrictEqual:
		"===";	
	case StrictNotEqual:
		"!==";	
	case Less:
		"<";	
	case Greater:
		">";	
	case LessEqual:
		"<=";	
	case GreaterEqual:
		">=";	
	case And:
		"and";	
	case Or:
		"or";	
	case AndAlso:
		"&&";	
	case OrElse:
		"||";	
	case BitwiseAnd:
		"&&&";	
	case BitwiseOr:
		"|||";	
	case BitwiseXor:
		"^^^";	
	case ShiftLeft:
		"<<<";	
	case ShiftRight:
		">>>";	
	case Concat:
		"++";	
	case ListSubtract:
		"--";	
	case StringConcat:
		"<>";	
	case In:
		"in";	
	case Match:
		"=";	
	case Pipe:
		"|>";	
	case TypeCheck:
		"::";	
	case When:
		"when";	
}) switch (@:exhaustive enumIndex op) {
								case 0: {
									{
										"+";
									};
								};
								case 1: {
									{
										"-";
									};
								};
								case 2: {
									{
										"*";
									};
								};
								case 3: {
									{
										"/";
									};
								};
								case 4: {
									{
										"rem";
									};
								};
								case 5: {
									{
										"**";
									};
								};
								case 6: {
									{
										"==";
									};
								};
								case 7: {
									{
										"!=";
									};
								};
								case 8: {
									{
										"===";
									};
								};
								case 9: {
									{
										"!==";
									};
								};
								case 10: {
									{
										"<";
									};
								};
								case 11: {
									{
										">";
									};
								};
								case 12: {
									{
										"<=";
									};
								};
								case 13: {
									{
										">=";
									};
								};
								case 14: {
									{
										"and";
									};
								};
								case 15: {
									{
										"or";
									};
								};
								case 16: {
									{
										"&&";
									};
								};
								case 17: {
									{
										"||";
									};
								};
								case 18: {
									{
										"&&&";
									};
								};
								case 19: {
									{
										"|||";
									};
								};
								case 20: {
									{
										"^^^";
									};
								};
								case 21: {
									{
										"<<<";
									};
								};
								case 22: {
									{
										">>>";
									};
								};
								case 23: {
									{
										"++";
									};
								};
								case 24: {
									{
										"--";
									};
								};
								case 25: {
									{
										"<>";
									};
								};
								case 26: {
									{
										"in";
									};
								};
								case 27: {
									{
										"=";
									};
								};
								case 28: {
									{
										"|>";
									};
								};
								case 29: {
									{
										"::";
									};
								};
								case 30: {
									{
										"when";
									};
								};
							};
							"(" + l + " " + opStr + " " + r + ")";
						};
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						var field = `;
						{
							var base = reflaxe.elixir.ast.TemplateHelpers.renderExpr(obj);
							if (StringTools.startsWith(base, "assigns.")) {
								"@" + base.substr("assigns.".length, null) + "." + field;
							} else {
								if (base == "assigns") {
									"@" + field;
								} else {
									base + "." + field;
								};
							};
						};
					};
				};
				case 29: {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var key = `;
						{
							var t = reflaxe.elixir.ast.TemplateHelpers.renderExpr(target);
							var k = reflaxe.elixir.ast.TemplateHelpers.renderExpr(key);
							t + "[" + k + "]";
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							":" + Std.string(a);
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							"\"" + s + "\"";
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var i = `;
						{
							Std.string(i);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Std.string(f);
						};
					};
				};
				case 35: {
					var ` = `[0];
					{
						var b = `;
						{
							if (b) {
								"true";
							} else {
								"false";
							};
						};
					};
				};
				case 36: {
					{
						"nil";
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name;
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							"(" + reflaxe.elixir.ast.TemplateHelpers.renderExpr(inner) + ")";
						};
					};
				};
				default: {
					reflaxe.elixir.ast.ElixirASTPrinter.print(ast, 0);
				}
			};
		};
	}

	public static function collectTemplateContent(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		var processed = rewriteInterpolations(s);
		processed = rewriteControlTags(processed);
		processed;	
	case EBinary(StringConcat, left, right):
		var l = collectTemplateContent(left);
		var r = collectTemplateContent(right);
		rewriteControlTags(l + r);	
	case EIf(condition, thenBranch, elseBranch):
		var condStr = renderExpr(condition);
		if (StringTools.startsWith(condStr, "assigns.")) condStr = "@" + condStr.substr("assigns.".length);
		var thenSimple:Null<String> = extractSimpleHtml(thenBranch);
		var elseSimple:Null<String> = (elseBranch != null) ? extractSimpleHtml(elseBranch) : "";
		if (thenSimple != null && elseSimple != null) {
			"<%= if " + condStr + ", do: " + toQuoted(thenSimple) + ", else: " + toQuoted(elseSimple) + " %>";
		} else {
			var thenStr = collectTemplateContent(thenBranch);
			var elseStr = elseBranch != null ? collectTemplateContent(elseBranch) : "";
			var out = new StringBuf();
			out.add("<%= if " + condStr + " do %>");
			out.add(thenStr);
			if (elseStr != null && elseStr != "") {
				out.add("<% else %>");
				out.add(elseStr);
			};
			out.add("<% end %>");
			out.toString();
		};	
	case ECall(module, func, args):
		var isHxxModule = false;
		if (module != null) switch (module.def) {
			case EVar(m):
				isHxxModule = (m == "HXX");			
			case EField(_, fld):
				isHxxModule = (fld == "HXX");			
			default:
		};
		if (isHxxModule && (func == "block" || func == "hxx") && args.length >= 1) {
			var inner = collectTemplateContent(args[0]);
			return rewriteControlTags(inner);
		};
		var callStr = (function() {
			var callHead = if (module != null) {
				switch (module.def) {
					case EVar(m):
						m + "." + func;					
					case EField(_, _):
						renderExpr(module) + "." + func;					
					default:
						func;					
				};
			} else func;
			function renderArgForTemplate(a:ElixirAST):String {
				return switch (a.def) {
					case EBlock(sts) if (sts != null && sts.length > 1):
						"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + " end).()";					
					case EParen(inner) if (switch (inner.def) {
					case EBlock(es) if (es.length > 1):
						true;					
					default:
						false;					
				}):
						"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + " end).()";					
					default:
						renderExpr(a);					
				};
			};
			var parts = [];
			for (a  in  args) parts.push(renderArgForTemplate(a));
			return callHead + "(" + parts.join(", ") + ")";
		})();
		if (StringTools.startsWith(callStr, "assigns.")) callStr = "@" + callStr.substr("assigns.".length);
		"<%= " + callStr + " %>";	
	case ERemoteCall(module, func, args):
		var head = renderExpr(module) + "." + func;
		function renderArg2(a:ElixirAST):String {
			return switch (a.def) {
				case EBlock(sts) if (sts != null && sts.length > 1):
					"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + " end).()";				
				case EParen(inner) if (switch (inner.def) {
				case EBlock(es) if (es.length > 1):
					true;				
				default:
					false;				
			}):
					"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + " end).()";				
				default:
					renderExpr(a);				
			};
		};
		var argList2 = [];
		for (a  in  args) argList2.push(renderArg2(a));
		var full = head + "(" + argList2.join(", ") + ")";
		if (StringTools.startsWith(full, "assigns.")) full = "@" + full.substr("assigns.".length);
		"<%= " + full + " %>";	
	case EVar(_) | EField(_, _) | EInteger(_) | EFloat(_) | EBoolean(_) | ENil | EAtom(_) | EBinary(_, _, _) | EParen(_):
		var exprStr = renderExpr(ast);
		if (StringTools.startsWith(exprStr, "assigns.")) {
			exprStr = "@" + exprStr.substr("assigns.".length);
		};
		"<%= " + exprStr + " %>";	
	default:
		var exprAny = renderExpr(ast);
		if (StringTools.startsWith(exprAny, "assigns.")) exprAny = "@" + exprAny.substr("assigns.".length);
		"<%= " + exprAny + " %>";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							var condStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(condition);
							if (StringTools.startsWith(condStr, "assigns.")) {
								condStr = "@" + condStr.substr("assigns.".length, null);
							};
							var thenSimple = reflaxe.elixir.ast.TemplateHelpers.extractSimpleHtml(thenBranch);
							var elseSimple = if ((elseBranch != null)) {
								reflaxe.elixir.ast.TemplateHelpers.extractSimpleHtml(elseBranch);
							} else {
								"";
							};
							if (thenSimple != null && elseSimple != null) {
								"<%= if " + condStr + ", do: " + {
									var t = StringTools.trim(thenSimple);
									if ((StringTools.startsWith(t, "\"") && StringTools.endsWith(t, "\"")) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
										t;
									} else {
										"\"" + t + "\"";
									};
								} + ", else: " + {
									var t = StringTools.trim(elseSimple);
									if ((StringTools.startsWith(t, "\"") && StringTools.endsWith(t, "\"")) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
										t;
									} else {
										"\"" + t + "\"";
									};
								} + " %>";
							} else {
								var thenStr = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(thenBranch);
								var elseStr = if (elseBranch != null) {
									reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(elseBranch);
								} else {
									"";
								};
								var out = new StringBuf();
								out.add("<%= if " + condStr + " do %>");
								out.add(thenStr);
								if (elseStr != null && elseStr != "") {
									out.add("<% else %>");
									out.add(elseStr);
								};
								out.add("<% end %>");
								out.toString();
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var isHxxModule = false;
							if (module != null) {
								@:ast(switch (module.def) {
	case EVar(m):
		isHxxModule = (m == "HXX");	
	case EField(_, fld):
		isHxxModule = (fld == "HXX");	
	default:
}) {
									var ` = module.def;
									switch (enumIndex `) {
										case 28: {
											var ` = `[0];
											var ` = `[1];
											{
												var fld = `;
												{
													isHxxModule = (fld == "HXX");
												};
											};
										};
										case 38: {
											var ` = `[0];
											{
												var m = `;
												{
													isHxxModule = (m == "HXX");
												};
											};
										};
										default: {}
									};
								};
							};
							if (isHxxModule && (func == "block" || func == "hxx") && args.length >= 1) {
								var inner = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(args[0]);
								return reflaxe.elixir.ast.TemplateHelpers.rewriteControlTags(inner);
							};
							var callStr = (function() {
								var callHead = if (module != null) {
									@:ast(switch (module.def) {
	case EVar(m):
		m + "." + func;	
	case EField(_, _):
		renderExpr(module) + "." + func;	
	default:
		func;	
}) {
										var ` = module.def;
										switch (enumIndex `) {
											case 28: {
												var ` = `[0];
												var ` = `[1];
												{
													reflaxe.elixir.ast.TemplateHelpers.renderExpr(module) + "." + func;
												};
											};
											case 38: {
												var ` = `[0];
												{
													var m = `;
													{
														m + "." + func;
													};
												};
											};
											default: {
												func;
											}
										};
									};
								} else {
									func;
								};
								var renderArgForTemplate = function(a:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (a.def) {
	case EBlock(sts) if (sts != null && sts.length > 1):
		"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + " end).()";	
	case EParen(inner) if (switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}):
		"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + " end).()";	
	default:
		renderExpr(a);	
}) {
										var ` = a.def;
										switch (enumIndex `) {
											case 53: {
												var ` = `[0];
												{
													var sts = `;
													if (sts != null && sts.length > 1) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(a, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
													};
												};
											};
											case 54: {
												var ` = `[0];
												{
													var inner = `;
													if (@:ast(switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}) {
														var ` = inner.def;
														if (enumIndex ` == 53) {
															var ` = `[0];
															{
																var es = `;
																if (es.length > 1) {
																	true;
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													}) {
														"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0)) + " end).()";
													} else {
														reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
													};
												};
											};
											default: {
												reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
											}
										};
									};
								};
								var parts = [];
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										parts.push(renderArgForTemplate(a));
									};
								};
								return callHead + "(" + parts.join(", ") + ")";
							})();
							if (StringTools.startsWith(callStr, "assigns.")) {
								callStr = "@" + callStr.substr("assigns.".length, null);
							};
							"<%= " + callStr + " %>";
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var head = reflaxe.elixir.ast.TemplateHelpers.renderExpr(module) + "." + func;
							var renderArg2 = function(a:reflaxe.elixir.ast.ElixirAST) {
								return @:ast(switch (a.def) {
	case EBlock(sts) if (sts != null && sts.length > 1):
		"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + " end).()";	
	case EParen(inner) if (switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}):
		"(fn -> " + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + " end).()";	
	default:
		renderExpr(a);	
}) {
									var ` = a.def;
									switch (enumIndex `) {
										case 53: {
											var ` = `[0];
											{
												var sts = `;
												if (sts != null && sts.length > 1) {
													"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(a, 0)) + " end).()";
												} else {
													reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
												};
											};
										};
										case 54: {
											var ` = `[0];
											{
												var inner = `;
												if (@:ast(switch (inner.def) {
	case EBlock(es) if (es.length > 1):
		true;	
	default:
		false;	
}) {
													var ` = inner.def;
													if (enumIndex ` == 53) {
														var ` = `[0];
														{
															var es = `;
															if (es.length > 1) {
																true;
															} else {
																false;
															};
														};
													} else {
														false;
													};
												}) {
													"(fn -> " + StringTools.rtrim(reflaxe.elixir.ast.ElixirASTPrinter.print(inner, 0)) + " end).()";
												} else {
													reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
												};
											};
										};
										default: {
											reflaxe.elixir.ast.TemplateHelpers.renderExpr(a);
										}
									};
								};
							};
							var argList2 = [];
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									argList2.push(renderArg2(a));
								};
							};
							var full = head + "(" + argList2.join(", ") + ")";
							if (StringTools.startsWith(full, "assigns.")) {
								full = "@" + full.substr("assigns.".length, null);
							};
							"<%= " + full + " %>";
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								var l = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(left);
								var r = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(right);
								reflaxe.elixir.ast.TemplateHelpers.rewriteControlTags(l + r);
							};
						};
					} else {
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 31: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							var processed = reflaxe.elixir.ast.TemplateHelpers.rewriteInterpolations(s);
							processed = reflaxe.elixir.ast.TemplateHelpers.rewriteControlTags(processed);
							processed;
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 34: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 35: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 36: {
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 38: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				case 54: {
					var ` = `[0];
					{
						var exprStr = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
						if (StringTools.startsWith(exprStr, "assigns.")) {
							exprStr = "@" + exprStr.substr("assigns.".length, null);
						};
						"<%= " + exprStr + " %>";
					};
				};
				default: {
					var exprAny = reflaxe.elixir.ast.TemplateHelpers.renderExpr(ast);
					if (StringTools.startsWith(exprAny, "assigns.")) {
						exprAny = "@" + exprAny.substr("assigns.".length, null);
					};
					"<%= " + exprAny + " %>";
				}
			};
		};
	}

	public static function rewriteInterpolations(s:String) {
		if (s == null) {
			return s;
		};
		if (s.indexOf("${", null) == -1 && s.indexOf("#{", null) == -1 && s.indexOf("<for {", null) == -1) {
			return s;
		};
		s = reflaxe.elixir.ast.TemplateHelpers.rewriteAttributeInterpolations(s);
		s = reflaxe.elixir.ast.TemplateHelpers.rewriteAttributeEexInterpolations(s);
		s = reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(s);
		var out = new StringBuf();
		var i = 0;
		while (i < s.length) {
			var j1 = s.indexOf("#{", i);
			var j2 = s.indexOf("${", i);
			var j = if ((j1 == -1)) {
				j2;
			} else {
				(if (j2 == -1) {
					j1;
				} else {
					(if (j1 < j2) {
						j1;
					} else {
						j2;
					});
				});
			};
			if (j == -1) {
				out.add(s.substr(i, null));
				break;
			};
			out.add(s.substr(i, j - i));
			var k = j + 2;
			var depth = 1;
			while (k < s.length && depth > 0) {
				var ch = s.charAt(k);
				if (ch == "{") {
					depth ++;
				} else {
					if (ch == "}") {
						depth --;
					};
				};
				k ++;
			};
			var inner = s.substr(j + 2, (k - 1) - (j + 2));
			var expr = StringTools.trim(inner);
			if (expr.length >= 2 && expr.charAt(0) == "\"" && expr.charAt(1) == "<") {
				haxe.macro.Context.error("HXX: injecting HTML via string inside interpolation is not allowed. Use HXX.block('...') or inline markup.", haxe.macro.Context.currentPos(), null);
			};
			var tern = reflaxe.elixir.ast.TemplateHelpers.splitTopLevelTernary(expr);
			if (tern != null) {
				var cond = StringTools.replace(tern.cond, "assigns.", "@");
				var th = reflaxe.elixir.ast.TemplateHelpers.extractBlockHtml(StringTools.trim(tern.thenPart));
				var el = reflaxe.elixir.ast.TemplateHelpers.extractBlockHtml(StringTools.trim(tern.elsePart));
				if (th != null || el != null) {
					var thenQ = if ((th != null)) {
						{
							var t = StringTools.trim(th);
							if ((StringTools.startsWith(t, "\"") && StringTools.endsWith(t, "\"")) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
								t;
							} else {
								"\"" + t + "\"";
							};
						};
					} else {
						"\"\"";
					};
					var elseQ = if ((el != null && el != "")) {
						{
							var t = StringTools.trim(el);
							if ((StringTools.startsWith(t, "\"") && StringTools.endsWith(t, "\"")) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
								t;
							} else {
								"\"" + t + "\"";
							};
						};
					} else {
						"\"\"";
					};
					out.add("<%= if " + cond + ", do: " + thenQ + ", else: " + elseQ + " %>");
				} else {
					out.add("<%= " + StringTools.replace(expr, "assigns.", "@") + " %>");
				};
			} else {
				out.add("<%= " + StringTools.replace(expr, "assigns.", "@") + " %>");
			};
			i = k;
		};
		var __res = out.toString();
		return __res;
	}

	public static function rewriteForBlocks(src:String) {
		var out = new StringBuf();
		var i = 0;
		while (i < src.length) {
			var start = src.indexOf("<for {", i);
			if (start == -1) {
				out.add(src.substr(i, null));
				break;
			};
			out.add(src.substr(i, start - i));
			var headEnd = src.indexOf("}>", start);
			if (headEnd == -1) {
				out.add(src.substr(start, null));
				break;
			};
			var headInner = src.substr(start + 6, headEnd - (start + 6));
			var closeTag = src.indexOf("</for>", headEnd + 2);
			if (closeTag == -1) {
				out.add(src.substr(start, null));
				break;
			};
			var body = src.substr(headEnd + 2, closeTag - (headEnd + 2));
			var parts = headInner.split(" in ");
			if (parts.length != 2) {
				out.add(src.substr(start, (closeTag + 6) - start));
				i = closeTag + 6;
				continue;
			};
			var pat = StringTools.trim(parts[0]);
			var iter = StringTools.trim(parts[1]);
			iter = StringTools.replace(iter, "assigns.", "@");
			out.add("<%= for " + pat + " <- " + iter + " do %>");
			out.add(reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(body));
			out.add("<% end %>");
			i = closeTag + 6;
		};
		var __s = out.toString();
		return __s;
	}

	static function rewriteAttributeEexInterpolations(s:String) {
		if (s == null || s.indexOf("<%", null) == -1) {
			return s;
		};
		var eexAttr = new EReg("=\\s*<%=\\s*([^%]+?)\\s*%>", "g");
		var result = eexAttr.replace(s, "={$1}");
		var eexIf = new EReg("=\\s*<%\\s*if\\s+(.+?)\\s+do\\s*%>([^<]*)<%\\s*else\\s*%>([^<]*)<%\\s*end\\s*%>", "g");
		result = eexIf.map(result, function(re:EReg) {
			var cond = StringTools.trim(re.matched(1));
			var th = StringTools.trim(re.matched(2));
			var el = StringTools.trim(re.matched(3));
			if (! (StringTools.startsWith(th, "\"") && StringTools.endsWith(th, "\"")) && ! (StringTools.startsWith(th, "'") && StringTools.endsWith(th, "'"))) {
				th = "\"" + th + "\"";
			};
			if (! (StringTools.startsWith(el, "\"") && StringTools.endsWith(el, "\"")) && ! (StringTools.startsWith(el, "'") && StringTools.endsWith(el, "'"))) {
				el = "\"" + el + "\"";
			};
			return "={if " + cond + ", do: " + th + ", else: " + el + "}";
		});
		return result;
	}

	public static inline function toQuoted(s:String) {
		var t = StringTools.trim(s);
		if ((StringTools.startsWith(t, "\"") && StringTools.endsWith(t, "\"")) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
			return t;
		};
		return "\"" + t + "\"";
	}

	static function rewriteAttributeInterpolations(s:String) {
		var out = new StringBuf();
		var i = 0;
		while (i < s.length) {
			var prev = i;
			var j = s.indexOf("${", i);
			if (j == -1) {
				out.add(s.substr(i, null));
				break;
			};
			var k = j - 1;
			var seenGt = false;
			while (k >= i) {
				var ch = s.charAt(k);
				if (ch == ">") {
					seenGt = true;
					break;
				};
				if (ch == "=") {
					break;
				};
				k --;
			};
			if (k < i || seenGt || s.charAt(k) != "=") {
				out.add(s.substr(i, (j - i)));
				out.add("${");
				i = j + 2;
				continue;
			};
			var nameEnd = k - 1;
			while (nameEnd >= i && new EReg("^\\s$", "").match(s.charAt(nameEnd))) {
				nameEnd --;
			};
			var nameStart = nameEnd;
			while (nameStart >= i && new EReg("^[A-Za-z0-9_:\\-]$", "").match(s.charAt(nameStart))) {
				nameStart --;
			};
			nameStart ++;
			if (nameStart > nameEnd) {
				out.add(s.substr(i, (j - i)));
				out.add("${");
				i = j + 2;
				continue;
			};
			var attrName = s.substr(nameStart, (nameEnd - nameStart + 1));
			out.add(s.substr(i, (nameStart - i)));
			out.add(attrName);
			out.add("=");
			var vpos = k + 1;
			while (vpos < s.length && new EReg("^\\s$", "").match(s.charAt(vpos))) {
				vpos ++;
			};
			var quote = null;
			if (vpos < s.length && (s.charAt(vpos) == "\"" || s.charAt(vpos) == "'")) {
				quote = s.charAt(vpos);
				vpos ++;
			};
			if (vpos != j) {
				out.add(s.substr(k + 1, (j - (k + 1))));
				out.add("${");
				i = j + 2;
				continue;
			};
			var p = j + 2;
			var depth = 1;
			while (p < s.length && depth > 0) {
				var c = s.charAt(p);
				if (c == "{") {
					depth ++;
				} else {
					if (c == "}") {
						depth --;
					};
				};
				p ++;
			};
			var inner = s.substr(j + 2, (p - 1) - (j + 2));
			var expr = StringTools.trim(inner);
			expr = StringTools.replace(expr, "assigns.", "@");
			var tern = reflaxe.elixir.ast.TemplateHelpers.splitTopLevelTernary(expr);
			if (tern != null) {
				var cond = StringTools.replace(StringTools.trim(tern.cond), "assigns.", "@");
				var th = StringTools.trim(tern.thenPart);
				var el = StringTools.trim(tern.elsePart);
				expr = "if " + cond + ", do: " + th + ", else: " + el;
			};
			out.add("{");
			out.add(expr);
			out.add("}");
			if (quote != null) {
				var qpos = p;
				if (qpos < s.length && s.charAt(qpos) == quote) {
					p = qpos + 1;
				};
			};
			i = p;
			if (i <= prev) {
				i = prev + 1;
			};
		};
		return out.toString();
	}

	static function extractBlockHtml(part:String) {
		if (part == null || part == "") {
			return "";
		};
		var p = part;
		if (StringTools.startsWith(p, "HXX.block(")) {
			var start = p.indexOf("(", null) + 1;
			var end = p.lastIndexOf(")", null);
			if (start > 0 && end > start) {
				var inner = StringTools.trim(p.substr(start, end - start));
				return reflaxe.elixir.ast.TemplateHelpers.unquote(inner);
			};
		};
		var uq = reflaxe.elixir.ast.TemplateHelpers.unquote(p);
		if (uq != null) {
			return uq;
		};
		return null;
	}

	static function extractSimpleHtml(branch:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (branch.def) {
	case ECall(module, func, args):
		var isHxx = false;
		if (module != null) switch (module.def) {
			case EVar(m):
				isHxx = (m == "HXX");			
			case EField(_, fld):
				isHxx = (fld == "HXX");			
			default:
		};
		if (isHxx && (func == "block" || func == "hxx") && args.length >= 1) {
			var inner = collectTemplateContent(args[0]);
			if (inner.indexOf("<%") == -1) inner else null;
		} else null;	
	case EString(s):
		var uq = unquote(s);
		uq != null ? uq : s;	
	default:
		null;	
}) {
			var ` = branch.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var isHxx = false;
							if (module != null) {
								@:ast(switch (module.def) {
	case EVar(m):
		isHxx = (m == "HXX");	
	case EField(_, fld):
		isHxx = (fld == "HXX");	
	default:
}) {
									var ` = module.def;
									switch (enumIndex `) {
										case 28: {
											var ` = `[0];
											var ` = `[1];
											{
												var fld = `;
												{
													isHxx = (fld == "HXX");
												};
											};
										};
										case 38: {
											var ` = `[0];
											{
												var m = `;
												{
													isHxx = (m == "HXX");
												};
											};
										};
										default: {}
									};
								};
							};
							if (isHxx && (func == "block" || func == "hxx") && args.length >= 1) {
								var inner = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(args[0]);
								if (inner.indexOf("<%", null) == -1) {
									inner;
								} else {
									null;
								};
							} else {
								null;
							};
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							var uq = reflaxe.elixir.ast.TemplateHelpers.unquote(s);
							if (uq != null) {
								uq;
							} else {
								s;
							};
						};
					};
				};
				default: {
					null;
				}
			};
		};
	}

	static function unquote(s:String) {
		if (s.length >= 2) {
			var a = s.charAt(0);
			var b = s.charAt(s.length - 1);
			if ((a == "\"" && b == "\"") || (a == "'" && b == "'")) {
				return s.substr(1, s.length - 2);
			};
		};
		return null;
	}

	static function splitTopLevelTernary(e:String) {
		var depth = 0;
		var inS = false;
		var inD = false;
		var q = -1;
		var col = -1;
		{
			var ` = 0;
			var ` = e.length;
			while (` < `) {
				var idx = ` ++;
				var ch = e.charAt(idx);
				if (! inS && ch == "\"" && ! inD) {
					inD = true;
					continue;
				} else {
					if (inD && ch == "\"") {
						inD = false;
						continue;
					};
				};
				if (! inD && ch == "'" && ! inS) {
					inS = true;
					continue;
				} else {
					if (inS && ch == "'") {
						inS = false;
						continue;
					};
				};
				if (inS || inD) {
					continue;
				};
				if (ch == "(" || ch == "{" || ch == "[") {
					depth ++;
				} else {
					if (ch == ")" || ch == "}" || ch == "]") {
						depth --;
					};
				};
				if (depth != 0) {
					continue;
				};
				if (ch == "?" && q == -1) {
					q = idx;
				} else {
					if (ch == ":" && q != -1) {
						col = idx;
						break;
					};
				};
			};
		};
		if (q == -1 || col == -1) {
			return null;
		};
		var cond = StringTools.trim(e.substr(0, q));
		var thenPart = StringTools.trim(e.substr(q + 1, col - (q + 1)));
		var elsePart = StringTools.trim(e.substr(col + 1, null));
		return {cond : cond, thenPart : thenPart, elsePart : elsePart};
	}

	static function rewriteInlineIfDoToBlock(s:String) {
		var out = new StringBuf();
		var i = 0;
		while (i < s.length) {
			var start = s.indexOf("<%=", i);
			if (start == -1) {
				out.add(s.substr(i, null));
				break;
			};
			out.add(s.substr(i, start - i));
			var endTag = s.indexOf("%>", start + 3);
			if (endTag == -1) {
				out.add(s.substr(start, null));
				break;
			};
			var inner = StringTools.trim(s.substr(start + 3, endTag - (start + 3)));
			if (StringTools.startsWith(inner, "if ")) {
				var rest = StringTools.trim(inner.substr(3, null));
				var idxDo = reflaxe.elixir.ast.TemplateHelpers.indexOfTopLevel(rest, ", do:");
				var cond = null;
				var doPart = null;
				var elsePart = null;
				if (idxDo != -1) {
					cond = StringTools.trim(rest.substr(0, idxDo));
					var afterDo = StringTools.trim(rest.substr(idxDo + 5, null));
					var qv = reflaxe.elixir.ast.TemplateHelpers.extractQuoted(afterDo);
					if (qv != null) {
						doPart = qv.value;
						var rem = StringTools.trim(afterDo.substr(qv.length, null));
						if (StringTools.startsWith(rem, ",")) {
							rem = StringTools.trim(rem.substr(1, null));
						};
						if (StringTools.startsWith(rem, "else:")) {
							var afterElse = StringTools.trim(rem.substr(5, null));
							var qv2 = reflaxe.elixir.ast.TemplateHelpers.extractQuoted(afterElse);
							if (qv2 != null) {
								elsePart = qv2.value;
							};
						};
					};
				};
				if (cond != null && doPart != null) {
					out.add("<%= if " + StringTools.replace(cond, "assigns.", "@") + " do %>");
					out.add(doPart);
					if (elsePart != null && elsePart != "") {
						out.add("<% else %>");
						out.add(elsePart);
					};
					out.add("<% end %>");
				} else {
					out.add(s.substr(start, (endTag + 2) - start));
				};
			} else {
				out.add(s.substr(start, (endTag + 2) - start));
			};
			i = endTag + 2;
		};
		return out.toString();
	}

	static function extractQuoted(s:String) {
		if (s.length == 0) {
			return null;
		};
		var quote = s.charAt(0);
		if (quote != "\"" && quote != "'") {
			return null;
		};
		var i = 1;
		while (i < s.length) {
			var ch = s.charAt(i);
			if (ch == quote) {
				var val = s.substr(1, i - 1);
				return {value : val, length : i + 1};
			};
			i ++;
		};
		return null;
	}

	public static function rewriteControlTags(s:String) {
		if (s == null || s.indexOf("<if", null) == -1) {
			return s;
		};
		var out = new StringBuf();
		var i = 0;
		while (i < s.length) {
			var idx = s.indexOf("<if", i);
			if (idx == -1) {
				out.add(s.substr(i, null));
				break;
			};
			out.add(s.substr(i, idx - i));
			var j = idx + 3;
			while (j < s.length && new EReg("^\\s$", "").match(s.charAt(j))) {
				j ++;
			};
			if (j >= s.length || s.charAt(j) != "{") {
				out.add("<if");
				i = idx + 3;
				continue;
			};
			var braceStart = j;
			j ++;
			var braceDepth = 1;
			while (j < s.length && braceDepth > 0) {
				var ch = s.charAt(j);
				if (ch == "{") {
					braceDepth ++;
				} else {
					if (ch == "}") {
						braceDepth --;
					};
				};
				j ++;
			};
			if (braceDepth != 0) {
				out.add(s.substr(idx, null));
				break;
			};
			var braceEnd = j - 1;
			while (j < s.length && new EReg("^\\s$", "").match(s.charAt(j))) {
				j ++;
			};
			if (j >= s.length || s.charAt(j) != ">") {
				out.add(s.substr(idx, j - idx));
				i = j;
				continue;
			};
			var openEnd = j + 1;
			var cond = StringTools.trim(s.substr(braceStart + 1, braceEnd - (braceStart + 1)));
			cond = StringTools.replace(cond, "assigns.", "@");
			var k = openEnd;
			var depth = 1;
			var elsePos = -1;
			while (k < s.length && depth > 0) {
				var nextIf = s.indexOf("<if", k);
				var nextElse = s.indexOf("<else>", k);
				var nextClose = s.indexOf("</if>", k);
				var next = -1;
				var tag = 0;
				if (nextIf != -1) {
					next = nextIf;
					tag = 1;
				};
				if (nextElse != -1 && (next == -1 || nextElse < next)) {
					next = nextElse;
					tag = 2;
				};
				if (nextClose != -1 && (next == -1 || nextClose < next)) {
					next = nextClose;
					tag = 3;
				};
				if (next == -1) {
					break;
				};
				if (tag == 1) {
					depth ++;
					k = next + 3;
				} else {
					if (tag == 2 && depth == 1 && elsePos == -1) {
						elsePos = next;
						k = next + 6;
					} else {
						if (tag == 3) {
							depth --;
							k = next + 5;
						} else {
							k = next + 1;
						};
					};
				};
			};
			if (depth != 0) {
				out.add(s.substr(idx, null));
				break;
			};
			var closeIdx = k - 5;
			var thenStart = openEnd;
			var thenEnd = if (elsePos != -1) {
				elsePos;
			} else {
				closeIdx;
			};
			var elseStart = if (elsePos != -1) {
				(elsePos + 6);
			} else {
				-1;
			};
			var elseEnd = closeIdx;
			var thenHtml = s.substr(thenStart, thenEnd - thenStart);
			var elseHtml = if (elseStart != -1) {
				s.substr(elseStart, elseEnd - elseStart);
			} else {
				null;
			};
			out.add("<%= if " + cond + " do %>");
			out.add(thenHtml);
			if (elseHtml != null && StringTools.trim(elseHtml) != "") {
				out.add("<% else %>");
				out.add(elseHtml);
			};
			out.add("<% end %>");
			var afterClose = s.indexOf(">", closeIdx + 1);
			i = if ((afterClose == -1)) {
				s.length;
			} else {
				afterClose + 1;
			};
		};
		return out.toString();
	}

	static function indexOfTopLevel(s:String, token:String) {
		var depth = 0;
		var inS = false;
		var inD = false;
		{
			var ` = 0;
			var ` = s.length - token.length + 1;
			while (` < `) {
				var i = ` ++;
				var ch = s.charAt(i);
				if (! inS && ch == "\"" && ! inD) {
					inD = true;
					continue;
				} else {
					if (inD && ch == "\"") {
						inD = false;
						continue;
					};
				};
				if (! inD && ch == "'" && ! inS) {
					inS = true;
					continue;
				} else {
					if (inS && ch == "'") {
						inS = false;
						continue;
					};
				};
				if (inS || inD) {
					continue;
				};
				if (ch == "(" || ch == "{" || ch == "[") {
					depth ++;
				} else {
					if (ch == ")" || ch == "}" || ch == "]") {
						depth --;
					};
				};
				if (depth != 0) {
					continue;
				};
				if (s.substr(i, token.length) == token) {
					return i;
				};
			};
		};
		return -1;
	}

	public static function collectTemplateArgument(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case EString(s):
		"\"" + s + "\"";	
	case EVar(name):
		name;	
	case EAtom(a):
		":" + a;	
	case EInteger(i):
		Std.string(i);	
	case EFloat(f):
		Std.string(f);	
	case EBoolean(b):
		b ? "true" : "false";	
	case ENil:
		"nil";	
	case EField(obj, field):
		switch (obj.def) {
			case EVar(v):
				v + "." + field;			
			default:
				"[complex]." + field;			
		};	
	default:
		"[complex arg]";	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						var field = `;
						{
							@:ast(switch (obj.def) {
	case EVar(v):
		v + "." + field;	
	default:
		"[complex]." + field;	
}) {
								var ` = obj.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										{
											v + "." + field;
										};
									};
								} else {
									"[complex]." + field;
								};
							};
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							":" + a;
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							"\"" + s + "\"";
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var i = `;
						{
							Std.string(i);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Std.string(f);
						};
					};
				};
				case 35: {
					var ` = `[0];
					{
						var b = `;
						{
							if (b) {
								"true";
							} else {
								"false";
							};
						};
					};
				};
				case 36: {
					{
						"nil";
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name;
						};
					};
				};
				default: {
					"[complex arg]";
				}
			};
		};
	}

	public static function isHXXModule(expr:haxe.macro.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		moduleName == "HXX";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var m = `;
					{
						var moduleName = reflaxe.elixir.ast.TemplateHelpers.moduleTypeToString(m);
						moduleName == "HXX";
					};
				};
			} else {
				false;
			};
		};
	}

	static function moduleTypeToString(m:haxe.macro.ModuleType) {
		return @:ast(switch (m) {
	case TClassDecl(c):
		var cls = c.get();
		if (cls.pack.length > 0) {
			cls.pack.join(".") + "." + cls.name;
		} else {
			cls.name;
		};	
	case TEnumDecl(e):
		var enm = e.get();
		if (enm.pack.length > 0) {
			enm.pack.join(".") + "." + enm.name;
		} else {
			enm.name;
		};	
	case TAbstract(a):
		var abs = a.get();
		if (abs.pack.length > 0) {
			abs.pack.join(".") + "." + abs.name;
		} else {
			abs.name;
		};	
	case TTypeDecl(t):
		var typ = t.get();
		if (typ.pack.length > 0) {
			typ.pack.join(".") + "." + typ.name;
		} else {
			typ.name;
		};	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						var cls = c.get();
						if (cls.pack.length > 0) {
							cls.pack.join(".") + "." + cls.name;
						} else {
							cls.name;
						};
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						var enm = e.get();
						if (enm.pack.length > 0) {
							enm.pack.join(".") + "." + enm.name;
						} else {
							enm.name;
						};
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						var typ = t.get();
						if (typ.pack.length > 0) {
							typ.pack.join(".") + "." + typ.name;
						} else {
							typ.name;
						};
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						var abs = a.get();
						if (abs.pack.length > 0) {
							abs.pack.join(".") + "." + abs.name;
						} else {
							abs.name;
						};
					};
				};
			};
		};
	}
}