class reflaxe.elixir.ast.transformers.NestedLoopDetector {

	public static function detectNestedLoop(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (stmts.length < 4) {
			return null;
		};
		{
			var ` = 0;
			var ` = [4, 9, 8, 16, 25];
			while (` < `.length) {
				var size = `[`];
				++ `;
				if (stmts.length >= size) {
					var subset = stmts.slice(0, size);
					var patterns = reflaxe.elixir.ast.transformers.NestedLoopDetector.extractIndexPatterns(subset);
					if (patterns != null) {
						var dimensions = reflaxe.elixir.ast.transformers.NestedLoopDetector.analyzeDimensions(patterns);
						if (dimensions != null && dimensions.length >= 2) {
							var expressionInfo = reflaxe.elixir.ast.transformers.NestedLoopDetector.analyzeExpressionPatterns(subset, patterns, dimensions);
							var sampleStmt = if (subset.length > 1) {
								subset[1];
							} else {
								subset[0];
							};
							var transformed = reflaxe.elixir.ast.transformers.NestedLoopDetector.buildNestedEnumEachWithExpressions(sampleStmt, dimensions, expressionInfo);
							return {transformed : transformed, count : size};
						};
					};
				};
			};
		};
		return null;
	}

	static function extractIndexPatterns(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		var patterns = [];
		{
			var ` = 0;
			while (` < stmts.length) {
				var stmt = stmts[`];
				++ `;
				var indices = reflaxe.elixir.ast.transformers.NestedLoopDetector.extractIndicesFromStatement(stmt);
				if (indices == null || indices.length < 2) {
					return null;
				};
				patterns.push(indices);
			};
		};
		return patterns;
	}

	static function extractIndicesFromStatement(stmt:reflaxe.elixir.ast.ElixirAST) {
		var actualStmt = stmt;
		@:ast(switch (stmt.def) {
	case EMatch(_, value):
		actualStmt = value;	
	case EParen(inner):
		actualStmt = inner;	
	case EBlock([single]):
		actualStmt = single;	
	default:
}) {
			var ` = stmt.def;
			switch (enumIndex `) {
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var value = `;
						{
							actualStmt = value;
						};
					};
				};
				case 53: {
					var ` = `[0];
					if (`.length == 1) {
						var ` = `[0];
						{
							var single = `;
							{
								actualStmt = single;
							};
						};
					} else {};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							actualStmt = inner;
						};
					};
				};
				default: {}
			};
		};
		@:ast(switch (actualStmt.def) {
	case ERemoteCall(module, func, args):
		var moduleName = switch (module.def) {
			case EVar(name):
				name;			
			default:
				"";			
		};
		if (moduleName == "Log" && func == "trace" && args.length > 0) {
			return extractIndicesFromArg(args[0]);
		};
		return null;	
	case ECall(_, func, args) if (args.length > 0):
		return extractIndicesFromArg(args[0]);	
	default:
		return null;	
}) {
			var ` = actualStmt.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var func = `;
						var args = `;
						if (args.length > 0) {
							return reflaxe.elixir.ast.transformers.NestedLoopDetector.extractIndicesFromArg(args[0]);
						} else {
							return null;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							var moduleName = @:ast(switch (module.def) {
	case EVar(name):
		name;	
	default:
		"";	
}) {
								var ` = module.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var name = `;
										{
											name;
										};
									};
								} else {
									"";
								};
							};
							if (moduleName == "Log" && func == "trace" && args.length > 0) {
								return reflaxe.elixir.ast.transformers.NestedLoopDetector.extractIndicesFromArg(args[0]);
							};
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function extractIndicesFromArg(arg:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (arg.def) {
	case ERaw(s):
		var indices:Array<Int> = [];
		var regex = ~/#{([0-9]+)}/;
		var tempStr = s;
		while (regex.match(tempStr)) {
			var index = Std.parseInt(regex.matched(1));
			if (index != null) {
				indices.push(index);
			};
			tempStr = regex.matchedRight();
		};
		if (indices.length == 0) {
			var bracketRegex = ~/\[#{([0-9]+)}\]/;
			tempStr = s;
			while (bracketRegex.match(tempStr)) {
				var index = Std.parseInt(bracketRegex.matched(1));
				if (index != null) {
					indices.push(index);
				};
				tempStr = bracketRegex.matchedRight();
			};
			if (indices.length > 0) { };
		};
		if (indices.length > 0) { };
		return indices.length > 0 ? indices : null;	
	case EString(s):
		return extractIndicesFromArg(makeAST(ERaw(s)));	
	default:
		return null;	
}) {
			var ` = arg.def;
			switch (enumIndex `) {
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							return reflaxe.elixir.ast.transformers.NestedLoopDetector.extractIndicesFromArg({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(s), metadata : {}, pos : pos};
							});
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var s = `;
						{
							var indices = [];
							var regex = new EReg("#{([0-9]+)}", "g");
							var tempStr = s;
							while (regex.match(tempStr)) {
								var index = Std.parseInt(regex.matched(1));
								if (index != null) {
									indices.push(index);
								};
								tempStr = regex.matchedRight();
							};
							if (indices.length == 0) {
								var bracketRegex = new EReg("\\[#{([0-9]+)}\\]", "g");
								tempStr = s;
								while (bracketRegex.match(tempStr)) {
									var index = Std.parseInt(bracketRegex.matched(1));
									if (index != null) {
										indices.push(index);
									};
									tempStr = bracketRegex.matchedRight();
								};
								if (indices.length > 0) {};
							};
							if (indices.length > 0) {};
							return if (indices.length > 0) {
								indices;
							} else {
								null;
							};
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function analyzeDimensions(patterns:Array<Array<Int>>) {
		if (patterns.length == 0) {
			return null;
		};
		var numDimensions = patterns[0].length;
		if (numDimensions < 2) {
			return null;
		};
		var dimensions = [];
		{
			var ` = 0;
			var ` = numDimensions;
			while (` < `) {
				var dim = ` ++;
				var maxValue = 0;
				{
					var ` = 0;
					while (` < patterns.length) {
						var pattern = patterns[`];
						++ `;
						if (pattern[dim] > maxValue) {
							maxValue = pattern[dim];
						};
					};
				};
				dimensions.push(maxValue + 1);
			};
		};
		var expectedCount = 1;
		{
			var ` = 0;
			while (` < dimensions.length) {
				var d = dimensions[`];
				++ `;
				expectedCount *= d;
			};
		};
		if (patterns.length != expectedCount) {
			return null;
		};
		if (! reflaxe.elixir.ast.transformers.NestedLoopDetector.verifyNestedOrder(patterns, dimensions)) {
			return null;
		};
		return dimensions;
	}

	static function verifyNestedOrder(patterns:Array<Array<Int>>, dimensions:Array<Int>) {
		var expected = reflaxe.elixir.ast.transformers.NestedLoopDetector.generateExpectedPatterns(dimensions);
		{
			var ` = 0;
			var ` = patterns.length;
			while (` < `) {
				var i = ` ++;
				{
					var ` = 0;
					var ` = patterns[i].length;
					while (` < `) {
						var j = ` ++;
						if (patterns[i][j] != expected[i][j]) {
							return false;
						};
					};
				};
			};
		};
		return true;
	}

	static function generateExpectedPatterns(dimensions:Array<Int>) {
		var patterns = [];
		var indices = {
			var ` = [];
			{
				var ` = 0;
				var ` = dimensions.length;
				while (` < `) {
					var i = ` ++;
					`.push(0);
				};
			};
			`;
		};
		while (true) {
			patterns.push(indices.copy());
			var carry = true;
			var pos = dimensions.length - 1;
			while (carry && pos >= 0) {
				indices[pos] ++;
				if (indices[pos] >= dimensions[pos]) {
					indices[pos] = 0;
					pos --;
				} else {
					carry = false;
				};
			};
			if (carry) {
				break;
			};
		};
		return patterns;
	}

	static function analyzeExpressionPatterns(stmts:Array<reflaxe.elixir.ast.ElixirAST>, patterns:Array<Array<Int>>, dimensions:Array<Int>) {
		return {multipliers : [], offsets : []};
	}

	static function buildNestedEnumEachWithExpressions(sampleStmt:reflaxe.elixir.ast.ElixirAST, dimensions:Array<Int>, expressionInfo:Dynamic) {
		return reflaxe.elixir.ast.transformers.NestedLoopDetector.buildNestedEnumEach(sampleStmt, dimensions);
	}

	static function reconstructExpressions(s:String, varNames:Array<String>) {
		haxe.Log.trace("[reconstructExpressions] Input: \"" + s + "\", varNames: " + Std.string(varNames), {fileName : "../../../../src/reflaxe/elixir/ast/transformers/NestedLoopDetector.hx", lineNumber : 331, className : "reflaxe.elixir.ast.transformers.NestedLoopDetector", methodName : "reconstructExpressions"});
		var result = s;
		var interpolations = [];
		var regex = new EReg("#{([0-9]+)}", "g");
		var searchStr = s;
		var offset = 0;
		while (regex.match(searchStr)) {
			var matchPos = offset + regex.matchedPos().pos;
			var val = Std.parseInt(regex.matched(1));
			if (val != null) {
				haxe.Log.trace("[reconstructExpressions] Found interpolation at pos " + matchPos + ": " + regex.matched(0), {fileName : "../../../../src/reflaxe/elixir/ast/transformers/NestedLoopDetector.hx", lineNumber : 346, className : "reflaxe.elixir.ast.transformers.NestedLoopDetector", methodName : "reconstructExpressions"});
				interpolations.push({pos : matchPos, value : val, pattern : regex.matched(0)});
			};
			offset += regex.matchedPos().pos + regex.matched(0).length;
			searchStr = regex.matchedRight();
		};
		haxe.Log.trace("[reconstructExpressions] Found " + interpolations.length + " interpolations", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/NestedLoopDetector.hx", lineNumber : 357, className : "reflaxe.elixir.ast.transformers.NestedLoopDetector", methodName : "reconstructExpressions"});
		interpolations.sort(function(a:{ value : Int, pos : Int, pattern : String }, b:{ value : Int, pos : Int, pattern : String }) return a.pos - b.pos);
		if (interpolations.length > 0 && varNames.length > 0) {
			var parts = [];
			var lastEnd = 0;
			{
				var ` = 0;
				var ` = interpolations.length;
				while (` < `) {
					var i = ` ++;
					var interp = interpolations[i];
					var varName = varNames[i % varNames.length];
					parts.push(s.substring(lastEnd, interp.pos));
					parts.push("#{" + varName + "}");
					lastEnd = interp.pos + interp.pattern.length;
				};
			};
			if (lastEnd < s.length) {
				parts.push(s.substring(lastEnd, null));
			};
			result = parts.join("");
		};
		return result;
	}

	static function buildNestedEnumEach(sampleStmt:reflaxe.elixir.ast.ElixirAST, dimensions:Array<Int>) {
		var callInfo = reflaxe.elixir.ast.transformers.NestedLoopDetector.extractFunctionCall(sampleStmt);
		if (callInfo == null) {
			return sampleStmt;
		};
		var varNames = ["i", "j", "k", "l", "m", "n"];
		var body = reflaxe.elixir.ast.transformers.NestedLoopDetector.recreateFunctionCall(callInfo, varNames.slice(0, dimensions.length));
		{
			var ` = 1;
			var ` = dimensions.length + 1;
			while (` < `) {
				var i = ` ++;
				var dimIndex = dimensions.length - i;
				var range = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
					}, {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(dimensions[dimIndex] - 1), metadata : {}, pos : pos};
					}, false), metadata : {}, pos : pos};
				};
				var varName = varNames[dimIndex];
				var clause = {args : [reflaxe.elixir.ast.EPattern.PVar(varName)], body : body};
				var func = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EFn([clause]), metadata : {}, pos : pos};
				};
				body = {
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
					}, "each", [range, func]), metadata : {}, pos : pos};
				};
			};
		};
		return body;
	}

	static function extractFunctionCall(ast:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (ast.def) {
	case ERemoteCall({ def : EVar(module) }, funcName, args):
		return { module : module, func : funcName, args : args };	
	case ECall(target, funcName, args):
		return { module : "", func : funcName, args : args };	
	default:
		return null;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							return {module : "", func : funcName, args : args};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var module = `;
								var funcName = `;
								var args = `;
								{
									return {module : module, func : funcName, args : args};
								};
							};
						} else {
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function recreateFunctionCall(callInfo:{ module : String, func : String, args : Array<reflaxe.elixir.ast.ElixirAST> }, varNames:Array<String>) {
		var bodyArgs = [];
		if (callInfo.args.length > 0) {
			var firstArg = callInfo.args[0];
			var transformedArg = @:ast(switch (firstArg.def) {
	case ERaw(s):
		var result = s;
		var hasOriginalExpression = false;
		if (firstArg.metadata != null) {
			if (firstArg.metadata.originalLoopExpression != null) {
				result = firstArg.metadata.originalLoopExpression;
				hasOriginalExpression = true;
				if (firstArg.metadata.loopVariableName != null && varNames.length > 0) {
					var originalVar = firstArg.metadata.loopVariableName;
					var newVar = varNames[0];
					result = StringTools.replace(result, originalVar, newVar);
				};
			};
		};
		if (!hasOriginalExpression) {
			var reconstructed = reconstructExpressions(s, varNames);
			if (reconstructed != s) {
				result = reconstructed;
			} else {
				trace("[NestedLoopDetector] Reconstruction unchanged, trying fallback replacement");
				for (i  in  0 ... varNames.length) {
					var pattern = "#{" + i + "}";
					var replacement = "#{" + varNames[i] + "}";
					result = StringTools.replace(result, pattern, replacement);
					var bracketPattern = "[#{" + i + "}]";
					var bracketReplacement = "[#{" + varNames[i] + "}]";
					result = StringTools.replace(result, bracketPattern, bracketReplacement);
				};
			};
		};
		makeAST(ERaw(result));	
	default:
		firstArg;	
}) {
				var ` = firstArg.def;
				if (enumIndex ` == 62) {
					var ` = `[0];
					{
						var s = `;
						{
							var result = s;
							var hasOriginalExpression = false;
							if (firstArg.metadata != null) {
								if (firstArg.metadata.originalLoopExpression != null) {
									result = firstArg.metadata.originalLoopExpression;
									hasOriginalExpression = true;
									if (firstArg.metadata.loopVariableName != null && varNames.length > 0) {
										var originalVar = firstArg.metadata.loopVariableName;
										var newVar = varNames[0];
										result = StringTools.replace(result, originalVar, newVar);
									};
								};
							};
							if (! hasOriginalExpression) {
								var reconstructed = reflaxe.elixir.ast.transformers.NestedLoopDetector.reconstructExpressions(s, varNames);
								if (reconstructed != s) {
									result = reconstructed;
								} else {
									haxe.Log.trace("[NestedLoopDetector] Reconstruction unchanged, trying fallback replacement", {fileName : "../../../../src/reflaxe/elixir/ast/transformers/NestedLoopDetector.hx", lineNumber : 501, className : "reflaxe.elixir.ast.transformers.NestedLoopDetector", methodName : "recreateFunctionCall"});
									{
										var ` = 0;
										var ` = varNames.length;
										while (` < `) {
											var i = ` ++;
											var pattern = "#{" + i + "}";
											var replacement = "#{" + varNames[i] + "}";
											result = StringTools.replace(result, pattern, replacement);
											var bracketPattern = "[#{" + i + "}]";
											var bracketReplacement = "[#{" + varNames[i] + "}]";
											result = StringTools.replace(result, bracketPattern, bracketReplacement);
										};
									};
								};
							};
							{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(result), metadata : {}, pos : pos};
							};
						};
					};
				} else {
					firstArg;
				};
			};
			bodyArgs.push(transformedArg);
			{
				var ` = 1;
				var ` = callInfo.args.length;
				while (` < `) {
					var i = ` ++;
					bodyArgs.push(callInfo.args[i]);
				};
			};
		};
		if (callInfo.module != "") {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(callInfo.module), metadata : {}, pos : pos};
				}, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		} else {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		};
	}
}