class reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms {

	public static function pass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ECase(expr, clauses):
		var out:Array<ECaseClause> = [];
		for (cl  in  clauses) out.push(promoteInClause(cl));
		makeASTWithMeta(ECase(expr, out), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							var out = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									out.push(reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInClause(cl));
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(expr, out), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function promoteInClause(cl:reflaxe.elixir.ast.ECaseClause) {
		var used = reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.collectUsedNames(cl.body);
		if (cl.guard != null) {
			{
				var src = reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.collectUsedNames(cl.guard);
				if (src == null) {
					null;
				} else {
					for (k in src.keys()) {
						{
							used.set(k, true);
						};
					};
				};
			};
		};
		var promoted = reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(cl.pattern, used);
		if (promoted == cl.pattern) {
			var bases = reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.collectUnderscoredBases(cl.pattern);
			if (bases.length > 0 && (reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.bodyContainsAny(cl.body, bases) || (cl.guard != null && reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.bodyContainsAny(cl.guard, bases)))) {
				var used2 = {
					{};
					new haxe.ds.StringMap();
				};
				{
					var ` = 0;
					while (` < bases.length) {
						var b = bases[`];
						++ `;
						{
							used2.set(b, true);
						};
					};
				};
				promoted = reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(cl.pattern, used2);
			};
		};
		return {pattern : promoted, guard : cl.guard, body : cl.body};
	}

	static function promoteInPattern(p:reflaxe.elixir.ast.EPattern, used:Map<String, Bool>) {
		return @:ast(switch (p) {
	case PVar(nm) if (nm != null && nm.length > 1 && nm.charAt(0) == "_"):
		var base = nm.substr(1);
		if (used.exists(base)) PVar(base) else p;	
	case PTuple(es):
		var isClassicPayload = (es.length == 2) && (switch (es[0]) {
			case PLiteral(_):
				true;			
			default:
				false;			
		});
		if (isClassicPayload) PTuple([es[0], promoteOnlyIfNotSecondSlot(es[1], used)]) else PTuple([for (e  in  es) promoteInPattern(e, used)]);	
	case PList(es):
		PList([for (e  in  es) promoteInPattern(e, used)]);	
	case PCons(h, t):
		PCons(promoteInPattern(h, used), promoteInPattern(t, used));	
	case PMap(kvs):
		PMap([for (kv  in  kvs) { key : kv.key, value : promoteInPattern(kv.value, used) }]);	
	case PStruct(nm, fs):
		PStruct(nm, [for (f  in  fs) { key : f.key, value : promoteInPattern(f.value, used) }]);	
	case PPin(inner):
		PPin(promoteInPattern(inner, used));	
	default:
		p;	
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var nm = `;
					if (nm != null && nm.length > 1 && nm.charAt(0) == "_") {
						var base = nm.substr(1, null);
						if (used.exists(base)) {
							reflaxe.elixir.ast.EPattern.PVar(base);
						} else {
							p;
						};
					} else {
						p;
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						var isClassicPayload = (es.length == 2) && (@:ast(switch (es[0]) {
	case PLiteral(_):
		true;	
	default:
		false;	
}) {
							var ` = es[0];
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									true;
								};
							} else {
								false;
							};
						});
						if (isClassicPayload) {
							reflaxe.elixir.ast.EPattern.PTuple([es[0], reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteOnlyIfNotSecondSlot(es[1], used)]);
						} else {
							reflaxe.elixir.ast.EPattern.PTuple({
								var ` = [];
								{
									var ` = 0;
									while (` < es.length) {
										var e = es[`];
										++ `;
										`.push(reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(e, used));
									};
								};
								`;
							});
						};
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						reflaxe.elixir.ast.EPattern.PList({
							var ` = [];
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									`.push(reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(e, used));
								};
							};
							`;
						});
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.EPattern.PCons(reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(h, used), reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(t, used));
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						reflaxe.elixir.ast.EPattern.PMap({
							var ` = [];
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									`.push({key : kv.key, value : reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(kv.value, used)});
								};
							};
							`;
						});
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var nm = `;
					var fs = `;
					{
						reflaxe.elixir.ast.EPattern.PStruct(nm, {
							var ` = [];
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									`.push({key : f.key, value : reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(f.value, used)});
								};
							};
							`;
						});
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.EPattern.PPin(reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(inner, used));
					};
				};
			};
			default: {
				p;
			}
		};
	}

	static function promoteOnlyIfNotSecondSlot(second:reflaxe.elixir.ast.EPattern, used:Map<String, Bool>) {
		return @:ast(switch (second) {
	case PVar(nm) if (nm != null && nm.length > 1 && nm.charAt(0) == "_"):
		PVar(nm);	
	default:
		promoteInPattern(second, used);	
}) if (enumIndex second == 0) {
			var ` = second[0];
			{
				var nm = `;
				if (nm != null && nm.length > 1 && nm.charAt(0) == "_") {
					reflaxe.elixir.ast.EPattern.PVar(nm);
				} else {
					reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(second, used);
				};
			};
		} else {
			reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.promoteInPattern(second, used);
		};
	}

	@:has_untyped
	static function collectUsedNames(body:reflaxe.elixir.ast.ElixirAST) {
		var used = {
			{};
			new haxe.ds.StringMap();
		};
		try {
			var meta = body.metadata;
			if (meta != null && meta.usedLocalsFromTyped != null) {
				var arr = meta.usedLocalsFromTyped;
				{
					var ` = 0;
					while (` < arr.length) {
						var n = arr[`];
						++ `;
						if (n != null && n.length > 0) {
							{
								used.set(n, true);
							};
						};
					};
				};
			};
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
		reflaxe.elixir.ast.ASTUtils.walk(body, function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(v):
		if (looksLower(v)) used.set(v, true);	
	case EString(s):
		markInterpolations(s, used);	
	case ERaw(code):
		markInterpolations(code, used);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.markInterpolations(s, used);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var v = `;
							{
								if (if (v == null || v.length == 0) {
									false;
								} else {
									var c = v.charAt(0);
									c == c.toLowerCase();
								}) {
									{
										used.set(v, true);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								reflaxe.elixir.ast.transformers.CaseTupleMultiBinderPromoteByUseTransforms.markInterpolations(code, used);
							};
						};
					};
					default: {}
				};
			};
		});
		return used;
	}

	static inline function mergeInto(dst:Map<String, Bool>, src:Map<String, Bool>) {
		if (src == null) {
			return;
		};
		for (k in src.keys()) {
			{
				dst.set(k, true);
			};
		};
	}

	static function collectUnderscoredBases(p:reflaxe.elixir.ast.EPattern) {
		var out = [];
		var walk = [null];
		walk[0] = function(pt:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pt) {
	case PVar(nm) if (nm != null && nm.length > 1 && nm.charAt(0) == "_"):
		out.push(nm.substr(1));	
	case PTuple(es):
		for (e  in  es) walk(e);	
	case PList(es):
		for (e  in  es) walk(e);	
	case PCons(h, t):
		walk(h);
		walk(t);	
	case PMap(kvs):
		for (kv  in  kvs) walk(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) walk(f.value);	
	case PPin(inner):
		walk(inner);	
	default:
}) switch (enumIndex pt) {
				case 0: {
					var ` = pt[0];
					{
						var nm = `;
						if (nm != null && nm.length > 1 && nm.charAt(0) == "_") {
							out.push(nm.substr(1, null));
						} else {};
					};
				};
				case 2: {
					var ` = pt[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									walk[0](e);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pt[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									walk[0](e);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pt[0];
					var ` = pt[1];
					{
						var h = `;
						var t = `;
						{
							walk[0](h);
							walk[0](t);
						};
					};
				};
				case 5: {
					var ` = pt[0];
					{
						var kvs = `;
						{
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									walk[0](kv.value);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pt[0];
					var ` = pt[1];
					{
						var fs = `;
						{
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									walk[0](f.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pt[0];
					{
						var inner = `;
						{
							walk[0](inner);
						};
					};
				};
				default: {}
			};
		};
		walk[0](p);
		return out;
	}

	static function bodyContainsAny(ast:reflaxe.elixir.ast.ElixirAST, bases:Array<String>) {
		var found = [false];
		{};
		reflaxe.elixir.ast.ASTUtils.walk(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			if (found[0] || n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EString(s):
		scanText(s);	
	case ERaw(code):
		scanText(code);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								{
									if (found[0] || s == null) {
										null;
									} else {
										{
											var ` = 0;
											while (` < bases.length) {
												var b = bases[`];
												++ `;
												if (b != null && b.length > 0 && s.indexOf(b, null) != -1) {
													found[0] = true;
													break;
												};
											};
										};
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								{
									if (found[0] || code == null) {
										null;
									} else {
										{
											var ` = 0;
											while (` < bases.length) {
												var b = bases[`];
												++ `;
												if (b != null && b.length > 0 && code.indexOf(b, null) != -1) {
													found[0] = true;
													break;
												};
											};
										};
									};
								};
							};
						};
					};
					default: {}
				};
			};
		});
		return found[0];
	}

	static inline function looksLower(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var c = name.charAt(0);
		return c == c.toLowerCase();
	}

	static function markInterpolations(s:String, used:Map<String, Bool>) {
		if (s == null) {
			return;
		};
		var re = new EReg("\\#\\{([^}]*)\\}", "g");
		var pos = 0;
		while (re.matchSub(s, pos, null)) {
			var inner = re.matched(1);
			var tok = new EReg("[A-Za-z_][A-Za-z0-9_]*", "g");
			var tpos = 0;
			while (tok.matchSub(inner, tpos, null)) {
				var id = tok.matched(0);
				if (if (id == null || id.length == 0) {
					false;
				} else {
					var c = id.charAt(0);
					c == c.toLowerCase();
				}) {
					{
						used.set(id, true);
					};
				};
				tpos = tok.matchedPos().pos + tok.matchedPos().len;
			};
			pos = re.matchedPos().pos + re.matchedPos().len;
		};
	}
}