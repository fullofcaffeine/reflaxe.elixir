class reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms {

	public static function promotePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		var updated = promoteArgs(args, body);
		makeASTWithMeta(EDef(name, updated, guards, body), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		var updated = promoteArgs(args, body);
		makeASTWithMeta(EDefp(name, updated, guards, body), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var updated = reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promoteArgs(args, body);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, updated, guards, body), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var updated = reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promoteArgs(args, body);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, updated, guards, body), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	static function promoteArgs(args:Array<reflaxe.elixir.ast.EPattern>, body:reflaxe.elixir.ast.ElixirAST) {
		if (args == null || args.length == 0) {
			return args;
		};
		var refs = reflaxe.elixir.ast.analyzers.VariableUsageCollector.referencedInFunctionScope(body);
		var paramNames = {
			{};
			new haxe.ds.StringMap();
		};
		{
			var ` = 0;
			while (` < args.length) {
				var a = args[`];
				++ `;
				for (nm in {
					var this = reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.collectPatternVars(a);
					cast this.keys();
				}) {
					if (nm != null && nm.length > 0 && nm.charAt(0) != "_") {
						{
							paramNames.set(nm, true);
						};
					};
				};
			};
		};
		return {
			var ` = [];
			{
				var ` = 0;
				while (` < args.length) {
					var a = args[`];
					++ `;
					`.push(reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(a, refs, paramNames));
				};
			};
			`;
		};
	}

	static function collectPatternVars(p:reflaxe.elixir.ast.EPattern) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var walk = [null];
		walk[0] = function(pt:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pt) {
	case PVar(n):
		if (n != null) m.set(n, true);	
	case PTuple(es):
		for (e  in  es) walk(e);	
	case PList(es):
		for (e  in  es) walk(e);	
	case PCons(h, t):
		walk(h);
		walk(t);	
	case PMap(kvs):
		for (kv  in  kvs) walk(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) walk(f.value);	
	case PPin(inner):
		walk(inner);	
	case PAlias(nm, pat):
		if (nm != null) m.set(nm, true);
		walk(pat);	
	default:
}) switch (enumIndex pt) {
				case 0: {
					var ` = pt[0];
					{
						var n = `;
						{
							if (n != null) {
								{
									m.set(n, true);
								};
							};
						};
					};
				};
				case 2: {
					var ` = pt[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									walk[0](e);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pt[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									walk[0](e);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pt[0];
					var ` = pt[1];
					{
						var h = `;
						var t = `;
						{
							walk[0](h);
							walk[0](t);
						};
					};
				};
				case 5: {
					var ` = pt[0];
					{
						var kvs = `;
						{
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									walk[0](kv.value);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pt[0];
					var ` = pt[1];
					{
						var fs = `;
						{
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									walk[0](f.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pt[0];
					{
						var inner = `;
						{
							walk[0](inner);
						};
					};
				};
				case 9: {
					var ` = pt[0];
					var ` = pt[1];
					{
						var nm = `;
						var pat = `;
						{
							if (nm != null) {
								{
									m.set(nm, true);
								};
							};
							walk[0](pat);
						};
					};
				};
				default: {}
			};
		};
		walk[0](p);
		return m;
	}

	static function promotePattern(p:reflaxe.elixir.ast.EPattern, refs:Map<String, Bool>, existing:Map<String, Bool>) {
		return @:ast(switch (p) {
	case PVar(n) if (n != null && n.length > 1 && n.charAt(0) == "_"):
		var trimmed = n.substr(1);
		if (refs.exists(trimmed) && !existing.exists(trimmed)) PVar(trimmed) else p;	
	case PAlias(nm, pat) if (nm != null && nm.length > 1 && nm.charAt(0) == "_"):
		var trimmedA = nm.substr(1);
		var inner = promotePattern(pat, refs, existing);
		if (refs.exists(trimmedA) && !existing.exists(trimmedA)) PAlias(trimmedA, inner) else PAlias(nm, inner);	
	case PTuple(es):
		PTuple([for (e  in  es) promotePattern(e, refs, existing)]);	
	case PList(es):
		PList([for (e  in  es) promotePattern(e, refs, existing)]);	
	case PCons(h, t):
		PCons(promotePattern(h, refs, existing), promotePattern(t, refs, existing));	
	case PMap(kvs):
		PMap([for (kv  in  kvs) { key : kv.key, value : promotePattern(kv.value, refs, existing) }]);	
	case PStruct(nm, fs):
		PStruct(nm, [for (f  in  fs) { key : f.key, value : promotePattern(f.value, refs, existing) }]);	
	case PPin(inner):
		PPin(promotePattern(inner, refs, existing));	
	default:
		p;	
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var n = `;
					if (n != null && n.length > 1 && n.charAt(0) == "_") {
						var trimmed = n.substr(1, null);
						if (refs.exists(trimmed) && ! existing.exists(trimmed)) {
							reflaxe.elixir.ast.EPattern.PVar(trimmed);
						} else {
							p;
						};
					} else {
						p;
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						reflaxe.elixir.ast.EPattern.PTuple({
							var ` = [];
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									`.push(reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(e, refs, existing));
								};
							};
							`;
						});
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						reflaxe.elixir.ast.EPattern.PList({
							var ` = [];
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									`.push(reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(e, refs, existing));
								};
							};
							`;
						});
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.EPattern.PCons(reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(h, refs, existing), reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(t, refs, existing));
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						reflaxe.elixir.ast.EPattern.PMap({
							var ` = [];
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									`.push({key : kv.key, value : reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(kv.value, refs, existing)});
								};
							};
							`;
						});
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var nm = `;
					var fs = `;
					{
						reflaxe.elixir.ast.EPattern.PStruct(nm, {
							var ` = [];
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									`.push({key : f.key, value : reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(f.value, refs, existing)});
								};
							};
							`;
						});
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.EPattern.PPin(reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(inner, refs, existing));
					};
				};
			};
			case 9: {
				var ` = p[0];
				var ` = p[1];
				{
					var nm = `;
					var pat = `;
					if (nm != null && nm.length > 1 && nm.charAt(0) == "_") {
						var trimmedA = nm.substr(1, null);
						var inner = reflaxe.elixir.ast.transformers.DefParamUnderscorePromoteTransforms.promotePattern(pat, refs, existing);
						if (refs.exists(trimmedA) && ! existing.exists(trimmedA)) {
							reflaxe.elixir.ast.EPattern.PAlias(trimmedA, inner);
						} else {
							reflaxe.elixir.ast.EPattern.PAlias(nm, inner);
						};
					} else {
						p;
					};
				};
			};
			default: {
				p;
			}
		};
	}
}