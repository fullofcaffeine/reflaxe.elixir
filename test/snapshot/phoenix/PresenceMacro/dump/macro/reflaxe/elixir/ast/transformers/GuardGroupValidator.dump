@:nullSafety(Off)
class reflaxe.elixir.ast.transformers.GuardGroupValidator {

	public static function validateGuardGroup(branches:Array<reflaxe.elixir.ast.GuardBranch>, boundVars:Array<String>) {
		var result = {canGroup : true, reason : "Valid for grouping", groupKey : "", patterns : []};
		if (branches.length == 0) {
			result.canGroup = false;
			result.reason = "No branches to group";
			return result;
		};
		var boundVarSet = new haxe.ds.StringMap();
		{
			var ` = 0;
			while (` < boundVars.length) {
				var v = boundVars[`];
				++ `;
				boundVarSet.set(v, true);
			};
		};
		var patternsFound = [];
		{
			var ` = 0;
			while (` < branches.length) {
				var branch = branches[`];
				++ `;
				if (branch.pattern != null) {
					var patternStr = reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(branch.pattern);
					if (patternsFound.indexOf(patternStr, null) == -1) {
						patternsFound.push(patternStr);
					};
				};
				var usedVars = reflaxe.elixir.ast.transformers.GuardConditionCollector.extractUsedVariables(branch.guard);
				{
					var ` = 0;
					while (` < usedVars.length) {
						var v = usedVars[`];
						++ `;
						if (! boundVarSet.exists(v)) {
							var baseName = new EReg("^([a-z]+)\\d+$", "").replace(v, "$1");
							if (! boundVarSet.exists(baseName)) {
								result.canGroup = false;
								result.reason = "Branch uses external variable: " + v;
								break;
							};
						};
					};
				};
			};
		};
		result.patterns = patternsFound;
		if (patternsFound.length > 0) {
			result.groupKey = patternsFound[0];
		};
		return result;
	}
}