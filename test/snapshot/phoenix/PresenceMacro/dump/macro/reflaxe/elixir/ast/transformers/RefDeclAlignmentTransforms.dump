class reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms {

	public static function alignLocalsPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EDef(name, params, guards, body):
		var newBody = align(body, params);
		makeASTWithMeta(EDef(name, params, guards, newBody), node.metadata, node.pos);	
	case EDefp(name, params, guards, body):
		var newBody = align(body, params);
		makeASTWithMeta(EDefp(name, params, guards, newBody), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var params = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.align(body, params);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, params, guards, newBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var params = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.align(body, params);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, params, guards, newBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	static function align(body:reflaxe.elixir.ast.ElixirAST, params:Null<Array<reflaxe.elixir.ast.EPattern>> = null) {
		var declared = {
			{};
			new haxe.ds.StringMap();
		};
		var referenced = [{
			{};
			new haxe.ds.StringMap();
		}];
		if (params != null) {
			{
				var ` = 0;
				while (` < params.length) {
					var p = params[`];
					++ `;
					reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(p, declared);
				};
			};
		};
		reflaxe.elixir.ast.ASTUtils.walk(body, function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EMatch(p, _):
		collectPatternDecls(p, declared);	
	case EBinary(Match, left, _):
		collectLhsDecls(left, declared);	
	case EFn(clauses):
		for (cl  in  clauses) for (a  in  cl.args) collectPatternDecls(a, declared);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var p = `;
							{
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(p, declared);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var left = `;
								{
									reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectLhsDecls(left, declared);
								};
							};
						} else {};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										{
											var ` = 0;
											var ` = cl.args;
											while (` < `.length) {
												var a = `[`];
												++ `;
												reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(a, declared);
											};
										};
									};
								};
							};
						};
					};
					default: {}
				};
			};
		});
		referenced[0] = reflaxe.elixir.ast.analyzers.VariableUsageCollector.referencedInFunctionScope(body);
		var allowIdent = function(id:String) {
			if (id == null || id.length == 0) {
				return false;
			};
			var c = id.charAt(0);
			return c.toLowerCase() == c && c != "_";
		};
		var collectTokensFromString = function(src:String, out:Map<String, Bool>) {
			if (src == null || src.indexOf("#{", null) == -1) {
				return;
			};
			var re = new EReg("[A-Za-z_][A-Za-z0-9_]*", "g");
			var pos = 0;
			while (re.matchSub(src, pos, null)) {
				var id = re.matched(0);
				if (allowIdent(id)) {
					{
						out.set(id, true);
					};
				};
				pos = re.matchedPos().pos + re.matchedPos().len;
			};
		};
		var addStringRefs = [null];
		addStringRefs[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EString(s):
		if (s != null) collectTokensFromString(s, referenced);	
	case ERaw(code):
		if (code != null) collectTokensFromString(code, referenced);	
	case EBlock(ss):
		for (e  in  ss) addStringRefs(e);	
	case EDo(ss2):
		for (e  in  ss2) addStringRefs(e);	
	case EIf(c, t, e):
		addStringRefs(c);
		addStringRefs(t);
		if (e != null) addStringRefs(e);	
	case ECase(expr, cs):
		addStringRefs(expr);
		for (c  in  cs) addStringRefs(c.body);	
	case ECall(tgt, _, args):
		if (tgt != null) addStringRefs(tgt);
		for (a  in  args) addStringRefs(a);	
	case ERemoteCall(tgt2, _, args2):
		addStringRefs(tgt2);
		for (a  in  args2) addStringRefs(a);	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var cs = `;
							{
								addStringRefs[0](expr);
								{
									var ` = 0;
									while (` < cs.length) {
										var c = cs[`];
										++ `;
										addStringRefs[0](c.body);
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								addStringRefs[0](c);
								addStringRefs[0](t);
								if (e != null) {
									addStringRefs[0](e);
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt = `;
							var args = `;
							{
								if (tgt != null) {
									addStringRefs[0](tgt);
								};
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										addStringRefs[0](a);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var tgt2 = `;
							var args2 = `;
							{
								addStringRefs[0](tgt2);
								{
									var ` = 0;
									while (` < args2.length) {
										var a = args2[`];
										++ `;
										addStringRefs[0](a);
									};
								};
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								if (s != null) {
									collectTokensFromString(s, referenced[0]);
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var ss = `;
							{
								{
									var ` = 0;
									while (` < ss.length) {
										var e = ss[`];
										++ `;
										addStringRefs[0](e);
									};
								};
							};
						};
					};
					case 55: {
						var ` = `[0];
						{
							var ss2 = `;
							{
								{
									var ` = 0;
									while (` < ss2.length) {
										var e = ss2[`];
										++ `;
										addStringRefs[0](e);
									};
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var code = `;
							{
								if (code != null) {
									collectTokensFromString(code, referenced[0]);
								};
							};
						};
					};
					default: {}
				};
			};
		};
		addStringRefs[0](body);
		var groups = {
			{};
			new haxe.ds.StringMap();
		};
		for (k in declared.keys()) {
			var info = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.splitBase(k);
			var arr = if ({
				var key = info.base;
				groups.exists(key);
			}) {
				{
					var key = info.base;
					groups.get(key);
				};
			} else {
				[];
			};
			arr.push(k);
			{
				var key = info.base;
				groups.set(key, arr);
			};
		};
		var canonical = {
			{};
			new haxe.ds.StringMap();
		};
		for (base in groups.keys()) {
			var variants = cast groups.get(base);
			var hasPlainRef = referenced[0].exists(base);
			var hasUnderscoreDecl = false;
			{
				var ` = 0;
				while (` < variants.length) {
					var v = variants[`];
					++ `;
					if (v == "_" + base) {
						hasUnderscoreDecl = true;
						break;
					};
				};
			};
			var numericDecls = {
				var ` = [];
				{
					var ` = 0;
					var ` = variants;
					while (` < `.length) {
						var v = `[`];
						++ `;
						if (function(v:String) {
							return reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.isNumericVariantOf(v, base);
						}(v)) {
							`.push(v);
						};
					};
				};
				`;
			};
			var pick = null;
			if (hasPlainRef) {
				pick = base;
			} else {
				if (numericDecls.length == 1 && referenced[0].exists(base)) {
					pick = base;
				} else {
					if (hasUnderscoreDecl && (referenced[0].exists(base) || referenced[0].exists("_" + base))) {
						pick = base;
					};
				};
			};
			if (pick != null) {
				{
					canonical.set(base, pick);
				};
			};
		};
		if (Lambda.count(cast canonical, null) == 0) {
			return body;
		};
		var tx = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return n;
			};
			return @:ast(switch (n.def) {
	case EMatch(p, rhs):
		makeASTWithMeta(EMatch(renamePatternToCanonical(p, canonical), rhs), n.metadata, n.pos);	
	case EBinary(Match, left, rhs):
		makeASTWithMeta(EBinary(Match, renameLhsToCanonical(left, canonical), rhs), n.metadata, n.pos);	
	case EVar(v):
		var nb = splitBase(v).base;
		if (canonical.exists(nb)) {
			var target = canonical.get(nb);
			if (v != target) makeASTWithMeta(EVar(target), n.metadata, n.pos) else n;
		} else n;	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var p = `;
							var rhs = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(p, canonical), rhs);
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var left = `;
								var rhs = `;
								{
									{
										var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renameLhsToCanonical(left, canonical), rhs);
										var meta = n.metadata;
										var pos = n.pos;
										{def : def, metadata : meta, pos : pos};
									};
								};
							};
						} else {
							n;
						};
					};
					case 38: {
						var ` = `[0];
						{
							var v = `;
							{
								var nb = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.splitBase(v).base;
								if (canonical.exists(nb)) {
									var target = cast canonical.get(nb);
									if (v != target) {
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar(target), metadata : n.metadata, pos : n.pos};
									} else {
										n;
									};
								} else {
									n;
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, tx);
	}

	static function splitBase(name:String) {
		if (name == null || name.length == 0) {
			return {base : name, kind : "plain"};
		};
		if (name.charAt(0) == "_") {
			return {base : name.substr(1, null), kind : "underscored"};
		};
		var i = name.length - 1;
		while (i >= 0 && name.charCodeAt(i) >= 48 && name.charCodeAt(i) <= 57) {
			i --;
		};
		var suffix = name.substr(i + 1, null);
		if (suffix.length > 0) {
			return {base : name.substr(0, i + 1), kind : "numeric"};
		};
		return {base : name, kind : "plain"};
	}

	static function isNumericVariantOf(name:String, base:String) {
		if (name == null || base == null) {
			return false;
		};
		if (! StringTools.startsWith(name, base)) {
			return false;
		};
		var rest = name.substr(base.length, null);
		if (rest.length == 0) {
			return false;
		};
		{
			var ` = 0;
			var ` = rest.length;
			while (` < `) {
				var i = ` ++;
				var c = rest.charCodeAt(i);
				if (c < 48 || c > 57) {
					return false;
				};
			};
		};
		return true;
	}

	static function collectPatternDecls(p:reflaxe.elixir.ast.EPattern, declared:Map<String, Bool>) {
		@:ast(switch (p) {
	case PVar(n):
		declared.set(n, true);	
	case PTuple(es) | PList(es):
		for (e  in  es) collectPatternDecls(e, declared);	
	case PCons(h, t):
		collectPatternDecls(h, declared);
		collectPatternDecls(t, declared);	
	case PMap(kvs):
		for (kv  in  kvs) collectPatternDecls(kv.value, declared);	
	case PStruct(_, fs):
		for (f  in  fs) collectPatternDecls(f.value, declared);	
	case PPin(inner):
		collectPatternDecls(inner, declared);	
	default:
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var n = `;
					{
						{
							declared.set(n, true);
						};
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(e, declared);
							};
						};
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						{
							var ` = 0;
							while (` < es.length) {
								var e = es[`];
								++ `;
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(e, declared);
							};
						};
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(h, declared);
						reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(t, declared);
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						{
							var ` = 0;
							while (` < kvs.length) {
								var kv = kvs[`];
								++ `;
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(kv.value, declared);
							};
						};
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var fs = `;
					{
						{
							var ` = 0;
							while (` < fs.length) {
								var f = fs[`];
								++ `;
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(f.value, declared);
							};
						};
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectPatternDecls(inner, declared);
					};
				};
			};
			default: {}
		};
	}

	static function collectLhsDecls(lhs:reflaxe.elixir.ast.ElixirAST, declared:Map<String, Bool>) {
		@:ast(switch (lhs.def) {
	case EVar(n):
		declared.set(n, true);	
	case EBinary(Match, l2, r2):
		collectLhsDecls(l2, declared);
		collectLhsDecls(r2, declared);	
	default:
}) {
			var ` = lhs.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var l2 = `;
							var r2 = `;
							{
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectLhsDecls(l2, declared);
								reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.collectLhsDecls(r2, declared);
							};
						};
					} else {};
				};
				case 38: {
					var ` = `[0];
					{
						var n = `;
						{
							{
								declared.set(n, true);
							};
						};
					};
				};
				default: {}
			};
		};
	}

	static function renamePatternToCanonical(p:reflaxe.elixir.ast.EPattern, canonical:Map<String, String>) {
		return @:ast(switch (p) {
	case PVar(n):
		var nb = splitBase(n).base;
		if (canonical.exists(nb)) PVar(canonical.get(nb)) else p;	
	case PTuple(es):
		PTuple([for (e  in  es) renamePatternToCanonical(e, canonical)]);	
	case PList(es):
		PList([for (e  in  es) renamePatternToCanonical(e, canonical)]);	
	case PCons(h, t):
		PCons(renamePatternToCanonical(h, canonical), renamePatternToCanonical(t, canonical));	
	case PMap(kvs):
		PMap([for (kv  in  kvs) { key : kv.key, value : renamePatternToCanonical(kv.value, canonical) }]);	
	case PStruct(nm, fs):
		PStruct(nm, [for (f  in  fs) { key : f.key, value : renamePatternToCanonical(f.value, canonical) }]);	
	case PPin(inner):
		PPin(renamePatternToCanonical(inner, canonical));	
	default:
		p;	
}) switch (enumIndex p) {
			case 0: {
				var ` = p[0];
				{
					var n = `;
					{
						var nb = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.splitBase(n).base;
						if (canonical.exists(nb)) {
							reflaxe.elixir.ast.EPattern.PVar(cast canonical.get(nb));
						} else {
							p;
						};
					};
				};
			};
			case 2: {
				var ` = p[0];
				{
					var es = `;
					{
						reflaxe.elixir.ast.EPattern.PTuple({
							var ` = [];
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									`.push(reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(e, canonical));
								};
							};
							`;
						});
					};
				};
			};
			case 3: {
				var ` = p[0];
				{
					var es = `;
					{
						reflaxe.elixir.ast.EPattern.PList({
							var ` = [];
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									`.push(reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(e, canonical));
								};
							};
							`;
						});
					};
				};
			};
			case 4: {
				var ` = p[0];
				var ` = p[1];
				{
					var h = `;
					var t = `;
					{
						reflaxe.elixir.ast.EPattern.PCons(reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(h, canonical), reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(t, canonical));
					};
				};
			};
			case 5: {
				var ` = p[0];
				{
					var kvs = `;
					{
						reflaxe.elixir.ast.EPattern.PMap({
							var ` = [];
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									`.push({key : kv.key, value : reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(kv.value, canonical)});
								};
							};
							`;
						});
					};
				};
			};
			case 6: {
				var ` = p[0];
				var ` = p[1];
				{
					var nm = `;
					var fs = `;
					{
						reflaxe.elixir.ast.EPattern.PStruct(nm, {
							var ` = [];
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									`.push({key : f.key, value : reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(f.value, canonical)});
								};
							};
							`;
						});
					};
				};
			};
			case 7: {
				var ` = p[0];
				{
					var inner = `;
					{
						reflaxe.elixir.ast.EPattern.PPin(reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renamePatternToCanonical(inner, canonical));
					};
				};
			};
			default: {
				p;
			}
		};
	}

	static function renameLhsToCanonical(lhs:reflaxe.elixir.ast.ElixirAST, canonical:Map<String, String>) {
		return @:ast(switch (lhs.def) {
	case EVar(v):
		var nb = splitBase(v).base;
		if (canonical.exists(nb)) makeASTWithMeta(EVar(canonical.get(nb)), lhs.metadata, lhs.pos) else lhs;	
	case EBinary(Match, l2, r2):
		makeASTWithMeta(EBinary(Match, renameLhsToCanonical(l2, canonical), renameLhsToCanonical(r2, canonical)), lhs.metadata, lhs.pos);	
	default:
		lhs;	
}) {
			var ` = lhs.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var l2 = `;
							var r2 = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renameLhsToCanonical(l2, canonical), reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.renameLhsToCanonical(r2, canonical));
									var meta = lhs.metadata;
									var pos = lhs.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					} else {
						lhs;
					};
				};
				case 38: {
					var ` = `[0];
					{
						var v = `;
						{
							var nb = reflaxe.elixir.ast.transformers.RefDeclAlignmentTransforms.splitBase(v).base;
							if (canonical.exists(nb)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(canonical.get(nb));
									var meta = lhs.metadata;
									var pos = lhs.pos;
									{def : def, metadata : meta, pos : pos};
								};
							} else {
								lhs;
							};
						};
					};
				};
				default: {
					lhs;
				}
			};
		};
	}
}