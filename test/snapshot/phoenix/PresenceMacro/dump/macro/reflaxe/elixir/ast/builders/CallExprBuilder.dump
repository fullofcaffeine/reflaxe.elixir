@:nullSafety(Off)
class reflaxe.elixir.ast.builders.CallExprBuilder {

	public static function buildCall(e:haxe.macro.TypedExpr, args:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		if (e != null) {
			@:ast(switch (e.expr) {
	case TField(target, FInstance(_, _, cf)) if (cf.get().name == "concat" && args != null && args.length >= 1):
		var left = buildExpression(target);
		var right = buildExpression(args[0]);
		return EBinary(EBinaryOp.Concat, left, right);	
	default:
}) {
				var ` = e.expr;
				if (enumIndex ` == 4) {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 0) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cf = `;
							var target = `;
							if (cf.get().name == "concat" && args != null && args.length >= 1) {
								var left = buildExpression(target);
								var right = buildExpression(args[0]);
								return reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Concat, left, right);
							} else {};
						};
					} else {};
				} else {};
			};
		};
		if (context.compiler.options.targetCodeInjectionName != null && e != null && args.length > 0) {
			var isInjectionCall = @:ast(switch (e.expr) {
	case TIdent(id):
		id == context.compiler.options.targetCodeInjectionName;	
	case TField(_, fa):
		switch (fa) {
			case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
				cf.get().name == context.compiler.options.targetCodeInjectionName;			
			case FEnum(_, ef):
				ef.name == context.compiler.options.targetCodeInjectionName;			
			case FDynamic(s):
				s == context.compiler.options.targetCodeInjectionName;			
		};	
	case TLocal(v):
		v.name == context.compiler.options.targetCodeInjectionName;	
	case _:
		false;	
}) {
				var ` = e.expr;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						{
							var v = `;
							{
								v.name == context.compiler.options.targetCodeInjectionName;
							};
						};
					};
					case 4: {
						var ` = `[0];
						var ` = `[1];
						{
							var fa = `;
							{
								@:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
		cf.get().name == context.compiler.options.targetCodeInjectionName;	
	case FEnum(_, ef):
		ef.name == context.compiler.options.targetCodeInjectionName;	
	case FDynamic(s):
		s == context.compiler.options.targetCodeInjectionName;	
}) switch (@:exhaustive enumIndex fa) {
									case 0: {
										var ` = fa[0];
										var ` = fa[1];
										var ` = fa[2];
										{
											var cf = `;
											{
												cf.get().name == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
									case 1: {
										var ` = fa[0];
										var ` = fa[1];
										{
											var cf = `;
											{
												cf.get().name == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
									case 2: {
										var ` = fa[0];
										{
											var cf = `;
											{
												cf.get().name == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
									case 3: {
										var ` = fa[0];
										{
											var s = `;
											{
												s == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
									case 4: {
										var ` = fa[0];
										var ` = fa[1];
										{
											var cf = `;
											{
												cf.get().name == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
									case 5: {
										var ` = fa[0];
										var ` = fa[1];
										{
											var ef = `;
											{
												ef.name == context.compiler.options.targetCodeInjectionName;
											};
										};
									};
								};
							};
						};
					};
					case 28: {
						var ` = `[0];
						{
							var id = `;
							{
								id == context.compiler.options.targetCodeInjectionName;
							};
						};
					};
					default: {
						false;
					}
				};
			};
			if (isInjectionCall) {
				var injectionString = @:ast(switch (args[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		"";	
}) {
					var ` = args[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							{
								var s = `;
								{
									s;
								};
							};
						} else {
							"";
						};
					} else {
						"";
					};
				};
				if (injectionString != "") {
					if (injectionString.indexOf("Ecto.Query.where", null) != -1 && injectionString.indexOf("[t]", null) != -1 && args.length >= 3) {
						var rx = new EReg("\\[t\\]\\s*,\\s*t\\.([a-zA-Z0-9_]+)\\s*(==|!=|<=|>=|<|>)\\s*\\^\\(", "");
						if (rx.match(injectionString)) {
							var fieldName = rx.matched(1);
							var opStr = rx.matched(2);
							var queryAst = buildExpression(args[1]);
							var rhsAst = buildExpression(args[2]);
							var binding = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EList([{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
								}]), metadata : {}, pos : pos};
							};
							var left = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EField({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
								}, fieldName), metadata : {}, pos : pos};
							};
							var right = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EPin({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EParen(rhsAst), metadata : {}, pos : pos};
								}), metadata : {}, pos : pos};
							};
							var op = @:ast(switch (opStr) {
	case "==":
		EBinaryOp.Equal;	
	case "!=":
		EBinaryOp.NotEqual;	
	case "<=":
		EBinaryOp.LessEqual;	
	case ">=":
		EBinaryOp.GreaterEqual;	
	case "<":
		EBinaryOp.Less;	
	case ">":
		EBinaryOp.Greater;	
	default:
		EBinaryOp.Equal;	
}) switch (opStr) {
								case "!=": {
									{
										reflaxe.elixir.ast.EBinaryOp.NotEqual;
									};
								};
								case "<": {
									{
										reflaxe.elixir.ast.EBinaryOp.Less;
									};
								};
								case "<=": {
									{
										reflaxe.elixir.ast.EBinaryOp.LessEqual;
									};
								};
								case "==": {
									{
										reflaxe.elixir.ast.EBinaryOp.Equal;
									};
								};
								case ">": {
									{
										reflaxe.elixir.ast.EBinaryOp.Greater;
									};
								};
								case ">=": {
									{
										reflaxe.elixir.ast.EBinaryOp.GreaterEqual;
									};
								};
								default: {
									reflaxe.elixir.ast.EBinaryOp.Equal;
								}
							};
							var condition = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, left, right), metadata : {}, pos : pos};
							};
							var whereCall = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
								}, "where", [queryAst, binding, condition]), metadata : {}, pos : pos};
							};
							return whereCall.def;
						};
					};
					if (injectionString.indexOf("Ecto.Query.order_by", null) != -1 && injectionString.indexOf("[t]", null) != -1 && args.length >= 3) {
						var rxOrder = new EReg("order_by\\(\\{0\\},\\s*\\[t\\],\\s*\\[(asc|desc):\\s*t\\.([a-zA-Z0-9_]+)\\]\\)", "");
						var queryAst = buildExpression(args[1]);
						var binding = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EList([{
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
							}]), metadata : {}, pos : pos};
						};
						if (rxOrder.match(injectionString)) {
							var dir = rxOrder.matched(1);
							var fieldName2 = rxOrder.matched(2);
							var kv = {key : dir, value : {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EField({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
								}, fieldName2), metadata : {}, pos : pos};
							}};
							var kw = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EKeywordList([kv]), metadata : {}, pos : pos};
							};
							return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
							}, "order_by", [queryAst, binding, kw]);
						} else {
							var fieldAst = buildExpression(args[2]);
							var fieldNameMaybe = @:ast(switch (args[2].expr) {
	case TConst(TString(s)):
		s;	
	default:
		null;	
}) {
								var ` = args[2].expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (enumIndex ` == 2) {
										var ` = `[0];
										{
											var s = `;
											{
												s;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
							var valueNode = if (fieldNameMaybe != null) {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EField({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
									}, fieldNameMaybe), metadata : {}, pos : pos};
								};
							} else {
								fieldAst;
							};
							var kvAsc = {key : "asc", value : valueNode};
							var kwAsc = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EKeywordList([kvAsc]), metadata : {}, pos : pos};
							};
							return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
							}, "order_by", [queryAst, binding, kwAsc]);
						};
					};
					if (injectionString.indexOf("Ecto.Query.preload", null) != -1 && args.length >= 3) {
						var queryAst = buildExpression(args[1]);
						var preloadAst = buildExpression(args[2]);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
						}, "preload", [queryAst, preloadAst]);
					};
					if (injectionString.indexOf("Ecto.Query.from", null) != -1 && injectionString.indexOf(" in ", null) != -1 && args.length >= 2) {
						var schemaModuleAst = null;
						@:ast(switch (args[1].expr) {
	case TTypeExpr(TClassDecl(classRef)):
		var cls = classRef.get();
		var nativeName:Null<String> = null;
		if (cls.meta.has(":native")) {
			var meta = cls.meta.extract(":native");
			if (meta != null && meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				switch (meta[0].params[0].expr) {
					case EConst(CString(s, _)):
						nativeName = s;					
					default:
				};
			};
		};
		var moduleName = nativeName != null ? nativeName : cls.name;
		schemaModuleAst = makeAST(EVar(moduleName));	
	default:
		schemaModuleAst = buildExpression(args[1]);	
}) {
							var ` = args[1].expr;
							if (enumIndex ` == 5) {
								var ` = `[0];
								if (enumIndex ` == 0) {
									var ` = `[0];
									{
										var classRef = `;
										{
											var cls = classRef.get();
											var nativeName = null;
											if (cls.meta.has(":native")) {
												var meta = cls.meta.extract(":native");
												if (meta != null && meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
													@:ast(switch (meta[0].params[0].expr) {
	case EConst(CString(s, _)):
		nativeName = s;	
	default:
}) {
														var ` = meta[0].params[0].expr;
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (enumIndex ` == 2) {
																var ` = `[0];
																var ` = `[1];
																{
																	var s = `;
																	{
																		nativeName = s;
																	};
																};
															} else {};
														} else {};
													};
												};
											};
											var moduleName = if (nativeName != null) {
												nativeName;
											} else {
												cls.name;
											};
											schemaModuleAst = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
											};
										};
									};
								} else {
									schemaModuleAst = buildExpression(args[1]);
								};
							} else {
								schemaModuleAst = buildExpression(args[1]);
							};
						};
						var inExpr = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.In, {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("t"), metadata : {}, pos : pos};
							}, schemaModuleAst), metadata : {}, pos : pos};
						};
						var emptyOpts = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EList([]), metadata : {}, pos : pos};
						};
						var fromCall = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Query"), metadata : {}, pos : pos};
							}, "from", [inExpr, emptyOpts]), metadata : {}, pos : pos};
						};
						return fromCall.def;
					};
					if (injectionString.indexOf("Ecto.Changeset.validate_required", null) != -1 && args.length >= 3) {
						var thisAst = buildExpression(args[1]);
						var fieldsAst = buildExpression(args[2]);
						var capture = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ECapture({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EField({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
								}, "to_atom"), metadata : {}, pos : pos};
							}, 1), metadata : {}, pos : pos};
						};
						var mappedFields = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
							}, "map", [fieldsAst, capture]), metadata : {}, pos : pos};
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Changeset"), metadata : {}, pos : pos};
						}, "validate_required", [thisAst, mappedFields]);
					};
					if (injectionString.indexOf("Ecto.Changeset.validate_length", null) != -1 && args.length >= 3) {
						var thisAst = buildExpression(args[1]);
						var fieldAst = buildExpression(args[2]);
						var atomField = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
							}, "to_atom", [fieldAst]), metadata : {}, pos : pos};
						};
						var keys = [];
						if (injectionString.indexOf("min:", null) != -1) {
							keys.push("min");
						};
						if (injectionString.indexOf("max:", null) != -1) {
							keys.push("max");
						};
						if (injectionString.indexOf("is:", null) != -1) {
							keys.push("is");
						};
						var optIndex = 3;
						var pairs = [];
						{
							var ` = 0;
							while (` < keys.length) {
								var k = keys[`];
								++ `;
								if (optIndex < args.length) {
									var valAst = buildExpression(args[optIndex]);
									pairs.push({key : k, value : valAst});
									optIndex ++;
								};
							};
						};
						var optionsAst = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EKeywordList(pairs), metadata : {}, pos : pos};
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Ecto.Changeset"), metadata : {}, pos : pos};
						}, "validate_length", [thisAst, atomField, optionsAst]);
					};
					var presenceTargetModule = "Phoenix.Presence";
					if (context != null && (context.currentModuleHasPresence == true)) {
						var appPrefix = null;
						if (context.currentModule != null) {
							var webIndex = context.currentModule.indexOf("Web", null);
							if (webIndex > 0) {
								appPrefix = context.currentModule.substring(0, webIndex);
							};
						};
						if (appPrefix == null) {
							try {
								appPrefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
							} catch (`:Dynamic) {
								{};
								{};
								if (true) {
									{};
									{};
								} else throw `;
							};
						};
						if (appPrefix != null) {
							presenceTargetModule = appPrefix + "Web.Presence";
						};
					};
					if (injectionString.indexOf("Phoenix.Presence.track", null) != -1 && args.length >= 5) {
						var socketAst = buildExpression(args[1]);
						var topicAst = buildExpression(args[2]);
						var keyAst = buildExpression(args[3]);
						var metaAst = buildExpression(args[4]);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(presenceTargetModule), metadata : {}, pos : pos};
						}, "track", [socketAst, topicAst, keyAst, metaAst]);
					};
					if (injectionString.indexOf("Phoenix.Presence.update", null) != -1 && args.length >= 5) {
						var socketAst = buildExpression(args[1]);
						var topicAst = buildExpression(args[2]);
						var keyAst = buildExpression(args[3]);
						var metaAst = buildExpression(args[4]);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(presenceTargetModule), metadata : {}, pos : pos};
						}, "update", [socketAst, topicAst, keyAst, metaAst]);
					};
					if (injectionString.indexOf("Phoenix.Presence.untrack", null) != -1 && args.length >= 4) {
						var socketAst = buildExpression(args[1]);
						var topicAst = buildExpression(args[2]);
						var keyAst = buildExpression(args[3]);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(presenceTargetModule), metadata : {}, pos : pos};
						}, "untrack", [socketAst, topicAst, keyAst]);
					};
					if (injectionString.indexOf("Phoenix.Presence.list", null) != -1 && args.length >= 2) {
						var topicAst = buildExpression(args[1]);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(presenceTargetModule), metadata : {}, pos : pos};
						}, "list", [topicAst]);
					};
					var finalCode = "";
					var insideString = false;
					var i = 0;
					while (i < injectionString.length) {
						var char = injectionString.charAt(i);
						if (char == "\"" && (i == 0 || injectionString.charAt(i - 1) != "\\")) {
							insideString = ! insideString;
							finalCode += char;
							i ++;
							continue;
						};
						if (char == "{" && i + 1 < injectionString.length) {
							var j = i + 1;
							var numStr = "";
							while (j < injectionString.length && injectionString.charAt(j) >= "0" && injectionString.charAt(j) <= "9") {
								numStr += injectionString.charAt(j);
								j ++;
							};
							if (numStr != "" && j < injectionString.length && injectionString.charAt(j) == "}") {
								var num = Std.parseInt(numStr);
								if (num != null && num + 1 < args.length) {
									var argAst = buildExpression(args[num + 1]);
									var argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst, null);
									if (insideString) {
										finalCode += "#{" + argStr + "}";
									} else {
										finalCode += argStr;
									};
									i = j + 1;
									continue;
								};
							};
						};
						finalCode += char;
						i ++;
					};
					return reflaxe.elixir.ast.ElixirASTDef.ERaw(finalCode);
				};
			};
		};
		if (e != null) {
			@:ast(switch (e.expr) {
	case TField(target, fa):
		switch (fa) {
			case FStatic(classRef, cf):
				var cls = classRef.get();
				var methodName = cf.get().name;
				if (cls.name == "HXX" && methodName == "hxx" && args.length >= 1) {
					var innerAst = buildExpression(args[0]);
					switch (innerAst.def) {
						case EString(s):
							if (s.indexOf("<%=") != -1 || s.indexOf("<% ") != -1 || s.indexOf("<%\n") != -1) {
								var pre = reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(s);
								return ESigil("H", pre, "");
							};						
						default:
					};
					var content = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(innerAst);
					content = reflaxe.elixir.ast.transformers.HeexControlTagTransforms.rewrite(content);
					return ESigil("H", content, "");
				};			
			default:
		};	
	default:
}) {
				var ` = e.expr;
				if (enumIndex ` == 4) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var fa = `;
						{
							@:ast(switch (fa) {
	case FStatic(classRef, cf):
		var cls = classRef.get();
		var methodName = cf.get().name;
		if (cls.name == "HXX" && methodName == "hxx" && args.length >= 1) {
			var innerAst = buildExpression(args[0]);
			switch (innerAst.def) {
				case EString(s):
					if (s.indexOf("<%=") != -1 || s.indexOf("<% ") != -1 || s.indexOf("<%\n") != -1) {
						var pre = reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(s);
						return ESigil("H", pre, "");
					};				
				default:
			};
			var content = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(innerAst);
			content = reflaxe.elixir.ast.transformers.HeexControlTagTransforms.rewrite(content);
			return ESigil("H", content, "");
		};	
	default:
}) if (enumIndex fa == 1) {
								var ` = fa[0];
								var ` = fa[1];
								{
									var classRef = `;
									var cf = `;
									{
										var cls = classRef.get();
										var methodName = cf.get().name;
										if (cls.name == "HXX" && methodName == "hxx" && args.length >= 1) {
											var innerAst = buildExpression(args[0]);
											@:ast(switch (innerAst.def) {
	case EString(s):
		if (s.indexOf("<%=") != -1 || s.indexOf("<% ") != -1 || s.indexOf("<%\n") != -1) {
			var pre = reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(s);
			return ESigil("H", pre, "");
		};	
	default:
}) {
												var ` = innerAst.def;
												if (enumIndex ` == 32) {
													var ` = `[0];
													{
														var s = `;
														{
															if (s.indexOf("<%=", null) != -1 || s.indexOf("<% ", null) != -1 || s.indexOf("<%\n", null) != -1) {
																var pre = reflaxe.elixir.ast.TemplateHelpers.rewriteForBlocks(s);
																return reflaxe.elixir.ast.ElixirASTDef.ESigil("H", pre, "");
															};
														};
													};
												} else {};
											};
											var content = reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(innerAst);
											content = reflaxe.elixir.ast.transformers.HeexControlTagTransforms.rewrite(content);
											return reflaxe.elixir.ast.ElixirASTDef.ESigil("H", content, "");
										};
									};
								};
							} else {};
						};
					};
				} else {};
			};
		};
		if (e != null && reflaxe.elixir.helpers.PatternDetector.isEnumConstructor(e)) {
			return reflaxe.elixir.ast.builders.CallExprBuilder.buildEnumConstructor(e, args, context);
		};
		if (e == null) {
			return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "unknown_function", {
				var ` = [];
				{
					var ` = 0;
					while (` < args.length) {
						var arg = args[`];
						++ `;
						`.push(buildExpression(arg));
					};
				};
				`;
			});
		};
		var target = buildExpression(e);
		var argASTs = {
			var ` = [];
			{
				var ` = 0;
				while (` < args.length) {
					var arg = args[`];
					++ `;
					`.push(buildExpression(arg));
				};
			};
			`;
		};
		@:ast(switch (e.expr) {
	case TField(obj, fa):
		switch (fa) {
			case FInstance(_, _, cf):
				var methodName = cf.get().name;
				return ECall(buildExpression(obj), methodName, argASTs);			
			case FStatic(classRef, cf):
				var className = classRef.get().name;
				var methodName = cf.get().name;
				var classPackArr = classRef.get().pack;
				var classPack = classPackArr != null ? classPackArr.join(".") : "";
				if (classPack == "haxe" && className == "Log" && methodName == "trace") {
					try {
						if (context != null && context.compiler != null) context.compiler.usedLogTrace = true;
					} catch(e:Dynamic) { };
					return ERemoteCall(makeAST(EVar("Log")), "trace", argASTs);
				};
				var specialCall = handleSpecialCall(className, methodName, args, context);
				if (specialCall != null) {
					return specialCall;
				};
				var classPack = classRef.get().pack != null ? classRef.get().pack.join(".") : "";
				if (className == "TypedQuery" && classPack == "ecto" && methodName == "from") {
					if (args.length >= 1) {
						var schemaAst = buildExpression(args[0]);
						var schemaStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(schemaAst);
						var code = "(require Ecto.Query; Ecto.Query.from(t in " + schemaStr + ", []))";
						return ERaw(code);
					};
				};
				var phoenixCall = handlePhoenixCall(className, methodName, args, context);
				if (phoenixCall != null) {
					return phoenixCall;
				};
				var elixirMethodName = ElixirNaming.toVarName(methodName);
				var currentClass = context.getCurrentClass();
				var isSameModule = currentClass != null && currentClass.name == className;
				if (isSameModule) {
					return ECall(null, elixirMethodName, argASTs);
				} else {
					return ERemoteCall(makeAST(EVar(className)), elixirMethodName, argASTs);
				};			
			case FEnum(_, ef):
				return buildEnumConstructor(e, args, context);			
			default:
				return ECall(target, "", argASTs);			
		};	
	case TLocal(v):
		var resolvedName = VariableBuilder.resolveVariableName(v, context);
		if (resolvedName == "trace") {
			try {
				if (context != null && context.compiler != null) context.compiler.usedLogTrace = true;
			} catch(e:Dynamic) { };
			return ERemoteCall(makeAST(EVar("Log")), "trace", argASTs);
		};
		return ECall(makeAST(EVar(resolvedName)), "", argASTs);	
	default:
		return ECall(target, "", argASTs);	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							var resolvedName = reflaxe.elixir.ast.builders.VariableBuilder.resolveVariableName(v, context);
							if (resolvedName == "trace") {
								try {
									if (context != null && context.compiler != null) {
										context.compiler.usedLogTrace = true;
									};
								} catch (`:Dynamic) {
									{};
									{};
									if (true) {
										{};
										{};
									} else throw `;
								};
								return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Log"), metadata : {}, pos : pos};
								}, "trace", argASTs);
							};
							return reflaxe.elixir.ast.ElixirASTDef.ECall({
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EVar(resolvedName), metadata : {}, pos : pos};
							}, "", argASTs);
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						var fa = `;
						{
							@:ast(switch (fa) {
	case FInstance(_, _, cf):
		var methodName = cf.get().name;
		return ECall(buildExpression(obj), methodName, argASTs);	
	case FStatic(classRef, cf):
		var className = classRef.get().name;
		var methodName = cf.get().name;
		var classPackArr = classRef.get().pack;
		var classPack = classPackArr != null ? classPackArr.join(".") : "";
		if (classPack == "haxe" && className == "Log" && methodName == "trace") {
			try {
				if (context != null && context.compiler != null) context.compiler.usedLogTrace = true;
			} catch(e:Dynamic) { };
			return ERemoteCall(makeAST(EVar("Log")), "trace", argASTs);
		};
		var specialCall = handleSpecialCall(className, methodName, args, context);
		if (specialCall != null) {
			return specialCall;
		};
		var classPack = classRef.get().pack != null ? classRef.get().pack.join(".") : "";
		if (className == "TypedQuery" && classPack == "ecto" && methodName == "from") {
			if (args.length >= 1) {
				var schemaAst = buildExpression(args[0]);
				var schemaStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(schemaAst);
				var code = "(require Ecto.Query; Ecto.Query.from(t in " + schemaStr + ", []))";
				return ERaw(code);
			};
		};
		var phoenixCall = handlePhoenixCall(className, methodName, args, context);
		if (phoenixCall != null) {
			return phoenixCall;
		};
		var elixirMethodName = ElixirNaming.toVarName(methodName);
		var currentClass = context.getCurrentClass();
		var isSameModule = currentClass != null && currentClass.name == className;
		if (isSameModule) {
			return ECall(null, elixirMethodName, argASTs);
		} else {
			return ERemoteCall(makeAST(EVar(className)), elixirMethodName, argASTs);
		};	
	case FEnum(_, ef):
		return buildEnumConstructor(e, args, context);	
	default:
		return ECall(target, "", argASTs);	
}) switch (enumIndex fa) {
								case 0: {
									var ` = fa[0];
									var ` = fa[1];
									var ` = fa[2];
									{
										var cf = `;
										{
											var methodName = cf.get().name;
											return reflaxe.elixir.ast.ElixirASTDef.ECall(buildExpression(obj), methodName, argASTs);
										};
									};
								};
								case 1: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var classRef = `;
										var cf = `;
										{
											var className = classRef.get().name;
											var methodName = cf.get().name;
											var classPackArr = classRef.get().pack;
											var classPack = if (classPackArr != null) {
												classPackArr.join(".");
											} else {
												"";
											};
											if (classPack == "haxe" && className == "Log" && methodName == "trace") {
												try {
													if (context != null && context.compiler != null) {
														context.compiler.usedLogTrace = true;
													};
												} catch (`:Dynamic) {
													{};
													{};
													if (true) {
														{};
														{};
													} else throw `;
												};
												return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Log"), metadata : {}, pos : pos};
												}, "trace", argASTs);
											};
											var specialCall = reflaxe.elixir.ast.builders.CallExprBuilder.handleSpecialCall(className, methodName, args, context);
											if (specialCall != null) {
												return specialCall;
											};
											var classPack = if (classRef.get().pack != null) {
												classRef.get().pack.join(".");
											} else {
												"";
											};
											if (className == "TypedQuery" && classPack == "ecto" && methodName == "from") {
												if (args.length >= 1) {
													var schemaAst = buildExpression(args[0]);
													var schemaStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(schemaAst, null);
													var code = "(require Ecto.Query; Ecto.Query.from(t in " + schemaStr + ", []))";
													return reflaxe.elixir.ast.ElixirASTDef.ERaw(code);
												};
											};
											var phoenixCall = reflaxe.elixir.ast.builders.CallExprBuilder.handlePhoenixCall(className, methodName, args, context);
											if (phoenixCall != null) {
												return phoenixCall;
											};
											var elixirMethodName = reflaxe.elixir.ast.naming.ElixirNaming.toVarName(methodName);
											var currentClass = context.getCurrentClass();
											var isSameModule = currentClass != null && currentClass.name == className;
											if (isSameModule) {
												return reflaxe.elixir.ast.ElixirASTDef.ECall(null, elixirMethodName, argASTs);
											} else {
												return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
												}, elixirMethodName, argASTs);
											};
										};
									};
								};
								case 5: {
									var ` = fa[0];
									var ` = fa[1];
									{
										var ef = `;
										{
											return reflaxe.elixir.ast.builders.CallExprBuilder.buildEnumConstructor(e, args, context);
										};
									};
								};
								default: {
									return reflaxe.elixir.ast.ElixirASTDef.ECall(target, "", argASTs);
								}
							};
						};
					};
				};
				default: {
					return reflaxe.elixir.ast.ElixirASTDef.ECall(target, "", argASTs);
				}
			};
		};
	}

	static function buildEnumConstructor(e:haxe.macro.TypedExpr, args:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		var tag = @:ast(switch (e.expr) {
	case TField(_, FEnum(_, ef)):
		ef.name;	
	case TField(_, FStatic(_, cf)):
		{
			var methodName = cf.get().name;
			methodName.charAt(0).toUpperCase() + methodName.substr(1);
		};	
	default:
		"ModuleRef";	
}) {
			var ` = e.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var cf = `;
							{
								{
									var methodName = cf.get().name;
									methodName.charAt(0).toUpperCase() + methodName.substr(1, null);
								};
							};
						};
					};
					case 5: {
						var ` = `[0];
						var ` = `[1];
						{
							var ef = `;
							{
								ef.name;
							};
						};
					};
					default: {
						"ModuleRef";
					}
				};
			} else {
				"ModuleRef";
			};
		};
		if (reflaxe.elixir.ast.builders.CallExprBuilder.hasIdiomaticMetadata(e)) {
			tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
		};
		var needsExtraction = false;
		var extractedAssignments = [];
		var processedArgs = [];
		{
			var ` = 0;
			var ` = args.length;
			while (` < `) {
				var i = ` ++;
				var builtArg = buildExpression(args[i]);
				var isInlineExpansion = @:ast(switch (builtArg.def) {
	case EBlock(exprs) if (exprs.length == 2):
		switch (exprs[0].def) {
			case EMatch(PVar(_), { def : ENil }):
				true;			
			case EBinary(Match, _, { def : ENil }):
				true;			
			case EMatch(PVar(_), { def : EAtom(a) }) if (a == "nil"):
				true;			
			case EBinary(Match, _, { def : EAtom(a) }) if (a == "nil"):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
					var ` = builtArg.def;
					if (enumIndex ` == 53) {
						var ` = `[0];
						{
							var exprs = `;
							if (exprs.length == 2) {
								@:ast(switch (exprs[0].def) {
	case EMatch(PVar(_), { def : ENil }):
		true;	
	case EBinary(Match, _, { def : ENil }):
		true;	
	case EMatch(PVar(_), { def : EAtom(a) }) if (a == "nil"):
		true;	
	case EBinary(Match, _, { def : EAtom(a) }) if (a == "nil"):
		true;	
	default:
		false;	
}) {
									var ` = exprs[0].def;
									switch (enumIndex `) {
										case 8: {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													switch (enumIndex `) {
														case 31: {
															var ` = `[0];
															{
																var a = `;
																if (a == "nil") {
																	true;
																} else {
																	false;
																};
															};
														};
														case 36: {
															{
																true;
															};
														};
														default: {
															false;
														}
													};
												};
											} else {
												false;
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 27) {
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													switch (enumIndex `) {
														case 31: {
															var ` = `[0];
															{
																var a = `;
																if (a == "nil") {
																	true;
																} else {
																	false;
																};
															};
														};
														case 36: {
															{
																true;
															};
														};
														default: {
															false;
														}
													};
												};
											} else {
												false;
											};
										};
										default: {
											false;
										}
									};
								};
							} else {
								false;
							};
						};
					} else {
						false;
					};
				};
				if (isInlineExpansion) {
					var tempVar = "enum_arg_" + i;
					var assignment = {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tempVar), builtArg), metadata : {}, pos : pos};
					};
					extractedAssignments.push(assignment);
					processedArgs.push({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tempVar), metadata : {}, pos : pos};
					});
					needsExtraction = true;
				} else {
					processedArgs.push(builtArg);
				};
			};
		};
		var tupleDef = reflaxe.elixir.ast.ElixirASTDef.ETuple([{
			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
				var this;
				this = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
				cast this;
			});
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		}].concat(processedArgs));
		if (needsExtraction) {
			var blockExprs = extractedAssignments.copy();
			blockExprs.push({
				var pos = null;
				{def : tupleDef, metadata : {}, pos : pos};
			});
			tupleDef = reflaxe.elixir.ast.ElixirASTDef.EBlock(blockExprs);
		};
		return tupleDef;
	}

	static function handleSpecialCall(className:String, methodName:String, args:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		@:ast(switch (className) {
	case "Std":
		switch (methodName) {
			case "is":
				if (args.length == 2) {
					var value = buildExpression(args[0]);
					var typeExpr = args[1];
					var typeCheck = switch (typeExpr.expr) {
						case TTypeExpr(TClassDecl(classRef)):
							var typeName = classRef.get().name;
							switch (typeName) {
								case "String":
									"is_binary";								
								case "Int":
									"is_integer";								
								case "Float":
									"is_float";								
								case "Bool":
									"is_boolean";								
								case "Array":
									"is_list";								
								case "Map":
									"is_map";								
								default:
									null;								
							};						
						default:
							null;						
					};
					if (typeCheck != null) {
						return ECall(makeAST(EVar(typeCheck)), "", [value]);
					};
				};			
			case "string":
				if (args.length == 1) {
					var value = buildExpression(args[0]);
					return ECall(null, "inspect", [value]);
				};			
			case "parseInt":
				if (args.length == 1) {
					var str = buildExpression(args[0]);
					return ERemoteCall(makeAST(EVar("String")), "to_integer", [str]);
				};			
			case "parseFloat":
				if (args.length == 1) {
					var str = buildExpression(args[0]);
					return ERemoteCall(makeAST(EVar("String")), "to_float", [str]);
				};			
			case "int":
				if (args.length == 1) {
					var value = buildExpression(args[0]);
					return ECall(makeAST(EVar("trunc")), "", [value]);
				};			
			case "random":
				if (args.length == 1) {
					var max = buildExpression(args[0]);
					return ERemoteCall(makeAST(EAtom("rand")), "uniform", [max]);
				};			
		};	
	case "Type":
		switch (methodName) {
			case "typeof":
				if (args.length == 1) {
					var value = buildExpression(args[0]);
					return ECall(makeAST(EVar("typeof")), "", [value]);
				};			
			case "getClassName":
				if (args.length == 1) {
					var cls = buildExpression(args[0]);
					var split = ERemoteCall(makeAST(EVar("Module")), "split", [cls]);
					return ERemoteCall(makeAST(EVar("List")), "last", [makeAST(split)]);
				};			
			case "getEnumName":
				if (args.length == 1) {
					var enumValue = buildExpression(args[0]);
					return ECall(makeAST(EVar("elem")), "", [enumValue, makeAST(EInteger(0))]);
				};			
		};	
	case "Reflect":
		switch (methodName) {
			case "field":
				if (args.length == 2) {
					var obj = buildExpression(args[0]);
					var field = buildExpression(args[1]);
					return ERemoteCall(makeAST(EVar("Map")), "get", [obj, field]);
				};			
			case "setField":
				if (args.length == 3) {
					var obj = buildExpression(args[0]);
					var field = buildExpression(args[1]);
					var value = buildExpression(args[2]);
					return ERemoteCall(makeAST(EVar("Map")), "put", [obj, field, value]);
				};			
			case "hasField":
				if (args.length == 2) {
					var obj = buildExpression(args[0]);
					var field = buildExpression(args[1]);
					return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, field]);
				};			
		};	
}) switch (className) {
			case "Reflect": {
				{
					@:ast(switch (methodName) {
	case "field":
		if (args.length == 2) {
			var obj = buildExpression(args[0]);
			var field = buildExpression(args[1]);
			return ERemoteCall(makeAST(EVar("Map")), "get", [obj, field]);
		};	
	case "setField":
		if (args.length == 3) {
			var obj = buildExpression(args[0]);
			var field = buildExpression(args[1]);
			var value = buildExpression(args[2]);
			return ERemoteCall(makeAST(EVar("Map")), "put", [obj, field, value]);
		};	
	case "hasField":
		if (args.length == 2) {
			var obj = buildExpression(args[0]);
			var field = buildExpression(args[1]);
			return ERemoteCall(makeAST(EVar("Map")), "has_key?", [obj, field]);
		};	
}) switch (methodName) {
						case "field": {
							{
								if (args.length == 2) {
									var obj = buildExpression(args[0]);
									var field = buildExpression(args[1]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
									}, "get", [obj, field]);
								};
							};
						};
						case "hasField": {
							{
								if (args.length == 2) {
									var obj = buildExpression(args[0]);
									var field = buildExpression(args[1]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
									}, "has_key?", [obj, field]);
								};
							};
						};
						case "setField": {
							{
								if (args.length == 3) {
									var obj = buildExpression(args[0]);
									var field = buildExpression(args[1]);
									var value = buildExpression(args[2]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
									}, "put", [obj, field, value]);
								};
							};
						};
					};
				};
			};
			case "Std": {
				{
					@:ast(switch (methodName) {
	case "is":
		if (args.length == 2) {
			var value = buildExpression(args[0]);
			var typeExpr = args[1];
			var typeCheck = switch (typeExpr.expr) {
				case TTypeExpr(TClassDecl(classRef)):
					var typeName = classRef.get().name;
					switch (typeName) {
						case "String":
							"is_binary";						
						case "Int":
							"is_integer";						
						case "Float":
							"is_float";						
						case "Bool":
							"is_boolean";						
						case "Array":
							"is_list";						
						case "Map":
							"is_map";						
						default:
							null;						
					};				
				default:
					null;				
			};
			if (typeCheck != null) {
				return ECall(makeAST(EVar(typeCheck)), "", [value]);
			};
		};	
	case "string":
		if (args.length == 1) {
			var value = buildExpression(args[0]);
			return ECall(null, "inspect", [value]);
		};	
	case "parseInt":
		if (args.length == 1) {
			var str = buildExpression(args[0]);
			return ERemoteCall(makeAST(EVar("String")), "to_integer", [str]);
		};	
	case "parseFloat":
		if (args.length == 1) {
			var str = buildExpression(args[0]);
			return ERemoteCall(makeAST(EVar("String")), "to_float", [str]);
		};	
	case "int":
		if (args.length == 1) {
			var value = buildExpression(args[0]);
			return ECall(makeAST(EVar("trunc")), "", [value]);
		};	
	case "random":
		if (args.length == 1) {
			var max = buildExpression(args[0]);
			return ERemoteCall(makeAST(EAtom("rand")), "uniform", [max]);
		};	
}) switch (methodName) {
						case "int": {
							{
								if (args.length == 1) {
									var value = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ECall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("trunc"), metadata : {}, pos : pos};
									}, "", [value]);
								};
							};
						};
						case "is": {
							{
								if (args.length == 2) {
									var value = buildExpression(args[0]);
									var typeExpr = args[1];
									var typeCheck = @:ast(switch (typeExpr.expr) {
	case TTypeExpr(TClassDecl(classRef)):
		var typeName = classRef.get().name;
		switch (typeName) {
			case "String":
				"is_binary";			
			case "Int":
				"is_integer";			
			case "Float":
				"is_float";			
			case "Bool":
				"is_boolean";			
			case "Array":
				"is_list";			
			case "Map":
				"is_map";			
			default:
				null;			
		};	
	default:
		null;	
}) {
										var ` = typeExpr.expr;
										if (enumIndex ` == 5) {
											var ` = `[0];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var classRef = `;
													{
														var typeName = classRef.get().name;
														@:ast(switch (typeName) {
	case "String":
		"is_binary";	
	case "Int":
		"is_integer";	
	case "Float":
		"is_float";	
	case "Bool":
		"is_boolean";	
	case "Array":
		"is_list";	
	case "Map":
		"is_map";	
	default:
		null;	
}) switch (typeName) {
															case "Array": {
																{
																	"is_list";
																};
															};
															case "Bool": {
																{
																	"is_boolean";
																};
															};
															case "Float": {
																{
																	"is_float";
																};
															};
															case "Int": {
																{
																	"is_integer";
																};
															};
															case "Map": {
																{
																	"is_map";
																};
															};
															case "String": {
																{
																	"is_binary";
																};
															};
															default: {
																null;
															}
														};
													};
												};
											} else {
												null;
											};
										} else {
											null;
										};
									};
									if (typeCheck != null) {
										return reflaxe.elixir.ast.ElixirASTDef.ECall({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(typeCheck), metadata : {}, pos : pos};
										}, "", [value]);
									};
								};
							};
						};
						case "parseFloat": {
							{
								if (args.length == 1) {
									var str = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
									}, "to_float", [str]);
								};
							};
						};
						case "parseInt": {
							{
								if (args.length == 1) {
									var str = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
									}, "to_integer", [str]);
								};
							};
						};
						case "random": {
							{
								if (args.length == 1) {
									var max = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase("rand");
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									}, "uniform", [max]);
								};
							};
						};
						case "string": {
							{
								if (args.length == 1) {
									var value = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ECall(null, "inspect", [value]);
								};
							};
						};
					};
				};
			};
			case "Type": {
				{
					@:ast(switch (methodName) {
	case "typeof":
		if (args.length == 1) {
			var value = buildExpression(args[0]);
			return ECall(makeAST(EVar("typeof")), "", [value]);
		};	
	case "getClassName":
		if (args.length == 1) {
			var cls = buildExpression(args[0]);
			var split = ERemoteCall(makeAST(EVar("Module")), "split", [cls]);
			return ERemoteCall(makeAST(EVar("List")), "last", [makeAST(split)]);
		};	
	case "getEnumName":
		if (args.length == 1) {
			var enumValue = buildExpression(args[0]);
			return ECall(makeAST(EVar("elem")), "", [enumValue, makeAST(EInteger(0))]);
		};	
}) switch (methodName) {
						case "getClassName": {
							{
								if (args.length == 1) {
									var cls = buildExpression(args[0]);
									var split = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Module"), metadata : {}, pos : pos};
									}, "split", [cls]);
									return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("List"), metadata : {}, pos : pos};
									}, "last", [{
										var pos = null;
										{def : split, metadata : {}, pos : pos};
									}]);
								};
							};
						};
						case "getEnumName": {
							{
								if (args.length == 1) {
									var enumValue = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ECall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("elem"), metadata : {}, pos : pos};
									}, "", [enumValue, {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
									}]);
								};
							};
						};
						case "typeof": {
							{
								if (args.length == 1) {
									var value = buildExpression(args[0]);
									return reflaxe.elixir.ast.ElixirASTDef.ECall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("typeof"), metadata : {}, pos : pos};
									}, "", [value]);
								};
							};
						};
					};
				};
			};
		};
		return null;
	}

	static function handlePhoenixCall(className:String, methodName:String, args:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var buildExpression = context.getExpressionBuilder();
		if (StringTools.endsWith(className, "PubSub")) {
			@:ast(switch (methodName) {
	case "subscribe", "unsubscribe":
		var moduleRef = makeAST(EVar(className));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		return ERemoteCall(moduleRef, methodName, argASTs);	
	case "broadcast", "broadcast_from":
		var moduleRef = makeAST(EVar(className));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		return ERemoteCall(moduleRef, methodName, argASTs);	
}) switch (methodName) {
				case "broadcast", "broadcast_from": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
				case "subscribe", "unsubscribe": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
			};
		};
		if (StringTools.endsWith(className, "Presence")) {
			@:ast(switch (methodName) {
	case "track", "update", "untrack":
		var moduleRef = makeAST(EVar(className));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		var selfCall = makeAST(ECall(null, "self", []));
		argASTs.unshift(selfCall);
		return ERemoteCall(moduleRef, methodName, argASTs);	
	case "list":
		var moduleRef = makeAST(EVar(className));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		return ERemoteCall(moduleRef, methodName, argASTs);	
}) switch (methodName) {
				case "list": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
				case "track", "untrack", "update": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						var selfCall = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, "self", []), metadata : {}, pos : pos};
						};
						argASTs.unshift(selfCall);
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
			};
		};
		if (className == "LiveView" || className == "Phoenix.LiveView") {
			@:ast(switch (methodName) {
	case "assign", "assign_new", "clear_flash", "put_flash":
		var moduleRef = makeAST(EVar("Phoenix.LiveView"));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		return ERemoteCall(moduleRef, methodName, argASTs);	
	case "push_event", "push_patch", "push_redirect":
		var moduleRef = makeAST(EVar("Phoenix.LiveView"));
		var argASTs = [for (arg  in  args) buildExpression(arg)];
		return ERemoteCall(moduleRef, methodName, argASTs);	
}) switch (methodName) {
				case "push_event", "push_patch", "push_redirect": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.LiveView"), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
				case "assign", "assign_new", "clear_flash", "put_flash": {
					{
						var moduleRef = {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.LiveView"), metadata : {}, pos : pos};
						};
						var argASTs = {
							var ` = [];
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									`.push(buildExpression(arg));
								};
							};
							`;
						};
						return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(moduleRef, methodName, argASTs);
					};
				};
			};
		};
		return null;
	}

	static function hasIdiomaticMetadata(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		return enumType.meta.has("elixirIdiomatic");	
	default:
		return false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 4) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 5) {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							return enumType.meta.has("elixirIdiomatic");
						};
					};
				} else {
					return false;
				};
			} else {
				return false;
			};
		};
	}

	static inline function makeAST(def:reflaxe.elixir.ast.ElixirASTDef, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : {}, pos : pos};
	}
}