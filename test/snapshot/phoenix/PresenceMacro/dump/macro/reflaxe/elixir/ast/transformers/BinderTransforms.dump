class reflaxe.elixir.ast.transformers.BinderTransforms {

	public static function liveViewUseInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		var hasLiveUse = function(body:Array<reflaxe.elixir.ast.ElixirAST>, appPrefix:String) {
			var found = false;
			{
				var ` = 0;
				while (` < body.length) {
					var b = body[`];
					++ `;
					@:ast(switch (b.def) {
	case EUse(module, args):
		if (module == appPrefix + "Web") {
			for (a  in  args) switch (a.def) {
				case EAtom(x) if (x == "live_view"):
					found = true;				
				default:
			};
		};
		if (module == "Phoenix.LiveView") found = true;	
	default:
}) {
						var ` = b.def;
						if (enumIndex ` == 46) {
							var ` = `[0];
							var ` = `[1];
							{
								var module = `;
								var args = `;
								{
									if (module == appPrefix + "Web") {
										{
											var ` = 0;
											while (` < args.length) {
												var a = args[`];
												++ `;
												@:ast(switch (a.def) {
	case EAtom(x) if (x == "live_view"):
		found = true;	
	default:
}) {
													var ` = a.def;
													if (enumIndex ` == 31) {
														var ` = `[0];
														{
															var x = `;
															if (x == "live_view") {
																found = true;
															} else {};
														};
													} else {};
												};
											};
										};
									};
									if (module == "Phoenix.LiveView") {
										found = true;
									};
								};
							};
						} else {};
					};
				};
			};
			return found;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(name, attrs, body) if (looksLikeLiveModule(name)):
		var app = deriveAppPrefix(name);
		if (app != null && !hasLiveUse(body, app)) {
			var useStmt = makeAST(EUse(app + "Web", [makeAST(EAtom("live_view"))]));
			var newBody = [useStmt];
			for (b  in  body) newBody.push(b);
			makeASTWithMeta(EModule(name, attrs, newBody), node.metadata, node.pos);
		} else node;	
	case EDefmodule(name, doBlock) if (looksLikeLiveModule(name)):
		var app2 = deriveAppPrefix(name);
		switch (doBlock.def) {
			case EBlock(stmts) if (app2 != null && !hasLiveUse(stmts, app2)):
				var useStmt = makeAST(EUse(app2 + "Web", [makeAST(EAtom("live_view"))]));
				var newDo = makeAST(EBlock([useStmt].concat(stmts)));
				makeASTWithMeta(EDefmodule(name, newDo), node.metadata, node.pos);			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name != null && (name.indexOf("Web.", null) > 0) && (StringTools.endsWith(name, "Live") || name.indexOf(".Live", null) != -1)) {
								var app = {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (app != null && ! hasLiveUse(body, app)) {
									var useStmt = {
										var def = reflaxe.elixir.ast.ElixirASTDef.EUse(app + "Web", [{
											var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
												var this;
												this = reflaxe.elixir.ast.NameUtils.toSnakeCase("live_view");
												cast this;
											});
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										}]);
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									};
									var newBody = [useStmt];
									{
										var ` = 0;
										while (` < body.length) {
											var b = body[`];
											++ `;
											newBody.push(b);
										};
									};
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : node.metadata, pos : node.pos};
								} else {
									node;
								};
							} else {
								node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name != null && (name.indexOf("Web.", null) > 0) && (StringTools.endsWith(name, "Live") || name.indexOf(".Live", null) != -1)) {
								var app2 = {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								@:ast(switch (doBlock.def) {
	case EBlock(stmts) if (app2 != null && !hasLiveUse(stmts, app2)):
		var useStmt = makeAST(EUse(app2 + "Web", [makeAST(EAtom("live_view"))]));
		var newDo = makeAST(EBlock([useStmt].concat(stmts)));
		makeASTWithMeta(EDefmodule(name, newDo), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var stmts = `;
											if (app2 != null && ! hasLiveUse(stmts, app2)) {
												var useStmt = {
													var def = reflaxe.elixir.ast.ElixirASTDef.EUse(app2 + "Web", [{
														var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
															var this;
															this = reflaxe.elixir.ast.NameUtils.toSnakeCase("live_view");
															cast this;
														});
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													}]);
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												};
												var newDo = {
													var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([useStmt].concat(stmts));
													var pos = null;
													{def : def, metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : node.metadata, pos : node.pos};
											} else {
												node;
											};
										};
									} else {
										node;
									};
								};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function caseClauseBinderRenameFromExprPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return node;
			};
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		var baseName = switch (target.def) {
			case EVar(n):
				n;			
			default:
				null;			
		};
		var preferred = baseName != null ? derivePreferredBinder(baseName) : null;
		for (clause  in  clauses) {
			if (preferred != null) {
				var renamedPattern = tryRenameSingleBinder(clause.pattern, preferred);
				if (renamedPattern != null) {
					newClauses.push({ pattern : renamedPattern, guard : clause.guard, body : clause.body });
					continue;
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							var baseName = @:ast(switch (target.def) {
	case EVar(n):
		n;	
	default:
		null;	
}) {
								var ` = target.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var n = `;
										{
											n;
										};
									};
								} else {
									null;
								};
							};
							var preferred = if (baseName != null) {
								reflaxe.elixir.ast.transformers.BinderTransforms.derivePreferredBinder(baseName);
							} else {
								null;
							};
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if (preferred != null) {
										var renamedPattern = reflaxe.elixir.ast.transformers.BinderTransforms.tryRenameSingleBinder(clause.pattern, preferred);
										if (renamedPattern != null) {
											newClauses.push({pattern : renamedPattern, guard : clause.guard, body : clause.body});
											continue;
										};
									};
									newClauses.push(clause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function globalRepoQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var derivedApp = [null];
		reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EModule(name, _, _):
		var idx = name.indexOf(".Repo");
		if (idx > 0) derivedApp = name.substring(0, idx);	
	default:
}) {
				var ` = n.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						{
							var idx = name.indexOf(".Repo", null);
							if (idx > 0) {
								derivedApp[0] = name.substring(0, idx);
							};
						};
					};
				} else {};
			};
			return n;
		});
		var app = if (derivedApp[0] != null) {
			derivedApp[0];
		} else {
			reflaxe.elixir.PhoenixMapper.getAppModuleName();
		};
		if (app == null || app.length == 0) {
			return ast;
		};
		var repoName = app + ".Repo";
		var rewrite = function(node:reflaxe.elixir.ast.ElixirAST) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (m == "Repo"):
				makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);			
			case EVar(m) if (m.indexOf(".Repo") != -1):
				n;			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null):
		switch (target.def) {
			case EVar(m) if (m == "Repo"):
				makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);			
			default:
				n;			
		};	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								var func = `;
								var args = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (m == "Repo"):
		makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(repoName), metadata : {}, pos : pos};
													}, func, args), metadata : n.metadata, pos : n.pos};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (m == "Repo"):
		makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);	
	case EVar(m) if (m.indexOf(".Repo") != -1):
		n;	
	default:
		n;	
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(repoName), metadata : {}, pos : pos};
													}, func, args), metadata : n.metadata, pos : n.pos};
												} else {
													var m = `;
													if (m.indexOf(".Repo", null) != -1) {
														n;
													} else {
														n;
													};
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return rewrite(ast);
	}

	public static function liveViewErrorBinderRenamePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(name, attrs, body) if (isLiveViewModule(name)):
		var newBody = [];
		for (b  in  body) {
			var tb = ElixirASTTransformer.transformNode(b, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case EFn(clauses):
						var newClauses = [];
						for (cl  in  clauses) {
							var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(m:ElixirAST):ElixirAST {
								return switch (m.def) {
									case ECase(target, innerClauses):
										var renamedClauses = [];
										for (ic  in  innerClauses) {
											var usedInner = collectUsedLowerVars(ic.body);
											var r = renameErrorBinderConditional(ic.pattern, usedInner);
											renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
										};
										makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);									
									default:
										m;									
								};
							});
							newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
						};
						makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);					
					case ECase(target, clauses):
						var newClauses = [];
						for (c  in  clauses) {
							var used = collectUsedLowerVars(c.body);
							var renamed = renameErrorBinderConditional(c.pattern, used);
							newClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
						};
						makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);					
					default:
						n;					
				};
			});
			newBody.push(tb);
		};
		makeASTWithMeta(EModule(name, attrs, newBody), node.metadata, node.pos);	
	case EDefmodule(name, doBlock) if (isLiveViewModule(name)):
		var transformed = ElixirASTTransformer.transformNode(doBlock, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case EFn(clauses):
					var newClauses = [];
					for (cl  in  clauses) {
						var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(m:ElixirAST):ElixirAST {
							return switch (m.def) {
								case ECase(target, innerClauses):
									var renamedClauses = [];
									for (ic  in  innerClauses) {
										var usedInner = collectUsedLowerVars(ic.body);
										var r = renameErrorBinderConditional(ic.pattern, usedInner);
										renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
									};
									makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);								
								default:
									m;								
							};
						});
						newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
					};
					makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);				
				case ECase(target, clauses):
					var newClauses = [];
					for (c  in  clauses) {
						var used = collectUsedLowerVars(c.body);
						var renamed = renameErrorBinderConditional(c.pattern, used);
						newClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefmodule(name, transformed), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name != null && (StringTools.endsWith(name, "Live") || name.indexOf("Live", null) != -1)) {
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										var tb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(n:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(m:ElixirAST):ElixirAST {
				return switch (m.def) {
					case ECase(target, innerClauses):
						var renamedClauses = [];
						for (ic  in  innerClauses) {
							var usedInner = collectUsedLowerVars(ic.body);
							var r = renameErrorBinderConditional(ic.pattern, usedInner);
							renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
						};
						makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);					
					default:
						m;					
				};
			});
			newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	case ECase(target, clauses):
		var newClauses = [];
		for (c  in  clauses) {
			var used = collectUsedLowerVars(c.body);
			var renamed = renameErrorBinderConditional(c.pattern, used);
			newClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
												var ` = n.def;
												switch (enumIndex `) {
													case 6: {
														var ` = `[0];
														var ` = `[1];
														{
															var target = `;
															var clauses = `;
															{
																var newClauses = [];
																{
																	var ` = 0;
																	while (` < clauses.length) {
																		var c = clauses[`];
																		++ `;
																		var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(c.body);
																		var renamed = {
																			var p = c.pattern;
																			@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		var tag = tagOf(p);
		switch elements[1] {
			case PVar(n) if (tag == "error" && n != "reason"):
				if (used != null && used.indexOf("changeset") == -1) {
					PTuple([elements[0], PVar("reason")]);
				} else {
					p;
				};			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																				var ` = p[0];
																				{
																					var elements = `;
																					if (elements.length == 2) {
																						var tag = @:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																							var ` = p[0];
																							{
																								var elements = `;
																								if (elements.length >= 1) {
																									@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																										var ` = elements[0];
																										if (enumIndex ` == 1) {
																											var ` = `[0];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 31) {
																													var ` = `[0];
																													{
																														var a = `;
																														{
																															a;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																						@:ast(switch elements[1] {
	case PVar(n) if (tag == "error" && n != "reason"):
		if (used != null && used.indexOf("changeset") == -1) {
			PTuple([elements[0], PVar("reason")]);
		} else {
			p;
		};	
	default:
		p;	
}) {
																							var ` = elements[1];
																							if (enumIndex ` == 0) {
																								var ` = `[0];
																								{
																									var n = `;
																									if (tag == "error" && n != "reason") {
																										if (used != null && used.indexOf("changeset", null) == -1) {
																											reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																										} else {
																											p;
																										};
																									} else {
																										p;
																									};
																								};
																							} else {
																								p;
																							};
																						};
																					} else {
																						p;
																					};
																				};
																			} else {
																				p;
																			};
																		};
																		newClauses.push({pattern : renamed, guard : c.guard, body : c.body});
																	};
																};
																{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
															};
														};
													};
													case 42: {
														var ` = `[0];
														{
															var clauses = `;
															{
																var newClauses = [];
																{
																	var ` = 0;
																	while (` < clauses.length) {
																		var cl = clauses[`];
																		++ `;
																		var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(cl.body, function(m:reflaxe.elixir.ast.ElixirAST) {
																			return @:ast(switch (m.def) {
	case ECase(target, innerClauses):
		var renamedClauses = [];
		for (ic  in  innerClauses) {
			var usedInner = collectUsedLowerVars(ic.body);
			var r = renameErrorBinderConditional(ic.pattern, usedInner);
			renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
		};
		makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);	
	default:
		m;	
}) {
																				var ` = m.def;
																				if (enumIndex ` == 6) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var target = `;
																						var innerClauses = `;
																						{
																							var renamedClauses = [];
																							{
																								var ` = 0;
																								while (` < innerClauses.length) {
																									var ic = innerClauses[`];
																									++ `;
																									var usedInner = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(ic.body);
																									var r = {
																										var p = ic.pattern;
																										@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		var tag = tagOf(p);
		switch elements[1] {
			case PVar(n) if (tag == "error" && n != "reason"):
				if (used != null && used.indexOf("changeset") == -1) {
					PTuple([elements[0], PVar("reason")]);
				} else {
					p;
				};			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																											var ` = p[0];
																											{
																												var elements = `;
																												if (elements.length == 2) {
																													var tag = @:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																														var ` = p[0];
																														{
																															var elements = `;
																															if (elements.length >= 1) {
																																@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																																	var ` = elements[0];
																																	if (enumIndex ` == 1) {
																																		var ` = `[0];
																																		{
																																			var ` = `.def;
																																			var ` = `.metadata;
																																			var ` = `.pos;
																																			if (enumIndex ` == 31) {
																																				var ` = `[0];
																																				{
																																					var a = `;
																																					{
																																						a;
																																					};
																																				};
																																			} else {
																																				null;
																																			};
																																		};
																																	} else {
																																		null;
																																	};
																																};
																															} else {
																																null;
																															};
																														};
																													} else {
																														null;
																													};
																													@:ast(switch elements[1] {
	case PVar(n) if (tag == "error" && n != "reason"):
		if (used != null && used.indexOf("changeset") == -1) {
			PTuple([elements[0], PVar("reason")]);
		} else {
			p;
		};	
	default:
		p;	
}) {
																														var ` = elements[1];
																														if (enumIndex ` == 0) {
																															var ` = `[0];
																															{
																																var n = `;
																																if (tag == "error" && n != "reason") {
																																	if (usedInner != null && usedInner.indexOf("changeset", null) == -1) {
																																		reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																																	} else {
																																		p;
																																	};
																																} else {
																																	p;
																																};
																															};
																														} else {
																															p;
																														};
																													};
																												} else {
																													p;
																												};
																											};
																										} else {
																											p;
																										};
																									};
																									renamedClauses.push({pattern : r, guard : ic.guard, body : ic.body});
																								};
																							};
																							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, renamedClauses), metadata : m.metadata, pos : m.pos};
																						};
																					};
																				} else {
																					m;
																				};
																			};
																		});
																		newClauses.push({args : cl.args, guard : cl.guard, body : fixedBody});
																	};
																};
																{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
															};
														};
													};
													default: {
														n;
													}
												};
											};
										});
										newBody.push(tb);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name != null && (StringTools.endsWith(name, "Live") || name.indexOf("Live", null) != -1)) {
								var transformed = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(m:ElixirAST):ElixirAST {
				return switch (m.def) {
					case ECase(target, innerClauses):
						var renamedClauses = [];
						for (ic  in  innerClauses) {
							var usedInner = collectUsedLowerVars(ic.body);
							var r = renameErrorBinderConditional(ic.pattern, usedInner);
							renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
						};
						makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);					
					default:
						m;					
				};
			});
			newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
		};
		makeASTWithMeta(EFn(newClauses), n.metadata, n.pos);	
	case ECase(target, clauses):
		var newClauses = [];
		for (c  in  clauses) {
			var used = collectUsedLowerVars(c.body);
			var renamed = renameErrorBinderConditional(c.pattern, used);
			newClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										switch (enumIndex `) {
											case 6: {
												var ` = `[0];
												var ` = `[1];
												{
													var target = `;
													var clauses = `;
													{
														var newClauses = [];
														{
															var ` = 0;
															while (` < clauses.length) {
																var c = clauses[`];
																++ `;
																var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(c.body);
																var renamed = {
																	var p = c.pattern;
																	@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		var tag = tagOf(p);
		switch elements[1] {
			case PVar(n) if (tag == "error" && n != "reason"):
				if (used != null && used.indexOf("changeset") == -1) {
					PTuple([elements[0], PVar("reason")]);
				} else {
					p;
				};			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																		var ` = p[0];
																		{
																			var elements = `;
																			if (elements.length == 2) {
																				var tag = @:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																					var ` = p[0];
																					{
																						var elements = `;
																						if (elements.length >= 1) {
																							@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																								var ` = elements[0];
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									{
																										var ` = `.def;
																										var ` = `.metadata;
																										var ` = `.pos;
																										if (enumIndex ` == 31) {
																											var ` = `[0];
																											{
																												var a = `;
																												{
																													a;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																				@:ast(switch elements[1] {
	case PVar(n) if (tag == "error" && n != "reason"):
		if (used != null && used.indexOf("changeset") == -1) {
			PTuple([elements[0], PVar("reason")]);
		} else {
			p;
		};	
	default:
		p;	
}) {
																					var ` = elements[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						{
																							var n = `;
																							if (tag == "error" && n != "reason") {
																								if (used != null && used.indexOf("changeset", null) == -1) {
																									reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																								} else {
																									p;
																								};
																							} else {
																								p;
																							};
																						};
																					} else {
																						p;
																					};
																				};
																			} else {
																				p;
																			};
																		};
																	} else {
																		p;
																	};
																};
																newClauses.push({pattern : renamed, guard : c.guard, body : c.body});
															};
														};
														{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
													};
												};
											};
											case 42: {
												var ` = `[0];
												{
													var clauses = `;
													{
														var newClauses = [];
														{
															var ` = 0;
															while (` < clauses.length) {
																var cl = clauses[`];
																++ `;
																var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(cl.body, function(m:reflaxe.elixir.ast.ElixirAST) {
																	return @:ast(switch (m.def) {
	case ECase(target, innerClauses):
		var renamedClauses = [];
		for (ic  in  innerClauses) {
			var usedInner = collectUsedLowerVars(ic.body);
			var r = renameErrorBinderConditional(ic.pattern, usedInner);
			renamedClauses.push({ pattern : r, guard : ic.guard, body : ic.body });
		};
		makeASTWithMeta(ECase(target, renamedClauses), m.metadata, m.pos);	
	default:
		m;	
}) {
																		var ` = m.def;
																		if (enumIndex ` == 6) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var target = `;
																				var innerClauses = `;
																				{
																					var renamedClauses = [];
																					{
																						var ` = 0;
																						while (` < innerClauses.length) {
																							var ic = innerClauses[`];
																							++ `;
																							var usedInner = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(ic.body);
																							var r = {
																								var p = ic.pattern;
																								@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		var tag = tagOf(p);
		switch elements[1] {
			case PVar(n) if (tag == "error" && n != "reason"):
				if (used != null && used.indexOf("changeset") == -1) {
					PTuple([elements[0], PVar("reason")]);
				} else {
					p;
				};			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																									var ` = p[0];
																									{
																										var elements = `;
																										if (elements.length == 2) {
																											var tag = @:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																												var ` = p[0];
																												{
																													var elements = `;
																													if (elements.length >= 1) {
																														@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																															var ` = elements[0];
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var ` = `.def;
																																	var ` = `.metadata;
																																	var ` = `.pos;
																																	if (enumIndex ` == 31) {
																																		var ` = `[0];
																																		{
																																			var a = `;
																																			{
																																				a;
																																			};
																																		};
																																	} else {
																																		null;
																																	};
																																};
																															} else {
																																null;
																															};
																														};
																													} else {
																														null;
																													};
																												};
																											} else {
																												null;
																											};
																											@:ast(switch elements[1] {
	case PVar(n) if (tag == "error" && n != "reason"):
		if (used != null && used.indexOf("changeset") == -1) {
			PTuple([elements[0], PVar("reason")]);
		} else {
			p;
		};	
	default:
		p;	
}) {
																												var ` = elements[1];
																												if (enumIndex ` == 0) {
																													var ` = `[0];
																													{
																														var n = `;
																														if (tag == "error" && n != "reason") {
																															if (usedInner != null && usedInner.indexOf("changeset", null) == -1) {
																																reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																															} else {
																																p;
																															};
																														} else {
																															p;
																														};
																													};
																												} else {
																													p;
																												};
																											};
																										} else {
																											p;
																										};
																									};
																								} else {
																									p;
																								};
																							};
																							renamedClauses.push({pattern : r, guard : ic.guard, body : ic.body});
																						};
																					};
																					{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, renamedClauses), metadata : m.metadata, pos : m.pos};
																				};
																			};
																		} else {
																			m;
																		};
																	};
																});
																newClauses.push({args : cl.args, guard : cl.guard, body : fixedBody});
															};
														};
														{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : n.metadata, pos : n.pos};
													};
												};
											};
											default: {
												n;
											}
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformed), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function stringSearchFilterNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ERemoteCall(mod, func, args) if ((func == "filter") && args != null && args.length == 2):
		var pred = args[1];
		switch (pred.def) {
			case EFn(clauses) if (clauses.length > 0):
				var newClauses = [];
				for (cl  in  clauses) {
					var tVar:Null<String> = null;
					if (cl.args != null && cl.args.length > 0) switch (cl.args[0]) {
						case PVar(n):
							tVar = n;						
						default:
					};
					if (tVar == null) {
						newClauses.push(cl);
						continue;
					};
					var tVarRef = makeAST(EVar(tVar));
					var titleField = makeAST(EField(tVarRef, "title"));
					var titleBool = makeIsNotNil(binaryMatch(downcase(titleField), makeAST(EVar("query"))));
					var descField = makeAST(EField(tVarRef, "description"));
					var descPresent = makeAST(EBinary(NotEqual, descField, makeAST(ENil)));
					var descBool = makeIsNotNil(binaryMatch(downcase(descField), makeAST(EVar("query"))));
					var right = makeAST(EBinary(And, descPresent, descBool));
					var combined = makeAST(EBinary(Or, titleBool, right));
					newClauses.push({ args : cl.args, guard : cl.guard, body : combined });
				};
				var newPred = makeAST(EFn(newClauses));
				makeASTWithMeta(ERemoteCall(mod, func, [args[0], newPred]), node.metadata, node.pos);			
			default:
				node;			
		};	
	case ECall(target, func, args) if ((func == "filter") && args != null && args.length == 2):
		var pred = args[1];
		switch (pred.def) {
			case EFn(clauses) if (clauses.length > 0):
				var newClauses = [];
				for (cl  in  clauses) {
					var tVar:Null<String> = null;
					if (cl.args != null && cl.args.length > 0) switch (cl.args[0]) {
						case PVar(n):
							tVar = n;						
						default:
					};
					if (tVar == null) {
						newClauses.push(cl);
						continue;
					};
					var tVarRef = makeAST(EVar(tVar));
					var titleField = makeAST(EField(tVarRef, "title"));
					var titleBool = makeIsNotNil(binaryMatch(downcase(titleField), makeAST(EVar("query"))));
					var descField = makeAST(EField(tVarRef, "description"));
					var descPresent = makeAST(EBinary(NotEqual, descField, makeAST(ENil)));
					var descBool = makeIsNotNil(binaryMatch(downcase(descField), makeAST(EVar("query"))));
					var right = makeAST(EBinary(And, descPresent, descBool));
					var combined = makeAST(EBinary(Or, titleBool, right));
					newClauses.push({ args : cl.args, guard : cl.guard, body : combined });
				};
				var newPred = makeAST(EFn(newClauses));
				makeASTWithMeta(ECall(target, func, [args[0], newPred]), node.metadata, node.pos);			
			default:
				node;			
		};	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							if ((func == "filter") && args != null && args.length == 2) {
								var pred = args[1];
								@:ast(switch (pred.def) {
	case EFn(clauses) if (clauses.length > 0):
		var newClauses = [];
		for (cl  in  clauses) {
			var tVar:Null<String> = null;
			if (cl.args != null && cl.args.length > 0) switch (cl.args[0]) {
				case PVar(n):
					tVar = n;				
				default:
			};
			if (tVar == null) {
				newClauses.push(cl);
				continue;
			};
			var tVarRef = makeAST(EVar(tVar));
			var titleField = makeAST(EField(tVarRef, "title"));
			var titleBool = makeIsNotNil(binaryMatch(downcase(titleField), makeAST(EVar("query"))));
			var descField = makeAST(EField(tVarRef, "description"));
			var descPresent = makeAST(EBinary(NotEqual, descField, makeAST(ENil)));
			var descBool = makeIsNotNil(binaryMatch(downcase(descField), makeAST(EVar("query"))));
			var right = makeAST(EBinary(And, descPresent, descBool));
			var combined = makeAST(EBinary(Or, titleBool, right));
			newClauses.push({ args : cl.args, guard : cl.guard, body : combined });
		};
		var newPred = makeAST(EFn(newClauses));
		makeASTWithMeta(ECall(target, func, [args[0], newPred]), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = pred.def;
									if (enumIndex ` == 42) {
										var ` = `[0];
										{
											var clauses = `;
											if (clauses.length > 0) {
												var newClauses = [];
												{
													var ` = 0;
													while (` < clauses.length) {
														var cl = clauses[`];
														++ `;
														var tVar = null;
														if (cl.args != null && cl.args.length > 0) {
															@:ast(switch (cl.args[0]) {
	case PVar(n):
		tVar = n;	
	default:
}) {
																var ` = cl.args[0];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var n = `;
																		{
																			tVar = n;
																		};
																	};
																} else {};
															};
														};
														if (tVar == null) {
															newClauses.push(cl);
															continue;
														};
														var tVarRef = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tVar), metadata : {}, pos : pos};
														};
														var titleField = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EField(tVarRef, "title"), metadata : {}, pos : pos};
														};
														var titleBool = {
															var expr = {
																var str = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																	}, "downcase", [titleField]), metadata : {}, pos : pos};
																};
																var query = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("query"), metadata : {}, pos : pos};
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(":binary"), metadata : {}, pos : pos};
																	}, "match", [str, query]), metadata : {}, pos : pos};
																};
															};
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																	}, "is_nil", [expr]), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
														var descField = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EField(tVarRef, "description"), metadata : {}, pos : pos};
														};
														var descPresent = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, descField, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														};
														var descBool = {
															var expr = {
																var str = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																	}, "downcase", [descField]), metadata : {}, pos : pos};
																};
																var query = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("query"), metadata : {}, pos : pos};
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(":binary"), metadata : {}, pos : pos};
																	}, "match", [str, query]), metadata : {}, pos : pos};
																};
															};
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																	}, "is_nil", [expr]), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
														var right = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.And, descPresent, descBool), metadata : {}, pos : pos};
														};
														var combined = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Or, titleBool, right), metadata : {}, pos : pos};
														};
														newClauses.push({args : cl.args, guard : cl.guard, body : combined});
													};
												};
												var newPred = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, [args[0], newPred]), metadata : node.metadata, pos : node.pos};
											} else {
												node;
											};
										};
									} else {
										node;
									};
								};
							} else {
								node;
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var func = `;
							var args = `;
							if ((func == "filter") && args != null && args.length == 2) {
								var pred = args[1];
								@:ast(switch (pred.def) {
	case EFn(clauses) if (clauses.length > 0):
		var newClauses = [];
		for (cl  in  clauses) {
			var tVar:Null<String> = null;
			if (cl.args != null && cl.args.length > 0) switch (cl.args[0]) {
				case PVar(n):
					tVar = n;				
				default:
			};
			if (tVar == null) {
				newClauses.push(cl);
				continue;
			};
			var tVarRef = makeAST(EVar(tVar));
			var titleField = makeAST(EField(tVarRef, "title"));
			var titleBool = makeIsNotNil(binaryMatch(downcase(titleField), makeAST(EVar("query"))));
			var descField = makeAST(EField(tVarRef, "description"));
			var descPresent = makeAST(EBinary(NotEqual, descField, makeAST(ENil)));
			var descBool = makeIsNotNil(binaryMatch(downcase(descField), makeAST(EVar("query"))));
			var right = makeAST(EBinary(And, descPresent, descBool));
			var combined = makeAST(EBinary(Or, titleBool, right));
			newClauses.push({ args : cl.args, guard : cl.guard, body : combined });
		};
		var newPred = makeAST(EFn(newClauses));
		makeASTWithMeta(ERemoteCall(mod, func, [args[0], newPred]), node.metadata, node.pos);	
	default:
		node;	
}) {
									var ` = pred.def;
									if (enumIndex ` == 42) {
										var ` = `[0];
										{
											var clauses = `;
											if (clauses.length > 0) {
												var newClauses = [];
												{
													var ` = 0;
													while (` < clauses.length) {
														var cl = clauses[`];
														++ `;
														var tVar = null;
														if (cl.args != null && cl.args.length > 0) {
															@:ast(switch (cl.args[0]) {
	case PVar(n):
		tVar = n;	
	default:
}) {
																var ` = cl.args[0];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var n = `;
																		{
																			tVar = n;
																		};
																	};
																} else {};
															};
														};
														if (tVar == null) {
															newClauses.push(cl);
															continue;
														};
														var tVarRef = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tVar), metadata : {}, pos : pos};
														};
														var titleField = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EField(tVarRef, "title"), metadata : {}, pos : pos};
														};
														var titleBool = {
															var expr = {
																var str = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																	}, "downcase", [titleField]), metadata : {}, pos : pos};
																};
																var query = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("query"), metadata : {}, pos : pos};
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(":binary"), metadata : {}, pos : pos};
																	}, "match", [str, query]), metadata : {}, pos : pos};
																};
															};
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																	}, "is_nil", [expr]), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
														var descField = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EField(tVarRef, "description"), metadata : {}, pos : pos};
														};
														var descPresent = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, descField, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														};
														var descBool = {
															var expr = {
																var str = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("String"), metadata : {}, pos : pos};
																	}, "downcase", [descField]), metadata : {}, pos : pos};
																};
																var query = {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("query"), metadata : {}, pos : pos};
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar(":binary"), metadata : {}, pos : pos};
																	}, "match", [str, query]), metadata : {}, pos : pos};
																};
															};
															{
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
																	}, "is_nil", [expr]), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															};
														};
														var right = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.And, descPresent, descBool), metadata : {}, pos : pos};
														};
														var combined = {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Or, titleBool, right), metadata : {}, pos : pos};
														};
														newClauses.push({args : cl.args, guard : cl.guard, body : combined});
													};
												};
												var newPred = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : {}, pos : pos};
												};
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, [args[0], newPred]), metadata : node.metadata, pos : node.pos};
											} else {
												node;
											};
										};
									} else {
										node;
									};
								};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function liveViewReduceWhileErrorBinderNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		var normalizeFnBody = function(fnAst:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (fnAst.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case ECase(target, caseClauses):
						var newCaseClauses = [];
						for (c  in  caseClauses) {
							var tag = tagOf(c.pattern);
							if (tag == "error") {
								var used = collectUsedLowerVars(c.body);
								var usesReason = used.indexOf("reason") != -1;
								var usesChangeset = used.indexOf("changeset") != -1;
								if (usesReason && !usesChangeset) {
									var renamed = renameBinder(c.pattern, "reason");
									newCaseClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
									continue;
								};
							};
							newCaseClauses.push(c);
						};
						makeASTWithMeta(ECase(target, newCaseClauses), n.metadata, n.pos);					
					default:
						n;					
				};
			});
			newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
		};
		makeASTWithMeta(EFn(newClauses), fnAst.metadata, fnAst.pos);	
	default:
		fnAst;	
}) {
				var ` = fnAst.def;
				if (enumIndex ` == 42) {
					var ` = `[0];
					{
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(cl.body, function(n:reflaxe.elixir.ast.ElixirAST) {
										return @:ast(switch (n.def) {
	case ECase(target, caseClauses):
		var newCaseClauses = [];
		for (c  in  caseClauses) {
			var tag = tagOf(c.pattern);
			if (tag == "error") {
				var used = collectUsedLowerVars(c.body);
				var usesReason = used.indexOf("reason") != -1;
				var usesChangeset = used.indexOf("changeset") != -1;
				if (usesReason && !usesChangeset) {
					var renamed = renameBinder(c.pattern, "reason");
					newCaseClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
					continue;
				};
			};
			newCaseClauses.push(c);
		};
		makeASTWithMeta(ECase(target, newCaseClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
											var ` = n.def;
											if (enumIndex ` == 6) {
												var ` = `[0];
												var ` = `[1];
												{
													var target = `;
													var caseClauses = `;
													{
														var newCaseClauses = [];
														{
															var ` = 0;
															while (` < caseClauses.length) {
																var c = caseClauses[`];
																++ `;
																var tag = {
																	var p = c.pattern;
																	@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																		var ` = p[0];
																		{
																			var elements = `;
																			if (elements.length >= 1) {
																				@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																					var ` = elements[0];
																					if (enumIndex ` == 1) {
																						var ` = `[0];
																						{
																							var ` = `.def;
																							var ` = `.metadata;
																							var ` = `.pos;
																							if (enumIndex ` == 31) {
																								var ` = `[0];
																								{
																									var a = `;
																									{
																										a;
																									};
																								};
																							} else {
																								null;
																							};
																						};
																					} else {
																						null;
																					};
																				};
																			} else {
																				null;
																			};
																		};
																	} else {
																		null;
																	};
																};
																if (tag == "error") {
																	var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(c.body);
																	var usesReason = used.indexOf("reason", null) != -1;
																	var usesChangeset = used.indexOf("changeset", null) != -1;
																	if (usesReason && ! usesChangeset) {
																		var renamed = {
																			var p = c.pattern;
																			@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																				var ` = p[0];
																				{
																					var elements = `;
																					if (elements.length == 2) {
																						@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																							var ` = elements[1];
																							if (enumIndex ` == 0) {
																								var ` = `[0];
																								{
																									reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																								};
																							} else {
																								p;
																							};
																						};
																					} else {
																						p;
																					};
																				};
																			} else {
																				p;
																			};
																		};
																		newCaseClauses.push({pattern : renamed, guard : c.guard, body : c.body});
																		continue;
																	};
																};
																newCaseClauses.push(c);
															};
														};
														{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newCaseClauses), metadata : n.metadata, pos : n.pos};
													};
												};
											} else {
												n;
											};
										};
									});
									newClauses.push({args : cl.args, guard : cl.guard, body : fixedBody});
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : fnAst.metadata, pos : fnAst.pos};
						};
					};
				} else {
					fnAst;
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(name, attrs, body) if (isLiveViewModule(name)):
		var newBody = [];
		for (b  in  body) {
			var tb = ElixirASTTransformer.transformNode(b, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case ERemoteCall(mod, func, args):
						var isEnum = switch (mod.def) {
							case EVar(m) if (m == "Enum"):
								true;							
							default:
								false;							
						};
						if (isEnum && func == "reduce_while" && args != null && args.length >= 3) {
							var newArgs = args.copy();
							newArgs[2] = normalizeFnBody(args[2]);
							makeASTWithMeta(ERemoteCall(mod, func, newArgs), n.metadata, n.pos);
						} else n;					
					case ECall(target, func, args):
						if (func == "reduce_while" && args != null && args.length >= 3) {
							var newArgs = args.copy();
							newArgs[2] = normalizeFnBody(args[2]);
							makeASTWithMeta(ECall(target, func, newArgs), n.metadata, n.pos);
						} else n;					
					default:
						n;					
				};
			});
			newBody.push(tb);
		};
		makeASTWithMeta(EModule(name, attrs, newBody), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						var attrs = `;
						var body = `;
						if (name != null && (StringTools.endsWith(name, "Live") || name.indexOf("Live", null) != -1)) {
							var newBody = [];
							{
								var ` = 0;
								while (` < body.length) {
									var b = body[`];
									++ `;
									var tb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(n:reflaxe.elixir.ast.ElixirAST) {
										return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		var isEnum = switch (mod.def) {
			case EVar(m) if (m == "Enum"):
				true;			
			default:
				false;			
		};
		if (isEnum && func == "reduce_while" && args != null && args.length >= 3) {
			var newArgs = args.copy();
			newArgs[2] = normalizeFnBody(args[2]);
			makeASTWithMeta(ERemoteCall(mod, func, newArgs), n.metadata, n.pos);
		} else n;	
	case ECall(target, func, args):
		if (func == "reduce_while" && args != null && args.length >= 3) {
			var newArgs = args.copy();
			newArgs[2] = normalizeFnBody(args[2]);
			makeASTWithMeta(ECall(target, func, newArgs), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
											var ` = n.def;
											switch (enumIndex `) {
												case 22: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var target = `;
														var func = `;
														var args = `;
														{
															if (func == "reduce_while" && args != null && args.length >= 3) {
																var newArgs = args.copy();
																newArgs[2] = normalizeFnBody(args[2]);
																{def : reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, newArgs), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													};
												};
												case 24: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var mod = `;
														var func = `;
														var args = `;
														{
															var isEnum = @:ast(switch (mod.def) {
	case EVar(m) if (m == "Enum"):
		true;	
	default:
		false;	
}) {
																var ` = mod.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var m = `;
																		if (m == "Enum") {
																			true;
																		} else {
																			false;
																		};
																	};
																} else {
																	false;
																};
															};
															if (isEnum && func == "reduce_while" && args != null && args.length >= 3) {
																var newArgs = args.copy();
																newArgs[2] = normalizeFnBody(args[2]);
																{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, newArgs), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													};
												};
												default: {
													n;
												}
											};
										};
									});
									newBody.push(tb);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : node.metadata, pos : node.pos};
						} else {
							node;
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function liveViewAssignCallRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var rewriteInside = function(x:reflaxe.elixir.ast.ElixirAST) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(x, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ECall(_, func, args) if (func == "assign" && args != null && args.length == 2):
		makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.Component")), "assign", args), n.metadata, n.pos);	
	case ERemoteCall(mod, func, args) if (func == "assign" && args != null && args.length >= 2):
		makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.Component")), "assign", args), n.metadata, n.pos);	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var func = `;
								var args = `;
								if (func == "assign" && args != null && args.length == 2) {
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.Component"), metadata : {}, pos : pos};
									}, "assign", args), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								if (func == "assign" && args != null && args.length >= 2) {
									{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.Component"), metadata : {}, pos : pos};
									}, "assign", args), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body) if (isLiveModuleName(name)):
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(rewriteInside(b));
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock) if (isLiveModuleName(name)):
		var newDo = rewriteInside(doBlock);
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name != null && (StringTools.endsWith(name, "Live") || name.indexOf("Live", null) != -1)) {
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(rewriteInside(b));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name != null && (StringTools.endsWith(name, "Live") || name.indexOf("Live", null) != -1)) {
								var newDo = rewriteInside(doBlock);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function listPushRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args) if (func == "push" && args != null && args.length == 1):
		switch (mod.def) {
			case EVar(name) if (name != null && name.length > 0 && isLower(name)):
				var listVar = makeAST(EVar(name));
				var newRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [listVar, makeAST(EList([args[0]]))]));
				makeAST(EMatch(PVar(name), newRight));			
			default:
				n;			
		};	
	case ECall(target, func, args) if (func == "push" && target != null && args != null && args.length == 1):
		switch (target.def) {
			case EVar(name) if (name != null && name.length > 0 && isLower(name)):
				var listVar = makeAST(EVar(name));
				var newRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [listVar, makeAST(EList([args[0]]))]));
				makeAST(EMatch(PVar(name), newRight));			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							if (func == "push" && target != null && args != null && args.length == 1) {
								@:ast(switch (target.def) {
	case EVar(name) if (name != null && name.length > 0 && isLower(name)):
		var listVar = makeAST(EVar(name));
		var newRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [listVar, makeAST(EList([args[0]]))]));
		makeAST(EMatch(PVar(name), newRight));	
	default:
		n;	
}) {
									var ` = target.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											if (name != null && name.length > 0 && {
												var c = name.charAt(0);
												c.toLowerCase() == c;
											}) {
												var listVar = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
												};
												var newRight = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
													}, "concat", [listVar, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EList([args[0]]), metadata : {}, pos : pos};
													}]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), newRight), metadata : {}, pos : pos};
												};
											} else {
												n;
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var func = `;
							var args = `;
							if (func == "push" && args != null && args.length == 1) {
								@:ast(switch (mod.def) {
	case EVar(name) if (name != null && name.length > 0 && isLower(name)):
		var listVar = makeAST(EVar(name));
		var newRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [listVar, makeAST(EList([args[0]]))]));
		makeAST(EMatch(PVar(name), newRight));	
	default:
		n;	
}) {
									var ` = mod.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var name = `;
											if (name != null && name.length > 0 && {
												var c = name.charAt(0);
												c.toLowerCase() == c;
											}) {
												var listVar = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
												};
												var newRight = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
													}, "concat", [listVar, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EList([args[0]]), metadata : {}, pos : pos};
													}]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(name), newRight), metadata : {}, pos : pos};
												};
											} else {
												n;
											};
										};
									} else {
										n;
									};
								};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function repoQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var rewriteRepoRefs = function(subtree:reflaxe.elixir.ast.ElixirAST, repoName:String) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(subtree, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (m == "Repo"):
				makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);			
			case EVar(m) if (m != null && m.indexOf(".Repo") != -1):
				n;			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null):
		switch (target.def) {
			case EVar(m) if (m == "Repo"):
				makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);			
			default:
				n;			
		};	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								var func = `;
								var args = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (m == "Repo"):
		makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(repoName), metadata : {}, pos : pos};
													}, func, args), metadata : n.metadata, pos : n.pos};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (m == "Repo"):
		makeASTWithMeta(ERemoteCall(makeAST(EVar(repoName)), func, args), n.metadata, n.pos);	
	case EVar(m) if (m != null && m.indexOf(".Repo") != -1):
		n;	
	default:
		n;	
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar(repoName), metadata : {}, pos : pos};
													}, func, args), metadata : n.metadata, pos : n.pos};
												} else {
													var m = `;
													if (m != null && m.indexOf(".Repo", null) != -1) {
														n;
													} else {
														n;
													};
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var prefix = deriveAppPrefix(name);
		if (prefix == null && n.metadata != null && Reflect.hasField(n.metadata, "appName") && n.metadata.appName != null) {
			prefix = n.metadata.appName;
		};
		if (prefix == null) {
			try {
				prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			} catch(e:Dynamic) { };
		};
		if (prefix != null) {
			var repoName = prefix + ".Repo";
			var newBody:Array<ElixirAST> = [];
			for (b  in  body) newBody.push(rewriteRepoRefs(b, repoName));
			makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);
		} else {
			n;
		};	
	case EDefmodule(name, doBlock):
		var prefix = deriveAppPrefix(name);
		if (prefix == null && n.metadata != null && Reflect.hasField(n.metadata, "appName") && n.metadata.appName != null) {
			prefix = n.metadata.appName;
		};
		if (prefix == null) {
			try {
				prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			} catch(e:Dynamic) { };
			if (prefix == null) {
				try {
					var d = haxe.macro.Compiler.getDefine("app_name");
					if (d != null && d.length > 0) prefix = d;
				} catch(e:Dynamic) { };
			};
		};
		if (prefix != null) {
			var repoName = prefix + ".Repo";
			var newDo = rewriteRepoRefs(doBlock, repoName);
			makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
		} else {
			n;
		};	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null && n.metadata != null && Reflect.hasField(n.metadata, "appName") && n.metadata.appName != null) {
									prefix = n.metadata.appName;
								};
								if (prefix == null) {
									try {
										prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
								};
								if (prefix != null) {
									var repoName = prefix + ".Repo";
									var newBody = [];
									{
										var ` = 0;
										while (` < body.length) {
											var b = body[`];
											++ `;
											newBody.push(rewriteRepoRefs(b, repoName));
										};
									};
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null && n.metadata != null && Reflect.hasField(n.metadata, "appName") && n.metadata.appName != null) {
									prefix = n.metadata.appName;
								};
								if (prefix == null) {
									try {
										prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
									if (prefix == null) {
										try {
											var d = haxe.macro.Compiler.getDefine("app_name");
											if (d != null && d.length > 0) {
												prefix = d;
											};
										} catch (`:Dynamic) {
											{};
											{};
											if (true) {
												{};
												{};
											} else throw `;
										};
									};
								};
								if (prefix != null) {
									var repoName = prefix + ".Repo";
									var newDo = rewriteRepoRefs(doBlock, repoName);
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function moduleQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var definedModules = {
			{};
			new haxe.ds.StringMap();
		};
		var collectModules = [null];
		collectModules[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EModule(name, _, body):
		definedModules.set(name, true);
		for (b  in  body) collectModules(b);	
	case EDefmodule(name, doBlock):
		definedModules.set(name, true);
		collectModules(doBlock);	
	default:
		switch (n.def) {
			case EBlock(exprs):
				for (e  in  exprs) collectModules(e);			
			case EIf(c, t, e):
				collectModules(c);
				collectModules(t);
				if (e != null) collectModules(e);			
			case ECase(ex, cls):
				collectModules(ex);
				for (c  in  cls) {
					if (c.guard != null) collectModules(c.guard);
					collectModules(c.body);
				};			
			case EFn(cs):
				for (cl  in  cs) collectModules(cl.body);			
			case ECall(t, _, args):
				if (t != null) collectModules(t);
				if (args != null) for (a  in  args) collectModules(a);			
			case ERemoteCall(m, _, args):
				collectModules(m);
				if (args != null) for (a  in  args) collectModules(a);			
			default:
		};	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var body = `;
							{
								{
									definedModules.set(name, true);
								};
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										collectModules[0](b);
									};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								{
									definedModules.set(name, true);
								};
								collectModules[0](doBlock);
							};
						};
					};
					default: {
						@:ast(switch (n.def) {
	case EBlock(exprs):
		for (e  in  exprs) collectModules(e);	
	case EIf(c, t, e):
		collectModules(c);
		collectModules(t);
		if (e != null) collectModules(e);	
	case ECase(ex, cls):
		collectModules(ex);
		for (c  in  cls) {
			if (c.guard != null) collectModules(c.guard);
			collectModules(c.body);
		};	
	case EFn(cs):
		for (cl  in  cs) collectModules(cl.body);	
	case ECall(t, _, args):
		if (t != null) collectModules(t);
		if (args != null) for (a  in  args) collectModules(a);	
	case ERemoteCall(m, _, args):
		collectModules(m);
		if (args != null) for (a  in  args) collectModules(a);	
	default:
}) {
							var ` = n.def;
							switch (enumIndex `) {
								case 6: {
									var ` = `[0];
									var ` = `[1];
									{
										var ex = `;
										var cls = `;
										{
											collectModules[0](ex);
											{
												var ` = 0;
												while (` < cls.length) {
													var c = cls[`];
													++ `;
													if (c.guard != null) {
														collectModules[0](c.guard);
													};
													collectModules[0](c.body);
												};
											};
										};
									};
								};
								case 10: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var c = `;
										var t = `;
										var e = `;
										{
											collectModules[0](c);
											collectModules[0](t);
											if (e != null) {
												collectModules[0](e);
											};
										};
									};
								};
								case 22: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var t = `;
										var args = `;
										{
											if (t != null) {
												collectModules[0](t);
											};
											if (args != null) {
												{
													var ` = 0;
													while (` < args.length) {
														var a = args[`];
														++ `;
														collectModules[0](a);
													};
												};
											};
										};
									};
								};
								case 24: {
									var ` = `[0];
									var ` = `[1];
									var ` = `[2];
									{
										var m = `;
										var args = `;
										{
											collectModules[0](m);
											if (args != null) {
												{
													var ` = 0;
													while (` < args.length) {
														var a = args[`];
														++ `;
														collectModules[0](a);
													};
												};
											};
										};
									};
								};
								case 42: {
									var ` = `[0];
									{
										var cs = `;
										{
											{
												var ` = 0;
												while (` < cs.length) {
													var cl = cs[`];
													++ `;
													collectModules[0](cl.body);
												};
											};
										};
									};
								};
								case 53: {
									var ` = `[0];
									{
										var exprs = `;
										{
											{
												var ` = 0;
												while (` < exprs.length) {
													var e = exprs[`];
													++ `;
													collectModules[0](e);
												};
											};
										};
									};
								};
								default: {}
							};
						};
					}
				};
			};
		};
		collectModules[0](ast);
		{};
		{};
		{};
		{};
		var qualifyIn = function(subtree:reflaxe.elixir.ast.ElixirAST, appPrefix:String) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(subtree, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ECapture(expr, arity):
		switch (expr.def) {
			case ERemoteCall(mod, func, args):
				switch (mod.def) {
					case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
						if (m == "Presence" && appPrefix != null) {
							var fqP = appPrefix + "Web." + m;
							return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fqP)), func, args)), arity), n.metadata, n.pos);
						};
						if (m == "SafePubSub") {
							return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args)), arity), n.metadata, n.pos);
						};
						if (appPrefix != null) {
							var fq = appPrefix + "." + m;
							return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fq)), func, args)), arity), n.metadata, n.pos);
						} else n;					
					default:
						n;					
				};			
			default:
				n;			
		};	
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (m == "Presence" && appPrefix != null) {
					var fqP = appPrefix + "Web." + m;
					return makeASTWithMeta(ERemoteCall(makeAST(EVar(fqP)), func, args), n.metadata, n.pos);
				};
				if (m == "SafePubSub") {
					return makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args), n.metadata, n.pos);
				};
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					return makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null):
		switch (target.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (m == "Presence" && appPrefix != null) {
					var fqP = appPrefix + "Web." + m;
					return makeASTWithMeta(ERemoteCall(makeAST(EVar(fqP)), func, args), n.metadata, n.pos);
				};
				if (m == "SafePubSub") {
					return makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args), n.metadata, n.pos);
				};
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					return makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								var func = `;
								var args = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (m == "Presence" && appPrefix != null) {
			var fqP = appPrefix + "Web." + m;
			return makeASTWithMeta(ERemoteCall(makeAST(EVar(fqP)), func, args), n.metadata, n.pos);
		};
		if (m == "SafePubSub") {
			return makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args), n.metadata, n.pos);
		};
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			return makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (m == "Presence" && appPrefix != null) {
														var fqP = appPrefix + "Web." + m;
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fqP), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													};
													if (m == "SafePubSub") {
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.SafePubSub"), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													};
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (m == "Presence" && appPrefix != null) {
			var fqP = appPrefix + "Web." + m;
			return makeASTWithMeta(ERemoteCall(makeAST(EVar(fqP)), func, args), n.metadata, n.pos);
		};
		if (m == "SafePubSub") {
			return makeASTWithMeta(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args), n.metadata, n.pos);
		};
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			return makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (m == "Presence" && appPrefix != null) {
														var fqP = appPrefix + "Web." + m;
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fqP), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													};
													if (m == "SafePubSub") {
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.SafePubSub"), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													};
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						case 43: {
							var ` = `[0];
							var ` = `[1];
							{
								var expr = `;
								var arity = `;
								{
									@:ast(switch (expr.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (m == "Presence" && appPrefix != null) {
					var fqP = appPrefix + "Web." + m;
					return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fqP)), func, args)), arity), n.metadata, n.pos);
				};
				if (m == "SafePubSub") {
					return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args)), arity), n.metadata, n.pos);
				};
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fq)), func, args)), arity), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
										var ` = expr.def;
										if (enumIndex ` == 24) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var mod = `;
												var func = `;
												var args = `;
												{
													@:ast(switch (mod.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (m == "Presence" && appPrefix != null) {
			var fqP = appPrefix + "Web." + m;
			return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fqP)), func, args)), arity), n.metadata, n.pos);
		};
		if (m == "SafePubSub") {
			return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar("Phoenix.SafePubSub")), func, args)), arity), n.metadata, n.pos);
		};
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			return makeASTWithMeta(ECapture(makeAST(ERemoteCall(makeAST(EVar(fq)), func, args)), arity), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
														var ` = mod.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var m = `;
																if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
																	var c = m.charAt(0);
																	c.toUpperCase() == c && c.toLowerCase() != c;
																} && ! m != null && {
																	var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
																	cast this.exists(m);
																}) {
																	if (m == "Presence" && appPrefix != null) {
																		var fqP = appPrefix + "Web." + m;
																		return {def : reflaxe.elixir.ast.ElixirASTDef.ECapture({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fqP), metadata : {}, pos : pos};
																			}, func, args), metadata : {}, pos : pos};
																		}, arity), metadata : n.metadata, pos : n.pos};
																	};
																	if (m == "SafePubSub") {
																		return {def : reflaxe.elixir.ast.ElixirASTDef.ECapture({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Phoenix.SafePubSub"), metadata : {}, pos : pos};
																			}, func, args), metadata : {}, pos : pos};
																		}, arity), metadata : n.metadata, pos : n.pos};
																	};
																	if (appPrefix != null) {
																		var fq = appPrefix + "." + m;
																		return {def : reflaxe.elixir.ast.ElixirASTDef.ECapture({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
																			}, func, args), metadata : {}, pos : pos};
																		}, arity), metadata : n.metadata, pos : n.pos};
																	} else {
																		n;
																	};
																} else {
																	n;
																};
															};
														} else {
															n;
														};
													};
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) {
			n;
		} else {
			var newBody:Array<ElixirAST> = [];
			for (b  in  body) newBody.push(qualifyIn(b, prefix));
			makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);
		};	
	case EDefmodule(name, doBlock):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) {
			n;
		} else {
			var newDo = qualifyIn(doBlock, prefix);
			makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
		};	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									n;
								} else {
									var newBody = [];
									{
										var ` = 0;
										while (` < body.length) {
											var b = body[`];
											++ `;
											newBody.push(qualifyIn(b, prefix));
										};
									};
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									n;
								} else {
									var newDo = qualifyIn(doBlock, prefix);
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function webEFnModuleQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		{};
		var qualifySubtree = function(sub:reflaxe.elixir.ast.ElixirAST, appPrefix:String) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(sub, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null):
		switch (target.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								var func = `;
								var args = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body) if (name.indexOf("Web") != -1):
		var prefix = deriveAppPrefix(name);
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(qualifySubtree(b, prefix));
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock) if (name.indexOf("Web") != -1):
		var prefix2 = deriveAppPrefix(name);
		var newDo = qualifySubtree(doBlock, prefix2);
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name.indexOf("Web", null) != -1) {
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(qualifySubtree(b, prefix));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name.indexOf("Web", null) != -1) {
								var prefix2 = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newDo = qualifySubtree(doBlock, prefix2);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function webReduceWhileEFnQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		{};
		var qualifyFnBody = function(fnAst:reflaxe.elixir.ast.ElixirAST, appPrefix:String) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(fnAst, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	case ECall(target, func, args) if (target != null):
		switch (target.def) {
			case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
				if (appPrefix != null) {
					var fq = appPrefix + "." + m;
					makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
				} else n;			
			default:
				n;			
		};	
	default:
		n;	
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								var func = `;
								var args = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								var func = `;
								var args = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (isSingleSegmentModule(m) && isUpperCamel(m) && !isGlobalWhitelisted(m)):
		if (appPrefix != null) {
			var fq = appPrefix + "." + m;
			makeASTWithMeta(ERemoteCall(makeAST(EVar(fq)), func, args), n.metadata, n.pos);
		} else n;	
	default:
		n;	
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m != null && m.indexOf(".", null) == -1 && m.length > 0 && {
													var c = m.charAt(0);
													c.toUpperCase() == c && c.toLowerCase() != c;
												} && ! m != null && {
													var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
													cast this.exists(m);
												}) {
													if (appPrefix != null) {
														var fq = appPrefix + "." + m;
														{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EVar(fq), metadata : {}, pos : pos};
														}, func, args), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(name, attrs, body) if (name.indexOf("Web") != -1):
		var app = deriveAppPrefix(name);
		var newBody = [];
		for (b  in  body) newBody.push(ElixirASTTransformer.transformNode(b, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ERemoteCall(mod, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
					var isEnum = switch (mod.def) {
						case EVar(m) if (m == "Enum"):
							true;						
						default:
							false;						
					};
					if (isEnum) {
						var a = args.copy();
						a[2] = qualifyFnBody(a[2], app);
						makeASTWithMeta(ERemoteCall(mod, func, a), n.metadata, n.pos);
					} else n;				
				case ECall(target, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
					var copiedArgs = args.copy();
					copiedArgs[2] = qualifyFnBody(copiedArgs[2], app);
					makeASTWithMeta(ECall(target, func, copiedArgs), n.metadata, n.pos);				
				default:
					n;				
			};
		}));
		makeASTWithMeta(EModule(name, attrs, newBody), node.metadata, node.pos);	
	case EDefmodule(name, doBlock) if (name.indexOf("Web") != -1):
		var appPrefix = deriveAppPrefix(name);
		var newDo = ElixirASTTransformer.transformNode(doBlock, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ERemoteCall(mod, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
					var isEnumModule = switch (mod.def) {
						case EVar(m) if (m == "Enum"):
							true;						
						default:
							false;						
					};
					if (isEnumModule) {
						var copiedArgs = args.copy();
						copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
						makeASTWithMeta(ERemoteCall(mod, func, copiedArgs), n.metadata, n.pos);
					} else n;				
				case ECall(target, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
					var copiedArgs = args.copy();
					copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
					makeASTWithMeta(ECall(target, func, copiedArgs), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefmodule(name, newDo), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name.indexOf("Web", null) != -1) {
								var app = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(n:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
		var isEnum = switch (mod.def) {
			case EVar(m) if (m == "Enum"):
				true;			
			default:
				false;			
		};
		if (isEnum) {
			var a = args.copy();
			a[2] = qualifyFnBody(a[2], app);
			makeASTWithMeta(ERemoteCall(mod, func, a), n.metadata, n.pos);
		} else n;	
	case ECall(target, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
		var copiedArgs = args.copy();
		copiedArgs[2] = qualifyFnBody(copiedArgs[2], app);
		makeASTWithMeta(ECall(target, func, copiedArgs), n.metadata, n.pos);	
	default:
		n;	
}) {
												var ` = n.def;
												switch (enumIndex `) {
													case 22: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var target = `;
															var func = `;
															var args = `;
															if (func == "reduce_while" && args != null && args.length >= 3) {
																var copiedArgs = args.copy();
																copiedArgs[2] = qualifyFnBody(copiedArgs[2], app);
																{def : reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, copiedArgs), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													};
													case 24: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var mod = `;
															var func = `;
															var args = `;
															if (func == "reduce_while" && args != null && args.length >= 3) {
																var isEnum = @:ast(switch (mod.def) {
	case EVar(m) if (m == "Enum"):
		true;	
	default:
		false;	
}) {
																	var ` = mod.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var m = `;
																			if (m == "Enum") {
																				true;
																			} else {
																				false;
																			};
																		};
																	} else {
																		false;
																	};
																};
																if (isEnum) {
																	var a = args.copy();
																	a[2] = qualifyFnBody(a[2], app);
																	{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, a), metadata : n.metadata, pos : n.pos};
																} else {
																	n;
																};
															} else {
																n;
															};
														};
													};
													default: {
														n;
													}
												};
											};
										}));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name.indexOf("Web", null) != -1) {
								var appPrefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
		var isEnumModule = switch (mod.def) {
			case EVar(m) if (m == "Enum"):
				true;			
			default:
				false;			
		};
		if (isEnumModule) {
			var copiedArgs = args.copy();
			copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
			makeASTWithMeta(ERemoteCall(mod, func, copiedArgs), n.metadata, n.pos);
		} else n;	
	case ECall(target, func, args) if (func == "reduce_while" && args != null && args.length >= 3):
		var copiedArgs = args.copy();
		copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
		makeASTWithMeta(ECall(target, func, copiedArgs), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										switch (enumIndex `) {
											case 22: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var target = `;
													var func = `;
													var args = `;
													if (func == "reduce_while" && args != null && args.length >= 3) {
														var copiedArgs = args.copy();
														copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
														{def : reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, copiedArgs), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var mod = `;
													var func = `;
													var args = `;
													if (func == "reduce_while" && args != null && args.length >= 3) {
														var isEnumModule = @:ast(switch (mod.def) {
	case EVar(m) if (m == "Enum"):
		true;	
	default:
		false;	
}) {
															var ` = mod.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var m = `;
																	if (m == "Enum") {
																		true;
																	} else {
																		false;
																	};
																};
															} else {
																false;
															};
														};
														if (isEnumModule) {
															var copiedArgs = args.copy();
															copiedArgs[2] = qualifyFnBody(copiedArgs[2], appPrefix);
															{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod, func, copiedArgs), metadata : n.metadata, pos : n.pos};
														} else {
															n;
														};
													} else {
														n;
													};
												};
											};
											default: {
												n;
											}
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function erawWebModuleQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var qualify = function(code:String, app:String) {
			var out = new StringBuf();
			var i = 0;
			while (i < code.length) {
				var ch = code.charAt(i);
				var prev = if (i > 0) {
					code.charAt(i - 1);
				} else {
					"";
				};
				var isPrevIdent = new EReg("^[A-Za-z0-9_]$", "").match(prev);
				if (! isPrevIdent && ch.toUpperCase() == ch && ch.toLowerCase() != ch) {
					var j = i;
					var name = new StringBuf();
					while (j < code.length) {
						var c = code.charAt(j);
						if (! new EReg("^[A-Za-z0-9_]$", "").match(c)) {
							break;
						};
						name.add(c);
						j ++;
					};
					var token = name.toString();
					if (j < code.length && code.charAt(j) == ".") {
						if (! token != null && {
							var this = reflaxe.elixir.ast.StdModuleWhitelist.ROOTS;
							cast this.exists(token);
						} && app != null && app.length > 0) {
							out.add(app);
							out.add(".");
						};
						out.add(token);
						i = j;
						continue;
					};
				};
				out.add(ch);
				i ++;
			};
			return out.toString();
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body) if (name.indexOf("Web") != -1):
		var app = name.substring(0, name.indexOf("Web"));
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(ElixirASTTransformer.transformNode(b, function(x) {
			return switch (x.def) {
				case ERaw(code):
					var q = qualify(code, app);
					q != code ? makeASTWithMeta(ERaw(q), x.metadata, x.pos) : x;				
				default:
					x;				
			};
		}));
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock) if (name.indexOf("Web") != -1):
		var app2 = name.substring(0, name.indexOf("Web"));
		var newDo = ElixirASTTransformer.transformNode(doBlock, function(x) {
			return switch (x.def) {
				case ERaw(code):
					var q = qualify(code, app2);
					q != code ? makeASTWithMeta(ERaw(q), x.metadata, x.pos) : x;				
				default:
					x;				
			};
		});
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name.indexOf("Web", null) != -1) {
								var app = name.substring(0, name.indexOf("Web", null));
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(x:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (x.def) {
	case ERaw(code):
		var q = qualify(code, app);
		q != code ? makeASTWithMeta(ERaw(q), x.metadata, x.pos) : x;	
	default:
		x;	
}) {
												var ` = x.def;
												if (enumIndex ` == 62) {
													var ` = `[0];
													{
														var code = `;
														{
															var q = qualify(code, app);
															if (q != code) {
																{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(q), metadata : x.metadata, pos : x.pos};
															} else {
																x;
															};
														};
													};
												} else {
													x;
												};
											};
										}));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name.indexOf("Web", null) != -1) {
								var app2 = name.substring(0, name.indexOf("Web", null));
								var newDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(x:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (x.def) {
	case ERaw(code):
		var q = qualify(code, app2);
		q != code ? makeASTWithMeta(ERaw(q), x.metadata, x.pos) : x;	
	default:
		x;	
}) {
										var ` = x.def;
										if (enumIndex ` == 62) {
											var ` = `[0];
											{
												var code = `;
												{
													var q = qualify(code, app2);
													if (q != code) {
														{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(q), metadata : x.metadata, pos : x.pos};
													} else {
														x;
													};
												};
											};
										} else {
											x;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function selfAssignCompressionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EMatch(PVar(v1), { def : EMatch(PVar(v2), expr) }) if (v1 == v2):
		makeASTWithMeta(EMatch(PVar(v1), expr), n.metadata, n.pos);	
	case EMatch(PVar(v1), { def : EBinary(Match, { def : EVar(v2) }, expr) }) if (v1 == v2):
		makeASTWithMeta(EMatch(PVar(v1), expr), n.metadata, n.pos);	
	case EMatch(PVar(v1), { def : EParen({ def : EMatch(PVar(v2), expr2) }) }) if (v1 == v2):
		makeASTWithMeta(EMatch(PVar(v1), expr2), n.metadata, n.pos);	
	case EMatch(PVar(v1), { def : EParen({ def : EBinary(Match, { def : EVar(v2p) }, expr2p) }) }) if (v1 == v2p):
		makeASTWithMeta(EMatch(PVar(v1), expr2p), n.metadata, n.pos);	
	case EMatch(PVar(v1), { def : EBlock(es) }) if (es.length == 1):
		switch (es[0].def) {
			case EMatch(PVar(v2), expr3) if (v1 == v2):
				makeASTWithMeta(EMatch(PVar(v1), expr3), n.metadata, n.pos);			
			default:
				n;			
		};	
	case EMatch(PVar(v1), { def : EBlock(esb) }) if (esb.length == 1):
		switch (esb[0].def) {
			case EBinary(Match, { def : EVar(v2b) }, expr3b) if (v1 == v2b):
				makeASTWithMeta(EMatch(PVar(v1), expr3b), n.metadata, n.pos);			
			default:
				n;			
		};	
	case EBinary(Match, left, { def : EBinary(Match, left2, expr2) }):
		var l1 = switch (left.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		var l2 = switch (left2.def) {
			case EVar(nm2):
				nm2;			
			default:
				null;			
		};
		if (l1 != null && l1 == l2) makeASTWithMeta(EBinary(Match, left, expr2), n.metadata, n.pos) else n;	
	case EBinary(Match, { def : EVar(vOut) }, { def : EMatch(PVar(vIn), exprR) }) if (vOut == vIn):
		makeASTWithMeta(EBinary(Match, makeAST(EVar(vOut)), exprR), n.metadata, n.pos);	
	case EBinary(Match, left, { def : EParen({ def : EBinary(Match, left2b, expr2b) }) }):
		var l1b = switch (left.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		var l2b = switch (left2b.def) {
			case EVar(nm2):
				nm2;			
			default:
				null;			
		};
		if (l1b != null && l1b == l2b) makeASTWithMeta(EBinary(Match, left, expr2b), n.metadata, n.pos) else n;	
	case EBinary(Match, left, { def : EBlock(es2) }) if (es2.length == 1):
		var lhsName = switch (left.def) {
			case EVar(nm):
				nm;			
			default:
				null;			
		};
		if (lhsName != null) {
			switch (es2[0].def) {
				case EBinary(Match, leftInner, exprInner):
					var lInner = switch (leftInner.def) {
						case EVar(nm3):
							nm3;						
						default:
							null;						
					};
					if (lInner != null && lInner == lhsName) makeASTWithMeta(EBinary(Match, left, exprInner), n.metadata, n.pos) else n;				
				default:
					n;				
			};
		} else n;	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								switch (enumIndex `) {
									case 8: {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var v2 = `;
												var expr = `;
												var v1 = `;
												if (v1 == v2) {
													{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr), metadata : n.metadata, pos : n.pos};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 27) {
											{
												var ` = `.def;
												var ` = `.metadata;
												var ` = `.pos;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var v2 = `;
														var expr = `;
														var v1 = `;
														if (v1 == v2) {
															{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr), metadata : n.metadata, pos : n.pos};
														} else {
															n;
														};
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
									case 53: {
										var ` = `[0];
										{
											var es = `;
											var v1 = `;
											if (es.length == 1) {
												@:ast(switch (es[0].def) {
	case EMatch(PVar(v2), expr3) if (v1 == v2):
		makeASTWithMeta(EMatch(PVar(v1), expr3), n.metadata, n.pos);	
	default:
		n;	
}) {
													var ` = es[0].def;
													if (enumIndex ` == 8) {
														var ` = `[0];
														var ` = `[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															{
																var v2 = `;
																var expr3 = `;
																if (v1 == v2) {
																	{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr3), metadata : n.metadata, pos : n.pos};
																} else {
																	n;
																};
															};
														} else {
															n;
														};
													} else {
														n;
													};
												};
											} else {
												var esb = `;
												var v1 = `;
												if (esb.length == 1) {
													@:ast(switch (esb[0].def) {
	case EBinary(Match, { def : EVar(v2b) }, expr3b) if (v1 == v2b):
		makeASTWithMeta(EMatch(PVar(v1), expr3b), n.metadata, n.pos);	
	default:
		n;	
}) {
														var ` = esb[0].def;
														if (enumIndex ` == 26) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 27) {
																{
																	var ` = `.def;
																	var ` = `.metadata;
																	var ` = `.pos;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var v2b = `;
																			var expr3b = `;
																			if (v1 == v2b) {
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr3b), metadata : n.metadata, pos : n.pos};
																			} else {
																				n;
																			};
																		};
																	} else {
																		n;
																	};
																};
															} else {
																n;
															};
														} else {
															n;
														};
													};
												} else {
													n;
												};
											};
										};
									};
									case 54: {
										var ` = `[0];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											switch (enumIndex `) {
												case 8: {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														{
															var v2 = `;
															var expr2 = `;
															var v1 = `;
															if (v1 == v2) {
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr2), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													} else {
														n;
													};
												};
												case 26: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													if (enumIndex ` == 27) {
														{
															var ` = `.def;
															var ` = `.metadata;
															var ` = `.pos;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var v2p = `;
																	var expr2p = `;
																	var v1 = `;
																	if (v1 == v2p) {
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v1), expr2p), metadata : n.metadata, pos : n.pos};
																	} else {
																		n;
																	};
																};
															} else {
																n;
															};
														};
													} else {
														n;
													};
												};
												default: {
													n;
												}
											};
										};
									};
									default: {
										n;
									}
								};
							};
						} else {
							n;
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (enumIndex ` == 27) {
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								switch (enumIndex `) {
									case 8: {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var ` = `.def;
												var ` = `.metadata;
												var ` = `.pos;
												if (enumIndex ` == 38) {
													var ` = `[0];
													{
														var vOut = `;
														var exprR = `;
														var vIn = `;
														if (vOut == vIn) {
															{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar(vOut), metadata : {}, pos : pos};
															}, exprR), metadata : n.metadata, pos : n.pos};
														} else {
															n;
														};
													};
												} else {
													n;
												};
											};
										} else {
											n;
										};
									};
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 27) {
											{
												var left2 = `;
												var expr2 = `;
												var left = `;
												{
													var l1 = @:ast(switch (left.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
														var ` = left.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var nm = `;
																{
																	nm;
																};
															};
														} else {
															null;
														};
													};
													var l2 = @:ast(switch (left2.def) {
	case EVar(nm2):
		nm2;	
	default:
		null;	
}) {
														var ` = left2.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var nm2 = `;
																{
																	nm2;
																};
															};
														} else {
															null;
														};
													};
													if (l1 != null && l1 == l2) {
														{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, left, expr2), metadata : n.metadata, pos : n.pos};
													} else {
														n;
													};
												};
											};
										} else {
											n;
										};
									};
									case 53: {
										var ` = `[0];
										{
											var es2 = `;
											var left = `;
											if (es2.length == 1) {
												var lhsName = @:ast(switch (left.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
													var ` = left.def;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var nm = `;
															{
																nm;
															};
														};
													} else {
														null;
													};
												};
												if (lhsName != null) {
													@:ast(switch (es2[0].def) {
	case EBinary(Match, leftInner, exprInner):
		var lInner = switch (leftInner.def) {
			case EVar(nm3):
				nm3;			
			default:
				null;			
		};
		if (lInner != null && lInner == lhsName) makeASTWithMeta(EBinary(Match, left, exprInner), n.metadata, n.pos) else n;	
	default:
		n;	
}) {
														var ` = es2[0].def;
														if (enumIndex ` == 26) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 27) {
																{
																	var leftInner = `;
																	var exprInner = `;
																	{
																		var lInner = @:ast(switch (leftInner.def) {
	case EVar(nm3):
		nm3;	
	default:
		null;	
}) {
																			var ` = leftInner.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					var nm3 = `;
																					{
																						nm3;
																					};
																				};
																			} else {
																				null;
																			};
																		};
																		if (lInner != null && lInner == lhsName) {
																			{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, left, exprInner), metadata : n.metadata, pos : n.pos};
																		} else {
																			n;
																		};
																	};
																};
															} else {
																n;
															};
														} else {
															n;
														};
													};
												} else {
													n;
												};
											} else {
												n;
											};
										};
									};
									case 54: {
										var ` = `[0];
										{
											var ` = `.def;
											var ` = `.metadata;
											var ` = `.pos;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left2b = `;
														var expr2b = `;
														var left = `;
														{
															var l1b = @:ast(switch (left.def) {
	case EVar(nm):
		nm;	
	default:
		null;	
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var nm = `;
																		{
																			nm;
																		};
																	};
																} else {
																	null;
																};
															};
															var l2b = @:ast(switch (left2b.def) {
	case EVar(nm2):
		nm2;	
	default:
		null;	
}) {
																var ` = left2b.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var nm2 = `;
																		{
																			nm2;
																		};
																	};
																} else {
																	null;
																};
															};
															if (l1b != null && l1b == l2b) {
																{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, left, expr2b), metadata : n.metadata, pos : n.pos};
															} else {
																n;
															};
														};
													};
												} else {
													n;
												};
											} else {
												n;
											};
										};
									};
									default: {
										n;
									}
								};
							};
						} else {
							n;
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function simplifyProvableIsNilFalsePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		var processBlock = [null];
		processBlock[0] = function(block:reflaxe.elixir.ast.ElixirAST, incoming:Map<String, Bool>) {
			return @:ast(switch (block.def) {
	case EBlock(stmts):
		var nonNil = new Map<String,Bool>();
		for (k  in  incoming.keys()) nonNil.set(k, true);
		var out:Array<ElixirAST> = [];
		for (stmt  in  stmts) {
			var s = stmt;
			s = ElixirASTTransformer.transformNode(s, function(n:ElixirAST):ElixirAST {
				return rewriteIsNilIfProvablyFalse(n, nonNil);
			});
			switch (s.def) {
				case EIf(cond, thenB, elseB):
					var newCond = rewriteIsNilIfProvablyFalse(cond, nonNil);
					var newThen = processBlock(thenB, nonNil);
					var newElse = elseB != null ? processBlock(elseB, nonNil) : null;
					s = makeASTWithMeta(EIf(newCond, newThen, newElse), s.metadata, s.pos);				
				case ECase(expr, clauses):
					var newExpr = rewriteIsNilIfProvablyFalse(expr, nonNil);
					var newClauses = [];
					for (c  in  clauses) {
						var bodyProcessed = processBlock(c.body, nonNil);
						newClauses.push({ pattern : c.pattern, guard : c.guard, body : bodyProcessed });
					};
					s = makeASTWithMeta(ECase(newExpr, newClauses), s.metadata, s.pos);				
				default:
			};
			switch (s.def) {
				case EMatch(PVar(name), rhs):
					if (isDefinitelyNonNilLiteral(rhs)) {
						nonNil.set(name, true);
					} else {
						nonNil.remove(name);
					};				
				case EBinary(Match, left, rhs):
					switch (left.def) {
						case EVar(name2):
							if (isDefinitelyNonNilLiteral(rhs)) {
								nonNil.set(name2, true);
							} else {
								nonNil.remove(name2);
							};						
						default:
					};				
				default:
			};
			out.push(s);
		};
		makeASTWithMeta(EBlock(out), block.metadata, block.pos);	
	default:
		ElixirASTTransformer.transformNode(block, function(n) return n);	
}) {
				var ` = block.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							var nonNil = {
								{};
								new haxe.ds.StringMap();
							};
							for (k in incoming.keys()) {
								{
									nonNil.set(k, true);
								};
							};
							var out = [];
							{
								var ` = 0;
								while (` < stmts.length) {
									var stmt = stmts[`];
									++ `;
									var s = stmt;
									s = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(s, function(n:reflaxe.elixir.ast.ElixirAST) {
										return @:ast(switch (expr.def) {
	case ERemoteCall(mod, func, args) if (func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (mod.def) {
			case EVar(m) if (m == "Kernel"):
				switch (args[0].def) {
					case EVar(v) if (nonNil.exists(v)):
						makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);					
					default:
						expr;					
				};			
			default:
				expr;			
		};	
	case ECall(target, func, args) if (target == null && func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
											var ` = n.def;
											switch (enumIndex `) {
												case 22: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var target = `;
														var func = `;
														var args = `;
														if (target == null && func == "is_nil" && args != null && args.length == 1) {
															if (n.metadata != null && n.metadata.ectoPinnedNilGuard == true) {
																n;
															} else {
																@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																	var ` = args[0].def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var v = `;
																			if (nonNil.exists(v)) {
																				{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : n.metadata, pos : n.pos};
																			} else {
																				n;
																			};
																		};
																	} else {
																		n;
																	};
																};
															};
														} else {
															n;
														};
													};
												};
												case 24: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var mod = `;
														var func = `;
														var args = `;
														if (func == "is_nil" && args != null && args.length == 1) {
															if (n.metadata != null && n.metadata.ectoPinnedNilGuard == true) {
																n;
															} else {
																@:ast(switch (mod.def) {
	case EVar(m) if (m == "Kernel"):
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
																	var ` = mod.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var m = `;
																			if (m == "Kernel") {
																				@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																					var ` = args[0].def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v = `;
																							if (nonNil.exists(v)) {
																								{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : n.metadata, pos : n.pos};
																							} else {
																								n;
																							};
																						};
																					} else {
																						n;
																					};
																				};
																			} else {
																				n;
																			};
																		};
																	} else {
																		n;
																	};
																};
															};
														} else {
															n;
														};
													};
												};
												default: {
													n;
												}
											};
										};
									});
									@:ast(switch (s.def) {
	case EIf(cond, thenB, elseB):
		var newCond = rewriteIsNilIfProvablyFalse(cond, nonNil);
		var newThen = processBlock(thenB, nonNil);
		var newElse = elseB != null ? processBlock(elseB, nonNil) : null;
		s = makeASTWithMeta(EIf(newCond, newThen, newElse), s.metadata, s.pos);	
	case ECase(expr, clauses):
		var newExpr = rewriteIsNilIfProvablyFalse(expr, nonNil);
		var newClauses = [];
		for (c  in  clauses) {
			var bodyProcessed = processBlock(c.body, nonNil);
			newClauses.push({ pattern : c.pattern, guard : c.guard, body : bodyProcessed });
		};
		s = makeASTWithMeta(ECase(newExpr, newClauses), s.metadata, s.pos);	
	default:
}) {
										var ` = s.def;
										switch (enumIndex `) {
											case 6: {
												var ` = `[0];
												var ` = `[1];
												{
													var expr = `;
													var clauses = `;
													{
														var newExpr = @:ast(switch (expr.def) {
	case ERemoteCall(mod, func, args) if (func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (mod.def) {
			case EVar(m) if (m == "Kernel"):
				switch (args[0].def) {
					case EVar(v) if (nonNil.exists(v)):
						makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);					
					default:
						expr;					
				};			
			default:
				expr;			
		};	
	case ECall(target, func, args) if (target == null && func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
															var ` = expr.def;
															switch (enumIndex `) {
																case 22: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var target = `;
																		var func = `;
																		var args = `;
																		if (target == null && func == "is_nil" && args != null && args.length == 1) {
																			if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) {
																				expr;
																			} else {
																				@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																					var ` = args[0].def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v = `;
																							if (nonNil.exists(v)) {
																								{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : expr.metadata, pos : expr.pos};
																							} else {
																								expr;
																							};
																						};
																					} else {
																						expr;
																					};
																				};
																			};
																		} else {
																			expr;
																		};
																	};
																};
																case 24: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var func = `;
																		var args = `;
																		if (func == "is_nil" && args != null && args.length == 1) {
																			if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) {
																				expr;
																			} else {
																				@:ast(switch (mod.def) {
	case EVar(m) if (m == "Kernel"):
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
																					var ` = mod.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var m = `;
																							if (m == "Kernel") {
																								@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																									var ` = args[0].def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										{
																											var v = `;
																											if (nonNil.exists(v)) {
																												{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : expr.metadata, pos : expr.pos};
																											} else {
																												expr;
																											};
																										};
																									} else {
																										expr;
																									};
																								};
																							} else {
																								expr;
																							};
																						};
																					} else {
																						expr;
																					};
																				};
																			};
																		} else {
																			expr;
																		};
																	};
																};
																default: {
																	expr;
																}
															};
														};
														var newClauses = [];
														{
															var ` = 0;
															while (` < clauses.length) {
																var c = clauses[`];
																++ `;
																var bodyProcessed = processBlock[0](c.body, nonNil);
																newClauses.push({pattern : c.pattern, guard : c.guard, body : bodyProcessed});
															};
														};
														s = {def : reflaxe.elixir.ast.ElixirASTDef.ECase(newExpr, newClauses), metadata : s.metadata, pos : s.pos};
													};
												};
											};
											case 10: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var cond = `;
													var thenB = `;
													var elseB = `;
													{
														var newCond = @:ast(switch (expr.def) {
	case ERemoteCall(mod, func, args) if (func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (mod.def) {
			case EVar(m) if (m == "Kernel"):
				switch (args[0].def) {
					case EVar(v) if (nonNil.exists(v)):
						makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);					
					default:
						expr;					
				};			
			default:
				expr;			
		};	
	case ECall(target, func, args) if (target == null && func == "is_nil" && args != null && args.length == 1):
		if (expr.metadata != null && expr.metadata.ectoPinnedNilGuard == true) return expr;
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
															var ` = cond.def;
															switch (enumIndex `) {
																case 22: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var target = `;
																		var func = `;
																		var args = `;
																		if (target == null && func == "is_nil" && args != null && args.length == 1) {
																			if (cond.metadata != null && cond.metadata.ectoPinnedNilGuard == true) {
																				cond;
																			} else {
																				@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																					var ` = args[0].def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var v = `;
																							if (nonNil.exists(v)) {
																								{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : cond.metadata, pos : cond.pos};
																							} else {
																								cond;
																							};
																						};
																					} else {
																						cond;
																					};
																				};
																			};
																		} else {
																			cond;
																		};
																	};
																};
																case 24: {
																	var ` = `[0];
																	var ` = `[1];
																	var ` = `[2];
																	{
																		var mod = `;
																		var func = `;
																		var args = `;
																		if (func == "is_nil" && args != null && args.length == 1) {
																			if (cond.metadata != null && cond.metadata.ectoPinnedNilGuard == true) {
																				cond;
																			} else {
																				@:ast(switch (mod.def) {
	case EVar(m) if (m == "Kernel"):
		switch (args[0].def) {
			case EVar(v) if (nonNil.exists(v)):
				makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);			
			default:
				expr;			
		};	
	default:
		expr;	
}) {
																					var ` = mod.def;
																					if (enumIndex ` == 38) {
																						var ` = `[0];
																						{
																							var m = `;
																							if (m == "Kernel") {
																								@:ast(switch (args[0].def) {
	case EVar(v) if (nonNil.exists(v)):
		makeASTWithMeta(EBoolean(false), expr.metadata, expr.pos);	
	default:
		expr;	
}) {
																									var ` = args[0].def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										{
																											var v = `;
																											if (nonNil.exists(v)) {
																												{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(false), metadata : cond.metadata, pos : cond.pos};
																											} else {
																												cond;
																											};
																										};
																									} else {
																										cond;
																									};
																								};
																							} else {
																								cond;
																							};
																						};
																					} else {
																						cond;
																					};
																				};
																			};
																		} else {
																			cond;
																		};
																	};
																};
																default: {
																	cond;
																}
															};
														};
														var newThen = processBlock[0](thenB, nonNil);
														var newElse = if (elseB != null) {
															processBlock[0](elseB, nonNil);
														} else {
															null;
														};
														s = {def : reflaxe.elixir.ast.ElixirASTDef.EIf(newCond, newThen, newElse), metadata : s.metadata, pos : s.pos};
													};
												};
											};
											default: {}
										};
									};
									@:ast(switch (s.def) {
	case EMatch(PVar(name), rhs):
		if (isDefinitelyNonNilLiteral(rhs)) {
			nonNil.set(name, true);
		} else {
			nonNil.remove(name);
		};	
	case EBinary(Match, left, rhs):
		switch (left.def) {
			case EVar(name2):
				if (isDefinitelyNonNilLiteral(rhs)) {
					nonNil.set(name2, true);
				} else {
					nonNil.remove(name2);
				};			
			default:
		};	
	default:
}) {
										var ` = s.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												if (enumIndex ` == 0) {
													var ` = `[0];
													{
														var name = `;
														var rhs = `;
														{
															if (@:ast(switch (e.def) {
	case EString(_):
		true;	
	case EInteger(_):
		true;	
	case EFloat(_):
		true;	
	case EBoolean(_):
		true;	
	case EList(_):
		true;	
	case EMap(_):
		true;	
	case ETuple(_):
		true;	
	case EAtom(atom) if (atom != "nil"):
		true;	
	default:
		false;	
}) {
																var ` = rhs.def;
																switch (enumIndex `) {
																	case 15: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 16: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 17: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 31: {
																		var ` = `[0];
																		{
																			var atom = `;
																			if (atom != "nil") {
																				true;
																			} else {
																				false;
																			};
																		};
																	};
																	case 32: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 33: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 34: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	case 35: {
																		var ` = `[0];
																		{
																			true;
																		};
																	};
																	default: {
																		false;
																	}
																};
															}) {
																{
																	nonNil.set(name, true);
																};
															} else {
																nonNil.remove(name);
															};
														};
													};
												} else {};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var rhs = `;
														{
															@:ast(switch (left.def) {
	case EVar(name2):
		if (isDefinitelyNonNilLiteral(rhs)) {
			nonNil.set(name2, true);
		} else {
			nonNil.remove(name2);
		};	
	default:
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var name2 = `;
																		{
																			if (@:ast(switch (e.def) {
	case EString(_):
		true;	
	case EInteger(_):
		true;	
	case EFloat(_):
		true;	
	case EBoolean(_):
		true;	
	case EList(_):
		true;	
	case EMap(_):
		true;	
	case ETuple(_):
		true;	
	case EAtom(atom) if (atom != "nil"):
		true;	
	default:
		false;	
}) {
																				var ` = rhs.def;
																				switch (enumIndex `) {
																					case 15: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 16: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 17: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 31: {
																						var ` = `[0];
																						{
																							var atom = `;
																							if (atom != "nil") {
																								true;
																							} else {
																								false;
																							};
																						};
																					};
																					case 32: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 33: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 34: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					case 35: {
																						var ` = `[0];
																						{
																							true;
																						};
																					};
																					default: {
																						false;
																					}
																				};
																			}) {
																				{
																					nonNil.set(name2, true);
																				};
																			} else {
																				nonNil.remove(name2);
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									out.push(s);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : block.metadata, pos : block.pos};
						};
					};
				} else {
					reflaxe.elixir.ast.ElixirASTTransformer.transformNode(block, function(n:reflaxe.elixir.ast.ElixirAST) return n);
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		makeASTWithMeta(EDef(name, args, guards, processBlock(body, new Map())), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		makeASTWithMeta(EDefp(name, args, guards, processBlock(body, new Map())), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, processBlock[0](body, {
										{};
										new haxe.ds.StringMap();
									}));
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, processBlock[0](body, {
										{};
										new haxe.ds.StringMap();
									}));
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function stringToAtomLiteralPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall(mod, func, args):
		switch (mod.def) {
			case EVar(m) if (m == "String" && (func == "to_atom" || func == "to_existing_atom") && args != null && args.length == 1):
				toAtom(args[0]);			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var mod = `;
						var func = `;
						var args = `;
						{
							@:ast(switch (mod.def) {
	case EVar(m) if (m == "String" && (func == "to_atom" || func == "to_existing_atom") && args != null && args.length == 1):
		toAtom(args[0]);	
	default:
		n;	
}) {
								var ` = mod.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var m = `;
										if (m == "String" && (func == "to_atom" || func == "to_existing_atom") && args != null && args.length == 1) {
											{
												var e = args[0];
												@:ast(switch (e.def) {
	case EString(s):
		makeAST(EAtom(s));	
	default:
		e;	
}) {
													var ` = e.def;
													if (enumIndex ` == 32) {
														var ` = `[0];
														{
															var s = `;
															{
																{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																};
															};
														};
													} else {
														e;
													};
												};
											};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	public static function dateImplRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(m) }, f, args) if (isDateImplModule(m) && f == "from_string" && args.length == 1):
		args[0];	
	case ERemoteCall({ def : EVar(m) }, f, args) if (isDateImplModule(m) && f == "get_time" && args.length == 1):
		switch (args[0].def) {
			case ERemoteCall({ def : EVar(dm) }, "utc_now", _) if (dm == "DateTime"):
				makeAST(ERemoteCall(makeAST(EVar("DateTime")), "to_iso8601", [args[0]]));			
			default:
				args[0];			
		};	
	case ECall({ def : EVar(m) }, f, args) if (isDateImplModule(m) && f == "from_string" && args.length == 1):
		args[0];	
	case ECall({ def : EVar(m) }, f, args) if (isDateImplModule(m) && f == "get_time" && args.length == 1):
		switch (args[0].def) {
			case ERemoteCall({ def : EVar(dm) }, "utc_now", _) if (dm == "DateTime"):
				makeAST(ERemoteCall(makeAST(EVar("DateTime")), "to_iso8601", [args[0]]));			
			default:
				args[0];			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == null) {
							n;
						} else {
							var ` = `.def;
							var ` = `.metadata;
							var ` = `.pos;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var m = `;
									var f = `;
									var args = `;
									if (if (m == null) {
										false;
									} else {
										var lastDot = m.lastIndexOf(".", null);
										var last = if (lastDot >= 0) {
											m.substring(lastDot + 1, null);
										} else {
											m;
										};
										last == "Date_Impl_";
									} && f == "from_string" && args.length == 1) {
										args[0];
									} else {
										var m = `;
										var f = `;
										var args = `;
										if (if (m == null) {
											false;
										} else {
											var lastDot = m.lastIndexOf(".", null);
											var last = if (lastDot >= 0) {
												m.substring(lastDot + 1, null);
											} else {
												m;
											};
											last == "Date_Impl_";
										} && f == "get_time" && args.length == 1) {
											@:ast(switch (args[0].def) {
	case ERemoteCall({ def : EVar(dm) }, "utc_now", _) if (dm == "DateTime"):
		makeAST(ERemoteCall(makeAST(EVar("DateTime")), "to_iso8601", [args[0]]));	
	default:
		args[0];	
}) {
												var ` = args[0].def;
												if (enumIndex ` == 24) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var ` = `.def;
														var ` = `.metadata;
														var ` = `.pos;
														if (enumIndex ` == 38) {
															var ` = `[0];
															if (` == "utc_now") {
																{
																	var dm = `;
																	if (dm == "DateTime") {
																		{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("DateTime"), metadata : {}, pos : pos};
																			}, "to_iso8601", [args[0]]), metadata : {}, pos : pos};
																		};
																	} else {
																		args[0];
																	};
																};
															} else {
																args[0];
															};
														} else {
															args[0];
														};
													};
												} else {
													args[0];
												};
											};
										} else {
											n;
										};
									};
								};
							} else {
								n;
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var ` = `.def;
							var ` = `.metadata;
							var ` = `.pos;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var m = `;
									var f = `;
									var args = `;
									if (if (m == null) {
										false;
									} else {
										var lastDot = m.lastIndexOf(".", null);
										var last = if (lastDot >= 0) {
											m.substring(lastDot + 1, null);
										} else {
											m;
										};
										last == "Date_Impl_";
									} && f == "from_string" && args.length == 1) {
										args[0];
									} else {
										var m = `;
										var f = `;
										var args = `;
										if (if (m == null) {
											false;
										} else {
											var lastDot = m.lastIndexOf(".", null);
											var last = if (lastDot >= 0) {
												m.substring(lastDot + 1, null);
											} else {
												m;
											};
											last == "Date_Impl_";
										} && f == "get_time" && args.length == 1) {
											@:ast(switch (args[0].def) {
	case ERemoteCall({ def : EVar(dm) }, "utc_now", _) if (dm == "DateTime"):
		makeAST(ERemoteCall(makeAST(EVar("DateTime")), "to_iso8601", [args[0]]));	
	default:
		args[0];	
}) {
												var ` = args[0].def;
												if (enumIndex ` == 24) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var ` = `.def;
														var ` = `.metadata;
														var ` = `.pos;
														if (enumIndex ` == 38) {
															var ` = `[0];
															if (` == "utc_now") {
																{
																	var dm = `;
																	if (dm == "DateTime") {
																		{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("DateTime"), metadata : {}, pos : pos};
																			}, "to_iso8601", [args[0]]), metadata : {}, pos : pos};
																		};
																	} else {
																		args[0];
																	};
																};
															} else {
																args[0];
															};
														} else {
															args[0];
														};
													};
												} else {
													args[0];
												};
											};
										} else {
											n;
										};
									};
								};
							} else {
								n;
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function presenceApiModuleRewritePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var rewriteInScope = function(sub:reflaxe.elixir.ast.ElixirAST, app:String) {
			var presenceModule = app + "Web.Presence";
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(sub, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case ERemoteCall(mod, fn, args):
		var modStr = switch (mod.def) {
			case EVar(m):
				m;			
			default:
				null;			
		};
		if (modStr == "Phoenix.Presence") {
			switch (fn) {
				case "track" | "update" | "untrack" | "list":
					makeASTWithMeta(ERemoteCall(makeAST(EVar(presenceModule)), fn, args), n.metadata, n.pos);				
				default:
					n;				
			};
		} else n;	
	default:
		n;	
}) {
					var ` = n.def;
					if (enumIndex ` == 24) {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var fn = `;
							var args = `;
							{
								var modStr = @:ast(switch (mod.def) {
	case EVar(m):
		m;	
	default:
		null;	
}) {
									var ` = mod.def;
									if (enumIndex ` == 38) {
										var ` = `[0];
										{
											var m = `;
											{
												m;
											};
										};
									} else {
										null;
									};
								};
								if (modStr == "Phoenix.Presence") {
									@:ast(switch (fn) {
	case "track" | "update" | "untrack" | "list":
		makeASTWithMeta(ERemoteCall(makeAST(EVar(presenceModule)), fn, args), n.metadata, n.pos);	
	default:
		n;	
}) switch (fn) {
										case "list", "track", "untrack", "update": {
											{
												{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(presenceModule), metadata : {}, pos : pos};
												}, fn, args), metadata : n.metadata, pos : n.pos};
											};
										};
										default: {
											n;
										}
									};
								} else {
									n;
								};
							};
						};
					} else {
						n;
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var app = deriveAppPrefix(name);
		if (app == null) try app = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch(e:Dynamic) { };
		if (app == null) return n;
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(rewriteInScope(b, app));
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		var app = deriveAppPrefix(name);
		if (app == null) try app = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch(e:Dynamic) { };
		if (app == null) return n;
		var newDo = rewriteInScope(doBlock, app);
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var app = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (app == null) {
									try {
										app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
								};
								if (app == null) {
									return n;
								};
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(rewriteInScope(b, app));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var app = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (app == null) {
									try {
										app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
								};
								if (app == null) {
									return n;
								};
								var newDo = rewriteInScope(doBlock, app);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function moduleNewToStructLiteralPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		var toStruct = function(mod:reflaxe.elixir.ast.ElixirAST, meta:Dynamic, pos:haxe.macro.Position, appPrefix:Null<String>) {
			return @:ast(switch (mod.def) {
	case EVar(name) if (name != null && name.length > 0 && isUpperCamel(name)):
		var full = (appPrefix != null && name.indexOf(".") == -1) ? appPrefix + "." + name : name;
		makeASTWithMeta(EStruct(full, []), meta, pos);	
	default:
		makeASTWithMeta(EStruct(reflaxe.elixir.ast.ElixirASTPrinter.printAST(mod), []), meta, pos);	
}) {
				var ` = mod.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var name = `;
						if (name != null && name.length > 0 && name != null && name.length > 0 && (name.charAt(0) == name.charAt(0).toUpperCase()) && (name.charAt(0) != name.charAt(0).toLowerCase())) {
							var full = if ((appPrefix != null && name.indexOf(".", null) == -1)) {
								appPrefix + "." + name;
							} else {
								name;
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EStruct(full, []), metadata : cast meta, pos : pos};
						} else {
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EStruct(reflaxe.elixir.ast.ElixirASTPrinter.printAST(mod, null), []);
								{def : def, metadata : cast meta, pos : pos};
							};
						};
					};
				} else {
					{
						var def = reflaxe.elixir.ast.ElixirASTDef.EStruct(reflaxe.elixir.ast.ElixirASTPrinter.printAST(mod, null), []);
						{def : def, metadata : cast meta, pos : pos};
					};
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var prefix = deriveAppPrefix(name);
		var newBody = [for (b  in  body) ElixirASTTransformer.transformNode(b, function(x) {
			return switch (x.def) {
				case ERemoteCall(mod, "new", args) if (args.length == 0):
					toStruct(mod, x.metadata, x.pos, prefix);				
				case ECall(mod, "new", args) if (mod != null && args.length == 0):
					toStruct(mod, x.metadata, x.pos, prefix);				
				default:
					x;				
			};
		})];
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		var prefix = deriveAppPrefix(name);
		var newDo = ElixirASTTransformer.transformNode(doBlock, function(x) {
			return switch (x.def) {
				case ERemoteCall(mod, "new", args) if (args.length == 0):
					toStruct(mod, x.metadata, x.pos, prefix);				
				case ECall(mod, "new", args) if (mod != null && args.length == 0):
					toStruct(mod, x.metadata, x.pos, prefix);				
				default:
					x;				
			};
		});
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	case ERemoteCall(mod, "new", args) if (args.length == 0):
		toStruct(mod, n.metadata, n.pos, null);	
	case ECall(mod, "new", args) if (mod != null && args.length == 0):
		toStruct(mod, n.metadata, n.pos, null);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newBody = {
									var ` = [];
									{
										var ` = 0;
										while (` < body.length) {
											var b = body[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(x:reflaxe.elixir.ast.ElixirAST) {
												return @:ast(switch (x.def) {
	case ERemoteCall(mod, "new", args) if (args.length == 0):
		toStruct(mod, x.metadata, x.pos, prefix);	
	case ECall(mod, "new", args) if (mod != null && args.length == 0):
		toStruct(mod, x.metadata, x.pos, prefix);	
	default:
		x;	
}) {
													var ` = x.def;
													switch (enumIndex `) {
														case 22: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == "new") {
																{
																	var mod = `;
																	var args = `;
																	if (mod != null && args.length == 0) {
																		toStruct(mod, x.metadata, x.pos, prefix);
																	} else {
																		x;
																	};
																};
															} else {
																x;
															};
														};
														case 24: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == "new") {
																{
																	var mod = `;
																	var args = `;
																	if (args.length == 0) {
																		toStruct(mod, x.metadata, x.pos, prefix);
																	} else {
																		x;
																	};
																};
															} else {
																x;
															};
														};
														default: {
															x;
														}
													};
												};
											}));
										};
									};
									`;
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								var newDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(x:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (x.def) {
	case ERemoteCall(mod, "new", args) if (args.length == 0):
		toStruct(mod, x.metadata, x.pos, prefix);	
	case ECall(mod, "new", args) if (mod != null && args.length == 0):
		toStruct(mod, x.metadata, x.pos, prefix);	
	default:
		x;	
}) {
										var ` = x.def;
										switch (enumIndex `) {
											case 22: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (` == "new") {
													{
														var mod = `;
														var args = `;
														if (mod != null && args.length == 0) {
															toStruct(mod, x.metadata, x.pos, prefix);
														} else {
															x;
														};
													};
												} else {
													x;
												};
											};
											case 24: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (` == "new") {
													{
														var mod = `;
														var args = `;
														if (args.length == 0) {
															toStruct(mod, x.metadata, x.pos, prefix);
														} else {
															x;
														};
													};
												} else {
													x;
												};
											};
											default: {
												x;
											}
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == "new") {
							{
								var mod = `;
								var args = `;
								if (mod != null && args.length == 0) {
									toStruct(mod, n.metadata, n.pos, null);
								} else {
									n;
								};
							};
						} else {
							n;
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == "new") {
							{
								var mod = `;
								var args = `;
								if (args.length == 0) {
									toStruct(mod, n.metadata, n.pos, null);
								} else {
									n;
								};
							};
						} else {
							n;
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function changesetStructQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(modName, attrs, body):
		var appPrefix = deriveAppPrefix(modName);
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(ElixirASTTransformer.transformNode(b, function(x) {
			return switch (x.def) {
				case ERemoteCall(remoteMod, fn, args) if (fn == "changeset" && args.length >= 1 && appPrefix != null):
					var modStr = (function() {
						return switch (remoteMod.def) {
							case EVar(rn):
								rn;							
							default:
								ElixirASTPrinter.printAST(remoteMod);							
						};
					})();
					if (modStr.indexOf(appPrefix + ".") == 0) {
						switch (args[0].def) {
							case EStruct(name, fields) if (name.indexOf(".") == -1):
								var q = makeAST(EStruct(appPrefix + "." + name, fields));
								var newArgs = args.copy();
								newArgs[0] = q;
								makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);							
							default:
								x;							
						};
					} else x;				
				default:
					x;				
			};
		}));
		makeASTWithMeta(EModule(modName, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(modName, doBlock):
		var appPrefix = deriveAppPrefix(modName);
		var newDo = ElixirASTTransformer.transformNode(doBlock, function(x) {
			return switch (x.def) {
				case ERemoteCall(remoteMod, fn, args) if (fn == "changeset" && args.length >= 1 && appPrefix != null):
					var modStr = (function() {
						return switch (remoteMod.def) {
							case EVar(rn):
								rn;							
							default:
								ElixirASTPrinter.printAST(remoteMod);							
						};
					})();
					if (modStr.indexOf(appPrefix + ".") == 0) {
						switch (args[0].def) {
							case EStruct(name, fields) if (name.indexOf(".") == -1):
								var q = makeAST(EStruct(appPrefix + "." + name, fields));
								var newArgs = args.copy();
								newArgs[0] = q;
								makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);							
							default:
								x;							
						};
					} else x;				
				default:
					x;				
			};
		});
		makeASTWithMeta(EDefmodule(modName, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var modName = `;
							var attrs = `;
							var body = `;
							{
								var appPrefix = if (modName == null) {
									null;
								} else {
									var idx = modName.indexOf("Web", null);
									if (idx > 0) {
										modName.substring(0, idx);
									} else {
										null;
									};
								};
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(x:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (x.def) {
	case ERemoteCall(remoteMod, fn, args) if (fn == "changeset" && args.length >= 1 && appPrefix != null):
		var modStr = (function() {
			return switch (remoteMod.def) {
				case EVar(rn):
					rn;				
				default:
					ElixirASTPrinter.printAST(remoteMod);				
			};
		})();
		if (modStr.indexOf(appPrefix + ".") == 0) {
			switch (args[0].def) {
				case EStruct(name, fields) if (name.indexOf(".") == -1):
					var q = makeAST(EStruct(appPrefix + "." + name, fields));
					var newArgs = args.copy();
					newArgs[0] = q;
					makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);				
				default:
					x;				
			};
		} else x;	
	default:
		x;	
}) {
												var ` = x.def;
												if (enumIndex ` == 24) {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var remoteMod = `;
														var fn = `;
														var args = `;
														if (fn == "changeset" && args.length >= 1 && appPrefix != null) {
															var modStr = (function() {
																return @:ast(switch (remoteMod.def) {
	case EVar(rn):
		rn;	
	default:
		ElixirASTPrinter.printAST(remoteMod);	
}) {
																	var ` = remoteMod.def;
																	if (enumIndex ` == 38) {
																		var ` = `[0];
																		{
																			var rn = `;
																			{
																				rn;
																			};
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTPrinter.printAST(remoteMod, null);
																	};
																};
															})();
															if (modStr.indexOf(appPrefix + ".", null) == 0) {
																@:ast(switch (args[0].def) {
	case EStruct(name, fields) if (name.indexOf(".") == -1):
		var q = makeAST(EStruct(appPrefix + "." + name, fields));
		var newArgs = args.copy();
		newArgs[0] = q;
		makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);	
	default:
		x;	
}) {
																	var ` = args[0].def;
																	if (enumIndex ` == 18) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var name = `;
																			var fields = `;
																			if (name.indexOf(".", null) == -1) {
																				var q = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EStruct(appPrefix + "." + name, fields), metadata : {}, pos : pos};
																				};
																				var newArgs = args.copy();
																				newArgs[0] = q;
																				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(remoteMod, fn, newArgs), metadata : x.metadata, pos : x.pos};
																			} else {
																				x;
																			};
																		};
																	} else {
																		x;
																	};
																};
															} else {
																x;
															};
														} else {
															x;
														};
													};
												} else {
													x;
												};
											};
										}));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(modName, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var modName = `;
							var doBlock = `;
							{
								var appPrefix = if (modName == null) {
									null;
								} else {
									var idx = modName.indexOf("Web", null);
									if (idx > 0) {
										modName.substring(0, idx);
									} else {
										null;
									};
								};
								var newDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(x:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (x.def) {
	case ERemoteCall(remoteMod, fn, args) if (fn == "changeset" && args.length >= 1 && appPrefix != null):
		var modStr = (function() {
			return switch (remoteMod.def) {
				case EVar(rn):
					rn;				
				default:
					ElixirASTPrinter.printAST(remoteMod);				
			};
		})();
		if (modStr.indexOf(appPrefix + ".") == 0) {
			switch (args[0].def) {
				case EStruct(name, fields) if (name.indexOf(".") == -1):
					var q = makeAST(EStruct(appPrefix + "." + name, fields));
					var newArgs = args.copy();
					newArgs[0] = q;
					makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);				
				default:
					x;				
			};
		} else x;	
	default:
		x;	
}) {
										var ` = x.def;
										if (enumIndex ` == 24) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var remoteMod = `;
												var fn = `;
												var args = `;
												if (fn == "changeset" && args.length >= 1 && appPrefix != null) {
													var modStr = (function() {
														return @:ast(switch (remoteMod.def) {
	case EVar(rn):
		rn;	
	default:
		ElixirASTPrinter.printAST(remoteMod);	
}) {
															var ` = remoteMod.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var rn = `;
																	{
																		rn;
																	};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTPrinter.printAST(remoteMod, null);
															};
														};
													})();
													if (modStr.indexOf(appPrefix + ".", null) == 0) {
														@:ast(switch (args[0].def) {
	case EStruct(name, fields) if (name.indexOf(".") == -1):
		var q = makeAST(EStruct(appPrefix + "." + name, fields));
		var newArgs = args.copy();
		newArgs[0] = q;
		makeASTWithMeta(ERemoteCall(remoteMod, fn, newArgs), x.metadata, x.pos);	
	default:
		x;	
}) {
															var ` = args[0].def;
															if (enumIndex ` == 18) {
																var ` = `[0];
																var ` = `[1];
																{
																	var name = `;
																	var fields = `;
																	if (name.indexOf(".", null) == -1) {
																		var q = {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EStruct(appPrefix + "." + name, fields), metadata : {}, pos : pos};
																		};
																		var newArgs = args.copy();
																		newArgs[0] = q;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(remoteMod, fn, newArgs), metadata : x.metadata, pos : x.pos};
																	} else {
																		x;
																	};
																};
															} else {
																x;
															};
														};
													} else {
														x;
													};
												} else {
													x;
												};
											};
										} else {
											x;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(modName, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function erawRepoQualificationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var qualifyRepoToken = function(code:String, repoName:String) {
			var out = new StringBuf();
			var i = 0;
			while (i < code.length) {
				if (i + 5 <= code.length && code.substr(i, 5) == "Repo.") {
					var prev = if (i > 0) {
						code.charAt(i - 1);
					} else {
						"";
					};
					var isBoundary = (i == 0) || ! new EReg("[A-Za-z0-9_\\.]", "").match(prev);
					if (isBoundary) {
						out.add(repoName);
						out.add(".");
						i += 5;
						continue;
					};
				};
				out.add(code.charAt(i));
				i ++;
			};
			return out.toString();
		};
		var qualifyRepoInERaw = function(node:reflaxe.elixir.ast.ElixirAST, repoName:String) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(x:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (x.def) {
	case ERaw(code):
		var qualified = qualifyRepoToken(code, repoName);
		if (qualified != code) {
			makeASTWithMeta(ERaw(qualified), x.metadata, x.pos);
		} else x;	
	default:
		x;	
}) {
					var ` = x.def;
					if (enumIndex ` == 62) {
						var ` = `[0];
						{
							var code = `;
							{
								var qualified = qualifyRepoToken(code, repoName);
								if (qualified != code) {
									{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(qualified), metadata : x.metadata, pos : x.pos};
								} else {
									x;
								};
							};
						};
					} else {
						x;
					};
				};
			});
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) return n;
		var repoName = prefix + ".Repo";
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) newBody.push(qualifyRepoInERaw(b, repoName));
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) return n;
		var repoName = prefix + ".Repo";
		var newDo = qualifyRepoInERaw(doBlock, repoName);
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									return n;
								};
								var repoName = prefix + ".Repo";
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(qualifyRepoInERaw(b, repoName));
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									return n;
								};
								var repoName = prefix + ".Repo";
								var newDo = qualifyRepoInERaw(doBlock, repoName);
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function casePatternTempAssignmentRemovalPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var collectPatternVars = [null];
		collectPatternVars[0] = function(p:reflaxe.elixir.ast.EPattern, out:Map<String, Bool>) {
			@:ast(switch (p) {
	case PVar(name):
		if (name != null && name.length > 0 && name.charAt(0) != "_") out.set(name, true);	
	case PTuple(elems):
		for (ep  in  elems) collectPatternVars(ep, out);	
	case PList(elems):
		for (ep  in  elems) collectPatternVars(ep, out);	
	case PCons(h, t):
		collectPatternVars(h, out);
		collectPatternVars(t, out);	
	case PMap(pairs):
		for (kv  in  pairs) collectPatternVars(kv.value, out);	
	case PStruct(_, fields):
		for (f  in  fields) collectPatternVars(f.value, out);	
	case PPin(inner):
		collectPatternVars(inner, out);	
	case PAlias(varName, inner):
		if (varName != null && varName.length > 0 && varName.charAt(0) != "_") out.set(varName, true);
		collectPatternVars(inner, out);	
	default:
}) switch (enumIndex p) {
				case 0: {
					var ` = p[0];
					{
						var name = `;
						{
							if (name != null && name.length > 0 && name.charAt(0) != "_") {
								{
									out.set(name, true);
								};
							};
						};
					};
				};
				case 2: {
					var ` = p[0];
					{
						var elems = `;
						{
							{
								var ` = 0;
								while (` < elems.length) {
									var ep = elems[`];
									++ `;
									collectPatternVars[0](ep, out);
								};
							};
						};
					};
				};
				case 3: {
					var ` = p[0];
					{
						var elems = `;
						{
							{
								var ` = 0;
								while (` < elems.length) {
									var ep = elems[`];
									++ `;
									collectPatternVars[0](ep, out);
								};
							};
						};
					};
				};
				case 4: {
					var ` = p[0];
					var ` = p[1];
					{
						var h = `;
						var t = `;
						{
							collectPatternVars[0](h, out);
							collectPatternVars[0](t, out);
						};
					};
				};
				case 5: {
					var ` = p[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var kv = pairs[`];
									++ `;
									collectPatternVars[0](kv.value, out);
								};
							};
						};
					};
				};
				case 6: {
					var ` = p[0];
					var ` = p[1];
					{
						var fields = `;
						{
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									collectPatternVars[0](f.value, out);
								};
							};
						};
					};
				};
				case 7: {
					var ` = p[0];
					{
						var inner = `;
						{
							collectPatternVars[0](inner, out);
						};
					};
				};
				case 9: {
					var ` = p[0];
					var ` = p[1];
					{
						var varName = `;
						var inner = `;
						{
							if (varName != null && varName.length > 0 && varName.charAt(0) != "_") {
								{
									out.set(varName, true);
								};
							};
							collectPatternVars[0](inner, out);
						};
					};
				};
				default: {}
			};
		};
		var isInfraTemp = function(name:String) {
			if (name == null || name.length == 0) {
				return false;
			};
			if (name.charAt(0) == "_") {
				name = name.substr(1, null);
			};
			if (name == "g") {
				return true;
			};
			if (name.charAt(0) == "g") {
				var ok = true;
				{
					var ` = 1;
					var ` = name.length;
					while (` < `) {
						var i = ` ++;
						var c = name.charCodeAt(i);
						if (c < 48 || c > 57) {
							ok = false;
							break;
						};
					};
				};
				return ok;
			};
			return false;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EBlock(stmts):
		var filtered:Array<ElixirAST> = [];
		for (s  in  stmts) {
			var drop = false;
			switch (s.def) {
				case EBinary(Match, left, right):
					switch (left.def) {
						case EVar(lhs):
							switch (right.def) {
								case EVar(rn):
									if (isInfraTemp(rn)) drop = true;								
								default:
							};						
						default:
					};				
				case EMatch(pat, rhs):
					switch (pat) {
						case PVar(lhs):
							switch (rhs.def) {
								case EVar(rn):
									if (isInfraTemp(rn)) drop = true;								
								default:
							};						
						default:
					};				
				default:
			};
			if (!drop) filtered.push(s);
		};
		n = { def : EBlock(filtered), metadata : n.metadata, pos : n.pos };	
	default:
}) {
				var ` = n.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							var filtered = [];
							{
								var ` = 0;
								while (` < stmts.length) {
									var s = stmts[`];
									++ `;
									var drop = false;
									@:ast(switch (s.def) {
	case EBinary(Match, left, right):
		switch (left.def) {
			case EVar(lhs):
				switch (right.def) {
					case EVar(rn):
						if (isInfraTemp(rn)) drop = true;					
					default:
				};			
			default:
		};	
	case EMatch(pat, rhs):
		switch (pat) {
			case PVar(lhs):
				switch (rhs.def) {
					case EVar(rn):
						if (isInfraTemp(rn)) drop = true;					
					default:
				};			
			default:
		};	
	default:
}) {
										var ` = s.def;
										switch (enumIndex `) {
											case 8: {
												var ` = `[0];
												var ` = `[1];
												{
													var pat = `;
													var rhs = `;
													{
														@:ast(switch (pat) {
	case PVar(lhs):
		switch (rhs.def) {
			case EVar(rn):
				if (isInfraTemp(rn)) drop = true;			
			default:
		};	
	default:
}) if (enumIndex pat == 0) {
															var ` = pat[0];
															{
																var lhs = `;
																{
																	@:ast(switch (rhs.def) {
	case EVar(rn):
		if (isInfraTemp(rn)) drop = true;	
	default:
}) {
																		var ` = rhs.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var rn = `;
																				{
																					if (isInfraTemp(rn)) {
																						drop = true;
																					};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
											};
											case 26: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												if (enumIndex ` == 27) {
													{
														var left = `;
														var right = `;
														{
															@:ast(switch (left.def) {
	case EVar(lhs):
		switch (right.def) {
			case EVar(rn):
				if (isInfraTemp(rn)) drop = true;			
			default:
		};	
	default:
}) {
																var ` = left.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var lhs = `;
																		{
																			@:ast(switch (right.def) {
	case EVar(rn):
		if (isInfraTemp(rn)) drop = true;	
	default:
}) {
																				var ` = right.def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var rn = `;
																						{
																							if (isInfraTemp(rn)) {
																								drop = true;
																							};
																						};
																					};
																				} else {};
																			};
																		};
																	};
																} else {};
															};
														};
													};
												} else {};
											};
											default: {}
										};
									};
									if (! drop) {
										filtered.push(s);
									};
								};
							};
							n = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filtered), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {};
			};
			return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses:Array<ECaseClause> = [];
		for (cl  in  clauses) {
			var patternVars = new Map<String,Bool>();
			collectPatternVars(cl.pattern, patternVars);
			var newBody = cl.body;
			switch (cl.body.def) {
				case EBlock(stmts):
					var filtered:Array<ElixirAST> = [];
					for (s  in  stmts) {
						var drop = false;
						switch (s.def) {
							case EMatch(pat, rhs):
								switch (pat) {
									case PVar(lhs):
										if (patternVars.exists(lhs)) {
											switch (rhs.def) {
												case EVar(rn):
													if (isInfraTemp(rn)) drop = true;												
												default:
											};
										};									
									default:
								};							
							case EBinary(Match, left, right):
								switch (left.def) {
									case EVar(lhs):
										if (patternVars.exists(lhs)) {
											switch (right.def) {
												case EVar(rn):
													if (isInfraTemp(rn)) drop = true;												
												default:
											};
										};									
									default:
								};							
							default:
						};
						if (!drop) filtered.push(s);
					};
					newBody = { def : EBlock(filtered), metadata : cl.body.metadata, pos : cl.body.pos };				
				default:
			};
			newClauses.push({ pattern : cl.pattern, guard : cl.guard, body : newBody });
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var patternVars = {
										{};
										new haxe.ds.StringMap();
									};
									collectPatternVars[0](cl.pattern, patternVars);
									var newBody = cl.body;
									@:ast(switch (cl.body.def) {
	case EBlock(stmts):
		var filtered:Array<ElixirAST> = [];
		for (s  in  stmts) {
			var drop = false;
			switch (s.def) {
				case EMatch(pat, rhs):
					switch (pat) {
						case PVar(lhs):
							if (patternVars.exists(lhs)) {
								switch (rhs.def) {
									case EVar(rn):
										if (isInfraTemp(rn)) drop = true;									
									default:
								};
							};						
						default:
					};				
				case EBinary(Match, left, right):
					switch (left.def) {
						case EVar(lhs):
							if (patternVars.exists(lhs)) {
								switch (right.def) {
									case EVar(rn):
										if (isInfraTemp(rn)) drop = true;									
									default:
								};
							};						
						default:
					};				
				default:
			};
			if (!drop) filtered.push(s);
		};
		newBody = { def : EBlock(filtered), metadata : cl.body.metadata, pos : cl.body.pos };	
	default:
}) {
										var ` = cl.body.def;
										if (enumIndex ` == 53) {
											var ` = `[0];
											{
												var stmts = `;
												{
													var filtered = [];
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															var drop = false;
															@:ast(switch (s.def) {
	case EMatch(pat, rhs):
		switch (pat) {
			case PVar(lhs):
				if (patternVars.exists(lhs)) {
					switch (rhs.def) {
						case EVar(rn):
							if (isInfraTemp(rn)) drop = true;						
						default:
					};
				};			
			default:
		};	
	case EBinary(Match, left, right):
		switch (left.def) {
			case EVar(lhs):
				if (patternVars.exists(lhs)) {
					switch (right.def) {
						case EVar(rn):
							if (isInfraTemp(rn)) drop = true;						
						default:
					};
				};			
			default:
		};	
	default:
}) {
																var ` = s.def;
																switch (enumIndex `) {
																	case 8: {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var pat = `;
																			var rhs = `;
																			{
																				@:ast(switch (pat) {
	case PVar(lhs):
		if (patternVars.exists(lhs)) {
			switch (rhs.def) {
				case EVar(rn):
					if (isInfraTemp(rn)) drop = true;				
				default:
			};
		};	
	default:
}) if (enumIndex pat == 0) {
																					var ` = pat[0];
																					{
																						var lhs = `;
																						{
																							if (patternVars.exists(lhs)) {
																								@:ast(switch (rhs.def) {
	case EVar(rn):
		if (isInfraTemp(rn)) drop = true;	
	default:
}) {
																									var ` = rhs.def;
																									if (enumIndex ` == 38) {
																										var ` = `[0];
																										{
																											var rn = `;
																											{
																												if (isInfraTemp(rn)) {
																													drop = true;
																												};
																											};
																										};
																									} else {};
																								};
																							};
																						};
																					};
																				} else {};
																			};
																		};
																	};
																	case 26: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		if (enumIndex ` == 27) {
																			{
																				var left = `;
																				var right = `;
																				{
																					@:ast(switch (left.def) {
	case EVar(lhs):
		if (patternVars.exists(lhs)) {
			switch (right.def) {
				case EVar(rn):
					if (isInfraTemp(rn)) drop = true;				
				default:
			};
		};	
	default:
}) {
																						var ` = left.def;
																						if (enumIndex ` == 38) {
																							var ` = `[0];
																							{
																								var lhs = `;
																								{
																									if (patternVars.exists(lhs)) {
																										@:ast(switch (right.def) {
	case EVar(rn):
		if (isInfraTemp(rn)) drop = true;	
	default:
}) {
																											var ` = right.def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var rn = `;
																													{
																														if (isInfraTemp(rn)) {
																															drop = true;
																														};
																													};
																												};
																											} else {};
																										};
																									};
																								};
																							};
																						} else {};
																					};
																				};
																			};
																		} else {};
																	};
																	default: {}
																};
															};
															if (! drop) {
																filtered.push(s);
															};
														};
													};
													newBody = {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(filtered), metadata : cl.body.metadata, pos : cl.body.pos};
												};
											};
										} else {};
									};
									newClauses.push({pattern : cl.pattern, guard : cl.guard, body : newBody});
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	public static function nilGuardCoalesceToMapPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var containsFieldUse = function(node:reflaxe.elixir.ast.ElixirAST, v:String) {
			var found = [false];
			reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				if (found[0]) {
					return n;
				};
				@:ast(switch (n.def) {
	case EField({ def : EVar(name) }, _):
		if (name == v) found = true;	
	default:
}) {
					var ` = n.def;
					if (enumIndex ` == 28) {
						var ` = `[0];
						var ` = `[1];
						{
							var ` = `.def;
							var ` = `.metadata;
							var ` = `.pos;
							if (enumIndex ` == 38) {
								var ` = `[0];
								{
									var name = `;
									{
										if (name == v) {
											found[0] = true;
										};
									};
								};
							} else {};
						};
					} else {};
				};
				return n;
			});
			return found[0];
		};
		var rewriteFieldsAfterCoalesce = function(b:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (b.def) {
	case EBlock(stmts):
		var active:Map<String,Bool> = new Map();
		var newStmts:Array<ElixirAST> = [];
		function transformForActive(n:ElixirAST):ElixirAST {
			return ElixirASTTransformer.transformNode(n, function(x) {
				switch (x.def) {
					case EField({ def : EVar(name) }, field):
						if (active.exists(name)) {
							var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(field);
							return makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [makeAST(EVar(name)), makeAST(EAtom(atomField))]));
						} else {
							return x;
						};					
					case EAccess({ def : EVar(name) }, { def : EAtom(atom) }):
						if (active.exists(name)) {
							var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(atom);
							return makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [makeAST(EVar(name)), makeAST(EAtom(atomField))]));
						} else {
							return x;
						};					
					default:
						return x;					
				};
			});
		};
		for (s  in  stmts) {
			var transformed = transformForActive(s);
			switch (transformed.def) {
				case EMatch(PVar(name), { def : EMap([]) }):
					active.set(name, true);				
				case EMatch(PVar(name), _):
					if (active.exists(name)) active.remove(name);				
				default:
			};
			newStmts.push(transformed);
		};
		makeASTWithMeta(EBlock(newStmts), b.metadata, b.pos);	
	default:
		b;	
}) {
				var ` = b.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							var active = {
								{};
								new haxe.ds.StringMap();
							};
							var newStmts = [];
							var transformForActive = function(n:reflaxe.elixir.ast.ElixirAST) {
								return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(n, function(x:reflaxe.elixir.ast.ElixirAST) {
									@:ast(switch (x.def) {
	case EField({ def : EVar(name) }, field):
		if (active.exists(name)) {
			var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(field);
			return makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [makeAST(EVar(name)), makeAST(EAtom(atomField))]));
		} else {
			return x;
		};	
	case EAccess({ def : EVar(name) }, { def : EAtom(atom) }):
		if (active.exists(name)) {
			var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(atom);
			return makeAST(ERemoteCall(makeAST(EVar("Map")), "get", [makeAST(EVar(name)), makeAST(EAtom(atomField))]));
		} else {
			return x;
		};	
	default:
		return x;	
}) {
										var ` = x.def;
										switch (enumIndex `) {
											case 28: {
												var ` = `[0];
												var ` = `[1];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var name = `;
															var field = `;
															{
																if (active.exists(name)) {
																	var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(field);
																	return {
																		var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																		}, "get", [{
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
																		}, {
																			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																				var this;
																				this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomField);
																				cast this;
																			});
																			var pos = null;
																			{def : def, metadata : {}, pos : pos};
																		}]);
																		var pos = null;
																		{def : def, metadata : {}, pos : pos};
																	};
																} else {
																	return x;
																};
															};
														};
													} else {
														return x;
													};
												};
											};
											case 29: {
												var ` = `[0];
												var ` = `[1];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 38) {
														var ` = `[0];
														{
															var ` = `.def;
															var ` = `.metadata;
															var ` = `.pos;
															if (enumIndex ` == 31) {
																var ` = `[0];
																{
																	var atom = `;
																	var name = `;
																	{
																		if (active.exists(name)) {
																			var atomField = reflaxe.elixir.ast.NameUtils.toSnakeCase(atom);
																			return {
																				var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Map"), metadata : {}, pos : pos};
																				}, "get", [{
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : pos};
																				}, {
																					var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																						var this;
																						this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomField);
																						cast this;
																					});
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				}]);
																				var pos = null;
																				{def : def, metadata : {}, pos : pos};
																			};
																		} else {
																			return x;
																		};
																	};
																};
															} else {
																return x;
															};
														};
													} else {
														return x;
													};
												};
											};
											default: {
												return x;
											}
										};
									};
								});
							};
							{
								var ` = 0;
								while (` < stmts.length) {
									var s = stmts[`];
									++ `;
									var transformed = transformForActive(s);
									@:ast(switch (transformed.def) {
	case EMatch(PVar(name), { def : EMap([]) }):
		active.set(name, true);	
	case EMatch(PVar(name), _):
		if (active.exists(name)) active.remove(name);	
	default:
}) {
										var ` = transformed.def;
										if (enumIndex ` == 8) {
											var ` = `[0];
											var ` = `[1];
											if (enumIndex ` == 0) {
												var ` = `[0];
												{
													var ` = `.def;
													var ` = `.metadata;
													var ` = `.pos;
													if (enumIndex ` == 17) {
														var ` = `[0];
														if (`.length == 0) {
															{
																var name = `;
																{
																	{
																		active.set(name, true);
																	};
																};
															};
														} else {
															var name = `;
															{
																if (active.exists(name)) {
																	active.remove(name);
																};
															};
														};
													} else {
														var name = `;
														{
															if (active.exists(name)) {
																active.remove(name);
															};
														};
													};
												};
											} else {};
										} else {};
									};
									newStmts.push(transformed);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newStmts), metadata : b.metadata, pos : b.pos};
						};
					};
				} else {
					b;
				};
			};
		};
		var processBlock = function(b:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (b.def) {
	case EBlock(stmts):
		var out:Array<ElixirAST> = [];
		var i = 0;
		while (i < stmts.length) {
			var s = stmts[i];
			var inserted = false;
			switch (s.def) {
				case EIf(cond, thenB, elseB):
					var v:Null<String> = null;
					switch (cond.def) {
						case ERemoteCall({ def : EVar(m) }, f, args) if (m == "Kernel" && f == "is_nil" && args.length == 1):
							switch (args[0].def) {
								case EVar(name):
									v = name;								
								default:
							};						
						case ECall(null, f, args) if (f == "is_nil" && args.length == 1):
							switch (args[0].def) {
								case EVar(name):
									v = name;								
								default:
							};						
						default:
					};
					out.push(s);
					if (v != null) {
						var j = i + 1;
						var seenFieldUse = false;
						var seenReassign = false;
						while (j < stmts.length && !seenFieldUse && !seenReassign) {
							switch (stmts[j].def) {
								case EMatch(PVar(name), _):
									if (name == v) {
										seenReassign = true;
									} else if (containsFieldUse(stmts[j], v)) {
										seenFieldUse = true;
									};								
								default:
									if (containsFieldUse(stmts[j], v)) seenFieldUse = true;								
							};
							j++;
						};
						if (seenFieldUse && !seenReassign) {
							out.push(makeAST(EMatch(PVar(v), makeAST(EMap([])))));
							inserted = true;
						};
					};				
				default:
					out.push(s);				
			};
			i++;
		};
		makeASTWithMeta(EBlock(out), b.metadata, b.pos);	
	default:
		b;	
}) {
				var ` = b.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var stmts = `;
						{
							var out = [];
							var i = 0;
							while (i < stmts.length) {
								var s = stmts[i];
								var inserted = false;
								@:ast(switch (s.def) {
	case EIf(cond, thenB, elseB):
		var v:Null<String> = null;
		switch (cond.def) {
			case ERemoteCall({ def : EVar(m) }, f, args) if (m == "Kernel" && f == "is_nil" && args.length == 1):
				switch (args[0].def) {
					case EVar(name):
						v = name;					
					default:
				};			
			case ECall(null, f, args) if (f == "is_nil" && args.length == 1):
				switch (args[0].def) {
					case EVar(name):
						v = name;					
					default:
				};			
			default:
		};
		out.push(s);
		if (v != null) {
			var j = i + 1;
			var seenFieldUse = false;
			var seenReassign = false;
			while (j < stmts.length && !seenFieldUse && !seenReassign) {
				switch (stmts[j].def) {
					case EMatch(PVar(name), _):
						if (name == v) {
							seenReassign = true;
						} else if (containsFieldUse(stmts[j], v)) {
							seenFieldUse = true;
						};					
					default:
						if (containsFieldUse(stmts[j], v)) seenFieldUse = true;					
				};
				j++;
			};
			if (seenFieldUse && !seenReassign) {
				out.push(makeAST(EMatch(PVar(v), makeAST(EMap([])))));
				inserted = true;
			};
		};	
	default:
		out.push(s);	
}) {
									var ` = s.def;
									if (enumIndex ` == 10) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var cond = `;
											var thenB = `;
											var elseB = `;
											{
												var v = null;
												@:ast(switch (cond.def) {
	case ERemoteCall({ def : EVar(m) }, f, args) if (m == "Kernel" && f == "is_nil" && args.length == 1):
		switch (args[0].def) {
			case EVar(name):
				v = name;			
			default:
		};	
	case ECall(null, f, args) if (f == "is_nil" && args.length == 1):
		switch (args[0].def) {
			case EVar(name):
				v = name;			
			default:
		};	
	default:
}) {
													var ` = cond.def;
													switch (enumIndex `) {
														case 22: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (` == null) {
																var f = `;
																var args = `;
																if (f == "is_nil" && args.length == 1) {
																	@:ast(switch (args[0].def) {
	case EVar(name):
		v = name;	
	default:
}) {
																		var ` = args[0].def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				{
																					v = name;
																				};
																			};
																		} else {};
																	};
																} else {};
															} else {};
														};
														case 24: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var m = `;
																		var f = `;
																		var args = `;
																		if (m == "Kernel" && f == "is_nil" && args.length == 1) {
																			@:ast(switch (args[0].def) {
	case EVar(name):
		v = name;	
	default:
}) {
																				var ` = args[0].def;
																				if (enumIndex ` == 38) {
																					var ` = `[0];
																					{
																						var name = `;
																						{
																							v = name;
																						};
																					};
																				} else {};
																			};
																		} else {};
																	};
																} else {};
															};
														};
														default: {}
													};
												};
												out.push(s);
												if (v != null) {
													var j = i + 1;
													var seenFieldUse = false;
													var seenReassign = false;
													while (j < stmts.length && ! seenFieldUse && ! seenReassign) {
														@:ast(switch (stmts[j].def) {
	case EMatch(PVar(name), _):
		if (name == v) {
			seenReassign = true;
		} else if (containsFieldUse(stmts[j], v)) {
			seenFieldUse = true;
		};	
	default:
		if (containsFieldUse(stmts[j], v)) seenFieldUse = true;	
}) {
															var ` = stmts[j].def;
															if (enumIndex ` == 8) {
																var ` = `[0];
																var ` = `[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		var name = `;
																		{
																			if (name == v) {
																				seenReassign = true;
																			} else {
																				if (containsFieldUse(stmts[j], v)) {
																					seenFieldUse = true;
																				};
																			};
																		};
																	};
																} else {
																	if (containsFieldUse(stmts[j], v)) {
																		seenFieldUse = true;
																	};
																};
															} else {
																if (containsFieldUse(stmts[j], v)) {
																	seenFieldUse = true;
																};
															};
														};
														j ++;
													};
													if (seenFieldUse && ! seenReassign) {
														out.push({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v), {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMap([]), metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														});
														inserted = true;
													};
												};
											};
										};
									} else {
										out.push(s);
									};
								};
								i ++;
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(out), metadata : b.metadata, pos : b.pos};
						};
					};
				} else {
					b;
				};
			};
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		var pb = processBlock(body);
		makeASTWithMeta(EDef(name, args, guards, rewriteFieldsAfterCoalesce(pb)), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		var pb = processBlock(body);
		makeASTWithMeta(EDefp(name, args, guards, rewriteFieldsAfterCoalesce(pb)), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var pb = processBlock(body);
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, rewriteFieldsAfterCoalesce(pb));
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var pb = processBlock(body);
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, rewriteFieldsAfterCoalesce(pb));
									var meta = n.metadata;
									var pos = n.pos;
									{def : def, metadata : meta, pos : pos};
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function renameSwitchResultVarsPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return n;
			};
			return @:ast(switch (n.def) {
	case EVar(v):
		var newName = rename(v);
		if (newName != v) makeASTWithMeta(EVar(newName), n.metadata, n.pos) else n;	
	case EMatch(pattern, expr):
		var newPat = switch (pattern) {
			case PVar(pn):
				var nn = rename(pn);
				if (nn != pn) PVar(nn) else pattern;			
			default:
				pattern;			
		};
		if (newPat != pattern) makeASTWithMeta(EMatch(newPat, expr), n.metadata, n.pos) else n;	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								var newPat = @:ast(switch (pattern) {
	case PVar(pn):
		var nn = rename(pn);
		if (nn != pn) PVar(nn) else pattern;	
	default:
		pattern;	
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var pn = `;
										{
											var nn = if ((pn != null && pn.length >= 23 && pn.substr(0, 23) == "__elixir_switch_result_")) {
												("switch_result_" + pn.substr(23, null));
											} else {
												pn;
											};
											if (nn != pn) {
												reflaxe.elixir.ast.EPattern.PVar(nn);
											} else {
												pattern;
											};
										};
									};
								} else {
									pattern;
								};
								if (newPat != pattern) {
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(newPat, expr), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var v = `;
							{
								var newName = if ((v != null && v.length >= 23 && v.substr(0, 23) == "__elixir_switch_result_")) {
									("switch_result_" + v.substr(23, null));
								} else {
									v;
								};
								if (newName != v) {
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(newName), metadata : n.metadata, pos : n.pos};
								} else {
									n;
								};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function repoAliasInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		var referencesRepo = function(node:reflaxe.elixir.ast.ElixirAST) {
			var found = [false];
			reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				if (found[0]) {
					return n;
				};
				@:ast(switch (n.def) {
	case ERemoteCall(mod, _, _):
		switch (mod.def) {
			case EVar(m) if (m == "Repo"):
				found = true;			
			default:
		};	
	case ECall(target, _, _) if (target != null):
		switch (target.def) {
			case EVar(m) if (m == "Repo"):
				found = true;			
			default:
		};	
	case ERaw(code) if (code != null && code.indexOf("Repo.") != -1):
		found = true;	
	default:
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var target = `;
								if (target != null) {
									@:ast(switch (target.def) {
	case EVar(m) if (m == "Repo"):
		found = true;	
	default:
}) {
										var ` = target.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													found[0] = true;
												} else {};
											};
										} else {};
									};
								} else {};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var mod = `;
								{
									@:ast(switch (mod.def) {
	case EVar(m) if (m == "Repo"):
		found = true;	
	default:
}) {
										var ` = mod.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											{
												var m = `;
												if (m == "Repo") {
													found[0] = true;
												} else {};
											};
										} else {};
									};
								};
							};
						};
						case 62: {
							var ` = `[0];
							{
								var code = `;
								if (code != null && code.indexOf("Repo.", null) != -1) {
									found[0] = true;
								} else {};
							};
						};
						default: {}
					};
				};
				return n;
			});
			return found[0];
		};
		var hasRepoAlias = function(body:Array<reflaxe.elixir.ast.ElixirAST>, repoModule:String) {
			{
				var ` = 0;
				while (` < body.length) {
					var b = body[`];
					++ `;
					@:ast(switch (b.def) {
	case EAlias(module, as) if (module == repoModule && (as == null || as == "Repo")):
		return true;	
	default:
}) {
						var ` = b.def;
						if (enumIndex ` == 44) {
							var ` = `[0];
							var ` = `[1];
							{
								var module = `;
								var as = `;
								if (module == repoModule && (as == null || as == "Repo")) {
									return true;
								} else {};
							};
						} else {};
					};
				};
			};
			return false;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) {
			try {
				prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			} catch(e:Dynamic) { };
		};
		if (prefix == null) return n;
		var repoModule = prefix + ".Repo";
		if (!referencesRepo(n)) return n;
		if (hasRepoAlias(body, repoModule)) return n;
		var newBody:Array<ElixirAST> = [];
		newBody.push(makeAST(EAlias(repoModule, "Repo")));
		for (b  in  body) newBody.push(b);
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		var prefix = deriveAppPrefix(name);
		if (prefix == null) {
			try {
				prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			} catch(e:Dynamic) { };
		};
		if (prefix == null) return n;
		var repoModule = prefix + ".Repo";
		if (!referencesRepo(n)) return n;
		var newDo = switch (doBlock.def) {
			case EBlock(stmts):
				if (hasRepoAlias(stmts, repoModule)) doBlock else {
					var list = [makeAST(EAlias(repoModule, "Repo"))];
					for (s  in  stmts) list.push(s);
					makeAST(EBlock(list));
				};			
			default:
				makeAST(EBlock([makeAST(EAlias(repoModule, "Repo")), doBlock]));			
		};
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									try {
										prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
								};
								if (prefix == null) {
									return n;
								};
								var repoModule = prefix + ".Repo";
								if (! referencesRepo(n)) {
									return n;
								};
								if (hasRepoAlias(body, repoModule)) {
									return n;
								};
								var newBody = [];
								newBody.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
								});
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(b);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								var prefix = if (name == null) {
									null;
								} else {
									var idx = name.indexOf("Web", null);
									if (idx > 0) {
										name.substring(0, idx);
									} else {
										null;
									};
								};
								if (prefix == null) {
									try {
										prefix = reflaxe.elixir.PhoenixMapper.getAppModuleName();
									} catch (`:Dynamic) {
										{};
										{};
										if (true) {
											{};
											{};
										} else throw `;
									};
								};
								if (prefix == null) {
									return n;
								};
								var repoModule = prefix + ".Repo";
								if (! referencesRepo(n)) {
									return n;
								};
								var newDo = @:ast(switch (doBlock.def) {
	case EBlock(stmts):
		if (hasRepoAlias(stmts, repoModule)) doBlock else {
			var list = [makeAST(EAlias(repoModule, "Repo"))];
			for (s  in  stmts) list.push(s);
			makeAST(EBlock(list));
		};	
	default:
		makeAST(EBlock([makeAST(EAlias(repoModule, "Repo")), doBlock]));	
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var stmts = `;
											{
												if (hasRepoAlias(stmts, repoModule)) {
													doBlock;
												} else {
													var list = [{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
													}];
													{
														var ` = 0;
														while (` < stmts.length) {
															var s = stmts[`];
															++ `;
															list.push(s);
														};
													};
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(list), metadata : {}, pos : pos};
													};
												};
											};
										};
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
											}, doBlock]), metadata : {}, pos : pos};
										};
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function repoAliasInjectionGlobalPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var app = [null];
		reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EModule(name, _, _):
		var idx = name.indexOf(".Repo");
		if (idx > 0) app = name.substring(0, idx);	
	default:
}) {
				var ` = n.def;
				if (enumIndex ` == 0) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var name = `;
						{
							var idx = name.indexOf(".Repo", null);
							if (idx > 0) {
								app[0] = name.substring(0, idx);
							};
						};
					};
				} else {};
			};
			return n;
		});
		if (app[0] == null || app[0].length == 0) {
			try {
				app[0] = reflaxe.elixir.PhoenixMapper.getAppModuleName();
			} catch (`:Dynamic) {
				{};
				{};
				if (true) {
					{};
					{};
				} else throw `;
			};
		};
		if (app[0] == null || app[0].length == 0) {
			return ast;
		};
		var repoModule = app[0] + ".Repo";
		var referencesRepo = function(node:reflaxe.elixir.ast.ElixirAST) {
			var found = [false];
			reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				if (found[0]) {
					return n;
				};
				@:ast(switch (n.def) {
	case ERemoteCall({ def : EVar(m) }, _, _) if (m == "Repo"):
		found = true;	
	case ECall({ def : EVar(m) }, _, _) if (m == "Repo"):
		found = true;	
	default:
}) {
					var ` = n.def;
					switch (enumIndex `) {
						case 22: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							if (` == null) {} else {
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var m = `;
										if (m == "Repo") {
											found[0] = true;
										} else {};
									};
								} else {};
							};
						};
						case 24: {
							var ` = `[0];
							var ` = `[1];
							var ` = `[2];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var m = `;
										if (m == "Repo") {
											found[0] = true;
										} else {};
									};
								} else {};
							};
						};
						default: {}
					};
				};
				return n;
			});
			return found[0];
		};
		var hasRepoAlias = function(body:Array<reflaxe.elixir.ast.ElixirAST>) {
			{
				var ` = 0;
				while (` < body.length) {
					var b = body[`];
					++ `;
					@:ast(switch (b.def) {
	case EAlias(module, as) if (module == repoModule && (as == null || as == "Repo")):
		return true;	
	default:
}) {
						var ` = b.def;
						if (enumIndex ` == 44) {
							var ` = `[0];
							var ` = `[1];
							{
								var module = `;
								var as = `;
								if (module == repoModule && (as == null || as == "Repo")) {
									return true;
								} else {};
							};
						} else {};
					};
				};
			};
			return false;
		};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EModule(name, attrs, body):
		if (!referencesRepo(n) || hasRepoAlias(body)) return n;
		var newBody:Array<ElixirAST> = [];
		newBody.push(makeAST(EAlias(repoModule, "Repo")));
		for (b  in  body) newBody.push(b);
		makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);	
	case EDefmodule(name, doBlock):
		if (!referencesRepo(n)) return n;
		var newDo = switch (doBlock.def) {
			case EBlock(stmts):
				if (hasRepoAlias(stmts)) doBlock else makeAST(EBlock([makeAST(EAlias(repoModule, "Repo"))].concat(stmts)));			
			default:
				makeAST(EBlock([makeAST(EAlias(repoModule, "Repo")), doBlock]));			
		};
		makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							{
								if (! referencesRepo(n) || hasRepoAlias(body)) {
									return n;
								};
								var newBody = [];
								newBody.push({
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
								});
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										newBody.push(b);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								if (! referencesRepo(n)) {
									return n;
								};
								var newDo = @:ast(switch (doBlock.def) {
	case EBlock(stmts):
		if (hasRepoAlias(stmts)) doBlock else makeAST(EBlock([makeAST(EAlias(repoModule, "Repo"))].concat(stmts)));	
	default:
		makeAST(EBlock([makeAST(EAlias(repoModule, "Repo")), doBlock]));	
}) {
									var ` = doBlock.def;
									if (enumIndex ` == 53) {
										var ` = `[0];
										{
											var stmts = `;
											{
												if (hasRepoAlias(stmts)) {
													doBlock;
												} else {
													{
														var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([{
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
														}].concat(stmts));
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													};
												};
											};
										};
									} else {
										{
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([{
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAlias(repoModule, "Repo"), metadata : {}, pos : pos};
											}, doBlock]), metadata : {}, pos : pos};
										};
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, newDo), metadata : n.metadata, pos : n.pos};
							};
						};
					};
					default: {
						n;
					}
				};
			};
		});
	}

	public static function eqNilToIsNilPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EBinary(Equal, left, right):
		switch [left.def, right.def] {
			case [_, ENil]:
				makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [left]));			
			case [ENil, _]:
				makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [right]));			
			default:
				n;			
		};	
	case EBinary(NotEqual, left2, right2):
		switch [left2.def, right2.def] {
			case [_, ENil]:
				var inner = makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [left2]));
				makeAST(ElixirASTDef.EUnary(Not, inner));			
			case [ENil, _]:
				var inner2 = makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [right2]));
				makeAST(ElixirASTDef.EUnary(Not, inner2));			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 26) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 6: {
							{
								var left = `;
								var right = `;
								{
									@:ast(switch [left.def, right.def] {
	case [_, ENil]:
		makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [left]));	
	case [ENil, _]:
		makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [right]));	
	default:
		n;	
}) {
										var ` = left.def;
										var ` = right.def;
										if (enumIndex ` == 36) {
											{
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
													}, "is_nil", [left]), metadata : {}, pos : pos};
												};
											};
										} else if (enumIndex ` == 36) {
											{
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
													}, "is_nil", [right]), metadata : {}, pos : pos};
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						case 7: {
							{
								var left2 = `;
								var right2 = `;
								{
									@:ast(switch [left2.def, right2.def] {
	case [_, ENil]:
		var inner = makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [left2]));
		makeAST(ElixirASTDef.EUnary(Not, inner));	
	case [ENil, _]:
		var inner2 = makeAST(ERemoteCall(makeAST(EVar("Kernel")), "is_nil", [right2]));
		makeAST(ElixirASTDef.EUnary(Not, inner2));	
	default:
		n;	
}) {
										var ` = left2.def;
										var ` = right2.def;
										if (enumIndex ` == 36) {
											{
												var inner = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
													}, "is_nil", [left2]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, inner), metadata : {}, pos : pos};
												};
											};
										} else if (enumIndex ` == 36) {
											{
												var inner2 = {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Kernel"), metadata : {}, pos : pos};
													}, "is_nil", [right2]), metadata : {}, pos : pos};
												};
												{
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, inner2), metadata : {}, pos : pos};
												};
											};
										} else {
											n;
										};
									};
								};
							};
						};
						default: {
							n;
						}
					};
				} else {
					n;
				};
			};
		});
	}

	public static function systemAlertClauseNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EDef(name, args, guards, body) if (name == "handle_info"):
		var newBody = ElixirASTTransformer.transformNode(body, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var updated = false;
						var pat = clause.pattern;
						switch pat {
							case PTuple(elements) if (elements.length == 3):
								var tag = extractAtom(elements[0]);
								if (tag == "system_alert") {
									var third = switch elements[2] {
										case PVar(n):
											n;										
										default:
											null;										
									};
									var newSecond = PVar("message");
									var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
									pat = PTuple([elements[0], newSecond, newThird]);
									var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
										return switch (x.def) {
											case EVar(v) if (v == "flashType"):
												makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);											
											case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
												if (args2.length >= 2) {
													switch (args2[1].def) {
														case EVar(v) if (v == "flashType"):
															var newArgs = args2.copy();
															newArgs[1] = makeAST(EVar("flash_type"));
															return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);														
														default:
													};
												};
												x;											
											default:
												x;											
										};
									});
									newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
									updated = true;
								};							
							default:
						};
						if (!updated) newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDef(name, args, guards, newBody), node.metadata, node.pos);	
	case EDefp(name, args, guards, body) if (name == "handle_info"):
		var newBody = ElixirASTTransformer.transformNode(body, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var updated = false;
						var pat = clause.pattern;
						switch pat {
							case PTuple(elements) if (elements.length == 3):
								var tag = extractAtom(elements[0]);
								if (tag == "system_alert") {
									var third = switch elements[2] {
										case PVar(n):
											n;										
										default:
											null;										
									};
									var newSecond = PVar("message");
									var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
									pat = PTuple([elements[0], newSecond, newThird]);
									var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
										return switch (x.def) {
											case EVar(v) if (v == "flashType"):
												makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);											
											case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
												if (args2.length >= 2) {
													switch (args2[1].def) {
														case EVar(v) if (v == "flashType"):
															var newArgs = args2.copy();
															newArgs[1] = makeAST(EVar("flash_type"));
															return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);														
														default:
													};
												};
												x;											
											default:
												x;											
										};
									});
									newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
									updated = true;
								};							
							default:
						};
						if (!updated) newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefp(name, args, guards, newBody), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							if (name == "handle_info") {
								var newBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var updated = false;
			var pat = clause.pattern;
			switch pat {
				case PTuple(elements) if (elements.length == 3):
					var tag = extractAtom(elements[0]);
					if (tag == "system_alert") {
						var third = switch elements[2] {
							case PVar(n):
								n;							
							default:
								null;							
						};
						var newSecond = PVar("message");
						var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
						pat = PTuple([elements[0], newSecond, newThird]);
						var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
							return switch (x.def) {
								case EVar(v) if (v == "flashType"):
									makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);								
								case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
									if (args2.length >= 2) {
										switch (args2[1].def) {
											case EVar(v) if (v == "flashType"):
												var newArgs = args2.copy();
												newArgs[1] = makeAST(EVar("flash_type"));
												return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);											
											default:
										};
									};
									x;								
								default:
									x;								
							};
						});
						newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
						updated = true;
					};				
				default:
			};
			if (!updated) newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										if (enumIndex ` == 6) {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var clauses = `;
												{
													var newClauses = [];
													{
														var ` = 0;
														while (` < clauses.length) {
															var clause = clauses[`];
															++ `;
															var updated = false;
															var pat = clause.pattern;
															@:ast(switch pat {
	case PTuple(elements) if (elements.length == 3):
		var tag = extractAtom(elements[0]);
		if (tag == "system_alert") {
			var third = switch elements[2] {
				case PVar(n):
					n;				
				default:
					null;				
			};
			var newSecond = PVar("message");
			var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
			pat = PTuple([elements[0], newSecond, newThird]);
			var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
				return switch (x.def) {
					case EVar(v) if (v == "flashType"):
						makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);					
					case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
						if (args2.length >= 2) {
							switch (args2[1].def) {
								case EVar(v) if (v == "flashType"):
									var newArgs = args2.copy();
									newArgs[1] = makeAST(EVar("flash_type"));
									return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);								
								default:
							};
						};
						x;					
					default:
						x;					
				};
			});
			newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
			updated = true;
		};	
	default:
}) if (enumIndex pat == 2) {
																var ` = pat[0];
																{
																	var elements = `;
																	if (elements.length == 3) {
																		var tag = {
																			var pat = elements[0];
																			@:ast(switch (pat) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) if (enumIndex pat == 1) {
																				var ` = pat[0];
																				{
																					var ` = `.def;
																					var ` = `.metadata;
																					var ` = `.pos;
																					if (enumIndex ` == 31) {
																						var ` = `[0];
																						{
																							var a = `;
																							{
																								a;
																							};
																						};
																					} else {
																						null;
																					};
																				};
																			} else {
																				null;
																			};
																		};
																		if (tag == "system_alert") {
																			var third = @:ast(switch elements[2] {
	case PVar(n):
		n;	
	default:
		null;	
}) {
																				var ` = elements[2];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					{
																						var n = `;
																						{
																							n;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																			var newSecond = reflaxe.elixir.ast.EPattern.PVar("message");
																			var newThird = reflaxe.elixir.ast.EPattern.PVar(if (third != null && third != "flash_type") {
																				"flash_type";
																			} else {
																				(if (third == null) {
																					"flash_type";
																				} else {
																					third;
																				});
																			});
																			pat = reflaxe.elixir.ast.EPattern.PTuple([elements[0], newSecond, newThird]);
																			var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(clause.body, function(x:reflaxe.elixir.ast.ElixirAST) {
																				return @:ast(switch (x.def) {
	case EVar(v) if (v == "flashType"):
		makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);	
	case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
		if (args2.length >= 2) {
			switch (args2[1].def) {
				case EVar(v) if (v == "flashType"):
					var newArgs = args2.copy();
					newArgs[1] = makeAST(EVar("flash_type"));
					return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);				
				default:
			};
		};
		x;	
	default:
		x;	
}) {
																					var ` = x.def;
																					switch (enumIndex `) {
																						case 24: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var mod2 = `;
																								var func2 = `;
																								var args2 = `;
																								if (func2 == "put_flash") {
																									if (args2.length >= 2) {
																										@:ast(switch (args2[1].def) {
	case EVar(v) if (v == "flashType"):
		var newArgs = args2.copy();
		newArgs[1] = makeAST(EVar("flash_type"));
		return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);	
	default:
}) {
																											var ` = args2[1].def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var v = `;
																													if (v == "flashType") {
																														var newArgs = args2.copy();
																														newArgs[1] = {
																															var pos = null;
																															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("flash_type"), metadata : {}, pos : pos};
																														};
																														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod2, func2, newArgs), metadata : x.metadata, pos : x.pos};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									x;
																								} else {
																									x;
																								};
																							};
																						};
																						case 38: {
																							var ` = `[0];
																							{
																								var v = `;
																								if (v == "flashType") {
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("flash_type"), metadata : x.metadata, pos : x.pos};
																								} else {
																									x;
																								};
																							};
																						};
																						default: {
																							x;
																						}
																					};
																				};
																			});
																			newClauses.push({pattern : pat, guard : clause.guard, body : fixedBody});
																			updated = true;
																		};
																	} else {};
																};
															} else {};
															if (! updated) {
																newClauses.push(clause);
															};
														};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
												};
											};
										} else {
											n;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, newBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							if (name == "handle_info") {
								var newBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var updated = false;
			var pat = clause.pattern;
			switch pat {
				case PTuple(elements) if (elements.length == 3):
					var tag = extractAtom(elements[0]);
					if (tag == "system_alert") {
						var third = switch elements[2] {
							case PVar(n):
								n;							
							default:
								null;							
						};
						var newSecond = PVar("message");
						var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
						pat = PTuple([elements[0], newSecond, newThird]);
						var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
							return switch (x.def) {
								case EVar(v) if (v == "flashType"):
									makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);								
								case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
									if (args2.length >= 2) {
										switch (args2[1].def) {
											case EVar(v) if (v == "flashType"):
												var newArgs = args2.copy();
												newArgs[1] = makeAST(EVar("flash_type"));
												return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);											
											default:
										};
									};
									x;								
								default:
									x;								
							};
						});
						newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
						updated = true;
					};				
				default:
			};
			if (!updated) newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										if (enumIndex ` == 6) {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var clauses = `;
												{
													var newClauses = [];
													{
														var ` = 0;
														while (` < clauses.length) {
															var clause = clauses[`];
															++ `;
															var updated = false;
															var pat = clause.pattern;
															@:ast(switch pat {
	case PTuple(elements) if (elements.length == 3):
		var tag = extractAtom(elements[0]);
		if (tag == "system_alert") {
			var third = switch elements[2] {
				case PVar(n):
					n;				
				default:
					null;				
			};
			var newSecond = PVar("message");
			var newThird = PVar(third != null && third != "flash_type" ? "flash_type" : (third == null ? "flash_type" : third));
			pat = PTuple([elements[0], newSecond, newThird]);
			var fixedBody = ElixirASTTransformer.transformNode(clause.body, function(x) {
				return switch (x.def) {
					case EVar(v) if (v == "flashType"):
						makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);					
					case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
						if (args2.length >= 2) {
							switch (args2[1].def) {
								case EVar(v) if (v == "flashType"):
									var newArgs = args2.copy();
									newArgs[1] = makeAST(EVar("flash_type"));
									return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);								
								default:
							};
						};
						x;					
					default:
						x;					
				};
			});
			newClauses.push({ pattern : pat, guard : clause.guard, body : fixedBody });
			updated = true;
		};	
	default:
}) if (enumIndex pat == 2) {
																var ` = pat[0];
																{
																	var elements = `;
																	if (elements.length == 3) {
																		var tag = {
																			var pat = elements[0];
																			@:ast(switch (pat) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) if (enumIndex pat == 1) {
																				var ` = pat[0];
																				{
																					var ` = `.def;
																					var ` = `.metadata;
																					var ` = `.pos;
																					if (enumIndex ` == 31) {
																						var ` = `[0];
																						{
																							var a = `;
																							{
																								a;
																							};
																						};
																					} else {
																						null;
																					};
																				};
																			} else {
																				null;
																			};
																		};
																		if (tag == "system_alert") {
																			var third = @:ast(switch elements[2] {
	case PVar(n):
		n;	
	default:
		null;	
}) {
																				var ` = elements[2];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					{
																						var n = `;
																						{
																							n;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																			var newSecond = reflaxe.elixir.ast.EPattern.PVar("message");
																			var newThird = reflaxe.elixir.ast.EPattern.PVar(if (third != null && third != "flash_type") {
																				"flash_type";
																			} else {
																				(if (third == null) {
																					"flash_type";
																				} else {
																					third;
																				});
																			});
																			pat = reflaxe.elixir.ast.EPattern.PTuple([elements[0], newSecond, newThird]);
																			var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(clause.body, function(x:reflaxe.elixir.ast.ElixirAST) {
																				return @:ast(switch (x.def) {
	case EVar(v) if (v == "flashType"):
		makeASTWithMeta(EVar("flash_type"), x.metadata, x.pos);	
	case ERemoteCall(mod2, func2, args2) if (func2 == "put_flash"):
		if (args2.length >= 2) {
			switch (args2[1].def) {
				case EVar(v) if (v == "flashType"):
					var newArgs = args2.copy();
					newArgs[1] = makeAST(EVar("flash_type"));
					return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);				
				default:
			};
		};
		x;	
	default:
		x;	
}) {
																					var ` = x.def;
																					switch (enumIndex `) {
																						case 24: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var mod2 = `;
																								var func2 = `;
																								var args2 = `;
																								if (func2 == "put_flash") {
																									if (args2.length >= 2) {
																										@:ast(switch (args2[1].def) {
	case EVar(v) if (v == "flashType"):
		var newArgs = args2.copy();
		newArgs[1] = makeAST(EVar("flash_type"));
		return makeASTWithMeta(ERemoteCall(mod2, func2, newArgs), x.metadata, x.pos);	
	default:
}) {
																											var ` = args2[1].def;
																											if (enumIndex ` == 38) {
																												var ` = `[0];
																												{
																													var v = `;
																													if (v == "flashType") {
																														var newArgs = args2.copy();
																														newArgs[1] = {
																															var pos = null;
																															{def : reflaxe.elixir.ast.ElixirASTDef.EVar("flash_type"), metadata : {}, pos : pos};
																														};
																														return {def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(mod2, func2, newArgs), metadata : x.metadata, pos : x.pos};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									x;
																								} else {
																									x;
																								};
																							};
																						};
																						case 38: {
																							var ` = `[0];
																							{
																								var v = `;
																								if (v == "flashType") {
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar("flash_type"), metadata : x.metadata, pos : x.pos};
																								} else {
																									x;
																								};
																							};
																						};
																						default: {
																							x;
																						}
																					};
																				};
																			});
																			newClauses.push({pattern : pat, guard : clause.guard, body : fixedBody});
																			updated = true;
																		};
																	} else {};
																};
															} else {};
															if (! updated) {
																newClauses.push(clause);
															};
														};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
												};
											};
										} else {
											n;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, newBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function liveViewCancelEditInlinePresencePass(ast:reflaxe.elixir.ast.ElixirAST) {
		return ast;
	}

	public static function repoResultBinderNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			if (isRepoTuplePattern(clause.pattern)) {
				var binder = extractBinder(clause.pattern);
				if (binder != null) {
					var used = collectUsedLowerVars(clause.body);
					var canon = ["user", "data", "changeset", "reason"];
					var aliases = [for (v  in  used) if (v != binder && canon.indexOf(v) != -1) v];
					if (aliases.length > 0) {
						var assigns = [for (v  in  aliases) makeAST(EMatch(PVar(v), makeAST(EVar(binder))))];
						var newBody = switch (clause.body.def) {
							case EBlock(exprs):
								makeAST(EBlock(assigns.concat(exprs)));							
							default:
								makeAST(EBlock(assigns.concat([clause.body])));							
						};
						newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : newBody });
						continue;
					};
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									if ({
										var p = clause.pattern;
										@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(tag) }) if (tag == "ok" || tag == "error"):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) if (enumIndex p == 2) {
											var ` = p[0];
											{
												var elements = `;
												if (elements.length == 2) {
													@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(tag) }) if (tag == "ok" || tag == "error"):
		true;	
	default:
		false;	
}) {
														var ` = elements[0];
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 31) {
																	var ` = `[0];
																	{
																		var tag = `;
																		if (tag == "ok" || tag == "error") {
																			true;
																		} else {
																			false;
																		};
																	};
																} else {
																	false;
																};
															};
														} else {
															false;
														};
													};
												} else {
													false;
												};
											};
										} else {
											false;
										};
									}) {
										var binder = {
											var p = clause.pattern;
											@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(n):
				n;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
												var ` = p[0];
												{
													var elements = `;
													if (elements.length == 2) {
														@:ast(switch (elements[1]) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
															var ` = elements[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var n = `;
																	{
																		n;
																	};
																};
															} else {
																null;
															};
														};
													} else {
														null;
													};
												};
											} else {
												null;
											};
										};
										if (binder != null) {
											var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
											var canon = ["user", "data", "changeset", "reason"];
											var aliases = {
												var ` = [];
												{
													var ` = 0;
													while (` < used.length) {
														var v = used[`];
														++ `;
														if (v != binder && canon.indexOf(v, null) != -1) {
															`.push(v);
														};
													};
												};
												`;
											};
											if (aliases.length > 0) {
												var assigns = {
													var ` = [];
													{
														var ` = 0;
														while (` < aliases.length) {
															var v = aliases[`];
															++ `;
															`.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v), {
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																}), metadata : {}, pos : pos};
															});
														};
													};
													`;
												};
												var newBody = @:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
													var ` = clause.body.def;
													if (enumIndex ` == 53) {
														var ` = `[0];
														{
															var exprs = `;
															{
																{
																	var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																};
															};
														};
													} else {
														{
															var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														};
													};
												};
												newClauses.push({pattern : clause.pattern, guard : clause.guard, body : newBody});
												continue;
											};
										};
									};
									newClauses.push(clause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function errorReasonAliasInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var pat = clause.pattern;
			var tag:Null<String> = switch (pat) {
				case PTuple(e) if (e.length > 0):
					extractAtom(e[0]);				
				default:
					null;				
			};
			if (tag == "error") {
				var binder = switch (pat) {
					case PTuple(e) if (e.length == 2):
						switch (e[1]) {
							case PVar(n):
								n;							
							default:
								null;							
						};					
					default:
						null;					
				};
				var used = collectUsedLowerVars(clause.body);
				if (binder != null && binder != "reason" && used.indexOf("reason") != -1) {
					var aliasAssign = makeAST(EMatch(PVar("reason"), makeAST(EVar(binder))));
					var newBody = switch (clause.body.def) {
						case EBlock(exprs):
							makeAST(EBlock([aliasAssign].concat(exprs)));						
						default:
							makeAST(EBlock([aliasAssign, clause.body]));						
					};
					newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : newBody });
					continue;
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var pat = clause.pattern;
									var tag = @:ast(switch (pat) {
	case PTuple(e) if (e.length > 0):
		extractAtom(e[0]);	
	default:
		null;	
}) if (enumIndex pat == 2) {
										var ` = pat[0];
										{
											var e = `;
											if (e.length > 0) {
												{
													var pat = e[0];
													@:ast(switch (pat) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) if (enumIndex pat == 1) {
														var ` = pat[0];
														{
															var ` = `.def;
															var ` = `.metadata;
															var ` = `.pos;
															if (enumIndex ` == 31) {
																var ` = `[0];
																{
																	var a = `;
																	{
																		a;
																	};
																};
															} else {
																null;
															};
														};
													} else {
														null;
													};
												};
											} else {
												null;
											};
										};
									} else {
										null;
									};
									if (tag == "error") {
										var binder = @:ast(switch (pat) {
	case PTuple(e) if (e.length == 2):
		switch (e[1]) {
			case PVar(n):
				n;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex pat == 2) {
											var ` = pat[0];
											{
												var e = `;
												if (e.length == 2) {
													@:ast(switch (e[1]) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
														var ` = e[1];
														if (enumIndex ` == 0) {
															var ` = `[0];
															{
																var n = `;
																{
																	n;
																};
															};
														} else {
															null;
														};
													};
												} else {
													null;
												};
											};
										} else {
											null;
										};
										var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
										if (binder != null && binder != "reason" && used.indexOf("reason", null) != -1) {
											var aliasAssign = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("reason"), {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
												}), metadata : {}, pos : pos};
											};
											var newBody = @:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock([aliasAssign].concat(exprs)));	
	default:
		makeAST(EBlock([aliasAssign, clause.body]));	
}) {
												var ` = clause.body.def;
												if (enumIndex ` == 53) {
													var ` = `[0];
													{
														var exprs = `;
														{
															{
																var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([aliasAssign].concat(exprs));
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															};
														};
													};
												} else {
													{
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([aliasAssign, clause.body]), metadata : {}, pos : pos};
													};
												};
											};
											newClauses.push({pattern : clause.pattern, guard : clause.guard, body : newBody});
											continue;
										};
									};
									newClauses.push(clause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function resultErrorBinderLateNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EFn(clauses):
		var newClauses = [];
		for (cl  in  clauses) {
			var fixedBody = ElixirASTTransformer.transformNode(cl.body, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case ECase(target, caseClauses):
						var newCaseClauses = [];
						for (c  in  caseClauses) {
							var tag = tagOf(c.pattern);
							if (tag == "error") {
								var used = collectUsedLowerVars(c.body);
								var usesReason = used.indexOf("reason") != -1;
								var usesChangeset = used.indexOf("changeset") != -1;
								if (usesReason && !usesChangeset) {
									var renamed = renameBinder(c.pattern, "reason");
									newCaseClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
									continue;
								};
							};
							newCaseClauses.push(c);
						};
						makeASTWithMeta(ECase(target, newCaseClauses), n.metadata, n.pos);					
					default:
						n;					
				};
			});
			newClauses.push({ args : cl.args, guard : cl.guard, body : fixedBody });
		};
		makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);	
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if (tag == "error") {
				var used = collectUsedLowerVars(clause.body);
				var usesReason = used.indexOf("reason") != -1;
				var usesChangeset = used.indexOf("changeset") != -1;
				if (usesReason && !usesChangeset) {
					var renamed = renameBinder(clause.pattern, "reason");
					newClauses.push({ pattern : renamed, guard : clause.guard, body : clause.body });
					continue;
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var clauses = `;
							{
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var clause = clauses[`];
										++ `;
										var tag = {
											var p = clause.pattern;
											@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
												var ` = p[0];
												{
													var elements = `;
													if (elements.length >= 1) {
														@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
															var ` = elements[0];
															if (enumIndex ` == 1) {
																var ` = `[0];
																{
																	var ` = `.def;
																	var ` = `.metadata;
																	var ` = `.pos;
																	if (enumIndex ` == 31) {
																		var ` = `[0];
																		{
																			var a = `;
																			{
																				a;
																			};
																		};
																	} else {
																		null;
																	};
																};
															} else {
																null;
															};
														};
													} else {
														null;
													};
												};
											} else {
												null;
											};
										};
										if (tag == "error") {
											var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
											var usesReason = used.indexOf("reason", null) != -1;
											var usesChangeset = used.indexOf("changeset", null) != -1;
											if (usesReason && ! usesChangeset) {
												var renamed = {
													var p = clause.pattern;
													@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
														var ` = p[0];
														{
															var elements = `;
															if (elements.length == 2) {
																@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																	var ` = elements[1];
																	if (enumIndex ` == 0) {
																		var ` = `[0];
																		{
																			reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																		};
																	} else {
																		p;
																	};
																};
															} else {
																p;
															};
														};
													} else {
														p;
													};
												};
												newClauses.push({pattern : renamed, guard : clause.guard, body : clause.body});
												continue;
											};
										};
										newClauses.push(clause);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 42: {
						var ` = `[0];
						{
							var clauses = `;
							{
								var newClauses = [];
								{
									var ` = 0;
									while (` < clauses.length) {
										var cl = clauses[`];
										++ `;
										var fixedBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(cl.body, function(n:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (n.def) {
	case ECase(target, caseClauses):
		var newCaseClauses = [];
		for (c  in  caseClauses) {
			var tag = tagOf(c.pattern);
			if (tag == "error") {
				var used = collectUsedLowerVars(c.body);
				var usesReason = used.indexOf("reason") != -1;
				var usesChangeset = used.indexOf("changeset") != -1;
				if (usesReason && !usesChangeset) {
					var renamed = renameBinder(c.pattern, "reason");
					newCaseClauses.push({ pattern : renamed, guard : c.guard, body : c.body });
					continue;
				};
			};
			newCaseClauses.push(c);
		};
		makeASTWithMeta(ECase(target, newCaseClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
												var ` = n.def;
												if (enumIndex ` == 6) {
													var ` = `[0];
													var ` = `[1];
													{
														var target = `;
														var caseClauses = `;
														{
															var newCaseClauses = [];
															{
																var ` = 0;
																while (` < caseClauses.length) {
																	var c = caseClauses[`];
																	++ `;
																	var tag = {
																		var p = c.pattern;
																		@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																			var ` = p[0];
																			{
																				var elements = `;
																				if (elements.length >= 1) {
																					@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																						var ` = elements[0];
																						if (enumIndex ` == 1) {
																							var ` = `[0];
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 31) {
																									var ` = `[0];
																									{
																										var a = `;
																										{
																											a;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																	if (tag == "error") {
																		var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(c.body);
																		var usesReason = used.indexOf("reason", null) != -1;
																		var usesChangeset = used.indexOf("changeset", null) != -1;
																		if (usesReason && ! usesChangeset) {
																			var renamed = {
																				var p = c.pattern;
																				@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																					var ` = p[0];
																					{
																						var elements = `;
																						if (elements.length == 2) {
																							@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																								var ` = elements[1];
																								if (enumIndex ` == 0) {
																									var ` = `[0];
																									{
																										reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar("reason")]);
																									};
																								} else {
																									p;
																								};
																							};
																						} else {
																							p;
																						};
																					};
																				} else {
																					p;
																				};
																			};
																			newCaseClauses.push({pattern : renamed, guard : c.guard, body : c.body});
																			continue;
																		};
																	};
																	newCaseClauses.push(c);
																};
															};
															{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newCaseClauses), metadata : n.metadata, pos : n.pos};
														};
													};
												} else {
													n;
												};
											};
										});
										newClauses.push({args : cl.args, guard : cl.guard, body : fixedBody});
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function controllerResultBinderNormalizationPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(modName, attrs, body):
		var isCtrl = (modName != null && StringTools.endsWith(modName, "Controller"));
		if (!isCtrl) return node;
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) {
			var tb = ElixirASTTransformer.transformNode(b, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case EDef(name, args, guards, body):
						var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
							return switch (inner.def) {
								case ECase(target, clauses):
									var newClauses = [];
									for (clause  in  clauses) {
										var tag = tagOf(clause.pattern);
										if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
											var desired = tag == "ok" ? "user" : "changeset";
											var renamed = renameBinder(clause.pattern, desired);
											var used = collectUsedLowerVars(clause.body);
											var assigns:Array<ElixirAST> = [];
											if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
											var nb2 = if (assigns.length > 0) switch (clause.body.def) {
												case EBlock(exprs):
													makeAST(EBlock(assigns.concat(exprs)));												
												default:
													makeAST(EBlock(assigns.concat([clause.body])));												
											} else clause.body;
											newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
											continue;
										};
										newClauses.push(clause);
									};
									makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);								
								default:
									inner;								
							};
						});
						makeASTWithMeta(EDef(name, args, guards, nb), n.metadata, n.pos);					
					case EDefp(name, args, guards, body):
						var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
							return switch (inner.def) {
								case ECase(target, clauses):
									var newClauses = [];
									for (clause  in  clauses) {
										var tag = tagOf(clause.pattern);
										if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
											var desired = tag == "ok" ? "user" : "changeset";
											var renamed = renameBinder(clause.pattern, desired);
											var used = collectUsedLowerVars(clause.body);
											var assigns:Array<ElixirAST> = [];
											if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
											var nb2 = if (assigns.length > 0) switch (clause.body.def) {
												case EBlock(exprs):
													makeAST(EBlock(assigns.concat(exprs)));												
												default:
													makeAST(EBlock(assigns.concat([clause.body])));												
											} else clause.body;
											newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
											continue;
										};
										newClauses.push(clause);
									};
									makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);								
								default:
									inner;								
							};
						});
						makeASTWithMeta(EDefp(name, args, guards, nb), n.metadata, n.pos);					
					default:
						n;					
				};
			});
			newBody.push(tb);
		};
		makeASTWithMeta(EModule(modName, attrs, newBody), node.metadata, node.pos);	
	case EDefmodule(modName, doBlock):
		var isCtrl2 = (modName != null && StringTools.endsWith(modName, "Controller"));
		if (!isCtrl2) return node;
		var transformedDo = ElixirASTTransformer.transformNode(doBlock, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case EDef(name, args, guards, body):
					var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
						return switch (inner.def) {
							case ECase(target, clauses):
								var newClauses = [];
								for (clause  in  clauses) {
									var tag = tagOf(clause.pattern);
									if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
										var desired = tag == "ok" ? "user" : "changeset";
										var renamed = renameBinder(clause.pattern, desired);
										var used = collectUsedLowerVars(clause.body);
										var assigns:Array<ElixirAST> = [];
										if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
										if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
										if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
										var nb2 = if (assigns.length > 0) switch (clause.body.def) {
											case EBlock(exprs):
												makeAST(EBlock(assigns.concat(exprs)));											
											default:
												makeAST(EBlock(assigns.concat([clause.body])));											
										} else clause.body;
										newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
										continue;
									};
									newClauses.push(clause);
								};
								makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);							
							default:
								inner;							
						};
					});
					makeASTWithMeta(EDef(name, args, guards, nb), n.metadata, n.pos);				
				case EDefp(name, args, guards, body):
					var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
						return switch (inner.def) {
							case ECase(target, clauses):
								var newClauses = [];
								for (clause  in  clauses) {
									var tag = tagOf(clause.pattern);
									if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
										var desired = tag == "ok" ? "user" : "changeset";
										var renamed = renameBinder(clause.pattern, desired);
										var used = collectUsedLowerVars(clause.body);
										var assigns:Array<ElixirAST> = [];
										if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
										if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
										if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
										var nb2 = if (assigns.length > 0) switch (clause.body.def) {
											case EBlock(exprs):
												makeAST(EBlock(assigns.concat(exprs)));											
											default:
												makeAST(EBlock(assigns.concat([clause.body])));											
										} else clause.body;
										newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
										continue;
									};
									newClauses.push(clause);
								};
								makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);							
							default:
								inner;							
						};
					});
					makeASTWithMeta(EDefp(name, args, guards, nb), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefmodule(modName, transformedDo), node.metadata, node.pos);	
	case EDef(name, args, guards, body):
		var newBody = ElixirASTTransformer.transformNode(body, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && bodyUsesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("data") != -1) {
								assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							};
							var newBody2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : newBody2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDef(name, args, guards, newBody), node.metadata, node.pos);	
	case EDefp(name, args, guards, body):
		var newBody = ElixirASTTransformer.transformNode(body, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && bodyUsesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("data") != -1) {
								assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							};
							var newBody2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : newBody2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefp(name, args, guards, newBody), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var modName = `;
							var attrs = `;
							var body = `;
							{
								var isCtrl = (modName != null && StringTools.endsWith(modName, "Controller"));
								if (! isCtrl) {
									return node;
								};
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										var tb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(n:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
			return switch (inner.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							var nb2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);				
				default:
					inner;				
			};
		});
		makeASTWithMeta(EDef(name, args, guards, nb), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
			return switch (inner.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							var nb2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);				
				default:
					inner;				
			};
		});
		makeASTWithMeta(EDefp(name, args, guards, nb), n.metadata, n.pos);	
	default:
		n;	
}) {
												var ` = n.def;
												switch (enumIndex `) {
													case 2: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														var ` = `[3];
														{
															var name = `;
															var args = `;
															var guards = `;
															var body = `;
															{
																var nb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(inner:reflaxe.elixir.ast.ElixirAST) {
																	return @:ast(switch (inner.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				var nb2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);	
	default:
		inner;	
}) {
																		var ` = inner.def;
																		if (enumIndex ` == 6) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var target = `;
																				var clauses = `;
																				{
																					var newClauses = [];
																					{
																						var ` = 0;
																						while (` < clauses.length) {
																							var clause = clauses[`];
																							++ `;
																							var tag = {
																								var p = clause.pattern;
																								@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																									var ` = p[0];
																									{
																										var elements = `;
																										if (elements.length >= 1) {
																											@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																												var ` = elements[0];
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.def;
																														var ` = `.metadata;
																														var ` = `.pos;
																														if (enumIndex ` == 31) {
																															var ` = `[0];
																															{
																																var a = `;
																																{
																																	a;
																																};
																															};
																														} else {
																															null;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																							if ((tag == "ok" || tag == "error") && {
																								var body = clause.body;
																								var found = [false];
																								var scan = [null];
																								scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																									if (found[0] || n == null || n.def == null) {
																										return;
																									};
																									@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																										var ` = n.def;
																										switch (enumIndex `) {
																											case 6: {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var expr = `;
																													var clauses = `;
																													{
																														scan[0](expr);
																														{
																															var ` = 0;
																															while (` < clauses.length) {
																																var c = clauses[`];
																																++ `;
																																if (c.guard != null) {
																																	scan[0](c.guard);
																																};
																																scan[0](c.body);
																															};
																														};
																													};
																												};
																											};
																											case 10: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var c = `;
																													var t = `;
																													var e = `;
																													{
																														scan[0](c);
																														scan[0](t);
																														if (e != null) {
																															scan[0](e);
																														};
																													};
																												};
																											};
																											case 15: {
																												var ` = `[0];
																												{
																													var items = `;
																													{
																														{
																															var ` = 0;
																															while (` < items.length) {
																																var i = items[`];
																																++ `;
																																scan[0](i);
																															};
																														};
																													};
																												};
																											};
																											case 16: {
																												var ` = `[0];
																												{
																													var items = `;
																													{
																														{
																															var ` = 0;
																															while (` < items.length) {
																																var i = items[`];
																																++ `;
																																scan[0](i);
																															};
																														};
																													};
																												};
																											};
																											case 17: {
																												var ` = `[0];
																												{
																													var pairs = `;
																													{
																														{
																															var ` = 0;
																															while (` < pairs.length) {
																																var p = pairs[`];
																																++ `;
																																scan[0](p.key);
																																scan[0](p.value);
																															};
																														};
																													};
																												};
																											};
																											case 22: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var target = `;
																													var args = `;
																													{
																														if (target != null) {
																															scan[0](target);
																														};
																														{
																															var ` = 0;
																															while (` < args.length) {
																																var a = args[`];
																																++ `;
																																scan[0](a);
																															};
																														};
																													};
																												};
																											};
																											case 24: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var mod = `;
																													var args = `;
																													{
																														@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																															var ` = mod.def;
																															if (enumIndex ` == 38) {
																																var ` = `[0];
																																{
																																	var m = `;
																																	if (m == "Phoenix.Controller") {
																																		found[0] = true;
																																	} else {};
																																};
																															} else {};
																														};
																														if (! found[0]) {
																															scan[0](mod);
																															{
																																var ` = 0;
																																while (` < args.length) {
																																	var a = args[`];
																																	++ `;
																																	scan[0](a);
																																};
																															};
																														};
																													};
																												};
																											};
																											case 26: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var l = `;
																													var r = `;
																													{
																														scan[0](l);
																														scan[0](r);
																													};
																												};
																											};
																											case 27: {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var x = `;
																													{
																														scan[0](x);
																													};
																												};
																											};
																											case 53: {
																												var ` = `[0];
																												{
																													var exprs = `;
																													{
																														{
																															var ` = 0;
																															while (` < exprs.length) {
																																var e = exprs[`];
																																++ `;
																																scan[0](e);
																															};
																														};
																													};
																												};
																											};
																											case 54: {
																												var ` = `[0];
																												{
																													var x = `;
																													{
																														scan[0](x);
																													};
																												};
																											};
																											default: {}
																										};
																									};
																								};
																								scan[0](body);
																								found[0];
																							}) {
																								var desired = if (tag == "ok") {
																									"user";
																								} else {
																									"changeset";
																								};
																								var renamed = {
																									var p = clause.pattern;
																									@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																										var ` = p[0];
																										{
																											var elements = `;
																											if (elements.length == 2) {
																												@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																													var ` = elements[1];
																													if (enumIndex ` == 0) {
																														var ` = `[0];
																														{
																															reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																														};
																													} else {
																														p;
																													};
																												};
																											} else {
																												p;
																											};
																										};
																									} else {
																										p;
																									};
																								};
																								var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																								var assigns = [];
																								if (used.indexOf("data", null) != -1) {
																									assigns.push({
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																										}), metadata : {}, pos : pos};
																									});
																								};
																								var nb2 = if (assigns.length > 0) {
																									@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																										var ` = clause.body.def;
																										if (enumIndex ` == 53) {
																											var ` = `[0];
																											{
																												var exprs = `;
																												{
																													{
																														var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																														var pos = null;
																														{def : def, metadata : {}, pos : pos};
																													};
																												};
																											};
																										} else {
																											{
																												var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																												var pos = null;
																												{def : def, metadata : {}, pos : pos};
																											};
																										};
																									};
																								} else {
																									clause.body;
																								};
																								newClauses.push({pattern : renamed, guard : clause.guard, body : nb2});
																								continue;
																							};
																							newClauses.push(clause);
																						};
																					};
																					{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : inner.metadata, pos : inner.pos};
																				};
																			};
																		} else {
																			inner;
																		};
																	};
																});
																{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, nb), metadata : n.metadata, pos : n.pos};
															};
														};
													};
													case 3: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														var ` = `[3];
														{
															var name = `;
															var args = `;
															var guards = `;
															var body = `;
															{
																var nb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(inner:reflaxe.elixir.ast.ElixirAST) {
																	return @:ast(switch (inner.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				var nb2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);	
	default:
		inner;	
}) {
																		var ` = inner.def;
																		if (enumIndex ` == 6) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var target = `;
																				var clauses = `;
																				{
																					var newClauses = [];
																					{
																						var ` = 0;
																						while (` < clauses.length) {
																							var clause = clauses[`];
																							++ `;
																							var tag = {
																								var p = clause.pattern;
																								@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																									var ` = p[0];
																									{
																										var elements = `;
																										if (elements.length >= 1) {
																											@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																												var ` = elements[0];
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.def;
																														var ` = `.metadata;
																														var ` = `.pos;
																														if (enumIndex ` == 31) {
																															var ` = `[0];
																															{
																																var a = `;
																																{
																																	a;
																																};
																															};
																														} else {
																															null;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																							if ((tag == "ok" || tag == "error") && {
																								var body = clause.body;
																								var found = [false];
																								var scan = [null];
																								scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																									if (found[0] || n == null || n.def == null) {
																										return;
																									};
																									@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																										var ` = n.def;
																										switch (enumIndex `) {
																											case 6: {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var expr = `;
																													var clauses = `;
																													{
																														scan[0](expr);
																														{
																															var ` = 0;
																															while (` < clauses.length) {
																																var c = clauses[`];
																																++ `;
																																if (c.guard != null) {
																																	scan[0](c.guard);
																																};
																																scan[0](c.body);
																															};
																														};
																													};
																												};
																											};
																											case 10: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var c = `;
																													var t = `;
																													var e = `;
																													{
																														scan[0](c);
																														scan[0](t);
																														if (e != null) {
																															scan[0](e);
																														};
																													};
																												};
																											};
																											case 15: {
																												var ` = `[0];
																												{
																													var items = `;
																													{
																														{
																															var ` = 0;
																															while (` < items.length) {
																																var i = items[`];
																																++ `;
																																scan[0](i);
																															};
																														};
																													};
																												};
																											};
																											case 16: {
																												var ` = `[0];
																												{
																													var items = `;
																													{
																														{
																															var ` = 0;
																															while (` < items.length) {
																																var i = items[`];
																																++ `;
																																scan[0](i);
																															};
																														};
																													};
																												};
																											};
																											case 17: {
																												var ` = `[0];
																												{
																													var pairs = `;
																													{
																														{
																															var ` = 0;
																															while (` < pairs.length) {
																																var p = pairs[`];
																																++ `;
																																scan[0](p.key);
																																scan[0](p.value);
																															};
																														};
																													};
																												};
																											};
																											case 22: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var target = `;
																													var args = `;
																													{
																														if (target != null) {
																															scan[0](target);
																														};
																														{
																															var ` = 0;
																															while (` < args.length) {
																																var a = args[`];
																																++ `;
																																scan[0](a);
																															};
																														};
																													};
																												};
																											};
																											case 24: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var mod = `;
																													var args = `;
																													{
																														@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																															var ` = mod.def;
																															if (enumIndex ` == 38) {
																																var ` = `[0];
																																{
																																	var m = `;
																																	if (m == "Phoenix.Controller") {
																																		found[0] = true;
																																	} else {};
																																};
																															} else {};
																														};
																														if (! found[0]) {
																															scan[0](mod);
																															{
																																var ` = 0;
																																while (` < args.length) {
																																	var a = args[`];
																																	++ `;
																																	scan[0](a);
																																};
																															};
																														};
																													};
																												};
																											};
																											case 26: {
																												var ` = `[0];
																												var ` = `[1];
																												var ` = `[2];
																												{
																													var l = `;
																													var r = `;
																													{
																														scan[0](l);
																														scan[0](r);
																													};
																												};
																											};
																											case 27: {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var x = `;
																													{
																														scan[0](x);
																													};
																												};
																											};
																											case 53: {
																												var ` = `[0];
																												{
																													var exprs = `;
																													{
																														{
																															var ` = 0;
																															while (` < exprs.length) {
																																var e = exprs[`];
																																++ `;
																																scan[0](e);
																															};
																														};
																													};
																												};
																											};
																											case 54: {
																												var ` = `[0];
																												{
																													var x = `;
																													{
																														scan[0](x);
																													};
																												};
																											};
																											default: {}
																										};
																									};
																								};
																								scan[0](body);
																								found[0];
																							}) {
																								var desired = if (tag == "ok") {
																									"user";
																								} else {
																									"changeset";
																								};
																								var renamed = {
																									var p = clause.pattern;
																									@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																										var ` = p[0];
																										{
																											var elements = `;
																											if (elements.length == 2) {
																												@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																													var ` = elements[1];
																													if (enumIndex ` == 0) {
																														var ` = `[0];
																														{
																															reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																														};
																													} else {
																														p;
																													};
																												};
																											} else {
																												p;
																											};
																										};
																									} else {
																										p;
																									};
																								};
																								var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																								var assigns = [];
																								if (used.indexOf("data", null) != -1) {
																									assigns.push({
																										var pos = null;
																										{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																										}), metadata : {}, pos : pos};
																									});
																								};
																								var nb2 = if (assigns.length > 0) {
																									@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																										var ` = clause.body.def;
																										if (enumIndex ` == 53) {
																											var ` = `[0];
																											{
																												var exprs = `;
																												{
																													{
																														var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																														var pos = null;
																														{def : def, metadata : {}, pos : pos};
																													};
																												};
																											};
																										} else {
																											{
																												var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																												var pos = null;
																												{def : def, metadata : {}, pos : pos};
																											};
																										};
																									};
																								} else {
																									clause.body;
																								};
																								newClauses.push({pattern : renamed, guard : clause.guard, body : nb2});
																								continue;
																							};
																							newClauses.push(clause);
																						};
																					};
																					{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : inner.metadata, pos : inner.pos};
																				};
																			};
																		} else {
																			inner;
																		};
																	};
																});
																{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, nb), metadata : n.metadata, pos : n.pos};
															};
														};
													};
													default: {
														n;
													}
												};
											};
										});
										newBody.push(tb);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(modName, attrs, newBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var modName = `;
							var doBlock = `;
							{
								var isCtrl2 = (modName != null && StringTools.endsWith(modName, "Controller"));
								if (! isCtrl2) {
									return node;
								};
								var transformedDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case EDef(name, args, guards, body):
		var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
			return switch (inner.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
							if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
							if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							var nb2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);				
				default:
					inner;				
			};
		});
		makeASTWithMeta(EDef(name, args, guards, nb), n.metadata, n.pos);	
	case EDefp(name, args, guards, body):
		var nb = ElixirASTTransformer.transformNode(body, function(inner:ElixirAST):ElixirAST {
			return switch (inner.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
							var desired = tag == "ok" ? "user" : "changeset";
							var renamed = renameBinder(clause.pattern, desired);
							var used = collectUsedLowerVars(clause.body);
							var assigns:Array<ElixirAST> = [];
							if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
							if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
							if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
							var nb2 = if (assigns.length > 0) switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							} else clause.body;
							newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);				
				default:
					inner;				
			};
		});
		makeASTWithMeta(EDefp(name, args, guards, nb), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										switch (enumIndex `) {
											case 2: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												var ` = `[3];
												{
													var name = `;
													var args = `;
													var guards = `;
													var body = `;
													{
														var nb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(inner:reflaxe.elixir.ast.ElixirAST) {
															return @:ast(switch (inner.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
				if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
				if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				var nb2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);	
	default:
		inner;	
}) {
																var ` = inner.def;
																if (enumIndex ` == 6) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var target = `;
																		var clauses = `;
																		{
																			var newClauses = [];
																			{
																				var ` = 0;
																				while (` < clauses.length) {
																					var clause = clauses[`];
																					++ `;
																					var tag = {
																						var p = clause.pattern;
																						@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																							var ` = p[0];
																							{
																								var elements = `;
																								if (elements.length >= 1) {
																									@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																										var ` = elements[0];
																										if (enumIndex ` == 1) {
																											var ` = `[0];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 31) {
																													var ` = `[0];
																													{
																														var a = `;
																														{
																															a;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																					if ((tag == "ok" || tag == "error") && {
																						var body = clause.body;
																						var found = [false];
																						var scan = [null];
																						scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																							if (found[0] || n == null || n.def == null) {
																								return;
																							};
																							@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																								var ` = n.def;
																								switch (enumIndex `) {
																									case 6: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var expr = `;
																											var clauses = `;
																											{
																												scan[0](expr);
																												{
																													var ` = 0;
																													while (` < clauses.length) {
																														var c = clauses[`];
																														++ `;
																														if (c.guard != null) {
																															scan[0](c.guard);
																														};
																														scan[0](c.body);
																													};
																												};
																											};
																										};
																									};
																									case 10: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var c = `;
																											var t = `;
																											var e = `;
																											{
																												scan[0](c);
																												scan[0](t);
																												if (e != null) {
																													scan[0](e);
																												};
																											};
																										};
																									};
																									case 15: {
																										var ` = `[0];
																										{
																											var items = `;
																											{
																												{
																													var ` = 0;
																													while (` < items.length) {
																														var i = items[`];
																														++ `;
																														scan[0](i);
																													};
																												};
																											};
																										};
																									};
																									case 16: {
																										var ` = `[0];
																										{
																											var items = `;
																											{
																												{
																													var ` = 0;
																													while (` < items.length) {
																														var i = items[`];
																														++ `;
																														scan[0](i);
																													};
																												};
																											};
																										};
																									};
																									case 17: {
																										var ` = `[0];
																										{
																											var pairs = `;
																											{
																												{
																													var ` = 0;
																													while (` < pairs.length) {
																														var p = pairs[`];
																														++ `;
																														scan[0](p.key);
																														scan[0](p.value);
																													};
																												};
																											};
																										};
																									};
																									case 22: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var target = `;
																											var args = `;
																											{
																												if (target != null) {
																													scan[0](target);
																												};
																												{
																													var ` = 0;
																													while (` < args.length) {
																														var a = args[`];
																														++ `;
																														scan[0](a);
																													};
																												};
																											};
																										};
																									};
																									case 24: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var mod = `;
																											var args = `;
																											{
																												@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																													var ` = mod.def;
																													if (enumIndex ` == 38) {
																														var ` = `[0];
																														{
																															var m = `;
																															if (m == "Phoenix.Controller") {
																																found[0] = true;
																															} else {};
																														};
																													} else {};
																												};
																												if (! found[0]) {
																													scan[0](mod);
																													{
																														var ` = 0;
																														while (` < args.length) {
																															var a = args[`];
																															++ `;
																															scan[0](a);
																														};
																													};
																												};
																											};
																										};
																									};
																									case 26: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var l = `;
																											var r = `;
																											{
																												scan[0](l);
																												scan[0](r);
																											};
																										};
																									};
																									case 27: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var x = `;
																											{
																												scan[0](x);
																											};
																										};
																									};
																									case 53: {
																										var ` = `[0];
																										{
																											var exprs = `;
																											{
																												{
																													var ` = 0;
																													while (` < exprs.length) {
																														var e = exprs[`];
																														++ `;
																														scan[0](e);
																													};
																												};
																											};
																										};
																									};
																									case 54: {
																										var ` = `[0];
																										{
																											var x = `;
																											{
																												scan[0](x);
																											};
																										};
																									};
																									default: {}
																								};
																							};
																						};
																						scan[0](body);
																						found[0];
																					}) {
																						var desired = if (tag == "ok") {
																							"user";
																						} else {
																							"changeset";
																						};
																						var renamed = {
																							var p = clause.pattern;
																							@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																								var ` = p[0];
																								{
																									var elements = `;
																									if (elements.length == 2) {
																										@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																											var ` = elements[1];
																											if (enumIndex ` == 0) {
																												var ` = `[0];
																												{
																													reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																												};
																											} else {
																												p;
																											};
																										};
																									} else {
																										p;
																									};
																								};
																							} else {
																								p;
																							};
																						};
																						var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																						var assigns = [];
																						if (used.indexOf("user", null) != -1 && desired != "user") {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("user"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						if (used.indexOf("changeset", null) != -1 && desired != "changeset") {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("changeset"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						if (used.indexOf("data", null) != -1) {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						var nb2 = if (assigns.length > 0) {
																							@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																								var ` = clause.body.def;
																								if (enumIndex ` == 53) {
																									var ` = `[0];
																									{
																										var exprs = `;
																										{
																											{
																												var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																												var pos = null;
																												{def : def, metadata : {}, pos : pos};
																											};
																										};
																									};
																								} else {
																									{
																										var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																										var pos = null;
																										{def : def, metadata : {}, pos : pos};
																									};
																								};
																							};
																						} else {
																							clause.body;
																						};
																						newClauses.push({pattern : renamed, guard : clause.guard, body : nb2});
																						continue;
																					};
																					newClauses.push(clause);
																				};
																			};
																			{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : inner.metadata, pos : inner.pos};
																		};
																	};
																} else {
																	inner;
																};
															};
														});
														{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, nb), metadata : n.metadata, pos : n.pos};
													};
												};
											};
											case 3: {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												var ` = `[3];
												{
													var name = `;
													var args = `;
													var guards = `;
													var body = `;
													{
														var nb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(inner:reflaxe.elixir.ast.ElixirAST) {
															return @:ast(switch (inner.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && usesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("user") != -1 && desired != "user") assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(desired)))));
				if (used.indexOf("changeset") != -1 && desired != "changeset") assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(desired)))));
				if (used.indexOf("data") != -1) assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				var nb2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : nb2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), inner.metadata, inner.pos);	
	default:
		inner;	
}) {
																var ` = inner.def;
																if (enumIndex ` == 6) {
																	var ` = `[0];
																	var ` = `[1];
																	{
																		var target = `;
																		var clauses = `;
																		{
																			var newClauses = [];
																			{
																				var ` = 0;
																				while (` < clauses.length) {
																					var clause = clauses[`];
																					++ `;
																					var tag = {
																						var p = clause.pattern;
																						@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																							var ` = p[0];
																							{
																								var elements = `;
																								if (elements.length >= 1) {
																									@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																										var ` = elements[0];
																										if (enumIndex ` == 1) {
																											var ` = `[0];
																											{
																												var ` = `.def;
																												var ` = `.metadata;
																												var ` = `.pos;
																												if (enumIndex ` == 31) {
																													var ` = `[0];
																													{
																														var a = `;
																														{
																															a;
																														};
																													};
																												} else {
																													null;
																												};
																											};
																										} else {
																											null;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																					if ((tag == "ok" || tag == "error") && {
																						var body = clause.body;
																						var found = [false];
																						var scan = [null];
																						scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																							if (found[0] || n == null || n.def == null) {
																								return;
																							};
																							@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																								var ` = n.def;
																								switch (enumIndex `) {
																									case 6: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var expr = `;
																											var clauses = `;
																											{
																												scan[0](expr);
																												{
																													var ` = 0;
																													while (` < clauses.length) {
																														var c = clauses[`];
																														++ `;
																														if (c.guard != null) {
																															scan[0](c.guard);
																														};
																														scan[0](c.body);
																													};
																												};
																											};
																										};
																									};
																									case 10: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var c = `;
																											var t = `;
																											var e = `;
																											{
																												scan[0](c);
																												scan[0](t);
																												if (e != null) {
																													scan[0](e);
																												};
																											};
																										};
																									};
																									case 15: {
																										var ` = `[0];
																										{
																											var items = `;
																											{
																												{
																													var ` = 0;
																													while (` < items.length) {
																														var i = items[`];
																														++ `;
																														scan[0](i);
																													};
																												};
																											};
																										};
																									};
																									case 16: {
																										var ` = `[0];
																										{
																											var items = `;
																											{
																												{
																													var ` = 0;
																													while (` < items.length) {
																														var i = items[`];
																														++ `;
																														scan[0](i);
																													};
																												};
																											};
																										};
																									};
																									case 17: {
																										var ` = `[0];
																										{
																											var pairs = `;
																											{
																												{
																													var ` = 0;
																													while (` < pairs.length) {
																														var p = pairs[`];
																														++ `;
																														scan[0](p.key);
																														scan[0](p.value);
																													};
																												};
																											};
																										};
																									};
																									case 22: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var target = `;
																											var args = `;
																											{
																												if (target != null) {
																													scan[0](target);
																												};
																												{
																													var ` = 0;
																													while (` < args.length) {
																														var a = args[`];
																														++ `;
																														scan[0](a);
																													};
																												};
																											};
																										};
																									};
																									case 24: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var mod = `;
																											var args = `;
																											{
																												@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																													var ` = mod.def;
																													if (enumIndex ` == 38) {
																														var ` = `[0];
																														{
																															var m = `;
																															if (m == "Phoenix.Controller") {
																																found[0] = true;
																															} else {};
																														};
																													} else {};
																												};
																												if (! found[0]) {
																													scan[0](mod);
																													{
																														var ` = 0;
																														while (` < args.length) {
																															var a = args[`];
																															++ `;
																															scan[0](a);
																														};
																													};
																												};
																											};
																										};
																									};
																									case 26: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										{
																											var l = `;
																											var r = `;
																											{
																												scan[0](l);
																												scan[0](r);
																											};
																										};
																									};
																									case 27: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var x = `;
																											{
																												scan[0](x);
																											};
																										};
																									};
																									case 53: {
																										var ` = `[0];
																										{
																											var exprs = `;
																											{
																												{
																													var ` = 0;
																													while (` < exprs.length) {
																														var e = exprs[`];
																														++ `;
																														scan[0](e);
																													};
																												};
																											};
																										};
																									};
																									case 54: {
																										var ` = `[0];
																										{
																											var x = `;
																											{
																												scan[0](x);
																											};
																										};
																									};
																									default: {}
																								};
																							};
																						};
																						scan[0](body);
																						found[0];
																					}) {
																						var desired = if (tag == "ok") {
																							"user";
																						} else {
																							"changeset";
																						};
																						var renamed = {
																							var p = clause.pattern;
																							@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																								var ` = p[0];
																								{
																									var elements = `;
																									if (elements.length == 2) {
																										@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																											var ` = elements[1];
																											if (enumIndex ` == 0) {
																												var ` = `[0];
																												{
																													reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																												};
																											} else {
																												p;
																											};
																										};
																									} else {
																										p;
																									};
																								};
																							} else {
																								p;
																							};
																						};
																						var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																						var assigns = [];
																						if (used.indexOf("user", null) != -1 && desired != "user") {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("user"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						if (used.indexOf("changeset", null) != -1 && desired != "changeset") {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("changeset"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						if (used.indexOf("data", null) != -1) {
																							assigns.push({
																								var pos = null;
																								{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																								}), metadata : {}, pos : pos};
																							});
																						};
																						var nb2 = if (assigns.length > 0) {
																							@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																								var ` = clause.body.def;
																								if (enumIndex ` == 53) {
																									var ` = `[0];
																									{
																										var exprs = `;
																										{
																											{
																												var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																												var pos = null;
																												{def : def, metadata : {}, pos : pos};
																											};
																										};
																									};
																								} else {
																									{
																										var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																										var pos = null;
																										{def : def, metadata : {}, pos : pos};
																									};
																								};
																							};
																						} else {
																							clause.body;
																						};
																						newClauses.push({pattern : renamed, guard : clause.guard, body : nb2});
																						continue;
																					};
																					newClauses.push(clause);
																				};
																			};
																			{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : inner.metadata, pos : inner.pos};
																		};
																	};
																} else {
																	inner;
																};
															};
														});
														{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, nb), metadata : n.metadata, pos : n.pos};
													};
												};
											};
											default: {
												n;
											}
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(modName, transformedDo), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && bodyUsesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("data") != -1) {
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				};
				var newBody2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : newBody2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										if (enumIndex ` == 6) {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var clauses = `;
												{
													var newClauses = [];
													{
														var ` = 0;
														while (` < clauses.length) {
															var clause = clauses[`];
															++ `;
															var tag = {
																var p = clause.pattern;
																@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																	var ` = p[0];
																	{
																		var elements = `;
																		if (elements.length >= 1) {
																			@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																				var ` = elements[0];
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 31) {
																							var ` = `[0];
																							{
																								var a = `;
																								{
																									a;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
															if ((tag == "ok" || tag == "error") && {
																var b = clause.body;
																{
																	var found = [false];
																	var scan = [null];
																	scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																		if (found[0] || n == null || n.def == null) {
																			return;
																		};
																		@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																			var ` = n.def;
																			switch (enumIndex `) {
																				case 6: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var expr = `;
																						var clauses = `;
																						{
																							scan[0](expr);
																							{
																								var ` = 0;
																								while (` < clauses.length) {
																									var c = clauses[`];
																									++ `;
																									if (c.guard != null) {
																										scan[0](c.guard);
																									};
																									scan[0](c.body);
																								};
																							};
																						};
																					};
																				};
																				case 10: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var c = `;
																						var t = `;
																						var e = `;
																						{
																							scan[0](c);
																							scan[0](t);
																							if (e != null) {
																								scan[0](e);
																							};
																						};
																					};
																				};
																				case 15: {
																					var ` = `[0];
																					{
																						var items = `;
																						{
																							{
																								var ` = 0;
																								while (` < items.length) {
																									var i = items[`];
																									++ `;
																									scan[0](i);
																								};
																							};
																						};
																					};
																				};
																				case 16: {
																					var ` = `[0];
																					{
																						var items = `;
																						{
																							{
																								var ` = 0;
																								while (` < items.length) {
																									var i = items[`];
																									++ `;
																									scan[0](i);
																								};
																							};
																						};
																					};
																				};
																				case 17: {
																					var ` = `[0];
																					{
																						var pairs = `;
																						{
																							{
																								var ` = 0;
																								while (` < pairs.length) {
																									var p = pairs[`];
																									++ `;
																									scan[0](p.key);
																									scan[0](p.value);
																								};
																							};
																						};
																					};
																				};
																				case 22: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var target = `;
																						var args = `;
																						{
																							if (target != null) {
																								scan[0](target);
																							};
																							{
																								var ` = 0;
																								while (` < args.length) {
																									var a = args[`];
																									++ `;
																									scan[0](a);
																								};
																							};
																						};
																					};
																				};
																				case 24: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var mod = `;
																						var args = `;
																						{
																							@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																								var ` = mod.def;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var m = `;
																										if (m == "Phoenix.Controller") {
																											found[0] = true;
																										} else {};
																									};
																								} else {};
																							};
																							if (! found[0]) {
																								scan[0](mod);
																								{
																									var ` = 0;
																									while (` < args.length) {
																										var a = args[`];
																										++ `;
																										scan[0](a);
																									};
																								};
																							};
																						};
																					};
																				};
																				case 26: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var l = `;
																						var r = `;
																						{
																							scan[0](l);
																							scan[0](r);
																						};
																					};
																				};
																				case 27: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var x = `;
																						{
																							scan[0](x);
																						};
																					};
																				};
																				case 53: {
																					var ` = `[0];
																					{
																						var exprs = `;
																						{
																							{
																								var ` = 0;
																								while (` < exprs.length) {
																									var e = exprs[`];
																									++ `;
																									scan[0](e);
																								};
																							};
																						};
																					};
																				};
																				case 54: {
																					var ` = `[0];
																					{
																						var x = `;
																						{
																							scan[0](x);
																						};
																					};
																				};
																				default: {}
																			};
																		};
																	};
																	scan[0](b);
																	found[0];
																};
															}) {
																var desired = if (tag == "ok") {
																	"user";
																} else {
																	"changeset";
																};
																var renamed = {
																	var p = clause.pattern;
																	@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																		var ` = p[0];
																		{
																			var elements = `;
																			if (elements.length == 2) {
																				@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																					var ` = elements[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						{
																							reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																						};
																					} else {
																						p;
																					};
																				};
																			} else {
																				p;
																			};
																		};
																	} else {
																		p;
																	};
																};
																var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																var assigns = [];
																if (used.indexOf("data", null) != -1) {
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																};
																var newBody2 = if (assigns.length > 0) {
																	@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																		var ` = clause.body.def;
																		if (enumIndex ` == 53) {
																			var ` = `[0];
																			{
																				var exprs = `;
																				{
																					{
																						var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					};
																				};
																			};
																		} else {
																			{
																				var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																				var pos = null;
																				{def : def, metadata : {}, pos : pos};
																			};
																		};
																	};
																} else {
																	clause.body;
																};
																newClauses.push({pattern : renamed, guard : clause.guard, body : newBody2});
																continue;
															};
															newClauses.push(clause);
														};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
												};
											};
										} else {
											n;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, newBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								var newBody = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && bodyUsesPhoenixController(clause.body)) {
				var desired = tag == "ok" ? "user" : "changeset";
				var renamed = renameBinder(clause.pattern, desired);
				var used = collectUsedLowerVars(clause.body);
				var assigns:Array<ElixirAST> = [];
				if (used.indexOf("data") != -1) {
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(desired)))));
				};
				var newBody2 = if (assigns.length > 0) switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				} else clause.body;
				newClauses.push({ pattern : renamed, guard : clause.guard, body : newBody2 });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										if (enumIndex ` == 6) {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var clauses = `;
												{
													var newClauses = [];
													{
														var ` = 0;
														while (` < clauses.length) {
															var clause = clauses[`];
															++ `;
															var tag = {
																var p = clause.pattern;
																@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																	var ` = p[0];
																	{
																		var elements = `;
																		if (elements.length >= 1) {
																			@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																				var ` = elements[0];
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 31) {
																							var ` = `[0];
																							{
																								var a = `;
																								{
																									a;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
															if ((tag == "ok" || tag == "error") && {
																var b = clause.body;
																{
																	var found = [false];
																	var scan = [null];
																	scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
																		if (found[0] || n == null || n.def == null) {
																			return;
																		};
																		@:ast(switch (n.def) {
	case ERemoteCall(mod, _, args):
		switch (mod.def) {
			case EVar(m) if (m == "Phoenix.Controller"):
				found = true;			
			default:
		};
		if (!found) {
			scan(mod);
			for (a  in  args) scan(a);
		};	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECall(target, _, args):
		if (target != null) scan(target);
		for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	case EUnary(_, x):
		scan(x);	
	case EBinary(_, l, r):
		scan(l);
		scan(r);	
	case EParen(x):
		scan(x);	
	default:
}) {
																			var ` = n.def;
																			switch (enumIndex `) {
																				case 6: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var expr = `;
																						var clauses = `;
																						{
																							scan[0](expr);
																							{
																								var ` = 0;
																								while (` < clauses.length) {
																									var c = clauses[`];
																									++ `;
																									if (c.guard != null) {
																										scan[0](c.guard);
																									};
																									scan[0](c.body);
																								};
																							};
																						};
																					};
																				};
																				case 10: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var c = `;
																						var t = `;
																						var e = `;
																						{
																							scan[0](c);
																							scan[0](t);
																							if (e != null) {
																								scan[0](e);
																							};
																						};
																					};
																				};
																				case 15: {
																					var ` = `[0];
																					{
																						var items = `;
																						{
																							{
																								var ` = 0;
																								while (` < items.length) {
																									var i = items[`];
																									++ `;
																									scan[0](i);
																								};
																							};
																						};
																					};
																				};
																				case 16: {
																					var ` = `[0];
																					{
																						var items = `;
																						{
																							{
																								var ` = 0;
																								while (` < items.length) {
																									var i = items[`];
																									++ `;
																									scan[0](i);
																								};
																							};
																						};
																					};
																				};
																				case 17: {
																					var ` = `[0];
																					{
																						var pairs = `;
																						{
																							{
																								var ` = 0;
																								while (` < pairs.length) {
																									var p = pairs[`];
																									++ `;
																									scan[0](p.key);
																									scan[0](p.value);
																								};
																							};
																						};
																					};
																				};
																				case 22: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var target = `;
																						var args = `;
																						{
																							if (target != null) {
																								scan[0](target);
																							};
																							{
																								var ` = 0;
																								while (` < args.length) {
																									var a = args[`];
																									++ `;
																									scan[0](a);
																								};
																							};
																						};
																					};
																				};
																				case 24: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var mod = `;
																						var args = `;
																						{
																							@:ast(switch (mod.def) {
	case EVar(m) if (m == "Phoenix.Controller"):
		found = true;	
	default:
}) {
																								var ` = mod.def;
																								if (enumIndex ` == 38) {
																									var ` = `[0];
																									{
																										var m = `;
																										if (m == "Phoenix.Controller") {
																											found[0] = true;
																										} else {};
																									};
																								} else {};
																							};
																							if (! found[0]) {
																								scan[0](mod);
																								{
																									var ` = 0;
																									while (` < args.length) {
																										var a = args[`];
																										++ `;
																										scan[0](a);
																									};
																								};
																							};
																						};
																					};
																				};
																				case 26: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var l = `;
																						var r = `;
																						{
																							scan[0](l);
																							scan[0](r);
																						};
																					};
																				};
																				case 27: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var x = `;
																						{
																							scan[0](x);
																						};
																					};
																				};
																				case 53: {
																					var ` = `[0];
																					{
																						var exprs = `;
																						{
																							{
																								var ` = 0;
																								while (` < exprs.length) {
																									var e = exprs[`];
																									++ `;
																									scan[0](e);
																								};
																							};
																						};
																					};
																				};
																				case 54: {
																					var ` = `[0];
																					{
																						var x = `;
																						{
																							scan[0](x);
																						};
																					};
																				};
																				default: {}
																			};
																		};
																	};
																	scan[0](b);
																	found[0];
																};
															}) {
																var desired = if (tag == "ok") {
																	"user";
																} else {
																	"changeset";
																};
																var renamed = {
																	var p = clause.pattern;
																	@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
																		var ` = p[0];
																		{
																			var elements = `;
																			if (elements.length == 2) {
																				@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																					var ` = elements[1];
																					if (enumIndex ` == 0) {
																						var ` = `[0];
																						{
																							reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(desired)]);
																						};
																					} else {
																						p;
																					};
																				};
																			} else {
																				p;
																			};
																		};
																	} else {
																		p;
																	};
																};
																var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
																var assigns = [];
																if (used.indexOf("data", null) != -1) {
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(desired), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																};
																var newBody2 = if (assigns.length > 0) {
																	@:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																		var ` = clause.body.def;
																		if (enumIndex ` == 53) {
																			var ` = `[0];
																			{
																				var exprs = `;
																				{
																					{
																						var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																						var pos = null;
																						{def : def, metadata : {}, pos : pos};
																					};
																				};
																			};
																		} else {
																			{
																				var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																				var pos = null;
																				{def : def, metadata : {}, pos : pos};
																			};
																		};
																	};
																} else {
																	clause.body;
																};
																newClauses.push({pattern : renamed, guard : clause.guard, body : newBody2});
																continue;
															};
															newClauses.push(clause);
														};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
												};
											};
										} else {
											n;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, newBody), metadata : node.metadata, pos : node.pos};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function controllerPhoenixJsonAliasInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EModule(name, attrs, body) if (isControllerModuleName(name)):
		var newBody:Array<ElixirAST> = [];
		for (b  in  body) {
			var tb = ElixirASTTransformer.transformNode(b, function(n:ElixirAST):ElixirAST {
				return switch (n.def) {
					case ECase(target, clauses):
						var newClauses = [];
						for (clause  in  clauses) {
							var tag = tagOf(clause.pattern);
							var binder = binderOf(clause.pattern);
							if ((tag == "ok" || tag == "error") && binder != null) {
								var assigns:Array<ElixirAST> = [];
								if (tag == "ok") {
									assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(binder)))));
									assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
								} else {
									assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(binder)))));
									assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
								};
								var nb = switch (clause.body.def) {
									case EBlock(exprs):
										makeAST(EBlock(assigns.concat(exprs)));									
									default:
										makeAST(EBlock(assigns.concat([clause.body])));									
								};
								newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : nb });
								continue;
							};
							newClauses.push(clause);
						};
						makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);					
					default:
						n;					
				};
			});
			newBody.push(tb);
		};
		makeASTWithMeta(EModule(name, attrs, newBody), node.metadata, node.pos);	
	case EDefmodule(name, doBlock) if (isControllerModuleName(name)):
		var transformedDo = ElixirASTTransformer.transformNode(doBlock, function(n:ElixirAST):ElixirAST {
			return switch (n.def) {
				case ECase(target, clauses):
					var newClauses = [];
					for (clause  in  clauses) {
						var tag = tagOf(clause.pattern);
						var binder = binderOf(clause.pattern);
						if ((tag == "ok" || tag == "error") && binder != null) {
							var assigns:Array<ElixirAST> = [];
							if (tag == "ok") {
								assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(binder)))));
								assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
							} else {
								assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(binder)))));
								assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
							};
							var nb = switch (clause.body.def) {
								case EBlock(exprs):
									makeAST(EBlock(assigns.concat(exprs)));								
								default:
									makeAST(EBlock(assigns.concat([clause.body])));								
							};
							newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : nb });
							continue;
						};
						newClauses.push(clause);
					};
					makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);				
				default:
					n;				
			};
		});
		makeASTWithMeta(EDefmodule(name, transformedDo), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attrs = `;
							var body = `;
							if (name != null && StringTools.endsWith(name, "Controller")) {
								var newBody = [];
								{
									var ` = 0;
									while (` < body.length) {
										var b = body[`];
										++ `;
										var tb = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(b, function(n:reflaxe.elixir.ast.ElixirAST) {
											return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			var binder = binderOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && binder != null) {
				var assigns:Array<ElixirAST> = [];
				if (tag == "ok") {
					assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(binder)))));
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
				} else {
					assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(binder)))));
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
				};
				var nb = switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				};
				newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : nb });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
												var ` = n.def;
												if (enumIndex ` == 6) {
													var ` = `[0];
													var ` = `[1];
													{
														var target = `;
														var clauses = `;
														{
															var newClauses = [];
															{
																var ` = 0;
																while (` < clauses.length) {
																	var clause = clauses[`];
																	++ `;
																	var tag = {
																		var p = clause.pattern;
																		@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																			var ` = p[0];
																			{
																				var elements = `;
																				if (elements.length >= 1) {
																					@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																						var ` = elements[0];
																						if (enumIndex ` == 1) {
																							var ` = `[0];
																							{
																								var ` = `.def;
																								var ` = `.metadata;
																								var ` = `.pos;
																								if (enumIndex ` == 31) {
																									var ` = `[0];
																									{
																										var a = `;
																										{
																											a;
																										};
																									};
																								} else {
																									null;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																	var binder = {
																		var p = clause.pattern;
																		@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(n):
				n;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																			var ` = p[0];
																			{
																				var elements = `;
																				if (elements.length == 2) {
																					@:ast(switch (elements[1]) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
																						var ` = elements[1];
																						if (enumIndex ` == 0) {
																							var ` = `[0];
																							{
																								var n = `;
																								{
																									n;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																	if ((tag == "ok" || tag == "error") && binder != null) {
																		var assigns = [];
																		if (tag == "ok") {
																			assigns.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("user"), {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			});
																			assigns.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			});
																		} else {
																			assigns.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("changeset"), {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			});
																			assigns.push({
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																				}), metadata : {}, pos : pos};
																			});
																		};
																		var nb = @:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																			var ` = clause.body.def;
																			if (enumIndex ` == 53) {
																				var ` = `[0];
																				{
																					var exprs = `;
																					{
																						{
																							var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																							var pos = null;
																							{def : def, metadata : {}, pos : pos};
																						};
																					};
																				};
																			} else {
																				{
																					var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				};
																			};
																		};
																		newClauses.push({pattern : clause.pattern, guard : clause.guard, body : nb});
																		continue;
																	};
																	newClauses.push(clause);
																};
															};
															{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
														};
													};
												} else {
													n;
												};
											};
										});
										newBody.push(tb);
									};
								};
								{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attrs, newBody), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							if (name != null && StringTools.endsWith(name, "Controller")) {
								var transformedDo = reflaxe.elixir.ast.ElixirASTTransformer.transformNode(doBlock, function(n:reflaxe.elixir.ast.ElixirAST) {
									return @:ast(switch (n.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			var binder = binderOf(clause.pattern);
			if ((tag == "ok" || tag == "error") && binder != null) {
				var assigns:Array<ElixirAST> = [];
				if (tag == "ok") {
					assigns.push(makeAST(EMatch(PVar("user"), makeAST(EVar(binder)))));
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
				} else {
					assigns.push(makeAST(EMatch(PVar("changeset"), makeAST(EVar(binder)))));
					assigns.push(makeAST(EMatch(PVar("data"), makeAST(EVar(binder)))));
				};
				var nb = switch (clause.body.def) {
					case EBlock(exprs):
						makeAST(EBlock(assigns.concat(exprs)));					
					default:
						makeAST(EBlock(assigns.concat([clause.body])));					
				};
				newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : nb });
				continue;
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), n.metadata, n.pos);	
	default:
		n;	
}) {
										var ` = n.def;
										if (enumIndex ` == 6) {
											var ` = `[0];
											var ` = `[1];
											{
												var target = `;
												var clauses = `;
												{
													var newClauses = [];
													{
														var ` = 0;
														while (` < clauses.length) {
															var clause = clauses[`];
															++ `;
															var tag = {
																var p = clause.pattern;
																@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																	var ` = p[0];
																	{
																		var elements = `;
																		if (elements.length >= 1) {
																			@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
																				var ` = elements[0];
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var ` = `.def;
																						var ` = `.metadata;
																						var ` = `.pos;
																						if (enumIndex ` == 31) {
																							var ` = `[0];
																							{
																								var a = `;
																								{
																									a;
																								};
																							};
																						} else {
																							null;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
															var binder = {
																var p = clause.pattern;
																@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(n):
				n;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
																	var ` = p[0];
																	{
																		var elements = `;
																		if (elements.length == 2) {
																			@:ast(switch (elements[1]) {
	case PVar(n):
		n;	
	default:
		null;	
}) {
																				var ` = elements[1];
																				if (enumIndex ` == 0) {
																					var ` = `[0];
																					{
																						var n = `;
																						{
																							n;
																						};
																					};
																				} else {
																					null;
																				};
																			};
																		} else {
																			null;
																		};
																	};
																} else {
																	null;
																};
															};
															if ((tag == "ok" || tag == "error") && binder != null) {
																var assigns = [];
																if (tag == "ok") {
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("user"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																} else {
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("changeset"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																	assigns.push({
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar("data"), {
																			var pos = null;
																			{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
																		}), metadata : {}, pos : pos};
																	});
																};
																var nb = @:ast(switch (clause.body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([clause.body])));	
}) {
																	var ` = clause.body.def;
																	if (enumIndex ` == 53) {
																		var ` = `[0];
																		{
																			var exprs = `;
																			{
																				{
																					var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																					var pos = null;
																					{def : def, metadata : {}, pos : pos};
																				};
																			};
																		};
																	} else {
																		{
																			var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([clause.body]));
																			var pos = null;
																			{def : def, metadata : {}, pos : pos};
																		};
																	};
																};
																newClauses.push({pattern : clause.pattern, guard : clause.guard, body : nb});
																continue;
															};
															newClauses.push(clause);
														};
													};
													{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : n.metadata, pos : n.pos};
												};
											};
										} else {
											n;
										};
									};
								});
								{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformedDo), metadata : node.metadata, pos : node.pos};
							} else {
								node;
							};
						};
					};
					default: {
						node;
					}
				};
			};
		});
	}

	public static function resultBinderRenameByBodyUsagePass(ast:reflaxe.elixir.ast.ElixirAST) {
		{};
		{};
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var tag = tagOf(clause.pattern);
			if (tag == "ok" || tag == "error") {
				var used = collectUsedLowerVars(clause.body);
				var preferred:Null<String> = null;
				if (tag == "ok") {
					if (used.indexOf("user") != -1) preferred = "user" else if (used.indexOf("data") != -1) preferred = "data";
					if (preferred == null) {
						var declared = new Map<String,Bool>();
						var binds = collectPatternBinders(clause.pattern);
						for (b  in  binds) declared.set(b, true);
						var undef = used.filter(function(v) ->  @:implicitReturn return !declared.exists(v));
						if (undef.length == 1) preferred = undef[0];
					};
				} else {
					if (used.indexOf("reason") != -1) preferred = "reason" else if (used.indexOf("changeset") != -1) preferred = "changeset";
				};
				switch (clause.pattern) {
					case PTuple(elements) if (elements.length == 2):
						switch (elements[1]) {
							case PVar(name) if (tag == "error" && name == "socket"):
								preferred = "reason";							
							default:
						};					
					default:
				};
				if (preferred != null) {
					var renamed = renameBinder(clause.pattern, preferred);
					if (renamed != clause.pattern) {
						newClauses.push({ pattern : renamed, guard : clause.guard, body : clause.body });
						continue;
					};
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var tag = {
										var p = clause.pattern;
										@:ast(switch (p) {
	case PTuple(elements) if (elements.length >= 1):
		switch (elements[0]) {
			case PLiteral({ def : EAtom(a) }):
				a;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex p == 2) {
											var ` = p[0];
											{
												var elements = `;
												if (elements.length >= 1) {
													@:ast(switch (elements[0]) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) {
														var ` = elements[0];
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var ` = `.def;
																var ` = `.metadata;
																var ` = `.pos;
																if (enumIndex ` == 31) {
																	var ` = `[0];
																	{
																		var a = `;
																		{
																			a;
																		};
																	};
																} else {
																	null;
																};
															};
														} else {
															null;
														};
													};
												} else {
													null;
												};
											};
										} else {
											null;
										};
									};
									if (tag == "ok" || tag == "error") {
										var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
										var preferred = null;
										if (tag == "ok") {
											if (used.indexOf("user", null) != -1) {
												preferred = "user";
											} else {
												if (used.indexOf("data", null) != -1) {
													preferred = "data";
												};
											};
											if (preferred == null) {
												var declared = {
													{};
													new haxe.ds.StringMap();
												};
												var binds = reflaxe.elixir.ast.transformers.BinderTransforms.collectPatternBinders(clause.pattern);
												{
													var ` = 0;
													while (` < binds.length) {
														var b = binds[`];
														++ `;
														{
															declared.set(b, true);
														};
													};
												};
												var undef = {
													var ` = [];
													{
														var ` = 0;
														var ` = used;
														while (` < `.length) {
															var v = `[`];
															++ `;
															if (function(v:String) {
																return ! declared.exists(v);
															}(v)) {
																`.push(v);
															};
														};
													};
													`;
												};
												if (undef.length == 1) {
													preferred = undef[0];
												};
											};
										} else {
											if (used.indexOf("reason", null) != -1) {
												preferred = "reason";
											} else {
												if (used.indexOf("changeset", null) != -1) {
													preferred = "changeset";
												};
											};
										};
										@:ast(switch (clause.pattern) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(name) if (tag == "error" && name == "socket"):
				preferred = "reason";			
			default:
		};	
	default:
}) {
											var ` = clause.pattern;
											if (enumIndex ` == 2) {
												var ` = `[0];
												{
													var elements = `;
													if (elements.length == 2) {
														@:ast(switch (elements[1]) {
	case PVar(name) if (tag == "error" && name == "socket"):
		preferred = "reason";	
	default:
}) {
															var ` = elements[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var name = `;
																	if (tag == "error" && name == "socket") {
																		preferred = "reason";
																	} else {};
																};
															} else {};
														};
													} else {};
												};
											} else {};
										};
										if (preferred != null) {
											var renamed = {
												var p = clause.pattern;
												@:ast(switch (p) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(_):
				PTuple([elements[0], PVar(newName)]);			
			default:
				p;			
		};	
	default:
		p;	
}) if (enumIndex p == 2) {
													var ` = p[0];
													{
														var elements = `;
														if (elements.length == 2) {
															@:ast(switch (elements[1]) {
	case PVar(_):
		PTuple([elements[0], PVar(newName)]);	
	default:
		p;	
}) {
																var ` = elements[1];
																if (enumIndex ` == 0) {
																	var ` = `[0];
																	{
																		reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(preferred)]);
																	};
																} else {
																	p;
																};
															};
														} else {
															p;
														};
													};
												} else {
													p;
												};
											};
											if (renamed != clause.pattern) {
												newClauses.push({pattern : renamed, guard : clause.guard, body : clause.body});
												continue;
											};
										};
									};
									newClauses.push(clause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function caseClauseBinderRenameByTagPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return node;
			};
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var renamed = renameByTag(clause.pattern);
			if (renamed != null) newClauses.push({ pattern : renamed, guard : clause.guard, body : clause.body }) else newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var renamed = reflaxe.elixir.ast.transformers.BinderTransforms.renameByTag(clause.pattern);
									if (renamed != null) {
										newClauses.push({pattern : renamed, guard : clause.guard, body : clause.body});
									} else {
										newClauses.push(clause);
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function innerParsedMsgCaseToBinderPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var binder = extractSomeBinder(clause.pattern);
			if (binder != null) {
				var newBody = replaceParsedMsgCase(clause.body, binder);
				newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : newBody });
			} else {
				newClauses.push(clause);
			};
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var binder = reflaxe.elixir.ast.transformers.BinderTransforms.extractSomeBinder(clause.pattern);
									if (binder != null) {
										var newBody = reflaxe.elixir.ast.transformers.BinderTransforms.replaceParsedMsgCase(clause.body, binder);
										newClauses.push({pattern : clause.pattern, guard : clause.guard, body : newBody});
									} else {
										newClauses.push(clause);
									};
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	public static function eventParamAliasInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return ast;
	}

	static function extractSomeBinder(pat:reflaxe.elixir.ast.EPattern) {
		return @:ast(switch (pat) {
	case PTuple(elements) if (elements.length == 2):
		switch ([elements[0], elements[1]]) {
			case [PLiteral({ def : EAtom(a) }), PVar(name)] if (a == "some"):
				name;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex pat == 2) {
			var ` = pat[0];
			{
				var elements = `;
				if (elements.length == 2) {
					@:ast(switch ([elements[0], elements[1]]) {
	case [PLiteral({ def : EAtom(a) }), PVar(name)] if (a == "some"):
		name;	
	default:
		null;	
}) {
						var ` = elements[0];
						var ` = elements[1];
						if (enumIndex ` == 1) {
							var ` = `[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 31) {
									var ` = `[0];
									if (enumIndex ` == 0) {
										var ` = `[0];
										{
											var name = `;
											var a = `;
											if (a == "some") {
												name;
											} else {
												null;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	static function replaceParsedMsgCase(body:reflaxe.elixir.ast.ElixirAST, binder:String) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(body, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case ECase(caseExpr, clauses):
		switch (caseExpr.def) {
			case EVar(v) if (v == "parsed_msg"):
				makeASTWithMeta(ECase(makeAST(EVar(binder)), clauses), n.metadata, n.pos);			
			default:
				n;			
		};	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var caseExpr = `;
						var clauses = `;
						{
							@:ast(switch (caseExpr.def) {
	case EVar(v) if (v == "parsed_msg"):
		makeASTWithMeta(ECase(makeAST(EVar(binder)), clauses), n.metadata, n.pos);	
	default:
		n;	
}) {
								var ` = caseExpr.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										if (v == "parsed_msg") {
											{def : reflaxe.elixir.ast.ElixirASTDef.ECase({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
											}, clauses), metadata : n.metadata, pos : n.pos};
										} else {
											n;
										};
									};
								} else {
									n;
								};
							};
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function renameByTag(pat:reflaxe.elixir.ast.EPattern) {
		return @:ast(switch (pat) {
	case PTuple(elements) if (elements.length == 2):
		var tag = extractAtom(elements[0]);
		switch (elements[1]) {
			case PVar(old):
				var preferred = preferredNameForTag(tag);
				if (preferred != null && preferred != old) {
					PTuple([elements[0], PVar(preferred)]);
				} else null;			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex pat == 2) {
			var ` = pat[0];
			{
				var elements = `;
				if (elements.length == 2) {
					var tag = {
						var pat = elements[0];
						@:ast(switch (pat) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) if (enumIndex pat == 1) {
							var ` = pat[0];
							{
								var ` = `.def;
								var ` = `.metadata;
								var ` = `.pos;
								if (enumIndex ` == 31) {
									var ` = `[0];
									{
										var a = `;
										{
											a;
										};
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
					@:ast(switch (elements[1]) {
	case PVar(old):
		var preferred = preferredNameForTag(tag);
		if (preferred != null && preferred != old) {
			PTuple([elements[0], PVar(preferred)]);
		} else null;	
	default:
		null;	
}) {
						var ` = elements[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var old = `;
								{
									var preferred = reflaxe.elixir.ast.transformers.BinderTransforms.preferredNameForTag(tag);
									if (preferred != null && preferred != old) {
										reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(preferred)]);
									} else {
										null;
									};
								};
							};
						} else {
							null;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	static inline function extractAtom(pat:reflaxe.elixir.ast.EPattern) {
		return @:ast(switch (pat) {
	case PLiteral({ def : EAtom(a) }):
		a;	
	default:
		null;	
}) if (enumIndex pat == 1) {
			var ` = pat[0];
			{
				var ` = `.def;
				var ` = `.metadata;
				var ` = `.pos;
				if (enumIndex ` == 31) {
					var ` = `[0];
					{
						var a = `;
						{
							a;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	static function preferredNameForTag(tag:String) {
		if (tag == null) {
			return null;
		};
		var t = tag;
		{};
		{};
		if (t.indexOf("sort", null) != -1) {
			return "sort_by";
		};
		if (t.indexOf("filter", null) != -1) {
			return "filter";
		};
		if (t.indexOf("search", null) != -1) {
			return "params";
		};
		if (t.indexOf("query", null) != -1) {
			return "query";
		};
		if (t.indexOf("tag", null) != -1) {
			return "tag";
		};
		if (t.indexOf("priority", null) != -1) {
			return "priority";
		};
		if (StringTools.startsWith(t, "delete_") || StringTools.startsWith(t, "remove_") || StringTools.startsWith(t, "toggle_") || StringTools.startsWith(t, "edit_")) {
			return "id";
		};
		if (StringTools.startsWith(t, "save_") || StringTools.startsWith(t, "create_") || StringTools.startsWith(t, "update_")) {
			return "params";
		};
		@:ast(switch (tag) {
	case "validate":
		return "params";	
	case "clear_filters":
		return null;	
	case "bulk_update":
		return "action";	
	case "user_online" | "user_offline":
		return "user_id";	
	default:
}) switch (tag) {
			case "bulk_update": {
				{
					return "action";
				};
			};
			case "clear_filters": {
				{
					return null;
				};
			};
			case "user_offline", "user_online": {
				{
					return "user_id";
				};
			};
			case "validate": {
				{
					return "params";
				};
			};
			default: {}
		};
		return null;
	}

	static function tryRenameSingleBinder(pat:reflaxe.elixir.ast.EPattern, newName:String) {
		return @:ast(switch (pat) {
	case PTuple(elements) if (elements.length == 2):
		switch (elements[1]) {
			case PVar(oldName) if (oldName != newName):
				PTuple([elements[0], PVar(newName)]);			
			default:
				null;			
		};	
	default:
		null;	
}) if (enumIndex pat == 2) {
			var ` = pat[0];
			{
				var elements = `;
				if (elements.length == 2) {
					@:ast(switch (elements[1]) {
	case PVar(oldName) if (oldName != newName):
		PTuple([elements[0], PVar(newName)]);	
	default:
		null;	
}) {
						var ` = elements[1];
						if (enumIndex ` == 0) {
							var ` = `[0];
							{
								var oldName = `;
								if (oldName != newName) {
									reflaxe.elixir.ast.EPattern.PTuple([elements[0], reflaxe.elixir.ast.EPattern.PVar(newName)]);
								} else {
									null;
								};
							};
						} else {
							null;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	static function derivePreferredBinder(base:String) {
		var last = if ((base != null && base.indexOf("_", null) != -1)) {
			base.split("_")[base.split("_").length - 1];
		} else {
			base;
		};
		if (last != null) {
			if (StringTools.endsWith(last, "id")) {
				return "id";
			};
			if (StringTools.endsWith(last, "error")) {
				return "error";
			};
		};
		return "value";
	}

	public static function caseClauseBinderAliasInjectionPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null || node.def == null) {
				return node;
			};
			return @:ast(switch (node.def) {
	case ECase(target, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var binders = collectPatternBinders(clause.pattern);
			if (binders.length == 1) {
				var used = collectUsedLowerVars(clause.body);
				var binder = binders[0];
				var toAlias = used.filter(function(v) ->  @:implicitReturn return v != binder && toSnake(v) == binder);
				if (toAlias.length > 0) {
					var body = clause.body;
					var assigns = [for (v  in  toAlias) makeAST(EMatch(PVar(v), makeAST(EVar(binder))))];
					var newBody = switch (body.def) {
						case EBlock(exprs):
							makeAST(EBlock(assigns.concat(exprs)));						
						default:
							makeAST(EBlock(assigns.concat([body])));						
					};
					newClauses.push({ pattern : clause.pattern, guard : clause.guard, body : newBody });
					continue;
				};
			};
			newClauses.push(clause);
		};
		makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);	
	default:
		node;	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var target = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var binders = reflaxe.elixir.ast.transformers.BinderTransforms.collectPatternBinders(clause.pattern);
									if (binders.length == 1) {
										var used = reflaxe.elixir.ast.transformers.BinderTransforms.collectUsedLowerVars(clause.body);
										var binder = binders[0];
										var toAlias = {
											var ` = [];
											{
												var ` = 0;
												var ` = used;
												while (` < `.length) {
													var v = `[`];
													++ `;
													if (function(v:String) {
														return v != binder && reflaxe.elixir.ast.transformers.BinderTransforms.toSnake(v) == binder;
													}(v)) {
														`.push(v);
													};
												};
											};
											`;
										};
										if (toAlias.length > 0) {
											var body = clause.body;
											var assigns = {
												var ` = [];
												{
													var ` = 0;
													while (` < toAlias.length) {
														var v = toAlias[`];
														++ `;
														`.push({
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(v), {
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EVar(binder), metadata : {}, pos : pos};
															}), metadata : {}, pos : pos};
														});
													};
												};
												`;
											};
											var newBody = @:ast(switch (body.def) {
	case EBlock(exprs):
		makeAST(EBlock(assigns.concat(exprs)));	
	default:
		makeAST(EBlock(assigns.concat([body])));	
}) {
												var ` = body.def;
												if (enumIndex ` == 53) {
													var ` = `[0];
													{
														var exprs = `;
														{
															{
																var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat(exprs));
																var pos = null;
																{def : def, metadata : {}, pos : pos};
															};
														};
													};
												} else {
													{
														var def = reflaxe.elixir.ast.ElixirASTDef.EBlock(assigns.concat([body]));
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													};
												};
											};
											newClauses.push({pattern : clause.pattern, guard : clause.guard, body : newBody});
											continue;
										};
									};
									newClauses.push(clause);
								};
							};
							{def : reflaxe.elixir.ast.ElixirASTDef.ECase(target, newClauses), metadata : node.metadata, pos : node.pos};
						};
					};
				} else {
					node;
				};
			};
		});
	}

	static function collectPatternBinders(pat:reflaxe.elixir.ast.EPattern) {
		var result = [];
		var walk = [null];
		walk[0] = function(p:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (p) {
	case PVar(name):
		if (name != null && name.length > 0 && isLower(name)) result.push(name);	
	case PTuple(items):
		for (i  in  items) walk(i);	
	case PList(items):
		for (i  in  items) walk(i);	
	case PCons(head, tail):
		walk(head);
		walk(tail);	
	case PMap(pairs):
		for (kv  in  pairs) walk(kv.value);	
	default:
}) switch (enumIndex p) {
				case 0: {
					var ` = p[0];
					{
						var name = `;
						{
							if (name != null && name.length > 0 && {
								var c = name.charAt(0);
								c.toLowerCase() == c;
							}) {
								result.push(name);
							};
						};
					};
				};
				case 2: {
					var ` = p[0];
					{
						var items = `;
						{
							{
								var ` = 0;
								while (` < items.length) {
									var i = items[`];
									++ `;
									walk[0](i);
								};
							};
						};
					};
				};
				case 3: {
					var ` = p[0];
					{
						var items = `;
						{
							{
								var ` = 0;
								while (` < items.length) {
									var i = items[`];
									++ `;
									walk[0](i);
								};
							};
						};
					};
				};
				case 4: {
					var ` = p[0];
					var ` = p[1];
					{
						var head = `;
						var tail = `;
						{
							walk[0](head);
							walk[0](tail);
						};
					};
				};
				case 5: {
					var ` = p[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var kv = pairs[`];
									++ `;
									walk[0](kv.value);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		walk[0](pat);
		return result;
	}

	static function collectUsedLowerVars(ast:reflaxe.elixir.ast.ElixirAST) {
		var names = {
			{};
			new haxe.ds.StringMap();
		};
		var scan = [null];
		scan[0] = function(n:reflaxe.elixir.ast.ElixirAST) {
			if (n == null || n.def == null) {
				return;
			};
			@:ast(switch (n.def) {
	case EVar(name):
		if (name != null && name.length > 0 && isLower(name)) names.set(name, true);	
	case EString(value):
		if (value != null && value.length > 0) {
			var re = new EReg("\\#\\{([a-z_][a-zA-Z0-9_]*)\\}", "g");
			var pos = 0;
			while (re.matchSub(value, pos)) {
				var v = re.matched(1);
				if (v != null && isLower(v)) names.set(v, true);
				var mEnd = re.matchedPos().pos + re.matchedPos().len;
				pos = mEnd;
			};
		};	
	case EField(target, _):
		scan(target);	
	case EAccess(target, key):
		scan(target);
		scan(key);	
	case EBinary(_, left, right):
		scan(left);
		scan(right);	
	case EUnary(_, expr):
		scan(expr);	
	case EPipe(left, right):
		scan(left);
		scan(right);	
	case EBlock(exprs):
		for (e  in  exprs) scan(e);	
	case EIf(c, t, e):
		scan(c);
		scan(t);
		if (e != null) scan(e);	
	case ECase(expr, clauses):
		scan(expr);
		for (c  in  clauses) {
			if (c.guard != null) scan(c.guard);
			scan(c.body);
		};	
	case ECall(target, _, args):
		if (target != null) scan(target);
		if (args != null) for (a  in  args) scan(a);	
	case ERemoteCall(mod, _, args):
		scan(mod);
		if (args != null) for (a  in  args) scan(a);	
	case ETuple(items) | EList(items):
		for (i  in  items) scan(i);	
	case EMap(pairs):
		for (p  in  pairs) {
			scan(p.key);
			scan(p.value);
		};	
	default:
}) {
				var ` = n.def;
				switch (enumIndex `) {
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								scan[0](expr);
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										if (c.guard != null) {
											scan[0](c.guard);
										};
										scan[0](c.body);
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var c = `;
							var t = `;
							var e = `;
							{
								scan[0](c);
								scan[0](t);
								if (e != null) {
									scan[0](e);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var items = `;
							{
								{
									var ` = 0;
									while (` < items.length) {
										var i = items[`];
										++ `;
										scan[0](i);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var items = `;
							{
								{
									var ` = 0;
									while (` < items.length) {
										var i = items[`];
										++ `;
										scan[0](i);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										scan[0](p.key);
										scan[0](p.value);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var args = `;
							{
								if (target != null) {
									scan[0](target);
								};
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var a = args[`];
											++ `;
											scan[0](a);
										};
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var mod = `;
							var args = `;
							{
								scan[0](mod);
								if (args != null) {
									{
										var ` = 0;
										while (` < args.length) {
											var a = args[`];
											++ `;
											scan[0](a);
										};
									};
								};
							};
						};
					};
					case 25: {
						var ` = `[0];
						var ` = `[1];
						{
							var left = `;
							var right = `;
							{
								scan[0](left);
								scan[0](right);
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var left = `;
							var right = `;
							{
								scan[0](left);
								scan[0](right);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							{
								scan[0](expr);
							};
						};
					};
					case 28: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							{
								scan[0](target);
							};
						};
					};
					case 29: {
						var ` = `[0];
						var ` = `[1];
						{
							var target = `;
							var key = `;
							{
								scan[0](target);
								scan[0](key);
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var value = `;
							{
								if (value != null && value.length > 0) {
									var re = new EReg("\\#\\{([a-z_][a-zA-Z0-9_]*)\\}", "g");
									var pos = 0;
									while (re.matchSub(value, pos, null)) {
										var v = re.matched(1);
										if (v != null && {
											var c = v.charAt(0);
											c.toLowerCase() == c;
										}) {
											{
												names.set(v, true);
											};
										};
										var mEnd = re.matchedPos().pos + re.matchedPos().len;
										pos = mEnd;
									};
								};
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (name != null && name.length > 0 && {
									var c = name.charAt(0);
									c.toLowerCase() == c;
								}) {
									{
										names.set(name, true);
									};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										scan[0](e);
									};
								};
							};
						};
					};
					default: {}
				};
			};
		};
		scan[0](ast);
		return {
			var ` = [];
			for (k in names.keys()) {
				`.push(k);
			};
			`;
		};
	}

	static inline function isLower(s:String) {
		var c = s.charAt(0);
		return c.toLowerCase() == c;
	}

	static function toSnake(s:String) {
		if (s == null || s.length == 0) {
			return s;
		};
		var buf = new StringBuf();
		{
			var ` = 0;
			var ` = s.length;
			while (` < `) {
				var i = ` ++;
				var c = s.substr(i, 1);
				var lower = c.toLowerCase();
				var upper = c.toUpperCase();
				if (c == upper && c != lower) {
					if (i != 0) {
						buf.add("_");
					};
					buf.add(lower);
				} else {
					buf.add(c);
				};
			};
		};
		return buf.toString();
	}
}