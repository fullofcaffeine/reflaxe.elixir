class reflaxe.elixir.ast.analyzers.VariableUsageCollector {

	public static function referencedInFunctionScope(body:reflaxe.elixir.ast.ElixirAST) {
		var refs = {
			{};
			new haxe.ds.StringMap();
		};
		var empty = {
			{};
			new haxe.ds.StringMap();
		};
		reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(body, empty, refs);
		return refs;
	}

	public static function usedInFunctionScope(body:reflaxe.elixir.ast.ElixirAST, name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var refs = reflaxe.elixir.ast.analyzers.VariableUsageCollector.referencedInFunctionScope(body);
		return refs.exists(name);
	}

	static function walk(n:reflaxe.elixir.ast.ElixirAST, shadowed:Map<String, Bool>, refs:Map<String, Bool>) {
		if (n == null || n.def == null) {
			return;
		};
		@:ast(switch (n.def) {
	case EVar(v):
		if (!shadowed.exists(v)) refs.set(v, true);	
	case EBinary(Match, left, rhs):
		walk(rhs, shadowed, refs);	
	case EMatch(_, rhsExpr):
		walk(rhsExpr, shadowed, refs);	
	case EBlock(stmts):
		for (s  in  stmts) walk(s, shadowed, refs);	
	case EDo(statements):
		for (s  in  statements) walk(s, shadowed, refs);	
	case EParen(e):
		walk(e, shadowed, refs);	
	case EPipe(l, r):
		walk(l, shadowed, refs);
		walk(r, shadowed, refs);	
	case EIf(c, t, e):
		walk(c, shadowed, refs);
		walk(t, shadowed, refs);
		if (e != null) walk(e, shadowed, refs);	
	case EUnless(c, b, e):
		walk(c, shadowed, refs);
		walk(b, shadowed, refs);
		if (e != null) walk(e, shadowed, refs);	
	case ECase(expr, clauses):
		walk(expr, shadowed, refs);
		for (cl  in  clauses) {
			var add = collectPatternVars(cl.pattern);
			var next = extendShadow(shadowed, add);
			if (cl.guard != null) walk(cl.guard, next, refs);
			walk(cl.body, next, refs);
		};	
	case EReceive(clauses, after):
		for (cl  in  clauses) {
			var add = collectPatternVars(cl.pattern);
			var next = extendShadow(shadowed, add);
			walk(cl.body, next, refs);
		};
		if (after != null) walk(after.body, shadowed, refs);	
	case EWith(clauses, doBlock, elseBlock):
		var accum = cloneShadow(shadowed);
		for (wc  in  clauses) {
			walk(wc.expr, accum, refs);
			var add = collectPatternVars(wc.pattern);
			for (k  in  add.keys()) accum.set(k, true);
		};
		walk(doBlock, accum, refs);
		if (elseBlock != null) walk(elseBlock, accum, refs);	
	case EFor(gens, filters, body, into, _uniq):
		var accum = cloneShadow(shadowed);
		for (g  in  gens) {
			walk(g.expr, accum, refs);
			var add = collectPatternVars(g.pattern);
			for (k  in  add.keys()) accum.set(k, true);
		};
		for (f  in  filters) walk(f, accum, refs);
		if (body != null) walk(body, accum, refs);
		if (into != null) walk(into, shadowed, refs);	
	case EPin(inner):
		walk(inner, shadowed, refs);	
	case ECall(tgt, _, args):
		if (tgt != null) walk(tgt, shadowed, refs);
		for (a  in  args) walk(a, shadowed, refs);	
	case ERemoteCall(targetExpr, _, argsList):
		walk(targetExpr, shadowed, refs);
		for (a  in  argsList) walk(a, shadowed, refs);	
	case EField(obj, _):
		walk(obj, shadowed, refs);	
	case EAccess(objectExpr, key):
		walk(objectExpr, shadowed, refs);
		walk(key, shadowed, refs);	
	case EKeywordList(pairs):
		for (p  in  pairs) walk(p.value, shadowed, refs);	
	case EMap(pairs):
		for (p  in  pairs) {
			walk(p.key, shadowed, refs);
			walk(p.value, shadowed, refs);
		};	
	case EStructUpdate(base, fields):
		walk(base, shadowed, refs);
		for (f  in  fields) walk(f.value, shadowed, refs);	
	case ETuple(elems) | EList(elems):
		for (e  in  elems) walk(e, shadowed, refs);	
	case EFn(clauses):
		for (cl  in  clauses) {
			var add = collectArgVars(cl.args);
			var next = extendShadow(shadowed, add);
			if (cl.guard != null) walk(cl.guard, next, refs);
			walk(cl.body, next, refs);
		};	
	case ETry(body, rescueClauses, catchClauses, afterBlock, elseBlock):
		walk(body, shadowed, refs);
		if (rescueClauses != null) for (rc  in  rescueClauses) {
			var add = collectPatternVars(rc.pattern);
			var next = extendShadow(shadowed, add);
			walk(rc.body, next, refs);
		};
		if (catchClauses != null) for (cc  in  catchClauses) {
			var add = collectPatternVars(cc.pattern);
			var next = extendShadow(shadowed, add);
			walk(cc.body, next, refs);
		};
		if (afterBlock != null) walk(afterBlock, shadowed, refs);
		if (elseBlock != null) walk(elseBlock, shadowed, refs);	
	default:
}) {
			var ` = n.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(expr, shadowed, refs);
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(cl.pattern);
									var next = reflaxe.elixir.ast.analyzers.VariableUsageCollector.extendShadow(shadowed, add);
									if (cl.guard != null) {
										reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cl.guard, next, refs);
									};
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cl.body, next, refs);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var rhsExpr = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(rhsExpr, shadowed, refs);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var clauses = `;
						var doBlock = `;
						var elseBlock = `;
						{
							var accum = reflaxe.elixir.ast.analyzers.VariableUsageCollector.cloneShadow(shadowed);
							{
								var ` = 0;
								while (` < clauses.length) {
									var wc = clauses[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(wc.expr, accum, refs);
									var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(wc.pattern);
									for (k in add.keys()) {
										{
											accum.set(k, true);
										};
									};
								};
							};
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(doBlock, accum, refs);
							if (elseBlock != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(elseBlock, accum, refs);
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var t = `;
						var e = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(c, shadowed, refs);
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(t, shadowed, refs);
							if (e != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(e, shadowed, refs);
							};
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var b = `;
						var e = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(c, shadowed, refs);
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(b, shadowed, refs);
							if (e != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(e, shadowed, refs);
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var body = `;
						var rescueClauses = `;
						var catchClauses = `;
						var afterBlock = `;
						var elseBlock = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(body, shadowed, refs);
							if (rescueClauses != null) {
								{
									var ` = 0;
									while (` < rescueClauses.length) {
										var rc = rescueClauses[`];
										++ `;
										var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(rc.pattern);
										var next = reflaxe.elixir.ast.analyzers.VariableUsageCollector.extendShadow(shadowed, add);
										reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(rc.body, next, refs);
									};
								};
							};
							if (catchClauses != null) {
								{
									var ` = 0;
									while (` < catchClauses.length) {
										var cc = catchClauses[`];
										++ `;
										var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(cc.pattern);
										var next = reflaxe.elixir.ast.analyzers.VariableUsageCollector.extendShadow(shadowed, add);
										reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cc.body, next, refs);
									};
								};
							};
							if (afterBlock != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(afterBlock, shadowed, refs);
							};
							if (elseBlock != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(elseBlock, shadowed, refs);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elems = `;
						{
							{
								var ` = 0;
								while (` < elems.length) {
									var e = elems[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(e, shadowed, refs);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elems = `;
						{
							{
								var ` = 0;
								while (` < elems.length) {
									var e = elems[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(e, shadowed, refs);
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(p.key, shadowed, refs);
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(p.value, shadowed, refs);
								};
							};
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var base = `;
						var fields = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(base, shadowed, refs);
							{
								var ` = 0;
								while (` < fields.length) {
									var f = fields[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(f.value, shadowed, refs);
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(p.value, shadowed, refs);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var tgt = `;
						var args = `;
						{
							if (tgt != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(tgt, shadowed, refs);
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(a, shadowed, refs);
								};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var targetExpr = `;
						var argsList = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(targetExpr, shadowed, refs);
							{
								var ` = 0;
								while (` < argsList.length) {
									var a = argsList[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(a, shadowed, refs);
								};
							};
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var l = `;
						var r = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(l, shadowed, refs);
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(r, shadowed, refs);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 27) {
						{
							var left = `;
							var rhs = `;
							{
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(rhs, shadowed, refs);
							};
						};
					} else {};
				};
				case 28: {
					var ` = `[0];
					var ` = `[1];
					{
						var obj = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(obj, shadowed, refs);
						};
					};
				};
				case 29: {
					var ` = `[0];
					var ` = `[1];
					{
						var objectExpr = `;
						var key = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(objectExpr, shadowed, refs);
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(key, shadowed, refs);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var v = `;
						{
							if (! shadowed.exists(v)) {
								{
									refs.set(v, true);
								};
							};
						};
					};
				};
				case 39: {
					var ` = `[0];
					{
						var inner = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(inner, shadowed, refs);
						};
					};
				};
				case 41: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					var ` = `[4];
					{
						var gens = `;
						var filters = `;
						var body = `;
						var into = `;
						var _uniq = `;
						{
							var accum = reflaxe.elixir.ast.analyzers.VariableUsageCollector.cloneShadow(shadowed);
							{
								var ` = 0;
								while (` < gens.length) {
									var g = gens[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(g.expr, accum, refs);
									var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(g.pattern);
									for (k in add.keys()) {
										{
											accum.set(k, true);
										};
									};
								};
							};
							{
								var ` = 0;
								while (` < filters.length) {
									var f = filters[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(f, accum, refs);
								};
							};
							if (body != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(body, accum, refs);
							};
							if (into != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(into, shadowed, refs);
							};
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectArgVars(cl.args);
									var next = reflaxe.elixir.ast.analyzers.VariableUsageCollector.extendShadow(shadowed, add);
									if (cl.guard != null) {
										reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cl.guard, next, refs);
									};
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cl.body, next, refs);
								};
							};
						};
					};
				};
				case 51: {
					var ` = `[0];
					var ` = `[1];
					{
						var clauses = `;
						var after = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var cl = clauses[`];
									++ `;
									var add = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(cl.pattern);
									var next = reflaxe.elixir.ast.analyzers.VariableUsageCollector.extendShadow(shadowed, add);
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(cl.body, next, refs);
								};
							};
							if (after != null) {
								reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(after.body, shadowed, refs);
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						{
							{
								var ` = 0;
								while (` < stmts.length) {
									var s = stmts[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(s, shadowed, refs);
								};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(e, shadowed, refs);
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var statements = `;
						{
							{
								var ` = 0;
								while (` < statements.length) {
									var s = statements[`];
									++ `;
									reflaxe.elixir.ast.analyzers.VariableUsageCollector.walk(s, shadowed, refs);
								};
							};
						};
					};
				};
				default: {}
			};
		};
	}

	static function extendShadow(base:Map<String, Bool>, add:Map<String, Bool>) {
		var m = reflaxe.elixir.ast.analyzers.VariableUsageCollector.cloneShadow(base);
		for (k in add.keys()) {
			{
				m.set(k, true);
			};
		};
		return m;
	}

	static function cloneShadow(m:Map<String, Bool>) {
		var n = {
			{};
			new haxe.ds.StringMap();
		};
		for (k in m.keys()) {
			{
				n.set(k, true);
			};
		};
		return n;
	}

	static function collectArgVars(args:Array<reflaxe.elixir.ast.EPattern>) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		{
			var ` = 0;
			while (` < args.length) {
				var a = args[`];
				++ `;
				for (k in {
					var this = reflaxe.elixir.ast.analyzers.VariableUsageCollector.collectPatternVars(a);
					cast this.keys();
				}) {
					{
						m.set(k, true);
					};
				};
			};
		};
		return m;
	}

	static function collectPatternVars(p:reflaxe.elixir.ast.EPattern) {
		var m = {
			{};
			new haxe.ds.StringMap();
		};
		var add = function(nm:String) {
			if (nm == null) {
				return;
			};
			{
				m.set(nm, true);
			};
		};
		var visit = [null];
		visit[0] = function(pp:reflaxe.elixir.ast.EPattern) {
			@:ast(switch (pp) {
	case PVar(n):
		add(n);	
	case PAlias(varName, pat):
		add(varName);
		visit(pat);	
	case PTuple(es):
		for (e  in  es) visit(e);	
	case PList(es):
		for (e  in  es) visit(e);	
	case PCons(h, t):
		visit(h);
		visit(t);	
	case PMap(kvs):
		for (kv  in  kvs) visit(kv.value);	
	case PStruct(_, fs):
		for (f  in  fs) visit(f.value);	
	case PBinary(segs):
		for (s  in  segs) visit(s.pattern);	
	case PPin(inner):
		visit(inner);	
	default:
}) switch (enumIndex pp) {
				case 0: {
					var ` = pp[0];
					{
						var n = `;
						{
							add(n);
						};
					};
				};
				case 2: {
					var ` = pp[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									visit[0](e);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pp[0];
					{
						var es = `;
						{
							{
								var ` = 0;
								while (` < es.length) {
									var e = es[`];
									++ `;
									visit[0](e);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var h = `;
						var t = `;
						{
							visit[0](h);
							visit[0](t);
						};
					};
				};
				case 5: {
					var ` = pp[0];
					{
						var kvs = `;
						{
							{
								var ` = 0;
								while (` < kvs.length) {
									var kv = kvs[`];
									++ `;
									visit[0](kv.value);
								};
							};
						};
					};
				};
				case 6: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var fs = `;
						{
							{
								var ` = 0;
								while (` < fs.length) {
									var f = fs[`];
									++ `;
									visit[0](f.value);
								};
							};
						};
					};
				};
				case 7: {
					var ` = pp[0];
					{
						var inner = `;
						{
							visit[0](inner);
						};
					};
				};
				case 9: {
					var ` = pp[0];
					var ` = pp[1];
					{
						var varName = `;
						var pat = `;
						{
							add(varName);
							visit[0](pat);
						};
					};
				};
				case 10: {
					var ` = pp[0];
					{
						var segs = `;
						{
							{
								var ` = 0;
								while (` < segs.length) {
									var s = segs[`];
									++ `;
									visit[0](s.pattern);
								};
							};
						};
					};
				};
				default: {}
			};
		};
		visit[0](p);
		return m;
	}
}