class reflaxe.compiler.NullTypeEnforcer {

	@:value([])
	static var returnTypeStack:Array<Null<haxe.macro.Type>> = [];

	public static function checkAssignment(expr:Null<haxe.macro.TypedExpr>, type:Null<haxe.macro.Type>) {
		if (expr == null || type == null) {
			return;
		};
		if (reflaxe.helpers.TypedExprHelper.isNullExpr(expr) && ! reflaxe.helpers.TypeHelper.isNull(type)) {
			haxe.macro.Context.error("Cannot assign `null` to non-nullable type.", expr.pos, null);
		};
	}

	public static function checkClass(cls:haxe.macro.ClassType) {
		{
			var ` = 0;
			var ` = cls.fields.get();
			while (` < `.length) {
				var f = `[`];
				++ `;
				reflaxe.compiler.NullTypeEnforcer.checkClassField(f);
			};
		};
		{
			var ` = 0;
			var ` = cls.statics.get();
			while (` < `.length) {
				var f = `[`];
				++ `;
				reflaxe.compiler.NullTypeEnforcer.checkClassField(f);
			};
		};
	}

	public static function checkClassField(f:haxe.macro.ClassField) {
		var e = f.expr();
		if (e == null) {
			return;
		};
		@:ast(switch (f.kind) {
	case FVar(_, _):
		{
			checkAssignment(e, f.type);
			checkMaybeExpression(e);
		};	
	case FMethod(_):
		{
			returnTypeStack.push(switch (f.type) {
				case TFun(args, ret):
					ret;				
				case _:
					null;				
			});
			checkMaybeExpression(e);
			returnTypeStack.pop();
		};	
}) {
			var ` = f.kind;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					var ` = `[1];
					{
						{
							reflaxe.compiler.NullTypeEnforcer.checkAssignment(e, f.type);
							reflaxe.compiler.NullTypeEnforcer.checkMaybeExpression(e);
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						{
							reflaxe.compiler.NullTypeEnforcer.returnTypeStack.push(@:ast(switch (f.type) {
	case TFun(args, ret):
		ret;	
	case _:
		null;	
}) {
								var ` = f.type;
								if (enumIndex ` == 4) {
									var ` = `[0];
									var ` = `[1];
									{
										var args = `;
										var ret = `;
										{
											ret;
										};
									};
								} else {
									null;
								};
							});
							reflaxe.compiler.NullTypeEnforcer.checkMaybeExpression(e);
							reflaxe.compiler.NullTypeEnforcer.returnTypeStack.pop();
						};
					};
				};
			};
		};
	}

	public static function checkMaybeExpression(expr:Null<haxe.macro.TypedExpr>) {
		if (expr == null) {
			return;
		};
		reflaxe.compiler.NullTypeEnforcer.checkExpression(expr);
	}

	public static function checkExpression(expr:haxe.macro.TypedExpr) {
		expr.expr = haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TBool(true));
		@:ast(switch (expr.expr) {
	case TBinop(OpAssign, e1, e2):
		{
			checkAssignment(e2, e1.t);
		};	
	case TReturn(maybeExpr):
		{
			if (maybeExpr != null && returnTypeStack.length > 0) {
				checkAssignment(maybeExpr, returnTypeStack[returnTypeStack.length - 1]);
			};
		};	
	case TCall(e, el):
		{
			switch (e.t) {
				case TFun(args, ret):
					{
						for (i  in  0 ... el.length) {
							var argType = i < args.length ? args[i] : args[args.length - 1];
							if (!argType.opt) checkAssignment(el[i], argType.t);
						};
					};				
				case _:
					{ };				
			};
		};	
	case TVar(tvar, maybeExpr):
		{
			checkAssignment(maybeExpr, tvar.t);
		};	
	case _:
		{ };	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 4) {
						{
							var e1 = `;
							var e2 = `;
							{
								{
									reflaxe.compiler.NullTypeEnforcer.checkAssignment(e2, e1.t);
								};
							};
						};
					} else {
						{};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						{
							{
								@:ast(switch (e.t) {
	case TFun(args, ret):
		{
			for (i  in  0 ... el.length) {
				var argType = i < args.length ? args[i] : args[args.length - 1];
				if (!argType.opt) checkAssignment(el[i], argType.t);
			};
		};	
	case _:
		{ };	
}) {
									var ` = e.t;
									if (enumIndex ` == 4) {
										var ` = `[0];
										var ` = `[1];
										{
											var args = `;
											var ret = `;
											{
												{
													{
														var ` = 0;
														var ` = el.length;
														while (` < `) {
															var i = ` ++;
															var argType = if (i < args.length) {
																args[i];
															} else {
																args[args.length - 1];
															};
															if (! argType.opt) {
																reflaxe.compiler.NullTypeEnforcer.checkAssignment(el[i], argType.t);
															};
														};
													};
												};
											};
										};
									} else {
										{};
									};
								};
							};
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var tvar = `;
						var maybeExpr = `;
						{
							{
								reflaxe.compiler.NullTypeEnforcer.checkAssignment(maybeExpr, tvar.t);
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var maybeExpr = `;
						{
							{
								if (maybeExpr != null && reflaxe.compiler.NullTypeEnforcer.returnTypeStack.length > 0) {
									reflaxe.compiler.NullTypeEnforcer.checkAssignment(maybeExpr, reflaxe.compiler.NullTypeEnforcer.returnTypeStack[reflaxe.compiler.NullTypeEnforcer.returnTypeStack.length - 1]);
								};
							};
						};
					};
				};
				default: {
					{};
				}
			};
		};
		haxe.macro.TypedExprTools.iter(expr, reflaxe.compiler.NullTypeEnforcer.checkExpression);
	}

	static inline function nullComparable(type:haxe.macro.Type) {
		return reflaxe.helpers.TypeHelper.isNull(type) || reflaxe.helpers.TypeHelper.isDynamic(type);
	}

	public static function modifyExpression(expr:haxe.macro.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TBinop(b, e1, e2) if (b == OpEq || b == OpNotEq):
		{
			if (e1.isNullExpr() && e2.isNullExpr()) {
				expr.expr = TConst(TBool(b == OpEq));
			} else if (e1.isNullExpr()) {
				if (!nullComparable(e2.t)) {
					expr.expr = TConst(TBool(b == OpNotEq));
				};
			} else if (e2.isNullExpr()) {
				if (!nullComparable(e1.t)) {
					expr.expr = TConst(TBool(b == OpNotEq));
				};
			};
		};	
	case _:
		{ };	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var b = `;
					var e1 = `;
					var e2 = `;
					if (b == haxe.macro.Binop.OpEq || b == haxe.macro.Binop.OpNotEq) {
						{
							if (reflaxe.helpers.TypedExprHelper.isNullExpr(e1) && reflaxe.helpers.TypedExprHelper.isNullExpr(e2)) {
								expr.expr = haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TBool(b == haxe.macro.Binop.OpEq));
							} else {
								if (reflaxe.helpers.TypedExprHelper.isNullExpr(e1)) {
									if (! {
										var type = e2.t;
										reflaxe.helpers.TypeHelper.isNull(type) || reflaxe.helpers.TypeHelper.isDynamic(type);
									}) {
										expr.expr = haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TBool(b == haxe.macro.Binop.OpNotEq));
									};
								} else {
									if (reflaxe.helpers.TypedExprHelper.isNullExpr(e2)) {
										if (! {
											var type = e1.t;
											reflaxe.helpers.TypeHelper.isNull(type) || reflaxe.helpers.TypeHelper.isDynamic(type);
										}) {
											expr.expr = haxe.macro.TypedExprDef.TConst(haxe.macro.TConstant.TBool(b == haxe.macro.Binop.OpNotEq));
										};
									};
								};
							};
						};
					} else {
						{};
					};
				};
			} else {
				{};
			};
		};
		haxe.macro.TypedExprTools.iter(expr, reflaxe.compiler.NullTypeEnforcer.modifyExpression);
	}
}