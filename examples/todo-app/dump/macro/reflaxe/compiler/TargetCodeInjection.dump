class reflaxe.compiler.TargetCodeInjection {

	public static function checkTargetCodeInjection(injectFunctionName:String, expr:haxe.macro.TypedExpr, compiler:reflaxe.DirectToStringCompiler) {
		var arguments = [null];
		var callIdent = @:ast(switch (expr.expr) {
	case TCall(e, el):
		{
			switch (e.expr) {
				case TIdent(id):
					{
						arguments = el;
						id;
					};				
				case TLocal(v) if (v.name == injectFunctionName):
					{
						arguments = el;
						v.name;
					};				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					var el = `;
					{
						{
							@:ast(switch (e.expr) {
	case TIdent(id):
		{
			arguments = el;
			id;
		};	
	case TLocal(v) if (v.name == injectFunctionName):
		{
			arguments = el;
			v.name;
		};	
	case _:
		null;	
}) {
								var ` = e.expr;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										{
											var v = `;
											if (v.name == injectFunctionName) {
												{
													arguments[0] = el;
													v.name;
												};
											} else {
												null;
											};
										};
									};
									case 28: {
										var ` = `[0];
										{
											var id = `;
											{
												{
													arguments[0] = el;
													id;
												};
											};
										};
									};
									default: {
										null;
									}
								};
							};
						};
					};
				};
			} else {
				null;
			};
		};
		return if (callIdent == injectFunctionName && arguments[0] != null) {
			if (arguments[0].length == 0) {
				haxe.macro.Context.error(injectFunctionName + " requires at least one String argument.", expr.pos, null);
			};
			var injectionString = @:ast(switch (arguments[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		{
			Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0].pos);
		};	
}) {
				var ` = arguments[0][0].expr;
				if (enumIndex ` == 0) {
					var ` = `[0];
					if (enumIndex ` == 2) {
						var ` = `[0];
						{
							var s = `;
							{
								s;
							};
						};
					} else {
						{
							haxe.macro.Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0][0].pos, null);
						};
					};
				} else {
					{
						haxe.macro.Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0][0].pos, null);
					};
				};
			};
			var injectionArguments = {
				var ` = [];
				{
					var ` = 1;
					var ` = arguments[0].length;
					while (` < `) {
						var _ = ` ++;
						`.push(null);
					};
				};
				`;
			};
			var getArg = function(i:Int) {
				return if (i < injectionArguments.length) {
					if (injectionArguments[i] == null) {
						var arg = compiler.compileExpressionForCodeInject(arguments[0][i + 1]);
						if (arg == null) {
							haxe.macro.Context.error("Compiled expression resulted in nothing.", arguments[0][i].pos, null);
						} else {
							injectionArguments[i] = arg;
						};
					};
					injectionArguments[i];
				} else {
					null;
				};
			};
			new EReg("{(\\d+)}", "g").map(injectionString, function(ereg:EReg) {
				var num = Std.parseInt(ereg.matched(1));
				var num = if (num != null) {
					getArg(num);
				} else {
					null;
				};
				return @:mergeBlock {
					var tmp = {
						num;
					};
					if (tmp != null) tmp else {
						ereg.matched(0);
					};
				};
			});
		} else {
			null;
		};
	}

	public static function checkTargetCodeInjectionGeneric<A, B, ExpressionType, C, D>(injectFunctionName:String, expr:haxe.macro.TypedExpr, compiler:reflaxe.GenericCompiler<checkTargetCodeInjectionGeneric.A, checkTargetCodeInjectionGeneric.B, checkTargetCodeInjectionGeneric.ExpressionType, checkTargetCodeInjectionGeneric.C, checkTargetCodeInjectionGeneric.D>) {
		var arguments = [null];
		var callIdent = @:ast(switch (expr.expr) {
	case TCall(e, el):
		{
			switch (e.expr) {
				case TIdent(id):
					{
						arguments = el;
						id;
					};				
				case TLocal(v) if (v.name == injectFunctionName):
					{
						arguments = el;
						v.name;
					};				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					var el = `;
					{
						{
							@:ast(switch (e.expr) {
	case TIdent(id):
		{
			arguments = el;
			id;
		};	
	case TLocal(v) if (v.name == injectFunctionName):
		{
			arguments = el;
			v.name;
		};	
	case _:
		null;	
}) {
								var ` = e.expr;
								switch (enumIndex `) {
									case 1: {
										var ` = `[0];
										{
											var v = `;
											if (v.name == injectFunctionName) {
												{
													arguments[0] = el;
													v.name;
												};
											} else {
												null;
											};
										};
									};
									case 28: {
										var ` = `[0];
										{
											var id = `;
											{
												{
													arguments[0] = el;
													id;
												};
											};
										};
									};
									default: {
										null;
									}
								};
							};
						};
					};
				};
			} else {
				null;
			};
		};
		if (callIdent != injectFunctionName || arguments[0] == null) {
			return null;
		};
		if (arguments[0].length == 0) {
			haxe.macro.Context.error(injectFunctionName + " requires at least one String argument.", expr.pos, null);
		};
		var injectionString = @:ast(switch (arguments[0].expr) {
	case TConst(TString(s)):
		s;	
	case _:
		{
			Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0].pos);
		};	
}) {
			var ` = arguments[0][0].expr;
			if (enumIndex ` == 0) {
				var ` = `[0];
				if (enumIndex ` == 2) {
					var ` = `[0];
					{
						var s = `;
						{
							s;
						};
					};
				} else {
					{
						haxe.macro.Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0][0].pos, null);
					};
				};
			} else {
				{
					haxe.macro.Context.error(injectFunctionName + " first parameter must be a constant String.", arguments[0][0].pos, null);
				};
			};
		};
		var injectionArguments = {
			var ` = [];
			{
				var ` = 1;
				var ` = arguments[0].length;
				while (` < `) {
					var _ = ` ++;
					`.push(null);
				};
			};
			`;
		};
		var getArg = function(i:Int) {
			return if (i < injectionArguments.length) {
				if (injectionArguments[i] == null) {
					var arg = compiler.compileExpression(arguments[0][i + 1], null);
					if (arg == null) {
						haxe.macro.Context.error("Compiled expression resulted in nothing.", arguments[0][i].pos, null);
					} else {
						injectionArguments[i] = arg;
					};
				};
				injectionArguments[i];
			} else {
				null;
			};
		};
		var result = [];
		var lastMatchPosition = [null];
		new EReg("{(\\d+)}", "g").map(injectionString, function(ereg:EReg) {
			var lastPos = if (lastMatchPosition[0] == null) {
				0;
			} else {
				lastMatchPosition[0].pos + lastMatchPosition[0].len;
			};
			lastMatchPosition[0] = ereg.matchedPos();
			if (lastMatchPosition[0].pos != lastPos) {
				result.push(haxe.ds.Either.Left(injectionString.substring(lastPos, lastMatchPosition[0].pos)));
			};
			var expressionIndex = Std.parseInt(ereg.matched(1));
			var expression = if (expressionIndex != null) {
				getArg(expressionIndex);
			} else {
				null;
			};
			if (expression != null) {
				result.push(haxe.ds.Either.Right(expression));
			};
			return "";
		});
		if (lastMatchPosition[0] != null) {
			result.push(haxe.ds.Either.Left(injectionString.substring(lastMatchPosition[0].pos + lastMatchPosition[0].len, null)));
		};
		return result;
	}
}