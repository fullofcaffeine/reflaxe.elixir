class reflaxe.helpers.TypeHelper {

	public static function findResolvedTypeParams(t:haxe.macro.Type, cf:haxe.macro.ClassField) {
		if (cf.params.length == 0) {
			return [];
		};
		var result = [];
		var paramNameIndexMap = {
			{};
			new haxe.ds.StringMap();
		};
		{
			var ` = 0;
			var ` = cf.params.length;
			while (` < `) {
				var i = ` ++;
				{
					var key = cf.params[i].name;
					paramNameIndexMap.set(key, i);
				};
				result.push(null);
			};
		};
		var resolvedTypes = reflaxe.helpers.TypeHelper.getSubTypeList(t);
		var cfSubTypes = reflaxe.helpers.TypeHelper.getSubTypeList(cf.type);
		{
			var ` = cast new haxe.iterators.MapKeyValueIterator(cfSubTypes);
			while (`.hasNext()) {
				var ` = `.next();
				var key = `.key;
				var subType = `.value;
				{
					var typeParamName = reflaxe.helpers.TypeHelper.getTypeParameterName(subType);
					if (typeParamName != null && paramNameIndexMap.exists(typeParamName)) {
						var index = cast paramNameIndexMap.get(typeParamName);
						if (index != null && result[index] == null) {
							result[index] = cast resolvedTypes.get(key);
						};
					};
				};
			};
		};
		{
			var ` = 0;
			while (` < result.length) {
				var type = result[`];
				++ `;
				if (type == null) {
					return null;
				};
			};
		};
		return cast cast {
			if (result == null) {
				throw "Trusted on null value.";
			};
			@:nullSafety(Off) result;
		};
	}

	public static function getSubTypeList(t:haxe.macro.Type) {
		var result = {
			{};
			new haxe.ds.StringMap();
		};
		var index = [0];
		if (t == null) {
			return {
				{};
				new haxe.ds.StringMap();
			};
		};
		haxe.macro.TypeTools.iter(t, function(subType:haxe.macro.Type) {
			if (subType != null) {
				var si = Std.string(index[0]);
				{
					result.set(si, subType);
				};
				{
					var ` = {
						var this = reflaxe.helpers.TypeHelper.getSubTypeList(subType);
						cast new haxe.iterators.MapKeyValueIterator(cast this);
					};
					while (`.hasNext()) {
						var ` = `.next();
						var id = `.key;
						var subSubType = `.value;
						{
							{
								result.set(si + "_" + id, subSubType);
							};
						};
					};
				};
			};
			index[0] ++;
		});
		return result;
	}

	public static function fromModuleType(t:haxe.macro.ModuleType) {
		return @:ast(switch (t) {
	case TClassDecl(c):
		TInst(c, extractParamTypes(c.get().params));	
	case TEnumDecl(e):
		TEnum(e, extractParamTypes(e.get().params));	
	case TTypeDecl(t):
		TType(t, extractParamTypes(t.get().params));	
	case TAbstract(a):
		TAbstract(a, extractParamTypes(a.get().params));	
}) switch (@:exhaustive enumIndex t) {
			case 0: {
				var ` = t[0];
				{
					var c = `;
					{
						haxe.macro.Type.TInst(c, reflaxe.helpers.TypeHelper.extractParamTypes(c.get().params));
					};
				};
			};
			case 1: {
				var ` = t[0];
				{
					var e = `;
					{
						haxe.macro.Type.TEnum(e, reflaxe.helpers.TypeHelper.extractParamTypes(e.get().params));
					};
				};
			};
			case 2: {
				var ` = t[0];
				{
					var t = `;
					{
						haxe.macro.Type.TType(t, reflaxe.helpers.TypeHelper.extractParamTypes(t.get().params));
					};
				};
			};
			case 3: {
				var ` = t[0];
				{
					var a = `;
					{
						haxe.macro.Type.TAbstract(a, reflaxe.helpers.TypeHelper.extractParamTypes(a.get().params));
					};
				};
			};
		};
	}

	public static function toModuleType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		TClassDecl(c);	
	case TEnum(e, _):
		TEnumDecl(e);	
	case TType(t, _):
		TTypeDecl(t);	
	case TAbstract(a, _):
		TAbstract(a);	
	case TLazy(f):
		toModuleType(f());	
	case TMono(t):
		{
			var type = t.get();
			if (type != null) {
				toModuleType(type);
			} else {
				null;
			};
		};	
	case _:
		null;	
}) switch (enumIndex t) {
			case 0: {
				var ` = t[0];
				{
					var t = `;
					{
						{
							var type = t.get();
							if (type != null) {
								reflaxe.helpers.TypeHelper.toModuleType(type);
							} else {
								null;
							};
						};
					};
				};
			};
			case 1: {
				var ` = t[0];
				var ` = t[1];
				{
					var e = `;
					{
						haxe.macro.ModuleType.TEnumDecl(e);
					};
				};
			};
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						haxe.macro.ModuleType.TClassDecl(c);
					};
				};
			};
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var t = `;
					{
						haxe.macro.ModuleType.TTypeDecl(t);
					};
				};
			};
			case 7: {
				var ` = t[0];
				{
					var f = `;
					{
						reflaxe.helpers.TypeHelper.toModuleType(f());
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					{
						haxe.macro.ModuleType.TAbstract(a);
					};
				};
			};
			default: {
				null;
			}
		};
	}

	public static function getUniqueId(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TLazy(f):
		getUniqueId(f());	
	case TAnonymous(_) | TFun(_, _):
		Std.string(t);	
	case TDynamic(t):
		{
			if (t != null) {
				"TD" + getUniqueId(t);
			} else {
				"TD_Empty";
			};
		};	
	case TMono(t):
		{
			var type = t.get();
			if (type != null) {
				"TM" + getUniqueId(type);
			} else {
				"TM_Empty";
			};
		};	
	case _:
		{
			var mt = toModuleType(t);
			if (mt != null) {
				"T" + mt.getUniqueId();
			} else {
				"___TYPEUNIQUEID___" + Std.string(t);
			};
		};	
}) switch (enumIndex t) {
			case 0: {
				var ` = t[0];
				{
					var t = `;
					{
						{
							var type = t.get();
							if (type != null) {
								"TM" + reflaxe.helpers.TypeHelper.getUniqueId(type);
							} else {
								"TM_Empty";
							};
						};
					};
				};
			};
			case 4: {
				var ` = t[0];
				var ` = t[1];
				{
					Std.string(t);
				};
			};
			case 5: {
				var ` = t[0];
				{
					Std.string(t);
				};
			};
			case 6: {
				var ` = t[0];
				{
					var t = `;
					{
						{
							if (t != null) {
								"TD" + reflaxe.helpers.TypeHelper.getUniqueId(t);
							} else {
								"TD_Empty";
							};
						};
					};
				};
			};
			case 7: {
				var ` = t[0];
				{
					var f = `;
					{
						reflaxe.helpers.TypeHelper.getUniqueId(f());
					};
				};
			};
			default: {
				{
					var mt = reflaxe.helpers.TypeHelper.toModuleType(t);
					if (mt != null) {
						"T" + reflaxe.helpers.ModuleTypeHelper.getUniqueId(mt);
					} else {
						"___TYPEUNIQUEID___" + Std.string(t);
					};
				};
			}
		};
	}

	public static function equals(type:haxe.macro.Type, other:haxe.macro.Type) {
		if (reflaxe.helpers.TypeHelper.isNumberType(type) && reflaxe.helpers.TypeHelper.isNumberType(other)) {
			return true;
		};
		return Std.string(type) == Std.string(other);
	}

	public static function getMeta(type:haxe.macro.Type) {
		return @:ast(switch (type) {
	case TInst(c, _):
		c.get().meta;	
	case TEnum(e, _):
		e.get().meta;	
	case TType(t, _):
		t.get().meta;	
	case TAbstract(a, _):
		a.get().meta;	
	case TLazy(f):
		getMeta(f());	
	case TMono(t):
		{
			var type = t.get();
			if (type != null) {
				getMeta(type);
			} else {
				null;
			};
		};	
	case _:
		null;	
}) switch (enumIndex type) {
			case 0: {
				var ` = type[0];
				{
					var t = `;
					{
						{
							var type = t.get();
							if (type != null) {
								reflaxe.helpers.TypeHelper.getMeta(type);
							} else {
								null;
							};
						};
					};
				};
			};
			case 1: {
				var ` = type[0];
				var ` = type[1];
				{
					var e = `;
					{
						e.get().meta;
					};
				};
			};
			case 2: {
				var ` = type[0];
				var ` = type[1];
				{
					var c = `;
					{
						c.get().meta;
					};
				};
			};
			case 3: {
				var ` = type[0];
				var ` = type[1];
				{
					var t = `;
					{
						t.get().meta;
					};
				};
			};
			case 7: {
				var ` = type[0];
				{
					var f = `;
					{
						reflaxe.helpers.TypeHelper.getMeta(f());
					};
				};
			};
			case 8: {
				var ` = type[0];
				var ` = type[1];
				{
					var a = `;
					{
						a.get().meta;
					};
				};
			};
			default: {
				null;
			}
		};
	}

	public static function convertAnonToModuleType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAnonymous(anonTypeRef):
		{
			var anonType = anonTypeRef.get();
			switch (anonType.status) {
				case AClassStatics(c):
					TClassDecl(c);				
				case AEnumStatics(e):
					TEnumDecl(e);				
				case AAbstractStatics(a):
					TAbstract(a);				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) if (enumIndex t == 5) {
			var ` = t[0];
			{
				var anonTypeRef = `;
				{
					{
						var anonType = anonTypeRef.get();
						@:ast(switch (anonType.status) {
	case AClassStatics(c):
		TClassDecl(c);	
	case AEnumStatics(e):
		TEnumDecl(e);	
	case AAbstractStatics(a):
		TAbstract(a);	
	case _:
		null;	
}) {
							var ` = anonType.status;
							switch (enumIndex `) {
								case 4: {
									var ` = `[0];
									{
										var c = `;
										{
											haxe.macro.ModuleType.TClassDecl(c);
										};
									};
								};
								case 5: {
									var ` = `[0];
									{
										var e = `;
										{
											haxe.macro.ModuleType.TEnumDecl(e);
										};
									};
								};
								case 6: {
									var ` = `[0];
									{
										var a = `;
										{
											haxe.macro.ModuleType.TAbstract(a);
										};
									};
								};
								default: {
									null;
								}
							};
						};
					};
				};
			};
		} else {
			null;
		};
	}

	public static function getParams(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TEnum(_, params) | TInst(_, params) | TType(_, params) | TAbstract(_, params):
		params;	
	case _:
		null;	
}) switch (enumIndex t) {
			case 1: {
				var ` = t[0];
				var ` = t[1];
				{
					var params = `;
					{
						params;
					};
				};
			};
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var params = `;
					{
						params;
					};
				};
			};
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var params = `;
					{
						params;
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var params = `;
					{
						params;
					};
				};
			};
			default: {
				null;
			}
		};
	}

	public static function withParams(t:haxe.macro.Type, params:Array<haxe.macro.Type>) {
		return @:ast(switch (t) {
	case TEnum(e, _):
		TEnum(e, params);	
	case TInst(i, _):
		TInst(i, params);	
	case TType(t, _):
		TType(t, params);	
	case TAbstract(a, _):
		TAbstract(a, params);	
	case _:
		null;	
}) switch (enumIndex t) {
			case 1: {
				var ` = t[0];
				var ` = t[1];
				{
					var e = `;
					{
						haxe.macro.Type.TEnum(e, params);
					};
				};
			};
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var i = `;
					{
						haxe.macro.Type.TInst(i, params);
					};
				};
			};
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var t = `;
					{
						haxe.macro.Type.TType(t, params);
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					{
						haxe.macro.Type.TAbstract(a, params);
					};
				};
			};
			default: {
				null;
			}
		};
	}

	public static function mapParams(t:haxe.macro.Type, callback:(haxe.macro.Type, Int) -> haxe.macro.Type) {
		var params = reflaxe.helpers.TypeHelper.getParams(t);
		if (params == null) {
			return null;
		};
		var newParams = [];
		{
			var ` = 0;
			var ` = params.length;
			while (` < `) {
				var i = ` ++;
				newParams.push(callback(params[i], i));
			};
		};
		return reflaxe.helpers.TypeHelper.withParams(t, newParams);
	}

	static function extractParamTypes(params:Array<haxe.macro.TypeParameter>) {
		return {
			var ` = [];
			{
				var ` = 0;
				var ` = params;
				while (` < `.length) {
					var v = `[`];
					++ `;
					`.push(function(tp:haxe.macro.TypeParameter) {
						return tp.t;
					}(v));
				};
			};
			`;
		};
	}

	public static function isEnum(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TEnum(_, _):
		true;	
	case _:
		false;	
}) if (enumIndex t == 1) {
			var ` = t[0];
			var ` = t[1];
			{
				true;
			};
		} else {
			false;
		};
	}

	public static function isMonomorph(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TMono(_):
		true;	
	case _:
		false;	
}) if (enumIndex t == 0) {
			var ` = t[0];
			{
				true;
			};
		} else {
			false;
		};
	}

	public static function isTypedef(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TType(_, _):
		true;	
	case _:
		false;	
}) if (enumIndex t == 3) {
			var ` = t[0];
			var ` = t[1];
			{
				true;
			};
		} else {
			false;
		};
	}

	public static function isAnonStruct(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAnonymous(_):
		true;	
	case _:
		false;	
}) if (enumIndex t == 5) {
			var ` = t[0];
			{
				true;
			};
		} else {
			false;
		};
	}

	public static function isDynamic(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TDynamic(_):
		true;	
	case _:
		false;	
}) if (enumIndex t == 6) {
			var ` = t[0];
			{
				true;
			};
		} else {
			false;
		};
	}

	public static function isVoid(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(absRef, []):
		{
			absRef.get().name == "Void";
		};	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var absRef = `;
					{
						{
							absRef.get().name == "Void";
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isBool(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(_.get() => abs, []) if (abs.module == "StdTypes" && abs.name == "Bool"):
		true;	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var _hx_tmp;
					{
						var abs = (_hx_tmp = `.get());
						if (abs.module == "StdTypes" && abs.name == "Bool") {
							true;
						} else {
							false;
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isInt(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(_.get() => abs, []) if (abs.module == "StdTypes" && abs.name == "Int"):
		true;	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var _hx_tmp;
					{
						var abs = (_hx_tmp = `.get());
						if (abs.module == "StdTypes" && abs.name == "Int") {
							true;
						} else {
							false;
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isFloat(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(_.get() => abs, []) if (abs.module == "StdTypes" && abs.name == "Float"):
		true;	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var _hx_tmp;
					{
						var abs = (_hx_tmp = `.get());
						if (abs.module == "StdTypes" && abs.name == "Float") {
							true;
						} else {
							false;
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isString(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(clsTypeRef, []):
		{
			var clsType = clsTypeRef.get();
			var isNameString = clsType.hasMeta(":native") || clsType.name == "String";
			isNameString && clsType.module == "String" && clsType.pack.length == 0 && clsType.hasMeta(":coreApi");
		};	
	case _:
		false;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var clsTypeRef = `;
					{
						{
							var clsType = clsTypeRef.get();
							var isNameString = reflaxe.helpers.NameMetaHelper.hasMeta(clsType, ":native") || clsType.name == "String";
							isNameString && clsType.module == "String" && clsType.pack.length == 0 && reflaxe.helpers.NameMetaHelper.hasMeta(clsType, ":coreApi");
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isPrimitive(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(abTypeRef, []):
		{
			var abType = abTypeRef.get();
			abType.module == "StdTypes" && (abType.name == "Int" || abType.name == "Float" || abType.name == "Bool");
		};	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var abTypeRef = `;
					{
						{
							var abType = abTypeRef.get();
							abType.module == "StdTypes" && (abType.name == "Int" || abType.name == "Float" || abType.name == "Bool");
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isNumberType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(abTypeRef, []):
		{
			var abType = abTypeRef.get();
			if (abType.module == "StdTypes") {
				(abType.name == "Int" || abType.name == "Float" || abType.name == "Single");
			} else {
				(abType.module == "UInt" && abType.name == "UInt");
			};
		};	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var abTypeRef = `;
					{
						{
							var abType = abTypeRef.get();
							if (abType.module == "StdTypes") {
								(abType.name == "Int" || abType.name == "Float" || abType.name == "Single");
							} else {
								(abType.module == "UInt" && abType.name == "UInt");
							};
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isAny(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(absRef, []):
		{
			absRef.get().name == "Any";
		};	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			if (`.length == 0) {
				{
					var absRef = `;
					{
						{
							absRef.get().name == "Any";
						};
					};
				};
			} else {
				false;
			};
		} else {
			false;
		};
	}

	public static function isNull(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(absRef, params) if (params.length == 1):
		{
			absRef.get().name == "Null";
		};	
	case _:
		false;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			{
				var absRef = `;
				var params = `;
				if (params.length == 1) {
					{
						absRef.get().name == "Null";
					};
				} else {
					false;
				};
			};
		} else {
			false;
		};
	}

	public static function isClass(t:haxe.macro.Type) {
		return reflaxe.helpers.TypeHelper.getClassParameter(t) != null;
	}

	public static function isUnresolvedMonomorph(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TMono(tRef):
		{
			return tRef.get() == null;
		};	
	case _:
		false;	
}) if (enumIndex t == 0) {
			var ` = t[0];
			{
				var tRef = `;
				{
					{
						return tRef.get() == null;
					};
				};
			};
		} else {
			false;
		};
	}

	public static function isTypeParameter(t:haxe.macro.Type) {
		return reflaxe.helpers.TypeHelper.getTypeParameterName(t) != null;
	}

	public static function getTypeParameterName(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(clsRef, params):
		{
			switch (clsRef.get().kind) {
				case KTypeParameter(_):
					clsRef.get().name;				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var clsRef = `;
				var params = `;
				{
					{
						@:ast(switch (clsRef.get().kind) {
	case KTypeParameter(_):
		clsRef.get().name;	
	case _:
		null;	
}) {
							var ` = clsRef.get().kind;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									clsRef.get().name;
								};
							} else {
								null;
							};
						};
					};
				};
			};
		} else {
			null;
		};
	}

	public static function extractTypeParameterConstraints(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(clsRef, params):
		{
			switch (clsRef.get().kind) {
				case KTypeParameter(constraints):
					constraints;				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var clsRef = `;
				var params = `;
				{
					{
						@:ast(switch (clsRef.get().kind) {
	case KTypeParameter(constraints):
		constraints;	
	case _:
		null;	
}) {
							var ` = clsRef.get().kind;
							if (enumIndex ` == 1) {
								var ` = `[0];
								{
									var constraints = `;
									{
										constraints;
									};
								};
							} else {
								null;
							};
						};
					};
				};
			};
		} else {
			null;
		};
	}

	public static function extractTypeParameterConstType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(_.get() => { kind : KTypeParameter(constraints), meta : meta, pos : pos }, _) if (constraints.length == 1 && meta.has(":const")):
		{
			constraints[0];
		};	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var _hx_tmp;
				{
					var ` = (_hx_tmp = `.get()).constructor;
					var ` = _hx_tmp.doc;
					var ` = _hx_tmp.fields;
					var ` = _hx_tmp.init;
					var ` = _hx_tmp.interfaces;
					var ` = _hx_tmp.isAbstract;
					var ` = _hx_tmp.isExtern;
					var ` = _hx_tmp.isFinal;
					var ` = _hx_tmp.isInterface;
					var ` = _hx_tmp.isPrivate;
					var ` = _hx_tmp.kind;
					var ` = _hx_tmp.meta;
					var ` = _hx_tmp.module;
					var ` = _hx_tmp.name;
					var ` = _hx_tmp.overrides;
					var ` = _hx_tmp.pack;
					var ` = _hx_tmp.params;
					var ` = _hx_tmp.pos;
					var ` = _hx_tmp.statics;
					var ` = _hx_tmp.superClass;
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							var constraints = `;
							var meta = `;
							var pos = `;
							if (constraints.length == 1 && meta.has(":const")) {
								{
									constraints[0];
								};
							} else {
								null;
							};
						};
					} else {
						null;
					};
				};
			};
		} else {
			null;
		};
	}

	public static function getClassParameter(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(absRef, [param]):
		{
			var abs = absRef.get();
			if (abs.name == "Class" && abs.module == "Class" && abs.pack.length == 0) {
				toModuleType(param);
			} else {
				null;
			};
		};	
	case TType(defRef, []):
		{
			switch (defRef.get().type) {
				case TAnonymous(anon):
					{
						switch (anon.get().status) {
							case AClassStatics(clsRef):
								TClassDecl(clsRef);							
							case AEnumStatics(enumRef):
								TEnumDecl(enumRef);							
							case AAbstractStatics(absRef):
								TAbstract(absRef);							
							case _:
								null;							
						};
					};				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) switch (enumIndex t) {
			case 3: {
				var ` = t[0];
				var ` = t[1];
				if (`.length == 0) {
					{
						var defRef = `;
						{
							{
								@:ast(switch (defRef.get().type) {
	case TAnonymous(anon):
		{
			switch (anon.get().status) {
				case AClassStatics(clsRef):
					TClassDecl(clsRef);				
				case AEnumStatics(enumRef):
					TEnumDecl(enumRef);				
				case AAbstractStatics(absRef):
					TAbstract(absRef);				
				case _:
					null;				
			};
		};	
	case _:
		null;	
}) {
									var ` = defRef.get().type;
									if (enumIndex ` == 5) {
										var ` = `[0];
										{
											var anon = `;
											{
												{
													@:ast(switch (anon.get().status) {
	case AClassStatics(clsRef):
		TClassDecl(clsRef);	
	case AEnumStatics(enumRef):
		TEnumDecl(enumRef);	
	case AAbstractStatics(absRef):
		TAbstract(absRef);	
	case _:
		null;	
}) {
														var ` = anon.get().status;
														switch (enumIndex `) {
															case 4: {
																var ` = `[0];
																{
																	var clsRef = `;
																	{
																		haxe.macro.ModuleType.TClassDecl(clsRef);
																	};
																};
															};
															case 5: {
																var ` = `[0];
																{
																	var enumRef = `;
																	{
																		haxe.macro.ModuleType.TEnumDecl(enumRef);
																	};
																};
															};
															case 6: {
																var ` = `[0];
																{
																	var absRef = `;
																	{
																		haxe.macro.ModuleType.TAbstract(absRef);
																	};
																};
															};
															default: {
																null;
															}
														};
													};
												};
											};
										};
									} else {
										null;
									};
								};
							};
						};
					};
				} else {
					null;
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				if (`.length == 1) {
					var ` = `[0];
					{
						var param = `;
						var absRef = `;
						{
							{
								var abs = absRef.get();
								if (abs.name == "Class" && abs.module == "Class" && abs.pack.length == 0) {
									reflaxe.helpers.TypeHelper.toModuleType(param);
								} else {
									null;
								};
							};
						};
					};
				} else {
					null;
				};
			};
			default: {
				null;
			}
		};
	}

	public static function isExprClass(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(_.get().isExprClass() => true, _):
		true;	
	case _:
		false;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var _hx_tmp;
				if ((_hx_tmp = reflaxe.helpers.ClassTypeHelper.isExprClass(`.get())) == true) {
					{
						true;
					};
				} else {
					false;
				};
			};
		} else {
			false;
		};
	}

	public static function wrapWithNull(t:haxe.macro.Type) {
		return @:ast(switch (Context.getType("Null")) {
	case TAbstract(abRef, _):
		{
			TAbstract(abRef, [t]);
		};	
	case _:
		{
			throw "Could not find Null<T>";
		};	
}) {
			var ` = reflaxe.helpers.Context.getType("Null");
			if (enumIndex ` == 8) {
				var ` = `[0];
				var ` = `[1];
				{
					var abRef = `;
					{
						{
							haxe.macro.Type.TAbstract(abRef, [t]);
						};
					};
				};
			} else {
				{
					throw "Could not find Null<T>";
				};
			};
		};
	}

	public static function unwrapNullType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TAbstract(absRef, params) if (params.length == 1):
		{
			var abs = absRef.get();
			if (abs.name == "Null" && abs.pack.length == 0) {
				params[0];
			} else {
				null;
			};
		};	
	case _:
		null;	
}) if (enumIndex t == 8) {
			var ` = t[0];
			var ` = t[1];
			{
				var absRef = `;
				var params = `;
				if (params.length == 1) {
					{
						var abs = absRef.get();
						if (abs.name == "Null" && abs.pack.length == 0) {
							params[0];
						} else {
							null;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	public static function unwrapNullTypeOrSelf(t:haxe.macro.Type) {
		var temp = reflaxe.helpers.TypeHelper.unwrapNullType(t);
		return if (temp != null) {
			temp;
		} else {
			t;
		};
	}

	public static function unwrapArrayType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(clsRef, params) if (params.length == 1):
		{
			var cls = clsRef.get();
			if (cls.name == "Array" && cls.pack.length == 0) {
				params[0];
			} else {
				null;
			};
		};	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var clsRef = `;
				var params = `;
				if (params.length == 1) {
					{
						var cls = clsRef.get();
						if (cls.name == "Array" && cls.pack.length == 0) {
							params[0];
						} else {
							null;
						};
					};
				} else {
					null;
				};
			};
		} else {
			null;
		};
	}

	public static function getTFunArgs(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TFun(args, _):
		args;	
	case _:
		null;	
}) if (enumIndex t == 4) {
			var ` = t[0];
			var ` = t[1];
			{
				var args = `;
				{
					args;
				};
			};
		} else {
			null;
		};
	}

	public static function getTFunReturn(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TFun(_, ret):
		ret;	
	case _:
		null;	
}) if (enumIndex t == 4) {
			var ` = t[0];
			var ` = t[1];
			{
				var ret = `;
				{
					ret;
				};
			};
		} else {
			null;
		};
	}

	public static function isMultitype(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TType(defRef, _):
		{
			isMultitype(Context.follow(t));
		};	
	case TAbstract(absRef, _):
		{
			absRef.get().hasMeta(":multiType");
		};	
	case _:
		false;	
}) switch (enumIndex t) {
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var defRef = `;
					{
						{
							reflaxe.helpers.TypeHelper.isMultitype(reflaxe.helpers.Context.follow(t, null));
						};
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var absRef = `;
					{
						{
							reflaxe.helpers.NameMetaHelper.hasMeta(absRef.get(), ":multiType");
						};
					};
				};
			};
			default: {
				false;
			}
		};
	}

	public static function isDescendantOf(t:haxe.macro.Type, superClass:haxe.macro.Type) {
		return reflaxe.helpers.TypeHelper.isChildOf(t, superClass) || reflaxe.helpers.TypeHelper.implementsType(t, superClass);
	}

	public static function isChildOf(t:haxe.macro.Type, superClass:haxe.macro.Type) {
		var superClassType = @:ast(switch (superClass) {
	case TInst(clsRef, _):
		clsRef;	
	case _:
		return false;	
}) if (enumIndex superClass == 2) {
			var ` = superClass[0];
			var ` = superClass[1];
			{
				var clsRef = `;
				{
					clsRef;
				};
			};
		} else {
			return false;
		};
		return @:ast(switch (t) {
	case TInst(clsRef, _):
		{
			var c = clsRef.get();
			if (c.superClass != null) {
				ModuleTypeHelper.equals(TClassDecl(c.superClass.t), TClassDecl(superClassType));
			} else {
				false;
			};
		};	
	case _:
		false;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var clsRef = `;
				{
					{
						var c = clsRef.get();
						if (c.superClass != null) {
							reflaxe.helpers.ModuleTypeHelper.equals(haxe.macro.ModuleType.TClassDecl(c.superClass.t), haxe.macro.ModuleType.TClassDecl(superClassType));
						} else {
							false;
						};
					};
				};
			};
		} else {
			false;
		};
	}

	public static function implementsType(t:haxe.macro.Type, interfaceType:haxe.macro.Type) {
		var interfaceClassType = @:ast(switch (interfaceType) {
	case TInst(clsRef, _):
		clsRef;	
	case _:
		return false;	
}) if (enumIndex interfaceType == 2) {
			var ` = interfaceType[0];
			var ` = interfaceType[1];
			{
				var clsRef = `;
				{
					clsRef;
				};
			};
		} else {
			return false;
		};
		if (! interfaceClassType.get().isInterface) {
			return false;
		};
		return @:ast(switch (t) {
	case TInst(clsRef, _):
		{
			var c = clsRef.get();
			var result = false;
			for (int  in  c.interfaces) {
				if (ModuleTypeHelper.equals(TClassDecl(int.t), TClassDecl(interfaceClassType))) {
					result = true;
					break;
				};
			};
			result;
		};	
	case _:
		false;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var clsRef = `;
				{
					{
						var c = clsRef.get();
						var result = false;
						{
							var ` = 0;
							var ` = c.interfaces;
							while (` < `.length) {
								var int = `[`];
								++ `;
								if (reflaxe.helpers.ModuleTypeHelper.equals(haxe.macro.ModuleType.TClassDecl(int.t), haxe.macro.ModuleType.TClassDecl(interfaceClassType))) {
									result = true;
									break;
								};
							};
						};
						result;
					};
				};
			};
		} else {
			false;
		};
	}

	public static function getUnderlyingType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TType(_.get() => defType, params):
		{
			TypeTools.applyTypeParameters(defType.type, defType.params, params);
		};	
	case TAbstract(_.get() => absType, params):
		{
			TypeTools.applyTypeParameters(absType.type, absType.params, params);
		};	
	case _:
		null;	
}) switch (enumIndex t) {
			case 3: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var defType = (_hx_tmp = `.get());
						var params = `;
						{
							{
								haxe.macro.TypeTools.applyTypeParameters(defType.type, defType.params, params);
							};
						};
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var absType = (_hx_tmp = `.get());
						var params = `;
						{
							{
								haxe.macro.TypeTools.applyTypeParameters(absType.type, absType.params, params);
							};
						};
					};
				};
			};
			default: {
				null;
			}
		};
	}
}