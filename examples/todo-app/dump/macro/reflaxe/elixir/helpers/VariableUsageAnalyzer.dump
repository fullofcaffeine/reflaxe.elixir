class reflaxe.elixir.helpers.VariableUsageAnalyzer {

	public static function analyzeUsage(expr:haxe.macro.TypedExpr) {
		var usageMap = {
			{};
			new haxe.ds.IntMap();
		};
		var traverse = [null];
		traverse[0] = function(e:haxe.macro.TypedExpr) {
			if (e == null) {
				return;
			};
			@:ast(switch (e.expr) {
	case TLocal(v):
		usageMap.set(v.id, true);	
	case TVar(v, init):
		if (!usageMap.exists(v.id)) {
			usageMap.set(v.id, false);
		};
		if (init != null) traverse(init);	
	default:
		TypedExprTools.iter(e, traverse);	
}) {
				var ` = e.expr;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						{
							var v = `;
							{
								{
									var key = v.id;
									usageMap.set(key, true);
								};
							};
						};
					};
					case 13: {
						var ` = `[0];
						var ` = `[1];
						{
							var v = `;
							var init = `;
							{
								if (! {
									var key = v.id;
									usageMap.exists(key);
								}) {
									{
										var key = v.id;
										usageMap.set(key, false);
									};
								};
								if (init != null) {
									traverse[0](init);
								};
							};
						};
					};
					default: {
						haxe.macro.TypedExprTools.iter(e, traverse[0]);
					}
				};
			};
		};
		traverse[0](expr);
		return usageMap;
	}
}