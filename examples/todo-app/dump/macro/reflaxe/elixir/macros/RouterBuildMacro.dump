@:nullSafety(Off)
class reflaxe.elixir.macros.RouterBuildMacro {

	public static function generateRoutes() {
		var fields = haxe.macro.Context.getBuildFields();
		var classType = haxe.macro.Context.getLocalClass().get();
		var routeDefinitions = reflaxe.elixir.macros.RouterBuildMacro.extractRoutesAnnotation(classType);
		if (routeDefinitions == null || routeDefinitions.length == 0) {
			haxe.Log.trace("RouterBuildMacro: No @:routes annotation found in " + classType.name, {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 56, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "generateRoutes"});
			return fields;
		};
		haxe.Log.trace("RouterBuildMacro: Found " + routeDefinitions.length + " route definitions in " + classType.name, {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 60, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "generateRoutes"});
		reflaxe.elixir.macros.RouterBuildMacro.validateRouteDefinitions(routeDefinitions, classType.pos);
		{
			var ` = 0;
			while (` < routeDefinitions.length) {
				var routeDef = routeDefinitions[`];
				++ `;
				var generatedFunction = reflaxe.elixir.macros.RouterBuildMacro.createRouteFunction(routeDef, classType.pos);
				fields.push(generatedFunction);
				haxe.Log.trace("RouterBuildMacro: Generated function " + routeDef.name + " for route " + routeDef.method + " " + routeDef.path, {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 73, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "generateRoutes"});
			};
		};
		haxe.Log.trace("RouterBuildMacro: Successfully generated " + routeDefinitions.length + " route functions", {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 76, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "generateRoutes"});
		return fields;
	}

	static function extractRoutesAnnotation(classType:haxe.macro.ClassType) {
		if (! classType.meta.has(":routes")) {
			return null;
		};
		var routesMetadata = classType.meta.extract(":routes");
		if (routesMetadata.length == 0) {
			return null;
		};
		var routesEntry = routesMetadata[0];
		if (routesEntry.params == null || routesEntry.params.length == 0) {
			haxe.macro.Context.error("@:routes annotation requires array parameter: @:routes([{...}])", routesEntry.pos, null);
			return null;
		};
		var routesArrayExpr = routesEntry.params[0];
		return reflaxe.elixir.macros.RouterBuildMacro.parseRoutesArray(routesArrayExpr);
	}

	static function parseRoutesArray(arrayExpr:haxe.macro.Expr) {
		var routes = [];
		@:ast(switch (arrayExpr.expr) {
	case EArrayDecl(values):
		for (routeExpr  in  values) {
			var routeDef = parseRouteObject(routeExpr);
			if (routeDef != null) {
				routes.push(routeDef);
			};
		};	
	case _:
		Context.error("@:routes parameter must be an array: @:routes([{...}])", arrayExpr.pos);	
}) {
			var ` = arrayExpr.expr;
			if (enumIndex ` == 6) {
				var ` = `[0];
				{
					var values = `;
					{
						{
							var ` = 0;
							while (` < values.length) {
								var routeExpr = values[`];
								++ `;
								var routeDef = reflaxe.elixir.macros.RouterBuildMacro.parseRouteObject(routeExpr);
								if (routeDef != null) {
									routes.push(routeDef);
								};
							};
						};
					};
				};
			} else {
				haxe.macro.Context.error("@:routes parameter must be an array: @:routes([{...}])", arrayExpr.pos, null);
			};
		};
		return routes;
	}

	static function parseRouteObject(routeExpr:haxe.macro.Expr) {
		@:ast(switch (routeExpr.expr) {
	case EObjectDecl(fields):
		var routeDef = new RouteDefinition();
		for (field  in  fields) {
			switch (field.field) {
				case "name":
					routeDef.name = extractStringValue(field.expr, "name");				
				case "method":
					routeDef.method = extractStringValue(field.expr, "method");				
				case "path":
					routeDef.path = extractStringValue(field.expr, "path");				
				case "controller":
					routeDef.controller = extractStringValue(field.expr, "controller");				
				case "action":
					routeDef.action = extractStringValue(field.expr, "action");				
				case "pipeline":
					routeDef.pipeline = extractStringValue(field.expr, "pipeline");				
				case _:
					Context.warning("Unknown route field: ${field.field}", field.expr.pos);				
			};
		};
		return routeDef;	
	case _:
		Context.error("Route definition must be object: {name: \"...\", method: \"...\", ...}", routeExpr.pos);
		return null;	
}) {
			var ` = routeExpr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var fields = `;
					{
						var routeDef = new reflaxe.elixir.macros.RouteDefinition();
						{
							var ` = 0;
							while (` < fields.length) {
								var field = fields[`];
								++ `;
								@:ast(switch (field.field) {
	case "name":
		routeDef.name = extractStringValue(field.expr, "name");	
	case "method":
		routeDef.method = extractStringValue(field.expr, "method");	
	case "path":
		routeDef.path = extractStringValue(field.expr, "path");	
	case "controller":
		routeDef.controller = extractStringValue(field.expr, "controller");	
	case "action":
		routeDef.action = extractStringValue(field.expr, "action");	
	case "pipeline":
		routeDef.pipeline = extractStringValue(field.expr, "pipeline");	
	case _:
		Context.warning("Unknown route field: ${field.field}", field.expr.pos);	
}) {
									var ` = field.field;
									switch (`) {
										case "action": {
											{
												routeDef.action = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "action");
											};
										};
										case "controller": {
											{
												routeDef.controller = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "controller");
											};
										};
										case "method": {
											{
												routeDef.method = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "method");
											};
										};
										case "name": {
											{
												routeDef.name = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "name");
											};
										};
										case "path": {
											{
												routeDef.path = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "path");
											};
										};
										case "pipeline": {
											{
												routeDef.pipeline = reflaxe.elixir.macros.RouterBuildMacro.extractStringValue(field.expr, "pipeline");
											};
										};
										default: {
											haxe.macro.Context.warning("Unknown route field: " + field.field, field.expr.pos, null);
										}
									};
								};
							};
						};
						return routeDef;
					};
				};
			} else {
				haxe.macro.Context.error("Route definition must be object: {name: \"...\", method: \"...\", ...}", routeExpr.pos, null);
				return null;
			};
		};
	}

	static function extractStringValue(expr:haxe.macro.Expr, fieldName:String) {
		@:ast(switch (expr.expr) {
	case EConst(CString(s, _)):
		return s;	
	case EField(e, field):
		switch (e.expr) {
			case EConst(CIdent("HttpMethod")):
				return field;			
			case _:
				return extractTypeReference(expr, fieldName);			
		};	
	case EConst(CIdent(ident)):
		return ident;	
	case _:
		Context.error("${fieldName} must be a string literal, enum value, or class reference", expr.pos);
		return null;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					switch (enumIndex `) {
						case 2: {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									return s;
								};
							};
						};
						case 3: {
							var ` = `[0];
							{
								var ident = `;
								{
									return ident;
								};
							};
						};
						default: {
							haxe.macro.Context.error("" + fieldName + " must be a string literal, enum value, or class reference", expr.pos, null);
							return null;
						}
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var field = `;
						{
							@:ast(switch (e.expr) {
	case EConst(CIdent("HttpMethod")):
		return field;	
	case _:
		return extractTypeReference(expr, fieldName);	
}) {
								var ` = e.expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (enumIndex ` == 3) {
										var ` = `[0];
										if (` == "HttpMethod") {
											{
												return field;
											};
										} else {
											return reflaxe.elixir.macros.RouterBuildMacro.extractTypeReference(expr, fieldName);
										};
									} else {
										return reflaxe.elixir.macros.RouterBuildMacro.extractTypeReference(expr, fieldName);
									};
								} else {
									return reflaxe.elixir.macros.RouterBuildMacro.extractTypeReference(expr, fieldName);
								};
							};
						};
					};
				};
				default: {
					haxe.macro.Context.error("" + fieldName + " must be a string literal, enum value, or class reference", expr.pos, null);
					return null;
				}
			};
		};
	}

	static function extractTypeReference(expr:haxe.macro.Expr, fieldName:String) {
		@:ast(switch (expr.expr) {
	case EField(e, field):
		var className = extractClassName(e);
		return className != null ? className : field;	
	case EConst(CIdent(ident)):
		return ident;	
	case _:
		return null;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 3) {
						var ` = `[0];
						{
							var ident = `;
							{
								return ident;
							};
						};
					} else {
						return null;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var field = `;
						{
							var className = reflaxe.elixir.macros.RouterBuildMacro.extractClassName(e);
							return if (className != null) {
								className;
							} else {
								field;
							};
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function extractClassName(expr:haxe.macro.Expr) {
		@:ast(switch (expr.expr) {
	case EConst(CIdent(ident)):
		return ident;	
	case EField(e, field):
		var base = extractClassName(e);
		return base != null ? "${base}.${field}" : field;	
	case _:
		return null;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					if (enumIndex ` == 3) {
						var ` = `[0];
						{
							var ident = `;
							{
								return ident;
							};
						};
					} else {
						return null;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var field = `;
						{
							var base = reflaxe.elixir.macros.RouterBuildMacro.extractClassName(e);
							return if (base != null) {
								"" + base + "." + field;
							} else {
								field;
							};
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function validateRouteDefinitions(routes:Array<reflaxe.elixir.macros.RouteDefinition>, pos:haxe.macro.Position) {
		var usedNames = {
			{};
			new haxe.ds.StringMap();
		};
		var usedPaths = {
			{};
			new haxe.ds.StringMap();
		};
		{
			var ` = 0;
			while (` < routes.length) {
				var route = routes[`];
				++ `;
				if (route.name == null || route.name == "") {
					haxe.macro.Context.error("Route missing required 'name' field", pos, null);
				};
				if (route.method == null || route.method == "") {
					haxe.macro.Context.error("Route missing required 'method' field", pos, null);
				};
				if (route.path == null || route.path == "") {
					haxe.macro.Context.error("Route missing required 'path' field", pos, null);
				};
				if ({
					var key = route.name;
					usedNames.exists(key);
				}) {
					haxe.macro.Context.error("Duplicate route name: " + route.name, pos, null);
				};
				{
					var key = route.name;
					usedNames.set(key, true);
				};
				var pathMethodKey = "" + route.method + ":" + route.path;
				if (usedPaths.exists(pathMethodKey)) {
					haxe.macro.Context.warning("Duplicate route path/method: " + pathMethodKey + " (was " + cast usedPaths.get(pathMethodKey) + ")", pos, null);
				};
				{
					var value = route.name;
					usedPaths.set(pathMethodKey, value);
				};
				var validMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "LIVE", "LIVE_DASHBOARD"];
				if (! validMethods.contains(route.method)) {
					haxe.macro.Context.warning("Unknown HTTP method: " + route.method + ". Valid: " + validMethods.join(", "), pos, null);
				};
				if (route.controller != null && route.controller != "") {
					reflaxe.elixir.macros.RouterBuildMacro.validateControllerExists(route.controller, route.name, route.path, pos);
				};
				if (route.controller != null && route.action != null && route.controller != "" && route.action != "") {
					reflaxe.elixir.macros.RouterBuildMacro.validateActionExists(route.controller, route.action, route.name, pos);
				};
			};
		};
	}

	static function createRouteFunction(routeDef:reflaxe.elixir.macros.RouteDefinition, pos:haxe.macro.Position) {
		var routeAnnotation = {name : ":route", params : [reflaxe.elixir.macros.RouterBuildMacro.createRouteAnnotationObject(routeDef, pos)], pos : pos};
		var functionBody = {expr : haxe.macro.ExprDef.EReturn({expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.path, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}), pos : pos};
		var functionField = {name : routeDef.name, access : [haxe.macro.Access.APublic, haxe.macro.Access.AStatic], kind : haxe.macro.FieldType.FFun({args : [], ret : cast haxe.macro.ComplexType.TPath({pack : [], name : "String", params : []}), expr : functionBody}), pos : pos, meta : [routeAnnotation], doc : "Auto-generated route function for " + routeDef.method + " " + routeDef.path};
		return functionField;
	}

	static function createRouteAnnotationObject(routeDef:reflaxe.elixir.macros.RouteDefinition, pos:haxe.macro.Position) {
		var objectFields = [{field : "method", expr : {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.method, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}}, {field : "path", expr : {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.path, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}}];
		if (routeDef.controller != null) {
			objectFields.push({field : "controller", expr : {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.controller, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}});
		};
		if (routeDef.action != null) {
			objectFields.push({field : "action", expr : {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.action, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}});
		};
		if (routeDef.pipeline != null) {
			objectFields.push({field : "pipeline", expr : {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CString(routeDef.pipeline, haxe.macro.StringLiteralKind.DoubleQuotes)), pos : pos}});
		};
		return {expr : haxe.macro.ExprDef.EObjectDecl(objectFields), pos : pos};
	}

	static function validateControllerExists(controllerName:String, routeName:String, routePath:String, pos:haxe.macro.Position) {
		try {
			var controllerType = haxe.macro.Context.getType(controllerName);
			haxe.Log.trace("RouterBuildMacro: Controller " + controllerName + " exists and is valid", {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 360, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "validateControllerExists"});
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{
					haxe.macro.Context.warning("Controller \"" + controllerName + "\" not found in route \"" + routeName + "\" (path: \"" + routePath + "\"). Ensure the class exists and is in the classpath.", pos, null);
				};
			} else throw `;
		};
	}

	static function validateActionExists(controllerName:String, actionName:String, routeName:String, pos:haxe.macro.Position) {
		try {
			var controllerType = haxe.macro.Context.getType(controllerName);
			@:ast(switch (controllerType) {
	case TInst(ref, _):
		var classType = ref.get();
		var methodExists = false;
		for (field  in  classType.fields.get()) {
			if (field.name == actionName) {
				methodExists = true;
				break;
			};
		};
		if (!methodExists) {
			for (field  in  classType.statics.get()) {
				if (field.name == actionName) {
					methodExists = true;
					break;
				};
			};
		};
		if (methodExists) {
			trace("RouterBuildMacro: Action ${controllerName}.${actionName} exists and is valid");
		} else {
			Context.warning("Action \"${actionName}\" not found on controller \"${controllerName}\" in route \"${routeName}\". Check that the method exists and is public static.", pos);
		};	
	case _:
		Context.warning("Controller \"${controllerName}\" is not a class. Actions can only be validated on class types.", pos);	
}) if (enumIndex controllerType == 2) {
				var ` = controllerType[0];
				var ` = controllerType[1];
				{
					var ref = `;
					{
						var classType = ref.get();
						var methodExists = false;
						{
							var ` = 0;
							var ` = classType.fields.get();
							while (` < `.length) {
								var field = `[`];
								++ `;
								if (field.name == actionName) {
									methodExists = true;
									break;
								};
							};
						};
						if (! methodExists) {
							{
								var ` = 0;
								var ` = classType.statics.get();
								while (` < `.length) {
									var field = `[`];
									++ `;
									if (field.name == actionName) {
										methodExists = true;
										break;
									};
								};
							};
						};
						if (methodExists) {
							haxe.Log.trace("RouterBuildMacro: Action " + controllerName + "." + actionName + " exists and is valid", {fileName : "../../src/reflaxe/elixir/macros/RouterBuildMacro.hx", lineNumber : 399, className : "reflaxe.elixir.macros.RouterBuildMacro", methodName : "validateActionExists"});
						} else {
							haxe.macro.Context.warning("Action \"" + actionName + "\" not found on controller \"" + controllerName + "\" in route \"" + routeName + "\". Check that the method exists and is public static.", pos, null);
						};
					};
				};
			} else {
				haxe.macro.Context.warning("Controller \"" + controllerName + "\" is not a class. Actions can only be validated on class types.", pos, null);
			};
		} catch (`:Dynamic) {
			{};
			{};
			if (true) {
				{};
				{};
			} else throw `;
		};
	}
}