class reflaxe.elixir.ast.ElixirASTBuilder {

	@:value(null)
	public static var currentModule:String = null;

	@:value(false)
	public static var currentModuleHasPresence:Bool = false;

	@:value(0)
	public static var switchNestingLevel:Int = 0;

	@:value(null) @:allow(reflaxe.elixir.ElixirCompiler) @:allow(reflaxe.elixir.ast.builders.ModuleBuilder)
	public static var compiler:reflaxe.elixir.ElixirCompiler = null;

	@:value(null)
	public static var behaviorTransformer:reflaxe.elixir.behaviors.BehaviorTransformer = null;

	static function trackDependency(moduleName:String) {
		var builtins = ["Map", "Enum", "String", "Kernel", "List", "IO", "Process", "GenServer", "Supervisor", "Agent", "File", "Path", "System", "Code", "Module", "Application", "Integer", "Float", "Regex", "Date", "DateTime", "NaiveDateTime"];
		if (builtins.indexOf(moduleName, null) >= 0) {
			return;
		};
		if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule != null) {
			var deps = {
				var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.moduleDependencies;
				var key = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule;
				cast this.get(key);
			};
			if (deps != null && moduleName != reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler.currentCompiledModule) {
				{
					deps.set(moduleName, true);
				};
			};
		};
	}

	static function getVariableInitValue(varName:String, context:reflaxe.elixir.CompilationContext) {
		if (context.infrastructureVarInitValues != null && {
			var this = context.infrastructureVarInitValues;
			cast this.exists(varName);
		}) {
			return {
				var this = context.infrastructureVarInitValues;
				cast this.get(varName);
			};
		} else {
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(varName), metadata : {}, pos : pos};
			};
		};
	}

	static inline function replaceNullCoalVar(expr:reflaxe.elixir.ast.intent.TypedExpr, varId:Int, initExpr:reflaxe.elixir.ast.intent.TypedExpr) {
		return reflaxe.elixir.ast.SubstitutionHelpers.replaceNullCoalVar(expr, varId, initExpr);
	}

	static inline function substituteVariable(expr:reflaxe.elixir.ast.intent.TypedExpr, varToReplace:haxe.macro.TVar, replacement:reflaxe.elixir.ast.intent.TypedExpr) {
		return reflaxe.elixir.ast.SubstitutionHelpers.substituteVariable(expr, varToReplace, replacement);
	}

	@:value(null)
	static var currentContext:reflaxe.elixir.CompilationContext = null;

	public static function buildFromTypedExpr(expr:reflaxe.elixir.ast.intent.TypedExpr, context:reflaxe.elixir.CompilationContext) {
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, context);
	}

	static function buildFromTypedExprHelper(expr:reflaxe.elixir.ast.intent.TypedExpr, usageMapOrContext:Dynamic) {
		if (Std.isOfType(usageMapOrContext, reflaxe.elixir.CompilationContext)) {
			return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, cast usageMapOrContext);
		} else {
			if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null) {
				if (usageMapOrContext != null) {
					reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap = cast usageMapOrContext;
				};
				return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
			} else {
				var ctx = new reflaxe.elixir.CompilationContext();
				ctx.variableUsageMap = cast usageMapOrContext;
				return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExprWithContext(expr, ctx);
			};
		};
	}

	static function buildFromTypedExprWithContext(expr:reflaxe.elixir.ast.intent.TypedExpr, context:reflaxe.elixir.CompilationContext) {
		if (context.compiler == null && reflaxe.elixir.ast.ElixirASTBuilder.compiler != null) {
			context.compiler = reflaxe.elixir.ast.ElixirASTBuilder.compiler;
		};
		var previousContext = reflaxe.elixir.ast.ElixirASTBuilder.currentContext;
		if (previousContext != null && Lambda.count(cast context.tempVarRenameMap, null) == 0 && Lambda.count(cast previousContext.tempVarRenameMap, null) > 0) {
			for (key in {
				var this = previousContext.tempVarRenameMap;
				cast this.keys();
			}) {
				{
					var this = context.tempVarRenameMap;
					var value = {
						var this = previousContext.tempVarRenameMap;
						cast this.get(key);
					};
					cast this.set(key, value);
				};
			};
		};
		reflaxe.elixir.ast.ElixirASTBuilder.currentContext = context;
		if (context.variableUsageMap != null) {} else {
			context.variableUsageMap = {
				{};
				new haxe.ds.IntMap();
			};
		};
		reflaxe.elixir.ast.ElixirASTBuilder.compiler = context.compiler;
		reflaxe.elixir.ast.ElixirASTBuilder.behaviorTransformer = context.behaviorTransformer;
		reflaxe.elixir.ast.ElixirASTBuilder.currentModule = context.currentModule;
		reflaxe.elixir.ast.ElixirASTBuilder.currentModuleHasPresence = context.currentModuleHasPresence;
		var metadata = reflaxe.elixir.ast.ElixirASTBuilder.createMetadata(expr);
		var astDef = reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(expr);
		if (astDef == null) {
			reflaxe.elixir.ast.ElixirASTBuilder.currentContext = previousContext;
			return null;
		};
		@:ast(switch (expr.expr) {
	case TCall(e, _) if (e != null && PatternDetector.isEnumConstructor(e) && hasIdiomaticMetadata(e)):
		metadata.requiresIdiomaticTransform = true;
		metadata.idiomaticEnumType = switch (e.expr) {
			case TField(_, FEnum(enumRef, _)):
				enumRef.get().name;			
			default:
				"";			
		};	
	case TCall(_, _):
		switch (expr.t) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				if (enumType.meta.has(":elixirIdiomatic")) {
					metadata.requiresIdiomaticTransform = true;
					metadata.idiomaticEnumType = enumType.name;
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			if (enumIndex ` == 9) {
				var ` = `[0];
				var ` = `[1];
				{
					var e = `;
					if (e != null && reflaxe.elixir.helpers.PatternDetector.isEnumConstructor(e) && reflaxe.elixir.ast.ElixirASTBuilder.hasIdiomaticMetadata(e)) {
						metadata.requiresIdiomaticTransform = true;
						metadata.idiomaticEnumType = @:ast(switch (e.expr) {
	case TField(_, FEnum(enumRef, _)):
		enumRef.get().name;	
	default:
		"";	
}) {
							var ` = e.expr;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								if (enumIndex ` == 5) {
									var ` = `[0];
									var ` = `[1];
									{
										var enumRef = `;
										{
											enumRef.get().name;
										};
									};
								} else {
									"";
								};
							} else {
								"";
							};
						};
					} else {
						@:ast(switch (expr.t) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		if (enumType.meta.has(":elixirIdiomatic")) {
			metadata.requiresIdiomaticTransform = true;
			metadata.idiomaticEnumType = enumType.name;
		};	
	default:
}) {
							var ` = expr.t;
							if (enumIndex ` == 1) {
								var ` = `[0];
								var ` = `[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										if (enumType.meta.has(":elixirIdiomatic")) {
											metadata.requiresIdiomaticTransform = true;
											metadata.idiomaticEnumType = enumType.name;
										};
									};
								};
							} else {};
						};
					};
				};
			} else {};
		};
		var result = {def : astDef, metadata : metadata, pos : expr.pos};
		reflaxe.elixir.ast.ElixirASTBuilder.currentContext = previousContext;
		return result;
	}

	static function convertExpression(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(c):
		LiteralBuilder.buildConst(c, expr, currentContext);	
	case TLocal(v):
		var idKey = Std.string(v.id);
		var nameKey = v.name;
		var varName = if (currentContext.tempVarRenameMap.exists(idKey)) {
			var renamed = currentContext.tempVarRenameMap.get(idKey);
			renamed;
		} else if (currentContext.tempVarRenameMap.exists(nameKey)) {
			var renamed = currentContext.tempVarRenameMap.get(nameKey);
			renamed;
		} else if (currentContext.isInConstructorArgContext) {
			var pattern = ~/^(.+?)(\d+)$/;
			var baseName = if (pattern.match(v.name)) {
				var base = pattern.matched(1);
				var suffix = pattern.matched(2);
				base;
			} else {
				v.name;
			};
			VariableAnalyzer.toElixirVarName(baseName);
		} else {
			var converted = VariableAnalyzer.toElixirVarName(v.name);
			converted;
		};
		EVar(varName);	
	case TVar(v, init):
		if (init == null || isSimpleInit(init)) {
			var result = VariableBuilder.buildVariableDeclaration(v, init, currentContext);
			if (result != null) {
				return result;
			};
		};
		var isInfrastructureVar = reflaxe.elixir.preprocessor.TypedExprPreprocessor.isInfrastructureVar(v.name);
		if (isInfrastructureVar && init != null) {
			switch (init.expr) {
				case TField(obj, fa):
					var fieldName = extractFieldName(fa);
					switch (obj.expr) {
						case TLocal(localVar):
							var extractedVarName = VariableAnalyzer.toElixirVarName(localVar.name) + "_" + reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
							if (currentContext.tempVarRenameMap == null) {
								currentContext.tempVarRenameMap = new Map();
							};
							currentContext.tempVarRenameMap.set(v.name, extractedVarName);						
						default:
					};				
				case TEnumParameter(_, _, _):
				case TLocal(localVar):
					var sourceVar = localVar.name;
					if (sourceVar == "g" || sourceVar == "_g" || (sourceVar.length > 1 && sourceVar.charAt(0) == "g") || (sourceVar.length > 2 && sourceVar.substr(0, 2) == "_g")) {
						return null;
					};				
				default:
			};
		};
		if (init != null) {
			switch (init.expr) {
				case TBlock(blockStmts) if (blockStmts.length >= 3):
					var mapLiteral = tryBuildMapLiteralFromBlock(blockStmts, currentContext);
					if (mapLiteral != null) {
						return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), mapLiteral);
					};
					var isConditionalComp = false;
					var tempVarName = "";
					switch (blockStmts[0].expr) {
						case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
							switch (tempInit.expr) {
								case TArrayDecl([]):
									tempVarName = tempVar.name;
									if (blockStmts.length >= 3) {
										switch (blockStmts[1].expr) {
											case TBlock(ifStmts):
												var allIfs = true;
												for (stmt  in  ifStmts) {
													switch (stmt.expr) {
														case TIf(_, _, null):
															continue;														
														default:
															allIfs = false;
															break;														
													};
												};
												if (allIfs && blockStmts.length > 2) {
													switch (blockStmts[blockStmts.length - 1].expr) {
														case TLocal(retVar) if (retVar.name == tempVarName):
															isConditionalComp = true;														
														default:
													};
												};											
											default:
										};
									};								
								default:
							};						
						default:
					};
					if (isConditionalComp) {
						var reconstructed = ComprehensionBuilder.tryReconstructConditionalComprehension(blockStmts, tempVarName, currentContext);
						if (reconstructed != null) {
							return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), reconstructed);
						};
					};				
				default:
			};
		};
		var isEnumExtraction = false;
		var extractedFromTemp = "";
		var shouldSkipRedundantExtraction = false;
		var varOrigin:ElixirAST.VarOrigin = UserDefined;
		var tempToBinderMap:Map<Int,Int> = null;
		if (init != null) {
			switch (init.expr) {
				case TEnumParameter(e, _, index):
					isEnumExtraction = true;
					varOrigin = ExtractionTemp;
					var tempVarName = VariableAnalyzer.toElixirVarName(v.name);
					if (currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
						currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : tempVarName }]);
					};
					if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
						var plan = currentContext.currentClauseContext.enumBindingPlan;
						if (plan.exists(index)) {
							shouldSkipRedundantExtraction = true;
							return null;
						};
					};
					if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
						shouldSkipRedundantExtraction = true;
					};				
				case TLocal(tempVar):
					if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)) {
						extractedFromTemp = tempVar.name;
						varOrigin = PatternBinder;
						if (currentContext.currentClauseContext != null) {
							var userVarName = VariableAnalyzer.toElixirVarName(v.name);
							currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : userVarName }]);
						};
						if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
							return null;
						};
						if (tempToBinderMap == null) {
							tempToBinderMap = new Map<Int,Int>();
						};
						tempToBinderMap.set(tempVar.id, v.id);
					} else {
						varOrigin = UserDefined;
					};				
				case TSwitch(switchExpr, cases, edef):
					varOrigin = UserDefined;				
				case _:
					varOrigin = UserDefined;				
			};
		};
		var varName = v.name;
		var idKey = Std.string(v.id);
		var isUnused = false;
		var baseName = if (currentContext.tempVarRenameMap.exists(idKey)) {
			currentContext.tempVarRenameMap.get(idKey);
		} else {
			var isUsed = if (currentContext.variableUsageMap != null) {
				currentContext.variableUsageMap.exists(v.id) && currentContext.variableUsageMap.get(v.id);
			} else {
				true;
			};
			if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
				VariableAnalyzer.toElixirVarName(varName, false);
			} else {
				VariableAnalyzer.toElixirVarName(varName, false);
			};
		};
		var finalVarName = baseName;
		var matchNode = if (init != null) {
			var initValue = switch (init.expr) {
				case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
					var tmpVarName = VariableAnalyzer.toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
					var initAst = buildFromTypedExpr(tmpInit, currentContext);
					var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
					var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
					if (ifExpr.metadata == null) ifExpr.metadata = { };
					ifExpr.metadata.keepInlineInAssignment = true;
					ifExpr;				
				case _:
					var initExpr = switch (init.expr) {
						case TBlock(stmts) if (stmts.length > 2):
							var isUnrolled = false;
							var tempVarName = "";
							var values = [];
							if (stmts.length > 0) {
								switch (stmts[0].expr) {
									case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
										switch (initExpr.expr) {
											case TArrayDecl([]):
												isUnrolled = true;
												tempVarName = v.name;											
											default:
										};									
									default:
								};
							};
							if (isUnrolled && stmts.length > 1) {
								var concatStatements = [];
								switch (stmts[1].expr) {
									case TBlock(innerStmts):
										concatStatements = innerStmts;									
									default:
										concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];									
								};
								for (stmt  in  concatStatements) {
									switch (stmt.expr) {
										case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
											values.push(elem);										
										case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
											values.push(arg);										
										default:
									};
								};
								if (values.length == 0) {
									isUnrolled = false;
								};
							};
							if (isUnrolled && stmts.length > 0) {
								switch (stmts[stmts.length - 1].expr) {
									case TLocal(v) if (v.name == tempVarName):
									default:
										isUnrolled = false;									
								};
							};
							if (isUnrolled && values.length > 0) {
								var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
								makeAST(EList(valueASTs));
							} else {
								buildFromTypedExpr(init, currentContext);
							};						
						case TSwitch(_, _, _):
							var switchAST = buildFromTypedExpr(init, currentContext);
							switchAST;						
						default:
							buildFromTypedExpr(init, currentContext);						
					};
					initExpr;				
			};
			var shouldSkipAssignment = false;
			if (init != null && currentContext.currentClauseContext != null && currentContext.currentClauseContext.isVarIdSatisfiedByPattern(v.id)) {
				shouldSkipAssignment = true;
			} else if (init != null) {
				switch (init.expr) {
					case TEnumParameter(e, ef, index):
						if (currentContext.currentClauseContext != null) {
							var hasPlan = currentContext.currentClauseContext.enumBindingPlan.exists(index);
							if (hasPlan) {
								var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
								if (info.finalName == finalVarName) {
									shouldSkipAssignment = true;
								} else { };
								if (!shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
									var planIsTemp = PatternDetector.isTempPatternVarName(info.finalName);
									var lhsIsTemp = PatternDetector.isTempPatternVarName(finalVarName);
									if (lhsIsTemp && !planIsTemp) {
										shouldSkipAssignment = true;
									};
								};
							};
						};
						if (!shouldSkipAssignment && initValue != null) {
							switch (initValue.def) {
								case EVar(varName):
									if (varName == finalVarName) {
										shouldSkipAssignment = true;
									};								
								case _:
							};
						} else if (!shouldSkipAssignment) {
							shouldSkipAssignment = true;
						};					
					default:
				};
				if (!shouldSkipAssignment && init != null) {
					switch (init.expr) {
						case TLocal(tempVar):
							var tempVarName = tempVar.name;
							var isTempVar = false;
							if (tempVarName == "g" || tempVarName == "_g") {
								isTempVar = true;
							} else if (tempVarName.length > 1) {
								if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
									isTempVar = true;
								} else if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
									isTempVar = true;
								};
							};
							if (isTempVar) {
								var elixirTempName = VariableAnalyzer.toElixirVarName(tempVarName);
								if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
									shouldSkipAssignment = true;
								};
								if (finalVarName == tempVarName) {
									shouldSkipAssignment = true;
								};
							} else {
								if (finalVarName == tempVarName) {
									shouldSkipAssignment = true;
								};
							};						
						case _:
					};
				};
			};
			var result = if (shouldSkipAssignment) {
				null;
			} else if (initValue == null) {
				var fallbackValue = makeAST(ERaw("{:error, \"[Compiler Error] Failed to build initialization for " + finalVarName + "\"}"));
				var matchNode = makeAST(EMatch(PVar(finalVarName), fallbackValue));
				if (matchNode.metadata == null) matchNode.metadata = { };
				matchNode.metadata.requiresTempVar = true;
				matchNode.metadata.varOrigin = varOrigin;
				matchNode.metadata.varId = v.id;
				if (extractedFromTemp != null) { };
				matchNode;
			} else {
				var shouldSkipSelfAssignment = false;
				switch (initValue.def) {
					case EVar(varName):
						if (varName == finalVarName) {
							shouldSkipSelfAssignment = true;
						};					
					case _:
				};
				if (shouldSkipSelfAssignment) {
					null;
				} else {
					var matchNode = makeAST(EMatch(PVar(finalVarName), initValue));
					if (matchNode.metadata == null) matchNode.metadata = { };
					matchNode.metadata.varOrigin = varOrigin;
					matchNode.metadata.varId = v.id;
					if (tempToBinderMap != null) {
						matchNode.metadata.tempToBinderMap = tempToBinderMap;
					};
					matchNode;
				};
			};
			result;
		} else {
			makeAST(EMatch(PVar(finalVarName), makeAST(ENil)));
		};
		if (matchNode != null) {
			matchNode.def;
		} else {
			EMatch(PVar(finalVarName), makeAST(ENil));
		};	
	case TBinop(op, e1, e2):
		var result = switch (op) {
			case OpAssign:
				var pattern = PatternBuilder.extractPattern(e1);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var shouldSkipAssign = false;
				switch (pattern) {
					case PVar(name):
						var valueName = switch (rightAST != null ? rightAST.def : null) {
							case EVar(varName):
								varName;							
							default:
								null;							
						};
						if (PatternDetector.isTempPatternVarName(name)) {
							shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
								case EVar(varName) if (varName == name || PatternDetector.isTempPatternVarName(varName)):
									true;								
								default:
									false;								
							};
						} else if (valueName != null) {
							if (valueName == name) {
								shouldSkipAssign = true;
							} else if (PatternDetector.isTempPatternVarName(valueName)) {
								shouldSkipAssign = true;
							};
						};					
					default:
				};
				if (shouldSkipAssign) {
					null;
				} else {
					EMatch(pattern, rightAST);
				};			
			case OpAssignOp(innerOp):
				var pattern = PatternBuilder.extractPattern(e1);
				var leftAST = buildFromTypedExpr(e1, currentContext);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var innerBinop = BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s));
				EMatch(pattern, innerBinop);			
			default:
				var leftAST = buildFromTypedExpr(e1, currentContext);
				var rightAST = buildFromTypedExpr(e2, currentContext);
				var ast = BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s));
				ast.def;			
		};
		result;	
	case TUnop(op, postFix, e):
		switch (op) {
			case OpNot:
				switch (e.expr) {
					case TBlock([]):
						EUnary(Not, makeAST(ENil));					
					case TBlock(exprs) if (exprs.length == 1):
						EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));					
					case TBlock(exprs):
						var statements = [];
						for (i  in  0 ... exprs.length - 1) {
							statements.push(buildFromTypedExpr(exprs[i], currentContext));
						};
						var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
						statements.push(makeAST(EUnary(Not, lastExpr)));
						EBlock(statements);					
					default:
						var expr = buildFromTypedExpr(e, currentContext).def;
						EUnary(Not, makeAST(expr));					
				};			
			case OpNeg:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(Negate, makeAST(expr));			
			case OpNegBits:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(BitwiseNot, makeAST(expr));			
			case OpIncrement, OpDecrement:
				var one = makeAST(EInteger(1));
				var builtExpr = buildFromTypedExpr(e, currentContext);
				if (!postFix) {
					var operation = if (op == OpIncrement) {
						EBinary(Add, builtExpr, one);
					} else {
						EBinary(Subtract, builtExpr, one);
					};
					operation;
				} else {
					var operation = if (op == OpIncrement) {
						EBinary(Add, builtExpr, one);
					} else {
						EBinary(Subtract, builtExpr, one);
					};
					operation;
				};			
			case OpSpread:
				var builtExpr = buildFromTypedExpr(e, currentContext);
				EUnquoteSplicing(builtExpr);			
		};	
	case TCall(e, el):
		CallExprBuilder.buildCall(e, el, currentContext);	
	case TField(e, fa):
		var isSimpleCase = switch (fa) {
			case FEnum(_, _):
				true;			
			case FStatic(_, _):
				!currentContext.isInExUnitTest;			
			case FAnon(_):
				!currentContext.isInExUnitTest;			
			case FInstance(_, _, _):
				!currentContext.isInExUnitTest;			
			case FDynamic(_):
				true;			
			case FClosure(_, _):
				true;			
		};
		if (isSimpleCase) {
			var result = FieldAccessBuilder.build(e, fa, currentContext);
			if (result != null) {
				result;
			} else {
				switch (fa) {
					case FEnum(enumType, ef):
						var enumT = enumType.get();
						if (enumT.meta.has(":elixirIdiomatic")) {
							var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
							EAtom(atomName);
						} else {
							var hasParameters = switch (ef.type) {
								case TFun(args, _):
									args.length > 0;								
								default:
									false;								
							};
							var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
							if (hasParameters) {
								ETuple([makeAST(EAtom(atomName))]);
							} else {
								EAtom(atomName);
							};
						};					
					default:
						null;					
				};
			};
		} else {
			switch (fa) {
				case FEnum(enumType, ef):
					var enumT = enumType.get();
					if (enumT.meta.has(":elixirIdiomatic")) {
						var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
						EAtom(atomName);
					} else {
						var hasParameters = switch (ef.type) {
							case TFun(args, _):
								args.length > 0;							
							default:
								false;							
						};
						var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
						if (hasParameters) {
							ETuple([makeAST(EAtom(atomName))]);
						} else {
							EAtom(atomName);
						};
					};				
				case FStatic(classRef, cf):
					var className = classRef.get().name;
					var fieldName = extractFieldName(fa);
					var field = cf.get();
					var isAtomField = false;
					switch (field.type) {
						case TAbstract(abstractRef, _):
							var abstractType = abstractRef.get();
							if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
								isAtomField = true;
							};						
						case _:
					};
					if (!isAtomField) {
						var classType = classRef.get();
						switch (classType.kind) {
							case KAbstractImpl(abstractRef):
								var abstractType = abstractRef.get();
								switch (abstractType.type) {
									case TAbstract(underlyingRef, _):
										var underlyingType = underlyingRef.get();
										if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
											isAtomField = true;
										};									
									case _:
								};							
							case _:
						};
					};
					if (isAtomField && field.expr() != null) {
						switch (field.expr().expr) {
							case TConst(TString(s)):
								EAtom(s);							
							case _:
								fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
								var target = buildFromTypedExpr(e, currentContext);
								EField(target, fieldName);							
						};
					} else {
						fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
						if (false) {
							EVar(fieldName);
						} else {
							var target = if (e != null) {
								switch (e.expr) {
									case TTypeExpr(m):
										var moduleName = moduleTypeToString(m);
										makeAST(EVar(moduleName));									
									default:
										buildFromTypedExpr(e, currentContext);									
								};
							} else {
								null;
							};
							if (target == null) {
								EVar("UnknownModule." + fieldName);
							} else {
								EField(target, fieldName);
							};
						};
					};				
				case FAnon(cf):
					var fieldName = cf.get().name;
					var target = buildFromTypedExpr(e, currentContext);
					if (~/^_\d+$/.match(fieldName)) {
						var index = Std.parseInt(fieldName.substr(1)) - 1;
						ECall(null, "elem", [target, makeAST(EInteger(index))]);
					} else {
						fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
						EField(target, fieldName);
					};				
				default:
					var target = buildFromTypedExpr(e, currentContext);
					var fieldName = extractFieldName(fa);
					var originalFieldName = fieldName;
					fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
					if (currentContext.isInExUnitTest) {
						switch (e.expr) {
							case TConst(TThis):
								var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
								EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));							
							case TLocal(v) if (v.name == "struct"):
								var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
								EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));							
							default:
								if (fieldName == "elem") {
									EField(target, fieldName);
								} else if (isMapAccess(e.t)) {
									EAccess(target, makeAST(EAtom(fieldName)));
								} else {
									EField(target, fieldName);
								};							
						};
					} else {
						if (fieldName == "elem") {
							EField(target, fieldName);
						} else if (isMapAccess(e.t)) {
							EAccess(target, makeAST(EAtom(fieldName)));
						} else {
							EField(target, fieldName);
						};
					};				
			};
		};	
	case TArrayDecl(el):
		ArrayBuilder.buildArrayDecl(el, currentContext);	
	case TArray(e, index):
		ArrayBuilder.buildArrayAccess(e, index, currentContext);	
	case TIf(econd, eif, eelse):
		ControlFlowBuilder.buildIf(econd, eif, eelse, currentContext);	
	case TBlock(el):
		var result = BlockBuilder.build(el, currentContext);
		if (result != null) {
			return result;
		};
		trace("[ERROR] BlockBuilder returned null for TBlock - returning placeholder");
		return ERaw("# ERROR: BlockBuilder failed to compile block");	
	case TReturn(e):
		var result = ReturnBuilder.build(e, currentContext);
		if (result != null) {
			return result;
		};
		trace("[ERROR] ReturnBuilder returned null for TReturn - returning placeholder");
		return ERaw("# ERROR: ReturnBuilder failed to compile return statement");	
	case TBreak:
		ExceptionBuilder.buildBreak();	
	case TContinue:
		ExceptionBuilder.buildContinue();	
	case TSwitch(e, cases, edef):
		if (currentContext.compiler == null && compiler != null) {
			currentContext.compiler = compiler;
		};
		var result = SwitchBuilder.build(e, cases, edef, currentContext);
		if (result != null) {
			return result;
		};
		trace("[ERROR] SwitchBuilder returned null for TSwitch - returning placeholder");
		return ERaw("# ERROR: SwitchBuilder failed to compile switch expression");	
	case TTry(e, catches):
		var result = ExceptionBuilder.buildTry(e, catches, currentContext);
		if (result != null) {
			return result;
		};
		trace("[ERROR] ExceptionBuilder returned null for TTry - returning placeholder");
		return ERaw("# ERROR: ExceptionBuilder failed to compile try expression");	
	case TFunction(f):
		var fluentPattern = PatternDetector.detectFluentAPIPattern(f);
		var args = [];
		var paramRenaming = new Map<String,String>();
		var oldTempVarRenameMap = currentContext.tempVarRenameMap;
		var isFirstParam = true;
		for (arg  in  f.args) {
			var originalName = arg.v.name;
			var idKey = Std.string(arg.v.id);
			var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
				true;
			} else if (f.expr != null) {
				!reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, f.expr);
			} else {
				false;
			};
			var strippedName = originalName;
			var hasNumericSuffix = false;
			var renamedPattern = ~/^(.+?)(\d+)$/;
			if (renamedPattern.match(originalName)) {
				var baseWithoutSuffix = renamedPattern.matched(1);
				var suffix = renamedPattern.matched(2);
				var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items", "priority"];
				if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix) >= 0) {
					strippedName = baseWithoutSuffix;
					hasNumericSuffix = true;
				};
			};
			var baseName = ElixirASTHelpers.toElixirVarName(strippedName);
			var finalName = if (isActuallyUnused && !StringTools.startsWith(baseName, "_")) {
				"_" + baseName;
			} else {
				baseName;
			};
			if (!currentContext.tempVarRenameMap.exists(idKey)) {
				currentContext.tempVarRenameMap.set(idKey, finalName);
				currentContext.tempVarRenameMap.set(originalName, finalName);
			};
			if (originalName != finalName) {
				paramRenaming.set(originalName, finalName);
			};
			if (hasNumericSuffix && currentContext != null && currentContext.astContext != null) {
				currentContext.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);
			};
			if (originalName == "this1") {
				paramRenaming.set("this", finalName);
			};
			if (isFirstParam && currentContext.isInClassMethodContext) {
				currentContext.currentReceiverParamName = finalName;
				isFirstParam = false;
			};
			args.push(PVar(finalName));
			currentContext.functionParameterIds.set(idKey, true);
		};
		var functionUsageMap:Map<Int,Bool> = null;
		if (functionUsageMap != null) {
			currentContext.variableUsageMap = functionUsageMap;
		};
		trace("[TFunction DEBUG] BEFORE body compilation: tempVarRenameMap has ${Lambda.count(currentContext.tempVarRenameMap)} entries");
		if (currentContext.tempVarRenameMap.keys().hasNext()) {
			trace("[TFunction DEBUG] Map contents:");
			for (k  in  currentContext.tempVarRenameMap.keys()) {
				trace("[TFunction DEBUG]   \"$k\" -> \"${currentContext.tempVarRenameMap.get(k)}\"");
			};
		};
		var body = buildFromTypedExpr(f.expr, currentContext);
		trace("[TFunction DEBUG] AFTER body compilation: tempVarRenameMap has ${Lambda.count(currentContext.tempVarRenameMap)} entries");
		currentContext.tempVarRenameMap = oldTempVarRenameMap;
		for (arg  in  f.args) {
			currentContext.functionParameterIds.remove(Std.string(arg.v.id));
		};
		if (paramRenaming.keys().hasNext()) {
			body = applyParameterRenaming(body, paramRenaming);
		};
		var fnAst = makeAST(EFn([{ args : args, guard : null, body : body }]));
		if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
			fnAst.metadata.isFluentMethod = true;
			fnAst.metadata.returnsThis = fluentPattern.returnsThis;
			if (fluentPattern.fieldMutations.length > 0) {
				fnAst.metadata.mutatesFields = [];
				fnAst.metadata.fieldMutations = [];
				for (mutation  in  fluentPattern.fieldMutations) {
					fnAst.metadata.mutatesFields.push(mutation.field);
					fnAst.metadata.fieldMutations.push({ field : mutation.field, expr : buildFromTypedExpr(mutation.expr, currentContext) });
				};
			};
		};
		fnAst.def;	
	case TObjectDecl(fields):
		var result = reflaxe.elixir.ast.builders.ObjectBuilder.build(fields, currentContext);
		if (result != null) return result;
		trace("[ERROR] ObjectBuilder returned null for TObjectDecl - returning placeholder");
		return ERaw("# ERROR: ObjectBuilder failed to compile object declaration");	
	case TNew(c, params, el):
		var result = reflaxe.elixir.ast.builders.ConstructorBuilder.build(c, params, el, currentContext);
		if (result != null) return result;
		trace("[ERROR] ConstructorBuilder returned null for TNew - returning placeholder");
		return ERaw("# ERROR: ConstructorBuilder failed to compile constructor call");	
	case TFor(v, e1, e2):
		var buildContext:reflaxe.elixir.ast.builders.LoopBuilder.BuildContext = { isFeatureEnabled : function(f) return currentContext.isFeatureEnabled(f), buildFromTypedExpr : function(e, ?) return buildFromTypedExpr(e, currentContext), whileLoopCounter : currentContext.whileLoopCounter };
		return LoopBuilder.buildFor(v, e1, e2, expr, buildContext, function(name) ->  @:implicitReturn return VariableAnalyzer.toElixirVarName(name));	
	case TWhile(econd, e, normalWhile):
		var buildContext:reflaxe.elixir.ast.builders.LoopBuilder.BuildContext = { isFeatureEnabled : function(f) return currentContext.isFeatureEnabled(f), buildFromTypedExpr : function(e, ?) return buildFromTypedExpr(e, currentContext), whileLoopCounter : currentContext.whileLoopCounter };
		return LoopBuilder.buildWhileComplete(econd, e, normalWhile, expr, buildContext, function(name) ->  @:implicitReturn return VariableAnalyzer.toElixirVarName(name));	
	case TEnumParameter(e, ef, index):
		var sourceVarName:String = null;
		switch (e.expr) {
			case TLocal(v):
				sourceVarName = VariableAnalyzer.toElixirVarName(v.name);			
			default:
		};
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan.exists(index)) {
			var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
			if (sourceVarName != null && (sourceVarName == "g" || (sourceVarName.startsWith("g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
				if (info.finalName != sourceVarName) {
					return EVar(info.finalName);
				};
			};
			if (info.finalName == sourceVarName && sourceVarName != null) {
				return null;
			} else {
				return EVar(info.finalName);
			};
		} else {
			if (sourceVarName != null && (sourceVarName == "g" || (sourceVarName.startsWith("g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
				return null;
			};
			var skipExtraction = false;
			var extractedVarName:String = null;
			if (!skipExtraction) {
				switch (e.expr) {
					case TLocal(v):
						var varName = VariableAnalyzer.toElixirVarName(v.name);
						if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
							extractedVarName = currentContext.currentClauseContext.localToName.get(v.id);
							skipExtraction = true;
						} else {
							var isExtractionTemp = false;
							if (currentContext.tempVarRenameMap.exists(Std.string(v.id))) {
								isExtractionTemp = true;
							} else if (varName == "g" || (varName.startsWith("g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
								isExtractionTemp = false;
							};
							if (isExtractionTemp) {
								extractedVarName = varName;
								skipExtraction = true;
							};
						};					
					case _:
				};
			};
			if (skipExtraction && extractedVarName != null) {
				EVar(extractedVarName);
			} else {
				var exprAST = buildFromTypedExpr(e, currentContext);
				ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]);
			};
		};	
	case TEnumIndex(e):
		var enumExpr = buildFromTypedExpr(e, currentContext);
		if (enumExpr != null) {
			enumExpr.def;
		} else {
			EVar("nil");
		};	
	case TThrow(e):
		var result = ExceptionBuilder.buildThrow(e, currentContext);
		if (result != null) {
			return result;
		};
		EThrow(buildFromTypedExpr(e, currentContext));	
	case TMeta(_, e):
		convertExpression(e);	
	case TParenthesis(e):
		convertExpression(e);	
	case TCast(e, _):
		convertExpression(e);	
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		EAtom(moduleName);	
	case TIdent(s):
		EVar(VariableAnalyzer.toElixirVarName(s));	
}) {
			var ` = expr.expr;
			switch (@:exhaustive enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						var c = `;
						{
							reflaxe.elixir.ast.builders.LiteralBuilder.buildConst(c, expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
				};
				case 1: {
					var ` = `[0];
					{
						var v = `;
						{
							var idKey = Std.string(v.id);
							var nameKey = v.name;
							var varName = if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								var renamed = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.get(idKey);
								};
								renamed;
							} else {
								if ({
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.exists(nameKey);
								}) {
									var renamed = {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
										cast this.get(nameKey);
									};
									renamed;
								} else {
									if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInConstructorArgContext) {
										var pattern = new EReg("^(.+?)(\\d+)$", "");
										var baseName = if (pattern.match(v.name)) {
											var base = pattern.matched(1);
											var suffix = pattern.matched(2);
											base;
										} else {
											v.name;
										};
										reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(baseName, null);
									} else {
										var converted = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
										converted;
									};
								};
							};
							reflaxe.elixir.ast.ElixirASTDef.EVar(varName);
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var index = `;
						{
							reflaxe.elixir.ast.builders.ArrayBuilder.buildArrayAccess(e, index, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var e1 = `;
						var e2 = `;
						{
							var result = @:ast(switch (op) {
	case OpAssign:
		var pattern = PatternBuilder.extractPattern(e1);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var shouldSkipAssign = false;
		switch (pattern) {
			case PVar(name):
				var valueName = switch (rightAST != null ? rightAST.def : null) {
					case EVar(varName):
						varName;					
					default:
						null;					
				};
				if (PatternDetector.isTempPatternVarName(name)) {
					shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
						case EVar(varName) if (varName == name || PatternDetector.isTempPatternVarName(varName)):
							true;						
						default:
							false;						
					};
				} else if (valueName != null) {
					if (valueName == name) {
						shouldSkipAssign = true;
					} else if (PatternDetector.isTempPatternVarName(valueName)) {
						shouldSkipAssign = true;
					};
				};			
			default:
		};
		if (shouldSkipAssign) {
			null;
		} else {
			EMatch(pattern, rightAST);
		};	
	case OpAssignOp(innerOp):
		var pattern = PatternBuilder.extractPattern(e1);
		var leftAST = buildFromTypedExpr(e1, currentContext);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var innerBinop = BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s));
		EMatch(pattern, innerBinop);	
	default:
		var leftAST = buildFromTypedExpr(e1, currentContext);
		var rightAST = buildFromTypedExpr(e2, currentContext);
		var ast = BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s));
		ast.def;	
}) switch (enumIndex op) {
								case 4: {
									{
										var pattern = reflaxe.elixir.ast.builders.PatternBuilder.extractPattern(e1);
										var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										var shouldSkipAssign = false;
										@:ast(switch (pattern) {
	case PVar(name):
		var valueName = switch (rightAST != null ? rightAST.def : null) {
			case EVar(varName):
				varName;			
			default:
				null;			
		};
		if (PatternDetector.isTempPatternVarName(name)) {
			shouldSkipAssign = switch (rightAST != null ? rightAST.def : null) {
				case EVar(varName) if (varName == name || PatternDetector.isTempPatternVarName(varName)):
					true;				
				default:
					false;				
			};
		} else if (valueName != null) {
			if (valueName == name) {
				shouldSkipAssign = true;
			} else if (PatternDetector.isTempPatternVarName(valueName)) {
				shouldSkipAssign = true;
			};
		};	
	default:
}) if (enumIndex pattern == 0) {
											var ` = pattern[0];
											{
												var name = `;
												{
													var valueName = @:ast(switch (rightAST != null ? rightAST.def : null) {
	case EVar(varName):
		varName;	
	default:
		null;	
}) {
														var ` = if (rightAST != null) {
															rightAST.def;
														} else {
															null;
														};
														if (` == null) {
															null;
														} else if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var varName = `;
																{
																	varName;
																};
															};
														} else {
															null;
														};
													};
													if (reflaxe.elixir.helpers.PatternDetector.isTempPatternVarName(name)) {
														shouldSkipAssign = @:ast(switch (rightAST != null ? rightAST.def : null) {
	case EVar(varName) if (varName == name || PatternDetector.isTempPatternVarName(varName)):
		true;	
	default:
		false;	
}) {
															var ` = if (rightAST != null) {
																rightAST.def;
															} else {
																null;
															};
															if (` == null) {
																false;
															} else if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	var varName = `;
																	if (varName == name || reflaxe.elixir.helpers.PatternDetector.isTempPatternVarName(varName)) {
																		true;
																	} else {
																		false;
																	};
																};
															} else {
																false;
															};
														};
													} else {
														if (valueName != null) {
															if (valueName == name) {
																shouldSkipAssign = true;
															} else {
																if (reflaxe.elixir.helpers.PatternDetector.isTempPatternVarName(valueName)) {
																	shouldSkipAssign = true;
																};
															};
														};
													};
												};
											};
										} else {};
										if (shouldSkipAssign) {
											null;
										} else {
											reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, rightAST);
										};
									};
								};
								case 20: {
									var ` = op[0];
									{
										var innerOp = `;
										{
											var pattern = reflaxe.elixir.ast.builders.PatternBuilder.extractPattern(e1);
											var leftAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
											var innerBinop = reflaxe.elixir.ast.builders.BinaryOpBuilder.buildBinopFromAST(innerOp, leftAST, rightAST, e1, e2, function(s:String) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s), null);
											reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, innerBinop);
										};
									};
								};
								default: {
									var leftAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e1, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									var rightAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e2, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									var ast = reflaxe.elixir.ast.builders.BinaryOpBuilder.buildBinopFromAST(op, leftAST, rightAST, e1, e2, function(s:String) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s), null);
									ast.def;
								}
							};
							result;
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var fa = `;
						{
							var isSimpleCase = @:ast(switch (fa) {
	case FEnum(_, _):
		true;	
	case FStatic(_, _):
		!currentContext.isInExUnitTest;	
	case FAnon(_):
		!currentContext.isInExUnitTest;	
	case FInstance(_, _, _):
		!currentContext.isInExUnitTest;	
	case FDynamic(_):
		true;	
	case FClosure(_, _):
		true;	
}) switch (@:exhaustive enumIndex fa) {
								case 0: {
									var ` = fa[0];
									var ` = fa[1];
									var ` = fa[2];
									{
										! reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInExUnitTest;
									};
								};
								case 1: {
									var ` = fa[0];
									var ` = fa[1];
									{
										! reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInExUnitTest;
									};
								};
								case 2: {
									var ` = fa[0];
									{
										! reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInExUnitTest;
									};
								};
								case 3: {
									var ` = fa[0];
									{
										true;
									};
								};
								case 4: {
									var ` = fa[0];
									var ` = fa[1];
									{
										true;
									};
								};
								case 5: {
									var ` = fa[0];
									var ` = fa[1];
									{
										true;
									};
								};
							};
							if (isSimpleCase) {
								var result = reflaxe.elixir.ast.builders.FieldAccessBuilder.build(e, fa, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								if (result != null) {
									result;
								} else {
									@:ast(switch (fa) {
	case FEnum(enumType, ef):
		var enumT = enumType.get();
		if (enumT.meta.has(":elixirIdiomatic")) {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			EAtom(atomName);
		} else {
			var hasParameters = switch (ef.type) {
				case TFun(args, _):
					args.length > 0;				
				default:
					false;				
			};
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			if (hasParameters) {
				ETuple([makeAST(EAtom(atomName))]);
			} else {
				EAtom(atomName);
			};
		};	
	default:
		null;	
}) if (enumIndex fa == 5) {
										var ` = fa[0];
										var ` = fa[1];
										{
											var enumType = `;
											var ef = `;
											{
												var enumT = enumType.get();
												if (enumT.meta.has(":elixirIdiomatic")) {
													var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
													reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
														var this;
														this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
														cast cast this;
													});
												} else {
													var hasParameters = @:ast(switch (ef.type) {
	case TFun(args, _):
		args.length > 0;	
	default:
		false;	
}) {
														var ` = ef.type;
														if (enumIndex ` == 4) {
															var ` = `[0];
															var ` = `[1];
															{
																var args = `;
																{
																	args.length > 0;
																};
															};
														} else {
															false;
														};
													};
													var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
													if (hasParameters) {
														reflaxe.elixir.ast.ElixirASTDef.ETuple([{
															var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																var this;
																this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
																cast this;
															});
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}]);
													} else {
														reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
															var this;
															this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
															cast cast this;
														});
													};
												};
											};
										};
									} else {
										null;
									};
								};
							} else {
								@:ast(switch (fa) {
	case FEnum(enumType, ef):
		var enumT = enumType.get();
		if (enumT.meta.has(":elixirIdiomatic")) {
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			EAtom(atomName);
		} else {
			var hasParameters = switch (ef.type) {
				case TFun(args, _):
					args.length > 0;				
				default:
					false;				
			};
			var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
			if (hasParameters) {
				ETuple([makeAST(EAtom(atomName))]);
			} else {
				EAtom(atomName);
			};
		};	
	case FStatic(classRef, cf):
		var className = classRef.get().name;
		var fieldName = extractFieldName(fa);
		var field = cf.get();
		var isAtomField = false;
		switch (field.type) {
			case TAbstract(abstractRef, _):
				var abstractType = abstractRef.get();
				if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
					isAtomField = true;
				};			
			case _:
		};
		if (!isAtomField) {
			var classType = classRef.get();
			switch (classType.kind) {
				case KAbstractImpl(abstractRef):
					var abstractType = abstractRef.get();
					switch (abstractType.type) {
						case TAbstract(underlyingRef, _):
							var underlyingType = underlyingRef.get();
							if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
								isAtomField = true;
							};						
						case _:
					};				
				case _:
			};
		};
		if (isAtomField && field.expr() != null) {
			switch (field.expr().expr) {
				case TConst(TString(s)):
					EAtom(s);				
				case _:
					fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
					var target = buildFromTypedExpr(e, currentContext);
					EField(target, fieldName);				
			};
		} else {
			fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
			if (false) {
				EVar(fieldName);
			} else {
				var target = if (e != null) {
					switch (e.expr) {
						case TTypeExpr(m):
							var moduleName = moduleTypeToString(m);
							makeAST(EVar(moduleName));						
						default:
							buildFromTypedExpr(e, currentContext);						
					};
				} else {
					null;
				};
				if (target == null) {
					EVar("UnknownModule." + fieldName);
				} else {
					EField(target, fieldName);
				};
			};
		};	
	case FAnon(cf):
		var fieldName = cf.get().name;
		var target = buildFromTypedExpr(e, currentContext);
		if (~/^_\d+$/.match(fieldName)) {
			var index = Std.parseInt(fieldName.substr(1)) - 1;
			ECall(null, "elem", [target, makeAST(EInteger(index))]);
		} else {
			fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
			EField(target, fieldName);
		};	
	default:
		var target = buildFromTypedExpr(e, currentContext);
		var fieldName = extractFieldName(fa);
		var originalFieldName = fieldName;
		fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
		if (currentContext.isInExUnitTest) {
			switch (e.expr) {
				case TConst(TThis):
					var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
					EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));				
				case TLocal(v) if (v.name == "struct"):
					var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
					EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));				
				default:
					if (fieldName == "elem") {
						EField(target, fieldName);
					} else if (isMapAccess(e.t)) {
						EAccess(target, makeAST(EAtom(fieldName)));
					} else {
						EField(target, fieldName);
					};				
			};
		} else {
			if (fieldName == "elem") {
				EField(target, fieldName);
			} else if (isMapAccess(e.t)) {
				EAccess(target, makeAST(EAtom(fieldName)));
			} else {
				EField(target, fieldName);
			};
		};	
}) switch (enumIndex fa) {
									case 1: {
										var ` = fa[0];
										var ` = fa[1];
										{
											var classRef = `;
											var cf = `;
											{
												var className = classRef.get().name;
												var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
												var field = cf.get();
												var isAtomField = false;
												@:ast(switch (field.type) {
	case TAbstract(abstractRef, _):
		var abstractType = abstractRef.get();
		if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
			isAtomField = true;
		};	
	case _:
}) {
													var ` = field.type;
													if (enumIndex ` == 8) {
														var ` = `[0];
														var ` = `[1];
														{
															var abstractRef = `;
															{
																var abstractType = abstractRef.get();
																if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
																	isAtomField = true;
																};
															};
														};
													} else {};
												};
												if (! isAtomField) {
													var classType = classRef.get();
													@:ast(switch (classType.kind) {
	case KAbstractImpl(abstractRef):
		var abstractType = abstractRef.get();
		switch (abstractType.type) {
			case TAbstract(underlyingRef, _):
				var underlyingType = underlyingRef.get();
				if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
					isAtomField = true;
				};			
			case _:
		};	
	case _:
}) {
														var ` = classType.kind;
														if (enumIndex ` == 7) {
															var ` = `[0];
															{
																var abstractRef = `;
																{
																	var abstractType = abstractRef.get();
																	@:ast(switch (abstractType.type) {
	case TAbstract(underlyingRef, _):
		var underlyingType = underlyingRef.get();
		if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
			isAtomField = true;
		};	
	case _:
}) {
																		var ` = abstractType.type;
																		if (enumIndex ` == 8) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var underlyingRef = `;
																				{
																					var underlyingType = underlyingRef.get();
																					if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
																						isAtomField = true;
																					};
																				};
																			};
																		} else {};
																	};
																};
															};
														} else {};
													};
												};
												if (isAtomField && field.expr() != null) {
													@:ast(switch (field.expr().expr) {
	case TConst(TString(s)):
		EAtom(s);	
	case _:
		fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
		var target = buildFromTypedExpr(e, currentContext);
		EField(target, fieldName);	
}) {
														var ` = field.expr().expr;
														if (enumIndex ` == 0) {
															var ` = `[0];
															if (enumIndex ` == 2) {
																var ` = `[0];
																{
																	var s = `;
																	{
																		reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																			var this;
																			this = reflaxe.elixir.ast.NameUtils.toSnakeCase(s);
																			cast cast this;
																		});
																	};
																};
															} else {
																fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
															};
														} else {
															fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
															var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
														};
													};
												} else {
													fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
													if (false) {
														reflaxe.elixir.ast.ElixirASTDef.EVar(fieldName);
													} else {
														var target = if (e != null) {
															@:ast(switch (e.expr) {
	case TTypeExpr(m):
		var moduleName = moduleTypeToString(m);
		makeAST(EVar(moduleName));	
	default:
		buildFromTypedExpr(e, currentContext);	
}) {
																var ` = e.expr;
																if (enumIndex ` == 5) {
																	var ` = `[0];
																	{
																		var m = `;
																		{
																			var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
																			{
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(moduleName), metadata : {}, pos : pos};
																			};
																		};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																};
															};
														} else {
															null;
														};
														if (target == null) {
															reflaxe.elixir.ast.ElixirASTDef.EVar("UnknownModule." + fieldName);
														} else {
															reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
														};
													};
												};
											};
										};
									};
									case 2: {
										var ` = fa[0];
										{
											var cf = `;
											{
												var fieldName = cf.get().name;
												var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												if (new EReg("^_\\d+$", "").match(fieldName)) {
													var index = Std.parseInt(fieldName.substr(1, null)) - 1;
													reflaxe.elixir.ast.ElixirASTDef.ECall(null, "elem", [target, {
														var pos = null;
														{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index), metadata : {}, pos : pos};
													}]);
												} else {
													fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
													reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
												};
											};
										};
									};
									case 5: {
										var ` = fa[0];
										var ` = fa[1];
										{
											var enumType = `;
											var ef = `;
											{
												var enumT = enumType.get();
												if (enumT.meta.has(":elixirIdiomatic")) {
													var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
													reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
														var this;
														this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
														cast cast this;
													});
												} else {
													var hasParameters = @:ast(switch (ef.type) {
	case TFun(args, _):
		args.length > 0;	
	default:
		false;	
}) {
														var ` = ef.type;
														if (enumIndex ` == 4) {
															var ` = `[0];
															var ` = `[1];
															{
																var args = `;
																{
																	args.length > 0;
																};
															};
														} else {
															false;
														};
													};
													var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
													if (hasParameters) {
														reflaxe.elixir.ast.ElixirASTDef.ETuple([{
															var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																var this;
																this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
																cast this;
															});
															var pos = null;
															{def : def, metadata : {}, pos : pos};
														}]);
													} else {
														reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
															var this;
															this = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
															cast cast this;
														});
													};
												};
											};
										};
									};
									default: {
										var target = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
										var originalFieldName = fieldName;
										fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
										if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInExUnitTest) {
											@:ast(switch (e.expr) {
	case TConst(TThis):
		var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
		EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));	
	case TLocal(v) if (v.name == "struct"):
		var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
		EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));	
	default:
		if (fieldName == "elem") {
			EField(target, fieldName);
		} else if (isMapAccess(e.t)) {
			EAccess(target, makeAST(EAtom(fieldName)));
		} else {
			EField(target, fieldName);
		};	
}) {
												var ` = e.expr;
												switch (enumIndex `) {
													case 0: {
														var ` = `[0];
														if (enumIndex ` == 5) {
															{
																var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																reflaxe.elixir.ast.ElixirASTDef.EAccess({
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("context"), metadata : {}, pos : pos};
																}, {
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(snakeFieldName);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																});
															};
														} else {
															if (fieldName == "elem") {
																reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
															} else {
																if ({
																	var t = e.t;
																	reflaxe.elixir.ast.ElixirASTHelpers.isMapAccess(t);
																}) {
																	reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
																		var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																			var this;
																			this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																			cast this;
																		});
																		var pos = null;
																		{def : def, metadata : {}, pos : pos};
																	});
																} else {
																	reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
																};
															};
														};
													};
													case 1: {
														var ` = `[0];
														{
															var v = `;
															if (v.name == "struct") {
																var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																reflaxe.elixir.ast.ElixirASTDef.EAccess({
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EVar("context"), metadata : {}, pos : pos};
																}, {
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(snakeFieldName);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																});
															} else {
																if (fieldName == "elem") {
																	reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
																} else {
																	if ({
																		var t = e.t;
																		reflaxe.elixir.ast.ElixirASTHelpers.isMapAccess(t);
																	}) {
																		reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
																			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																				var this;
																				this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																				cast this;
																			});
																			var pos = null;
																			{def : def, metadata : {}, pos : pos};
																		});
																	} else {
																		reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
																	};
																};
															};
														};
													};
													default: {
														if (fieldName == "elem") {
															reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
														} else {
															if ({
																var t = e.t;
																reflaxe.elixir.ast.ElixirASTHelpers.isMapAccess(t);
															}) {
																reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
																	var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
																		var this;
																		this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																		cast this;
																	});
																	var pos = null;
																	{def : def, metadata : {}, pos : pos};
																});
															} else {
																reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
															};
														};
													}
												};
											};
										} else {
											if (fieldName == "elem") {
												reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
											} else {
												if ({
													var t = e.t;
													reflaxe.elixir.ast.ElixirASTHelpers.isMapAccess(t);
												}) {
													reflaxe.elixir.ast.ElixirASTDef.EAccess(target, {
														var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
															var this;
															this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
															cast this;
														});
														var pos = null;
														{def : def, metadata : {}, pos : pos};
													});
												} else {
													reflaxe.elixir.ast.ElixirASTDef.EField(target, fieldName);
												};
											};
										};
									}
								};
							};
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						var m = `;
						{
							var moduleName = reflaxe.elixir.ast.ElixirASTBuilder.moduleTypeToString(m);
							reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
								var this;
								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(moduleName);
								cast cast this;
							});
						};
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(e);
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var fields = `;
						{
							var result = reflaxe.elixir.ast.builders.ObjectBuilder.build(fields, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] ObjectBuilder returned null for TObjectDecl - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2609, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: ObjectBuilder failed to compile object declaration");
						};
					};
				};
				case 8: {
					var ` = `[0];
					{
						var el = `;
						{
							reflaxe.elixir.ast.builders.ArrayBuilder.buildArrayDecl(el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var el = `;
						{
							reflaxe.elixir.ast.builders.CallExprBuilder.buildCall(e, el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var c = `;
						var params = `;
						var el = `;
						{
							var result = reflaxe.elixir.ast.builders.ConstructorBuilder.build(c, params, el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] ConstructorBuilder returned null for TNew - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2620, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: ConstructorBuilder failed to compile constructor call");
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var postFix = `;
						var e = `;
						{
							@:ast(switch (op) {
	case OpNot:
		switch (e.expr) {
			case TBlock([]):
				EUnary(Not, makeAST(ENil));			
			case TBlock(exprs) if (exprs.length == 1):
				EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));			
			case TBlock(exprs):
				var statements = [];
				for (i  in  0 ... exprs.length - 1) {
					statements.push(buildFromTypedExpr(exprs[i], currentContext));
				};
				var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
				statements.push(makeAST(EUnary(Not, lastExpr)));
				EBlock(statements);			
			default:
				var expr = buildFromTypedExpr(e, currentContext).def;
				EUnary(Not, makeAST(expr));			
		};	
	case OpNeg:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(Negate, makeAST(expr));	
	case OpNegBits:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(BitwiseNot, makeAST(expr));	
	case OpIncrement, OpDecrement:
		var one = makeAST(EInteger(1));
		var builtExpr = buildFromTypedExpr(e, currentContext);
		if (!postFix) {
			var operation = if (op == OpIncrement) {
				EBinary(Add, builtExpr, one);
			} else {
				EBinary(Subtract, builtExpr, one);
			};
			operation;
		} else {
			var operation = if (op == OpIncrement) {
				EBinary(Add, builtExpr, one);
			} else {
				EBinary(Subtract, builtExpr, one);
			};
			operation;
		};	
	case OpSpread:
		var builtExpr = buildFromTypedExpr(e, currentContext);
		EUnquoteSplicing(builtExpr);	
}) switch (@:exhaustive enumIndex op) {
								case 0, 1: {
									{
										var one = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(1), metadata : {}, pos : pos};
										};
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										if (! postFix) {
											var operation = if (op == haxe.macro.Unop.OpIncrement) {
												reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, builtExpr, one);
											} else {
												reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, builtExpr, one);
											};
											operation;
										} else {
											var operation = if (op == haxe.macro.Unop.OpIncrement) {
												reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Add, builtExpr, one);
											} else {
												reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Subtract, builtExpr, one);
											};
											operation;
										};
									};
								};
								case 2: {
									{
										@:ast(switch (e.expr) {
	case TBlock([]):
		EUnary(Not, makeAST(ENil));	
	case TBlock(exprs) if (exprs.length == 1):
		EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));	
	case TBlock(exprs):
		var statements = [];
		for (i  in  0 ... exprs.length - 1) {
			statements.push(buildFromTypedExpr(exprs[i], currentContext));
		};
		var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
		statements.push(makeAST(EUnary(Not, lastExpr)));
		EBlock(statements);	
	default:
		var expr = buildFromTypedExpr(e, currentContext).def;
		EUnary(Not, makeAST(expr));	
}) {
											var ` = e.expr;
											if (enumIndex ` == 14) {
												var ` = `[0];
												if (`.length == 0) {
													{
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
															var pos = null;
															{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
														});
													};
												} else {
													var exprs = `;
													if (exprs.length == 1) {
														reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[0], reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
													} else {
														var exprs = `;
														{
															var statements = [];
															{
																var ` = 0;
																var ` = exprs.length - 1;
																while (` < `) {
																	var i = ` ++;
																	statements.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[i], reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																};
															};
															var lastExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(exprs[exprs.length - 1], reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															statements.push({
																var pos = null;
																{def : reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, lastExpr), metadata : {}, pos : pos};
															});
															reflaxe.elixir.ast.ElixirASTDef.EBlock(statements);
														};
													};
												};
											} else {
												var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
												reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Not, {
													var pos = null;
													{def : expr, metadata : {}, pos : pos};
												});
											};
										};
									};
								};
								case 3: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.Negate, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 4: {
									{
										var expr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext).def;
										reflaxe.elixir.ast.ElixirASTDef.EUnary(reflaxe.elixir.ast.EUnaryOp.BitwiseNot, {
											var pos = null;
											{def : expr, metadata : {}, pos : pos};
										});
									};
								};
								case 5: {
									{
										var builtExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
										reflaxe.elixir.ast.ElixirASTDef.EUnquoteSplicing(builtExpr);
									};
								};
							};
						};
					};
				};
				case 12: {
					var ` = `[0];
					{
						var f = `;
						{
							var fluentPattern = reflaxe.elixir.helpers.PatternDetector.detectFluentAPIPattern(f);
							var args = [];
							var paramRenaming = {
								{};
								new haxe.ds.StringMap();
							};
							var oldTempVarRenameMap = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
							var isFirstParam = true;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									var originalName = arg.v.name;
									var idKey = Std.string(arg.v.id);
									var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
										true;
									} else {
										if (f.expr != null) {
											! reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, f.expr);
										} else {
											false;
										};
									};
									var strippedName = originalName;
									var hasNumericSuffix = false;
									var renamedPattern = new EReg("^(.+?)(\\d+)$", "");
									if (renamedPattern.match(originalName)) {
										var baseWithoutSuffix = renamedPattern.matched(1);
										var suffix = renamedPattern.matched(2);
										var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items", "priority"];
										if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix, null) >= 0) {
											strippedName = baseWithoutSuffix;
											hasNumericSuffix = true;
										};
									};
									var baseName = reflaxe.elixir.ast.ElixirASTHelpers.toElixirVarName(strippedName);
									var finalName = if (isActuallyUnused && ! StringTools.startsWith(baseName, "_")) {
										"_" + baseName;
									} else {
										baseName;
									};
									if (! {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
										cast this.exists(idKey);
									}) {
										{
											var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
											cast this.set(idKey, finalName);
										};
										{
											var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
											cast this.set(originalName, finalName);
										};
									};
									if (originalName != finalName) {
										{
											paramRenaming.set(originalName, finalName);
										};
									};
									if (hasNumericSuffix && reflaxe.elixir.ast.ElixirASTBuilder.currentContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext != null) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentContext.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);
									};
									if (originalName == "this1") {
										{
											paramRenaming.set("this", finalName);
										};
									};
									if (isFirstParam && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isInClassMethodContext) {
										reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentReceiverParamName = finalName;
										isFirstParam = false;
									};
									args.push(reflaxe.elixir.ast.EPattern.PVar(finalName));
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.functionParameterIds;
										cast this.set(idKey, true);
									};
								};
							};
							var functionUsageMap = null;
							if (functionUsageMap != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap = functionUsageMap;
							};
							haxe.Log.trace("[TFunction DEBUG] BEFORE body compilation: tempVarRenameMap has " + Lambda.count(cast reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap, null) + " entries", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2505, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
								cast this.keys();
							}.hasNext()) {
								haxe.Log.trace("[TFunction DEBUG] Map contents:", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2507, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								for (k in {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.keys();
								}) {
									haxe.Log.trace("[TFunction DEBUG]   \"" + k + "\" -> \"" + {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
										cast this.get(k);
									} + "\"", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2509, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
								};
							};
							var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(f.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							haxe.Log.trace("[TFunction DEBUG] AFTER body compilation: tempVarRenameMap has " + Lambda.count(cast reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap, null) + " entries", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2515, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap = oldTempVarRenameMap;
							{
								var ` = 0;
								var ` = f.args;
								while (` < `.length) {
									var arg = `[`];
									++ `;
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.functionParameterIds;
										var key = Std.string(arg.v.id);
										cast this.remove(key);
									};
								};
							};
							if (paramRenaming.keys().hasNext()) {
								body = reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(body, paramRenaming);
							};
							var fnAst = {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : args, guard : null, body : body}]), metadata : {}, pos : pos};
							};
							if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
								fnAst.metadata.isFluentMethod = true;
								fnAst.metadata.returnsThis = fluentPattern.returnsThis;
								if (fluentPattern.fieldMutations.length > 0) {
									fnAst.metadata.mutatesFields = [];
									fnAst.metadata.fieldMutations = [];
									{
										var ` = 0;
										var ` = fluentPattern.fieldMutations;
										while (` < `.length) {
											var mutation = `[`];
											++ `;
											fnAst.metadata.mutatesFields.push(mutation.field);
											fnAst.metadata.fieldMutations.push({field : mutation.field, expr : reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(mutation.expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext)});
										};
									};
								};
							};
							fnAst.def;
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var v = `;
						var init = `;
						{
							if (init == null || reflaxe.elixir.ast.ElixirASTBuilder.isSimpleInit(init)) {
								var result = reflaxe.elixir.ast.builders.VariableBuilder.buildVariableDeclaration(v, init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
								if (result != null) {
									return result;
								};
							};
							var isInfrastructureVar = reflaxe.elixir.preprocessor.TypedExprPreprocessor.isInfrastructureVar(v.name);
							if (isInfrastructureVar && init != null) {
								@:ast(switch (init.expr) {
	case TField(obj, fa):
		var fieldName = extractFieldName(fa);
		switch (obj.expr) {
			case TLocal(localVar):
				var extractedVarName = VariableAnalyzer.toElixirVarName(localVar.name) + "_" + reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
				if (currentContext.tempVarRenameMap == null) {
					currentContext.tempVarRenameMap = new Map();
				};
				currentContext.tempVarRenameMap.set(v.name, extractedVarName);			
			default:
		};	
	case TEnumParameter(_, _, _):
	case TLocal(localVar):
		var sourceVar = localVar.name;
		if (sourceVar == "g" || sourceVar == "_g" || (sourceVar.length > 1 && sourceVar.charAt(0) == "g") || (sourceVar.length > 2 && sourceVar.substr(0, 2) == "_g")) {
			return null;
		};	
	default:
}) {
									var ` = init.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var localVar = `;
												{
													var sourceVar = localVar.name;
													if (sourceVar == "g" || sourceVar == "_g" || (sourceVar.length > 1 && sourceVar.charAt(0) == "g") || (sourceVar.length > 2 && sourceVar.substr(0, 2) == "_g")) {
														return null;
													};
												};
											};
										};
										case 4: {
											var ` = `[0];
											var ` = `[1];
											{
												var obj = `;
												var fa = `;
												{
													var fieldName = reflaxe.elixir.ast.ElixirASTBuilder.extractFieldName(fa);
													@:ast(switch (obj.expr) {
	case TLocal(localVar):
		var extractedVarName = VariableAnalyzer.toElixirVarName(localVar.name) + "_" + reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
		if (currentContext.tempVarRenameMap == null) {
			currentContext.tempVarRenameMap = new Map();
		};
		currentContext.tempVarRenameMap.set(v.name, extractedVarName);	
	default:
}) {
														var ` = obj.expr;
														if (enumIndex ` == 1) {
															var ` = `[0];
															{
																var localVar = `;
																{
																	var extractedVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(localVar.name, null) + "_" + reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
																	if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap == null) {
																		reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap = {
																			{};
																			new haxe.ds.StringMap();
																		};
																	};
																	{
																		var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
																		var key = v.name;
																		cast this.set(key, extractedVarName);
																	};
																};
															};
														} else {};
													};
												};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{};
										};
										default: {}
									};
								};
							};
							if (init != null) {
								@:ast(switch (init.expr) {
	case TBlock(blockStmts) if (blockStmts.length >= 3):
		var mapLiteral = tryBuildMapLiteralFromBlock(blockStmts, currentContext);
		if (mapLiteral != null) {
			return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), mapLiteral);
		};
		var isConditionalComp = false;
		var tempVarName = "";
		switch (blockStmts[0].expr) {
			case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
				switch (tempInit.expr) {
					case TArrayDecl([]):
						tempVarName = tempVar.name;
						if (blockStmts.length >= 3) {
							switch (blockStmts[1].expr) {
								case TBlock(ifStmts):
									var allIfs = true;
									for (stmt  in  ifStmts) {
										switch (stmt.expr) {
											case TIf(_, _, null):
												continue;											
											default:
												allIfs = false;
												break;											
										};
									};
									if (allIfs && blockStmts.length > 2) {
										switch (blockStmts[blockStmts.length - 1].expr) {
											case TLocal(retVar) if (retVar.name == tempVarName):
												isConditionalComp = true;											
											default:
										};
									};								
								default:
							};
						};					
					default:
				};			
			default:
		};
		if (isConditionalComp) {
			var reconstructed = ComprehensionBuilder.tryReconstructConditionalComprehension(blockStmts, tempVarName, currentContext);
			if (reconstructed != null) {
				return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), reconstructed);
			};
		};	
	default:
}) {
									var ` = init.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										{
											var blockStmts = `;
											if (blockStmts.length >= 3) {
												var mapLiteral = reflaxe.elixir.ast.ElixirASTBuilder.tryBuildMapLiteralFromBlock(blockStmts, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												if (mapLiteral != null) {
													return reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null)), mapLiteral);
												};
												var isConditionalComp = false;
												var tempVarName = "";
												@:ast(switch (blockStmts[0].expr) {
	case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
		switch (tempInit.expr) {
			case TArrayDecl([]):
				tempVarName = tempVar.name;
				if (blockStmts.length >= 3) {
					switch (blockStmts[1].expr) {
						case TBlock(ifStmts):
							var allIfs = true;
							for (stmt  in  ifStmts) {
								switch (stmt.expr) {
									case TIf(_, _, null):
										continue;									
									default:
										allIfs = false;
										break;									
								};
							};
							if (allIfs && blockStmts.length > 2) {
								switch (blockStmts[blockStmts.length - 1].expr) {
									case TLocal(retVar) if (retVar.name == tempVarName):
										isConditionalComp = true;									
									default:
								};
							};						
						default:
					};
				};			
			default:
		};	
	default:
}) {
													var ` = blockStmts[0].expr;
													if (enumIndex ` == 13) {
														var ` = `[0];
														var ` = `[1];
														{
															var tempVar = `;
															var tempInit = `;
															if (tempInit != null && (StringTools.startsWith(tempVar.name, "g") || StringTools.startsWith(tempVar.name, "_g"))) {
																@:ast(switch (tempInit.expr) {
	case TArrayDecl([]):
		tempVarName = tempVar.name;
		if (blockStmts.length >= 3) {
			switch (blockStmts[1].expr) {
				case TBlock(ifStmts):
					var allIfs = true;
					for (stmt  in  ifStmts) {
						switch (stmt.expr) {
							case TIf(_, _, null):
								continue;							
							default:
								allIfs = false;
								break;							
						};
					};
					if (allIfs && blockStmts.length > 2) {
						switch (blockStmts[blockStmts.length - 1].expr) {
							case TLocal(retVar) if (retVar.name == tempVarName):
								isConditionalComp = true;							
							default:
						};
					};				
				default:
			};
		};	
	default:
}) {
																	var ` = tempInit.expr;
																	if (enumIndex ` == 8) {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				tempVarName = tempVar.name;
																				if (blockStmts.length >= 3) {
																					@:ast(switch (blockStmts[1].expr) {
	case TBlock(ifStmts):
		var allIfs = true;
		for (stmt  in  ifStmts) {
			switch (stmt.expr) {
				case TIf(_, _, null):
					continue;				
				default:
					allIfs = false;
					break;				
			};
		};
		if (allIfs && blockStmts.length > 2) {
			switch (blockStmts[blockStmts.length - 1].expr) {
				case TLocal(retVar) if (retVar.name == tempVarName):
					isConditionalComp = true;				
				default:
			};
		};	
	default:
}) {
																						var ` = blockStmts[1].expr;
																						if (enumIndex ` == 14) {
																							var ` = `[0];
																							{
																								var ifStmts = `;
																								{
																									var allIfs = true;
																									{
																										var ` = 0;
																										while (` < ifStmts.length) {
																											var stmt = ifStmts[`];
																											++ `;
																											@:ast(switch (stmt.expr) {
	case TIf(_, _, null):
		continue;	
	default:
		allIfs = false;
		break;	
}) {
																												var ` = stmt.expr;
																												if (enumIndex ` == 16) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (` == null) {
																														continue;
																													} else {
																														allIfs = false;
																														break;
																													};
																												} else {
																													allIfs = false;
																													break;
																												};
																											};
																										};
																									};
																									if (allIfs && blockStmts.length > 2) {
																										@:ast(switch (blockStmts[blockStmts.length - 1].expr) {
	case TLocal(retVar) if (retVar.name == tempVarName):
		isConditionalComp = true;	
	default:
}) {
																											var ` = blockStmts[blockStmts.length - 1].expr;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												{
																													var retVar = `;
																													if (retVar.name == tempVarName) {
																														isConditionalComp = true;
																													} else {};
																												};
																											} else {};
																										};
																									};
																								};
																							};
																						} else {};
																					};
																				};
																			};
																		} else {};
																	} else {};
																};
															} else {};
														};
													} else {};
												};
												if (isConditionalComp) {
													var reconstructed = reflaxe.elixir.ast.builders.ComprehensionBuilder.tryReconstructConditionalComprehension(blockStmts, tempVarName, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													if (reconstructed != null) {
														return reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null)), reconstructed);
													};
												};
											} else {};
										};
									} else {};
								};
							};
							var isEnumExtraction = false;
							var extractedFromTemp = "";
							var shouldSkipRedundantExtraction = false;
							var varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
							var tempToBinderMap = null;
							if (init != null) {
								@:ast(switch (init.expr) {
	case TEnumParameter(e, _, index):
		isEnumExtraction = true;
		varOrigin = ExtractionTemp;
		var tempVarName = VariableAnalyzer.toElixirVarName(v.name);
		if (currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
			currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : tempVarName }]);
		};
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
			var plan = currentContext.currentClauseContext.enumBindingPlan;
			if (plan.exists(index)) {
				shouldSkipRedundantExtraction = true;
				return null;
			};
		};
		if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
			shouldSkipRedundantExtraction = true;
		};	
	case TLocal(tempVar):
		if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)) {
			extractedFromTemp = tempVar.name;
			varOrigin = PatternBinder;
			if (currentContext.currentClauseContext != null) {
				var userVarName = VariableAnalyzer.toElixirVarName(v.name);
				currentContext.currentClauseContext.pushPatternBindings([{ varId : v.id, binderName : userVarName }]);
			};
			if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
				return null;
			};
			if (tempToBinderMap == null) {
				tempToBinderMap = new Map<Int,Int>();
			};
			tempToBinderMap.set(tempVar.id, v.id);
		} else {
			varOrigin = UserDefined;
		};	
	case TSwitch(switchExpr, cases, edef):
		varOrigin = UserDefined;	
	case _:
		varOrigin = UserDefined;	
}) {
									var ` = init.expr;
									switch (enumIndex `) {
										case 1: {
											var ` = `[0];
											{
												var tempVar = `;
												{
													if (StringTools.startsWith(tempVar.name, "_g") || tempVar.name == "g" || new EReg("^g\\d+$", "").match(tempVar.name)) {
														extractedFromTemp = tempVar.name;
														varOrigin = reflaxe.elixir.ast.VarOrigin.PatternBinder;
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null) {
															var userVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
															reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.pushPatternBindings([{varId : v.id, binderName : userVarName}]);
														};
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan != null) {
															return null;
														};
														if (tempToBinderMap == null) {
															tempToBinderMap = {
																{};
																new haxe.ds.IntMap();
															};
														};
														{
															var key = tempVar.id;
															var value = v.id;
															tempToBinderMap.set(key, value);
														};
													} else {
														varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
													};
												};
											};
										};
										case 18: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var switchExpr = `;
												var cases = `;
												var edef = `;
												{
													varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
												};
											};
										};
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var e = `;
												var index = `;
												{
													isEnumExtraction = true;
													varOrigin = reflaxe.elixir.ast.VarOrigin.ExtractionTemp;
													var tempVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && tempVarName.charAt(0) == "g") {
														reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.pushPatternBindings([{varId : v.id, binderName : tempVarName}]);
													};
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan != null) {
														var plan = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
														if (plan.exists(index)) {
															shouldSkipRedundantExtraction = true;
															return null;
														};
													};
													if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9"))) {
														shouldSkipRedundantExtraction = true;
													};
												};
											};
										};
										default: {
											varOrigin = reflaxe.elixir.ast.VarOrigin.UserDefined;
										}
									};
								};
							};
							var varName = v.name;
							var idKey = Std.string(v.id);
							var isUnused = false;
							var baseName = if ({
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
								cast this.exists(idKey);
							}) {
								{
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
									cast this.get(idKey);
								};
							} else {
								var isUsed = if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap != null) {
									{
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
										var key = v.id;
										cast this.exists(key);
									} && {
										var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.variableUsageMap;
										var key = v.id;
										cast this.get(key);
									};
								} else {
									true;
								};
								if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
									reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(varName, false);
								} else {
									reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(varName, false);
								};
							};
							var finalVarName = baseName;
							var matchNode = if (init != null) {
								var initValue = @:ast(switch (init.expr) {
	case TBlock([{ expr : TVar(tmpVar, tmpInit) }, { expr : TBinop(OpNullCoal, { expr : TLocal(localVar) }, defaultExpr) }]) if (localVar.id == tmpVar.id && tmpInit != null):
		var tmpVarName = VariableAnalyzer.toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
		var initAst = buildFromTypedExpr(tmpInit, currentContext);
		var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
		var ifExpr = makeAST(EIf(makeAST(EBinary(NotEqual, makeAST(EMatch(PVar(tmpVarName), initAst)), makeAST(ENil))), makeAST(EVar(tmpVarName)), defaultAst));
		if (ifExpr.metadata == null) ifExpr.metadata = { };
		ifExpr.metadata.keepInlineInAssignment = true;
		ifExpr;	
	case _:
		var initExpr = switch (init.expr) {
			case TBlock(stmts) if (stmts.length > 2):
				var isUnrolled = false;
				var tempVarName = "";
				var values = [];
				if (stmts.length > 0) {
					switch (stmts[0].expr) {
						case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
							switch (initExpr.expr) {
								case TArrayDecl([]):
									isUnrolled = true;
									tempVarName = v.name;								
								default:
							};						
						default:
					};
				};
				if (isUnrolled && stmts.length > 1) {
					var concatStatements = [];
					switch (stmts[1].expr) {
						case TBlock(innerStmts):
							concatStatements = innerStmts;						
						default:
							concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];						
					};
					for (stmt  in  concatStatements) {
						switch (stmt.expr) {
							case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
								values.push(elem);							
							case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
								values.push(arg);							
							default:
						};
					};
					if (values.length == 0) {
						isUnrolled = false;
					};
				};
				if (isUnrolled && stmts.length > 0) {
					switch (stmts[stmts.length - 1].expr) {
						case TLocal(v) if (v.name == tempVarName):
						default:
							isUnrolled = false;						
					};
				};
				if (isUnrolled && values.length > 0) {
					var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
					makeAST(EList(valueASTs));
				} else {
					buildFromTypedExpr(init, currentContext);
				};			
			case TSwitch(_, _, _):
				var switchAST = buildFromTypedExpr(init, currentContext);
				switchAST;			
			default:
				buildFromTypedExpr(init, currentContext);			
		};
		initExpr;	
}) {
									var ` = init.expr;
									if (enumIndex ` == 14) {
										var ` = `[0];
										if (`.length == 2) {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 13) {
													var ` = `[0];
													var ` = `[1];
													{
														var ` = `.expr;
														var ` = `.pos;
														var ` = `.t;
														if (enumIndex ` == 3) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 24) {
																{
																	var ` = `.expr;
																	var ` = `.pos;
																	var ` = `.t;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var localVar = `;
																			var defaultExpr = `;
																			var tmpInit = `;
																			var tmpVar = `;
																			if (localVar.id == tmpVar.id && tmpInit != null) {
																				var tmpVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(if (tmpVar.name.charAt(0) == "_") {
																					tmpVar.name.substr(1, null);
																				} else {
																					tmpVar.name;
																				}, null);
																				var initAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(tmpInit, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var defaultAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(defaultExpr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				var ifExpr = {
																					var pos = null;
																					{def : reflaxe.elixir.ast.ElixirASTDef.EIf({
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.NotEqual, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(tmpVarName), initAst), metadata : {}, pos : pos};
																						}, {
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
																						}), metadata : {}, pos : pos};
																					}, {
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(tmpVarName), metadata : {}, pos : pos};
																					}, defaultAst), metadata : {}, pos : pos};
																				};
																				if (ifExpr.metadata == null) {
																					ifExpr.metadata = {};
																				};
																				ifExpr.metadata.keepInlineInAssignment = true;
																				ifExpr;
																			} else {
																				var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																					var ` = init.expr;
																					switch (enumIndex `) {
																						case 14: {
																							var ` = `[0];
																							{
																								var stmts = `;
																								if (stmts.length > 2) {
																									var isUnrolled = false;
																									var tempVarName = "";
																									var values = [];
																									if (stmts.length > 0) {
																										@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																											var ` = stmts[0].expr;
																											if (enumIndex ` == 13) {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var v = `;
																													var initExpr = `;
																													if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																														@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																															var ` = initExpr.expr;
																															if (enumIndex ` == 8) {
																																var ` = `[0];
																																if (`.length == 0) {
																																	{
																																		isUnrolled = true;
																																		tempVarName = v.name;
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									if (isUnrolled && stmts.length > 1) {
																										var concatStatements = [];
																										@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																											var ` = stmts[1].expr;
																											if (enumIndex ` == 14) {
																												var ` = `[0];
																												{
																													var innerStmts = `;
																													{
																														concatStatements = innerStmts;
																													};
																												};
																											} else {
																												concatStatements = {
																													var ` = [];
																													{
																														var ` = 1;
																														var ` = stmts.length - 1;
																														while (` < `) {
																															var i = ` ++;
																															`.push(stmts[i]);
																														};
																													};
																													`;
																												};
																											};
																										};
																										{
																											var ` = 0;
																											while (` < concatStatements.length) {
																												var stmt = concatStatements[`];
																												++ `;
																												@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																													var ` = stmt.expr;
																													switch (enumIndex `) {
																														case 3: {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (enumIndex ` == 4) {
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 1) {
																																		var ` = `[0];
																																		{
																																			var ` = `.expr;
																																			var ` = `.pos;
																																			var ` = `.t;
																																			if (enumIndex ` == 3) {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				if (enumIndex ` == 0) {
																																					{
																																						var ` = `.expr;
																																						var ` = `.pos;
																																						var ` = `.t;
																																						if (enumIndex ` == 1) {
																																							var ` = `[0];
																																							{
																																								var ` = `.expr;
																																								var ` = `.pos;
																																								var ` = `.t;
																																								if (enumIndex ` == 8) {
																																									var ` = `[0];
																																									if (`.length == 1) {
																																										var ` = `[0];
																																										{
																																											var elem = `;
																																											var v2 = `;
																																											var v = `;
																																											if (v.name == tempVarName && v2.name == tempVarName) {
																																												values.push(elem);
																																											} else {};
																																										};
																																									} else {};
																																								} else {};
																																							};
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		};
																																	} else {};
																																};
																															} else {};
																														};
																														case 9: {
																															var ` = `[0];
																															var ` = `[1];
																															{
																																var ` = `.expr;
																																var ` = `.pos;
																																var ` = `.t;
																																if (enumIndex ` == 4) {
																																	var ` = `[0];
																																	var ` = `[1];
																																	{
																																		var ` = `.expr;
																																		var ` = `.pos;
																																		var ` = `.t;
																																		if (enumIndex ` == 1) {
																																			var ` = `[0];
																																			if (enumIndex ` == 0) {
																																				var ` = `[0];
																																				var ` = `[1];
																																				var ` = `[2];
																																				if (`.length == 1) {
																																					var ` = `[0];
																																					{
																																						var arg = `;
																																						var v = `;
																																						var cf = `;
																																						if (v.name == tempVarName && cf.get().name == "push") {
																																							values.push(arg);
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		} else {};
																																	};
																																} else {};
																															};
																														};
																														default: {}
																													};
																												};
																											};
																										};
																										if (values.length == 0) {
																											isUnrolled = false;
																										};
																									};
																									if (isUnrolled && stmts.length > 0) {
																										@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																											var ` = stmts[stmts.length - 1].expr;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												{
																													var v = `;
																													if (v.name == tempVarName) {} else {
																														isUnrolled = false;
																													};
																												};
																											} else {
																												isUnrolled = false;
																											};
																										};
																									};
																									if (isUnrolled && values.length > 0) {
																										var valueASTs = {
																											var ` = [];
																											{
																												var ` = 0;
																												while (` < values.length) {
																													var v = values[`];
																													++ `;
																													`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																												};
																											};
																											`;
																										};
																										{
																											var pos = null;
																											{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																										};
																									} else {
																										reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																									};
																								} else {
																									reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																								};
																							};
																						};
																						case 18: {
																							var ` = `[0];
																							var ` = `[1];
																							var ` = `[2];
																							{
																								var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																								switchAST;
																							};
																						};
																						default: {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						}
																					};
																				};
																				initExpr;
																			};
																		};
																	} else {
																		var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																			var ` = init.expr;
																			switch (enumIndex `) {
																				case 14: {
																					var ` = `[0];
																					{
																						var stmts = `;
																						if (stmts.length > 2) {
																							var isUnrolled = false;
																							var tempVarName = "";
																							var values = [];
																							if (stmts.length > 0) {
																								@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																									var ` = stmts[0].expr;
																									if (enumIndex ` == 13) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var v = `;
																											var initExpr = `;
																											if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																												@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																													var ` = initExpr.expr;
																													if (enumIndex ` == 8) {
																														var ` = `[0];
																														if (`.length == 0) {
																															{
																																isUnrolled = true;
																																tempVarName = v.name;
																															};
																														} else {};
																													} else {};
																												};
																											} else {};
																										};
																									} else {};
																								};
																							};
																							if (isUnrolled && stmts.length > 1) {
																								var concatStatements = [];
																								@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																									var ` = stmts[1].expr;
																									if (enumIndex ` == 14) {
																										var ` = `[0];
																										{
																											var innerStmts = `;
																											{
																												concatStatements = innerStmts;
																											};
																										};
																									} else {
																										concatStatements = {
																											var ` = [];
																											{
																												var ` = 1;
																												var ` = stmts.length - 1;
																												while (` < `) {
																													var i = ` ++;
																													`.push(stmts[i]);
																												};
																											};
																											`;
																										};
																									};
																								};
																								{
																									var ` = 0;
																									while (` < concatStatements.length) {
																										var stmt = concatStatements[`];
																										++ `;
																										@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																											var ` = stmt.expr;
																											switch (enumIndex `) {
																												case 3: {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 4) {
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 3) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		var ` = `[2];
																																		if (enumIndex ` == 0) {
																																			{
																																				var ` = `.expr;
																																				var ` = `.pos;
																																				var ` = `.t;
																																				if (enumIndex ` == 1) {
																																					var ` = `[0];
																																					{
																																						var ` = `.expr;
																																						var ` = `.pos;
																																						var ` = `.t;
																																						if (enumIndex ` == 8) {
																																							var ` = `[0];
																																							if (`.length == 1) {
																																								var ` = `[0];
																																								{
																																									var elem = `;
																																									var v2 = `;
																																									var v = `;
																																									if (v.name == tempVarName && v2.name == tempVarName) {
																																										values.push(elem);
																																									} else {};
																																								};
																																							} else {};
																																						} else {};
																																					};
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															} else {};
																														};
																													} else {};
																												};
																												case 9: {
																													var ` = `[0];
																													var ` = `[1];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 4) {
																															var ` = `[0];
																															var ` = `[1];
																															{
																																var ` = `.expr;
																																var ` = `.pos;
																																var ` = `.t;
																																if (enumIndex ` == 1) {
																																	var ` = `[0];
																																	if (enumIndex ` == 0) {
																																		var ` = `[0];
																																		var ` = `[1];
																																		var ` = `[2];
																																		if (`.length == 1) {
																																			var ` = `[0];
																																			{
																																				var arg = `;
																																				var v = `;
																																				var cf = `;
																																				if (v.name == tempVarName && cf.get().name == "push") {
																																					values.push(arg);
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																} else {};
																															};
																														} else {};
																													};
																												};
																												default: {}
																											};
																										};
																									};
																								};
																								if (values.length == 0) {
																									isUnrolled = false;
																								};
																							};
																							if (isUnrolled && stmts.length > 0) {
																								@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																									var ` = stmts[stmts.length - 1].expr;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										{
																											var v = `;
																											if (v.name == tempVarName) {} else {
																												isUnrolled = false;
																											};
																										};
																									} else {
																										isUnrolled = false;
																									};
																								};
																							};
																							if (isUnrolled && values.length > 0) {
																								var valueASTs = {
																									var ` = [];
																									{
																										var ` = 0;
																										while (` < values.length) {
																											var v = values[`];
																											++ `;
																											`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																										};
																									};
																									`;
																								};
																								{
																									var pos = null;
																									{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																								};
																							} else {
																								reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																							};
																						} else {
																							reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						};
																					};
																				};
																				case 18: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					{
																						var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																						switchAST;
																					};
																				};
																				default: {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				}
																			};
																		};
																		initExpr;
																	};
																};
															} else {
																var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																	var ` = init.expr;
																	switch (enumIndex `) {
																		case 14: {
																			var ` = `[0];
																			{
																				var stmts = `;
																				if (stmts.length > 2) {
																					var isUnrolled = false;
																					var tempVarName = "";
																					var values = [];
																					if (stmts.length > 0) {
																						@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																							var ` = stmts[0].expr;
																							if (enumIndex ` == 13) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var v = `;
																									var initExpr = `;
																									if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																										@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																											var ` = initExpr.expr;
																											if (enumIndex ` == 8) {
																												var ` = `[0];
																												if (`.length == 0) {
																													{
																														isUnrolled = true;
																														tempVarName = v.name;
																													};
																												} else {};
																											} else {};
																										};
																									} else {};
																								};
																							} else {};
																						};
																					};
																					if (isUnrolled && stmts.length > 1) {
																						var concatStatements = [];
																						@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																							var ` = stmts[1].expr;
																							if (enumIndex ` == 14) {
																								var ` = `[0];
																								{
																									var innerStmts = `;
																									{
																										concatStatements = innerStmts;
																									};
																								};
																							} else {
																								concatStatements = {
																									var ` = [];
																									{
																										var ` = 1;
																										var ` = stmts.length - 1;
																										while (` < `) {
																											var i = ` ++;
																											`.push(stmts[i]);
																										};
																									};
																									`;
																								};
																							};
																						};
																						{
																							var ` = 0;
																							while (` < concatStatements.length) {
																								var stmt = concatStatements[`];
																								++ `;
																								@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																									var ` = stmt.expr;
																									switch (enumIndex `) {
																										case 3: {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (enumIndex ` == 4) {
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 3) {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (enumIndex ` == 0) {
																																	{
																																		var ` = `.expr;
																																		var ` = `.pos;
																																		var ` = `.t;
																																		if (enumIndex ` == 1) {
																																			var ` = `[0];
																																			{
																																				var ` = `.expr;
																																				var ` = `.pos;
																																				var ` = `.t;
																																				if (enumIndex ` == 8) {
																																					var ` = `[0];
																																					if (`.length == 1) {
																																						var ` = `[0];
																																						{
																																							var elem = `;
																																							var v2 = `;
																																							var v = `;
																																							if (v.name == tempVarName && v2.name == tempVarName) {
																																								values.push(elem);
																																							} else {};
																																						};
																																					} else {};
																																				} else {};
																																			};
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										};
																										case 9: {
																											var ` = `[0];
																											var ` = `[1];
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 4) {
																													var ` = `[0];
																													var ` = `[1];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 1) {
																															var ` = `[0];
																															if (enumIndex ` == 0) {
																																var ` = `[0];
																																var ` = `[1];
																																var ` = `[2];
																																if (`.length == 1) {
																																	var ` = `[0];
																																	{
																																		var arg = `;
																																		var v = `;
																																		var cf = `;
																																		if (v.name == tempVarName && cf.get().name == "push") {
																																			values.push(arg);
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										};
																										default: {}
																									};
																								};
																							};
																						};
																						if (values.length == 0) {
																							isUnrolled = false;
																						};
																					};
																					if (isUnrolled && stmts.length > 0) {
																						@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																							var ` = stmts[stmts.length - 1].expr;
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								{
																									var v = `;
																									if (v.name == tempVarName) {} else {
																										isUnrolled = false;
																									};
																								};
																							} else {
																								isUnrolled = false;
																							};
																						};
																					};
																					if (isUnrolled && values.length > 0) {
																						var valueASTs = {
																							var ` = [];
																							{
																								var ` = 0;
																								while (` < values.length) {
																									var v = values[`];
																									++ `;
																									`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																								};
																							};
																							`;
																						};
																						{
																							var pos = null;
																							{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																						};
																					} else {
																						reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			};
																		};
																		case 18: {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			{
																				var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				switchAST;
																			};
																		};
																		default: {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		}
																	};
																};
																initExpr;
															};
														} else {
															var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 14: {
																		var ` = `[0];
																		{
																			var stmts = `;
																			if (stmts.length > 2) {
																				var isUnrolled = false;
																				var tempVarName = "";
																				var values = [];
																				if (stmts.length > 0) {
																					@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																						var ` = stmts[0].expr;
																						if (enumIndex ` == 13) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var v = `;
																								var initExpr = `;
																								if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																									@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																										var ` = initExpr.expr;
																										if (enumIndex ` == 8) {
																											var ` = `[0];
																											if (`.length == 0) {
																												{
																													isUnrolled = true;
																													tempVarName = v.name;
																												};
																											} else {};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																				};
																				if (isUnrolled && stmts.length > 1) {
																					var concatStatements = [];
																					@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																						var ` = stmts[1].expr;
																						if (enumIndex ` == 14) {
																							var ` = `[0];
																							{
																								var innerStmts = `;
																								{
																									concatStatements = innerStmts;
																								};
																							};
																						} else {
																							concatStatements = {
																								var ` = [];
																								{
																									var ` = 1;
																									var ` = stmts.length - 1;
																									while (` < `) {
																										var i = ` ++;
																										`.push(stmts[i]);
																									};
																								};
																								`;
																							};
																						};
																					};
																					{
																						var ` = 0;
																						while (` < concatStatements.length) {
																							var stmt = concatStatements[`];
																							++ `;
																							@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																								var ` = stmt.expr;
																								switch (enumIndex `) {
																									case 3: {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (enumIndex ` == 4) {
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 3) {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (enumIndex ` == 0) {
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 1) {
																																		var ` = `[0];
																																		{
																																			var ` = `.expr;
																																			var ` = `.pos;
																																			var ` = `.t;
																																			if (enumIndex ` == 8) {
																																				var ` = `[0];
																																				if (`.length == 1) {
																																					var ` = `[0];
																																					{
																																						var elem = `;
																																						var v2 = `;
																																						var v = `;
																																						if (v.name == tempVarName && v2.name == tempVarName) {
																																							values.push(elem);
																																						} else {};
																																					};
																																				} else {};
																																			} else {};
																																		};
																																	} else {};
																																};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										} else {};
																									};
																									case 9: {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 4) {
																												var ` = `[0];
																												var ` = `[1];
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														if (enumIndex ` == 0) {
																															var ` = `[0];
																															var ` = `[1];
																															var ` = `[2];
																															if (`.length == 1) {
																																var ` = `[0];
																																{
																																	var arg = `;
																																	var v = `;
																																	var cf = `;
																																	if (v.name == tempVarName && cf.get().name == "push") {
																																		values.push(arg);
																																	} else {};
																																};
																															} else {};
																														} else {};
																													} else {};
																												};
																											} else {};
																										};
																									};
																									default: {}
																								};
																							};
																						};
																					};
																					if (values.length == 0) {
																						isUnrolled = false;
																					};
																				};
																				if (isUnrolled && stmts.length > 0) {
																					@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																						var ` = stmts[stmts.length - 1].expr;
																						if (enumIndex ` == 1) {
																							var ` = `[0];
																							{
																								var v = `;
																								if (v.name == tempVarName) {} else {
																									isUnrolled = false;
																								};
																							};
																						} else {
																							isUnrolled = false;
																						};
																					};
																				};
																				if (isUnrolled && values.length > 0) {
																					var valueASTs = {
																						var ` = [];
																						{
																							var ` = 0;
																							while (` < values.length) {
																								var v = values[`];
																								++ `;
																								`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																							};
																						};
																						`;
																					};
																					{
																						var pos = null;
																						{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																					};
																				} else {
																					reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																				};
																			} else {
																				reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			};
																		};
																	};
																	case 18: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																			switchAST;
																		};
																	};
																	default: {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	}
																};
															};
															initExpr;
														};
													};
												} else {
													var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
														var ` = init.expr;
														switch (enumIndex `) {
															case 14: {
																var ` = `[0];
																{
																	var stmts = `;
																	if (stmts.length > 2) {
																		var isUnrolled = false;
																		var tempVarName = "";
																		var values = [];
																		if (stmts.length > 0) {
																			@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																				var ` = stmts[0].expr;
																				if (enumIndex ` == 13) {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var v = `;
																						var initExpr = `;
																						if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																							@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																								var ` = initExpr.expr;
																								if (enumIndex ` == 8) {
																									var ` = `[0];
																									if (`.length == 0) {
																										{
																											isUnrolled = true;
																											tempVarName = v.name;
																										};
																									} else {};
																								} else {};
																							};
																						} else {};
																					};
																				} else {};
																			};
																		};
																		if (isUnrolled && stmts.length > 1) {
																			var concatStatements = [];
																			@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																				var ` = stmts[1].expr;
																				if (enumIndex ` == 14) {
																					var ` = `[0];
																					{
																						var innerStmts = `;
																						{
																							concatStatements = innerStmts;
																						};
																					};
																				} else {
																					concatStatements = {
																						var ` = [];
																						{
																							var ` = 1;
																							var ` = stmts.length - 1;
																							while (` < `) {
																								var i = ` ++;
																								`.push(stmts[i]);
																							};
																						};
																						`;
																					};
																				};
																			};
																			{
																				var ` = 0;
																				while (` < concatStatements.length) {
																					var stmt = concatStatements[`];
																					++ `;
																					@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																						var ` = stmt.expr;
																						switch (enumIndex `) {
																							case 3: {
																								var ` = `[0];
																								var ` = `[1];
																								var ` = `[2];
																								if (enumIndex ` == 4) {
																									{
																										var ` = `.expr;
																										var ` = `.pos;
																										var ` = `.t;
																										if (enumIndex ` == 1) {
																											var ` = `[0];
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 3) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (enumIndex ` == 0) {
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 1) {
																																var ` = `[0];
																																{
																																	var ` = `.expr;
																																	var ` = `.pos;
																																	var ` = `.t;
																																	if (enumIndex ` == 8) {
																																		var ` = `[0];
																																		if (`.length == 1) {
																																			var ` = `[0];
																																			{
																																				var elem = `;
																																				var v2 = `;
																																				var v = `;
																																				if (v.name == tempVarName && v2.name == tempVarName) {
																																					values.push(elem);
																																				} else {};
																																			};
																																		} else {};
																																	} else {};
																																};
																															} else {};
																														};
																													} else {};
																												} else {};
																											};
																										} else {};
																									};
																								} else {};
																							};
																							case 9: {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 4) {
																										var ` = `[0];
																										var ` = `[1];
																										{
																											var ` = `.expr;
																											var ` = `.pos;
																											var ` = `.t;
																											if (enumIndex ` == 1) {
																												var ` = `[0];
																												if (enumIndex ` == 0) {
																													var ` = `[0];
																													var ` = `[1];
																													var ` = `[2];
																													if (`.length == 1) {
																														var ` = `[0];
																														{
																															var arg = `;
																															var v = `;
																															var cf = `;
																															if (v.name == tempVarName && cf.get().name == "push") {
																																values.push(arg);
																															} else {};
																														};
																													} else {};
																												} else {};
																											} else {};
																										};
																									} else {};
																								};
																							};
																							default: {}
																						};
																					};
																				};
																			};
																			if (values.length == 0) {
																				isUnrolled = false;
																			};
																		};
																		if (isUnrolled && stmts.length > 0) {
																			@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																				var ` = stmts[stmts.length - 1].expr;
																				if (enumIndex ` == 1) {
																					var ` = `[0];
																					{
																						var v = `;
																						if (v.name == tempVarName) {} else {
																							isUnrolled = false;
																						};
																					};
																				} else {
																					isUnrolled = false;
																				};
																			};
																		};
																		if (isUnrolled && values.length > 0) {
																			var valueASTs = {
																				var ` = [];
																				{
																					var ` = 0;
																					while (` < values.length) {
																						var v = values[`];
																						++ `;
																						`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																					};
																				};
																				`;
																			};
																			{
																				var pos = null;
																				{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																			};
																		} else {
																			reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																		};
																	} else {
																		reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	};
																};
															};
															case 18: {
																var ` = `[0];
																var ` = `[1];
																var ` = `[2];
																{
																	var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																	switchAST;
																};
															};
															default: {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															}
														};
													};
													initExpr;
												};
											};
										} else {
											var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
												var ` = init.expr;
												switch (enumIndex `) {
													case 14: {
														var ` = `[0];
														{
															var stmts = `;
															if (stmts.length > 2) {
																var isUnrolled = false;
																var tempVarName = "";
																var values = [];
																if (stmts.length > 0) {
																	@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																		var ` = stmts[0].expr;
																		if (enumIndex ` == 13) {
																			var ` = `[0];
																			var ` = `[1];
																			{
																				var v = `;
																				var initExpr = `;
																				if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																					@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																						var ` = initExpr.expr;
																						if (enumIndex ` == 8) {
																							var ` = `[0];
																							if (`.length == 0) {
																								{
																									isUnrolled = true;
																									tempVarName = v.name;
																								};
																							} else {};
																						} else {};
																					};
																				} else {};
																			};
																		} else {};
																	};
																};
																if (isUnrolled && stmts.length > 1) {
																	var concatStatements = [];
																	@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																		var ` = stmts[1].expr;
																		if (enumIndex ` == 14) {
																			var ` = `[0];
																			{
																				var innerStmts = `;
																				{
																					concatStatements = innerStmts;
																				};
																			};
																		} else {
																			concatStatements = {
																				var ` = [];
																				{
																					var ` = 1;
																					var ` = stmts.length - 1;
																					while (` < `) {
																						var i = ` ++;
																						`.push(stmts[i]);
																					};
																				};
																				`;
																			};
																		};
																	};
																	{
																		var ` = 0;
																		while (` < concatStatements.length) {
																			var stmt = concatStatements[`];
																			++ `;
																			@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																				var ` = stmt.expr;
																				switch (enumIndex `) {
																					case 3: {
																						var ` = `[0];
																						var ` = `[1];
																						var ` = `[2];
																						if (enumIndex ` == 4) {
																							{
																								var ` = `.expr;
																								var ` = `.pos;
																								var ` = `.t;
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									{
																										var ` = `.expr;
																										var ` = `.pos;
																										var ` = `.t;
																										if (enumIndex ` == 3) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (enumIndex ` == 0) {
																												{
																													var ` = `.expr;
																													var ` = `.pos;
																													var ` = `.t;
																													if (enumIndex ` == 1) {
																														var ` = `[0];
																														{
																															var ` = `.expr;
																															var ` = `.pos;
																															var ` = `.t;
																															if (enumIndex ` == 8) {
																																var ` = `[0];
																																if (`.length == 1) {
																																	var ` = `[0];
																																	{
																																		var elem = `;
																																		var v2 = `;
																																		var v = `;
																																		if (v.name == tempVarName && v2.name == tempVarName) {
																																			values.push(elem);
																																		} else {};
																																	};
																																} else {};
																															} else {};
																														};
																													} else {};
																												};
																											} else {};
																										} else {};
																									};
																								} else {};
																							};
																						} else {};
																					};
																					case 9: {
																						var ` = `[0];
																						var ` = `[1];
																						{
																							var ` = `.expr;
																							var ` = `.pos;
																							var ` = `.t;
																							if (enumIndex ` == 4) {
																								var ` = `[0];
																								var ` = `[1];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 1) {
																										var ` = `[0];
																										if (enumIndex ` == 0) {
																											var ` = `[0];
																											var ` = `[1];
																											var ` = `[2];
																											if (`.length == 1) {
																												var ` = `[0];
																												{
																													var arg = `;
																													var v = `;
																													var cf = `;
																													if (v.name == tempVarName && cf.get().name == "push") {
																														values.push(arg);
																													} else {};
																												};
																											} else {};
																										} else {};
																									} else {};
																								};
																							} else {};
																						};
																					};
																					default: {}
																				};
																			};
																		};
																	};
																	if (values.length == 0) {
																		isUnrolled = false;
																	};
																};
																if (isUnrolled && stmts.length > 0) {
																	@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																		var ` = stmts[stmts.length - 1].expr;
																		if (enumIndex ` == 1) {
																			var ` = `[0];
																			{
																				var v = `;
																				if (v.name == tempVarName) {} else {
																					isUnrolled = false;
																				};
																			};
																		} else {
																			isUnrolled = false;
																		};
																	};
																};
																if (isUnrolled && values.length > 0) {
																	var valueASTs = {
																		var ` = [];
																		{
																			var ` = 0;
																			while (` < values.length) {
																				var v = values[`];
																				++ `;
																				`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																			};
																		};
																		`;
																	};
																	{
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																	};
																} else {
																	reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														};
													};
													case 18: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															switchAST;
														};
													};
													default: {
														reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
													}
												};
											};
											initExpr;
										};
									} else {
										var initExpr = @:ast(switch (init.expr) {
	case TBlock(stmts) if (stmts.length > 2):
		var isUnrolled = false;
		var tempVarName = "";
		var values = [];
		if (stmts.length > 0) {
			switch (stmts[0].expr) {
				case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
					switch (initExpr.expr) {
						case TArrayDecl([]):
							isUnrolled = true;
							tempVarName = v.name;						
						default:
					};				
				default:
			};
		};
		if (isUnrolled && stmts.length > 1) {
			var concatStatements = [];
			switch (stmts[1].expr) {
				case TBlock(innerStmts):
					concatStatements = innerStmts;				
				default:
					concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];				
			};
			for (stmt  in  concatStatements) {
				switch (stmt.expr) {
					case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
						values.push(elem);					
					case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
						values.push(arg);					
					default:
				};
			};
			if (values.length == 0) {
				isUnrolled = false;
			};
		};
		if (isUnrolled && stmts.length > 0) {
			switch (stmts[stmts.length - 1].expr) {
				case TLocal(v) if (v.name == tempVarName):
				default:
					isUnrolled = false;				
			};
		};
		if (isUnrolled && values.length > 0) {
			var valueASTs = [for (v  in  values) buildFromTypedExpr(v, currentContext)];
			makeAST(EList(valueASTs));
		} else {
			buildFromTypedExpr(init, currentContext);
		};	
	case TSwitch(_, _, _):
		var switchAST = buildFromTypedExpr(init, currentContext);
		switchAST;	
	default:
		buildFromTypedExpr(init, currentContext);	
}) {
											var ` = init.expr;
											switch (enumIndex `) {
												case 14: {
													var ` = `[0];
													{
														var stmts = `;
														if (stmts.length > 2) {
															var isUnrolled = false;
															var tempVarName = "";
															var values = [];
															if (stmts.length > 0) {
																@:ast(switch (stmts[0].expr) {
	case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
		switch (initExpr.expr) {
			case TArrayDecl([]):
				isUnrolled = true;
				tempVarName = v.name;			
			default:
		};	
	default:
}) {
																	var ` = stmts[0].expr;
																	if (enumIndex ` == 13) {
																		var ` = `[0];
																		var ` = `[1];
																		{
																			var v = `;
																			var initExpr = `;
																			if (initExpr != null && (StringTools.startsWith(v.name, "g") || StringTools.startsWith(v.name, "_g"))) {
																				@:ast(switch (initExpr.expr) {
	case TArrayDecl([]):
		isUnrolled = true;
		tempVarName = v.name;	
	default:
}) {
																					var ` = initExpr.expr;
																					if (enumIndex ` == 8) {
																						var ` = `[0];
																						if (`.length == 0) {
																							{
																								isUnrolled = true;
																								tempVarName = v.name;
																							};
																						} else {};
																					} else {};
																				};
																			} else {};
																		};
																	} else {};
																};
															};
															if (isUnrolled && stmts.length > 1) {
																var concatStatements = [];
																@:ast(switch (stmts[1].expr) {
	case TBlock(innerStmts):
		concatStatements = innerStmts;	
	default:
		concatStatements = [for (i  in  1 ... stmts.length - 1) stmts[i]];	
}) {
																	var ` = stmts[1].expr;
																	if (enumIndex ` == 14) {
																		var ` = `[0];
																		{
																			var innerStmts = `;
																			{
																				concatStatements = innerStmts;
																			};
																		};
																	} else {
																		concatStatements = {
																			var ` = [];
																			{
																				var ` = 1;
																				var ` = stmts.length - 1;
																				while (` < `) {
																					var i = ` ++;
																					`.push(stmts[i]);
																				};
																			};
																			`;
																		};
																	};
																};
																{
																	var ` = 0;
																	while (` < concatStatements.length) {
																		var stmt = concatStatements[`];
																		++ `;
																		@:ast(switch (stmt.expr) {
	case TBinop(OpAssign, { expr : TLocal(v) }, { expr : TBinop(OpAdd, { expr : TLocal(v2) }, { expr : TArrayDecl([elem]) }) }) if (v.name == tempVarName && v2.name == tempVarName):
		values.push(elem);	
	case TCall({ expr : TField({ expr : TLocal(v) }, FInstance(_, _, cf)) }, [arg]) if (v.name == tempVarName && cf.get().name == "push"):
		values.push(arg);	
	default:
}) {
																			var ` = stmt.expr;
																			switch (enumIndex `) {
																				case 3: {
																					var ` = `[0];
																					var ` = `[1];
																					var ` = `[2];
																					if (enumIndex ` == 4) {
																						{
																							var ` = `.expr;
																							var ` = `.pos;
																							var ` = `.t;
																							if (enumIndex ` == 1) {
																								var ` = `[0];
																								{
																									var ` = `.expr;
																									var ` = `.pos;
																									var ` = `.t;
																									if (enumIndex ` == 3) {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (enumIndex ` == 0) {
																											{
																												var ` = `.expr;
																												var ` = `.pos;
																												var ` = `.t;
																												if (enumIndex ` == 1) {
																													var ` = `[0];
																													{
																														var ` = `.expr;
																														var ` = `.pos;
																														var ` = `.t;
																														if (enumIndex ` == 8) {
																															var ` = `[0];
																															if (`.length == 1) {
																																var ` = `[0];
																																{
																																	var elem = `;
																																	var v2 = `;
																																	var v = `;
																																	if (v.name == tempVarName && v2.name == tempVarName) {
																																		values.push(elem);
																																	} else {};
																																};
																															} else {};
																														} else {};
																													};
																												} else {};
																											};
																										} else {};
																									} else {};
																								};
																							} else {};
																						};
																					} else {};
																				};
																				case 9: {
																					var ` = `[0];
																					var ` = `[1];
																					{
																						var ` = `.expr;
																						var ` = `.pos;
																						var ` = `.t;
																						if (enumIndex ` == 4) {
																							var ` = `[0];
																							var ` = `[1];
																							{
																								var ` = `.expr;
																								var ` = `.pos;
																								var ` = `.t;
																								if (enumIndex ` == 1) {
																									var ` = `[0];
																									if (enumIndex ` == 0) {
																										var ` = `[0];
																										var ` = `[1];
																										var ` = `[2];
																										if (`.length == 1) {
																											var ` = `[0];
																											{
																												var arg = `;
																												var v = `;
																												var cf = `;
																												if (v.name == tempVarName && cf.get().name == "push") {
																													values.push(arg);
																												} else {};
																											};
																										} else {};
																									} else {};
																								} else {};
																							};
																						} else {};
																					};
																				};
																				default: {}
																			};
																		};
																	};
																};
																if (values.length == 0) {
																	isUnrolled = false;
																};
															};
															if (isUnrolled && stmts.length > 0) {
																@:ast(switch (stmts[stmts.length - 1].expr) {
	case TLocal(v) if (v.name == tempVarName):
	default:
		isUnrolled = false;	
}) {
																	var ` = stmts[stmts.length - 1].expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var v = `;
																			if (v.name == tempVarName) {} else {
																				isUnrolled = false;
																			};
																		};
																	} else {
																		isUnrolled = false;
																	};
																};
															};
															if (isUnrolled && values.length > 0) {
																var valueASTs = {
																	var ` = [];
																	{
																		var ` = 0;
																		while (` < values.length) {
																			var v = values[`];
																			++ `;
																			`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(v, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
																		};
																	};
																	`;
																};
																{
																	var pos = null;
																	{def : reflaxe.elixir.ast.ElixirASTDef.EList(valueASTs), metadata : {}, pos : pos};
																};
															} else {
																reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
															};
														} else {
															reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														};
													};
												};
												case 18: {
													var ` = `[0];
													var ` = `[1];
													var ` = `[2];
													{
														var switchAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
														switchAST;
													};
												};
												default: {
													reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(init, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												}
											};
										};
										initExpr;
									};
								};
								var shouldSkipAssignment = false;
								if (init != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.isVarIdSatisfiedByPattern(v.id)) {
									shouldSkipAssignment = true;
								} else {
									if (init != null) {
										@:ast(switch (init.expr) {
	case TEnumParameter(e, ef, index):
		if (currentContext.currentClauseContext != null) {
			var hasPlan = currentContext.currentClauseContext.enumBindingPlan.exists(index);
			if (hasPlan) {
				var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
				if (info.finalName == finalVarName) {
					shouldSkipAssignment = true;
				} else { };
				if (!shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
					var planIsTemp = PatternDetector.isTempPatternVarName(info.finalName);
					var lhsIsTemp = PatternDetector.isTempPatternVarName(finalVarName);
					if (lhsIsTemp && !planIsTemp) {
						shouldSkipAssignment = true;
					};
				};
			};
		};
		if (!shouldSkipAssignment && initValue != null) {
			switch (initValue.def) {
				case EVar(varName):
					if (varName == finalVarName) {
						shouldSkipAssignment = true;
					};				
				case _:
			};
		} else if (!shouldSkipAssignment) {
			shouldSkipAssignment = true;
		};	
	default:
}) {
											var ` = init.expr;
											if (enumIndex ` == 26) {
												var ` = `[0];
												var ` = `[1];
												var ` = `[2];
												{
													var e = `;
													var ef = `;
													var index = `;
													{
														if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null) {
															var hasPlan = {
																var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
																cast this.exists(index);
															};
															if (hasPlan) {
																var info = {
																	var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
																	cast this.get(index);
																};
																if (info.finalName == finalVarName) {
																	shouldSkipAssignment = true;
																} else {};
																if (! shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
																	var planIsTemp = reflaxe.elixir.helpers.PatternDetector.isTempPatternVarName(info.finalName);
																	var lhsIsTemp = reflaxe.elixir.helpers.PatternDetector.isTempPatternVarName(finalVarName);
																	if (lhsIsTemp && ! planIsTemp) {
																		shouldSkipAssignment = true;
																	};
																};
															};
														};
														if (! shouldSkipAssignment && initValue != null) {
															@:ast(switch (initValue.def) {
	case EVar(varName):
		if (varName == finalVarName) {
			shouldSkipAssignment = true;
		};	
	case _:
}) {
																var ` = initValue.def;
																if (enumIndex ` == 38) {
																	var ` = `[0];
																	{
																		var varName = `;
																		{
																			if (varName == finalVarName) {
																				shouldSkipAssignment = true;
																			};
																		};
																	};
																} else {};
															};
														} else {
															if (! shouldSkipAssignment) {
																shouldSkipAssignment = true;
															};
														};
													};
												};
											} else {};
										};
										if (! shouldSkipAssignment && init != null) {
											@:ast(switch (init.expr) {
	case TLocal(tempVar):
		var tempVarName = tempVar.name;
		var isTempVar = false;
		if (tempVarName == "g" || tempVarName == "_g") {
			isTempVar = true;
		} else if (tempVarName.length > 1) {
			if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
				isTempVar = true;
			} else if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
				isTempVar = true;
			};
		};
		if (isTempVar) {
			var elixirTempName = VariableAnalyzer.toElixirVarName(tempVarName);
			if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
				shouldSkipAssignment = true;
			};
			if (finalVarName == tempVarName) {
				shouldSkipAssignment = true;
			};
		} else {
			if (finalVarName == tempVarName) {
				shouldSkipAssignment = true;
			};
		};	
	case _:
}) {
												var ` = init.expr;
												if (enumIndex ` == 1) {
													var ` = `[0];
													{
														var tempVar = `;
														{
															var tempVarName = tempVar.name;
															var isTempVar = false;
															if (tempVarName == "g" || tempVarName == "_g") {
																isTempVar = true;
															} else {
																if (tempVarName.length > 1) {
																	if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= "0" && tempVarName.charAt(1) <= "9") {
																		isTempVar = true;
																	} else {
																		if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" && tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= "0" && tempVarName.charAt(2) <= "9") {
																			isTempVar = true;
																		};
																	};
																};
															};
															if (isTempVar) {
																var elixirTempName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(tempVarName, null);
																if (elixirTempName == "g" || (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 && elixirTempName.charAt(1) >= "0" && elixirTempName.charAt(1) <= "9")) {
																	shouldSkipAssignment = true;
																};
																if (finalVarName == tempVarName) {
																	shouldSkipAssignment = true;
																};
															} else {
																if (finalVarName == tempVarName) {
																	shouldSkipAssignment = true;
																};
															};
														};
													};
												} else {};
											};
										};
									};
								};
								var result = if (shouldSkipAssignment) {
									null;
								} else {
									if (initValue == null) {
										var fallbackValue = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ERaw("{:error, \"[Compiler Error] Failed to build initialization for " + finalVarName + "\"}"), metadata : {}, pos : pos};
										};
										var matchNode = {
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), fallbackValue), metadata : {}, pos : pos};
										};
										if (matchNode.metadata == null) {
											matchNode.metadata = {};
										};
										matchNode.metadata.requiresTempVar = true;
										matchNode.metadata.varOrigin = varOrigin;
										matchNode.metadata.varId = v.id;
										if (extractedFromTemp != null) {};
										matchNode;
									} else {
										var shouldSkipSelfAssignment = false;
										@:ast(switch (initValue.def) {
	case EVar(varName):
		if (varName == finalVarName) {
			shouldSkipSelfAssignment = true;
		};	
	case _:
}) {
											var ` = initValue.def;
											if (enumIndex ` == 38) {
												var ` = `[0];
												{
													var varName = `;
													{
														if (varName == finalVarName) {
															shouldSkipSelfAssignment = true;
														};
													};
												};
											} else {};
										};
										if (shouldSkipSelfAssignment) {
											null;
										} else {
											var matchNode = {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), initValue), metadata : {}, pos : pos};
											};
											if (matchNode.metadata == null) {
												matchNode.metadata = {};
											};
											matchNode.metadata.varOrigin = varOrigin;
											matchNode.metadata.varId = v.id;
											if (tempToBinderMap != null) {
												matchNode.metadata.tempToBinderMap = tempToBinderMap;
											};
											matchNode;
										};
									};
								};
								result;
							} else {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
									}), metadata : {}, pos : pos};
								};
							};
							if (matchNode != null) {
								matchNode.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.EMatch(reflaxe.elixir.ast.EPattern.PVar(finalVarName), {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
								});
							};
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							var result = reflaxe.elixir.ast.builders.BlockBuilder.build(el, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] BlockBuilder returned null for TBlock - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2195, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: BlockBuilder failed to compile block");
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var v = `;
						var e1 = `;
						var e2 = `;
						{
							var buildContext = {isFeatureEnabled : function(f:String) return reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isFeatureEnabled(f), buildFromTypedExpr : function(e:haxe.macro.TypedExpr, ctx:Null<Unknown<0>> = null) return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext), whileLoopCounter : reflaxe.elixir.ast.ElixirASTBuilder.currentContext.whileLoopCounter};
							return reflaxe.elixir.ast.builders.LoopBuilder.buildFor(v, e1, e2, expr, buildContext, function(name:String) return reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(name, null));
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var eif = `;
						var eelse = `;
						{
							reflaxe.elixir.ast.builders.ControlFlowBuilder.buildIf(econd, eif, eelse, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
						};
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var econd = `;
						var e = `;
						var normalWhile = `;
						{
							var buildContext = {isFeatureEnabled : function(f:String) return reflaxe.elixir.ast.ElixirASTBuilder.currentContext.isFeatureEnabled(f), buildFromTypedExpr : function(e:haxe.macro.TypedExpr, ctx:Null<Unknown<1>> = null) return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext), whileLoopCounter : reflaxe.elixir.ast.ElixirASTBuilder.currentContext.whileLoopCounter};
							return reflaxe.elixir.ast.builders.LoopBuilder.buildWhileComplete(econd, e, normalWhile, expr, buildContext, function(name:String) return reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(name, null));
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var cases = `;
						var edef = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler == null && reflaxe.elixir.ast.ElixirASTBuilder.compiler != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.currentContext.compiler = reflaxe.elixir.ast.ElixirASTBuilder.compiler;
							};
							var result = reflaxe.elixir.ast.builders.SwitchBuilder.build(e, cases, edef, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] SwitchBuilder returned null for TSwitch - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2234, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: SwitchBuilder failed to compile switch expression");
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							var result = reflaxe.elixir.ast.builders.ExceptionBuilder.buildTry(e, catches, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] ExceptionBuilder returned null for TTry - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2246, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: ExceptionBuilder failed to compile try expression");
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var e = `;
						{
							var result = reflaxe.elixir.ast.builders.ReturnBuilder.build(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							haxe.Log.trace("[ERROR] ReturnBuilder returned null for TReturn - returning placeholder", {fileName : "../../src/reflaxe/elixir/ast/ElixirASTBuilder.hx", lineNumber : 2206, className : "reflaxe.elixir.ast.ElixirASTBuilder", methodName : "convertExpression"});
							return reflaxe.elixir.ast.ElixirASTDef.ERaw("# ERROR: ReturnBuilder failed to compile return statement");
						};
					};
				};
				case 21: {
					{
						reflaxe.elixir.ast.builders.ExceptionBuilder.buildBreak();
					};
				};
				case 22: {
					{
						reflaxe.elixir.ast.builders.ExceptionBuilder.buildContinue();
					};
				};
				case 23: {
					var ` = `[0];
					{
						var e = `;
						{
							var result = reflaxe.elixir.ast.builders.ExceptionBuilder.buildThrow(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (result != null) {
								return result;
							};
							reflaxe.elixir.ast.ElixirASTDef.EThrow(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext));
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(e);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.convertExpression(e);
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						var ef = `;
						var index = `;
						{
							var sourceVarName = null;
							@:ast(switch (e.expr) {
	case TLocal(v):
		sourceVarName = VariableAnalyzer.toElixirVarName(v.name);	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var v = `;
										{
											sourceVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
										};
									};
								} else {};
							};
							if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && {
								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
								cast this.exists(index);
							}) {
								var info = {
									var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.enumBindingPlan;
									cast this.get(index);
								};
								if (sourceVarName != null && (sourceVarName == "g" || (StringTools.startsWith(sourceVarName, "g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
									if (info.finalName != sourceVarName) {
										return reflaxe.elixir.ast.ElixirASTDef.EVar(info.finalName);
									};
								};
								if (info.finalName == sourceVarName && sourceVarName != null) {
									return null;
								} else {
									return reflaxe.elixir.ast.ElixirASTDef.EVar(info.finalName);
								};
							} else {
								if (sourceVarName != null && (sourceVarName == "g" || (StringTools.startsWith(sourceVarName, "g") && sourceVarName.length > 1 && sourceVarName.charAt(1) >= "0" && sourceVarName.charAt(1) <= "9"))) {
									return null;
								};
								var skipExtraction = false;
								var extractedVarName = null;
								if (! skipExtraction) {
									@:ast(switch (e.expr) {
	case TLocal(v):
		var varName = VariableAnalyzer.toElixirVarName(v.name);
		if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
			extractedVarName = currentContext.currentClauseContext.localToName.get(v.id);
			skipExtraction = true;
		} else {
			var isExtractionTemp = false;
			if (currentContext.tempVarRenameMap.exists(Std.string(v.id))) {
				isExtractionTemp = true;
			} else if (varName == "g" || (varName.startsWith("g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
				isExtractionTemp = false;
			};
			if (isExtractionTemp) {
				extractedVarName = varName;
				skipExtraction = true;
			};
		};	
	case _:
}) {
										var ` = e.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var v = `;
												{
													var varName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
													if (reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext != null && {
														var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
														var key = v.id;
														cast this.exists(key);
													}) {
														extractedVarName = {
															var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.currentClauseContext.localToName;
															var key = v.id;
															cast this.get(key);
														};
														skipExtraction = true;
													} else {
														var isExtractionTemp = false;
														if ({
															var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.tempVarRenameMap;
															var key = Std.string(v.id);
															cast this.exists(key);
														}) {
															isExtractionTemp = true;
														} else {
															if (varName == "g" || (StringTools.startsWith(varName, "g") && varName.length > 1 && varName.charAt(1) >= "0" && varName.charAt(1) <= "9")) {
																isExtractionTemp = false;
															};
														};
														if (isExtractionTemp) {
															extractedVarName = varName;
															skipExtraction = true;
														};
													};
												};
											};
										} else {};
									};
								};
								if (skipExtraction && extractedVarName != null) {
									reflaxe.elixir.ast.ElixirASTDef.EVar(extractedVarName);
								} else {
									var exprAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
									reflaxe.elixir.ast.ElixirASTDef.ECall(exprAST, "elem", [{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(index + 1), metadata : {}, pos : pos};
									}]);
								};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					{
						var e = `;
						{
							var enumExpr = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
							if (enumExpr != null) {
								enumExpr.def;
							} else {
								reflaxe.elixir.ast.ElixirASTDef.EVar("nil");
							};
						};
					};
				};
				case 28: {
					var ` = `[0];
					{
						var s = `;
						{
							reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(s, null));
						};
					};
				};
			};
		};
	}

	static function buildFieldPatternSwitch(rootObj:reflaxe.elixir.ast.intent.TypedExpr, fieldName:String, cases:Array<{ values : Array<reflaxe.elixir.ast.intent.TypedExpr>, expr : reflaxe.elixir.ast.intent.TypedExpr }>, edef:Null<reflaxe.elixir.ast.intent.TypedExpr>, pos:haxe.macro.Position, context:reflaxe.elixir.CompilationContext) {
		var targetAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(rootObj, context);
		if (targetAST.def == reflaxe.elixir.ast.ElixirASTDef.ENil) {};
		var objectFields = [];
		@:ast(switch (rootObj.t) {
	case TAnonymous(anonRef):
		var anon = anonRef.get();
		for (field  in  anon.fields) {
			objectFields.push(field.name);
		};	
	default:
}) {
			var ` = rootObj.t;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var anonRef = `;
					{
						var anon = anonRef.get();
						{
							var ` = 0;
							var ` = anon.fields;
							while (` < `.length) {
								var field = `[`];
								++ `;
								objectFields.push(field.name);
							};
						};
					};
				};
			} else {};
		};
		var clauses = [];
		{
			var ` = 0;
			while (` < cases.length) {
				var switchCase = cases[`];
				++ `;
				{
					var ` = 0;
					var ` = switchCase.values;
					while (` < `.length) {
						var value = `[`];
						++ `;
						var patternPairs = [];
						var fieldValue = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(value, context);
						var fieldPattern = @:ast(switch (fieldValue.def) {
	case EString(s):
		PLiteral(makeAST(EString(s)));	
	case EInteger(i):
		PLiteral(makeAST(EInteger(i)));	
	case EFloat(f):
		PLiteral(makeAST(EFloat(f)));	
	case EBoolean(b):
		PLiteral(makeAST(EBoolean(b)));	
	case EAtom(a):
		PLiteral(makeAST(EAtom(a)));	
	case ENil:
		PLiteral(makeAST(ENil));	
	default:
		PVar("_matched_value");	
}) {
							var ` = fieldValue.def;
							switch (enumIndex `) {
								case 31: {
									var ` = `[0];
									{
										var a = `;
										{
											reflaxe.elixir.ast.EPattern.PLiteral({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(a), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 32: {
									var ` = `[0];
									{
										var s = `;
										{
											reflaxe.elixir.ast.EPattern.PLiteral({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EString(s), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 33: {
									var ` = `[0];
									{
										var i = `;
										{
											reflaxe.elixir.ast.EPattern.PLiteral({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(i), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 34: {
									var ` = `[0];
									{
										var f = `;
										{
											reflaxe.elixir.ast.EPattern.PLiteral({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EFloat(f), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 35: {
									var ` = `[0];
									{
										var b = `;
										{
											reflaxe.elixir.ast.EPattern.PLiteral({
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBoolean(b), metadata : {}, pos : pos};
											});
										};
									};
								};
								case 36: {
									{
										reflaxe.elixir.ast.EPattern.PLiteral({
											var pos = null;
											{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
										});
									};
								};
								default: {
									reflaxe.elixir.ast.EPattern.PVar("_matched_value");
								}
							};
						};
						patternPairs.push({key : {
							var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
								var this;
								this = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
								cast this;
							});
							var pos = null;
							{def : def, metadata : {}, pos : pos};
						}, value : fieldPattern});
						{
							var ` = 0;
							while (` < objectFields.length) {
								var otherField = objectFields[`];
								++ `;
								if (otherField != fieldName) {
									var rootName = @:ast(switch (rootObj.expr) {
	case TLocal(v):
		v.name;	
	case TField(_, FAnon(cf)):
		cf.get().name;	
	case TField(_, FInstance(_, _, cf)):
		cf.get().name;	
	default:
		"obj";	
}) {
										var ` = rootObj.expr;
										switch (enumIndex `) {
											case 1: {
												var ` = `[0];
												{
													var v = `;
													{
														v.name;
													};
												};
											};
											case 4: {
												var ` = `[0];
												var ` = `[1];
												switch (enumIndex `) {
													case 0: {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															{
																cf.get().name;
															};
														};
													};
													case 2: {
														var ` = `[0];
														{
															var cf = `;
															{
																cf.get().name;
															};
														};
													};
													default: {
														"obj";
													}
												};
											};
											default: {
												"obj";
											}
										};
									};
									var varName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(rootName + "_" + otherField, null);
									patternPairs.push({key : {
										var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
											var this;
											this = reflaxe.elixir.ast.NameUtils.toSnakeCase(otherField);
											cast this;
										});
										var pos = null;
										{def : def, metadata : {}, pos : pos};
									}, value : reflaxe.elixir.ast.EPattern.PVar(varName)});
								};
							};
						};
						var pattern = reflaxe.elixir.ast.EPattern.PMap(patternPairs);
						var body = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(switchCase.expr, context);
						var clauseDef = {pattern : pattern, guard : null, body : body};
						clauses.push(clauseDef);
					};
				};
			};
		};
		if (edef != null) {
			var defaultBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(edef, context);
			var defaultClauseDef = {pattern : reflaxe.elixir.ast.EPattern.PWildcard, guard : null, body : defaultBody};
			clauses.push(defaultClauseDef);
		};
		return reflaxe.elixir.ast.ElixirASTDef.ECase(targetAST, clauses);
	}

	static function tryOptimizeArrayPattern(econd:reflaxe.elixir.ast.intent.TypedExpr, ebody:reflaxe.elixir.ast.intent.TypedExpr) {
		var isArrayPattern = false;
		var arrayVarName = "";
		var indexVarName = "";
		@:ast(switch (econd.expr) {
	case TBinop(OpLt, e1, e2):
		switch (e1.expr) {
			case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
				switch (e2.expr) {
					case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
						switch (arrayRef.expr) {
							case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
								isArrayPattern = true;
								indexVarName = indexVar.name;
								arrayVarName = arrayVar.name;							
							case _:
								isArrayPattern = true;
								indexVarName = indexVar.name;							
						};					
					case _:
				};			
			case _:
		};	
	case _:
}) {
			var ` = econd.expr;
			if (enumIndex ` == 3) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				if (enumIndex ` == 9) {
					{
						var e1 = `;
						var e2 = `;
						{
							@:ast(switch (e1.expr) {
	case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
		switch (e2.expr) {
			case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
				switch (arrayRef.expr) {
					case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
						isArrayPattern = true;
						indexVarName = indexVar.name;
						arrayVarName = arrayVar.name;					
					case _:
						isArrayPattern = true;
						indexVarName = indexVar.name;					
				};			
			case _:
		};	
	case _:
}) {
								var ` = e1.expr;
								if (enumIndex ` == 1) {
									var ` = `[0];
									{
										var indexVar = `;
										if (StringTools.startsWith(indexVar.name, "_g")) {
											@:ast(switch (e2.expr) {
	case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
		switch (arrayRef.expr) {
			case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
				isArrayPattern = true;
				indexVarName = indexVar.name;
				arrayVarName = arrayVar.name;			
			case _:
				isArrayPattern = true;
				indexVarName = indexVar.name;			
		};	
	case _:
}) {
												var ` = e2.expr;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														{
															var cf = `;
															var arrayRef = `;
															if (cf.get().name == "length") {
																@:ast(switch (arrayRef.expr) {
	case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
		isArrayPattern = true;
		indexVarName = indexVar.name;
		arrayVarName = arrayVar.name;	
	case _:
		isArrayPattern = true;
		indexVarName = indexVar.name;	
}) {
																	var ` = arrayRef.expr;
																	if (enumIndex ` == 1) {
																		var ` = `[0];
																		{
																			var arrayVar = `;
																			if (StringTools.startsWith(arrayVar.name, "_g")) {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																				arrayVarName = arrayVar.name;
																			} else {
																				isArrayPattern = true;
																				indexVarName = indexVar.name;
																			};
																		};
																	} else {
																		isArrayPattern = true;
																		indexVarName = indexVar.name;
																	};
																};
															} else {};
														};
													} else {};
												} else {};
											};
										} else {};
									};
								} else {};
							};
						};
					};
				} else {};
			} else {};
		};
		if (! isArrayPattern) {
			return null;
		};
		var bodyAnalysis = reflaxe.elixir.ast.optimizers.LoopOptimizer.analyzeLoopBody(ebody);
		var arrayExpr = {
			var def = reflaxe.elixir.ast.ElixirASTDef.EVar(reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(if ((arrayVarName.length > 0)) arrayVarName else "_g2", null));
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		};
		if (bodyAnalysis.hasMapPattern) {
			var loopVar = if (bodyAnalysis.loopVar != null) {
				reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(bodyAnalysis.loopVar.name, null);
			} else {
				"item";
			};
			var transformation = reflaxe.elixir.ast.optimizers.LoopOptimizer.extractMapTransformation(ebody, bodyAnalysis.loopVar);
			return reflaxe.elixir.ast.builders.EnumHandler.generateEnumMap(arrayExpr, loopVar, transformation, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		} else {
			if (bodyAnalysis.hasFilterPattern) {
				var loopVar = if (bodyAnalysis.loopVar != null) {
					reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(bodyAnalysis.loopVar.name, null);
				} else {
					"item";
				};
				var condition = reflaxe.elixir.ast.optimizers.LoopOptimizer.extractFilterCondition(ebody);
				return reflaxe.elixir.ast.builders.EnumHandler.generateEnumFilter(arrayExpr, loopVar, condition, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
			} else {
				if (bodyAnalysis.hasReducePattern) {
					return null;
				};
			};
		};
		return null;
	}

	static function buildFromTypedExprWithSubstitution(expr:reflaxe.elixir.ast.intent.TypedExpr, loopVar:Null<haxe.macro.TVar>) {
		return reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(expr, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
	}

	static function createMetadata(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return {sourceExpr : expr, sourceLine : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).min;
		} else {
			0;
		}, sourceFile : if (expr.pos != null) {
			haxe.macro.Context.getPosInfos(expr.pos).file;
		} else {
			null;
		}, type : expr.t, elixirType : reflaxe.elixir.ast.ElixirASTBuilder.typeToElixir(expr.t), purity : cast reflaxe.elixir.helpers.PatternDetector.isPure(expr), tailPosition : cast false, async : cast false, requiresReturn : cast false, requiresTempVar : cast false, inPipeline : cast false, inComprehension : cast false, inGuard : cast false, canInline : cast reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(expr), isConstant : cast reflaxe.elixir.helpers.PatternDetector.isConstant(expr), sideEffects : cast reflaxe.elixir.ast.ElixirASTBuilder.hasSideEffects(expr)};
	}

	static function hasIdiomaticMetadata(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		@:ast(switch (expr.expr) {
	case TField(_, FEnum(enumRef, _)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	case TTypeExpr(TEnumDecl(enumRef)):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 4: {
					var ` = `[0];
					var ` = `[1];
					if (enumIndex ` == 5) {
						var ` = `[0];
						var ` = `[1];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								return hasIt;
							};
						};
					} else {};
				};
				case 5: {
					var ` = `[0];
					if (enumIndex ` == 1) {
						var ` = `[0];
						{
							var enumRef = `;
							{
								var enumType = enumRef.get();
								var hasIt = enumType.meta.has(":elixirIdiomatic");
								return hasIt;
							};
						};
					} else {};
				};
				default: {}
			};
		};
		@:ast(switch (expr.t) {
	case TFun(_, ret):
		switch (ret) {
			case TEnum(enumRef, _):
				var enumType = enumRef.get();
				var hasIt = enumType.meta.has(":elixirIdiomatic");
				return hasIt;			
			default:
		};	
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) {
			var ` = expr.t;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var enumRef = `;
						{
							var enumType = enumRef.get();
							var hasIt = enumType.meta.has(":elixirIdiomatic");
							return hasIt;
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var ret = `;
						{
							@:ast(switch (ret) {
	case TEnum(enumRef, _):
		var enumType = enumRef.get();
		var hasIt = enumType.meta.has(":elixirIdiomatic");
		return hasIt;	
	default:
}) if (enumIndex ret == 1) {
								var ` = ret[0];
								var ` = ret[1];
								{
									var enumRef = `;
									{
										var enumType = enumRef.get();
										var hasIt = enumType.meta.has(":elixirIdiomatic");
										return hasIt;
									};
								};
							} else {};
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	static function toElixirAtomName(name:String) {
		var result = [];
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var c = name.charAt(i);
				if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
					result.push("_");
					result.push(c.toLowerCase());
				} else {
					result.push(c.toLowerCase());
				};
			};
		};
		return result.join("");
	}

	static function containsIfStatement(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TIf(_, _, _):
		true;	
	case TBlock(el):
		for (e  in  el) {
			if (containsIfStatement(e)) return true;
		};
		false;	
	case TWhile(_, body, _):
		containsIfStatement(body);	
	case TFor(_, _, body):
		containsIfStatement(body);	
	case TSwitch(_, cases, _):
		for (c  in  cases) {
			if (containsIfStatement(c.expr)) return true;
		};
		false;	
	case TCall(_, args):
		for (arg  in  args) {
			if (containsIfStatement(arg)) return true;
		};
		false;	
	case TVar(_, init) if (init != null):
		containsIfStatement(init);	
	case TBinop(_, e1, e2):
		containsIfStatement(e1) || containsIfStatement(e2);	
	case TUnop(_, _, e):
		containsIfStatement(e);	
	case TParenthesis(e):
		containsIfStatement(e);	
	case TMeta(_, e):
		containsIfStatement(e);	
	case TCast(e, _):
		containsIfStatement(e);	
	case TTry(e, catches):
		if (containsIfStatement(e)) return true;
		for (c  in  catches) {
			if (containsIfStatement(c.expr)) return true;
		};
		false;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e1) || reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e2);
						};
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var args = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(arg)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						var init = `;
						if (init != null) {
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(init);
						} else {
							false;
						};
					};
				};
				case 14: {
					var ` = `[0];
					{
						var el = `;
						{
							{
								var ` = 0;
								while (` < el.length) {
									var e = el[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var body = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(body);
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var body = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(body);
						};
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cases = `;
						{
							{
								var ` = 0;
								while (` < cases.length) {
									var c = cases[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(c.expr)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var catches = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e)) {
								return true;
							};
							{
								var ` = 0;
								while (` < catches.length) {
									var c = catches[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(c.expr)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.containsIfStatement(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static inline function isArrayType(t:haxe.macro.Type) {
		return reflaxe.elixir.ast.ElixirASTHelpers.isArrayType(t);
	}

	static function tryExpandElixirInjection(methodExpr:reflaxe.elixir.ast.intent.TypedExpr, thisExpr:reflaxe.elixir.ast.intent.TypedExpr, args:Array<reflaxe.elixir.ast.intent.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		@:ast(switch (methodExpr.expr) {
	case TFunction(tfunc):
		if (tfunc.expr != null) {
			return tryExpandElixirInjection(tfunc.expr, thisExpr, args, context);
		};	
	default:
}) {
			var ` = methodExpr.expr;
			if (enumIndex ` == 12) {
				var ` = `[0];
				{
					var tfunc = `;
					{
						if (tfunc.expr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirInjection(tfunc.expr, thisExpr, args, context);
						};
					};
				};
			} else {};
		};
		@:ast(switch (methodExpr.expr) {
	case TReturn(retOpt):
		if (retOpt != null) {
			return tryExpandElixirCall(retOpt, thisExpr, args, context);
		};	
	case TBlock(exprs):
		if (exprs.length > 0) {
			var lastExpr = exprs[exprs.length - 1];
			return tryExpandElixirCall(lastExpr, thisExpr, args, context);
		};	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, args, context);
		if (ifResult != null) {
			var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, args, context) : null;
			if (elseResult != null) {
				var condAst = buildFromTypedExpr(cond, context);
				return makeAST(EIf(condAst, ifResult, elseResult));
			};
			return ifResult;
		};	
	case TCall(_):
		return tryExpandElixirCall(methodExpr, thisExpr, args, context);	
	default:
}) {
			var ` = methodExpr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(methodExpr, thisExpr, args, context);
					};
				};
				case 14: {
					var ` = `[0];
					{
						var exprs = `;
						{
							if (exprs.length > 0) {
								var lastExpr = exprs[exprs.length - 1];
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(lastExpr, thisExpr, args, context);
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, args, context);
							if (ifResult != null) {
								var elseResult = if (elseExpr != null) {
									reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, args, context);
								} else {
									null;
								};
								if (elseResult != null) {
									var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, context);
									return {
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
									};
								};
								return ifResult;
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retOpt = `;
						{
							if (retOpt != null) {
								return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retOpt, thisExpr, args, context);
							};
						};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static function tryExpandElixirCall(expr:reflaxe.elixir.ast.intent.TypedExpr, thisExpr:reflaxe.elixir.ast.intent.TypedExpr, methodArgs:Array<reflaxe.elixir.ast.intent.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		@:ast(switch (expr.expr) {
	case TReturn(retExpr) if (retExpr != null):
		return tryExpandElixirCall(retExpr, thisExpr, methodArgs, context);	
	case TMeta({ name : ":untyped" }, untypedExpr):
		return tryExpandElixirCall(untypedExpr, thisExpr, methodArgs, context);	
	case TIf(cond, ifExpr, elseExpr):
		var ifResult = tryExpandElixirCall(ifExpr, thisExpr, methodArgs, context);
		var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, methodArgs, context) : null;
		if (ifResult != null && elseResult != null) {
			var condAst = buildFromTypedExpr(cond, context);
			return makeAST(EIf(condAst, ifResult, elseResult));
		} else if (ifResult != null) {
			return ifResult;
		} else if (elseResult != null) {
			return elseResult;
		};	
	case TCall(e, callArgs):
		switch (e.expr) {
			case TIdent("__elixir__"):
				if (callArgs.length > 0) {
					switch (callArgs[0].expr) {
						case TConst(TString(code)):
							var processedCode = "";
							var insideString = false;
							var i = 0;
							while (i < code.length) {
								var char = code.charAt(i);
								if (char == "\"" && (i == 0 || code.charAt(i - 1) != "\\")) {
									insideString = !insideString;
									processedCode += char;
									i++;
									continue;
								};
								if (char == "{" && i + 1 < code.length) {
									var j = i + 1;
									var numStr = "";
									while (j < code.length && code.charAt(j) >= "0" && code.charAt(j) <= "9") {
										numStr += code.charAt(j);
										j++;
									};
									if (numStr != "" && j < code.length && code.charAt(j) == "}") {
										var num = Std.parseInt(numStr);
										var argStr:String = null;
										if (num == 0) {
											var thisAst = buildFromTypedExpr(thisExpr, context);
											argStr = ElixirASTPrinter.printAST(thisAst);
										} else if (num != null && num - 1 < methodArgs.length) {
											var argAst = buildFromTypedExpr(methodArgs[num - 1], context);
											argStr = ElixirASTPrinter.printAST(argAst);
										};
										if (argStr != null) {
											if (insideString) {
												processedCode += "#{$argStr}";
											} else {
												processedCode += argStr;
											};
											i = j + 1;
											continue;
										};
									};
								};
								processedCode += char;
								i++;
							};
							return makeAST(ERaw(processedCode));						
						default:
					};
				};			
			default:
		};	
	default:
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						var callArgs = `;
						{
							@:ast(switch (e.expr) {
	case TIdent("__elixir__"):
		if (callArgs.length > 0) {
			switch (callArgs[0].expr) {
				case TConst(TString(code)):
					var processedCode = "";
					var insideString = false;
					var i = 0;
					while (i < code.length) {
						var char = code.charAt(i);
						if (char == "\"" && (i == 0 || code.charAt(i - 1) != "\\")) {
							insideString = !insideString;
							processedCode += char;
							i++;
							continue;
						};
						if (char == "{" && i + 1 < code.length) {
							var j = i + 1;
							var numStr = "";
							while (j < code.length && code.charAt(j) >= "0" && code.charAt(j) <= "9") {
								numStr += code.charAt(j);
								j++;
							};
							if (numStr != "" && j < code.length && code.charAt(j) == "}") {
								var num = Std.parseInt(numStr);
								var argStr:String = null;
								if (num == 0) {
									var thisAst = buildFromTypedExpr(thisExpr, context);
									argStr = ElixirASTPrinter.printAST(thisAst);
								} else if (num != null && num - 1 < methodArgs.length) {
									var argAst = buildFromTypedExpr(methodArgs[num - 1], context);
									argStr = ElixirASTPrinter.printAST(argAst);
								};
								if (argStr != null) {
									if (insideString) {
										processedCode += "#{$argStr}";
									} else {
										processedCode += argStr;
									};
									i = j + 1;
									continue;
								};
							};
						};
						processedCode += char;
						i++;
					};
					return makeAST(ERaw(processedCode));				
				default:
			};
		};	
	default:
}) {
								var ` = e.expr;
								if (enumIndex ` == 28) {
									var ` = `[0];
									if (` == "__elixir__") {
										{
											if (callArgs.length > 0) {
												@:ast(switch (callArgs[0].expr) {
	case TConst(TString(code)):
		var processedCode = "";
		var insideString = false;
		var i = 0;
		while (i < code.length) {
			var char = code.charAt(i);
			if (char == "\"" && (i == 0 || code.charAt(i - 1) != "\\")) {
				insideString = !insideString;
				processedCode += char;
				i++;
				continue;
			};
			if (char == "{" && i + 1 < code.length) {
				var j = i + 1;
				var numStr = "";
				while (j < code.length && code.charAt(j) >= "0" && code.charAt(j) <= "9") {
					numStr += code.charAt(j);
					j++;
				};
				if (numStr != "" && j < code.length && code.charAt(j) == "}") {
					var num = Std.parseInt(numStr);
					var argStr:String = null;
					if (num == 0) {
						var thisAst = buildFromTypedExpr(thisExpr, context);
						argStr = ElixirASTPrinter.printAST(thisAst);
					} else if (num != null && num - 1 < methodArgs.length) {
						var argAst = buildFromTypedExpr(methodArgs[num - 1], context);
						argStr = ElixirASTPrinter.printAST(argAst);
					};
					if (argStr != null) {
						if (insideString) {
							processedCode += "#{$argStr}";
						} else {
							processedCode += argStr;
						};
						i = j + 1;
						continue;
					};
				};
			};
			processedCode += char;
			i++;
		};
		return makeAST(ERaw(processedCode));	
	default:
}) {
													var ` = callArgs[0].expr;
													if (enumIndex ` == 0) {
														var ` = `[0];
														if (enumIndex ` == 2) {
															var ` = `[0];
															{
																var code = `;
																{
																	var processedCode = "";
																	var insideString = false;
																	var i = 0;
																	while (i < code.length) {
																		var char = code.charAt(i);
																		if (char == "\"" && (i == 0 || code.charAt(i - 1) != "\\")) {
																			insideString = ! insideString;
																			processedCode += char;
																			i ++;
																			continue;
																		};
																		if (char == "{" && i + 1 < code.length) {
																			var j = i + 1;
																			var numStr = "";
																			while (j < code.length && code.charAt(j) >= "0" && code.charAt(j) <= "9") {
																				numStr += code.charAt(j);
																				j ++;
																			};
																			if (numStr != "" && j < code.length && code.charAt(j) == "}") {
																				var num = Std.parseInt(numStr);
																				var argStr = null;
																				if (num == 0) {
																					var thisAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(thisExpr, context);
																					argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(thisAst, null);
																				} else {
																					if (num != null && num - 1 < methodArgs.length) {
																						var argAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(methodArgs[num - 1], context);
																						argStr = reflaxe.elixir.ast.ElixirASTPrinter.printAST(argAst, null);
																					};
																				};
																				if (argStr != null) {
																					if (insideString) {
																						processedCode += "#{" + argStr + "}";
																					} else {
																						processedCode += argStr;
																					};
																					i = j + 1;
																					continue;
																				};
																			};
																		};
																		processedCode += char;
																		i ++;
																	};
																	return {
																		var pos = null;
																		{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(processedCode), metadata : {}, pos : pos};
																	};
																};
															};
														} else {};
													} else {};
												};
											};
										};
									} else {};
								} else {};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var ifExpr = `;
						var elseExpr = `;
						{
							var ifResult = reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(ifExpr, thisExpr, methodArgs, context);
							var elseResult = if (elseExpr != null) {
								reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(elseExpr, thisExpr, methodArgs, context);
							} else {
								null;
							};
							if (ifResult != null && elseResult != null) {
								var condAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, context);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EIf(condAst, ifResult, elseResult), metadata : {}, pos : pos};
								};
							} else {
								if (ifResult != null) {
									return ifResult;
								} else {
									if (elseResult != null) {
										return elseResult;
									};
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var retExpr = `;
						if (retExpr != null) {
							return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(retExpr, thisExpr, methodArgs, context);
						} else {};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.name;
						var ` = `.params;
						var ` = `.pos;
						if (` == ":untyped") {
							{
								var untypedExpr = `;
								{
									return reflaxe.elixir.ast.ElixirASTBuilder.tryExpandElixirCall(untypedExpr, thisExpr, methodArgs, context);
								};
							};
						} else {};
					};
				};
				default: {}
			};
		};
		return null;
	}

	static inline function isMapType(t:haxe.macro.Type) {
		return reflaxe.elixir.ast.ElixirASTHelpers.isMapType(t);
	}

	static function convertAssignOp(op:haxe.macro.Binop) {
		return @:ast(switch (op) {
	case OpAdd:
		Add;	
	case OpSub:
		Subtract;	
	case OpMult:
		Multiply;	
	case OpDiv:
		Divide;	
	case OpMod:
		Remainder;	
	case OpAnd:
		BitwiseAnd;	
	case OpOr:
		BitwiseOr;	
	case OpXor:
		BitwiseXor;	
	case OpShl:
		ShiftLeft;	
	case OpShr:
		ShiftRight;	
	default:
		Add;	
}) switch (enumIndex op) {
			case 0: {
				{
					reflaxe.elixir.ast.EBinaryOp.Add;
				};
			};
			case 1: {
				{
					reflaxe.elixir.ast.EBinaryOp.Multiply;
				};
			};
			case 2: {
				{
					reflaxe.elixir.ast.EBinaryOp.Divide;
				};
			};
			case 3: {
				{
					reflaxe.elixir.ast.EBinaryOp.Subtract;
				};
			};
			case 11: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseAnd;
				};
			};
			case 12: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseOr;
				};
			};
			case 13: {
				{
					reflaxe.elixir.ast.EBinaryOp.BitwiseXor;
				};
			};
			case 16: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftLeft;
				};
			};
			case 17: {
				{
					reflaxe.elixir.ast.EBinaryOp.ShiftRight;
				};
			};
			case 19: {
				{
					reflaxe.elixir.ast.EBinaryOp.Remainder;
				};
			};
			default: {
				reflaxe.elixir.ast.EBinaryOp.Add;
			}
		};
	}

	static function applyParameterRenaming(ast:reflaxe.elixir.ast.ElixirAST, renaming:Map<String, String>) {
		return @:ast(switch (ast.def) {
	case EVar(name):
		if (renaming.exists(name)) {
			makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
		} else {
			ast;
		};	
	case EBlock(exprs):
		makeASTWithMeta(EBlock(exprs.map(function(e) ->  @:implicitReturn return applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);	
	case ECall(target, func, args):
		makeASTWithMeta(ECall(target != null ? applyParameterRenaming(target, renaming) : null, func, args.map(function(a) ->  @:implicitReturn return applyParameterRenaming(a, renaming))), ast.metadata, ast.pos);	
	case EBinary(op, left, right):
		makeASTWithMeta(EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)), ast.metadata, ast.pos);	
	case EUnary(op, expr):
		makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);	
	case EIf(cond, then, else_):
		makeASTWithMeta(EIf(applyParameterRenaming(cond, renaming), applyParameterRenaming(then, renaming), else_ != null ? applyParameterRenaming(else_, renaming) : null), ast.metadata, ast.pos);	
	case ECase(expr, clauses):
		makeASTWithMeta(ECase(applyParameterRenaming(expr, renaming), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? applyParameterRenaming(c.guard, renaming) : null, body : applyParameterRenaming(c.body, renaming) })), ast.metadata, ast.pos);	
	default:
		ast;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.guard, renaming) else null, body : reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v.body, renaming)});
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var then = `;
						var else_ = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(cond, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(then, renaming), if ((else_ != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(else_, renaming) else null);
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var func = `;
						var args = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(target, renaming) else null, func, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(left, renaming), reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(right, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(expr, renaming));
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							if (renaming.exists(name)) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EVar(renaming.get(name));
									var meta = ast.metadata;
									var pos = ast.pos;
									{def : def, metadata : meta, pos : pos};
								};
							} else {
								ast;
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
									var ` = [];
									{
										var ` = 0;
										var ` = exprs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(reflaxe.elixir.ast.ElixirASTBuilder.applyParameterRenaming(v, renaming));
										};
									};
									`;
								});
								var meta = ast.metadata;
								var pos = ast.pos;
								{def : def, metadata : meta, pos : pos};
							};
						};
					};
				};
				default: {
					ast;
				}
			};
		};
	}

	static function isCamelCaseParameter(name:String) {
		if (name.length < 2) {
			return false;
		};
		var firstChar = name.charAt(0);
		if (firstChar != firstChar.toLowerCase()) {
			return false;
		};
		{
			var ` = 1;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
					return true;
				};
			};
		};
		return false;
	}

	public static function isTempPatternVarName(name:String) {
		if (name == null || name.length == 0) {
			return false;
		};
		var isDigits = function(str:String) {
			if (str == null || str.length == 0) {
				return false;
			};
			{
				var ` = 0;
				var ` = str.length;
				while (` < `) {
					var i = ` ++;
					var c = str.charAt(i);
					if (c < "0" || c > "9") {
						return false;
					};
				};
			};
			return true;
		};
		var check = function(candidate:String) {
			if (candidate == null || candidate.length == 0) {
				return false;
			};
			if (candidate == "g" || candidate == "_g") {
				return true;
			};
			if (candidate.length > 1 && candidate.charAt(0) == "g" && isDigits(candidate.substr(1, null))) {
				return true;
			};
			if (candidate.length > 2 && candidate.charAt(0) == "_" && candidate.charAt(1) == "g" && isDigits(candidate.substr(2, null))) {
				return true;
			};
			return false;
		};
		if (check(name)) {
			return true;
		};
		var canonical = reflaxe.elixir.ast.naming.ElixirNaming.toVarName(name);
		if (canonical != name && check(canonical)) {
			return true;
		};
		return false;
	}

	public static function extractFieldName(fa:haxe.macro.FieldAccess) {
		return @:ast(switch (fa) {
	case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
		cf.get().name;	
	case FDynamic(s):
		s;	
	case FEnum(_, ef):
		ef.name;	
}) switch (@:exhaustive enumIndex fa) {
			case 0: {
				var ` = fa[0];
				var ` = fa[1];
				var ` = fa[2];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 1: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 2: {
				var ` = fa[0];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 3: {
				var ` = fa[0];
				{
					var s = `;
					{
						s;
					};
				};
			};
			case 4: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var cf = `;
					{
						cf.get().name;
					};
				};
			};
			case 5: {
				var ` = fa[0];
				var ` = fa[1];
				{
					var ef = `;
					{
						ef.name;
					};
				};
			};
		};
	}

	@:value({ enumBindingPlan : null })
	static function createVariableMappingsForCase(caseExpr:reflaxe.elixir.ast.intent.TypedExpr, extractedParams:Array<String>, enumType:Null<haxe.macro.EnumType>, values:Array<reflaxe.elixir.ast.intent.TypedExpr>, enumBindingPlan:Null<Map<Int, { isUsed : Bool, finalName : String }>> = null) {
		var mapping = {
			{};
			new haxe.ds.IntMap();
		};
		if (enumType == null) {
			var scanForVariableAssignments = [null];
			scanForVariableAssignments[0] = function(expr:reflaxe.elixir.ast.intent.TypedExpr) {
				@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) scanForVariableAssignments(e);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TLocal(sourceVar):
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments);	
}) {
					var ` = expr.expr;
					switch (enumIndex `) {
						case 13: {
							var ` = `[0];
							var ` = `[1];
							{
								var v = `;
								var init = `;
								if (init != null) {
									@:ast(switch (init.expr) {
	case TLocal(sourceVar):
	default:
}) {
										var ` = init.expr;
										if (enumIndex ` == 1) {
											var ` = `[0];
											{
												var sourceVar = `;
												{};
											};
										} else {};
									};
								} else {
									haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments[0]);
								};
							};
						};
						case 14: {
							var ` = `[0];
							{
								var exprs = `;
								{
									{
										var ` = 0;
										while (` < exprs.length) {
											var e = exprs[`];
											++ `;
											scanForVariableAssignments[0](e);
										};
									};
								};
							};
						};
						default: {
							haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments[0]);
						}
					};
				};
			};
			scanForVariableAssignments[0](caseExpr);
			return mapping;
		};
		if (values.length > 0) {
			@:ast(switch (values[0].expr) {
	case TConst(TInt(index)):
		var constructors = [];
		for (name  in  enumType.constructs.keys()) {
			var constructor = enumType.constructs.get(name);
			constructors[constructor.index] = constructor;
		};
		if (index >= 0 && index < constructors.length && constructors[index] != null) {
			var constructor = constructors[index];
			var canonicalNames = switch (constructor.type) {
				case TFun(args, _):
					[for (arg  in  args) arg.name];				
				default:
					[];				
			};
			var enumExtractionVars = new Map<Int,Bool>();
			function scanForTVars(expr:TypedExpr):Void {
				switch (expr.expr) {
					case TBlock(exprs):
						for (e  in  exprs) scanForTVars(e);					
					case TVar(v, init) if (init != null):
						switch (init.expr) {
							case TEnumParameter(_, _, paramIndex):
								var finalName:String;
								if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
									finalName = enumBindingPlan.get(paramIndex).finalName;
								} else {
									var varName = VariableAnalyzer.toElixirVarName(v.name);
									if (varName.startsWith("_g")) {
										varName = varName.substr(1);
									};
									finalName = varName;
								};
								mapping.set(v.id, finalName);
								enumExtractionVars.set(v.id, true);							
							case TLocal(tempVar):
								var tempVarName = VariableAnalyzer.toElixirVarName(tempVar.name);
								var patternVarName = VariableAnalyzer.toElixirVarName(v.name);
								if (enumExtractionVars.exists(tempVar.id)) {
									mapping.set(v.id, patternVarName);
								} else if (mapping.exists(tempVar.id)) {
									var canonicalName = mapping.get(tempVar.id);
									mapping.set(v.id, canonicalName);
									if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
										currentContext.patternVariableRegistry.set(v.id, canonicalName);
									};
								} else { };							
							default:
						};					
					default:
						haxe.macro.TypedExprTools.iter(expr, scanForTVars);					
				};
			};
			scanForTVars(caseExpr);
		};	
	default:
}) {
				var ` = values[0].expr;
				if (enumIndex ` == 0) {
					var ` = `[0];
					if (enumIndex ` == 0) {
						var ` = `[0];
						{
							var index = `;
							{
								var constructors = [];
								for (name in {
									var this = enumType.constructs;
									cast this.keys();
								}) {
									var constructor = {
										var this = enumType.constructs;
										cast this.get(name);
									};
									constructors[constructor.index] = constructor;
								};
								if (index >= 0 && index < constructors.length && constructors[index] != null) {
									var constructor = constructors[index];
									var canonicalNames = @:ast(switch (constructor.type) {
	case TFun(args, _):
		[for (arg  in  args) arg.name];	
	default:
		[];	
}) {
										var ` = constructor.type;
										if (enumIndex ` == 4) {
											var ` = `[0];
											var ` = `[1];
											{
												var args = `;
												{
													{
														var ` = [];
														{
															var ` = 0;
															while (` < args.length) {
																var arg = args[`];
																++ `;
																`.push(arg.name);
															};
														};
														`;
													};
												};
											};
										} else {
											[];
										};
									};
									var enumExtractionVars = {
										{};
										new haxe.ds.IntMap();
									};
									var scanForTVars = [null];
									scanForTVars[0] = function(expr:reflaxe.elixir.ast.intent.TypedExpr) {
										@:ast(switch (expr.expr) {
	case TBlock(exprs):
		for (e  in  exprs) scanForTVars(e);	
	case TVar(v, init) if (init != null):
		switch (init.expr) {
			case TEnumParameter(_, _, paramIndex):
				var finalName:String;
				if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
					finalName = enumBindingPlan.get(paramIndex).finalName;
				} else {
					var varName = VariableAnalyzer.toElixirVarName(v.name);
					if (varName.startsWith("_g")) {
						varName = varName.substr(1);
					};
					finalName = varName;
				};
				mapping.set(v.id, finalName);
				enumExtractionVars.set(v.id, true);			
			case TLocal(tempVar):
				var tempVarName = VariableAnalyzer.toElixirVarName(tempVar.name);
				var patternVarName = VariableAnalyzer.toElixirVarName(v.name);
				if (enumExtractionVars.exists(tempVar.id)) {
					mapping.set(v.id, patternVarName);
				} else if (mapping.exists(tempVar.id)) {
					var canonicalName = mapping.get(tempVar.id);
					mapping.set(v.id, canonicalName);
					if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
						currentContext.patternVariableRegistry.set(v.id, canonicalName);
					};
				} else { };			
			default:
		};	
	default:
		haxe.macro.TypedExprTools.iter(expr, scanForTVars);	
}) {
											var ` = expr.expr;
											switch (enumIndex `) {
												case 13: {
													var ` = `[0];
													var ` = `[1];
													{
														var v = `;
														var init = `;
														if (init != null) {
															@:ast(switch (init.expr) {
	case TEnumParameter(_, _, paramIndex):
		var finalName:String;
		if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
			finalName = enumBindingPlan.get(paramIndex).finalName;
		} else {
			var varName = VariableAnalyzer.toElixirVarName(v.name);
			if (varName.startsWith("_g")) {
				varName = varName.substr(1);
			};
			finalName = varName;
		};
		mapping.set(v.id, finalName);
		enumExtractionVars.set(v.id, true);	
	case TLocal(tempVar):
		var tempVarName = VariableAnalyzer.toElixirVarName(tempVar.name);
		var patternVarName = VariableAnalyzer.toElixirVarName(v.name);
		if (enumExtractionVars.exists(tempVar.id)) {
			mapping.set(v.id, patternVarName);
		} else if (mapping.exists(tempVar.id)) {
			var canonicalName = mapping.get(tempVar.id);
			mapping.set(v.id, canonicalName);
			if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
				currentContext.patternVariableRegistry.set(v.id, canonicalName);
			};
		} else { };	
	default:
}) {
																var ` = init.expr;
																switch (enumIndex `) {
																	case 1: {
																		var ` = `[0];
																		{
																			var tempVar = `;
																			{
																				var tempVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(tempVar.name, null);
																				var patternVarName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
																				if ({
																					var key = tempVar.id;
																					enumExtractionVars.exists(key);
																				}) {
																					{
																						var key = v.id;
																						mapping.set(key, patternVarName);
																					};
																				} else {
																					if ({
																						var key = tempVar.id;
																						mapping.exists(key);
																					}) {
																						var canonicalName = {
																							var key = tempVar.id;
																							mapping.get(key);
																						};
																						{
																							var key = v.id;
																							mapping.set(key, canonicalName);
																						};
																						if ({
																							var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.patternVariableRegistry;
																							var key = tempVar.id;
																							cast this.exists(key);
																						}) {
																							{
																								var this = reflaxe.elixir.ast.ElixirASTBuilder.currentContext.patternVariableRegistry;
																								var key = v.id;
																								cast this.set(key, canonicalName);
																							};
																						};
																					} else {};
																				};
																			};
																		};
																	};
																	case 26: {
																		var ` = `[0];
																		var ` = `[1];
																		var ` = `[2];
																		{
																			var paramIndex = `;
																			{
																				var finalName;
																				if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
																					finalName = cast enumBindingPlan.get(paramIndex).finalName;
																				} else {
																					var varName = reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(v.name, null);
																					if (StringTools.startsWith(varName, "_g")) {
																						varName = varName.substr(1, null);
																					};
																					finalName = varName;
																				};
																				{
																					var key = v.id;
																					mapping.set(key, finalName);
																				};
																				{
																					var key = v.id;
																					enumExtractionVars.set(key, true);
																				};
																			};
																		};
																	};
																	default: {}
																};
															};
														} else {
															haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
														};
													};
												};
												case 14: {
													var ` = `[0];
													{
														var exprs = `;
														{
															{
																var ` = 0;
																while (` < exprs.length) {
																	var e = exprs[`];
																	++ `;
																	scanForTVars[0](e);
																};
															};
														};
													};
												};
												default: {
													haxe.macro.TypedExprTools.iter(expr, scanForTVars[0]);
												}
											};
										};
									};
									scanForTVars[0](caseExpr);
								};
							};
						};
					} else {};
				} else {};
			};
		};
		return mapping;
	}

	static inline function collectTemplateContent(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.TemplateHelpers.collectTemplateContent(ast);
	}

	static inline function collectTemplateArgument(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.TemplateHelpers.collectTemplateArgument(ast);
	}

	static inline function isHXXModule(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return reflaxe.elixir.ast.TemplateHelpers.isHXXModule(expr);
	}

	static function isAssertClass(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(TClassDecl(classRef)):
		var classType = classRef.get();
		var pack = classType.pack.join(".");
		var name = classType.name;
		pack == "haxe.test" && name == "Assert";	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				if (enumIndex ` == 0) {
					var ` = `[0];
					{
						var classRef = `;
						{
							var classType = classRef.get();
							var pack = classType.pack.join(".");
							var name = classType.name;
							pack == "haxe.test" && name == "Assert";
						};
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	static function isModuleCall(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TTypeExpr(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static inline function isMapAccess(t:haxe.macro.Type) {
		return reflaxe.elixir.ast.ElixirASTHelpers.isMapAccess(t);
	}

	static function getExternNativeModuleNameFromType(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(cRef, _):
		var c = cRef.get();
		if (c.isExtern && c.meta.has(":native")) {
			var meta = c.meta.extract(":native");
			if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
				switch (meta[0].params[0].expr) {
					case EConst(CString(s, _)):
						s;					
					default:
						null;					
				};
			} else null;
		} else null;	
	case _:
		null;	
}) if (enumIndex t == 2) {
			var ` = t[0];
			var ` = t[1];
			{
				var cRef = `;
				{
					var c = cRef.get();
					if (c.isExtern && c.meta.has(":native")) {
						var meta = c.meta.extract(":native");
						if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
							@:ast(switch (meta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		null;	
}) {
								var ` = meta[0].params[0].expr;
								if (enumIndex ` == 0) {
									var ` = `[0];
									if (enumIndex ` == 2) {
										var ` = `[0];
										var ` = `[1];
										{
											var s = `;
											{
												s;
											};
										};
									} else {
										null;
									};
								} else {
									null;
								};
							};
						} else {
							null;
						};
					} else {
						null;
					};
				};
			};
		} else {
			null;
		};
	}

	static function moduleTypeToString(m:haxe.macro.ModuleType) {
		var name = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().name;	
	case TEnumDecl(e):
		e.get().name;	
	case TTypeDecl(t):
		t.get().name;	
	case TAbstract(a):
		a.get().name;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().name;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().name;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().name;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().name;
					};
				};
			};
		};
		var isExtern = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().isExtern;	
	default:
		false;	
}) if (enumIndex m == 0) {
			var ` = m[0];
			{
				var c = `;
				{
					c.get().isExtern;
				};
			};
		} else {
			false;
		};
		var pack = @:ast(switch (m) {
	case TClassDecl(c):
		c.get().pack;	
	case TEnumDecl(e):
		e.get().pack;	
	case TTypeDecl(t):
		t.get().pack;	
	case TAbstract(a):
		a.get().pack;	
}) switch (@:exhaustive enumIndex m) {
			case 0: {
				var ` = m[0];
				{
					var c = `;
					{
						c.get().pack;
					};
				};
			};
			case 1: {
				var ` = m[0];
				{
					var e = `;
					{
						e.get().pack;
					};
				};
			};
			case 2: {
				var ` = m[0];
				{
					var t = `;
					{
						t.get().pack;
					};
				};
			};
			case 3: {
				var ` = m[0];
				{
					var a = `;
					{
						a.get().pack;
					};
				};
			};
		};
		if (pack.length > 0) {
			if (StringTools.endsWith(name, "_Impl_") || name.indexOf("_Impl_", null) != -1) {
				return name;
			};
			if (! isExtern) {
				return name;
			};
			@:ast(switch (pack[0]) {
	case "ecto":
		return "Ecto." + name;	
	case "phoenix":
		return "Phoenix." + name;	
	case "plug":
		return "Plug." + name;	
	default:
}) {
				var ` = pack[0];
				switch (`) {
					case "ecto": {
						{
							return "Ecto." + name;
						};
					};
					case "phoenix": {
						{
							return "Phoenix." + name;
						};
					};
					case "plug": {
						{
							return "Plug." + name;
						};
					};
					default: {}
				};
			};
		};
		return name;
	}

	static inline function countVarOccurrencesInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String) {
		return reflaxe.elixir.ast.ElixirASTHelpers.countVarOccurrencesInAST(ast, name);
	}

	static inline function replaceVarInAST(ast:reflaxe.elixir.ast.ElixirAST, name:String, replacement:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTHelpers.replaceVarInAST(ast, name, replacement);
	}

	static function typeToElixir(t:haxe.macro.Type) {
		if (t == null) {
			return "any";
		};
		return @:ast(switch (t) {
	case TInst(_.get() => { name : "String" }, _):
		"binary";	
	case TInst(_.get() => { name : "Array" }, _):
		"list";	
	case TAbstract(_.get() => { name : "Int" }, _):
		"integer";	
	case TAbstract(_.get() => { name : "Float" }, _):
		"float";	
	case TAbstract(_.get() => { name : "Bool" }, _):
		"boolean";	
	case TDynamic(_):
		"any";	
	default:
		"term";	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).constructor;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.fields;
						var ` = _hx_tmp.init;
						var ` = _hx_tmp.interfaces;
						var ` = _hx_tmp.isAbstract;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isFinal;
						var ` = _hx_tmp.isInterface;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.kind;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.overrides;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.statics;
						var ` = _hx_tmp.superClass;
						switch (`) {
							case "Array": {
								{
									"list";
								};
							};
							case "String": {
								{
									"binary";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			case 6: {
				var ` = t[0];
				{
					"any";
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var _hx_tmp;
					{
						var ` = (_hx_tmp = `.get()).array;
						var ` = _hx_tmp.binops;
						var ` = _hx_tmp.doc;
						var ` = _hx_tmp.from;
						var ` = _hx_tmp.impl;
						var ` = _hx_tmp.isExtern;
						var ` = _hx_tmp.isPrivate;
						var ` = _hx_tmp.meta;
						var ` = _hx_tmp.module;
						var ` = _hx_tmp.name;
						var ` = _hx_tmp.pack;
						var ` = _hx_tmp.params;
						var ` = _hx_tmp.pos;
						var ` = _hx_tmp.resolve;
						var ` = _hx_tmp.resolveWrite;
						var ` = _hx_tmp.to;
						var ` = _hx_tmp.type;
						var ` = _hx_tmp.unops;
						switch (`) {
							case "Bool": {
								{
									"boolean";
								};
							};
							case "Float": {
								{
									"float";
								};
							};
							case "Int": {
								{
									"integer";
								};
							};
							default: {
								"term";
							}
						};
					};
				};
			};
			default: {
				"term";
			}
		};
	}

	static function isPure(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_) | TTypeExpr(_):
		true;	
	case TBinop(_, e1, e2):
		isPure(e1) && isPure(e2);	
	case TUnop(_, _, e):
		isPure(e);	
	case TField(e, _):
		isPure(e);	
	case TParenthesis(e):
		isPure(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e1) && reflaxe.elixir.ast.ElixirASTBuilder.isPure(e2);
						};
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						true;
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isPure(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function canBeInlined(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_) | TLocal(_):
		true;	
	case TBinop(_, e1, e2):
		canBeInlined(e1) && canBeInlined(e2);	
	case TUnop(_, _, e):
		canBeInlined(e);	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e1 = `;
						var e2 = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e1) && reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e2);
						};
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.canBeInlined(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isConstant(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TConst(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			if (enumIndex ` == 0) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	static function hasSideEffects(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return @:ast(switch (expr.expr) {
	case TCall(_, _) | TNew(_, _, _) | TVar(_, _):
		true;	
	case TBinop(OpAssign | OpAssignOp(_), _, _):
		true;	
	case TUnop(OpIncrement | OpDecrement, _, _):
		true;	
	case TThrow(_):
		true;	
	default:
		false;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 4: {
							{
								true;
							};
						};
						case 20: {
							var ` = `[0];
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					switch (enumIndex `) {
						case 0, 1: {
							{
								true;
							};
						};
						default: {
							false;
						}
					};
				};
				case 13: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 23: {
					var ` = `[0];
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isSimpleInit(init:reflaxe.elixir.ast.intent.TypedExpr) {
		if (init == null) {
			return true;
		};
		return @:ast(switch (init.expr) {
	case TConst(_):
		true;	
	case TLocal(_):
		true;	
	case TField(_, _):
		true;	
	case TCall(_, _):
		true;	
	case TNew(_, _, _):
		true;	
	case TObjectDecl(_):
		true;	
	case TArrayDecl(_):
		true;	
	case TBinop(_, _, _):
		true;	
	case TUnop(_, _, _):
		true;	
	case TParenthesis(e):
		isSimpleInit(e);	
	case TCast(e, _):
		isSimpleInit(e);	
	case TMeta(_, e):
		isSimpleInit(e);	
	case TBlock(_):
		false;	
	case TIf(_, _, _):
		false;	
	case TSwitch(_, _, _):
		false;	
	case TWhile(_, _, _):
		false;	
	case TFor(_, _, _):
		false;	
	case TTry(_, _):
		false;	
	case TFunction(_):
		false;	
	default:
		true;	
}) {
			var ` = init.expr;
			switch (enumIndex `) {
				case 0: {
					var ` = `[0];
					{
						true;
					};
				};
				case 1: {
					var ` = `[0];
					{
						true;
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 4: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 6: {
					var ` = `[0];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isSimpleInit(e);
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						true;
					};
				};
				case 8: {
					var ` = `[0];
					{
						true;
					};
				};
				case 9: {
					var ` = `[0];
					var ` = `[1];
					{
						true;
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 11: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						true;
					};
				};
				case 12: {
					var ` = `[0];
					{
						false;
					};
				};
				case 14: {
					var ` = `[0];
					{
						false;
					};
				};
				case 15: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						false;
					};
				};
				case 16: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						false;
					};
				};
				case 17: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						false;
					};
				};
				case 18: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						false;
					};
				};
				case 19: {
					var ` = `[0];
					var ` = `[1];
					{
						false;
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isSimpleInit(e);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var e = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isSimpleInit(e);
						};
					};
				};
				default: {
					true;
				}
			};
		};
	}

	static function isVariableUsedInAST(varName:String, ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EVar(name):
		name == varName;	
	case EBlock(exprs):
		for (e  in  exprs) {
			if (isVariableUsedInAST(varName, e)) return true;
		};
		false;	
	case EIf(cond, thenBranch, elseBranch):
		isVariableUsedInAST(varName, cond) || isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && isVariableUsedInAST(varName, elseBranch));	
	case ETuple(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EList(values):
		for (v  in  values) {
			if (isVariableUsedInAST(varName, v)) return true;
		};
		false;	
	case EBinary(_, left, right):
		isVariableUsedInAST(varName, left) || isVariableUsedInAST(varName, right);	
	case ECall(target, funcName, args):
		if (target != null && isVariableUsedInAST(varName, target)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case ERemoteCall(module, func, args):
		if (isVariableUsedInAST(varName, module)) return true;
		for (a  in  args) {
			if (isVariableUsedInAST(varName, a)) return true;
		};
		false;	
	case EFn(clauses):
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case ECase(expr, clauses):
		if (isVariableUsedInAST(varName, expr)) return true;
		for (c  in  clauses) {
			if (isVariableUsedInAST(varName, c.body)) return true;
			if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
		};
		false;	
	case EAssign(name):
		name == varName;	
	case _:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, expr)) {
								return true;
							};
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, cond) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, thenBranch) || (elseBranch != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, elseBranch));
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, v)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							if (target != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, target)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, module)) {
								return true;
							};
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, a)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, left) || reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, right);
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.body)) {
										return true;
									};
									if (c.guard != null && reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, c.guard)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									if (reflaxe.elixir.ast.ElixirASTBuilder.isVariableUsedInAST(varName, e)) {
										return true;
									};
								};
							};
							false;
						};
					};
				};
				case 63: {
					var ` = `[0];
					{
						var name = `;
						{
							name == varName;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function generateIdiomaticEnumCall(arrayRef:reflaxe.elixir.ast.intent.TypedExpr, operation:String, body:reflaxe.elixir.ast.intent.TypedExpr) {
		var arrayAST = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arrayRef, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
		var lambdaBody = null;
		var itemVar = "v";
		@:ast(switch (body.expr) {
	case TBlock(exprs):
		for (expr  in  exprs) {
			switch (expr.expr) {
				case TVar(tvar, _):
					itemVar = tvar.name;				
				case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
					lambdaBody = buildFromTypedExpr(arg, currentContext);				
				case TIf(cond, thenExpr, _) if (operation == "filter"):
					lambdaBody = buildFromTypedExpr(cond, currentContext);				
				case _:
			};
		};	
	case _:
}) {
			var ` = body.expr;
			if (enumIndex ` == 14) {
				var ` = `[0];
				{
					var exprs = `;
					{
						{
							var ` = 0;
							while (` < exprs.length) {
								var expr = exprs[`];
								++ `;
								@:ast(switch (expr.expr) {
	case TVar(tvar, _):
		itemVar = tvar.name;	
	case TCall({ expr : TField(_, FInstance(_, _, cf)) }, [arg]) if (cf.get().name == "push"):
		lambdaBody = buildFromTypedExpr(arg, currentContext);	
	case TIf(cond, thenExpr, _) if (operation == "filter"):
		lambdaBody = buildFromTypedExpr(cond, currentContext);	
	case _:
}) {
									var ` = expr.expr;
									switch (enumIndex `) {
										case 9: {
											var ` = `[0];
											var ` = `[1];
											{
												var ` = `.expr;
												var ` = `.pos;
												var ` = `.t;
												if (enumIndex ` == 4) {
													var ` = `[0];
													var ` = `[1];
													if (enumIndex ` == 0) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (`.length == 1) {
															var ` = `[0];
															{
																var arg = `;
																var cf = `;
																if (cf.get().name == "push") {
																	lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(arg, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
																} else {};
															};
														} else {};
													} else {};
												} else {};
											};
										};
										case 13: {
											var ` = `[0];
											var ` = `[1];
											{
												var tvar = `;
												{
													itemVar = tvar.name;
												};
											};
										};
										case 16: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cond = `;
												var thenExpr = `;
												if (operation == "filter") {
													lambdaBody = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(cond, reflaxe.elixir.ast.ElixirASTBuilder.currentContext);
												} else {};
											};
										};
										default: {}
									};
								};
							};
						};
					};
				};
			} else {};
		};
		if (lambdaBody == null) {
			lambdaBody = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(itemVar), metadata : {}, pos : pos};
			};
		};
		var lambda = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([{args : [reflaxe.elixir.ast.EPattern.PVar(itemVar)], guard : null, body : lambdaBody}]), metadata : {}, pos : pos};
		};
		@:ast(switch (operation) {
	case "map":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
	case "filter":
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "filter", [arrayAST, lambda]);	
	default:
		return ERemoteCall(makeAST(EAtom(ElixirAtom.raw("Enum"))), "map", [arrayAST, lambda]);	
}) switch (operation) {
			case "filter": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "filter", [arrayAST, lambda]);
				};
			};
			case "map": {
				{
					return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
					}, "map", [arrayAST, lambda]);
				};
			};
			default: {
				return reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast "Enum"), metadata : {}, pos : pos};
				}, "map", [arrayAST, lambda]);
			}
		};
	}

	static function unwrapMetaParens(e:reflaxe.elixir.ast.intent.TypedExpr) {
		if (e == null) {
			return null;
		};
		return @:ast(switch (e.expr) {
	case TMeta(_, expr):
		unwrapMetaParens(expr);	
	case TParenthesis(expr):
		unwrapMetaParens(expr);	
	case _:
		e;	
}) {
			var ` = e.expr;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				case 25: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.ElixirASTBuilder.unwrapMetaParens(expr);
						};
					};
				};
				default: {
					e;
				}
			};
		};
	}

	static function tryBuildMapLiteralFromBlock(blockStmts:Array<reflaxe.elixir.ast.intent.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		if (blockStmts == null || blockStmts.length < 3) {
			return null;
		};
		var tempVar = null;
		var tempInit = null;
		@:ast(switch (blockStmts[0].expr) {
	case TVar(tv, init) if (init != null):
		tempVar = tv;
		tempInit = init;	
	default:
		return null;	
}) {
			var ` = blockStmts[0].expr;
			if (enumIndex ` == 13) {
				var ` = `[0];
				var ` = `[1];
				{
					var tv = `;
					var init = `;
					if (init != null) {
						tempVar = tv;
						tempInit = init;
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
		if (tempVar == null || tempInit == null) {
			return null;
		};
		var isMapCtor = @:ast(switch (tempInit.expr) {
	case TNew(c, _, _):
		var className = c.get().name;
		className == "StringMap" || className == "Map" || className.endsWith("Map");	
	default:
		false;	
}) {
			var ` = tempInit.expr;
			if (enumIndex ` == 10) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var c = `;
					{
						var className = c.get().name;
						className == "StringMap" || className == "Map" || StringTools.endsWith(className, "Map");
					};
				};
			} else {
				false;
			};
		};
		if (! isMapCtor) {
			return null;
		};
		var tempName = tempVar.name;
		var pairs = [];
		{
			var ` = 1;
			var ` = blockStmts.length - 1;
			while (` < `) {
				var i = ` ++;
				var stmt = blockStmts[i];
				@:ast(switch (stmt.expr) {
	case TCall({ expr : TField({ expr : TLocal(local) }, FInstance(_, _, cf)) }, callArgs):
		if (local.name != tempName || cf.get().name != "set" || callArgs.length != 2) {
			return null;
		};
		var keyAst = buildFromTypedExpr(callArgs[0], context);
		var valueAst = buildFromTypedExpr(callArgs[1], context);
		pairs.push({ key : keyAst, value : valueAst });	
	default:
		return null;	
}) {
					var ` = stmt.expr;
					if (enumIndex ` == 9) {
						var ` = `[0];
						var ` = `[1];
						{
							var ` = `.expr;
							var ` = `.pos;
							var ` = `.t;
							if (enumIndex ` == 4) {
								var ` = `[0];
								var ` = `[1];
								{
									var ` = `.expr;
									var ` = `.pos;
									var ` = `.t;
									if (enumIndex ` == 1) {
										var ` = `[0];
										if (enumIndex ` == 0) {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											{
												var cf = `;
												var local = `;
												var callArgs = `;
												{
													if (local.name != tempName || cf.get().name != "set" || callArgs.length != 2) {
														return null;
													};
													var keyAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(callArgs[0], context);
													var valueAst = reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(callArgs[1], context);
													pairs.push({key : keyAst, value : valueAst});
												};
											};
										} else {
											return null;
										};
									} else {
										return null;
									};
								};
							} else {
								return null;
							};
						};
					} else {
						return null;
					};
				};
			};
		};
		@:ast(switch (blockStmts[blockStmts.length - 1].expr) {
	case TLocal(retVar) if (retVar.name == tempName):
		return makeAST(EMap(pairs));	
	default:
		return null;	
}) {
			var ` = blockStmts[blockStmts.length - 1].expr;
			if (enumIndex ` == 1) {
				var ` = `[0];
				{
					var retVar = `;
					if (retVar.name == tempName) {
						return {
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EMap(pairs), metadata : {}, pos : pos};
						};
					} else {
						return null;
					};
				};
			} else {
				return null;
			};
		};
	}

	static function isEmptyCaseBody(body:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.builders.PatternBuilder.isEmptyCaseBody(body);
	}

	static function computePatternKey(pattern:reflaxe.elixir.ast.EPattern) {
		return reflaxe.elixir.ast.builders.PatternBuilder.computePatternKey(pattern);
	}

	static function extractBoundVariables(pattern:reflaxe.elixir.ast.EPattern) {
		return reflaxe.elixir.ast.builders.PatternBuilder.extractBoundVariables(pattern);
	}

	static inline function processLoopIntent(intent:reflaxe.elixir.ast.intent.LoopIntent, metadata:reflaxe.elixir.ast.intent.LoopIntentMetadata, context:reflaxe.elixir.CompilationContext) {
		return reflaxe.elixir.ast.LoopHelpers.processLoopIntent(intent, metadata, context);
	}

	static inline function buildMapIteration(pattern:reflaxe.elixir.ast.optimizers.MapIterationPattern, context:reflaxe.elixir.CompilationContext) {
		return reflaxe.elixir.ast.LoopHelpers.buildMapIteration(pattern, context);
	}

	static inline function analyzesAsExpression(expr:reflaxe.elixir.ast.intent.TypedExpr) {
		return reflaxe.elixir.ast.LoopHelpers.analyzesAsExpression(expr);
	}
}