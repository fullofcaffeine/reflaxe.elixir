class reflaxe.elixir.ast.transformers.TempVariableTransforms {

	public static function inlineTempBindingInExprPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var replaceVar = function(node:reflaxe.elixir.ast.ElixirAST, name:String, replacement:reflaxe.elixir.ast.ElixirAST) {
			return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				return @:ast(switch (n.def) {
	case EVar(v) if (v == name):
		makeAST(EParen(replacement));	
	case _:
		n;	
}) {
					var ` = n.def;
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var v = `;
							if (v == name) {
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EParen(replacement), metadata : {}, pos : pos};
								};
							} else {
								n;
							};
						};
					} else {
						n;
					};
				};
			});
		};
		var containsVar = function(node:reflaxe.elixir.ast.ElixirAST, varName:String) {
			var found = [false];
			reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(node, function(n:reflaxe.elixir.ast.ElixirAST) {
				@:ast(switch (n.def) {
	case EVar(v) if (v == varName):
		found = true;	
	default:
}) {
					var ` = n.def;
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var v = `;
							if (v == varName) {
								found[0] = true;
							} else {};
						};
					} else {};
				};
			});
			return found[0];
		};
		var isInExpressionContext = function(parent:reflaxe.elixir.ast.ElixirAST, child:reflaxe.elixir.ast.ElixirAST) {
			if (parent == null) {
				return false;
			};
			return @:ast(switch (parent.def) {
	case EMap(pairs):
		true;	
	case EKeywordList(pairs):
		true;	
	case ECall(_, _, _):
		true;	
	case EBinary(_, _, _):
		true;	
	case EUnary(_, _):
		true;	
	case EParen(_):
		true;	
	case EList(_):
		true;	
	case ETuple(_):
		true;	
	case EMatch(_, _):
		true;	
	case ECase(_, clauses):
		false;	
	case EDef(_, _, _, _):
		false;	
	case EDefp(_, _, _, _):
		false;	
	case EDefmodule(_, _):
		false;	
	case EBlock(_):
		false;	
	case EIf(_, _, _):
		false;	
	case ECond(clauses):
		false;	
	default:
		false;	
}) {
				var ` = parent.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							false;
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							false;
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							false;
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var clauses = `;
							{
								false;
							};
						};
					};
					case 7: {
						var ` = `[0];
						{
							var clauses = `;
							{
								false;
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							true;
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							false;
						};
					};
					case 15: {
						var ` = `[0];
						{
							true;
						};
					};
					case 16: {
						var ` = `[0];
						{
							true;
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								true;
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								true;
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							true;
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							true;
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							true;
						};
					};
					case 53: {
						var ` = `[0];
						{
							false;
						};
					};
					case 54: {
						var ` = `[0];
						{
							true;
						};
					};
					default: {
						false;
					}
				};
			};
		};
		var parentOf = new haxe.ds.ObjectMap();
		var walk = [null];
		walk[0] = function(node:reflaxe.elixir.ast.ElixirAST, parent:Null<reflaxe.elixir.ast.ElixirAST>) {
			if (node == null) {
				return;
			};
			if (parent != null) {
				parentOf.set(node, parent);
			};
			@:ast(switch (node.def) {
	case EBlock(exprs):
		for (e  in  exprs) walk(e, node);	
	case ECall(target, method, args):
		walk(target, node);
		for (a  in  args) walk(a, node);	
	case EMap(pairs):
		for (p  in  pairs) walk(p.value, node);	
	case EKeywordList(pairs):
		for (p  in  pairs) walk(p.value, node);	
	case ETuple(values):
		for (v  in  values) walk(v, node);	
	case EList(items):
		for (i  in  items) walk(i, node);	
	case EBinary(op, left, right):
		walk(left, node);
		walk(right, node);	
	case EUnary(op, expr):
		walk(expr, node);	
	case ECase(expr, clauses):
		walk(expr, node);
		for (c  in  clauses) {
			if (c.guard != null) walk(c.guard, node);
			walk(c.body, node);
		};	
	case EIf(cond, thenB, elseB):
		walk(cond, node);
		walk(thenB, node);
		if (elseB != null) walk(elseB, node);	
	case ECond(clauses):
		for (c  in  clauses) {
			walk(c.condition, node);
			walk(c.body, node);
		};	
	case EDef(name, args, guards, body):
		if (guards != null) walk(guards, node);
		walk(body, node);	
	case EDefp(name, args, guards, body):
		if (guards != null) walk(guards, node);
		walk(body, node);	
	case EDefmodule(name, body):
		walk(body, node);	
	case EAssign(name):
	case EParen(expr):
		walk(expr, node);	
	case EMatch(pattern, expr):
		walk(expr, node);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var body = `;
							{
								walk[0](body, node);
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								if (guards != null) {
									walk[0](guards, node);
								};
								walk[0](body, node);
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								if (guards != null) {
									walk[0](guards, node);
								};
								walk[0](body, node);
							};
						};
					};
					case 6: {
						var ` = `[0];
						var ` = `[1];
						{
							var expr = `;
							var clauses = `;
							{
								walk[0](expr, node);
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										if (c.guard != null) {
											walk[0](c.guard, node);
										};
										walk[0](c.body, node);
									};
								};
							};
						};
					};
					case 7: {
						var ` = `[0];
						{
							var clauses = `;
							{
								{
									var ` = 0;
									while (` < clauses.length) {
										var c = clauses[`];
										++ `;
										walk[0](c.condition, node);
										walk[0](c.body, node);
									};
								};
							};
						};
					};
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var cond = `;
							var thenB = `;
							var elseB = `;
							{
								walk[0](cond, node);
								walk[0](thenB, node);
								if (elseB != null) {
									walk[0](elseB, node);
								};
							};
						};
					};
					case 15: {
						var ` = `[0];
						{
							var items = `;
							{
								{
									var ` = 0;
									while (` < items.length) {
										var i = items[`];
										++ `;
										walk[0](i, node);
									};
								};
							};
						};
					};
					case 16: {
						var ` = `[0];
						{
							var values = `;
							{
								{
									var ` = 0;
									while (` < values.length) {
										var v = values[`];
										++ `;
										walk[0](v, node);
									};
								};
							};
						};
					};
					case 17: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										walk[0](p.value, node);
									};
								};
							};
						};
					};
					case 20: {
						var ` = `[0];
						{
							var pairs = `;
							{
								{
									var ` = 0;
									while (` < pairs.length) {
										var p = pairs[`];
										++ `;
										walk[0](p.value, node);
									};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var method = `;
							var args = `;
							{
								walk[0](target, node);
								{
									var ` = 0;
									while (` < args.length) {
										var a = args[`];
										++ `;
										walk[0](a, node);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								walk[0](left, node);
								walk[0](right, node);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							{
								{
									var ` = 0;
									while (` < exprs.length) {
										var e = exprs[`];
										++ `;
										walk[0](e, node);
									};
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var expr = `;
							{
								walk[0](expr, node);
							};
						};
					};
					case 63: {
						var ` = `[0];
						{
							var name = `;
							{};
						};
					};
					default: {}
				};
			};
		};
		walk[0](ast, null);
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			var parent = if (parentOf.exists(node)) {
				parentOf.get(node);
			} else {
				null;
			};
			var inExpr = parent != null && isInExpressionContext(parent, node);
			var shouldCollapse = @:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length == 2):
		inExpr;	
	default:
		false;	
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length == 2) {
							inExpr;
						} else {
							false;
						};
					};
				} else {
					false;
				};
			};
			if (! shouldCollapse) {
				return node;
			};
			@:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length == 2):
		switch (exprs[0].def) {
			case EMatch(PVar(tmp), bindExpr):
				var second = exprs[1];
				if (containsVar(second, tmp)) {
					var shouldPreserve = switch (bindExpr.def) {
						case ECase(_):
							true;						
						case EBlock(exprs) if (exprs.length > 0):
							switch (exprs[exprs.length - 1].def) {
								case ECase(_):
									true;								
								default:
									false;								
							};						
						default:
							false;						
					};
					if (shouldPreserve) {
						return node;
					};
					var collapsed = replaceVar(second, tmp, bindExpr);
					return collapsed;
				};			
			default:
		};	
	default:
}) {
				var ` = node.def;
				if (enumIndex ` == 53) {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length == 2) {
							@:ast(switch (exprs[0].def) {
	case EMatch(PVar(tmp), bindExpr):
		var second = exprs[1];
		if (containsVar(second, tmp)) {
			var shouldPreserve = switch (bindExpr.def) {
				case ECase(_):
					true;				
				case EBlock(exprs) if (exprs.length > 0):
					switch (exprs[exprs.length - 1].def) {
						case ECase(_):
							true;						
						default:
							false;						
					};				
				default:
					false;				
			};
			if (shouldPreserve) {
				return node;
			};
			var collapsed = replaceVar(second, tmp, bindExpr);
			return collapsed;
		};	
	default:
}) {
								var ` = exprs[0].def;
								if (enumIndex ` == 8) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										{
											var tmp = `;
											var bindExpr = `;
											{
												var second = exprs[1];
												if (containsVar(second, tmp)) {
													var shouldPreserve = @:ast(switch (bindExpr.def) {
	case ECase(_):
		true;	
	case EBlock(exprs) if (exprs.length > 0):
		switch (exprs[exprs.length - 1].def) {
			case ECase(_):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
														var ` = bindExpr.def;
														switch (enumIndex `) {
															case 6: {
																var ` = `[0];
																var ` = `[1];
																{
																	true;
																};
															};
															case 53: {
																var ` = `[0];
																{
																	var exprs = `;
																	if (exprs.length > 0) {
																		@:ast(switch (exprs[exprs.length - 1].def) {
	case ECase(_):
		true;	
	default:
		false;	
}) {
																			var ` = exprs[exprs.length - 1].def;
																			if (enumIndex ` == 6) {
																				var ` = `[0];
																				var ` = `[1];
																				{
																					true;
																				};
																			} else {
																				false;
																			};
																		};
																	} else {
																		false;
																	};
																};
															};
															default: {
																false;
															}
														};
													};
													if (shouldPreserve) {
														return node;
													};
													var collapsed = replaceVar(second, tmp, bindExpr);
													return collapsed;
												};
											};
										};
									} else {};
								} else {};
							};
						} else {};
					};
				} else {};
			};
			return node;
		});
	}

	public static function tempAliasCleanupPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, reflaxe.elixir.ast.transformers.TempVariableTransforms.cleanupTempAliases);
	}

	static function cleanupTempAliases(node:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length >= 2):
		var newExprs = [];
		var i = 0;
		while (i < exprs.length) {
			if (i < exprs.length - 1) {
				switch (exprs[i].def) {
					case EMatch(PVar(varName), value) if (varName.indexOf("g_") == 0):
						var nextExpr = exprs[i + 1];
						if (isSingleUseOfVar(nextExpr, varName)) {
							var replaced = replaceVarWithValue(nextExpr, varName, value);
							newExprs.push(replaced);
							i += 2;
							continue;
						};					
					default:
				};
			};
			newExprs.push(exprs[i]);
			i++;
		};
		if (newExprs.length != exprs.length) {
			return makeAST(EBlock(newExprs));
		};	
	default:
}) {
			var ` = node.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					if (exprs.length >= 2) {
						var newExprs = [];
						var i = 0;
						while (i < exprs.length) {
							if (i < exprs.length - 1) {
								@:ast(switch (exprs[i].def) {
	case EMatch(PVar(varName), value) if (varName.indexOf("g_") == 0):
		var nextExpr = exprs[i + 1];
		if (isSingleUseOfVar(nextExpr, varName)) {
			var replaced = replaceVarWithValue(nextExpr, varName, value);
			newExprs.push(replaced);
			i += 2;
			continue;
		};	
	default:
}) {
									var ` = exprs[i].def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var varName = `;
												var value = `;
												if (varName.indexOf("g_", null) == 0) {
													var nextExpr = exprs[i + 1];
													if (reflaxe.elixir.ast.transformers.TempVariableTransforms.isSingleUseOfVar(nextExpr, varName)) {
														var replaced = reflaxe.elixir.ast.transformers.TempVariableTransforms.replaceVarWithValue(nextExpr, varName, value);
														newExprs.push(replaced);
														i += 2;
														continue;
													};
												} else {};
											};
										} else {};
									} else {};
								};
							};
							newExprs.push(exprs[i]);
							i ++;
						};
						if (newExprs.length != exprs.length) {
							return {
								var pos = null;
								{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(newExprs), metadata : {}, pos : pos};
							};
						};
					} else {};
				};
			} else {};
		};
		return node;
	}

	static function isSingleUseOfVar(expr:reflaxe.elixir.ast.ElixirAST, varName:String) {
		return @:ast(switch (expr.def) {
	case ECase(caseExpr, _):
		switch (caseExpr.def) {
			case EVar(v) if (v == varName):
				true;			
			default:
				false;			
		};	
	case ECall(_, _, args):
		args.length > 0 && switch (args[0].def) {
			case EVar(v) if (v == varName):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = expr.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var caseExpr = `;
						{
							@:ast(switch (caseExpr.def) {
	case EVar(v) if (v == varName):
		true;	
	default:
		false;	
}) {
								var ` = caseExpr.def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										if (v == varName) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var args = `;
						{
							args.length > 0 && @:ast(switch (args[0].def) {
	case EVar(v) if (v == varName):
		true;	
	default:
		false;	
}) {
								var ` = args[0].def;
								if (enumIndex ` == 38) {
									var ` = `[0];
									{
										var v = `;
										if (v == varName) {
											true;
										} else {
											false;
										};
									};
								} else {
									false;
								};
							};
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function replaceVarWithValue(expr:reflaxe.elixir.ast.ElixirAST, varName:String, value:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(expr, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EVar(v) if (v == varName):
		value;	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == varName) {
							value;
						} else {
							n;
						};
					};
				} else {
					n;
				};
			};
		});
	}

	public static function resolveClauseLocalsPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node.metadata != null && node.metadata.varIdToName != null) {
				var varIdToName = node.metadata.varIdToName;
				return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, function(inner:reflaxe.elixir.ast.ElixirAST) {
					@:ast(switch (inner.def) {
	case EVar(currentName):
		if (inner.metadata != null && inner.metadata.sourceVarId != null) {
			var sourceId = inner.metadata.sourceVarId;
			if (varIdToName.exists(sourceId)) {
				var newName = varIdToName.get(sourceId);
				return makeASTWithMeta(EVar(newName), inner.metadata, inner.pos);
			};
		};
		return inner;	
	default:
		return inner;	
}) {
						var ` = inner.def;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var currentName = `;
								{
									if (inner.metadata != null && inner.metadata.sourceVarId != null) {
										var sourceId = inner.metadata.sourceVarId;
										if (varIdToName.exists(sourceId)) {
											var newName = cast varIdToName.get(sourceId);
											return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(newName), metadata : inner.metadata, pos : inner.pos};
										};
									};
									return inner;
								};
							};
						} else {
							return inner;
						};
					};
				});
			};
			return node;
		});
	}

	public static function inlineIfTempAssignmentPass(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length == 2):
		switch (exprs[0].def) {
			case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
				switch (exprs[1].def) {
					case EIf(condition, thenBranch, elseBranch):
						if (containsTempVar(condition, tempVar)) {
							var newCondition = replaceTempVar(condition, tempVar, value);
							return makeAST(EIf(newCondition, thenBranch, elseBranch), node.pos);
						};					
					default:
				};			
			default:
		};	
	case EIf(condition, thenBranch, elseBranch):
		switch (condition.def) {
			case EBinary(op, left, right):
				var transformedLeft = switch (left.def) {
					case EParen(inner):
						switch (inner.def) {
							case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
								value;							
							default:
								left;							
						};					
					case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
						value;					
					default:
						left;					
				};
				if (transformedLeft != left) {
					var newCondition = makeAST(EBinary(op, transformedLeft, right), condition.pos);
					return makeAST(EIf(newCondition, thenBranch, elseBranch), node.pos);
				};			
			default:
		};	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								@:ast(switch (condition.def) {
	case EBinary(op, left, right):
		var transformedLeft = switch (left.def) {
			case EParen(inner):
				switch (inner.def) {
					case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
						value;					
					default:
						left;					
				};			
			case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
				value;			
			default:
				left;			
		};
		if (transformedLeft != left) {
			var newCondition = makeAST(EBinary(op, transformedLeft, right), condition.pos);
			return makeAST(EIf(newCondition, thenBranch, elseBranch), node.pos);
		};	
	default:
}) {
									var ` = condition.def;
									if (enumIndex ` == 26) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var op = `;
											var left = `;
											var right = `;
											{
												var transformedLeft = @:ast(switch (left.def) {
	case EParen(inner):
		switch (inner.def) {
			case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
				value;			
			default:
				left;			
		};	
	case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
		value;	
	default:
		left;	
}) {
													var ` = left.def;
													switch (enumIndex `) {
														case 8: {
															var ` = `[0];
															var ` = `[1];
															if (enumIndex ` == 0) {
																var ` = `[0];
																{
																	var tempVar = `;
																	var value = `;
																	if (reflaxe.elixir.ast.transformers.TempVariableTransforms.isTempVar(tempVar)) {
																		value;
																	} else {
																		left;
																	};
																};
															} else {
																left;
															};
														};
														case 54: {
															var ` = `[0];
															{
																var inner = `;
																{
																	@:ast(switch (inner.def) {
	case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
		value;	
	default:
		left;	
}) {
																		var ` = inner.def;
																		if (enumIndex ` == 8) {
																			var ` = `[0];
																			var ` = `[1];
																			if (enumIndex ` == 0) {
																				var ` = `[0];
																				{
																					var tempVar = `;
																					var value = `;
																					if (reflaxe.elixir.ast.transformers.TempVariableTransforms.isTempVar(tempVar)) {
																						value;
																					} else {
																						left;
																					};
																				};
																			} else {
																				left;
																			};
																		} else {
																			left;
																		};
																	};
																};
															};
														};
														default: {
															left;
														}
													};
												};
												if (transformedLeft != left) {
													var newCondition = {def : reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformedLeft, right), metadata : {}, pos : condition.pos};
													return {def : reflaxe.elixir.ast.ElixirASTDef.EIf(newCondition, thenBranch, elseBranch), metadata : {}, pos : node.pos};
												};
											};
										};
									} else {};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var exprs = `;
							if (exprs.length == 2) {
								@:ast(switch (exprs[0].def) {
	case EMatch(PVar(tempVar), value) if (isTempVar(tempVar)):
		switch (exprs[1].def) {
			case EIf(condition, thenBranch, elseBranch):
				if (containsTempVar(condition, tempVar)) {
					var newCondition = replaceTempVar(condition, tempVar, value);
					return makeAST(EIf(newCondition, thenBranch, elseBranch), node.pos);
				};			
			default:
		};	
	default:
}) {
									var ` = exprs[0].def;
									if (enumIndex ` == 8) {
										var ` = `[0];
										var ` = `[1];
										if (enumIndex ` == 0) {
											var ` = `[0];
											{
												var tempVar = `;
												var value = `;
												if (reflaxe.elixir.ast.transformers.TempVariableTransforms.isTempVar(tempVar)) {
													@:ast(switch (exprs[1].def) {
	case EIf(condition, thenBranch, elseBranch):
		if (containsTempVar(condition, tempVar)) {
			var newCondition = replaceTempVar(condition, tempVar, value);
			return makeAST(EIf(newCondition, thenBranch, elseBranch), node.pos);
		};	
	default:
}) {
														var ` = exprs[1].def;
														if (enumIndex ` == 10) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															{
																var condition = `;
																var thenBranch = `;
																var elseBranch = `;
																{
																	if (reflaxe.elixir.ast.transformers.TempVariableTransforms.containsTempVar(condition, tempVar)) {
																		var newCondition = reflaxe.elixir.ast.transformers.TempVariableTransforms.replaceTempVar(condition, tempVar, value);
																		return {def : reflaxe.elixir.ast.ElixirASTDef.EIf(newCondition, thenBranch, elseBranch), metadata : {}, pos : node.pos};
																	};
																};
															};
														} else {};
													};
												} else {};
											};
										} else {};
									} else {};
								};
							} else {};
						};
					};
					default: {}
				};
			};
			return node;
		});
	}

	static function isTempVar(name:String) {
		return new EReg("^g(_?\\d*)?$", "").match(name);
	}

	static function containsTempVar(ast:reflaxe.elixir.ast.ElixirAST, varName:String) {
		var found = [false];
		reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (n.def) {
	case EVar(v) if (v == varName):
		found = true;	
	default:
}) {
				var ` = n.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == varName) {
							found[0] = true;
						} else {};
					};
				} else {};
			};
		});
		return found[0];
	}

	static function replaceTempVar(ast:reflaxe.elixir.ast.ElixirAST, varName:String, replacement:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(n:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (n.def) {
	case EVar(v) if (v == varName):
		makeAST(EParen(replacement), n.pos);	
	default:
		n;	
}) {
				var ` = n.def;
				if (enumIndex ` == 38) {
					var ` = `[0];
					{
						var v = `;
						if (v == varName) {
							{def : reflaxe.elixir.ast.ElixirASTDef.EParen(replacement), metadata : {}, pos : n.pos};
						} else {
							n;
						};
					};
				} else {
					n;
				};
			};
		});
	}

	static function iterateAST(node:reflaxe.elixir.ast.ElixirAST, visitor:reflaxe.elixir.ast.ElixirAST -> Void) {
		if (node == null) {
			return;
		};
		visitor(node);
		@:ast(switch (node.def) {
	case EBlock(exprs):
		for (e  in  exprs) iterateAST(e, visitor);	
	case ECall(target, method, args):
		iterateAST(target, visitor);
		for (a  in  args) iterateAST(a, visitor);	
	case EMap(pairs):
		for (p  in  pairs) iterateAST(p.value, visitor);	
	case EKeywordList(pairs):
		for (p  in  pairs) iterateAST(p.value, visitor);	
	case ETuple(values):
		for (v  in  values) iterateAST(v, visitor);	
	case EList(items):
		for (i  in  items) iterateAST(i, visitor);	
	case EBinary(op, left, right):
		iterateAST(left, visitor);
		iterateAST(right, visitor);	
	case EUnary(op, expr):
		iterateAST(expr, visitor);	
	case ECase(expr, clauses):
		iterateAST(expr, visitor);
		for (c  in  clauses) {
			if (c.guard != null) iterateAST(c.guard, visitor);
			iterateAST(c.body, visitor);
		};	
	case EIf(cond, thenB, elseB):
		iterateAST(cond, visitor);
		iterateAST(thenB, visitor);
		if (elseB != null) iterateAST(elseB, visitor);	
	case ECond(clauses):
		for (c  in  clauses) {
			iterateAST(c.condition, visitor);
			iterateAST(c.body, visitor);
		};	
	case EDef(name, args, guards, body):
		if (guards != null) iterateAST(guards, visitor);
		iterateAST(body, visitor);	
	case EDefp(name, args, guards, body):
		if (guards != null) iterateAST(guards, visitor);
		iterateAST(body, visitor);	
	case EDefmodule(name, body):
		iterateAST(body, visitor);	
	case EParen(expr):
		iterateAST(expr, visitor);	
	case EMatch(pattern, expr):
		iterateAST(expr, visitor);	
	default:
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var name = `;
						var body = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(body, visitor);
						};
					};
				};
				case 2: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							if (guards != null) {
								reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(guards, visitor);
							};
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(body, visitor);
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					var ` = `[3];
					{
						var name = `;
						var args = `;
						var guards = `;
						var body = `;
						{
							if (guards != null) {
								reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(guards, visitor);
							};
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(body, visitor);
						};
					};
				};
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(expr, visitor);
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									if (c.guard != null) {
										reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(c.guard, visitor);
									};
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(c.body, visitor);
								};
							};
						};
					};
				};
				case 7: {
					var ` = `[0];
					{
						var clauses = `;
						{
							{
								var ` = 0;
								while (` < clauses.length) {
									var c = clauses[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(c.condition, visitor);
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(c.body, visitor);
								};
							};
						};
					};
				};
				case 8: {
					var ` = `[0];
					var ` = `[1];
					{
						var pattern = `;
						var expr = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(expr, visitor);
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenB = `;
						var elseB = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(cond, visitor);
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(thenB, visitor);
							if (elseB != null) {
								reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(elseB, visitor);
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var items = `;
						{
							{
								var ` = 0;
								while (` < items.length) {
									var i = items[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(i, visitor);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var values = `;
						{
							{
								var ` = 0;
								while (` < values.length) {
									var v = values[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(v, visitor);
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(p.value, visitor);
								};
							};
						};
					};
				};
				case 20: {
					var ` = `[0];
					{
						var pairs = `;
						{
							{
								var ` = 0;
								while (` < pairs.length) {
									var p = pairs[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(p.value, visitor);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var method = `;
						var args = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(target, visitor);
							{
								var ` = 0;
								while (` < args.length) {
									var a = args[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(a, visitor);
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(left, visitor);
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(right, visitor);
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(expr, visitor);
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							{
								var ` = 0;
								while (` < exprs.length) {
									var e = exprs[`];
									++ `;
									reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(e, visitor);
								};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var expr = `;
						{
							reflaxe.elixir.ast.transformers.TempVariableTransforms.iterateAST(expr, visitor);
						};
					};
				};
				default: {}
			};
		};
	}
}