class reflaxe.elixir.ast.transformers.LoopTransforms {

	static function transformChildrenManually(node:reflaxe.elixir.ast.ElixirAST, transformer:reflaxe.elixir.ast.ElixirAST -> reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (node.def) {
	case EIf(cond, thenBranch, elseBranch):
		return makeAST(EIf(transformer(cond), transformer(thenBranch), elseBranch != null ? transformer(elseBranch) : null));	
	case ECase(expr, clauses):
		return makeAST(ECase(transformer(expr), clauses.map(function(c) ->  @:implicitReturn return { pattern : c.pattern, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })));	
	case ECall(target, funcName, args):
		return makeAST(ECall(target != null ? transformer(target) : null, funcName, args.map(function(a) ->  @:implicitReturn return transformer(a))));	
	case ERemoteCall(module, funcName, args):
		return makeAST(ERemoteCall(transformer(module), funcName, args.map(function(a) ->  @:implicitReturn return transformer(a))));	
	case EList(elements):
		return makeAST(EList(elements.map(function(e) ->  @:implicitReturn return transformer(e))));	
	case ETuple(elements):
		return makeAST(ETuple(elements.map(function(e) ->  @:implicitReturn return transformer(e))));	
	case EMap(pairs):
		return makeAST(EMap(pairs.map(function(p) ->  @:implicitReturn return { key : transformer(p.key), value : transformer(p.value) })));	
	case EBinary(op, left, right):
		return makeAST(EBinary(op, transformer(left), transformer(right)));	
	case EUnary(op, expr):
		return makeAST(EUnary(op, transformer(expr)));	
	case EFn(clauses):
		return makeAST(EFn(clauses.map(function(c) ->  @:implicitReturn return { args : c.args, guard : c.guard != null ? transformer(c.guard) : null, body : transformer(c.body) })));	
	case EDo(body):
		return makeAST(EDo(body.map(function(stmt) ->  @:implicitReturn return transformer(stmt))));	
	case EVar(_) | EAtom(_) | EInteger(_) | EFloat(_) | EString(_) | ENil:
		return node;	
	default:
		return node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 6: {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ECase(transformer(expr), {
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({pattern : v.pattern, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var cond = `;
						var thenBranch = `;
						var elseBranch = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EIf(transformer(cond), transformer(thenBranch), if ((elseBranch != null)) transformer(elseBranch) else null);
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EList({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ETuple({
									var ` = [];
									{
										var ` = 0;
										var ` = elements;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EMap({
									var ` = [];
									{
										var ` = 0;
										var ` = pairs;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({key : transformer(v.key), value : transformer(v.value)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ECall(if ((target != null)) transformer(target) else null, funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var funcName = `;
						var args = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(transformer(module), funcName, {
									var ` = [];
									{
										var ` = 0;
										var ` = args;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EBinary(op, transformer(left), transformer(right));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 27: {
					var ` = `[0];
					var ` = `[1];
					{
						var op = `;
						var expr = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EUnary(op, transformer(expr));
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 32: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 33: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 34: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 36: {
					{
						return node;
					};
				};
				case 38: {
					var ` = `[0];
					{
						return node;
					};
				};
				case 42: {
					var ` = `[0];
					{
						var clauses = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EFn({
									var ` = [];
									{
										var ` = 0;
										var ` = clauses;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push({args : v.args, guard : if ((v.guard != null)) transformer(v.guard) else null, body : transformer(v.body)});
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				case 55: {
					var ` = `[0];
					{
						var body = `;
						{
							return {
								var def = reflaxe.elixir.ast.ElixirASTDef.EDo({
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while ((` < `.length)) {
											var v = `[`];
											++ `;
											`.push(transformer(v));
										};
									};
									`;
								});
								var pos = null;
								{def : def, metadata : {}, pos : pos};
							};
						};
					};
				};
				default: {
					return node;
				}
			};
		};
	}

	@:value({ depth : 0, prefix : "" })
	static function dumpAST(ast:reflaxe.elixir.ast.ElixirAST, prefix:String = "", depth:Int = 0) {
		var indent = "";
		{
			var ` = 0;
			var ` = depth;
			while (` < `) {
				var i = ` ++;
				indent += "  ";
			};
		};
		@:ast(switch (ast.def) {
	case ERemoteCall(module, func, args):
		Sys.println(indent + prefix + "ERemoteCall:");
		Sys.println(indent + "  module: " + ElixirASTPrinter.print(module, 0));
		Sys.println(indent + "  func: " + func);
		Sys.println(indent + "  args (" + args.length + "):");
		for (i  in  0 ... args.length) {
			dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
		};	
	case ECall(target, func, args):
		Sys.println(indent + prefix + "ECall:");
		if (target != null) {
			Sys.println(indent + "  target: " + ElixirASTPrinter.print(target, 0));
		};
		Sys.println(indent + "  func: " + func);
		Sys.println(indent + "  args (" + args.length + "):");
		for (i  in  0 ... args.length) {
			dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
		};	
	case EString(s):
		Sys.println(indent + prefix + "EString: \"" + s + "\"");	
	case EBinary(op, left, right):
		Sys.println(indent + prefix + "EBinary: " + op);
		dumpAST(left, "left: ", depth + 1);
		dumpAST(right, "right: ", depth + 1);	
	case EVar(name):
		Sys.println(indent + prefix + "EVar: " + name);	
	case EInteger(n):
		Sys.println(indent + prefix + "EInteger: " + n);	
	case EFloat(f):
		Sys.println(indent + prefix + "EFloat: " + f);	
	case EAtom(a):
		Sys.println(indent + prefix + "EAtom: :" + a);	
	case EList(elements):
		Sys.println(indent + prefix + "EList (" + elements.length + " elements):");
		for (i  in  0 ... elements.length) {
			dumpAST(elements[i], "[" + i + "]: ", depth + 1);
		};	
	case ETuple(elements):
		Sys.println(indent + prefix + "ETuple (" + elements.length + " elements):");
		for (i  in  0 ... elements.length) {
			dumpAST(elements[i], "{" + i + "}: ", depth + 1);
		};	
	case EMap(pairs):
		Sys.println(indent + prefix + "EMap (" + pairs.length + " pairs):");
		for (i  in  0 ... pairs.length) {
			Sys.println(indent + "  pair[" + i + "]:");
			dumpAST(pairs[i].key, "key: ", depth + 2);
			dumpAST(pairs[i].value, "value: ", depth + 2);
		};	
	case EBlock(stmts):
		Sys.println(indent + prefix + "EBlock (" + stmts.length + " statements):");
		for (i  in  0 ... Std.int(Math.min(stmts.length, 5))) {
			dumpAST(stmts[i], "stmt[" + i + "]: ", depth + 1);
		};
		if (stmts.length > 5) {
			Sys.println(indent + "  ... and " + (stmts.length - 5) + " more statements");
		};	
	case ENil:
		Sys.println(indent + prefix + "ENil");	
	default:
		Sys.println(indent + prefix + "AST Node: " + Type.enumConstructor(ast.def));	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 15: {
					var ` = `[0];
					{
						var elements = `;
						{
							Sys.println(indent + prefix + "EList (" + elements.length + " elements):");
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(elements[i], "[" + i + "]: ", depth + 1);
								};
							};
						};
					};
				};
				case 16: {
					var ` = `[0];
					{
						var elements = `;
						{
							Sys.println(indent + prefix + "ETuple (" + elements.length + " elements):");
							{
								var ` = 0;
								var ` = elements.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(elements[i], "{" + i + "}: ", depth + 1);
								};
							};
						};
					};
				};
				case 17: {
					var ` = `[0];
					{
						var pairs = `;
						{
							Sys.println(indent + prefix + "EMap (" + pairs.length + " pairs):");
							{
								var ` = 0;
								var ` = pairs.length;
								while (` < `) {
									var i = ` ++;
									Sys.println(indent + "  pair[" + i + "]:");
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(pairs[i].key, "key: ", depth + 2);
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(pairs[i].value, "value: ", depth + 2);
								};
							};
						};
					};
				};
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var func = `;
						var args = `;
						{
							Sys.println(indent + prefix + "ECall:");
							if (target != null) {
								Sys.println(indent + "  target: " + reflaxe.elixir.ast.ElixirASTPrinter.print(target, 0));
							};
							Sys.println(indent + "  func: " + func);
							Sys.println(indent + "  args (" + args.length + "):");
							{
								var ` = 0;
								var ` = args.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
								};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var module = `;
						var func = `;
						var args = `;
						{
							Sys.println(indent + prefix + "ERemoteCall:");
							Sys.println(indent + "  module: " + reflaxe.elixir.ast.ElixirASTPrinter.print(module, 0));
							Sys.println(indent + "  func: " + func);
							Sys.println(indent + "  args (" + args.length + "):");
							{
								var ` = 0;
								var ` = args.length;
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(args[i], "arg[" + i + "]: ", depth + 2);
								};
							};
						};
					};
				};
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var op = `;
						var left = `;
						var right = `;
						{
							Sys.println(indent + prefix + "EBinary: " + Std.string(op));
							reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(left, "left: ", depth + 1);
							reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(right, "right: ", depth + 1);
						};
					};
				};
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							Sys.println(indent + prefix + "EAtom: :" + a);
						};
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							Sys.println(indent + prefix + "EString: \"" + s + "\"");
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var n = `;
						{
							Sys.println(indent + prefix + "EInteger: " + n);
						};
					};
				};
				case 34: {
					var ` = `[0];
					{
						var f = `;
						{
							Sys.println(indent + prefix + "EFloat: " + f);
						};
					};
				};
				case 36: {
					{
						Sys.println(indent + prefix + "ENil");
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							Sys.println(indent + prefix + "EVar: " + name);
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						{
							Sys.println(indent + prefix + "EBlock (" + stmts.length + " statements):");
							{
								var ` = 0;
								var ` = Std.int(Math.min(stmts.length, 5));
								while (` < `) {
									var i = ` ++;
									reflaxe.elixir.ast.transformers.LoopTransforms.dumpAST(stmts[i], "stmt[" + i + "]: ", depth + 1);
								};
							};
							if (stmts.length > 5) {
								Sys.println(indent + "  ... and " + (stmts.length - 5) + " more statements");
							};
						};
					};
				};
				default: {
					Sys.println(indent + prefix + "AST Node: " + Type.enumConstructor(ast.def));
				}
			};
		};
	}

	public static function unrolledLoopTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		Sys.println("[XRay LoopTransforms] ============ UNROLLED LOOP TRANSFORM STARTED ============");
		var detectAndTransformUnrolledLoops = [null];
		detectAndTransformUnrolledLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case EModule(name, attributes, body):
		trace("[XRay LoopTransforms] Found EModule: $name with ${body.length} body items");
		var transformedBody = body.map(function(b) ->  @:implicitReturn return detectAndTransformUnrolledLoops(b));
		return makeAST(EModule(name, attributes, transformedBody));	
	case EDefmodule(name, doBlock):
		trace("[XRay LoopTransforms] Found EDefmodule: $name");
		var transformedBlock = detectAndTransformUnrolledLoops(doBlock);
		return makeAST(EDefmodule(name, transformedBlock));	
	case EDef(name, args, guards, body):
		trace("[XRay LoopTransforms] Found EDef (public function): $name");
		var transformedBody = detectAndTransformUnrolledLoops(body);
		return makeAST(EDef(name, args, guards, transformedBody));	
	case EDefp(name, args, guards, body):
		trace("[XRay LoopTransforms] Found EDefp (private function): $name");
		var transformedBody = detectAndTransformUnrolledLoops(body);
		return makeAST(EDefp(name, args, guards, transformedBody));	
	case EBlock(stmts):
		if (stmts.length > 2) {
			Sys.println("[XRay LoopTransforms] Found EBlock with " + stmts.length + " statements");
			var maxToShow = stmts.length < 3 ? stmts.length : 3;
			for (i  in  0 ... maxToShow) {
				Sys.println("[XRay LoopTransforms]   Statement " + i + " type: " + stmts[i].def);
			};
		};
		var nestedUnrolledLoop = detectNestedUnrolledLoop(stmts);
		if (nestedUnrolledLoop != null) {
			trace("[XRay LoopTransforms] ✅ DETECTED NESTED UNROLLED LOOP - transforming to nested Enum.each");
			return nestedUnrolledLoop;
		};
		var nestedLoop = NestedLoopDetector.detectNestedLoop(stmts);
		if (nestedLoop != null) {
			trace("[XRay LoopTransforms] ✅ DETECTED NESTED LOOP - transforming ${nestedLoop.count} statements");
			var remainingStmts = stmts.slice(nestedLoop.count);
			if (remainingStmts.length > 0) {
				trace("[XRay LoopTransforms] Processing ${remainingStmts.length} remaining statements after nested loop");
				var remainingUnrolled = detectUnrolledLoop(remainingStmts);
				if (remainingUnrolled != null) {
					trace("[XRay LoopTransforms] ✅ Remaining statements form an unrolled loop!");
					return makeAST(EBlock([nestedLoop.transformed, remainingUnrolled]));
				};
				var processedRemaining = remainingStmts.map(function(stmt) ->  @:implicitReturn return detectAndTransformUnrolledLoops(stmt));
				return makeAST(EBlock([nestedLoop.transformed].concat(processedRemaining)));
			};
			return nestedLoop.transformed;
		};
		var unrolledLoop = detectUnrolledLoop(stmts);
		if (unrolledLoop != null) {
			trace("[XRay LoopTransforms] ✅ DETECTED UNROLLED LOOP - transforming ${stmts.length} statements");
			return unrolledLoop;
		} else {
			trace("[XRay LoopTransforms] ❌ Not an unrolled loop pattern");
		};
		var transformedStmts = stmts.map(function(stmt) ->  @:implicitReturn return detectAndTransformUnrolledLoops(stmt));
		return makeAST(EBlock(transformedStmts));	
	default:
		return transformChildrenManually(node, detectAndTransformUnrolledLoops);	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 0: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var name = `;
							var attributes = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EModule: " + name + " with " + body.length + " body items", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 276, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = {
									var ` = [];
									{
										var ` = 0;
										var ` = body;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(b:reflaxe.elixir.ast.ElixirAST) {
												return detectAndTransformUnrolledLoops[0](b);
											}(v));
										};
									};
									`;
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EModule(name, attributes, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 1: {
						var ` = `[0];
						var ` = `[1];
						{
							var name = `;
							var doBlock = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDefmodule: " + name, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 281, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBlock = detectAndTransformUnrolledLoops[0](doBlock);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefmodule(name, transformedBlock), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 2: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDef (public function): " + name, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 287, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = detectAndTransformUnrolledLoops[0](body);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDef(name, args, guards, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 3: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						var ` = `[3];
						{
							var name = `;
							var args = `;
							var guards = `;
							var body = `;
							{
								haxe.Log.trace("[XRay LoopTransforms] Found EDefp (private function): " + name, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 292, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								var transformedBody = detectAndTransformUnrolledLoops[0](body);
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EDefp(name, args, guards, transformedBody), metadata : {}, pos : pos};
								};
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								if (stmts.length > 2) {
									Sys.println("[XRay LoopTransforms] Found EBlock with " + stmts.length + " statements");
									var maxToShow = if (stmts.length < 3) {
										stmts.length;
									} else {
										3;
									};
									{
										var ` = 0;
										var ` = maxToShow;
										while (` < `) {
											var i = ` ++;
											Sys.println("[XRay LoopTransforms]   Statement " + i + " type: " + Std.string(stmts[i].def));
										};
									};
								};
								var nestedUnrolledLoop = reflaxe.elixir.ast.transformers.LoopTransforms.detectNestedUnrolledLoop(stmts);
								if (nestedUnrolledLoop != null) {
									haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED NESTED UNROLLED LOOP - transforming to nested Enum.each", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 311, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
									return nestedUnrolledLoop;
								};
								var nestedLoop = reflaxe.elixir.ast.transformers.NestedLoopDetector.detectNestedLoop(stmts);
								if (nestedLoop != null) {
									haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED NESTED LOOP - transforming " + nestedLoop.count + " statements", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 318, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
									var remainingStmts = stmts.slice(nestedLoop.count, null);
									if (remainingStmts.length > 0) {
										haxe.Log.trace("[XRay LoopTransforms] Processing " + remainingStmts.length + " remaining statements after nested loop", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 322, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
										var remainingUnrolled = reflaxe.elixir.ast.transformers.LoopTransforms.detectUnrolledLoop(remainingStmts);
										if (remainingUnrolled != null) {
											haxe.Log.trace("[XRay LoopTransforms] ✅ Remaining statements form an unrolled loop!", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 327, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
											return {
												var pos = null;
												{def : reflaxe.elixir.ast.ElixirASTDef.EBlock([nestedLoop.transformed, remainingUnrolled]), metadata : {}, pos : pos};
											};
										};
										var processedRemaining = {
											var ` = [];
											{
												var ` = 0;
												var ` = remainingStmts;
												while (` < `.length) {
													var v = `[`];
													++ `;
													`.push(function(stmt:reflaxe.elixir.ast.ElixirAST) {
														return detectAndTransformUnrolledLoops[0](stmt);
													}(v));
												};
											};
											`;
										};
										return {
											var def = reflaxe.elixir.ast.ElixirASTDef.EBlock([nestedLoop.transformed].concat(processedRemaining));
											var pos = null;
											{def : def, metadata : {}, pos : pos};
										};
									};
									return nestedLoop.transformed;
								};
								var unrolledLoop = reflaxe.elixir.ast.transformers.LoopTransforms.detectUnrolledLoop(stmts);
								if (unrolledLoop != null) {
									haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED UNROLLED LOOP - transforming " + stmts.length + " statements", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 341, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
									return unrolledLoop;
								} else {
									haxe.Log.trace("[XRay LoopTransforms] ❌ Not an unrolled loop pattern", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 344, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "unrolledLoopTransformPass"});
								};
								var transformedStmts = {
									var ` = [];
									{
										var ` = 0;
										var ` = stmts;
										while (` < `.length) {
											var v = `[`];
											++ `;
											`.push(function(stmt:reflaxe.elixir.ast.ElixirAST) {
												return detectAndTransformUnrolledLoops[0](stmt);
											}(v));
										};
									};
									`;
								};
								return {
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedStmts), metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						return reflaxe.elixir.ast.transformers.LoopTransforms.transformChildrenManually(node, detectAndTransformUnrolledLoops[0]);
					}
				};
			};
		};
		return detectAndTransformUnrolledLoops[0](ast);
	}

	static function detectNestedUnrolledLoop(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (stmts.length < 4) {
			return null;
		};
		var outerStatements = [];
		var innerLoops = [];
		var expectedIndex = 0;
		var i = 0;
		while (i < stmts.length - 1) {
			var stmt = stmts[i];
			var nextStmt = stmts[i + 1];
			var isEnumEach = reflaxe.elixir.ast.transformers.LoopTransforms.isEnumEachCall(nextStmt);
			if (! isEnumEach) {
				return null;
			};
			if (! reflaxe.elixir.ast.transformers.LoopTransforms.containsIndex(stmt, expectedIndex)) {
				return null;
			};
			outerStatements.push(stmt);
			innerLoops.push(nextStmt);
			expectedIndex ++;
			i += 2;
		};
		if (outerStatements.length < 2) {
			return null;
		};
		return reflaxe.elixir.ast.transformers.LoopTransforms.reconstructNestedLoop(outerStatements, innerLoops);
	}

	static function isEnumEachCall(ast:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (ast.def) {
	case ERemoteCall(module, func, _):
		switch (module.def) {
			case EAtom(atom):
				var atomStr:String = atom;
				atomStr == "Enum" && func == "each";			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = ast.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var module = `;
					var func = `;
					{
						@:ast(switch (module.def) {
	case EAtom(atom):
		var atomStr:String = atom;
		atomStr == "Enum" && func == "each";	
	default:
		false;	
}) {
							var ` = module.def;
							if (enumIndex ` == 31) {
								var ` = `[0];
								{
									var atom = `;
									{
										var atomStr = atom;
										atomStr == "Enum" && func == "each";
									};
								};
							} else {
								false;
							};
						};
					};
				};
			} else {
				false;
			};
		};
	}

	static function containsIndex(ast:reflaxe.elixir.ast.ElixirAST, index:Int) {
		var indexStr = Std.string(index);
		var checkAST = [null];
		checkAST[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EInteger(i):
		i == index;	
	case EString(s):
		s.indexOf(indexStr) >= 0;	
	case ERemoteCall(_, _, args):
		Lambda.exists(args, function(a) ->  @:implicitReturn return checkAST(a));	
	case ECall(_, _, args):
		Lambda.exists(args, function(a) ->  @:implicitReturn return checkAST(a));	
	case EBlock(stmts):
		Lambda.exists(stmts, function(s) ->  @:implicitReturn return checkAST(s));	
	case EList(elements):
		Lambda.exists(elements, function(e) ->  @:implicitReturn return checkAST(e));	
	default:
		false;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 15: {
						var ` = `[0];
						{
							var elements = `;
							{
								Lambda.exists(elements, function(e:reflaxe.elixir.ast.ElixirAST) return checkAST[0](e));
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var args = `;
							{
								Lambda.exists(args, function(a:reflaxe.elixir.ast.ElixirAST) return checkAST[0](a));
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var args = `;
							{
								Lambda.exists(args, function(a:reflaxe.elixir.ast.ElixirAST) return checkAST[0](a));
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								s.indexOf(indexStr, null) >= 0;
							};
						};
					};
					case 33: {
						var ` = `[0];
						{
							var i = `;
							{
								i == index;
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								Lambda.exists(stmts, function(s:reflaxe.elixir.ast.ElixirAST) return checkAST[0](s));
							};
						};
					};
					default: {
						false;
					}
				};
			};
		};
		return checkAST[0](ast);
	}

	static function reconstructNestedLoop(outerStatements:Array<reflaxe.elixir.ast.ElixirAST>, innerLoops:Array<reflaxe.elixir.ast.ElixirAST>) {
		var count = outerStatements.length;
		var firstInnerLoop = innerLoops[0];
		var firstOuterStmt = outerStatements[0];
		var outerRange = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
			}, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(count - 1), metadata : {}, pos : pos};
			}, false), metadata : {}, pos : pos};
		};
		var bodyStatements = [];
		var substitutedOuterStmt = reflaxe.elixir.ast.transformers.LoopTransforms.substituteIndex(firstOuterStmt, 0, {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EVar("x"), metadata : {}, pos : pos};
		});
		bodyStatements.push(substitutedOuterStmt);
		bodyStatements.push(reflaxe.elixir.ast.transformers.LoopTransforms.makeVariableSubstitutedLoop(firstInnerLoop, "x"));
		var functionBody = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(bodyStatements), metadata : {}, pos : pos};
		};
		var fnClause = {args : [reflaxe.elixir.ast.EPattern.PVar("x")], guard : null, body : functionBody};
		var outerFunction = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([fnClause]), metadata : {}, pos : pos};
		};
		var enumAtom = {
			var this;
			this = reflaxe.elixir.ast.NameUtils.toSnakeCase("Enum");
			cast cast this;
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(enumAtom), metadata : {}, pos : pos};
			}, "each", [outerRange, outerFunction]), metadata : {}, pos : pos};
		};
	}

	static function substituteIndex(ast:reflaxe.elixir.ast.ElixirAST, oldIndex:Int, newVar:reflaxe.elixir.ast.ElixirAST) {
		var indexStr = Std.string(oldIndex);
		var substitute = [null];
		substitute[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EInteger(i) if (i == oldIndex):
		newVar;	
	case EString(s) if (s.indexOf(indexStr) >= 0):
		makeAST(EString(s.split(indexStr).join("#{x}")));	
	case ERemoteCall(module, func, args):
		makeAST(ERemoteCall(module, func, args.map(function(a) ->  @:implicitReturn return substitute(a))));	
	case ECall(target, func, args):
		makeAST(ECall(target, func, args.map(function(a) ->  @:implicitReturn return substitute(a))));	
	case EBlock(stmts):
		makeAST(EBlock(stmts.map(function(s) ->  @:implicitReturn return substitute(s))));	
	case EList(elements):
		makeAST(EList(elements.map(function(e) ->  @:implicitReturn return substitute(e))));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 15: {
						var ` = `[0];
						{
							var elements = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EList({
										var ` = [];
										{
											var ` = 0;
											var ` = elements;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, {
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var func = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, func, {
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var s = `;
							if (s.indexOf(indexStr, null) >= 0) {
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EString(s.split(indexStr).join("#{x}"));
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							} else {
								node;
							};
						};
					};
					case 33: {
						var ` = `[0];
						{
							var i = `;
							if (i == oldIndex) {
								newVar;
							} else {
								node;
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
										var ` = [];
										{
											var ` = 0;
											var ` = stmts;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		};
		return substitute[0](ast);
	}

	static function makeVariableSubstitutedLoop(innerLoop:reflaxe.elixir.ast.ElixirAST, outerVar:String) {
		return @:ast(switch (innerLoop.def) {
	case ERemoteCall(module, func, args) if (func == "each" && args.length >= 2):
		var substitutedArgs = args.copy();
		if (args.length >= 2) {
			substitutedArgs[1] = substituteInFunction(args[1], outerVar);
		};
		makeAST(ERemoteCall(module, func, substitutedArgs));	
	default:
		innerLoop;	
}) {
			var ` = innerLoop.def;
			if (enumIndex ` == 24) {
				var ` = `[0];
				var ` = `[1];
				var ` = `[2];
				{
					var module = `;
					var func = `;
					var args = `;
					if (func == "each" && args.length >= 2) {
						var substitutedArgs = args.copy();
						if (args.length >= 2) {
							substitutedArgs[1] = reflaxe.elixir.ast.transformers.LoopTransforms.substituteInFunction(args[1], outerVar);
						};
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, func, substitutedArgs), metadata : {}, pos : pos};
						};
					} else {
						innerLoop;
					};
				};
			} else {
				innerLoop;
			};
		};
	}

	static function substituteInFunction(fnAst:reflaxe.elixir.ast.ElixirAST, outerVar:String) {
		return @:ast(switch (fnAst.def) {
	case EFn(clauses):
		var newClauses = clauses.map(function(clause) ->  @:implicitReturn return {
			var newBody = substituteOuterIndex(clause.body, outerVar);
			{ args : clause.args, guard : clause.guard, body : newBody };
		});
		makeAST(EFn(newClauses));	
	default:
		fnAst;	
}) {
			var ` = fnAst.def;
			if (enumIndex ` == 42) {
				var ` = `[0];
				{
					var clauses = `;
					{
						var newClauses = {
							var ` = [];
							{
								var ` = 0;
								var ` = clauses;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(function(clause:reflaxe.elixir.ast.EFnClause) {
										return {
											var newBody = reflaxe.elixir.ast.transformers.LoopTransforms.substituteOuterIndex(clause.body, outerVar);
											{args : clause.args, guard : clause.guard, body : newBody};
										};
									}(v));
								};
							};
							`;
						};
						{
							var pos = null;
							{def : reflaxe.elixir.ast.ElixirASTDef.EFn(newClauses), metadata : {}, pos : pos};
						};
					};
				};
			} else {
				fnAst;
			};
		};
	}

	static function substituteOuterIndex(ast:reflaxe.elixir.ast.ElixirAST, outerVar:String) {
		var substitute = [null];
		substitute[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			return @:ast(switch (node.def) {
	case EString(s) if (s.indexOf("#{0}") >= 0 || s.indexOf("#{1}") >= 0 || s.indexOf("#{2}") >= 0):
		var newStr = s;
		for (i  in  0 ... 3) {
			var searchPattern = "#{$i}";
			var replacePattern = "#{$outerVar}";
			newStr = newStr.split(searchPattern).join(replacePattern);
		};
		makeAST(EString(newStr));	
	case ERemoteCall(module, func, args):
		makeAST(ERemoteCall(module, func, args.map(function(a) ->  @:implicitReturn return substitute(a))));	
	case ECall(target, func, args):
		makeAST(ECall(target, func, args.map(function(a) ->  @:implicitReturn return substitute(a))));	
	case EBlock(stmts):
		makeAST(EBlock(stmts.map(function(s) ->  @:implicitReturn return substitute(s))));	
	default:
		node;	
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var func = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ECall(target, func, {
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var module = `;
							var func = `;
							var args = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, func, {
										var ` = [];
										{
											var ` = 0;
											var ` = args;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					case 32: {
						var ` = `[0];
						{
							var s = `;
							if (s.indexOf("#{0}", null) >= 0 || s.indexOf("#{1}", null) >= 0 || s.indexOf("#{2}", null) >= 0) {
								var newStr = s;
								{
									{
										var searchPattern = "#{" + 0 + "}";
										var replacePattern = "#{" + outerVar + "}";
										newStr = newStr.split(searchPattern).join(replacePattern);
									};
									{
										var searchPattern = "#{" + 1 + "}";
										var replacePattern = "#{" + outerVar + "}";
										newStr = newStr.split(searchPattern).join(replacePattern);
									};
									{
										var searchPattern = "#{" + 2 + "}";
										var replacePattern = "#{" + outerVar + "}";
										newStr = newStr.split(searchPattern).join(replacePattern);
									};
								};
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.EString(newStr), metadata : {}, pos : pos};
								};
							} else {
								node;
							};
						};
					};
					case 53: {
						var ` = `[0];
						{
							var stmts = `;
							{
								{
									var def = reflaxe.elixir.ast.ElixirASTDef.EBlock({
										var ` = [];
										{
											var ` = 0;
											var ` = stmts;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												`.push(substitute[0](v));
											};
										};
										`;
									});
									var pos = null;
									{def : def, metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						node;
					}
				};
			};
		};
		return substitute[0](ast);
	}

	static function detectUnrolledLoop(stmts:Array<reflaxe.elixir.ast.ElixirAST>) {
		if (stmts.length < 2) {
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] detectUnrolledLoop: Analyzing " + stmts.length + " statements for unrolled patterns", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 633, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
		var i = 0;
		var transformedStmts = [];
		while (i < stmts.length) {
			var loopGroup = reflaxe.elixir.ast.transformers.LoopTransforms.detectLoopGroup(stmts, i);
			if (loopGroup != null) {
				haxe.Log.trace("[XRay LoopTransforms] ✅ Found loop group at position " + i + " with " + loopGroup.count + " iterations", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 644, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
				transformedStmts.push(loopGroup.transformed);
				i += loopGroup.count;
			} else {
				transformedStmts.push(stmts[i]);
				i ++;
			};
		};
		if (transformedStmts.length != stmts.length) {
			haxe.Log.trace("[XRay LoopTransforms] Transformed block: " + stmts.length + " statements → " + transformedStmts.length + " statements", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 656, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
			return {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EBlock(transformedStmts), metadata : {}, pos : pos};
			};
		};
		haxe.Log.trace("[XRay LoopTransforms] No unrolled loops detected in block", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 660, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectUnrolledLoop"});
		return null;
	}

	static function detectLoopGroup(stmts:Array<reflaxe.elixir.ast.ElixirAST>, startIdx:Int) {
		if (startIdx >= stmts.length) {
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] detectLoopGroup: Called with startIdx=" + startIdx + ", total stmts=" + stmts.length, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 671, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		var firstCall = reflaxe.elixir.ast.transformers.LoopTransforms.extractFunctionCall(stmts[startIdx]);
		if (firstCall == null) {
			haxe.Log.trace("[XRay LoopTransforms]   No function call at index " + startIdx, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 675, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] detectLoopGroup: Checking from index " + startIdx + ", first call: " + firstCall.module + "." + firstCall.func, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 679, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		if (firstCall.args.length > 0) {
			haxe.Log.trace("[XRay LoopTransforms]   First arg type: " + Std.string(firstCall.args[0].def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 681, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		};
		var count = 0;
		var expectedIndex = 0;
		{
			var ` = startIdx;
			var ` = stmts.length;
			while (` < `) {
				var i = ` ++;
				var call = reflaxe.elixir.ast.transformers.LoopTransforms.extractFunctionCall(stmts[i]);
				if (call == null) {
					haxe.Log.trace("[XRay LoopTransforms]   Statement " + i + " is not a function call, stopping", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 693, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
					break;
				};
				if (call.module != firstCall.module || call.func != firstCall.func) {
					haxe.Log.trace("[XRay LoopTransforms]   Statement " + i + " has different function (" + call.module + "." + call.func + "), stopping", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 698, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
					break;
				};
				if (call.args.length > 0) {
					haxe.Log.trace("[XRay LoopTransforms]   Checking for index " + expectedIndex + " in arg: " + Std.string(call.args[0].def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 704, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
					var hasExpectedIndex = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(call.args[0], expectedIndex);
					if (! hasExpectedIndex) {
						haxe.Log.trace("[XRay LoopTransforms]   No index " + expectedIndex + " found, stopping", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 707, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
						break;
					};
					haxe.Log.trace("[XRay LoopTransforms]   ✓ Statement " + i + " matches with index " + expectedIndex, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 711, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
				};
				count ++;
				expectedIndex ++;
			};
		};
		if (count < 2) {
			haxe.Log.trace("[XRay LoopTransforms] detectLoopGroup: Only " + count + " matching statements, not enough for a loop", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 720, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
			return null;
		};
		haxe.Log.trace("[XRay LoopTransforms] ✅ DETECTED LOOP GROUP: " + firstCall.module + "." + firstCall.func + " with " + count + " iterations", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 724, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
		var transformed = reflaxe.elixir.ast.transformers.LoopTransforms.transformToEnumEach(firstCall, count);
		if (transformed == null) {
			haxe.Log.trace("[XRay LoopTransforms] Transformation was skipped - keeping original unrolled statements", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 732, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "detectLoopGroup"});
			return null;
		};
		return {transformed : transformed, count : count};
	}

	static function checkForIndex(ast:reflaxe.elixir.ast.ElixirAST, expectedIndex:Int) {
		haxe.Log.trace("[XRay LoopTransforms] checkForIndex: Looking for index " + expectedIndex + " in " + Std.string(ast.def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 747, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
		@:ast(switch (ast.def) {
	case EString(s):
		var exactPattern = "Iteration " + expectedIndex;
		if (s == exactPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT match found: \"" + s + "\"");
			return true;
		};
		var interpolationPattern = "Iteration #{" + expectedIndex + "}";
		if (s == interpolationPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT interpolation match: \"" + s + "\"");
			return true;
		};
		var placeholderPattern = "#{" + expectedIndex + "}";
		if (s == placeholderPattern) {
			trace("[XRay LoopTransforms]   ✓ EXACT placeholder match: \"" + s + "\"");
			return true;
		};
		var indexStr = Std.string(expectedIndex);
		if (s == indexStr) {
			trace("[XRay LoopTransforms]   ✓ EXACT index string match: \"" + s + "\"");
			return true;
		};
		var indexPattern = "Index: " + expectedIndex;
		if (s == indexPattern || s.indexOf(indexPattern) != -1) {
			trace("[XRay LoopTransforms]   ✓ Found \"Index: " + expectedIndex + "\" pattern in: \"" + s + "\"");
			return true;
		};
		if (s.indexOf(exactPattern) != -1 || s.indexOf(interpolationPattern) != -1 || s.indexOf(placeholderPattern) != -1) {
			trace("[XRay LoopTransforms]   ✓ Found index via contains fallback in: \"" + s + "\"");
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ No match in string: \"" + s + "\"");
		return false;	
	case EBinary(StringConcat, left, right):
		var leftHas = checkForIndex(left, expectedIndex);
		var rightHas = checkForIndex(right, expectedIndex);
		if (leftHas || rightHas) {
			trace("[XRay LoopTransforms]   ✓ Found index in binary concat");
		};
		return leftHas || rightHas;	
	case EInteger(n):
		if (n == expectedIndex) {
			trace("[XRay LoopTransforms]   ✓ Found exact index as integer: " + n);
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ Integer " + n + " does not match expected " + expectedIndex);
		return false;	
	case EVar(name):
		var indexStr = Std.string(expectedIndex);
		if (name == indexStr || name == "i" + indexStr) {
			trace("[XRay LoopTransforms]   ✓ Found index in variable name: " + name);
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ Variable " + name + " does not match index");
		return false;	
	case ERaw(rawString):
		var indexStr = Std.string(expectedIndex);
		var patterns = ["Index: #{" + indexStr + "}", "Iteration #{" + indexStr + "}", "#{" + indexStr + "}", "Iteration " + indexStr, "Index: " + indexStr, "Value: #{" + indexStr + "}", "Pair: #{" + indexStr + "}"];
		for (pattern  in  patterns) {
			if (rawString.indexOf(pattern) != -1) {
				trace("[XRay LoopTransforms]   ✓ Found index in ERaw string: \"" + rawString + "\" (matched: \"" + pattern + "\")");
				return true;
			};
		};
		var interpolationPattern = "#{" + indexStr + "}";
		if (rawString.indexOf(interpolationPattern) != -1) {
			trace("[XRay LoopTransforms]   ✓ Found index interpolation in ERaw: \"" + rawString + "\"");
			return true;
		};
		trace("[XRay LoopTransforms]   ✗ No index " + expectedIndex + " found in ERaw: \"" + rawString + "\"");
		return false;	
	default:
		trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def));
		return false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 26: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					if (enumIndex ` == 25) {
						{
							var left = `;
							var right = `;
							{
								var leftHas = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(left, expectedIndex);
								var rightHas = reflaxe.elixir.ast.transformers.LoopTransforms.checkForIndex(right, expectedIndex);
								if (leftHas || rightHas) {
									haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in binary concat", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 804, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								};
								return leftHas || rightHas;
							};
						};
					} else {
						haxe.Log.trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 863, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
						return false;
					};
				};
				case 32: {
					var ` = `[0];
					{
						var s = `;
						{
							var exactPattern = "Iteration " + expectedIndex;
							if (s == exactPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT match found: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 754, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var interpolationPattern = "Iteration #{" + expectedIndex + "}";
							if (s == interpolationPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT interpolation match: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 761, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var placeholderPattern = "#{" + expectedIndex + "}";
							if (s == placeholderPattern) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT placeholder match: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 768, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var indexStr = Std.string(expectedIndex);
							if (s == indexStr) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ EXACT index string match: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 775, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							var indexPattern = "Index: " + expectedIndex;
							if (s == indexPattern || s.indexOf(indexPattern, null) != -1) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found \"Index: " + expectedIndex + "\" pattern in: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 782, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							if (s.indexOf(exactPattern, null) != -1 || s.indexOf(interpolationPattern, null) != -1 || s.indexOf(placeholderPattern, null) != -1) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index via contains fallback in: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 791, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ No match in string: \"" + s + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 795, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 33: {
					var ` = `[0];
					{
						var n = `;
						{
							if (n == expectedIndex) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found exact index as integer: " + n, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 811, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ Integer " + n + " does not match expected " + expectedIndex, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 814, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 38: {
					var ` = `[0];
					{
						var name = `;
						{
							var indexStr = Std.string(expectedIndex);
							if (name == indexStr || name == "i" + indexStr) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in variable name: " + name, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 822, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ Variable " + name + " does not match index", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 825, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var rawString = `;
						{
							var indexStr = Std.string(expectedIndex);
							var patterns = ["Index: #{" + indexStr + "}", "Iteration #{" + indexStr + "}", "#{" + indexStr + "}", "Iteration " + indexStr, "Index: " + indexStr, "Value: #{" + indexStr + "}", "Pair: #{" + indexStr + "}"];
							{
								var ` = 0;
								while (` < patterns.length) {
									var pattern = patterns[`];
									++ `;
									if (rawString.indexOf(pattern, null) != -1) {
										haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index in ERaw string: \"" + rawString + "\" (matched: \"" + pattern + "\")", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 846, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
										return true;
									};
								};
							};
							var interpolationPattern = "#{" + indexStr + "}";
							if (rawString.indexOf(interpolationPattern, null) != -1) {
								haxe.Log.trace("[XRay LoopTransforms]   ✓ Found index interpolation in ERaw: \"" + rawString + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 854, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
								return true;
							};
							haxe.Log.trace("[XRay LoopTransforms]   ✗ No index " + expectedIndex + " found in ERaw: \"" + rawString + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 858, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
							return false;
						};
					};
				};
				default: {
					haxe.Log.trace("[XRay LoopTransforms]   ⚠ Unhandled AST type in checkForIndex: " + Type.enumConstructor(ast.def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 863, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "checkForIndex"});
					return false;
				}
			};
		};
	}

	static function containsInvalidInterpolation(ast:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (ast.def) {
	case ERaw(s):
		var invalidPattern = ~/#{\\s*\\d+\\s*\\+\\s*"/;
		if (invalidPattern.match(s)) {
			trace("[XRay LoopTransforms] Found invalid interpolation: " + s);
			return true;
		};	
	case EBlock(stmts):
		for (stmt  in  stmts) {
			if (containsInvalidInterpolation(stmt)) {
				return true;
			};
		};	
	case ERemoteCall(_, _, args) | ECall(_, _, args):
		for (arg  in  args) {
			if (containsInvalidInterpolation(arg)) {
				return true;
			};
		};	
	default:
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var args = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (reflaxe.elixir.ast.transformers.LoopTransforms.containsInvalidInterpolation(arg)) {
										return true;
									};
								};
							};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var args = `;
						{
							{
								var ` = 0;
								while (` < args.length) {
									var arg = args[`];
									++ `;
									if (reflaxe.elixir.ast.transformers.LoopTransforms.containsInvalidInterpolation(arg)) {
										return true;
									};
								};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var stmts = `;
						{
							{
								var ` = 0;
								while (` < stmts.length) {
									var stmt = stmts[`];
									++ `;
									if (reflaxe.elixir.ast.transformers.LoopTransforms.containsInvalidInterpolation(stmt)) {
										return true;
									};
								};
							};
						};
					};
				};
				case 62: {
					var ` = `[0];
					{
						var s = `;
						{
							var invalidPattern = new EReg("#{\\\\s*\\\\d+\\\\s*\\\\+\\\\s*\"", "");
							if (invalidPattern.match(s)) {
								haxe.Log.trace("[XRay LoopTransforms] Found invalid interpolation: " + s, {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 879, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "containsInvalidInterpolation"});
								return true;
							};
						};
					};
				};
				default: {}
			};
		};
		return false;
	}

	static function extractFunctionCall(ast:reflaxe.elixir.ast.ElixirAST) {
		@:ast(switch (ast.def) {
	case ERemoteCall({ def : EVar(module) }, funcName, args):
		return { module : module, func : funcName, args : args };	
	case ECall(target, funcName, args):
		return { module : "", func : funcName, args : args };	
	default:
		return null;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 22: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var target = `;
						var funcName = `;
						var args = `;
						{
							return {module : "", func : funcName, args : args};
						};
					};
				};
				case 24: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							{
								var module = `;
								var funcName = `;
								var args = `;
								{
									return {module : module, func : funcName, args : args};
								};
							};
						} else {
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function transformToEnumEach(callInfo:{ module : String, func : String, args : Array<reflaxe.elixir.ast.ElixirAST> }, count:Int) {
		{
			var ` = 0;
			var ` = callInfo.args;
			while (` < `.length) {
				var arg = `[`];
				++ `;
				if (reflaxe.elixir.ast.transformers.LoopTransforms.containsInvalidInterpolation(arg)) {
					haxe.Log.trace("[XRay LoopTransforms] ⚠️ SKIPPING TRANSFORMATION: Detected invalid interpolation pattern", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 927, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "transformToEnumEach"});
					return null;
				};
			};
		};
		var range = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERange({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(0), metadata : {}, pos : pos};
			}, {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EInteger(count - 1), metadata : {}, pos : pos};
			}, false), metadata : {}, pos : pos};
		};
		var loopVar = "k";
		var bodyArgs = [];
		if (callInfo.args.length > 0) {
			var firstArg = callInfo.args[0];
			haxe.Log.trace("[XRay LoopTransforms] transformToEnumEach: Processing first arg: " + Std.string(firstArg.def), {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 951, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "transformToEnumEach"});
			var transformedArg = @:ast(switch (firstArg.def) {
	case ERaw(s):
		var result = s;
		for (idx  in  0 ... count) {
			var patterns = ["#{$idx}", "Index: $idx", "$idx"];
			for (pattern  in  patterns) {
				if (result.indexOf(pattern) != -1) {
					var replacement = pattern == "#{$idx}" ? "#{$loopVar}" : pattern == "Index: $idx" ? "Index: #{$loopVar}" : loopVar;
					result = StringTools.replace(result, pattern, replacement);
					trace("[XRay LoopTransforms]   Replaced \"$pattern\" with \"$replacement\"");
				};
			};
		};
		makeAST(ERaw(result));	
	case EString(s):
		var result = s;
		var found = false;
		for (idx  in  0 ... count) {
			var indexStr = Std.string(idx);
			if (s.indexOf("Index: " + indexStr) != -1) {
				result = StringTools.replace(s, "Index: " + indexStr, "Index: #{$loopVar}");
				found = true;
				break;
			} else if (s == indexStr) {
				result = "#{$loopVar}";
				found = true;
				break;
			};
		};
		if (found) {
			makeAST(ERaw(result));
		} else {
			firstArg;
		};	
	default:
		firstArg;	
}) {
				var ` = firstArg.def;
				switch (enumIndex `) {
					case 32: {
						var ` = `[0];
						{
							var s = `;
							{
								var result = s;
								var found = false;
								{
									var ` = 0;
									var ` = count;
									while (` < `) {
										var idx = ` ++;
										var indexStr = Std.string(idx);
										if (s.indexOf("Index: " + indexStr, null) != -1) {
											result = StringTools.replace(s, "Index: " + indexStr, "Index: #{" + loopVar + "}");
											found = true;
											break;
										} else {
											if (s == indexStr) {
												result = "#{" + loopVar + "}";
												found = true;
												break;
											};
										};
									};
								};
								if (found) {
									{
										var pos = null;
										{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(result), metadata : {}, pos : pos};
									};
								} else {
									firstArg;
								};
							};
						};
					};
					case 62: {
						var ` = `[0];
						{
							var s = `;
							{
								var result = s;
								{
									var ` = 0;
									var ` = count;
									while (` < `) {
										var idx = ` ++;
										var patterns = ["#{" + idx + "}", "Index: " + idx, "" + idx];
										{
											var ` = 0;
											while (` < patterns.length) {
												var pattern = patterns[`];
												++ `;
												if (result.indexOf(pattern, null) != -1) {
													var replacement = if (pattern == "#{" + idx + "}") {
														"#{" + loopVar + "}";
													} else {
														if (pattern == "Index: " + idx) {
															"Index: #{" + loopVar + "}";
														} else {
															loopVar;
														};
													};
													result = StringTools.replace(result, pattern, replacement);
													haxe.Log.trace("[XRay LoopTransforms]   Replaced \"" + pattern + "\" with \"" + replacement + "\"", {fileName : "../../src/reflaxe/elixir/ast/transformers/LoopTransforms.hx", lineNumber : 972, className : "reflaxe.elixir.ast.transformers.LoopTransforms", methodName : "transformToEnumEach"});
												};
											};
										};
									};
								};
								{
									var pos = null;
									{def : reflaxe.elixir.ast.ElixirASTDef.ERaw(result), metadata : {}, pos : pos};
								};
							};
						};
					};
					default: {
						firstArg;
					}
				};
			};
			bodyArgs.push(transformedArg);
			{
				var ` = 1;
				var ` = callInfo.args.length;
				while (` < `) {
					var i = ` ++;
					bodyArgs.push(callInfo.args[i]);
				};
			};
		};
		var body = if (callInfo.module != "") {
			{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
					var pos = null;
					{def : reflaxe.elixir.ast.ElixirASTDef.EVar(callInfo.module), metadata : {}, pos : pos};
				}, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		} else {
			{
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.ECall(null, callInfo.func, bodyArgs), metadata : {}, pos : pos};
			};
		};
		var clause = {args : [reflaxe.elixir.ast.EPattern.PVar(loopVar)], body : body};
		var func = {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.EFn([clause]), metadata : {}, pos : pos};
		};
		return {
			var pos = null;
			{def : reflaxe.elixir.ast.ElixirASTDef.ERemoteCall({
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar("Enum"), metadata : {}, pos : pos};
			}, "each", [range, func]), metadata : {}, pos : pos};
		};
	}

	public static function whileLoopTransformPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var transformWhileLoops = [null];
		transformWhileLoops[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall({ def : EVar("Enum") }, "reduce_while", args) if (args.length >= 3):
		var hasEmptyBody = switch (args[2].def) {
			case EFn(clauses) if (clauses.length > 0):
				switch (clauses[0].body.def) {
					case ENil:
						true;					
					case EBlock([]):
						true;					
					default:
						false;					
				};			
			default:
				false;			
		};
		if (hasEmptyBody) {
			return makeAST(ENil);
		};
		return ElixirASTTransformer.transformNode(node, transformWhileLoops);	
	default:
		return ElixirASTTransformer.transformNode(node, transformWhileLoops);	
}) {
				var ` = node.def;
				if (enumIndex ` == 24) {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.def;
						var ` = `.metadata;
						var ` = `.pos;
						if (enumIndex ` == 38) {
							var ` = `[0];
							if (` == "Enum") {
								if (` == "reduce_while") {
									{
										var args = `;
										if (args.length >= 3) {
											var hasEmptyBody = @:ast(switch (args[2].def) {
	case EFn(clauses) if (clauses.length > 0):
		switch (clauses[0].body.def) {
			case ENil:
				true;			
			case EBlock([]):
				true;			
			default:
				false;			
		};	
	default:
		false;	
}) {
												var ` = args[2].def;
												if (enumIndex ` == 42) {
													var ` = `[0];
													{
														var clauses = `;
														if (clauses.length > 0) {
															@:ast(switch (clauses[0].body.def) {
	case ENil:
		true;	
	case EBlock([]):
		true;	
	default:
		false;	
}) {
																var ` = clauses[0].body.def;
																switch (enumIndex `) {
																	case 36: {
																		{
																			true;
																		};
																	};
																	case 53: {
																		var ` = `[0];
																		if (`.length == 0) {
																			{
																				true;
																			};
																		} else {
																			false;
																		};
																	};
																	default: {
																		false;
																	}
																};
															};
														} else {
															false;
														};
													};
												} else {
													false;
												};
											};
											if (hasEmptyBody) {
												return {
													var pos = null;
													{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
												};
											};
											return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
										} else {
											return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
										};
									};
								} else {
									return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
								};
							} else {
								return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
							};
						} else {
							return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
						};
					};
				} else {
					return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(node, transformWhileLoops[0]);
				};
			};
		};
		return transformWhileLoops[0](ast);
	}
}