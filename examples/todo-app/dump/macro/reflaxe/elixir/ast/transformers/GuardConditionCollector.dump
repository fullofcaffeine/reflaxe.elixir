@:nullSafety(Off)
class reflaxe.elixir.ast.transformers.GuardConditionCollector {

	public static function collectAllGuardConditions(ast:reflaxe.elixir.ast.ElixirAST) {
		var branches = [];
		var visitedNodes = new haxe.ds.StringMap();
		var collectRecursive = [null];
		collectRecursive[0] = function(node:reflaxe.elixir.ast.ElixirAST, depth:Int = 0) {
			if (node == null) {
				return;
			};
			var nodeId = Std.string(node.pos) + "_" + Type.enumConstructor(node.def);
			if (visitedNodes.exists(nodeId)) {
				return;
			};
			visitedNodes.set(nodeId, true);
			if (reflaxe.elixir.ast.transformers.GuardConditionCollector.isInlineFunctionExpansion(node)) {
				if (depth > 0) {
					branches.push({pattern : null, guard : reflaxe.elixir.ast.transformers.GuardConditionCollector.makeAST(reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), null), body : node, depth : cast depth});
				};
				return;
			};
			var unwrapped = reflaxe.elixir.ast.transformers.GuardConditionCollector.unwrapNode(node);
			if (unwrapped == null) {
				return;
			};
			@:ast(switch (unwrapped.def) {
	case EIf(condition, thenBranch, elseBranch):
		var isInlineCheck = switch (condition.def) {
			case EParen(inner):
				switch (inner.def) {
					case EBinary(Equal, left, right):
						var leftIsVar = switch (left.def) {
							case EVar(_):
								true;							
							default:
								false;							
						};
						var rightIsNil = isNilValue(right);
						leftIsVar && rightIsNil;					
					default:
						false;					
				};			
			case EBinary(Equal, left, right):
				var leftIsVar = switch (left.def) {
					case EVar(_):
						true;					
					default:
						false;					
				};
				var rightIsNil = isNilValue(right);
				leftIsVar && rightIsNil;			
			default:
				false;			
		};
		if (isInlineCheck) {
			if (depth > 0) {
				branches.push({ pattern : null, guard : makeAST(EBoolean(true)), body : unwrapped, depth : depth });
			};
			return;
		};
		branches.push({ pattern : null, guard : condition, body : thenBranch, depth : depth });
		if (elseBranch != null) {
			collectRecursive(elseBranch, depth + 1);
		};	
	case ECond(condBranches):
		for (branch  in  condBranches) {
			var isTrueBranch = switch (branch.condition.def) {
				case EBoolean(true):
					true;				
				case EAtom(a):
					((a : String)) == "true";				
				default:
					false;				
			};
			if (isTrueBranch) {
				collectRecursive(branch.body, depth + 1);
			} else {
				branches.push({ pattern : null, guard : branch.condition, body : branch.body, depth : depth });
			};
		};	
	default:
		if (depth > 0 && !isNilAssignmentBlock(unwrapped)) {
			branches.push({ pattern : null, guard : makeAST(EBoolean(true)), body : unwrapped, depth : depth });
		};	
}) {
				var ` = unwrapped.def;
				switch (enumIndex `) {
					case 7: {
						var ` = `[0];
						{
							var condBranches = `;
							{
								{
									var ` = 0;
									while (` < condBranches.length) {
										var branch = condBranches[`];
										++ `;
										var isTrueBranch = @:ast(switch (branch.condition.def) {
	case EBoolean(true):
		true;	
	case EAtom(a):
		((a : String)) == "true";	
	default:
		false;	
}) {
											var ` = branch.condition.def;
											switch (enumIndex `) {
												case 31: {
													var ` = `[0];
													{
														var a = `;
														{
															(cast a) == "true";
														};
													};
												};
												case 35: {
													var ` = `[0];
													if (` == true) {
														{
															true;
														};
													} else {
														false;
													};
												};
												default: {
													false;
												}
											};
										};
										if (isTrueBranch) {
											collectRecursive[0](branch.body, depth + 1);
										} else {
											branches.push({pattern : null, guard : branch.condition, body : branch.body, depth : cast depth});
										};
									};
								};
							};
						};
					};
					case 10: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var condition = `;
							var thenBranch = `;
							var elseBranch = `;
							{
								var isInlineCheck = @:ast(switch (condition.def) {
	case EParen(inner):
		switch (inner.def) {
			case EBinary(Equal, left, right):
				var leftIsVar = switch (left.def) {
					case EVar(_):
						true;					
					default:
						false;					
				};
				var rightIsNil = isNilValue(right);
				leftIsVar && rightIsNil;			
			default:
				false;			
		};	
	case EBinary(Equal, left, right):
		var leftIsVar = switch (left.def) {
			case EVar(_):
				true;			
			default:
				false;			
		};
		var rightIsNil = isNilValue(right);
		leftIsVar && rightIsNil;	
	default:
		false;	
}) {
									var ` = condition.def;
									switch (enumIndex `) {
										case 26: {
											var ` = `[0];
											var ` = `[1];
											var ` = `[2];
											if (enumIndex ` == 6) {
												{
													var left = `;
													var right = `;
													{
														var leftIsVar = @:ast(switch (left.def) {
	case EVar(_):
		true;	
	default:
		false;	
}) {
															var ` = left.def;
															if (enumIndex ` == 38) {
																var ` = `[0];
																{
																	true;
																};
															} else {
																false;
															};
														};
														var rightIsNil = reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right);
														leftIsVar && rightIsNil;
													};
												};
											} else {
												false;
											};
										};
										case 54: {
											var ` = `[0];
											{
												var inner = `;
												{
													@:ast(switch (inner.def) {
	case EBinary(Equal, left, right):
		var leftIsVar = switch (left.def) {
			case EVar(_):
				true;			
			default:
				false;			
		};
		var rightIsNil = isNilValue(right);
		leftIsVar && rightIsNil;	
	default:
		false;	
}) {
														var ` = inner.def;
														if (enumIndex ` == 26) {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 6) {
																{
																	var left = `;
																	var right = `;
																	{
																		var leftIsVar = @:ast(switch (left.def) {
	case EVar(_):
		true;	
	default:
		false;	
}) {
																			var ` = left.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					true;
																				};
																			} else {
																				false;
																			};
																		};
																		var rightIsNil = reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right);
																		leftIsVar && rightIsNil;
																	};
																};
															} else {
																false;
															};
														} else {
															false;
														};
													};
												};
											};
										};
										default: {
											false;
										}
									};
								};
								if (isInlineCheck) {
									if (depth > 0) {
										branches.push({pattern : null, guard : reflaxe.elixir.ast.transformers.GuardConditionCollector.makeAST(reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), null), body : unwrapped, depth : cast depth});
									};
									return;
								};
								branches.push({pattern : null, guard : condition, body : thenBranch, depth : cast depth});
								if (elseBranch != null) {
									collectRecursive[0](elseBranch, depth + 1);
								};
							};
						};
					};
					default: {
						if (depth > 0 && ! reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilAssignmentBlock(unwrapped)) {
							branches.push({pattern : null, guard : reflaxe.elixir.ast.transformers.GuardConditionCollector.makeAST(reflaxe.elixir.ast.ElixirASTDef.EBoolean(true), null), body : unwrapped, depth : cast depth});
						};
					}
				};
			};
		};
		collectRecursive[0](ast, 0);
		return branches;
	}

	static function unwrapNode(node:reflaxe.elixir.ast.ElixirAST) {
		if (node == null) {
			return null;
		};
		return @:ast(switch (node.def) {
	case EParen(inner):
		unwrapNode(inner);	
	case EBlock(exprs):
		var cleaned = exprs.filter(function(e) ->  @:implicitReturn return !isNilAssignment(e));
		if (cleaned.length == 1) {
			unwrapNode(cleaned[0]);
		} else if (cleaned.length == 0) {
			null;
		} else {
			makeAST(EBlock(cleaned), node.pos);
		};	
	default:
		node;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						{
							var cleaned = {
								var ` = [];
								{
									var ` = 0;
									var ` = exprs;
									while (` < `.length) {
										var v = `[`];
										++ `;
										if (function(e:reflaxe.elixir.ast.ElixirAST) {
											return ! reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilAssignment(e);
										}(v)) {
											`.push(v);
										};
									};
								};
								`;
							};
							if (cleaned.length == 1) {
								reflaxe.elixir.ast.transformers.GuardConditionCollector.unwrapNode(cleaned[0]);
							} else {
								if (cleaned.length == 0) {
									null;
								} else {
									reflaxe.elixir.ast.transformers.GuardConditionCollector.makeAST(reflaxe.elixir.ast.ElixirASTDef.EBlock(cleaned), node.pos);
								};
							};
						};
					};
				};
				case 54: {
					var ` = `[0];
					{
						var inner = `;
						{
							reflaxe.elixir.ast.transformers.GuardConditionCollector.unwrapNode(inner);
						};
					};
				};
				default: {
					node;
				}
			};
		};
	}

	static function isInlineFunctionExpansion(node:reflaxe.elixir.ast.ElixirAST) {
		if (node == null) {
			return false;
		};
		return @:ast(switch (node.def) {
	case EBlock(exprs) if (exprs.length >= 2 && exprs[0] != null):
		var hasNilAssignment = switch (exprs[0].def) {
			case EMatch(PVar(_), value):
				isNilValue(value);			
			default:
				false;			
		};
		var hasNilCheck = if (exprs.length > 1 && exprs[1] != null) {
			switch (exprs[1].def) {
				case EIf(condition, _, _):
					switch (condition.def) {
						case EParen(inner):
							switch (inner.def) {
								case EBinary(Equal, left, right):
									switch (left.def) {
										case EVar(_):
											isNilValue(right);										
										default:
											false;										
									};								
								default:
									false;								
							};						
						case EBinary(Equal, left, right):
							switch (left.def) {
								case EVar(_):
									isNilValue(right);								
								default:
									false;								
							};						
						default:
							false;						
					};				
				default:
					false;				
			};
		} else {
			false;
		};
		hasNilAssignment && hasNilCheck;	
	case EIf(condition, _, _):
		switch (condition.def) {
			case EParen(inner):
				switch (inner.def) {
					case EBinary(Equal, left, right):
						switch (left.def) {
							case EVar(name):
								isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");							
							default:
								false;							
						};					
					default:
						false;					
				};			
			case EBinary(Equal, left, right):
				switch (left.def) {
					case EVar(name):
						isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
			var ` = node.def;
			switch (enumIndex `) {
				case 10: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var condition = `;
						{
							@:ast(switch (condition.def) {
	case EParen(inner):
		switch (inner.def) {
			case EBinary(Equal, left, right):
				switch (left.def) {
					case EVar(name):
						isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");					
					default:
						false;					
				};			
			default:
				false;			
		};	
	case EBinary(Equal, left, right):
		switch (left.def) {
			case EVar(name):
				isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");			
			default:
				false;			
		};	
	default:
		false;	
}) {
								var ` = condition.def;
								switch (enumIndex `) {
									case 26: {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										if (enumIndex ` == 6) {
											{
												var left = `;
												var right = `;
												{
													@:ast(switch (left.def) {
	case EVar(name):
		isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");	
	default:
		false;	
}) {
														var ` = left.def;
														if (enumIndex ` == 38) {
															var ` = `[0];
															{
																var name = `;
																{
																	reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");
																};
															};
														} else {
															false;
														};
													};
												};
											};
										} else {
											false;
										};
									};
									case 54: {
										var ` = `[0];
										{
											var inner = `;
											{
												@:ast(switch (inner.def) {
	case EBinary(Equal, left, right):
		switch (left.def) {
			case EVar(name):
				isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");			
			default:
				false;			
		};	
	default:
		false;	
}) {
													var ` = inner.def;
													if (enumIndex ` == 26) {
														var ` = `[0];
														var ` = `[1];
														var ` = `[2];
														if (enumIndex ` == 6) {
															{
																var left = `;
																var right = `;
																{
																	@:ast(switch (left.def) {
	case EVar(name):
		isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");	
	default:
		false;	
}) {
																		var ` = left.def;
																		if (enumIndex ` == 38) {
																			var ` = `[0];
																			{
																				var name = `;
																				{
																					reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right) && (name == "len" || name == "pos" || name == "start" || name == "end");
																				};
																			};
																		} else {
																			false;
																		};
																	};
																};
															};
														} else {
															false;
														};
													} else {
														false;
													};
												};
											};
										};
									};
									default: {
										false;
									}
								};
							};
						};
					};
				};
				case 53: {
					var ` = `[0];
					{
						var exprs = `;
						if (exprs.length >= 2 && exprs[0] != null) {
							var hasNilAssignment = @:ast(switch (exprs[0].def) {
	case EMatch(PVar(_), value):
		isNilValue(value);	
	default:
		false;	
}) {
								var ` = exprs[0].def;
								if (enumIndex ` == 8) {
									var ` = `[0];
									var ` = `[1];
									if (enumIndex ` == 0) {
										var ` = `[0];
										{
											var value = `;
											{
												reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(value);
											};
										};
									} else {
										false;
									};
								} else {
									false;
								};
							};
							var hasNilCheck = if (exprs.length > 1 && exprs[1] != null) {
								@:ast(switch (exprs[1].def) {
	case EIf(condition, _, _):
		switch (condition.def) {
			case EParen(inner):
				switch (inner.def) {
					case EBinary(Equal, left, right):
						switch (left.def) {
							case EVar(_):
								isNilValue(right);							
							default:
								false;							
						};					
					default:
						false;					
				};			
			case EBinary(Equal, left, right):
				switch (left.def) {
					case EVar(_):
						isNilValue(right);					
					default:
						false;					
				};			
			default:
				false;			
		};	
	default:
		false;	
}) {
									var ` = exprs[1].def;
									if (enumIndex ` == 10) {
										var ` = `[0];
										var ` = `[1];
										var ` = `[2];
										{
											var condition = `;
											{
												@:ast(switch (condition.def) {
	case EParen(inner):
		switch (inner.def) {
			case EBinary(Equal, left, right):
				switch (left.def) {
					case EVar(_):
						isNilValue(right);					
					default:
						false;					
				};			
			default:
				false;			
		};	
	case EBinary(Equal, left, right):
		switch (left.def) {
			case EVar(_):
				isNilValue(right);			
			default:
				false;			
		};	
	default:
		false;	
}) {
													var ` = condition.def;
													switch (enumIndex `) {
														case 26: {
															var ` = `[0];
															var ` = `[1];
															var ` = `[2];
															if (enumIndex ` == 6) {
																{
																	var left = `;
																	var right = `;
																	{
																		@:ast(switch (left.def) {
	case EVar(_):
		isNilValue(right);	
	default:
		false;	
}) {
																			var ` = left.def;
																			if (enumIndex ` == 38) {
																				var ` = `[0];
																				{
																					reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right);
																				};
																			} else {
																				false;
																			};
																		};
																	};
																};
															} else {
																false;
															};
														};
														case 54: {
															var ` = `[0];
															{
																var inner = `;
																{
																	@:ast(switch (inner.def) {
	case EBinary(Equal, left, right):
		switch (left.def) {
			case EVar(_):
				isNilValue(right);			
			default:
				false;			
		};	
	default:
		false;	
}) {
																		var ` = inner.def;
																		if (enumIndex ` == 26) {
																			var ` = `[0];
																			var ` = `[1];
																			var ` = `[2];
																			if (enumIndex ` == 6) {
																				{
																					var left = `;
																					var right = `;
																					{
																						@:ast(switch (left.def) {
	case EVar(_):
		isNilValue(right);	
	default:
		false;	
}) {
																							var ` = left.def;
																							if (enumIndex ` == 38) {
																								var ` = `[0];
																								{
																									reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(right);
																								};
																							} else {
																								false;
																							};
																						};
																					};
																				};
																			} else {
																				false;
																			};
																		} else {
																			false;
																		};
																	};
																};
															};
														};
														default: {
															false;
														}
													};
												};
											};
										};
									} else {
										false;
									};
								};
							} else {
								false;
							};
							hasNilAssignment && hasNilCheck;
						} else {
							false;
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	static function isNilAssignment(expr:reflaxe.elixir.ast.ElixirAST) {
		if (expr == null) {
			return false;
		};
		return @:ast(switch (expr.def) {
	case EMatch(PVar(name), value):
		~/^[a-z]+\d+$/.match(name) && isNilValue(value);	
	default:
		false;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 8) {
				var ` = `[0];
				var ` = `[1];
				if (enumIndex ` == 0) {
					var ` = `[0];
					{
						var name = `;
						var value = `;
						{
							new EReg("^[a-z]+\\d+$", "").match(name) && reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilValue(value);
						};
					};
				} else {
					false;
				};
			} else {
				false;
			};
		};
	}

	static function isNilAssignmentBlock(ast:reflaxe.elixir.ast.ElixirAST) {
		if (ast == null) {
			return false;
		};
		return @:ast(switch (ast.def) {
	case EBlock(exprs):
		exprs.length > 0 && exprs.filter(function(e) ->  @:implicitReturn return !isNilAssignment(e)).length == 0;	
	default:
		false;	
}) {
			var ` = ast.def;
			if (enumIndex ` == 53) {
				var ` = `[0];
				{
					var exprs = `;
					{
						exprs.length > 0 && {
							var ` = [];
							{
								var ` = 0;
								var ` = exprs;
								while (` < `.length) {
									var v = `[`];
									++ `;
									if (function(e:reflaxe.elixir.ast.ElixirAST) {
										return ! reflaxe.elixir.ast.transformers.GuardConditionCollector.isNilAssignment(e);
									}(v)) {
										`.push(v);
									};
								};
							};
							`;
						}.length == 0;
					};
				};
			} else {
				false;
			};
		};
	}

	static function isNilValue(ast:reflaxe.elixir.ast.ElixirAST) {
		return ast != null && @:ast(switch (ast.def) {
	case EAtom(a):
		((a : String)) == "nil";	
	case ENil:
		true;	
	default:
		false;	
}) {
			var ` = ast.def;
			switch (enumIndex `) {
				case 31: {
					var ` = `[0];
					{
						var a = `;
						{
							(cast a) == "nil";
						};
					};
				};
				case 36: {
					{
						true;
					};
				};
				default: {
					false;
				}
			};
		};
	}

	public static function patternToString(pattern:reflaxe.elixir.ast.EPattern) {
		return @:ast(switch (pattern) {
	case PVar(name):
		name;	
	case PLiteral(value):
		Std.string(value);	
	case PTuple(elements):
		var elementStrs = elements.map(function(p) ->  @:implicitReturn return patternToString(p));
		"{${elementStrs.join(\", \")}}";	
	case PList(elements):
		var elementStrs = elements.map(function(p) ->  @:implicitReturn return patternToString(p));
		"[${elementStrs.join(\", \")}]";	
	case PCons(head, tail):
		"[${patternToString(head)} | ${patternToString(tail)}]";	
	case PMap(pairs):
		"%{map}";	
	case PStruct(module, fields):
		"%$module{}";	
	case PPin(pattern):
		"^${patternToString(pattern)}";	
	case PWildcard:
		"_";	
	case PAlias(varName, pattern):
		"$varName = ${patternToString(pattern)}";	
	case PBinary(segments):
		"<<binary>>";	
}) switch (@:exhaustive enumIndex pattern) {
			case 0: {
				var ` = pattern[0];
				{
					var name = `;
					{
						name;
					};
				};
			};
			case 1: {
				var ` = pattern[0];
				{
					var value = `;
					{
						Std.string(value);
					};
				};
			};
			case 2: {
				var ` = pattern[0];
				{
					var elements = `;
					{
						var elementStrs = {
							var ` = [];
							{
								var ` = 0;
								var ` = elements;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(function(p:reflaxe.elixir.ast.EPattern) {
										return reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(p);
									}(v));
								};
							};
							`;
						};
						"{" + elementStrs.join(", ") + "}";
					};
				};
			};
			case 3: {
				var ` = pattern[0];
				{
					var elements = `;
					{
						var elementStrs = {
							var ` = [];
							{
								var ` = 0;
								var ` = elements;
								while (` < `.length) {
									var v = `[`];
									++ `;
									`.push(function(p:reflaxe.elixir.ast.EPattern) {
										return reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(p);
									}(v));
								};
							};
							`;
						};
						"[" + elementStrs.join(", ") + "]";
					};
				};
			};
			case 4: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var head = `;
					var tail = `;
					{
						"[" + reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(head) + " | " + reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(tail) + "]";
					};
				};
			};
			case 5: {
				var ` = pattern[0];
				{
					var pairs = `;
					{
						"%{map}";
					};
				};
			};
			case 6: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var module = `;
					var fields = `;
					{
						"%" + module + "{}";
					};
				};
			};
			case 7: {
				var ` = pattern[0];
				{
					var pattern = `;
					{
						"^" + reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(pattern);
					};
				};
			};
			case 8: {
				{
					"_";
				};
			};
			case 9: {
				var ` = pattern[0];
				var ` = pattern[1];
				{
					var varName = `;
					var pattern = `;
					{
						"" + varName + " = " + reflaxe.elixir.ast.transformers.GuardConditionCollector.patternToString(pattern);
					};
				};
			};
			case 10: {
				var ` = pattern[0];
				{
					var segments = `;
					{
						"<<binary>>";
					};
				};
			};
		};
	}

	public static function extractUsedVariables(expr:reflaxe.elixir.ast.ElixirAST) {
		var vars = [];
		var collect = [null];
		collect[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			if (node == null) {
				return;
			};
			@:ast(switch (node.def) {
	case EVar(name):
		if (!~/^[a-z]+\d+$/.match(name)) {
			vars.push(name);
		};	
	case EBinary(op, left, right):
		collect(left);
		collect(right);	
	case ECall(target, method, args):
		collect(target);
		for (arg  in  args) collect(arg);	
	case EParen(inner):
		collect(inner);	
	case EUnary(op, expr):
		collect(expr);	
	default:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 22: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var target = `;
							var method = `;
							var args = `;
							{
								collect[0](target);
								{
									var ` = 0;
									while (` < args.length) {
										var arg = args[`];
										++ `;
										collect[0](arg);
									};
								};
							};
						};
					};
					case 26: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						{
							var op = `;
							var left = `;
							var right = `;
							{
								collect[0](left);
								collect[0](right);
							};
						};
					};
					case 27: {
						var ` = `[0];
						var ` = `[1];
						{
							var op = `;
							var expr = `;
							{
								collect[0](expr);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								if (! new EReg("^[a-z]+\\d+$", "").match(name)) {
									vars.push(name);
								};
							};
						};
					};
					case 54: {
						var ` = `[0];
						{
							var inner = `;
							{
								collect[0](inner);
							};
						};
					};
					default: {}
				};
			};
		};
		collect[0](expr);
		return vars;
	}

	static function makeAST(def:reflaxe.elixir.ast.ElixirASTDef, pos:Null<haxe.macro.Position> = null) {
		return {def : def, pos : if (pos != null) {
			pos;
		} else {
			haxe.macro.Context.currentPos();
		}, metadata : null};
	}
}