@:nullSafety(Off)
class reflaxe.elixir.ast.builders.ExceptionBuilder {

	public static function buildTry(e:haxe.macro.TypedExpr, catches:Array<{ v : haxe.macro.TVar, expr : haxe.macro.TypedExpr }>, context:reflaxe.elixir.CompilationContext) {
		var body = if (context.compiler != null) {
			context.compiler.compileExpressionImpl(e, false);
		} else {
			return null;
		};
		if (body == null) {
			return null;
		};
		var rescueClauses = [];
		{
			var ` = 0;
			while (` < catches.length) {
				var c = catches[`];
				++ `;
				var pattern = reflaxe.elixir.ast.EPattern.PVar(reflaxe.elixir.ast.analyzers.VariableAnalyzer.toElixirVarName(c.v.name, null));
				var catchBody = if (context.compiler != null) {
					context.compiler.compileExpressionImpl(c.expr, false);
				} else {
					{
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					};
				};
				if (catchBody == null) {
					catchBody = {
						var pos = null;
						{def : reflaxe.elixir.ast.ElixirASTDef.ENil, metadata : {}, pos : pos};
					};
				};
				rescueClauses.push({pattern : pattern, body : catchBody});
			};
		};
		return reflaxe.elixir.ast.ElixirASTDef.ETry(body, rescueClauses, [], null, null);
	}

	public static function buildThrow(e:haxe.macro.TypedExpr, context:reflaxe.elixir.CompilationContext) {
		var throwExpr = if (context.compiler != null) {
			context.compiler.compileExpressionImpl(e, false);
		} else {
			return null;
		};
		if (throwExpr == null) {
			return null;
		};
		return reflaxe.elixir.ast.ElixirASTDef.EThrow(throwExpr);
	}

	public static function buildBreak() {
		return reflaxe.elixir.ast.ElixirASTDef.EThrow({
			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
				var this;
				this = reflaxe.elixir.ast.NameUtils.toSnakeCase("break");
				cast this;
			});
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		});
	}

	public static function buildContinue() {
		return reflaxe.elixir.ast.ElixirASTDef.EThrow({
			var def = reflaxe.elixir.ast.ElixirASTDef.EAtom(@:implicitCast {
				var this;
				this = reflaxe.elixir.ast.NameUtils.toSnakeCase("continue");
				cast this;
			});
			var pos = null;
			{def : def, metadata : {}, pos : pos};
		});
	}

	public static function isCatchAll(v:haxe.macro.TVar) {
		return @:ast(switch (v.t) {
	case TDynamic(_):
		true;	
	case null:
		true;	
	default:
		false;	
}) {
			var ` = v.t;
			if (` == null) {
				true;
			} else if (enumIndex ` == 6) {
				var ` = `[0];
				{
					true;
				};
			} else {
				false;
			};
		};
	}

	public static function getExceptionTypeName(t:haxe.macro.Type) {
		return @:ast(switch (t) {
	case TInst(c, _):
		var cls = c.get();
		cls.name;	
	case TAbstract(a, _):
		var abs = a.get();
		abs.name;	
	default:
		null;	
}) switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				var ` = t[1];
				{
					var c = `;
					{
						var cls = c.get();
						cls.name;
					};
				};
			};
			case 8: {
				var ` = t[0];
				var ` = t[1];
				{
					var a = `;
					{
						var abs = a.get();
						abs.name;
					};
				};
			};
			default: {
				null;
			}
		};
	}
}