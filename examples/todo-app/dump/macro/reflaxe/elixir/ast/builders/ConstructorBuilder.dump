@:nullSafety(Off)
class reflaxe.elixir.ast.builders.ConstructorBuilder {

	public static function build(c:haxe.macro.Ref<haxe.macro.ClassType>, params:Array<haxe.macro.Type>, el:Array<haxe.macro.TypedExpr>, context:reflaxe.elixir.CompilationContext) {
		var classType = c.get();
		var className = classType.name;
		haxe.Log.trace("[ConstructorBuilder] SETTING FLAG isInConstructorArgContext = true", {fileName : "../../src/reflaxe/elixir/ast/builders/ConstructorBuilder.hx", lineNumber : 78, className : "reflaxe.elixir.ast.builders.ConstructorBuilder", methodName : "build"});
		context.isInConstructorArgContext = true;
		var args = {
			var ` = [];
			{
				var ` = 0;
				while (` < el.length) {
					var e = el[`];
					++ `;
					`.push(reflaxe.elixir.ast.ElixirASTBuilder.buildFromTypedExpr(e, context));
				};
			};
			`;
		};
		context.isInConstructorArgContext = false;
		haxe.Log.trace("[ConstructorBuilder] RESET FLAG isInConstructorArgContext = false", {fileName : "../../src/reflaxe/elixir/ast/builders/ConstructorBuilder.hx", lineNumber : 85, className : "reflaxe.elixir.ast.builders.ConstructorBuilder", methodName : "build"});
		if (classType.meta.has("schema")) {
			return reflaxe.elixir.ast.builders.ConstructorBuilder.buildEctoSchema(classType, className);
		};
		if (reflaxe.elixir.ast.builders.ConstructorBuilder.isMapType(className)) {
			return reflaxe.elixir.ast.ElixirASTDef.EMap([]);
		};
		var hasInstanceMethods = reflaxe.elixir.ast.builders.ConstructorBuilder.hasInstanceMethodsCheck(classType);
		var hasConstructor = classType.constructor != null;
		if (hasInstanceMethods || hasConstructor) {
			var moduleRef = {
				var pos = null;
				{def : reflaxe.elixir.ast.ElixirASTDef.EVar(className), metadata : {}, pos : pos};
			};
			return reflaxe.elixir.ast.ElixirASTDef.ECall(moduleRef, "new", args);
		} else {
			return reflaxe.elixir.ast.ElixirASTDef.EStruct(className, []);
		};
	}

	static function buildEctoSchema(classType:haxe.macro.ClassType, defaultName:String) {
		var moduleName = if (classType.meta.has("native")) {
			var nativeMeta = classType.meta.extract("native");
			if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
				@:ast(switch (nativeMeta[0].params[0].expr) {
	case EConst(CString(s, _)):
		s;	
	default:
		defaultName;	
}) {
					var ` = nativeMeta[0].params[0].expr;
					if (enumIndex ` == 0) {
						var ` = `[0];
						if (enumIndex ` == 2) {
							var ` = `[0];
							var ` = `[1];
							{
								var s = `;
								{
									s;
								};
							};
						} else {
							defaultName;
						};
					} else {
						defaultName;
					};
				};
			} else {
				defaultName;
			};
		} else {
			defaultName;
		};
		return reflaxe.elixir.ast.ElixirASTDef.EStruct(moduleName, []);
	}

	static function isMapType(className:String) {
		return className == "StringMap" || className == "Map" || className == "IntMap" || StringTools.endsWith(className, "Map");
	}

	static function hasInstanceMethodsCheck(classType:haxe.macro.ClassType) {
		{
			var ` = 0;
			var ` = classType.fields.get();
			while (` < `.length) {
				var field = `[`];
				++ `;
				if ({
					var ` = field.kind;
					if (enumIndex ` == 1) {
						var ` = `[0];
						true;
					} else false;
				}) {
					var isStatic = false;
					{
						var ` = 0;
						var ` = classType.statics.get();
						while (` < `.length) {
							var staticField = `[`];
							++ `;
							if (staticField.name == field.name) {
								isStatic = true;
								break;
							};
						};
					};
					if (! isStatic) {
						return true;
					};
				};
			};
		};
		return false;
	}
}