class reflaxe.elixir.ast.context.ClauseContext {

	public function new(parentContext:Null<reflaxe.elixir.ast.context.ClauseContext> = null, varMapping:Null<Map<Int, String>> = null, enumPlan:Null<Map<Int, { isUsed : Bool, finalName : String }>> = null) {
		this.patternSatisfiedVarIds = new haxe.ds.IntMap();
		this.patternBindings = new haxe.ds.IntMap();
		this.usedNames = new haxe.ds.StringMap();
		this.localsInScope = new haxe.ds.StringMap();
		this.syntheticBindings = [];
		this.enumType = null;
		this.enumBindingPlan = new haxe.ds.IntMap();
		this.localToName = new haxe.ds.IntMap();
		this.parent = null;
		this.parent = parentContext;
		if ((parentContext != null && parentContext.localsInScope != null)) {
			var _g = cast new haxe.iterators.MapKeyValueIterator(cast cast parentContext.localsInScope);
			while ((_g.hasNext())) {
				var _g = _g.next();
				var name = _g.key;
				var _ = _g.value;
				cast cast this.localsInScope.set(name, true);
			};
		};
		if ((varMapping != null)) this.localToName = varMapping;
		if ((enumPlan != null)) this.enumBindingPlan = enumPlan;
	}

	@:value(null)
	public var parent:Null<reflaxe.elixir.ast.context.ClauseContext>;

	@:value(new Map())
	public var localToName:Map<Int, String>;

	@:value(new Map())
	public var enumBindingPlan:Map<Int, { isUsed : Bool, finalName : String }>;

	@:value(null)
	public var enumType:Null<haxe.macro.EnumType>;

	@:value([])
	public var syntheticBindings:Array<{ name : String, init : reflaxe.elixir.ast.ElixirAST }>;

	@:value(new Map())
	public var localsInScope:Map<String, Bool>;

	@:value(new Map())
	var usedNames:Map<String, Bool>;

	@:value(new Map())
	var patternBindings:Map<Int, String>;

	@:value(new Map())
	var patternSatisfiedVarIds:Map<Int, Bool>;

	public function pushPatternBindings(bindings:Array<{ varId : Int, binderName : String }>) {
		{
			var ` = 0;
			while (` < bindings.length) {
				var binding = bindings[`];
				++ `;
				{
					var this = this.patternBindings;
					var key = binding.varId;
					var value = binding.binderName;
					cast this.set(key, value);
				};
			};
		};
	}

	public function clearPatternBindings() {
		{
			var this = this.patternBindings;
			cast this.clear();
		};
	}

	public function markPatternSatisfiedVars(varIds:Map<Int, Int>) {
		{
			var ` = cast new haxe.iterators.MapKeyValueIterator(varIds);
			while (`.hasNext()) {
				var ` = `.next();
				var index = `.key;
				var varId = `.value;
				{
					{
						var this = this.patternSatisfiedVarIds;
						cast this.set(varId, true);
					};
				};
			};
		};
	}

	public function isVarIdSatisfiedByPattern(varId:Int) {
		if ({
			var this = this.patternSatisfiedVarIds;
			cast this.exists(varId);
		}) {
			return true;
		};
		if (this.parent != null) {
			return this.parent.isVarIdSatisfiedByPattern(varId);
		};
		return false;
	}

	public function lookupVariable(varId:Int) {
		if ({
			var this = this.patternBindings;
			cast this.exists(varId);
		}) {
			return {
				var this = this.patternBindings;
				cast this.get(varId);
			};
		};
		if ({
			var this = this.localToName;
			cast this.exists(varId);
		}) {
			return {
				var this = this.localToName;
				cast this.get(varId);
			};
		};
		if (this.parent != null) {
			return this.parent.lookupVariable(varId);
		};
		return null;
	}

	public function needTemp(name:String, buildInit:() -> reflaxe.elixir.ast.ElixirAST) {
		if ({
			var this = this.usedNames;
			cast this.exists(name);
		}) {
			return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(name), metadata : {}, pos : null};
		};
		var actualName = name;
		if ({
			var this = this.localsInScope;
			cast this.exists(name);
		}) {
			var counter = 1;
			while ({
				var this = this.localsInScope;
				cast this.exists("" + name + "_" + counter);
			} || {
				var this = this.usedNames;
				cast this.exists("" + name + "_" + counter);
			}) {
				counter ++;
			};
			actualName = "" + name + "_" + counter;
		};
		this.syntheticBindings.push({name : actualName, init : buildInit()});
		{
			var this = this.usedNames;
			cast this.set(actualName, true);
		};
		return {def : reflaxe.elixir.ast.ElixirASTDef.EVar(actualName), metadata : {}, pos : null};
	}

	public function wrapBody(body:reflaxe.elixir.ast.ElixirAST) {
		if (this.syntheticBindings.length == 0) {
			return body;
		};
		var statements = [];
		{
			var ` = 0;
			var ` = this.syntheticBindings;
			while (` < `.length) {
				var binding = `[`];
				++ `;
				var isSelfAssignment = false;
				@:ast(switch (binding.init.def) {
	case EVar(initVarName):
		if (initVarName == binding.name) {
			isSelfAssignment = true;
		} else { };	
	default:
}) {
					var ` = binding.init.def;
					if (enumIndex ` == 38) {
						var ` = `[0];
						{
							var initVarName = `;
							{
								if (initVarName == binding.name) {
									isSelfAssignment = true;
								} else {};
							};
						};
					} else {};
				};
				if (! isSelfAssignment) {
					statements.push({def : reflaxe.elixir.ast.ElixirASTDef.EBinary(reflaxe.elixir.ast.EBinaryOp.Match, {def : reflaxe.elixir.ast.ElixirASTDef.EVar(binding.name), metadata : {}, pos : null}, binding.init), metadata : {}, pos : null});
				};
			};
		};
		statements.push(body);
		return {def : reflaxe.elixir.ast.ElixirASTDef.EBlock(statements), metadata : {}, pos : null};
	}
}