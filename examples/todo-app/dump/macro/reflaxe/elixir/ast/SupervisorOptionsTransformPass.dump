class reflaxe.elixir.ast.SupervisorOptionsTransformPass {

	public static function transform(ast:reflaxe.elixir.ast.ElixirAST, context:Null<reflaxe.elixir.CompilationContext> = null) {
		return reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorCalls(ast);
	}

	static function transformSupervisorCalls(ast:reflaxe.elixir.ast.ElixirAST) {
		return reflaxe.elixir.ast.ElixirASTTransformer.transformNode(ast, function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ERemoteCall(module, "start_link", args) if (args.length == 2):
		var isSupervisor = switch (module.def) {
			case EVar("Supervisor"):
				true;			
			case _:
				false;			
		};
		if (isSupervisor) {
			var children = args[0];
			var opts = transformSupervisorOptions(args[1]);
			return makeASTWithMeta(ERemoteCall(module, "start_link", [children, opts]), node.metadata, node.pos);
		};	
	case EMatch(pattern, expr):
		var varName = switch (pattern) {
			case PVar(name):
				name;			
			case _:
				null;			
		};
		if (varName != null && (varName == "opts" || varName.indexOf("option") != -1 || varName.indexOf("config") != -1)) {
			var transformedExpr = transformSupervisorOptions(expr);
			if (transformedExpr != expr) {
				return makeASTWithMeta(EMatch(pattern, transformedExpr), node.metadata, node.pos);
			};
		};	
	case _:
}) {
				var ` = node.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								var varName = @:ast(switch (pattern) {
	case PVar(name):
		name;	
	case _:
		null;	
}) if (enumIndex pattern == 0) {
									var ` = pattern[0];
									{
										var name = `;
										{
											name;
										};
									};
								} else {
									null;
								};
								if (varName != null && (varName == "opts" || varName.indexOf("option", null) != -1 || varName.indexOf("config", null) != -1)) {
									var transformedExpr = reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorOptions(expr);
									if (transformedExpr != expr) {
										return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.EMatch(pattern, transformedExpr), node.metadata, node.pos);
									};
								};
							};
						};
					};
					case 24: {
						var ` = `[0];
						var ` = `[1];
						var ` = `[2];
						if (` == "start_link") {
							{
								var module = `;
								var args = `;
								if (args.length == 2) {
									var isSupervisor = @:ast(switch (module.def) {
	case EVar("Supervisor"):
		true;	
	case _:
		false;	
}) {
										var ` = module.def;
										if (enumIndex ` == 38) {
											var ` = `[0];
											if (` == "Supervisor") {
												{
													true;
												};
											} else {
												false;
											};
										} else {
											false;
										};
									};
									if (isSupervisor) {
										var children = args[0];
										var opts = reflaxe.elixir.ast.SupervisorOptionsTransformPass.transformSupervisorOptions(args[1]);
										return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.ERemoteCall(module, "start_link", [children, opts]), node.metadata, node.pos);
									};
								} else {};
							};
						} else {};
					};
					default: {}
				};
			};
			return node;
		});
	}

	static function transformSupervisorOptions(expr:reflaxe.elixir.ast.ElixirAST) {
		return @:ast(switch (expr.def) {
	case EMap(pairs):
		var hasStrategy = false;
		var hasMaxRestarts = false;
		var hasMaxSeconds = false;
		var hasName = false;
		for (pair  in  pairs) {
			var keyName:Null<String> = switch (pair.key.def) {
				case EAtom(atom):
					atom;				
				case _:
					null;				
			};
			if (keyName != null) {
				switch (keyName.toLowerCase()) {
					case "strategy":
						hasStrategy = true;					
					case "max_restarts" | "maxrestarts":
						hasMaxRestarts = true;					
					case "max_seconds" | "maxseconds":
						hasMaxSeconds = true;					
					case "name":
						hasName = true;					
				};
			};
		};
		if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
			var keywordPairs:Array<EKeywordPair> = [];
			for (pair  in  pairs) {
				var key = switch (pair.key.def) {
					case EAtom(name):
						name;					
					case _:
						continue;					
				};
				keywordPairs.push({ key : key, value : pair.value });
			};
			return makeASTWithMeta(EKeywordList(keywordPairs), expr.metadata, expr.pos);
		};
		expr;	
	case _:
		expr;	
}) {
			var ` = expr.def;
			if (enumIndex ` == 17) {
				var ` = `[0];
				{
					var pairs = `;
					{
						var hasStrategy = false;
						var hasMaxRestarts = false;
						var hasMaxSeconds = false;
						var hasName = false;
						{
							var ` = 0;
							while (` < pairs.length) {
								var pair = pairs[`];
								++ `;
								var keyName = @:ast(switch (pair.key.def) {
	case EAtom(atom):
		atom;	
	case _:
		null;	
}) {
									var ` = pair.key.def;
									if (enumIndex ` == 31) {
										var ` = `[0];
										{
											var atom = `;
											{
												atom;
											};
										};
									} else {
										null;
									};
								};
								if (keyName != null) {
									@:ast(switch (keyName.toLowerCase()) {
	case "strategy":
		hasStrategy = true;	
	case "max_restarts" | "maxrestarts":
		hasMaxRestarts = true;	
	case "max_seconds" | "maxseconds":
		hasMaxSeconds = true;	
	case "name":
		hasName = true;	
}) {
										var ` = keyName.toLowerCase();
										switch (`) {
											case "max_restarts", "maxrestarts": {
												{
													hasMaxRestarts = true;
												};
											};
											case "max_seconds", "maxseconds": {
												{
													hasMaxSeconds = true;
												};
											};
											case "name": {
												{
													hasName = true;
												};
											};
											case "strategy": {
												{
													hasStrategy = true;
												};
											};
										};
									};
								};
							};
						};
						if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
							var keywordPairs = [];
							{
								var ` = 0;
								while (` < pairs.length) {
									var pair = pairs[`];
									++ `;
									var key = @:ast(switch (pair.key.def) {
	case EAtom(name):
		name;	
	case _:
		continue;	
}) {
										var ` = pair.key.def;
										if (enumIndex ` == 31) {
											var ` = `[0];
											{
												var name = `;
												{
													name;
												};
											};
										} else {
											continue;
										};
									};
									keywordPairs.push({key : cast key, value : pair.value});
								};
							};
							return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.EKeywordList(keywordPairs), expr.metadata, expr.pos);
						};
						expr;
					};
				};
			} else {
				expr;
			};
		};
	}

	static function makeASTWithMeta(def:reflaxe.elixir.ast.ElixirASTDef, metadata:Null<reflaxe.elixir.ast.ElixirMetadata> = null, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : if (metadata != null) {
			metadata;
		} else {}, pos : pos};
	}

	static function patternVariableOriginAnalysisPass(ast:reflaxe.elixir.ast.ElixirAST) {
		var analyzeAndTransform = [null];
		var analyzeClause = [null];
		var collectPatternVars = [null];
		var analyzeUsage = [null];
		var updatePatternWithUsage = [null];
		analyzeAndTransform[0] = function(node:reflaxe.elixir.ast.ElixirAST) {
			@:ast(switch (node.def) {
	case ECase(expr, clauses):
		var newClauses = [];
		for (clause  in  clauses) {
			var transformedClause = analyzeClause(clause, node.metadata);
			newClauses.push(transformedClause);
		};
		return makeASTWithMeta(ECase(analyzeAndTransform(expr), newClauses), node.metadata, node.pos);	
	default:
		return ElixirASTTransformer.transformAST(node, analyzeAndTransform);	
}) {
				var ` = node.def;
				if (enumIndex ` == 6) {
					var ` = `[0];
					var ` = `[1];
					{
						var expr = `;
						var clauses = `;
						{
							var newClauses = [];
							{
								var ` = 0;
								while (` < clauses.length) {
									var clause = clauses[`];
									++ `;
									var transformedClause = analyzeClause[0](clause, node.metadata);
									newClauses.push(transformedClause);
								};
							};
							return reflaxe.elixir.ast.SupervisorOptionsTransformPass.makeASTWithMeta(reflaxe.elixir.ast.ElixirASTDef.ECase(analyzeAndTransform[0](expr), newClauses), node.metadata, node.pos);
						};
					};
				} else {
					return reflaxe.elixir.ast.ElixirASTTransformer.transformAST(node, analyzeAndTransform[0]);
				};
			};
		};
		analyzeClause[0] = function(clause:reflaxe.elixir.ast.ECaseClause, caseMetadata:reflaxe.elixir.ast.ElixirMetadata) {
			var varOrigin = if (caseMetadata != null && caseMetadata.varOrigin != null) {
				caseMetadata.varOrigin;
			} else {
				null;
			};
			var tempToBinderMap = if (caseMetadata != null && caseMetadata.tempToBinderMap != null) {
				caseMetadata.tempToBinderMap;
			} else {
				null;
			};
			var patternVars = {
				{};
				new haxe.ds.StringMap();
			};
			collectPatternVars[0](clause.pattern, patternVars, varOrigin);
			var usedVars = {
				{};
				new haxe.ds.StringMap();
			};
			analyzeUsage[0](clause.body, usedVars);
			var updatedPattern = updatePatternWithUsage[0](clause.pattern, patternVars, usedVars);
			return {pattern : updatedPattern, guard : if (clause.guard != null) {
				analyzeAndTransform[0](clause.guard);
			} else {
				null;
			}, body : analyzeAndTransform[0](clause.body)};
		};
		collectPatternVars[0] = function(pattern:reflaxe.elixir.ast.EPattern, vars:Map<String, reflaxe.elixir.ast.VarOrigin>, defaultOrigin:reflaxe.elixir.ast.VarOrigin) {
			@:ast(switch (pattern) {
	case PVar(name):
		var origin = defaultOrigin != null ? defaultOrigin : UserDefined;
		if (name == "g" || (name.startsWith("g") && name.length > 1 && name.charAt(1) >= "0" && name.charAt(1) <= "9")) {
			origin = ExtractionTemp;
		};
		vars.set(name, origin);	
	case PTuple(elements):
		for (elem  in  elements) {
			collectPatternVars(elem, vars, defaultOrigin);
		};	
	case PList(elements):
		for (elem  in  elements) {
			collectPatternVars(elem, vars, defaultOrigin);
		};	
	case PCons(head, tail):
		collectPatternVars(head, vars, defaultOrigin);
		collectPatternVars(tail, vars, defaultOrigin);	
	default:
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							var origin = if (defaultOrigin != null) {
								defaultOrigin;
							} else {
								reflaxe.elixir.ast.VarOrigin.UserDefined;
							};
							if (name == "g" || (StringTools.startsWith(name, "g") && name.length > 1 && name.charAt(1) >= "0" && name.charAt(1) <= "9")) {
								origin = reflaxe.elixir.ast.VarOrigin.ExtractionTemp;
							};
							{
								vars.set(name, origin);
							};
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									collectPatternVars[0](elem, vars, defaultOrigin);
								};
							};
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var elements = `;
						{
							{
								var ` = 0;
								while (` < elements.length) {
									var elem = elements[`];
									++ `;
									collectPatternVars[0](elem, vars, defaultOrigin);
								};
							};
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							collectPatternVars[0](head, vars, defaultOrigin);
							collectPatternVars[0](tail, vars, defaultOrigin);
						};
					};
				};
				default: {}
			};
		};
		analyzeUsage[0] = function(ast:reflaxe.elixir.ast.ElixirAST, usedVars:Map<String, Bool>) {
			@:ast(switch (ast.def) {
	case EVar(name):
		var cleanName = name.startsWith("_") ? name.substring(1) : name;
		usedVars.set(cleanName, true);
		usedVars.set(name, true);	
	case EMatch(pattern, expr):
		analyzeUsage(expr, usedVars);	
	default:
}) {
				var ` = ast.def;
				switch (enumIndex `) {
					case 8: {
						var ` = `[0];
						var ` = `[1];
						{
							var pattern = `;
							var expr = `;
							{
								analyzeUsage[0](expr, usedVars);
							};
						};
					};
					case 38: {
						var ` = `[0];
						{
							var name = `;
							{
								var cleanName = if (StringTools.startsWith(name, "_")) {
									name.substring(1, null);
								} else {
									name;
								};
								{
									usedVars.set(cleanName, true);
								};
								{
									usedVars.set(name, true);
								};
							};
						};
					};
					default: {}
				};
			};
		};
		updatePatternWithUsage[0] = function(pattern:reflaxe.elixir.ast.EPattern, patternVars:Map<String, reflaxe.elixir.ast.VarOrigin>, usedVars:Map<String, Bool>) {
			@:ast(switch (pattern) {
	case PVar(name):
		var origin = patternVars.get(name);
		var isUsed = usedVars.exists(name) && usedVars.get(name);
		if (!isUsed && !name.startsWith("_")) {
			if (origin == ExtractionTemp) {
				return pattern;
			};
		};
		return pattern;	
	case PTuple(elements):
		return PTuple(elements.map(function(e) ->  @:implicitReturn return updatePatternWithUsage(e, patternVars, usedVars)));	
	case PList(elements):
		return PList(elements.map(function(e) ->  @:implicitReturn return updatePatternWithUsage(e, patternVars, usedVars)));	
	case PCons(head, tail):
		return PCons(updatePatternWithUsage(head, patternVars, usedVars), updatePatternWithUsage(tail, patternVars, usedVars));	
	default:
		return pattern;	
}) switch (enumIndex pattern) {
				case 0: {
					var ` = pattern[0];
					{
						var name = `;
						{
							var origin = cast patternVars.get(name);
							var isUsed = usedVars.exists(name) && cast usedVars.get(name);
							if (! isUsed && ! StringTools.startsWith(name, "_")) {
								if (origin == reflaxe.elixir.ast.VarOrigin.ExtractionTemp) {
									return pattern;
								};
							};
							return pattern;
						};
					};
				};
				case 2: {
					var ` = pattern[0];
					{
						var elements = `;
						{
							return reflaxe.elixir.ast.EPattern.PTuple({
								var ` = [];
								{
									var ` = 0;
									var ` = elements;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(e:reflaxe.elixir.ast.EPattern) {
											return updatePatternWithUsage[0](e, patternVars, usedVars);
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				case 3: {
					var ` = pattern[0];
					{
						var elements = `;
						{
							return reflaxe.elixir.ast.EPattern.PList({
								var ` = [];
								{
									var ` = 0;
									var ` = elements;
									while (` < `.length) {
										var v = `[`];
										++ `;
										`.push(function(e:reflaxe.elixir.ast.EPattern) {
											return updatePatternWithUsage[0](e, patternVars, usedVars);
										}(v));
									};
								};
								`;
							});
						};
					};
				};
				case 4: {
					var ` = pattern[0];
					var ` = pattern[1];
					{
						var head = `;
						var tail = `;
						{
							return reflaxe.elixir.ast.EPattern.PCons(updatePatternWithUsage[0](head, patternVars, usedVars), updatePatternWithUsage[0](tail, patternVars, usedVars));
						};
					};
				};
				default: {
					return pattern;
				}
			};
		};
		return analyzeAndTransform[0](ast);
	}
}