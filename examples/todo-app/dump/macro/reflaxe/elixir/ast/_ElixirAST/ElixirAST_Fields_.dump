private class reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_ {

	public static inline function emptyMetadata() {
		return {};
	}

	public static inline function makeAST(def:reflaxe.elixir.ast.ElixirASTDef, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : {}, pos : pos};
	}

	public static inline function makeASTWithMeta(def:reflaxe.elixir.ast.ElixirASTDef, meta:reflaxe.elixir.ast.ElixirMetadata, pos:Null<haxe.macro.Position> = null) {
		return {def : def, metadata : meta, pos : pos};
	}

	public static function applyIdiomaticEnumTransformation(node:reflaxe.elixir.ast.ElixirAST) {
		var elements = @:ast(switch (node.def) {
	case ETuple(els):
		els;	
	default:
		return node;	
}) {
			var ` = node.def;
			if (enumIndex ` == 16) {
				var ` = `[0];
				{
					var els = `;
					{
						els;
					};
				};
			} else {
				return node;
			};
		};
		if (elements.length == 0) {
			return node;
		};
		var tag = @:ast(switch (elements[0].def) {
	case EAtom(name):
		name;	
	default:
		return node;	
}) {
			var ` = elements[0].def;
			if (enumIndex ` == 31) {
				var ` = `[0];
				{
					var name = `;
					{
						name;
					};
				};
			} else {
				return node;
			};
		};
		var args = elements.slice(1, null);
		var argCount = args.length;
		@:ast(switch (argCount) {
	case 0:
		return makeASTWithMeta(EAtom(tag), node.metadata, node.pos);	
	case 1:
		var unwrapped = switch (args[0].def) {
			case EString(s) if (isModuleName(s)):
				makeAST(EVar(s), args[0].pos);			
			default:
				args[0];			
		};
		return makeASTWithMeta(unwrapped.def, node.metadata, node.pos);	
	case 2:
		var moduleArg = switch (args[0].def) {
			case EString(s) if (isModuleName(s)):
				makeAST(EVar(s), args[0].pos);			
			default:
				args[0];			
		};
		var configArg = switch (args[1].def) {
			case EKeywordList(_):
				args[1];			
			case EList(elements):
				var keywordPairs:Array<EKeywordPair> = [];
				var isKeyValueConfig = true;
				for (elem  in  elements) {
					switch (elem.def) {
						case EMap(pairs):
							var keyName:String = null;
							var keyValue:ElixirAST = null;
							for (pair  in  pairs) {
								switch (pair.key.def) {
									case EAtom(atom) if (atom == "key"):
										switch (pair.value.def) {
											case EString(s):
												keyName = s;											
											default:
												isKeyValueConfig = false;											
										};									
									case EAtom(atom) if (atom == "value"):
										keyValue = pair.value;									
									default:
										isKeyValueConfig = false;									
								};
							};
							if (keyName != null && keyValue != null) {
								var finalValue = if (keyName == "name") {
									switch (keyValue.def) {
										case EString(s) if (isModuleName(s)):
											makeAST(EVar(s), keyValue.pos);										
										default:
											keyValue;										
									};
								} else if (keyName == "keys") {
									switch (keyValue.def) {
										case EString(s) if (s == "unique" || s == "duplicate"):
											makeAST(EAtom(ElixirAtom.raw(s)), keyValue.pos);										
										default:
											keyValue;										
									};
								} else {
									keyValue;
								};
								keywordPairs.push({ key : keyName, value : finalValue });
							} else {
								isKeyValueConfig = false;
							};						
						default:
							isKeyValueConfig = false;						
					};
				};
				if (isKeyValueConfig && keywordPairs.length > 0) {
					makeAST(EKeywordList(keywordPairs), args[1].pos);
				} else {
					args[1];
				};			
			default:
				args[1];			
		};
		return makeASTWithMeta(ETuple([moduleArg, configArg]), node.metadata, node.pos);	
}) switch (argCount) {
			case 0: {
				{
					return {def : reflaxe.elixir.ast.ElixirASTDef.EAtom(tag), metadata : node.metadata, pos : node.pos};
				};
			};
			case 1: {
				{
					var unwrapped = @:ast(switch (args[0].def) {
	case EString(s) if (isModuleName(s)):
		makeAST(EVar(s), args[0].pos);	
	default:
		args[0];	
}) {
						var ` = args[0].def;
						if (enumIndex ` == 32) {
							var ` = `[0];
							{
								var s = `;
								if (reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.isModuleName(s)) {
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(s), metadata : {}, pos : args[0].pos};
								} else {
									args[0];
								};
							};
						} else {
							args[0];
						};
					};
					return {def : unwrapped.def, metadata : node.metadata, pos : node.pos};
				};
			};
			case 2: {
				{
					var moduleArg = @:ast(switch (args[0].def) {
	case EString(s) if (isModuleName(s)):
		makeAST(EVar(s), args[0].pos);	
	default:
		args[0];	
}) {
						var ` = args[0].def;
						if (enumIndex ` == 32) {
							var ` = `[0];
							{
								var s = `;
								if (reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.isModuleName(s)) {
									{def : reflaxe.elixir.ast.ElixirASTDef.EVar(s), metadata : {}, pos : args[0].pos};
								} else {
									args[0];
								};
							};
						} else {
							args[0];
						};
					};
					var configArg = @:ast(switch (args[1].def) {
	case EKeywordList(_):
		args[1];	
	case EList(elements):
		var keywordPairs:Array<EKeywordPair> = [];
		var isKeyValueConfig = true;
		for (elem  in  elements) {
			switch (elem.def) {
				case EMap(pairs):
					var keyName:String = null;
					var keyValue:ElixirAST = null;
					for (pair  in  pairs) {
						switch (pair.key.def) {
							case EAtom(atom) if (atom == "key"):
								switch (pair.value.def) {
									case EString(s):
										keyName = s;									
									default:
										isKeyValueConfig = false;									
								};							
							case EAtom(atom) if (atom == "value"):
								keyValue = pair.value;							
							default:
								isKeyValueConfig = false;							
						};
					};
					if (keyName != null && keyValue != null) {
						var finalValue = if (keyName == "name") {
							switch (keyValue.def) {
								case EString(s) if (isModuleName(s)):
									makeAST(EVar(s), keyValue.pos);								
								default:
									keyValue;								
							};
						} else if (keyName == "keys") {
							switch (keyValue.def) {
								case EString(s) if (s == "unique" || s == "duplicate"):
									makeAST(EAtom(ElixirAtom.raw(s)), keyValue.pos);								
								default:
									keyValue;								
							};
						} else {
							keyValue;
						};
						keywordPairs.push({ key : keyName, value : finalValue });
					} else {
						isKeyValueConfig = false;
					};				
				default:
					isKeyValueConfig = false;				
			};
		};
		if (isKeyValueConfig && keywordPairs.length > 0) {
			makeAST(EKeywordList(keywordPairs), args[1].pos);
		} else {
			args[1];
		};	
	default:
		args[1];	
}) {
						var ` = args[1].def;
						switch (enumIndex `) {
							case 15: {
								var ` = `[0];
								{
									var elements = `;
									{
										var keywordPairs = [];
										var isKeyValueConfig = true;
										{
											var ` = 0;
											while (` < elements.length) {
												var elem = elements[`];
												++ `;
												@:ast(switch (elem.def) {
	case EMap(pairs):
		var keyName:String = null;
		var keyValue:ElixirAST = null;
		for (pair  in  pairs) {
			switch (pair.key.def) {
				case EAtom(atom) if (atom == "key"):
					switch (pair.value.def) {
						case EString(s):
							keyName = s;						
						default:
							isKeyValueConfig = false;						
					};				
				case EAtom(atom) if (atom == "value"):
					keyValue = pair.value;				
				default:
					isKeyValueConfig = false;				
			};
		};
		if (keyName != null && keyValue != null) {
			var finalValue = if (keyName == "name") {
				switch (keyValue.def) {
					case EString(s) if (isModuleName(s)):
						makeAST(EVar(s), keyValue.pos);					
					default:
						keyValue;					
				};
			} else if (keyName == "keys") {
				switch (keyValue.def) {
					case EString(s) if (s == "unique" || s == "duplicate"):
						makeAST(EAtom(ElixirAtom.raw(s)), keyValue.pos);					
					default:
						keyValue;					
				};
			} else {
				keyValue;
			};
			keywordPairs.push({ key : keyName, value : finalValue });
		} else {
			isKeyValueConfig = false;
		};	
	default:
		isKeyValueConfig = false;	
}) {
													var ` = elem.def;
													if (enumIndex ` == 17) {
														var ` = `[0];
														{
															var pairs = `;
															{
																var keyName = null;
																var keyValue = null;
																{
																	var ` = 0;
																	while (` < pairs.length) {
																		var pair = pairs[`];
																		++ `;
																		@:ast(switch (pair.key.def) {
	case EAtom(atom) if (atom == "key"):
		switch (pair.value.def) {
			case EString(s):
				keyName = s;			
			default:
				isKeyValueConfig = false;			
		};	
	case EAtom(atom) if (atom == "value"):
		keyValue = pair.value;	
	default:
		isKeyValueConfig = false;	
}) {
																			var ` = pair.key.def;
																			if (enumIndex ` == 31) {
																				var ` = `[0];
																				{
																					var atom = `;
																					if (atom == "key") {
																						@:ast(switch (pair.value.def) {
	case EString(s):
		keyName = s;	
	default:
		isKeyValueConfig = false;	
}) {
																							var ` = pair.value.def;
																							if (enumIndex ` == 32) {
																								var ` = `[0];
																								{
																									var s = `;
																									{
																										keyName = s;
																									};
																								};
																							} else {
																								isKeyValueConfig = false;
																							};
																						};
																					} else {
																						var atom = `;
																						if (atom == "value") {
																							keyValue = pair.value;
																						} else {
																							isKeyValueConfig = false;
																						};
																					};
																				};
																			} else {
																				isKeyValueConfig = false;
																			};
																		};
																	};
																};
																if (keyName != null && keyValue != null) {
																	var finalValue = if (keyName == "name") {
																		@:ast(switch (keyValue.def) {
	case EString(s) if (isModuleName(s)):
		makeAST(EVar(s), keyValue.pos);	
	default:
		keyValue;	
}) {
																			var ` = keyValue.def;
																			if (enumIndex ` == 32) {
																				var ` = `[0];
																				{
																					var s = `;
																					if (reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.isModuleName(s)) {
																						{def : reflaxe.elixir.ast.ElixirASTDef.EVar(s), metadata : {}, pos : keyValue.pos};
																					} else {
																						keyValue;
																					};
																				};
																			} else {
																				keyValue;
																			};
																		};
																	} else {
																		if (keyName == "keys") {
																			@:ast(switch (keyValue.def) {
	case EString(s) if (s == "unique" || s == "duplicate"):
		makeAST(EAtom(ElixirAtom.raw(s)), keyValue.pos);	
	default:
		keyValue;	
}) {
																				var ` = keyValue.def;
																				if (enumIndex ` == 32) {
																					var ` = `[0];
																					{
																						var s = `;
																						if (s == "unique" || s == "duplicate") {
																							{def : reflaxe.elixir.ast.ElixirASTDef.EAtom(cast s), metadata : {}, pos : keyValue.pos};
																						} else {
																							keyValue;
																						};
																					};
																				} else {
																					keyValue;
																				};
																			};
																		} else {
																			keyValue;
																		};
																	};
																	keywordPairs.push({key : keyName, value : finalValue});
																} else {
																	isKeyValueConfig = false;
																};
															};
														};
													} else {
														isKeyValueConfig = false;
													};
												};
											};
										};
										if (isKeyValueConfig && keywordPairs.length > 0) {
											{def : reflaxe.elixir.ast.ElixirASTDef.EKeywordList(keywordPairs), metadata : {}, pos : args[1].pos};
										} else {
											args[1];
										};
									};
								};
							};
							case 20: {
								var ` = `[0];
								{
									args[1];
								};
							};
							default: {
								args[1];
							}
						};
					};
					return {def : reflaxe.elixir.ast.ElixirASTDef.ETuple([moduleArg, configArg]), metadata : node.metadata, pos : node.pos};
				};
			};
		};
		return node;
	}

	public static function isModuleName(s:String) {
		if (s.length == 0) {
			return false;
		};
		var firstChar = s.charAt(0);
		if (firstChar != firstChar.toUpperCase()) {
			return false;
		};
		{
			var ` = 0;
			var ` = s.length;
			while (` < `) {
				var i = ` ++;
				var char = s.charAt(i);
				if (! reflaxe.elixir.ast._ElixirAST.ElixirAST_Fields_.isAlphaNumeric(char) && char != "." && char != "_") {
					return false;
				};
			};
		};
		return true;
	}

	public static function isAlphaNumeric(char:String) {
		var code = char.charCodeAt(0);
		return (code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
	}
}