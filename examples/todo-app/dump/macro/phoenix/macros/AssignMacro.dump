@:nullSafety(Off)
class phoenix.macros.AssignMacro {

	@:has_untyped
	public static function processAssign(socketExpr:haxe.macro.Expr, fieldExpr:haxe.macro.Expr, value:haxe.macro.Expr) {
		var fieldName = phoenix.macros.AssignMacro.extractFieldName(fieldExpr);
		if (fieldName == null) {
			haxe.macro.Context.error("Expected field access expression like _.fieldName", fieldExpr.pos, null);
		};
		var assignsType = phoenix.macros.AssignMacro.extractAssignsType(socketExpr);
		phoenix.macros.AssignMacro.validateFieldExists(assignsType, fieldName, fieldExpr.pos);
		var snakeCaseName = phoenix.macros.AssignMacro.camelToSnake(fieldName);
		return cast {expr : haxe.macro.ExprDef.ECall({expr : haxe.macro.ExprDef.EField({expr : haxe.macro.ExprDef.EField({expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent("phoenix")), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 2051, 2058)}, "Component", haxe.macro.EFieldKind.Normal), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 2051, 2068)}, "assign", haxe.macro.EFieldKind.Normal), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 2051, 2075)}, [socketExpr, haxe.macro.Context.makeExpr(snakeCaseName, $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 2092, 2105)), value]), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 2051, 2115)};
	}

	@:has_untyped
	public static function processMerge(socketExpr:haxe.macro.Expr, updates:haxe.macro.Expr) {
		@:ast(switch (updates.expr) {
	case EObjectDecl(fields):
		var assignsType = extractAssignsType(socketExpr);
		var transformedFields = [];
		for (field  in  fields) {
			validateFieldExists(assignsType, field.field, field.expr.pos);
			var snakeCaseName = camelToSnake(field.field);
			transformedFields.push({ field : snakeCaseName, expr : field.expr });
		};
		var mapFields = [];
		for (field  in  transformedFields) {
			mapFields.push({ field : field.field, expr : field.expr });
		};
		var mapExpr = { expr : EObjectDecl(mapFields), pos : updates.pos };
		return ({ expr : ECall({ expr : EField({ expr : EField({ expr : EConst(CIdent("phoenix")), pos : untyped $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3384) }, "Component", Normal), pos : untyped $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3394) }, "assign", Normal), pos : untyped $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3401) }, [socketExpr, mapExpr]), pos : untyped $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3424) } : haxe.macro.Expr);	
	case _:
		Context.error("Expected object literal with fields to merge", updates.pos);
		return null;	
}) {
			var ` = updates.expr;
			if (enumIndex ` == 5) {
				var ` = `[0];
				{
					var fields = `;
					{
						var assignsType = phoenix.macros.AssignMacro.extractAssignsType(socketExpr);
						var transformedFields = [];
						{
							var ` = 0;
							while (` < fields.length) {
								var field = fields[`];
								++ `;
								phoenix.macros.AssignMacro.validateFieldExists(assignsType, field.field, field.expr.pos);
								var snakeCaseName = phoenix.macros.AssignMacro.camelToSnake(field.field);
								transformedFields.push({field : snakeCaseName, expr : field.expr});
							};
						};
						var mapFields = [];
						{
							var ` = 0;
							while (` < transformedFields.length) {
								var field = transformedFields[`];
								++ `;
								mapFields.push({field : field.field, expr : field.expr});
							};
						};
						var mapExpr = {expr : haxe.macro.ExprDef.EObjectDecl(mapFields), pos : updates.pos};
						return cast {expr : haxe.macro.ExprDef.ECall({expr : haxe.macro.ExprDef.EField({expr : haxe.macro.ExprDef.EField({expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent("phoenix")), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3384)}, "Component", haxe.macro.EFieldKind.Normal), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3394)}, "assign", haxe.macro.EFieldKind.Normal), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3401)}, [socketExpr, mapExpr]), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 3377, 3424)};
					};
				};
			} else {
				haxe.macro.Context.error("Expected object literal with fields to merge", updates.pos, null);
				return null;
			};
		};
	}

	@:has_untyped
	public static function processAssignNew(socketExpr:haxe.macro.Expr, fieldExpr:haxe.macro.Expr, defaultFn:haxe.macro.Expr) {
		var fieldName = phoenix.macros.AssignMacro.extractFieldName(fieldExpr);
		if (fieldName == null) {
			haxe.macro.Context.error("Expected field access expression like _.fieldName", fieldExpr.pos, null);
		};
		var assignsType = phoenix.macros.AssignMacro.extractAssignsType(socketExpr);
		phoenix.macros.AssignMacro.validateFieldExists(assignsType, fieldName, fieldExpr.pos);
		var snakeCaseName = phoenix.macros.AssignMacro.camelToSnake(fieldName);
		var codeStr = "Phoenix.Component.assign_new({0}, :" + snakeCaseName + ", {1})";
		return cast {expr : haxe.macro.ExprDef.EUntyped({expr : haxe.macro.ExprDef.ECall({expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent("__elixir__")), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 4730, 4740)}, [haxe.macro.Context.makeExpr(codeStr, $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 4744, 4751)), socketExpr, defaultFn]), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 4730, 4778)}), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 4722, 4778)};
	}

	@:has_untyped
	public static function processUpdate(socketExpr:haxe.macro.Expr, fieldExpr:haxe.macro.Expr, updater:haxe.macro.Expr) {
		var fieldName = phoenix.macros.AssignMacro.extractFieldName(fieldExpr);
		if (fieldName == null) {
			haxe.macro.Context.error("Expected field access expression like _.fieldName", fieldExpr.pos, null);
		};
		var assignsType = phoenix.macros.AssignMacro.extractAssignsType(socketExpr);
		phoenix.macros.AssignMacro.validateFieldExists(assignsType, fieldName, fieldExpr.pos);
		var snakeCaseName = phoenix.macros.AssignMacro.camelToSnake(fieldName);
		var codeStr = "Phoenix.Component.update({0}, :" + snakeCaseName + ", {1})";
		return cast {expr : haxe.macro.ExprDef.EUntyped({expr : haxe.macro.ExprDef.ECall({expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent("__elixir__")), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 5925, 5935)}, [haxe.macro.Context.makeExpr(codeStr, $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 5939, 5946)), socketExpr, updater]), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 5925, 5971)}), pos : $__mk_pos__("../../std/phoenix/macros/AssignMacro.hx", 5917, 5971)};
	}

	static function extractFieldName(expr:haxe.macro.Expr) {
		@:ast(switch (expr.expr) {
	case EField({ expr : EConst(CIdent("_")) }, field):
		return field;	
	case EArray({ expr : EConst(CIdent("_")) }, { expr : EConst(CString(field, _)) }):
		return field;	
	case _:
		return null;	
}) {
			var ` = expr.expr;
			switch (enumIndex `) {
				case 1: {
					var ` = `[0];
					var ` = `[1];
					{
						var ` = `.expr;
						var ` = `.pos;
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (enumIndex ` == 3) {
								var ` = `[0];
								if (` == "_") {
									{
										var ` = `.expr;
										var ` = `.pos;
										if (enumIndex ` == 0) {
											var ` = `[0];
											if (enumIndex ` == 2) {
												var ` = `[0];
												var ` = `[1];
												{
													var field = `;
													{
														return field;
													};
												};
											} else {
												return null;
											};
										} else {
											return null;
										};
									};
								} else {
									return null;
								};
							} else {
								return null;
							};
						} else {
							return null;
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					var ` = `[2];
					{
						var ` = `.expr;
						var ` = `.pos;
						if (enumIndex ` == 0) {
							var ` = `[0];
							if (enumIndex ` == 3) {
								var ` = `[0];
								if (` == "_") {
									{
										var field = `;
										{
											return field;
										};
									};
								} else {
									return null;
								};
							} else {
								return null;
							};
						} else {
							return null;
						};
					};
				};
				default: {
					return null;
				}
			};
		};
	}

	static function extractAssignsType(socketExpr:haxe.macro.Expr) {
		var socketType = haxe.macro.Context.typeof(socketExpr);
		@:ast(switch (socketType) {
	case TAbstract(ref, params) if (ref.get().name == "LiveSocket" && params.length > 0):
		return params[0];	
	case TInst(ref, params) if (ref.get().name == "Socket" && params.length > 0):
		return params[0];	
	case _:
		Context.error("Unable to extract assigns type from socket", socketExpr.pos);
		return null;	
}) switch (enumIndex socketType) {
			case 2: {
				var ` = socketType[0];
				var ` = socketType[1];
				{
					var ref = `;
					var params = `;
					if (ref.get().name == "Socket" && params.length > 0) {
						return params[0];
					} else {
						haxe.macro.Context.error("Unable to extract assigns type from socket", socketExpr.pos, null);
						return null;
					};
				};
			};
			case 8: {
				var ` = socketType[0];
				var ` = socketType[1];
				{
					var ref = `;
					var params = `;
					if (ref.get().name == "LiveSocket" && params.length > 0) {
						return params[0];
					} else {
						haxe.macro.Context.error("Unable to extract assigns type from socket", socketExpr.pos, null);
						return null;
					};
				};
			};
			default: {
				haxe.macro.Context.error("Unable to extract assigns type from socket", socketExpr.pos, null);
				return null;
			}
		};
	}

	static function validateFieldExists(assignsType:haxe.macro.Type, fieldName:String, pos:haxe.macro.Position) {
		var fields = phoenix.macros.AssignMacro.getTypeFields(assignsType);
		if (! fields.exists(fieldName)) {
			var availableFields = {
				var ` = [];
				for (name in fields.keys()) {
					`.push(name);
				};
				`;
			};
			availableFields.sort(function(a:String, b:String) return Reflect.compare(a, b));
			var message = "Field \"" + fieldName + "\" does not exist in assigns type.\n";
			if (availableFields.length > 0) {
				message += "Available fields: " + availableFields.join(", ");
			} else {
				message += "The assigns type has no fields.";
			};
			haxe.macro.Context.error(message, pos, null);
		};
	}

	static function getTypeFields(type:haxe.macro.Type) {
		var fields = {
			{};
			new haxe.ds.StringMap();
		};
		@:ast(switch (type.follow()) {
	case TAnonymous(ref):
		for (field  in  ref.get().fields) {
			fields.set(field.name, true);
		};	
	case TInst(ref, _):
		var classType = ref.get();
		for (field  in  classType.fields.get()) {
			fields.set(field.name, true);
		};	
	case TType(ref, _):
		return getTypeFields(ref.get().type);	
	case _:
}) {
			var ` = {
				var once = null;
				haxe.macro.Context.follow(type, once);
			};
			switch (enumIndex `) {
				case 2: {
					var ` = `[0];
					var ` = `[1];
					{
						var ref = `;
						{
							var classType = ref.get();
							{
								var ` = 0;
								var ` = classType.fields.get();
								while (` < `.length) {
									var field = `[`];
									++ `;
									{
										var key = field.name;
										fields.set(key, true);
									};
								};
							};
						};
					};
				};
				case 3: {
					var ` = `[0];
					var ` = `[1];
					{
						var ref = `;
						{
							return phoenix.macros.AssignMacro.getTypeFields(ref.get().type);
						};
					};
				};
				case 5: {
					var ` = `[0];
					{
						var ref = `;
						{
							{
								var ` = 0;
								var ` = ref.get().fields;
								while (` < `.length) {
									var field = `[`];
									++ `;
									{
										var key = field.name;
										fields.set(key, true);
									};
								};
							};
						};
					};
				};
				default: {}
			};
		};
		return fields;
	}

	static function camelToSnake(name:String) {
		if (name.length == 0) {
			return name;
		};
		var result = new StringBuf();
		var prevWasUpper = false;
		{
			var ` = 0;
			var ` = name.length;
			while (` < `) {
				var i = ` ++;
				var char = name.charAt(i);
				var isUpper = char == char.toUpperCase() && char != char.toLowerCase();
				if (i > 0 && isUpper && ! prevWasUpper) {
					result.add("_");
				};
				result.add(char.toLowerCase());
				prevWasUpper = isUpper;
			};
		};
		return result.toString();
	}
}