@:realPath("phoenix.SafePubSub") @:keep @:directlyUsed @:used @:native("Phoenix.SafePubSub")
class Phoenix.SafePubSub {

	@:has_untyped
	public static function subscribeWithConverter<T>(topic:subscribeWithConverter.T, topicConverter:subscribeWithConverter.T -> String) {
		var pubsubModule = Phoenix.SafePubSub.getPubSubModule();
		var topicString = topicConverter(topic);
		var subscribeResult = Phoenix.PubSub.subscribe(pubsubModule, topicString);
		var isOk = __elixir__("{0} == :ok", subscribeResult);
		if ((isOk)) return haxe.functional.Result.Ok(null) else {
			var errorReason = __elixir__("\n                case {0} do\n                    {:error, reason} -> to_string(reason)\n                    _ -> \"Unknown subscription error\"\n                end", subscribeResult);
			return haxe.functional.Result.Error(errorReason);
		};
	}

	public static function broadcastWithConverters<T, M>(topic:broadcastWithConverters.T, message:broadcastWithConverters.M, topicConverter:broadcastWithConverters.T -> String, messageConverter:broadcastWithConverters.M -> Dynamic) {
		var pubsubModule = Phoenix.SafePubSub.getPubSubModule();
		var topicString = topicConverter(topic);
		var messagePayload = messageConverter(message);
		return Phoenix.PubSub.broadcast(pubsubModule, topicString, messagePayload);
	}

	public static function parseWithConverter<M>(msg:Dynamic, messageParser:Dynamic -> haxe.ds.Option<parseWithConverter.M>) {
		return messageParser(msg);
	}

	public static function addTimestamp(payload:Dynamic) {
		if ((payload == null)) payload = {};
		Reflect.setField(payload, "timestamp", _Date.Date_Impl_.getTime(cast DateTime.utc_now()));
		return payload;
	}

	public static function isValidMessage(msg:Dynamic) {
		return msg != null && Reflect.hasField(msg, "type") && Reflect.field(msg, "type") != null;
	}

	public static function createUnknownMessageError(messageType:String) {
		return "Unknown PubSub message type: \"" + messageType + "\". Check your message enum definitions.";
	}

	public static function createMalformedMessageError(msg:Dynamic) {
		var msgStr = try {
			var replacer = null;
			var space = null;
			haxe.format.JsonPrinter.print(msg, replacer, space);
		} catch (e:Dynamic) {
			"unparseable message";
		};
		return "Malformed PubSub message: " + msgStr + ". Expected message with \"type\" field.";
	}

	@:has_untyped
	public static function getPubSubModule() {
		return __elixir__("\n            debug? = System.get_env(\"SAFE_PUBSUB_DEBUG\") in [\"1\", \"true\", \"TRUE\"]\n            \n            # Get all loaded applications\n            apps = Application.loaded_applications()\n            \n            # Find the first application that has an endpoint module\n            {app_name, endpoint_module} = Enum.find_value(apps, fn {app, _desc, _vsn} ->\n                case :application.get_key(app, :modules) do\n                    {:ok, modules} ->\n                        endpoint = Enum.find(modules, fn mod ->\n                            mod_str = to_string(mod)\n                            String.ends_with?(mod_str, \".Endpoint\")\n                        end)\n                        if endpoint, do: {app, endpoint}, else: nil\n                    _ -> nil\n                end\n            end) || {:todo_app, TodoAppWeb.Endpoint}\n            \n            pubsub_mod = case Application.get_env(app_name, endpoint_module) do\n                nil -> \n                    # Fallback: construct proper module alias from app name\n                    app_mod = app_name\n                    |> to_string()\n                    |> String.split(\"_\")\n                    |> Enum.map(&String.capitalize/1)\n                    |> Module.concat()\n                    Module.concat(app_mod, :PubSub)\n                config when is_list(config) ->\n                    Keyword.get(config, :pubsub_server) || \n                        (app_name\n                        |> to_string()\n                        |> String.split(\"_\")\n                        |> Enum.map(&String.capitalize/1)\n                        |> Module.concat()\n                        |> (&Module.concat(&1, :PubSub)).())\n            end\n            if debug? do\n                IO.puts(\"[SafePubSub] app=#{inspect(app_name)} endpoint=#{inspect(endpoint_module)} pubsub=#{inspect(pubsub_mod)}\")\n            end\n            pubsub_mod\n        ");
	}
}