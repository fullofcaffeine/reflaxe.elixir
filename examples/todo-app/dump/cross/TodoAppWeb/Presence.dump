@:realPath("server.presence.TodoPresence") @:directlyUsed @:used @:keep @:build(phoenix.macros.PresenceMacro.build()) @:autoBuild(phoenix.macros.PresenceMacro.build()) @:native("TodoAppWeb.Presence") @:presence @:presenceTopic("users")
class TodoAppWeb.Presence implements phoenix.PresenceBehavior {

	@:keep @:value(PresenceTopic.Users)
	public static inline var TOPIC_ENUM:server.types.PresenceTopic = server.types.PresenceTopic.Users;

	@:keep @:value("users")
	public static inline var TOPIC:String = "users";

	@:keep
	public static function trackUser<T>(socket:Phoenix.LiveView.Socket<trackUser.T>, user:server.types.User) {
		var meta = {onlineAt : _Date.Date_Impl_.getTime(cast DateTime.utc_now()), userName : user.name, userEmail : user.email, avatar : null, editingTodoId : null, editingStartedAt : null};
		{
			var key = Std.string(user.id);
			__elixir__("Phoenix.Presence.track({0}, {1}, {2}, {3})", __elixir__("self()"), "users", key, meta);
		};
		return socket;
	}

	@:keep
	public static function updateUserEditing<T>(socket:Phoenix.LiveView.Socket<updateUserEditing.T>, user:server.types.User, todoId:Null<Int>) {
		var currentMeta = TodoAppWeb.Presence.getUserPresence(socket, user.id);
		if ((currentMeta == null)) return TodoAppWeb.Presence.trackUser(socket, user);
		var updatedMeta = {onlineAt : currentMeta.onlineAt, userName : currentMeta.userName, userEmail : currentMeta.userEmail, avatar : currentMeta.avatar, editingTodoId : todoId, editingStartedAt : if ((todoId != null)) _Date.Date_Impl_.getTime(cast DateTime.utc_now()) else null};
		{
			var key = Std.string(user.id);
			__elixir__("Phoenix.Presence.update({0}, {1}, {2}, {3})", __elixir__("self()"), "users", key, updatedMeta);
		};
		return socket;
	}

	@:keep
	static function getUserPresence<T>(socket:Phoenix.LiveView.Socket<getUserPresence.T>, userId:Int) {
		var presences = cast __elixir__("Phoenix.Presence.list({0})", "users");
		var userKey = Std.string(userId);
		if ((Reflect.hasField(presences, userKey))) {
			var entry = Reflect.field(presences, userKey);
			return if ((entry.metas.length > 0)) entry.metas[0] else null;
		};
		return null;
	}

	@:keep
	public static function listOnlineUsers<T>(socket:Phoenix.LiveView.Socket<listOnlineUsers.T>) {
		return cast __elixir__("Phoenix.Presence.list({0})", "users");
	}

	@:keep
	public static function getUsersEditingTodo<T>(socket:Phoenix.LiveView.Socket<getUsersEditingTodo.T>, todoId:Int) {
		var allUsers = cast __elixir__("Phoenix.Presence.list({0})", "users");
		var editingUsers = [];
		{
			var _g = 0;
			var _g1 = Reflect.fields(allUsers);
			while ((_g < _g1.length)) {
				var userId = _g1[_g];
				++ _g;
				var entry = Reflect.field(allUsers, userId);
				if ((entry.metas.length > 0)) {
					var meta = entry.metas[0];
					if ((meta.editingTodoId == todoId)) editingUsers.push(meta);
				};
			};
		};
		return editingUsers;
	}

	@:keep @:doc
	public static inline function trackSimple<M>(key:String, meta:trackSimple.M) {
		__elixir__("Phoenix.Presence.track({0}, {1}, {2}, {3})", __elixir__("self()"), "users", key, meta);
	}

	@:keep @:doc
	public static inline function updateSimple<M>(key:String, meta:updateSimple.M) {
		__elixir__("Phoenix.Presence.update({0}, {1}, {2}, {3})", __elixir__("self()"), "users", key, meta);
	}

	@:keep @:doc
	public static inline function untrackSimple(key:String) {
		__elixir__("Phoenix.Presence.untrack({0}, {1}, {2})", __elixir__("self()"), "users", key);
	}

	@:keep @:has_untyped @:doc
	public static inline function listSimple() {
		return __elixir__("Phoenix.Presence.list({0})", "users");
	}

	@:keep @:doc
	public static inline function trackWithSocket<T, M>(socket:trackWithSocket.T, topic:String, key:String, meta:trackWithSocket.M) {
		__elixir__("Phoenix.Presence.track({0}, {1}, {2}, {3})", __elixir__("self()"), topic, key, meta);
		return socket;
	}

	@:keep @:doc
	public static inline function updateWithSocket<T, M>(socket:updateWithSocket.T, topic:String, key:String, meta:updateWithSocket.M) {
		__elixir__("Phoenix.Presence.update({0}, {1}, {2}, {3})", __elixir__("self()"), topic, key, meta);
		return socket;
	}

	@:keep @:doc
	public static inline function untrackWithSocket<T>(socket:untrackWithSocket.T, topic:String, key:String) {
		__elixir__("Phoenix.Presence.untrack({0}, {1}, {2})", __elixir__("self()"), topic, key);
		return socket;
	}
}