package server.pubsub;

import phoenix.SafePubSub;
import haxe.ds.Option;
import haxe.functional.Result;
import server.types.Types.TodoPriority;
import server.types.Types.BulkOperationType;
import server.types.Types.AlertLevel;

/**
 * Todo-app specific PubSub topics and messages with complete type safety
 * 
 * This module demonstrates how applications should extend the framework's
 * SafePubSub infrastructure with their own domain-specific types.
 * 
 * ## Usage Examples
 * 
 * ```haxe
 * // Type-safe broadcasting - IntelliSense shows all options
 * TodoPubSub.broadcast(TodoUpdates, TodoCreated(newTodo));
 * 
 * // Type-safe subscription
 * TodoPubSub.subscribe(UserActivity);
 * 
 * // Type-safe message parsing in LiveView handle_info
 * switch (TodoPubSub.parseMessage(msg)) {
 *     case Some(TodoCreated(todo)): addTodoToUI(todo);
 *     case Some(TodoUpdated(todo)): updateTodoInUI(todo);
 *     case None: trace("Unknown message");
 * }
 * ```
 * 
 * ## Compile-Time Safety Examples
 * 
 * ```haxe
 * // ❌ This will be caught at compile-time:
 * TodoPubSub.broadcast(TodoUpades, TodoCreated(todo)); // "Unknown constructor"
 * 
 * // ❌ This will be caught at compile-time:
 * TodoPubSub.broadcast(TodoUpdates, TodoCreated(null)); // "Missing argument"
 * 
 * // ✅ This compiles and has IntelliSense support:
 * TodoPubSub.broadcast(TodoUpdates, TodoUpdated(updatedTodo));
 * ```
 */

/**
 * Type-safe PubSub topics for the todo application
 * 
 * Adding new topics requires:
 * 1. Add enum case here
 * 2. Add case to topicToString function
 * 3. Compiler ensures exhaustiveness
 */
enum TodoPubSubTopic {
    TodoUpdates;          // "todo:updates"
    UserActivity;         // "user:activity"  
    SystemNotifications;  // "system:notifications"
}

/**
 * Type-safe PubSub message types with compile-time validation
 * 
 * Each message type is strongly typed with required parameters.
 * Adding new messages requires updating parseMessage function.
 */
enum TodoPubSubMessage {
    TodoCreated(todo: server.schemas.Todo);
    TodoUpdated(todo: server.schemas.Todo);
    TodoDeleted(id: Int);
    BulkUpdate(action: BulkOperationType);
    UserOnline(user_id: Int);
    UserOffline(user_id: Int);
    SystemAlert(message: String, level: AlertLevel);
}

// BulkOperationType and AlertLevel are imported from server.types.Types

/**
 * Todo-app specific SafePubSub wrapper with complete type safety
 * 
 * This class provides a convenient API for the todo application while
 * using the framework's SafePubSub infrastructure underneath.
 */
class TodoPubSub {
    
    /**
     * Type-safe subscribe to a topic
     * 
     * @param topic Topic to subscribe to (with IntelliSense support)
     * @return Result indicating success or failure with descriptive error
     */
    public static function subscribe(topic: TodoPubSubTopic): Result<Void, String> {
        return SafePubSub.subscribeTopic(topicToString(topic));
    }
    
    /**
     * Type-safe broadcast with topic and message validation
     * 
     * @param topic Topic to broadcast to (compile-time validated)
     * @param message Message to broadcast (compile-time structure validated)
     * @return Result indicating success or failure with descriptive error
     */
    public static function broadcast(topic: TodoPubSubTopic, message: TodoPubSubMessage): Result<Void, String> {
        return SafePubSub.broadcastTopicPayload(topicToString(topic), messageToElixir(message));
    }
    
    /**
     * Parse incoming PubSub messages back to typed enums
     * 
     * @param msg Raw Dynamic message from Phoenix PubSub
     * @return Typed message or None if parsing failed
     * 
     * NOTE: This function should be auto-generated by macro in Phase 2.
     * Manual implementation ensures type safety until macro is available.
     */
    public static function parseMessage(msg: Dynamic): Option<TodoPubSubMessage> {
        return SafePubSub.parseWithConverter(msg, parseMessageImpl);
    }
    
    // ========================================================================
    // Private Implementation Functions
    // ========================================================================
    
    /**
     * Convert TodoPubSubTopic enum to string for Elixir compatibility
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function topicToString(topic: TodoPubSubTopic): String {
        return switch (topic) {
            case TodoUpdates: "todo:updates";
            case UserActivity: "user:activity";
            case SystemNotifications: "system:notifications";
        };
    }
    
    /**
     * Convert typed message to Dynamic object for Elixir PubSub
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function messageToElixir(message: TodoPubSubMessage): Dynamic {
        // Avoid ephemeral locals: build payload inline and add timestamp
        return SafePubSub.addTimestamp(switch (message) {
            case TodoCreated(todo):
                { type: "todo_created", todo: todo };
            case TodoUpdated(todo):
                { type: "todo_updated", todo: todo };
            case TodoDeleted(id):
                cast { type: "todo_deleted", todo_id: id };
            case BulkUpdate(action):
                cast { type: "bulk_update", action: bulkActionToString(action) };
            case UserOnline(user_id):
                cast { type: "user_online", user_id: user_id };
            case UserOffline(user_id):
                cast { type: "user_offline", user_id: user_id };
            case SystemAlert(message, level):
                cast { type: "system_alert", message: message, level: alertLevelToString(level) };
        });
    }
    
    /**
     * Parse Dynamic message to typed enum (implementation)
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function parseMessageImpl(msg: Dynamic): Option<TodoPubSubMessage> {
        if (!SafePubSub.isValidMessage(msg)) {
            trace(SafePubSub.createMalformedMessageError(msg));
            return None;
        }
        
        return switch (msg.type) {
            case "todo_created":
                if (msg.todo != null) Some(TodoCreated(msg.todo)) else None;
            case "todo_updated":
                if (msg.todo != null) Some(TodoUpdated(msg.todo)) else None;
            case "todo_deleted":
                if (msg.todo_id != null) Some(TodoDeleted(msg.todo_id)) else None;
            case "bulk_update":
                if (msg.action != null) {
                    return switch (msg.action) {
                        case "complete_all": Some(BulkUpdate(CompleteAll));
                        case "delete_completed": Some(BulkUpdate(DeleteCompleted));
                        case "set_priority": Some(BulkUpdate(SetPriority(TodoPriority.Medium)));
                        case "add_tag": Some(BulkUpdate(AddTag("")));
                        case "remove_tag": Some(BulkUpdate(RemoveTag("")));
                        case _: None;
                    };
                } else None;
            case "user_online":
                if (msg.user_id != null) Some(UserOnline(msg.user_id)) else None;
            case "user_offline":
                if (msg.user_id != null) Some(UserOffline(msg.user_id)) else None;
            case "system_alert":
                if (msg.message != null && msg.level != null) {
                    return switch (msg.level) {
                        case "info": Some(SystemAlert(msg.message, Info));
                        case "warning": Some(SystemAlert(msg.message, Warning));
                        case "error": Some(SystemAlert(msg.message, Error));
                        case "critical": Some(SystemAlert(msg.message, Critical));
                        case _: None;
                    };
                } else None;
            case _:
                trace(SafePubSub.createUnknownMessageError(msg.type));
                None;
        };
    }
    
    /**
     * Convert bulk action enum to string
     */
    private static function bulkActionToString(action: BulkOperationType): String {
        return switch (action) {
            case CompleteAll: "complete_all";
            case DeleteCompleted: "delete_completed";
            case SetPriority(priority): "set_priority";
            case AddTag(tag): "add_tag";
            case RemoveTag(tag): "remove_tag";
        };
    }
    
    /**
     * Parse bulk action string back to enum
     */
    @:keep private static function parseBulkAction(action: String): Null<BulkOperationType> {
        return switch (action) {
            case "complete_all": CompleteAll;
            case "delete_completed": DeleteCompleted;
            case "set_priority": SetPriority(TodoPriority.Medium);
            case "add_tag": AddTag("");
            case "remove_tag": RemoveTag("");
            case _: null;
        };
    }
    
    /**
     * Convert alert level enum to string
     */
    private static function alertLevelToString(level: AlertLevel): String {
        return switch (level) {
            case Info: "info";
            case Warning: "warning";  
            case Error: "error";
            case Critical: "critical";
        };
    }
    
    /**
     * Parse alert level string back to enum
     */
    @:keep private static function parseAlertLevel(level: String): Null<AlertLevel> {
        return switch (level) {
            case "info": Info;
            case "warning": Warning;  
            case "error": Error;
            case "critical": Critical;
            case _: null;
        };
    }
}
