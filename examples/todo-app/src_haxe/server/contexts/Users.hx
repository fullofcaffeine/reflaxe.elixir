package contexts;

import elixir.types.Result;
import ecto.Changeset;
import ecto.Query;
import server.infrastructure.Repo;

/**
 * Complete user management context with Ecto integration
 * Demonstrates schemas, changesets, queries, and business logic
 */

typedef UserFilter = {
    ?name: String,
    ?email: String,
    ?isActive: Bool
}

@:schema("users")
class User {
    @:primary_key
    public var id: Int;
    
    @:field({type: "string", nullable: false})
    public var name: String;
    
    @:field({type: "string", nullable: false})
    public var email: String;
    
    @:field({type: "integer"})
    public var age: Int;
    
    @:field({type: "boolean", defaultValue: true})
    public var active: Bool;
    
    @:timestamps
    public var insertedAt: String;
    public var updatedAt: String;
    
    @:has_many("posts", "Post", "user_id")
    public var posts: Array<Post>;
}

/**
 * UserChangeset provides custom changeset logic for User validation
 * 
 * This is separate from the auto-generated changeset in the User @:schema class.
 * The User.changeset function is generated by @:schema, but this allows custom validation.
 */
class UserChangeset {
    public static function changeset(?user: User, attrs: UserParams): Changeset<User, UserParams> {
        // Create a typed changeset for compile-time safety
        // The actual Ecto validations would be added by the generated Elixir code
        var changeset = new Changeset(user, attrs);
        
        // Validation annotations would go here when implemented:
        // @:validate_required(["name", "email"])
        // @:validate_format("email", "email_regex")
        // @:validate_length("name", {min: 2, max: 100})
        // @:validate_number("age", {greater_than: 0, less_than: 150})
        
        return changeset;
    }
}

class Users {
    /**
     * Get all users with optional filtering
     */
    public static function listUsers(?filter: UserFilter): Array<User> {
        // Use typed Repo extern for type-safe database access
        if (filter != null) {
            // Apply filtering based on the provided criteria
            var query = Query.from(User);
            
            if (filter.name != null) {
                // Use the where method on the EctoQuery instance
                query = query.where("name", '%${filter.name}%');
            }
            if (filter.email != null) {
                query = query.where("email", '%${filter.email}%');
            }
            if (filter.isActive != null) {
                query = query.where("active", filter.isActive);
            }
            
            return Repo.all(query);
        }
        
        return Repo.all(User);
    }
    
    /**
     * Create changeset for user (required by LiveView example)
     */
    public static function changeUser(?user: User): Changeset<User, UserParams> {
        // Create Ecto changeset for form validation
        // For new users, pass null and let the changeset handle the empty struct
        var emptyParams: UserParams = {};
        return new Changeset(user, emptyParams);
    }
    
    /**
     * Main function for compilation testing
     */
    public static function main(): Void {
        trace("Users context with User schema compiled successfully!");
    }
    
    /**
     * Get user by ID with error handling
     */
    public static function getUser(id: Int): User {
        // Use typed Repo extern - throws if not found
        var user = Repo.get(User, id);
        if (user == null) {
            throw 'User not found with id: $id';
        }
        return user;
    }
    
    /**
     * Get user by ID, returns null if not found
     */
    public static function getUserSafe(id: Int): Null<User> {
        // Use typed Repo extern for safe lookup
        return Repo.get(User, id);
    }
    
    /**
     * Create a new user
     * Returns Result with either the created User or the invalid Changeset
     */
    public static function createUser(attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Create changeset and insert using typed Repo
        // Pass null for new user - the changeset will handle struct creation
        var changeset = UserChangeset.changeset(null, attrs);
        return Repo.insert(changeset);
    }
    
    /**
     * Update existing user
     * Returns Result with either the updated User or the invalid Changeset
     */
    public static function updateUser(user: User, attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Update user using typed Repo
        var changeset = UserChangeset.changeset(user, attrs);
        return Repo.update(changeset);
    }
    
    /**
     * Delete user (hard delete from database)
     * Returns Result with either the deleted User or a Changeset with errors
     */
    public static function deleteUser(user: User): Result<User, Changeset<User, {}>> {
        // Delete user using typed Repo
        return Repo.delete(user);
    }
    
    /**
     * Search users by name or email
     */
    public static function searchUsers(term: String): Array<User> {
        // Query DSL implementation will be handled by future @:query annotation
        return [];
    }
    
    /**
     * Get users with their posts (preload association)
     */
    static function usersWithPosts(): Array<User> {
        // Query DSL implementation will be handled by future @:query annotation
        return [];
    }
    
    /**
     * Get user statistics
     */
    public static function userStats(): UserStats {
        // Query DSL implementation will be handled by future @:query annotation
        return {total: 0, active: 0, inactive: 0};
    }
}

// Supporting types
typedef UserParams = {
    ?name: String,
    ?email: String,
    ?age: Int,
    ?active: Bool
}

typedef UserStats = {
    total: Int,
    active: Int,
    inactive: Int
}

typedef Post = {
    id: Int,
    title: String,
    user_id: Int
}