package contexts;

import elixir.types.Result;
import ecto.Changeset;
import ecto.TypedQuery;
import server.infrastructure.Repo;
using reflaxe.elixir.macros.TypedQueryLambda; // ensure extension where(...) is available

/**
 * Complete user management context with Ecto integration
 * Demonstrates schemas, changesets, queries, and business logic
 */

typedef UserFilter = {
    ?name: String,
    ?email: String,
    ?isActive: Bool
}

@:schema("users")
class User {
    @:primary_key
    public var id: Int;
    
    @:field({type: "string", nullable: false})
    public var name: String;
    
    @:field({type: "string", nullable: false})
    public var email: String;
    
    @:field({type: "integer"})
    public var age: Int;
    
    @:field({type: "boolean", defaultValue: true})
    public var active: Bool;
    
    @:timestamps
    public var insertedAt: String;
    public var updatedAt: String;
    
    @:has_many("posts", "Post", "user_id")
    public var posts: Array<Post>;
}

/**
 * UserChangeset provides custom changeset logic for User validation
 * 
 * This is separate from the auto-generated changeset in the User @:schema class.
 * The User.changeset function is generated by @:schema, but this allows custom validation.
 */
class UserChangeset {
    public static function changeset(?user: User, attrs: UserParams): Changeset<User, UserParams> {
        // Create a typed changeset for compile-time safety
        // The actual Ecto validations would be added by the generated Elixir code
        // Return inline to avoid losing the binding during hygiene passes
        return new Changeset(user, attrs);
    }
}

@:native("TodoApp.Users")
class Users {
    /**
     * Get all users with optional filtering
     */
    public static function listUsers(?filter: UserFilter): Array<User> {
        // Build a single query variable and refine it conditionally; return at the end.
        var query = TypedQuery.from(contexts.User);
        if (filter != null) {
            if (filter.name != null) {
                query = query.where(u -> u.name == '%${filter.name}%');
            }
            if (filter.email != null) {
                query = query.where(u -> u.email == '%${filter.email}%');
            }
            if (filter.isActive != null) {
                query = query.where(u -> u.active == filter.isActive);
            }
        }
        return Repo.all(query);
    }
    
    /**
     * Create changeset for user (required by LiveView example)
     */
    public static function changeUser(?user: User): Changeset<User, UserParams> {
        // Create Ecto changeset for form validation
        // For new users, pass null and let the changeset handle the empty struct
        return new Changeset(user, {});
    }
    
    /**
     * Main function for compilation testing
     */
    public static function main(): Void {
        trace("Users context with User schema compiled successfully!");
    }
    
    /**
     * Get user by ID with error handling
     */
    public static function getUser(id: Int): User {
        // Use typed Repo extern - throws if not found
        var user = Repo.get(User, id);
        if (user == null) {
            throw 'User not found with id: $id';
        }
        return user;
    }
    
    /**
     * Get user by ID, returns null if not found
     */
    public static function getUserSafe(id: Int): Null<User> {
        // Use typed Repo extern for safe lookup
        return Repo.get(User, id);
    }
    
    /**
     * Create a new user
     * Returns Result with either the created User or the invalid Changeset
     */
    public static function createUser(attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Inline changeset to avoid temp var naming drift
        return Repo.insert(UserChangeset.changeset(null, attrs));
    }
    
    /**
     * Update existing user
     * Returns Result with either the updated User or the invalid Changeset
     */
    public static function updateUser(user: User, attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Inline changeset to avoid temp var naming drift
        return Repo.update(UserChangeset.changeset(user, attrs));
    }
    
    /**
     * Delete user (hard delete from database)
     * Returns Result with either the deleted User or a Changeset with errors
     */
    public static function deleteUser(user: User): Result<User, Changeset<User, {}>> {
        // Delete user using typed Repo
        return Repo.delete(user);
    }
    
    /**
     * Search users by name or email
     */
    public static function searchUsers(term: String): Array<User> {
        // Query DSL implementation will be handled by future @:query annotation
        return [];
    }
    
    /**
     * Get user statistics
     */
    public static function userStats(): UserStats {
        // Query DSL implementation will be handled by future @:query annotation
        return {total: 0, active: 0, inactive: 0};
    }
}

// Supporting types
typedef UserParams = {
    ?name: String,
    ?email: String,
    ?age: Int,
    ?active: Bool
}

typedef UserStats = {
    total: Int,
    active: Int,
    inactive: Int
}

typedef Post = {
    id: Int,
    title: String,
    user_id: Int
}
