defmodule Mix.Tasks.Haxe.Gen.Schema do
  @moduledoc """
  Generates an Ecto schema authored in Haxe.

  This task is **Haxe-first**: it writes a Haxe `@:schema` class and relies on the
  Reflaxe.Elixir compiler to generate the Elixir module when you compile your project.

  ## Examples

      mix haxe.gen.schema User
      mix haxe.gen.schema Post --table posts
      mix haxe.gen.schema Account --fields "name:string,email:string,age:integer"

  ## Options

    * `--table` - Specify the table name (defaults to pluralized schema name)
    * `--fields` - Comma-separated list of fields (e.g., "name:string,email:string,age:integer")
    * `--primary-key` - Specify custom primary key field (default: "id")
    * `--timestamps` - Include timestamps (default: true)
    * `--haxe-dir` - Directory for Haxe schema files (default: "src_haxe/schemas")
    * `--changeset` - Generate changeset function (default: true)

  """
  use Mix.Task

  @shortdoc "Generates a new Haxe-based Ecto schema"

  @doc """
  Entry point for the Mix task
  """
  def run(args) do
    {opts, [schema_name | _], _} = OptionParser.parse(args, 
      switches: [
        table: :string,
        fields: :string,
        primary_key: :string,
        timestamps: :boolean,
        haxe_dir: :string,
        changeset: :boolean
      ]
    )

    if schema_name == nil do
      Mix.shell().error("Schema name is required. Usage: mix haxe.gen.schema SchemaName")
      System.halt(1)
    end

    generate_schema(schema_name, opts)
  end

  # Generate Haxe schema source (Elixir is generated by compilation)
  defp generate_schema(schema_name, opts) do
    # Configuration
    haxe_dir = Keyword.get(opts, :haxe_dir, "src_haxe/schemas")
    table_name = Keyword.get(opts, :table, infer_table_name(schema_name))
    fields = parse_fields(Keyword.get(opts, :fields, ""))

    # Create directories
    File.mkdir_p!(haxe_dir)
    
    # Generate Haxe schema file
    haxe_content = generate_haxe_schema_content(schema_name, table_name, fields, opts)
    haxe_filename = "#{haxe_dir}/#{schema_name}.hx"
    
    File.write!(haxe_filename, haxe_content)
    Mix.shell().info("Generated Haxe schema: #{haxe_filename}")
    
    # Display next steps
    Mix.shell().info("")
    Mix.shell().info("Next steps:")
    Mix.shell().info("  1. Edit #{haxe_filename} to customize fields + changeset rules")
    Mix.shell().info("  2. Ensure this type is included in your build.hxml")
    Mix.shell().info("  3. Run: mix compile.haxe (or `haxe build.hxml`) to generate Elixir")
    
    :ok
  end

  # Generate Haxe schema source file content
  defp generate_haxe_schema_content(schema_name, table_name, fields, opts) do
    primary_key = Keyword.get(opts, :primary_key, "id")
    include_timestamps = Keyword.get(opts, :timestamps, true)
    generate_changeset = Keyword.get(opts, :changeset, true)

    {field_definitions, imports, cast_fields, required_fields, params_fields} =
      generate_haxe_fields(fields, primary_key, include_timestamps)

    changeset_meta =
      if generate_changeset do
        "@:changeset([#{Enum.join(cast_fields, ", ")}], [#{Enum.join(required_fields, ", ")}])\n"
      else
        ""
      end

    params_typedef =
      if params_fields == [] do
        ""
      else
        """
        typedef #{schema_name}Params = {
        #{Enum.join(params_fields, "\n")}
        }

        """
      end

    changeset_extern =
      if generate_changeset do
        """
            /**
             * Standard changeset for create/update.
             * Generated by the schema transformer; this extern exposes it to Haxe code.
             */
            extern public static function changeset(struct: #{schema_name}, params: #{schema_name}Params): Changeset<#{schema_name}, #{schema_name}Params>;
        """
      else
        ""
      end

    """
    package schemas;

    /**
     * Generated Haxe schema: #{schema_name}
     * 
     * This schema maps to the #{table_name} table in your database.
     * Customize the fields, associations, and validation rules below.
     * 
     * After editing, run `mix compile` to generate the corresponding Elixir schema.
     */
    #{Enum.join(imports, "\n")}

    #{params_typedef}@:native("#{app_module_name()}.#{schema_name}")
    @:schema("#{table_name}")
    #{if include_timestamps, do: "@:timestamps\n", else: ""}#{changeset_meta}class #{schema_name} {
      
    #{field_definitions}

        public function new() {}

    #{changeset_extern}
    }
    """
  end

  # Generate Haxe field definitions
  defp generate_haxe_fields(fields, primary_key, _include_timestamps) do
    imports = [
      "import ecto.Changeset;",
      "import elixir.types.Term;"
    ]

    {field_lines, cast_fields, required_fields, params_fields, needs_naive_datetime?} =
      Enum.reduce(fields, {[], [], [], [], false}, fn {name, type, opts}, {field_lines, cast_fields, required_fields, params_fields, needs_ndt?} ->
        haxe_name = to_haxe_field_name(name)
        {haxe_type, needs_ndt} = ecto_type_to_haxe(type, opts)

        field_lines = ["    @:field public var #{haxe_name}: #{haxe_type};" | field_lines]
        cast_fields = ["\"#{haxe_name}\"" | cast_fields]
        required_fields = if Enum.member?(opts, :null), do: required_fields, else: ["\"#{haxe_name}\"" | required_fields]
        params_fields = ["    ?#{haxe_name}: #{haxe_type}," | params_fields]
        {field_lines, cast_fields, required_fields, params_fields, needs_ndt? or needs_ndt}
      end)

    imports =
      if needs_naive_datetime? do
        imports ++ ["import elixir.DateTime.NaiveDateTime;"]
      else
        imports
      end

    # Primary key first
    field_lines = ["    @:field @:primary_key public var #{primary_key}: Int;" | field_lines]

    # Render with stable ordering
    rendered_fields =
      field_lines
      |> Enum.reverse()
      |> Enum.join("\n")

    # Params typedef: drop trailing comma on last field if any
    params_fields =
      params_fields
      |> Enum.reverse()
      |> Enum.map(&String.trim_trailing(&1, ","))

    cast_fields = cast_fields |> Enum.reverse()
    required_fields = required_fields |> Enum.reverse()

    {rendered_fields, imports, cast_fields, required_fields, params_fields}
  end

  # Infer table name from schema name
  defp infer_table_name(schema_name) do
    schema_name
    |> Macro.underscore()
    |> pluralize()
  end

  # Simple pluralization without external dependencies
  defp pluralize(word) when is_binary(word) do
    cond do
      String.ends_with?(word, ["s", "sh", "ch", "x", "z"]) -> word <> "es"
      String.ends_with?(word, "y") and not String.ends_with?(word, ["ay", "ey", "iy", "oy", "uy"]) ->
        String.slice(word, 0..-2//-1) <> "ies"
      String.ends_with?(word, "f") -> String.slice(word, 0..-2//-1) <> "ves"
      String.ends_with?(word, "fe") -> String.slice(word, 0..-3//-1) <> "ves"
      true -> word <> "s"
    end
  end

  # Parse field specifications from command line
  defp parse_fields(""), do: [{"name", "string", []}, {"description", "text", []}]
  defp parse_fields(fields_string) do
    fields_string
    |> String.split(",")
    |> Enum.map(fn field_spec ->
      case String.split(field_spec, ":") do
        [name, type, "unique"] -> {String.trim(name), String.trim(type), [:unique]}
        [name, type, "null"] -> {String.trim(name), String.trim(type), [:null]}
        [name, type] -> {String.trim(name), String.trim(type), []}
        [name] -> {String.trim(name), "string", []}
      end
    end)
  end

  defp ecto_type_to_haxe(type, opts) do
    base =
      case String.downcase(type) do
        "string" -> {"String", false}
        "text" -> {"String", false}
        "integer" -> {"Int", false}
        "boolean" -> {"Bool", false}
        "float" -> {"Float", false}
        "decimal" -> {"Float", false}
        "datetime" -> {"NaiveDateTime", true}
        "naive_datetime" -> {"NaiveDateTime", true}
        _ -> {"Term", false}
      end

    {haxe_type, needs_ndt?} = base
    if Enum.member?(opts, :null), do: {"Null<#{haxe_type}>", needs_ndt?}, else: {haxe_type, needs_ndt?}
  end

  defp to_haxe_field_name(name) when is_binary(name) do
    name
    |> String.trim()
    |> Macro.underscore()
    |> String.split("_", trim: true)
    |> Enum.with_index()
    |> Enum.map(fn
      {part, 0} -> part
      {part, _} -> String.capitalize(part)
    end)
    |> Enum.join()
  end

  defp app_module_name() do
    Mix.Project.config()[:app]
    |> to_string()
    |> Macro.camelize()
  end
end
