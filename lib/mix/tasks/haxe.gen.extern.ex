defmodule Mix.Tasks.Haxe.Gen.Extern do
  @moduledoc """
  Generates a starter Haxe `extern` from an Elixir module.

  This is intended to help you integrate existing Elixir/Erlang libraries from Haxe
  without reaching for `untyped __elixir__(...)` in application code.

  The generated extern uses `elixir.types.Term` at the boundary by default (safe, but generic).
  You can then tighten types incrementally and decode dynamic returns with `elixir.types.TermDecoder`.

  ## Examples

      mix haxe.gen.extern Enum
      mix haxe.gen.extern Ecto.Changeset --package externs.ecto --out src_haxe/externs
      mix haxe.gen.extern :crypto --package externs.erlang --out src_haxe/externs

  ## Options

    * `--out` - Output directory (default: `src_haxe/externs`)
    * `--package` - Haxe package name (default: `externs`)
    * `--class-name` - Override generated Haxe class name (default: last segment of module)

  """

  use Mix.Task

  @shortdoc "Generate a starter Haxe extern from an Elixir module"

  @impl true
  def run(args) do
    Mix.Task.run("app.start")

    {opts, argv, _} =
      OptionParser.parse(args,
        switches: [
          out: :string,
          package: :string,
          class_name: :string
        ]
      )

    case argv do
      [module_name | _] ->
        generate(module_name, opts)

      _ ->
        Mix.shell().error("""
        Expected a module name.

        Usage:
          mix haxe.gen.extern Module.Name [--out DIR] [--package PKG] [--class-name Name]
        """)

        System.halt(1)
    end
  end

  defp generate(module_name, opts) when is_binary(module_name) do
    native_module = String.trim(module_name)
    module = parse_module(native_module)

    unless Code.ensure_loaded?(module) do
      Mix.shell().error("Module not available: #{native_module}")
      System.halt(1)
    end

    out_dir = Keyword.get(opts, :out, "src_haxe/externs")
    pkg = Keyword.get(opts, :package, "externs") |> normalize_package()
    class_name = Keyword.get(opts, :class_name, default_class_name(native_module))

    functions =
      module.__info__(:functions)
      |> Enum.map(fn {name, arity} -> {Atom.to_string(name), arity} end)
      |> Enum.sort_by(fn {name, arity} -> {name, arity} end)
      |> Enum.group_by(fn {name, _arity} -> name end, fn {_name, arity} -> arity end)

    File.mkdir_p!(out_dir)

    file_path = Path.join(out_dir, "#{class_name}.hx")
    File.write!(file_path, render_haxe(pkg, class_name, native_module, functions))

    Mix.shell().info("Generated extern: #{file_path}")
    Mix.shell().info("Next: tighten types + decode boundaries with elixir.types.TermDecoder")
  end

  defp parse_module(":" <> _ = erl) do
    String.to_atom(erl)
  end

  defp parse_module(elixir_module) do
    parts = String.split(elixir_module, ".", trim: true)
    Module.concat(parts)
  end

  defp default_class_name(":" <> rest) do
    rest |> Macro.camelize()
  end

  defp default_class_name(module_name) do
    module_name |> String.split(".", trim: true) |> List.last() |> to_string()
  end

  defp normalize_package(pkg) do
    pkg
    |> String.trim()
    |> String.split(".", trim: true)
    |> Enum.map(&String.downcase/1)
    |> Enum.join(".")
  end

  defp render_haxe(pkg, class_name, native_module, functions_by_name) do
    header = """
    // Generated by `mix haxe.gen.extern`
    // Native module: #{native_module}

    package #{pkg};

    import elixir.types.Term;

    @:native("#{native_module}")
    extern class #{class_name} {

    """

    body =
      functions_by_name
      |> Enum.map(fn {name, arities} -> render_function_group(name, arities) end)
      |> Enum.join("\n")

    footer = """
    }
    """

    header <> body <> footer
  end

  defp render_function_group(name, arities) do
    arities = Enum.sort(arities)
    haxe_name = haxe_function_name(name)

    case arities do
      [arity] ->
        render_function(name, haxe_name, arity, [])

      _ ->
        max_arity = Enum.max(arities)
        overloads = Enum.filter(arities, &(&1 != max_arity))
        render_function(name, haxe_name, max_arity, overloads)
    end
  end

  defp render_function(native_name, haxe_name, arity, overload_arities) do
    overloads =
      overload_arities
      |> Enum.map(fn overload_arity ->
        """
            @:overload(function(#{render_params(overload_arity)}): Term {})
        """
      end)
      |> Enum.join("")

    """
        #{overloads}    @:native("#{native_name}")
        public static function #{haxe_name}(#{render_params(arity)}): Term;
    """
  end

  defp render_params(0), do: ""

  defp render_params(arity) do
    1..arity
    |> Enum.map(&param_name/1)
    |> Enum.map(fn name -> "#{name}: Term" end)
    |> Enum.join(", ")
  end

  defp param_name(1), do: "first"
  defp param_name(2), do: "second"
  defp param_name(3), do: "third"
  defp param_name(4), do: "fourth"
  defp param_name(5), do: "fifth"
  defp param_name(6), do: "sixth"
  defp param_name(7), do: "seventh"
  defp param_name(8), do: "eighth"
  defp param_name(9), do: "ninth"
  defp param_name(10), do: "tenth"
  defp param_name(11), do: "eleventh"
  defp param_name(12), do: "twelfth"
  defp param_name(13), do: "thirteenth"
  defp param_name(14), do: "fourteenth"
  defp param_name(15), do: "fifteenth"
  defp param_name(16), do: "sixteenth"
  defp param_name(17), do: "seventeenth"
  defp param_name(18), do: "eighteenth"
  defp param_name(19), do: "nineteenth"
  defp param_name(20), do: "twentieth"

  defp param_name(n) when is_integer(n) and n > 20 do
    # Avoid numeric suffixes in generated Haxe identifiers; fall back to lettered args.
    "arg" <> base26_alpha(n - 21)
  end

  defp base26_alpha(n) when is_integer(n) and n >= 0 do
    # 0 -> A, 25 -> Z, 26 -> AA, ...
    alphabet = ~c"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    to_base26_alpha(n, alphabet, [])
  end

  defp to_base26_alpha(n, alphabet, acc) when n < 26 do
    [Enum.at(alphabet, n) | acc] |> to_string()
  end

  defp to_base26_alpha(n, alphabet, acc) do
    q = div(n, 26) - 1
    r = rem(n, 26)
    to_base26_alpha(q, alphabet, [Enum.at(alphabet, r) | acc])
  end

  defp haxe_function_name(native) do
    {base, suffix} =
      cond do
        String.ends_with?(native, "?") -> {String.trim_trailing(native, "?"), "Q"}
        String.ends_with?(native, "!") -> {String.trim_trailing(native, "!"), "Bang"}
        true -> {native, ""}
      end

    base =
      base
      |> String.replace(~r/[^a-zA-Z0-9_]/, "_")
      |> Macro.camelize()

    name =
      case base do
        "" -> "call"
        other -> String.replace_prefix(other, String.first(other), String.downcase(String.first(other)))
      end

    sanitize_haxe_ident(name <> suffix)
  end

  defp sanitize_haxe_ident("new"), do: "new_"
  defp sanitize_haxe_ident("function"), do: "function_"
  defp sanitize_haxe_ident("var"), do: "var_"
  defp sanitize_haxe_ident(other), do: other
end
