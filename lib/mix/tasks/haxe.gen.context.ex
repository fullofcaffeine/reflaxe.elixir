defmodule Mix.Tasks.Haxe.Gen.Context do
  @moduledoc """
  Generates a Phoenix context authored in Haxe.

  This task is **Haxe-first**: it writes Haxe source files only. The corresponding
  Elixir modules are generated when you compile your project with Reflaxe.Elixir.

  ## Examples

      mix haxe.gen.context Accounts User users
      mix haxe.gen.context Blog Post posts --schema-attrs "title:string,body:text"

  ## Arguments

    * `context` - Context module name (e.g., Accounts, Blog)
    * `schema` - Schema module name (e.g., User, Post)
    * `table` - Table name (e.g., users, posts)

  ## Options

    * `--schema-attrs` - Schema field attributes (e.g., "name:string,email:string,age:integer")
    * `--no-schema` - Skip schema generation (use existing schema)
    * `--changeset` - Include changeset-based CRUD (default: true)
    * `--repo` - Haxe type path for Repo module (default: "Repo")
    * `--haxe-dir` - Directory for context files (default: "src_haxe/contexts")
    * `--schema-dir` - Directory for schema files (default: "src_haxe/schemas")
  """
  use Mix.Task

  @shortdoc "Generates a Phoenix context (Haxe-first)"

  @impl Mix.Task
  def run(args) do
    {opts, [context_name, schema_name, table_name | _], _errors} =
      OptionParser.parse(args,
        switches: [
          schema_attrs: :string,
          schema_dir: :string,
          no_schema: :boolean,
          changeset: :boolean,
          repo: :string,
          haxe_dir: :string
        ]
      )

    if context_name == nil or schema_name == nil or table_name == nil do
      Mix.shell().error("Context name, schema name, and table name are required.")
      Mix.shell().error("Usage: mix haxe.gen.context ContextName SchemaName table_name")
      System.halt(1)
    end

    generate_context(context_name, schema_name, table_name, opts)
  end

  defp generate_context(context_name, schema_name, table_name, opts) do
    haxe_dir = Keyword.get(opts, :haxe_dir, "src_haxe/contexts")
    schema_dir = Keyword.get(opts, :schema_dir, "src_haxe/schemas")
    repo_type = Keyword.get(opts, :repo, "Repo")
    generate_schema? = not Keyword.get(opts, :no_schema, false)
    include_changeset? = Keyword.get(opts, :changeset, true)
    schema_attrs = Keyword.get(opts, :schema_attrs, "")

    File.mkdir_p!(haxe_dir)
    File.mkdir_p!(schema_dir)

    if generate_schema? do
      Mix.Task.reenable("haxe.gen.schema")

      schema_args =
        [schema_name, "--table", table_name, "--haxe-dir", schema_dir] ++
          (if schema_attrs != "", do: ["--fields", schema_attrs], else: [])

      Mix.Task.run("haxe.gen.schema", schema_args)
    end

    haxe_content =
      generate_haxe_context_content(context_name, schema_name, table_name, repo_type, include_changeset?)

    haxe_filename = Path.join(haxe_dir, "#{context_name}.hx")
    File.write!(haxe_filename, haxe_content)
    Mix.shell().info("Generated Haxe context: #{haxe_filename}")

    Mix.shell().info("")
    Mix.shell().info("Next steps:")
    Mix.shell().info("  1. Ensure `#{context_name}` and `#{schema_name}` are included in your build.hxml")
    Mix.shell().info("  2. Run: mix compile.haxe (or `haxe build.hxml`) to generate Elixir")
  end

  defp generate_haxe_context_content(context_name, schema_name, table_name, repo_type, include_changeset?) do
    {repo_import, repo_alias} = split_haxe_type(repo_type)
    singular = Macro.underscore(schema_name)
    plural = Macro.underscore(table_name)

    changeset_fns =
      if include_changeset? do
        """
            public static function create_#{singular}(params: schemas.#{schema_name}.#{schema_name}Params): Result<#{schema_name}, Changeset<#{schema_name}, schemas.#{schema_name}.#{schema_name}Params>> {
                var changeset = #{schema_name}.changeset(new #{schema_name}(), params);
                return #{repo_alias}.insert(changeset);
            }

            public static function update_#{singular}(struct: #{schema_name}, params: schemas.#{schema_name}.#{schema_name}Params): Result<#{schema_name}, Changeset<#{schema_name}, schemas.#{schema_name}.#{schema_name}Params>> {
                var changeset = #{schema_name}.changeset(struct, params);
                return #{repo_alias}.update(changeset);
            }

            public static function change_#{singular}(struct: Null<#{schema_name}>, params: schemas.#{schema_name}.#{schema_name}Params): Changeset<#{schema_name}, schemas.#{schema_name}.#{schema_name}Params> {
                var base = struct != null ? struct : new #{schema_name}();
                return #{schema_name}.changeset(base, params);
            }
        """
      else
        ""
      end

    """
    package contexts;

    import ecto.Changeset;
    import elixir.types.Result;
    import schemas.#{schema_name};
    #{repo_import}

    /**
     * Phoenix context: #{context_name}
     *
     * Generated by `mix haxe.gen.context`.
     *
     * This module is intended to follow Phoenix conventions:
     * - list_#{plural}/0
     * - get_#{singular}/1
     * - create_#{singular}/1, update_#{singular}/2, delete_#{singular}/1
     */
    @:native("#{app_module_name()}.#{context_name}")
    @:module
    class #{context_name} {

        public static function list_#{plural}(): Array<#{schema_name}> {
            return #{repo_alias}.all(#{schema_name});
        }

        public static function get_#{singular}(id: Int): Null<#{schema_name}> {
            return #{repo_alias}.get(#{schema_name}, id);
        }

        #{changeset_fns}

        public static function delete_#{singular}(struct: #{schema_name}): Result<#{schema_name}, Changeset<#{schema_name}, {}>> {
            return #{repo_alias}.delete(struct);
        }
    }
    """
  end

  defp split_haxe_type(type_path) when is_binary(type_path) do
    parts = String.split(type_path, ".", trim: true)

    case parts do
      [single] ->
        {"", single}

      _ ->
        alias_name = List.last(parts)
        {"import #{type_path};", alias_name}
    end
  end

  defp app_module_name() do
    Mix.Project.config()[:app]
    |> to_string()
    |> Macro.camelize()
  end
end

