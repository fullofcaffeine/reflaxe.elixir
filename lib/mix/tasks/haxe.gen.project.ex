defmodule Mix.Tasks.Haxe.Gen.Project do
  @moduledoc """
  Mix task for adding Reflaxe.Elixir support to existing Elixir projects.
  
  This task sets up the necessary directory structure, configuration files,
  and build pipeline to enable Haxe compilation within an existing Elixir project.
  It's the Mix complement to the Haxe-based project generator.

  ## Examples

      mix haxe.gen.project
      mix haxe.gen.project --basic-modules
      mix haxe.gen.project --phoenix
      mix haxe.gen.project --skip-examples

  ## Options

    * `--basic-modules` - Include basic utility modules (StringUtils, MathHelper)
    * `--phoenix` - Add Phoenix-specific configuration and examples
    * `--skip-examples` - Don't generate example Haxe files
    * `--skip-npm` - Don't create package.json or install npm dependencies
    * `--haxe-dir` - Directory for Haxe source files (default: "src_haxe")
    * `--output-dir` - Directory for generated Elixir files (default: "lib/generated")
    * `--force` - Overwrite existing files without confirmation

  """
  use Mix.Task

  @shortdoc "Adds Reflaxe.Elixir support to existing Elixir project"

  @doc """
  Entry point for the Mix task
  """
  def run(args) do
    {opts, [], _} = OptionParser.parse(args, 
      switches: [
        basic_modules: :boolean,
        phoenix: :boolean,
        skip_examples: :boolean,
        skip_npm: :boolean,
        haxe_dir: :string,
        output_dir: :string,
        force: :boolean
      ]
    )

    Mix.shell().info("Adding Reflaxe.Elixir support to existing project...")
    
    project_config = %{
      app_name: get_app_name(),
      module_name: get_module_name(),
      haxe_dir: Keyword.get(opts, :haxe_dir, "src_haxe"),
      output_dir: Keyword.get(opts, :output_dir, "lib/generated"),
      basic_modules: Keyword.get(opts, :basic_modules, false),
      phoenix: Keyword.get(opts, :phoenix, false),
      skip_examples: Keyword.get(opts, :skip_examples, false),
      skip_npm: Keyword.get(opts, :skip_npm, false),
      force: Keyword.get(opts, :force, false)
    }

    setup_project(project_config)
  end

  # Main setup workflow
  defp setup_project(config) do
    # 1. Create directory structure
    create_directories(config)
    
    # 2. Create Haxe build configuration
    create_build_config(config)
    
    # 3. Create package.json for npm dependencies (if not skipped)
    unless config.skip_npm do
      create_package_json(config)
    end
    
    # 4. Update mix.exs with Haxe compiler
    update_mix_exs(config)
    
    # 5. Create example modules (if not skipped)
    unless config.skip_examples do
      create_example_modules(config)
    end
    
    # 6. Create VS Code configuration
    create_vscode_config(config)
    
    # 7. Update .gitignore
    update_gitignore(config)
    
    # 8. Display next steps
    display_next_steps(config)
    
    Mix.shell().info("âœ… Successfully added Reflaxe.Elixir support!")
    :ok
  end

  # Create necessary directories
  defp create_directories(config) do
    base_directories = [
      config.haxe_dir,
      config.output_dir,
      "#{config.haxe_dir}/utils",
      "#{config.haxe_dir}/services",
      ".vscode"
    ]

    all_directories = if config.phoenix do
      base_directories ++ [
        "#{config.haxe_dir}/live",
        "#{config.haxe_dir}/controllers"
      ]
    else
      base_directories
    end

    Enum.each(all_directories, fn dir ->
      File.mkdir_p!(dir)
      Mix.shell().info("Created directory: #{dir}")
    end)
  end

  # Create build.hxml configuration file
  defp create_build_config(config) do
    build_content = build_hxml_content(config)
    
    write_file_with_confirmation("build.hxml", build_content, config.force)
    Mix.shell().info("Created Haxe build configuration: build.hxml")
  end

  # Generate build.hxml content
  defp build_hxml_content(config) do
    """
    # Reflaxe.Elixir Build Configuration
    # Generated by mix haxe.gen.project
    
    # Source directories
    -cp #{config.haxe_dir}
    
    # Libraries
    -lib reflaxe.elixir
    
    # Compiler flags
    -D reflaxe.output=#{config.output_dir}
    -D reflaxe_runtime
    
    # Entry point
    --main Main
    
    # Phoenix-specific flags
    #{if config.phoenix, do: "-D phoenix", else: ""}
    """
  end

  # Create package.json for npm dependencies
  defp create_package_json(config) do
    package_content = package_json_content(config)
    
    write_file_with_confirmation("package.json", package_content, config.force)
    Mix.shell().info("Created package.json with npm dependencies")
  end

  # Generate package.json content
  defp package_json_content(config) do
    Jason.encode!(%{
      name: to_string(config.app_name),
      version: "0.1.0",
      description: "Elixir project with Reflaxe.Elixir support",
      scripts: %{
        compile: "npx haxe build.hxml",
        watch: "npx nodemon --watch #{config.haxe_dir} --ext hx --exec \"npx haxe build.hxml\"",
        test: "npm run test:haxe && npm run test:elixir",
        "test:haxe": "npx haxe test.hxml",
        "test:elixir": "mix test"
      },
      devDependencies: %{
        lix: "^15.12.4",
        nodemon: "^3.0.0"
      }
    }, pretty: true)
  end

  # Update mix.exs to include Haxe compiler
  defp update_mix_exs(config) do
    mix_exs_path = "mix.exs"
    
    unless File.exists?(mix_exs_path) do
      Mix.shell().error("mix.exs not found - this doesn't appear to be an Elixir project")
      System.halt(1)
    end

    current_content = File.read!(mix_exs_path)
    
    # Check if already has Haxe compiler
    if String.contains?(current_content, ":haxe") do
      Mix.shell().info("mix.exs already includes Haxe compiler configuration")
    else
      # Add Haxe compiler to the compilers list
      updated_content = add_haxe_compiler_to_mix_exs(current_content)
      
      if config.force || confirm_overwrite("mix.exs") do
        File.write!(mix_exs_path, updated_content)
        Mix.shell().info("âœ… Updated mix.exs with Haxe compiler configuration")
      else
        Mix.shell().info("Skipped updating mix.exs")
        Mix.shell().info("To manually add Haxe support, add this to your mix.exs project config:")
        Mix.shell().info("  compilers: [:haxe] ++ Mix.compilers()")
      end
    end
  end

  # Add Haxe compiler to mix.exs
  defp add_haxe_compiler_to_mix_exs(content) do
    # Look for the project function and add compilers configuration
    content
    |> String.replace(
      ~r/(def project do\s*\[)/m,
      "\\1\n      compilers: [:haxe] ++ Mix.compilers(),"
    )
  end

  # Create example modules
  defp create_example_modules(config) do
    # Main.hx entry point
    main_content = main_hx_content(config)
    write_file_with_confirmation("#{config.haxe_dir}/Main.hx", main_content, config.force)

    if config.basic_modules do
      # StringUtils utility
      string_utils_content = string_utils_content()
      write_file_with_confirmation("#{config.haxe_dir}/utils/StringUtils.hx", string_utils_content, config.force)
      
      # MathHelper utility
      math_helper_content = math_helper_content()
      write_file_with_confirmation("#{config.haxe_dir}/utils/MathHelper.hx", math_helper_content, config.force)
    end

    if config.phoenix do
      # Phoenix LiveView example
      live_example_content = live_example_content(config)
      write_file_with_confirmation("#{config.haxe_dir}/live/AppLive.hx", live_example_content, config.force)
    end

    Mix.shell().info("Created example Haxe modules")
  end

  # Generate Main.hx content
  defp main_hx_content(config) do
    """
    package;

    /**
     * Main entry point for Reflaxe.Elixir compilation
     * Generated by mix haxe.gen.project
     */
    @:module
    class Main {
        public static function main(): Void {
            // Entry point for Haxe compilation
            trace("#{config.module_name} - Reflaxe.Elixir compilation successful!");
        }
        
        public static function hello(name: String): String {
            return 'Hello, $name! Welcome to Reflaxe.Elixir!';
        }
    }
    """
  end

  # Generate StringUtils content
  defp string_utils_content() do
    """
    package utils;

    /**
     * String utility functions
     * Generated example module
     */
    @:module
    class StringUtils {
        public static function capitalize(str: String): String {
            if (str.length == 0) return str;
            return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
        }
        
        public static function reverse(str: String): String {
            var chars = str.split("");
            chars.reverse();
            return chars.join("");
        }
        
        public static function slugify(str: String): String {
            return str.toLowerCase()
                     .split(" ")
                     .join("-")
                     .split("_")
                     .join("-");
        }
    }
    """
  end

  # Generate MathHelper content
  defp math_helper_content() do
    """
    package utils;

    /**
     * Mathematical utility functions  
     * Generated example module
     */
    @:module
    class MathHelper {
        public static function clamp(value: Float, min: Float, max: Float): Float {
            if (value < min) return min;
            if (value > max) return max;
            return value;
        }
        
        public static function lerp(a: Float, b: Float, t: Float): Float {
            return a + (b - a) * t;
        }
        
        public static function isPrime(n: Int): Bool {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 == 0 || n % 3 == 0) return false;
            
            var i = 5;
            while (i * i <= n) {
                if (n % i == 0 || n % (i + 2) == 0) return false;
                i += 6;
            }
            return true;
        }
    }
    """
  end

  # Generate LiveView example content
  defp live_example_content(config) do
    """
    package live;

    /**
     * Phoenix LiveView example component
     * Generated example module
     */
    @:liveview
    class AppLive {
        public var count: Int = 0;
        
        public function mount(_params: Dynamic, _session: Dynamic, socket: Dynamic): Dynamic {
            return socket;
        }
        
        public function handle_event(event: String, _params: Dynamic, socket: Dynamic): Dynamic {
            return switch (event) {
                case "increment":
                    count++;
                    socket;
                case "decrement":  
                    count--;
                    socket;
                case _:
                    socket;
            };
        }
        
        public function render(assigns: Dynamic): String {
            return '<div>
                <h1>#{config.module_name} Counter</h1>
                <p>Count: <%= @count %></p>
                <button phx-click="increment">+</button>
                <button phx-click="decrement">-</button>
            </div>';
        }
    }
    """
  end

  # Create VS Code configuration
  defp create_vscode_config(config) do
    # settings.json
    settings_content = vscode_settings_content()
    write_file_with_confirmation(".vscode/settings.json", settings_content, config.force)
    
    # extensions.json
    extensions_content = vscode_extensions_content()
    write_file_with_confirmation(".vscode/extensions.json", extensions_content, config.force)
    
    Mix.shell().info("Created VS Code configuration")
  end

  # Generate VS Code settings.json
  defp vscode_settings_content() do
    Jason.encode!(%{
      "editor.formatOnSave" => true,
      "files.exclude" => %{
        "**/_build" => true,
        "**/deps" => true,
        "**/node_modules" => true
      },
      "[haxe]" => %{
        "editor.insertSpaces" => false
      },
      "[elixir]" => %{
        "editor.insertSpaces" => true,
        "editor.tabSize" => 2
      }
    }, pretty: true)
  end

  # Generate VS Code extensions.json
  defp vscode_extensions_content() do
    Jason.encode!(%{
      recommendations: [
        "vshaxe.haxe-extension-pack",
        "jakebecker.elixir-ls",
        "phoenixframework.phoenix"
      ]
    }, pretty: true)
  end

  # Update .gitignore to exclude generated files
  defp update_gitignore(config) do
    gitignore_additions = [
      "",
      "# Reflaxe.Elixir generated files",
      "#{config.output_dir}/",
      "node_modules/",
      "package-lock.json",
      "*.hxml.cache",
      ".haxe_cache/",
      ""
    ]

    if File.exists?(".gitignore") do
      current_content = File.read!(".gitignore")
      
      # Check if already contains our additions
      unless String.contains?(current_content, "Reflaxe.Elixir generated files") do
        updated_content = current_content <> Enum.join(gitignore_additions, "\n")
        File.write!(".gitignore", updated_content)
        Mix.shell().info("Updated .gitignore with Reflaxe.Elixir exclusions")
      end
    else
      File.write!(".gitignore", Enum.join(gitignore_additions, "\n"))
      Mix.shell().info("Created .gitignore with Reflaxe.Elixir exclusions")
    end
  end

  # Display next steps to the user
  defp display_next_steps(config) do
    Mix.shell().info("")
    Mix.shell().info("ðŸŽ‰ Reflaxe.Elixir setup complete!")
    Mix.shell().info("")
    Mix.shell().info("Next steps:")
    Mix.shell().info("  1. Install Reflaxe.Elixir:")
    Mix.shell().info("     npx lix install github:fullofcaffeine/reflaxe.elixir")
    Mix.shell().info("")
    
    unless config.skip_npm do
      Mix.shell().info("  2. Install npm dependencies:")
      Mix.shell().info("     npm install")
      Mix.shell().info("")
    end
    
    Mix.shell().info("  3. Compile your first Haxe code:")
    Mix.shell().info("     npx haxe build.hxml")
    Mix.shell().info("")
    Mix.shell().info("  4. Start development with file watching:")
    Mix.shell().info("     npm run watch")
    Mix.shell().info("")
    Mix.shell().info("  5. Test your generated Elixir code:")
    Mix.shell().info("     mix test")
    Mix.shell().info("")
    Mix.shell().info("ðŸ“– For more information, see: documentation/GETTING_STARTED.md")
    Mix.shell().info("")
  end

  # Helper functions

  defp get_app_name() do
    Mix.Project.config()[:app] || :my_app
  end

  defp get_module_name() do
    get_app_name() |> to_string() |> Macro.camelize()
  end

  defp write_file_with_confirmation(path, content, force) do
    if File.exists?(path) && !force do
      if confirm_overwrite(path) do
        File.write!(path, content)
      else
        Mix.shell().info("Skipped: #{path}")
      end
    else
      File.write!(path, content)
    end
  end

  defp confirm_overwrite(path) do
    Mix.shell().yes?("File #{path} already exists. Overwrite?")
  end
end