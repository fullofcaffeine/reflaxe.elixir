defmodule Mix.Tasks.Haxe.Gen.Live do
  @shortdoc "Generates a Phoenix LiveView module (Haxe-first)"

  @moduledoc """
  Generates a Haxe-authored Phoenix LiveView module.

  This task is **Haxe-first**: it writes Haxe source only. The Elixir `defmodule`
  is generated by compiling your project with Reflaxe.Elixir.

  ## Usage

      mix haxe.gen.live ModuleName [options]

  ## Examples

      mix haxe.gen.live DashboardLive
      mix haxe.gen.live TodoLive --assigns "count:Int"
      mix haxe.gen.live UsersLive --events "refresh,search"

  ## Options

    * `--events` - Custom event handlers to generate (comma-separated)
    * `--assigns` - Initial assigns for socket (comma-separated key:type pairs)
    * `--haxe-dir` - Haxe source directory (default: "src_haxe/live")
  """

  use Mix.Task

  @requirements ["app.config"]

  @impl Mix.Task
  def run(args) do
    {opts, parsed_args, _errors} =
      OptionParser.parse(args,
        switches: [
          events: :string,
          assigns: :string,
          haxe_dir: :string
        ],
        aliases: [
          e: :events
        ]
      )

    case parsed_args do
      [module_name] ->
        generate_liveview(module_name, opts)

      [] ->
        Mix.raise("Module name is required. Usage: mix haxe.gen.live ModuleName [options]")

      _ ->
        Mix.raise("Too many arguments. Usage: mix haxe.gen.live ModuleName [options]")
    end
  end

  defp generate_liveview(module_name, opts) do
    events = parse_csv(Keyword.get(opts, :events, ""))
    assigns = parse_assigns(Keyword.get(opts, :assigns, ""))
    haxe_dir = Keyword.get(opts, :haxe_dir, "src_haxe/live")

    File.mkdir_p!(haxe_dir)

    haxe_file = Path.join(haxe_dir, "#{module_name}.hx")
    File.write!(haxe_file, generate_haxe_liveview(module_name, assigns, events))

    Mix.shell().info("""

    Generated LiveView (Haxe-first):

    * #{haxe_file}

    Next steps:
      1) Ensure #{module_name} is included in your build.hxml
      2) Run: mix compile.haxe (or `haxe build.hxml`)
      3) Add a route in your Phoenix router, e.g.:

         live "/#{Macro.underscore(module_name)}", #{app_module_name()}Web.#{module_name}
    """)
  end

  defp generate_haxe_liveview(module_name, assigns, events) do
    assigns = ensure_assign(assigns, {"count", "Int"})

    assigns_typedef =
      assigns
      |> Enum.map(fn {key, type} -> "    #{key}: #{type}," end)
      |> Enum.join("\n")

    assigns_init =
      assigns
      |> Enum.map(fn {key, type} -> "            #{key}: #{default_value_for_type(type)}," end)
      |> Enum.join("\n")

    assigns_typedef = if assigns_typedef == "", do: "    count: Int,", else: assigns_typedef
    assigns_init = if assigns_init == "", do: "            count: 0,", else: assigns_init

    event_cases =
      Enum.map(events, fn event ->
        """
                case "#{event}":
                    handle_#{event}(params, socket);
        """
      end)
      |> Enum.join("\n")

    handler_fns =
      Enum.map(events, fn event ->
        """
        private static function handle_#{event}(_params: EventParams, socket: Socket<#{module_name}Assigns>): HandleEventResult<#{module_name}Assigns> {
            // Fill in your event logic.
            return NoReply(socket);
        }
        """
      end)
      |> Enum.join("\n")

    handler_fns = if handler_fns == "", do: "", else: "\n" <> handler_fns

    """
    package live;

    import elixir.types.Term;
    import phoenix.Phoenix.LiveView;
    import phoenix.Phoenix.MountParams;
    import phoenix.Phoenix.Session;
    import phoenix.Phoenix.Socket;
    import phoenix.Phoenix.MountResult;
    import phoenix.Phoenix.EventParams;
    import phoenix.Phoenix.HandleEventResult;

    import HXX.*;

    private typedef #{module_name}Assigns = {
    #{assigns_typedef}
    }

    /**
     * Phoenix LiveView: #{module_name}
     *
     * Generated by `mix haxe.gen.live`. This is Haxe-authored and compiles to
     * idiomatic Phoenix LiveView callbacks (`mount/3`, `handle_event/3`, `render/1`).
     */
    @:native("#{app_module_name()}Web.#{module_name}")
    @:liveview
    class #{module_name} {
        public static function mount(_params: MountParams, _session: Session, socket: Socket<#{module_name}Assigns>): MountResult<#{module_name}Assigns> {
            var assigns: #{module_name}Assigns = {
    #{assigns_init}
            };

            return Ok(LiveView.assignMultiple(socket, assigns));
        }

        public static function handle_event(event: String, params: EventParams, socket: Socket<#{module_name}Assigns>): HandleEventResult<#{module_name}Assigns> {
            return switch (event) {
                case "increment":
                    var updated = LiveView.assignMultiple(socket, {count: socket.assigns.count + 1});
                    NoReply(updated);

                case "decrement":
                    var updated = LiveView.assignMultiple(socket, {count: socket.assigns.count - 1});
                    NoReply(updated);

    #{event_cases}                default:
                    NoReply(socket);
            };
        }

        public static function render(assigns: #{module_name}Assigns): String {
            return hxx('
                <div class="p-6">
                    <h1 class="text-2xl font-semibold">#{module_name}</h1>
                <p class="mt-2">Count: \#{@count}</p>
                    <div class="mt-4 flex gap-2">
                        <button phx-click="decrement" class="px-3 py-2 border rounded">-</button>
                        <button phx-click="increment" class="px-3 py-2 border rounded">+</button>
                    </div>
            </div>
            ');
        }
    #{handler_fns}
    }
    """
  end

  defp parse_csv(""), do: []

  defp parse_csv(csv) when is_binary(csv) do
    csv
    |> String.split(",")
    |> Enum.map(&String.trim/1)
    |> Enum.reject(&(&1 == ""))
    |> Enum.map(fn event -> Macro.underscore(event) end)
  end

  defp parse_assigns(nil), do: []
  defp parse_assigns(""), do: []

  defp parse_assigns(assigns_string) do
    assigns_string
    |> String.split(",")
    |> Enum.map(&String.trim/1)
    |> Enum.reject(&(&1 == ""))
    |> Enum.map(fn spec ->
      case String.split(spec, ":", parts: 2) do
        [key, type] -> {String.trim(key), String.trim(type)}
        [key] -> {String.trim(key), "Term"}
      end
    end)
  end

  defp default_value_for_type(type) when is_binary(type) do
    case String.trim(type) do
      "Int" -> "0"
      "Float" -> "0.0"
      "Bool" -> "false"
      "String" -> "\"\""
      _ -> "null"
    end
  end

  defp ensure_assign(assigns, {key, type}) do
    if Enum.any?(assigns, fn {k, _t} -> k == key end) do
      assigns
    else
      assigns ++ [{key, type}]
    end
  end

  defp app_module_name() do
    Mix.Project.config()[:app]
    |> to_string()
    |> Macro.camelize()
  end
end
