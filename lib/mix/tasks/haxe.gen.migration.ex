defmodule Mix.Tasks.Haxe.Gen.Migration do
  @moduledoc """
  Generates a Haxe-authored Ecto migration skeleton.

  This task is **Haxe-first**: it creates the Haxe source file for the migration.
  Compile the project to generate Elixir output.

  Ecto executes migrations from `priv/repo/migrations/*.exs`. Reflaxe.Elixir can emit
  runnable `.exs` migrations via an **opt-in migration build**:

  - Add `-D ecto_migrations_exs`
  - Set `-D elixir_output=priv/repo/migrations`
  - Compile only your `@:migration` classes (to avoid non-migration `.exs` files in that directory)

  ## Examples

      mix haxe.gen.migration CreateUsersTable --table users --columns "name:string,email:string"
      mix haxe.gen.migration AddIndexToUsers --table users --index email --unique
      mix haxe.gen.migration CreateUsersTable --timestamp 20240101120000

  ## Options

    * `--table` - Specify the table name (defaults to inferred from migration name)
    * `--columns` - Comma-separated list of columns (e.g., "name:string,email:string,age:integer")
    * `--index` - Add an index on the specified field(s)
    * `--unique` - Make the index unique
    * `--timestamp` - Migration timestamp for filename ordering (default: UTC now as YYYYMMDDHHMMSS)
    * `--haxe-dir` - Directory for Haxe migration files (default: "src_haxe/migrations")
  """
  use Mix.Task

  @shortdoc "Generates a Haxe migration skeleton"

  @impl Mix.Task
  def run(args) do
    {opts, [migration_name | _], _} =
      OptionParser.parse(args,
        switches: [
          table: :string,
          columns: :string,
          index: :string,
          unique: :boolean,
          timestamp: :string,
          haxe_dir: :string
        ]
      )

    if migration_name == nil do
      Mix.shell().error("Migration name is required. Usage: mix haxe.gen.migration MigrationName")
      System.halt(1)
    end

    generate_migration(migration_name, opts)
  end

  defp generate_migration(migration_name, opts) do
    haxe_dir = Keyword.get(opts, :haxe_dir, "src_haxe/migrations")
    table_name = Keyword.get(opts, :table, infer_table_name(migration_name))
    columns = parse_columns(Keyword.get(opts, :columns, ""))
    index_field = Keyword.get(opts, :index)
    unique? = Keyword.get(opts, :unique, false)
    timestamp = Keyword.get(opts, :timestamp, default_timestamp())

    File.mkdir_p!(haxe_dir)

    haxe_content = generate_haxe_migration_content(migration_name, table_name, columns, index_field, unique?, timestamp)
    haxe_filename = Path.join(haxe_dir, "#{migration_name}.hx")

    File.write!(haxe_filename, haxe_content)
    Mix.shell().info("Generated Haxe migration: #{haxe_filename}")

    Mix.shell().info("")
    Mix.shell().info("Next steps:")
    Mix.shell().info("  1. Include #{migration_name} in a migration-only build (recommended)")
    Mix.shell().info("     -D elixir_output=priv/repo/migrations")
    Mix.shell().info("     -D ecto_migrations_exs")
    Mix.shell().info("  2. Compile migrations: haxe build-migrations.hxml")
    Mix.shell().info("  3. Run: mix ecto.migrate")
  end

  defp generate_haxe_migration_content(migration_name, table_name, columns, index_field, unique?, timestamp) do
    column_lines =
      Enum.map(columns, fn {name, type} ->
        opts =
          if String.ends_with?(type, "?") do
            ", {nullable: true}"
          else
            ""
          end

        clean_type = String.trim_trailing(type, "?")
        "            .addColumn(\"#{name}\", #{column_type(clean_type)}#{opts})"
      end)
      |> Enum.join("\n")

    index_line =
      cond do
        index_field == nil ->
          ""

        unique? ->
          "\n            .addIndex([\"#{index_field}\"], {unique: true});"

        true ->
          "\n            .addIndex([\"#{index_field}\"]);"
      end

    """
    package migrations;

    import ecto.Migration;
    import ecto.Migration.ColumnType;

    /**
     * Migration: #{migration_name}
     *
     * Generated by `mix haxe.gen.migration`.
     */
    @:migration({timestamp: "#{timestamp}"})
    class #{migration_name} extends Migration {
        public function up(): Void {
            createTable("#{table_name}")
    #{column_lines}
            .addTimestamps()#{index_line}
        }

        public function down(): Void {
            dropTable("#{table_name}");
        }
    }
    """
  end

  defp column_type(type) do
    case String.downcase(type) do
      "string" -> "ColumnType.String()"
      "text" -> "ColumnType.Text"
      "integer" -> "ColumnType.Integer"
      "bigint" -> "ColumnType.BigInteger"
      "boolean" -> "ColumnType.Boolean"
      "float" -> "ColumnType.Float"
      "datetime" -> "ColumnType.DateTime"
      "naive_datetime" -> "ColumnType.DateTime"
      "uuid" -> "ColumnType.UUID"
      "json" -> "ColumnType.Json"
      "json_array" -> "ColumnType.JsonArray"
      _ -> "ColumnType.String()"
    end
  end

  defp infer_table_name(migration_name) do
    migration_name
    |> String.replace(~r/^Create/, "")
    |> String.replace(~r/^Alter/, "")
    |> String.replace(~r/^Drop/, "")
    |> String.replace(~r/Table$/, "")
    |> Macro.underscore()
  end

  defp parse_columns(""), do: [{"name", "string"}, {"description", "text"}]

  defp parse_columns(columns_string) do
    columns_string
    |> String.split(",")
    |> Enum.map(fn column_spec ->
      case String.split(column_spec, ":") do
        [name, type] -> {String.trim(name), String.trim(type)}
        [name] -> {String.trim(name), "string"}
      end
    end)
  end

  defp default_timestamp do
    DateTime.utc_now()
    |> Calendar.strftime("%Y%m%d%H%M%S")
  end
end
