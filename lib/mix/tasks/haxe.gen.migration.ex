defmodule Mix.Tasks.Haxe.Gen.Migration do
  @moduledoc """
  Generates a Haxe-authored Ecto migration skeleton.

  This task is **Haxe-first**: it creates the Haxe source file for the migration.
  Compile the project to generate Elixir output.

  NOTE: Ecto executes migrations from `priv/repo/migrations/*.exs`. If you want
  executable migrations today, prefer `mix ecto.gen.migration` for the timestamped
  `.exs` file and keep the migration logic in Elixir. The Haxe migration DSL is
  still evolving in the alpha series.

  ## Examples

      mix haxe.gen.migration CreateUsersTable --table users --columns "name:string,email:string"
      mix haxe.gen.migration AddIndexToUsers --table users --index email --unique

  ## Options

    * `--table` - Specify the table name (defaults to inferred from migration name)
    * `--columns` - Comma-separated list of columns (e.g., "name:string,email:string,age:integer")
    * `--index` - Add an index on the specified field(s)
    * `--unique` - Make the index unique
    * `--haxe-dir` - Directory for Haxe migration files (default: "src_haxe/migrations")
  """
  use Mix.Task

  @shortdoc "Generates a Haxe migration skeleton"

  @impl Mix.Task
  def run(args) do
    {opts, [migration_name | _], _} =
      OptionParser.parse(args,
        switches: [
          table: :string,
          columns: :string,
          index: :string,
          unique: :boolean,
          haxe_dir: :string
        ]
      )

    if migration_name == nil do
      Mix.shell().error("Migration name is required. Usage: mix haxe.gen.migration MigrationName")
      System.halt(1)
    end

    generate_migration(migration_name, opts)
  end

  defp generate_migration(migration_name, opts) do
    haxe_dir = Keyword.get(opts, :haxe_dir, "src_haxe/migrations")
    table_name = Keyword.get(opts, :table, infer_table_name(migration_name))
    columns = parse_columns(Keyword.get(opts, :columns, ""))
    index_field = Keyword.get(opts, :index)
    unique? = Keyword.get(opts, :unique, false)

    File.mkdir_p!(haxe_dir)

    haxe_content = generate_haxe_migration_content(migration_name, table_name, columns, index_field, unique?)
    haxe_filename = Path.join(haxe_dir, "#{migration_name}.hx")

    File.write!(haxe_filename, haxe_content)
    Mix.shell().info("Generated Haxe migration: #{haxe_filename}")

    Mix.shell().info("")
    Mix.shell().info("Next steps:")
    Mix.shell().info("  1. Include #{migration_name} in your build.hxml (or a dedicated migrations build)")
    Mix.shell().info("  2. Run: mix compile.haxe (or `haxe build.hxml`) to generate Elixir")
  end

  defp generate_haxe_migration_content(migration_name, table_name, columns, index_field, unique?) do
    column_lines =
      Enum.map(columns, fn {name, type} ->
        opts =
          if String.ends_with?(type, "?") do
            ", {nullable: true}"
          else
            ""
          end

        clean_type = String.trim_trailing(type, "?")
        "            .addColumn(\"#{name}\", #{column_type(clean_type)}#{opts})"
      end)
      |> Enum.join("\n")

    index_line =
      cond do
        index_field == nil ->
          ""

        unique? ->
          "\n            .addIndex([\"#{index_field}\"], {unique: true});"

        true ->
          "\n            .addIndex([\"#{index_field}\"]);"
      end

    """
    package migrations;

    import ecto.Migration;
    import ecto.Migration.*;

    /**
     * Migration: #{migration_name}
     *
     * Generated by `mix haxe.gen.migration`.
     */
    @:migration
    class #{migration_name} extends Migration {
        public function up(): Void {
            createTable("#{table_name}")
    #{column_lines}
            .addTimestamps()#{index_line}
        }

        public function down(): Void {
            dropTable("#{table_name}");
        }
    }
    """
  end

  defp column_type(type) do
    case String.downcase(type) do
      "string" -> "String()"
      "text" -> "Text"
      "integer" -> "Integer"
      "bigint" -> "BigInteger"
      "boolean" -> "Boolean"
      "float" -> "Float"
      "datetime" -> "DateTime"
      "naive_datetime" -> "DateTime"
      "uuid" -> "UUID"
      "json" -> "Json"
      "json_array" -> "JsonArray"
      _ -> "String()"
    end
  end

  defp infer_table_name(migration_name) do
    migration_name
    |> String.replace(~r/^Create/, "")
    |> String.replace(~r/^Alter/, "")
    |> String.replace(~r/^Drop/, "")
    |> String.replace(~r/Table$/, "")
    |> Macro.underscore()
  end

  defp parse_columns(""), do: [{"name", "string"}, {"description", "text"}]

  defp parse_columns(columns_string) do
    columns_string
    |> String.split(",")
    |> Enum.map(fn column_spec ->
      case String.split(column_spec, ":") do
        [name, type] -> {String.trim(name), String.trim(type)}
        [name] -> {String.trim(name), "string"}
      end
    end)
  end
end

