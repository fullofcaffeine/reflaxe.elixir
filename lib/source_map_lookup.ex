defmodule SourceMapLookup do
  @moduledoc """
  Source mapping lookup functionality for reverse mapping from generated Elixir
  code positions back to original Haxe source positions.
  
  This module provides the core functionality to:
  
  * Parse Source Map v3 files generated by the Haxeâ†’Elixir compiler
  * Build reverse lookup tables for efficient position mapping
  * Integrate with error storage system to enhance debugging information
  * Support LLM agents with accurate cross-language position mapping
  
  ## Usage
  
      # Parse a source map file
      {:ok, source_map} = SourceMapLookup.parse_source_map("lib/MyClass.ex.map")
      
      # Find original Haxe position from generated Elixir position
      {:ok, haxe_pos} = SourceMapLookup.lookup_haxe_position(source_map, 25, 10)
      
      # Enhance error with source mapping information
      enhanced_error = SourceMapLookup.enhance_error_with_source_mapping(error)
  """
  
  require Logger
  import Bitwise
  
  @doc """
  Parses a Source Map v3 file and returns a structured source mapping.
  
  ## Parameters
  
    * `source_map_path` - Path to the .ex.map source map file
    
  ## Returns
  
    * `{:ok, source_map}` - Successfully parsed source map
    * `{:error, reason}` - Failed to parse source map
  """
  @spec parse_source_map(String.t()) :: {:ok, map()} | {:error, String.t()}
  def parse_source_map(source_map_path) do
    if File.exists?(source_map_path) do
      case File.read(source_map_path) do
        {:ok, content} ->
          if Code.ensure_loaded?(Jason) do
            case Jason.decode(content) do
              {:ok, source_map_data} ->
                process_source_map(source_map_data, source_map_path)
                
              {:error, decode_error} ->
                {:error, "Failed to decode source map JSON: #{inspect(decode_error)}"}
            end
          else
            {:error, "Jason library not available. Cannot parse JSON source maps."}
          end
          
        {:error, read_error} ->
          {:error, "Failed to read source map file: #{inspect(read_error)}"}
      end
    else
      {:error, "Source map file not found: #{source_map_path}"}
    end
  end
  
  @doc """
  Looks up the original Haxe source position for a given generated Elixir position.
  
  ## Parameters
  
    * `source_map` - Parsed source map structure
    * `generated_line` - Line number in generated Elixir file (1-based)
    * `generated_column` - Column number in generated Elixir file (0-based)
    
  ## Returns
  
    * `{:ok, haxe_position}` - Found Haxe source position
    * `{:error, reason}` - Position not found or lookup failed
  """
  @spec lookup_haxe_position(map(), integer(), integer()) :: {:ok, map()} | {:error, String.t()}
  def lookup_haxe_position(source_map, generated_line, generated_column) do
    # Convert to 0-based line number for internal lookup
    line_index = generated_line - 1
    
    case find_mapping_for_position(source_map, line_index, generated_column) do
      {:ok, mapping} ->
        {:ok, %{
          file: mapping.source_file,
          line: mapping.source_line + 1,  # Convert back to 1-based
          column: mapping.source_column,
          original_position: %{
            line: generated_line,
            column: generated_column
          }
        }}
        
      {:error, reason} ->
        {:error, reason}
    end
  end
  
  @doc """
  Enhances a compilation error with source mapping information.
  
  If the error refers to a generated Elixir file that has a corresponding source map,
  this function will add the original Haxe position information to the error.
  
  ## Parameters
  
    * `error` - Error map from HaxeCompiler.get_compilation_errors()
    
  ## Returns
  
    * Enhanced error map with source mapping information
  """
  @spec enhance_error_with_source_mapping(map()) :: map()
  def enhance_error_with_source_mapping(error) do
    case find_source_map_for_error(error) do
      {:ok, source_map_path} ->
        case parse_source_map(source_map_path) do
          {:ok, source_map} ->
            enhance_error_with_mapping(error, source_map)
            
          {:error, _reason} ->
            # If source map parsing fails, return original error
            error
        end
        
      {:error, _reason} ->
        # If no source map found, return original error  
        error
    end
  end
  
  @doc """
  Batch enhances multiple errors with source mapping information.
  
  ## Parameters
  
    * `errors` - List of error maps
    
  ## Returns
  
    * List of enhanced error maps with source mapping information
  """
  @spec enhance_errors_with_source_mapping([map()]) :: [map()]
  def enhance_errors_with_source_mapping(errors) when is_list(errors) do
    Enum.map(errors, &enhance_error_with_source_mapping/1)
  end
  
  @doc """
  Finds all available source map files in the project.
  
  ## Parameters
  
    * `target_dir` - Directory to search for .ex.map files (default: "lib")
    
  ## Returns
  
    * List of source map file paths
  """
  @spec find_available_source_maps(String.t()) :: [String.t()]
  def find_available_source_maps(target_dir \\ "lib") do
    if File.exists?(target_dir) do
      Path.wildcard(Path.join(target_dir, "**/*.ex.map"))
    else
      []
    end
  end
  
  # Private helper functions
  
  defp process_source_map(source_map_data, source_map_path) do
    case validate_source_map_format(source_map_data) do
      :ok ->
        case decode_vlq_mappings(source_map_data["mappings"], source_map_data["sources"]) do
          {:ok, {mappings, mappings_by_line}} ->
            processed_map = %{
              version: source_map_data["version"],
              file: source_map_data["file"],
              sources: source_map_data["sources"],
              mappings: mappings,
              mappings_by_line: mappings_by_line,
              source_map_path: source_map_path
            }
            
            {:ok, processed_map}
            
          {:error, reason} ->
            {:error, reason}
        end
        
      {:error, reason} ->
        {:error, reason}
    end
  end
  
  defp validate_source_map_format(source_map_data) do
    cond do
      not Map.has_key?(source_map_data, "version") ->
        {:error, "Missing version field in source map"}
        
      source_map_data["version"] != 3 ->
        {:error, "Unsupported source map version: #{source_map_data["version"]}"}
        
      not Map.has_key?(source_map_data, "mappings") ->
        {:error, "Missing mappings field in source map"}
        
      not Map.has_key?(source_map_data, "sources") ->
        {:error, "Missing sources field in source map"}
        
      true ->
        :ok
    end
  end
  
  defp decode_vlq_mappings(mappings_string, sources) do
    lines = String.split(mappings_string, ";", trim: false)
    
    # Source Map v3 delta state across the whole file (generated_column resets per line).
    state = %{
      source_index: 0,
      source_line: 0,
      source_column: 0
    }
    
    try do
      {decoded_lines, final_state} = Enum.map_reduce(lines, state, fn line, acc_state ->
        decode_vlq_line(line, sources, acc_state)
      end)
      
      _ = final_state
      
      # Flatten while keeping a per-line index for fast lookups.
      flattened =
        decoded_lines
        |> Enum.with_index()
        |> Enum.flat_map(fn {line_mappings, line_index} ->
          Enum.map(line_mappings, fn mapping ->
            Map.put(mapping, :generated_line, line_index)
          end)
        end)
      
      {:ok, {flattened, decoded_lines}}
    rescue
      e ->
        {:error, "Failed to decode VLQ mappings: #{Exception.message(e)}"}
    end
  end
  
  defp decode_vlq_line(line, sources, state) do
    # Reset generated column for each new generated line (Source Map v3 spec).
    line_state = Map.put(state, :generated_column, 0)
    
    {decoded_segments, final_state} =
      if String.trim(line) == "" do
        {[], line_state}
      else
        segments = String.split(line, ",", trim: false)
        
        Enum.map_reduce(segments, line_state, fn segment, acc_state ->
          decode_vlq_segment(segment, sources, acc_state)
        end)
      end
    
    # Drop generated_column from the persisted cross-line state.
    next_state = %{
      source_index: final_state.source_index,
      source_line: final_state.source_line,
      source_column: final_state.source_column
    }
    
    {Enum.reject(decoded_segments, &is_nil/1), next_state}
  end
  
  defp decode_vlq_segment("", _sources, state), do: {nil, state}
  
  defp decode_vlq_segment(segment, sources, state) do
    values = decode_vlq_values(segment)
    
    case values do
      [generated_column_delta, source_index_delta, source_line_delta, source_column_delta | _rest] ->
        generated_column = state.generated_column + generated_column_delta
        source_index = state.source_index + source_index_delta
        source_line = state.source_line + source_line_delta
        source_column = state.source_column + source_column_delta
        
        mapping = %{
          generated_column: generated_column,
          source_file: Enum.at(sources, source_index, "unknown.hx"),
          source_line: source_line,
          source_column: source_column
        }
        
        new_state = %{
          generated_column: generated_column,
          source_index: source_index,
          source_line: source_line,
          source_column: source_column
        }
        
        {mapping, new_state}
        
      [generated_column_delta] ->
        # Segment without source info: update generated column only.
        generated_column = state.generated_column + generated_column_delta
        {nil, %{state | generated_column: generated_column}}
        
      _ ->
        raise "Invalid VLQ segment (expected at least 1 value): #{inspect(segment)}"
    end
  end
  
  defp decode_vlq_values(segment) when is_binary(segment) do
    segment
    |> String.to_charlist()
    |> do_decode_vlq([], 0, 0)
    |> Enum.reverse()
  end
  
  # Base64 VLQ decoding (Source Map v3)
  defp do_decode_vlq([], values, 0, 0), do: values
  defp do_decode_vlq([], _values, _shift, _vlq), do: raise("Incomplete VLQ value at end of segment")
  
  defp do_decode_vlq([char | rest], values, shift, vlq) do
    digit = decode_base64_digit(char)
    continuation? = (digit &&& 32) != 0
    digit_value = digit &&& 31
    
    vlq = vlq + (digit_value <<< shift)
    
    if continuation? do
      do_decode_vlq(rest, values, shift + 5, vlq)
    else
      value = from_vlq_signed(vlq)
      do_decode_vlq(rest, [value | values], 0, 0)
    end
  end
  
  defp from_vlq_signed(vlq) do
    sign = vlq &&& 1
    value = vlq >>> 1
    if sign == 1, do: -value, else: value
  end
  
  defp decode_base64_digit(char) when char in ?A..?Z, do: char - ?A
  defp decode_base64_digit(char) when char in ?a..?z, do: char - ?a + 26
  defp decode_base64_digit(char) when char in ?0..?9, do: char - ?0 + 52
  defp decode_base64_digit(?+), do: 62
  defp decode_base64_digit(?/), do: 63
  defp decode_base64_digit(other), do: raise("Invalid base64 digit in VLQ segment: #{inspect(<<other>>)}")
  
  defp find_mapping_for_position(source_map, line_index, column) do
    # Prefer the indexed per-line mappings if present (fast path).
    mappings_by_line = Map.get(source_map, :mappings_by_line, [])
    line_mappings = Enum.at(mappings_by_line, line_index, [])
    
    mapping =
      line_mappings
      |> Enum.reduce(nil, fn m, acc ->
        if m.generated_column <= column, do: m, else: acc
      end)
    
    case mapping do
      nil ->
        {:error, "No mapping found for position #{line_index + 1}:#{column}"}
        
      m ->
        {:ok, m}
    end
  end
  
  defp find_source_map_for_error(error) do
    file = Map.get(error, :file)
    
    cond do
      is_nil(file) ->
        {:error, "No file information in error"}
        
      String.ends_with?(file, ".hx") ->
        # Haxe source file - look for corresponding .ex.map
        elixir_file = String.replace(file, ".hx", ".ex")
        source_map_path = elixir_file <> ".map"
        
        if File.exists?(source_map_path) do
          {:ok, source_map_path}
        else
          {:error, "Source map not found: #{source_map_path}"}
        end
        
      String.ends_with?(file, ".ex") ->
        # Generated Elixir file - look for corresponding .map
        source_map_path = file <> ".map"
        
        if File.exists?(source_map_path) do
          {:ok, source_map_path}
        else
          {:error, "Source map not found: #{source_map_path}"}
        end
        
      true ->
        {:error, "Unknown file type for source mapping: #{file}"}
    end
  end
  
  defp enhance_error_with_mapping(error, source_map) do
    line = Map.get(error, :line, 1)
    column = Map.get(error, :column_start, 0)
    
    case lookup_haxe_position(source_map, line, column) do
      {:ok, haxe_position} ->
        Map.merge(error, %{
          source_mapping: %{
            original_haxe: %{
              file: haxe_position.file,
              line: haxe_position.line,
              column: haxe_position.column
            },
            generated_elixir: %{
              file: error.file,
              line: line,
              column: column
            },
            source_map_file: source_map.source_map_path
          }
        })
        
      {:error, _reason} ->
        # If lookup fails, just mark that source mapping was attempted
        Map.put(error, :source_mapping_attempted, true)
    end
  end
end
