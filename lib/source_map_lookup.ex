defmodule SourceMapLookup do
  @moduledoc """
  Source mapping lookup functionality for reverse mapping from generated Elixir
  code positions back to original Haxe source positions.
  
  This module provides the core functionality to:
  
  * Parse Source Map v3 files generated by the Haxeâ†’Elixir compiler
  * Build reverse lookup tables for efficient position mapping
  * Integrate with error storage system to enhance debugging information
  * Support LLM agents with accurate cross-language position mapping
  
  ## Usage
  
      # Parse a source map file
      {:ok, source_map} = SourceMapLookup.parse_source_map("lib/MyClass.ex.map")
      
      # Find original Haxe position from generated Elixir position
      {:ok, haxe_pos} = SourceMapLookup.lookup_haxe_position(source_map, 25, 10)
      
      # Enhance error with source mapping information
      enhanced_error = SourceMapLookup.enhance_error_with_source_mapping(error)
  """
  
  require Logger
  
  @doc """
  Parses a Source Map v3 file and returns a structured source mapping.
  
  ## Parameters
  
    * `source_map_path` - Path to the .ex.map source map file
    
  ## Returns
  
    * `{:ok, source_map}` - Successfully parsed source map
    * `{:error, reason}` - Failed to parse source map
  """
  @spec parse_source_map(String.t()) :: {:ok, map()} | {:error, String.t()}
  def parse_source_map(source_map_path) do
    if File.exists?(source_map_path) do
      case File.read(source_map_path) do
        {:ok, content} ->
          case Jason.decode(content) do
            {:ok, source_map_data} ->
              process_source_map(source_map_data, source_map_path)
              
            {:error, decode_error} ->
              {:error, "Failed to decode source map JSON: #{inspect(decode_error)}"}
          end
          
        {:error, read_error} ->
          {:error, "Failed to read source map file: #{inspect(read_error)}"}
      end
    else
      {:error, "Source map file not found: #{source_map_path}"}
    end
  end
  
  @doc """
  Looks up the original Haxe source position for a given generated Elixir position.
  
  ## Parameters
  
    * `source_map` - Parsed source map structure
    * `generated_line` - Line number in generated Elixir file (1-based)
    * `generated_column` - Column number in generated Elixir file (0-based)
    
  ## Returns
  
    * `{:ok, haxe_position}` - Found Haxe source position
    * `{:error, reason}` - Position not found or lookup failed
  """
  @spec lookup_haxe_position(map(), integer(), integer()) :: {:ok, map()} | {:error, String.t()}
  def lookup_haxe_position(source_map, generated_line, generated_column) do
    # Convert to 0-based line number for internal lookup
    line_index = generated_line - 1
    
    case find_mapping_for_position(source_map, line_index, generated_column) do
      {:ok, mapping} ->
        {:ok, %{
          file: mapping.source_file,
          line: mapping.source_line + 1,  # Convert back to 1-based
          column: mapping.source_column,
          original_position: %{
            line: generated_line,
            column: generated_column
          }
        }}
        
      {:error, reason} ->
        {:error, reason}
    end
  end
  
  @doc """
  Enhances a compilation error with source mapping information.
  
  If the error refers to a generated Elixir file that has a corresponding source map,
  this function will add the original Haxe position information to the error.
  
  ## Parameters
  
    * `error` - Error map from HaxeCompiler.get_compilation_errors()
    
  ## Returns
  
    * Enhanced error map with source mapping information
  """
  @spec enhance_error_with_source_mapping(map()) :: map()
  def enhance_error_with_source_mapping(error) do
    case find_source_map_for_error(error) do
      {:ok, source_map_path} ->
        case parse_source_map(source_map_path) do
          {:ok, source_map} ->
            enhance_error_with_mapping(error, source_map)
            
          {:error, _reason} ->
            # If source map parsing fails, return original error
            error
        end
        
      {:error, _reason} ->
        # If no source map found, return original error  
        error
    end
  end
  
  @doc """
  Batch enhances multiple errors with source mapping information.
  
  ## Parameters
  
    * `errors` - List of error maps
    
  ## Returns
  
    * List of enhanced error maps with source mapping information
  """
  @spec enhance_errors_with_source_mapping([map()]) :: [map()]
  def enhance_errors_with_source_mapping(errors) when is_list(errors) do
    Enum.map(errors, &enhance_error_with_source_mapping/1)
  end
  
  @doc """
  Finds all available source map files in the project.
  
  ## Parameters
  
    * `target_dir` - Directory to search for .ex.map files (default: "lib")
    
  ## Returns
  
    * List of source map file paths
  """
  @spec find_available_source_maps(String.t()) :: [String.t()]
  def find_available_source_maps(target_dir \\ "lib") do
    if File.exists?(target_dir) do
      Path.wildcard(Path.join(target_dir, "**/*.ex.map"))
    else
      []
    end
  end
  
  # Private helper functions
  
  defp process_source_map(source_map_data, source_map_path) do
    case validate_source_map_format(source_map_data) do
      :ok ->
        mappings = decode_vlq_mappings(source_map_data["mappings"], source_map_data["sources"])
        
        processed_map = %{
          version: source_map_data["version"],
          file: source_map_data["file"],
          sources: source_map_data["sources"],
          mappings: mappings,
          source_map_path: source_map_path
        }
        
        {:ok, processed_map}
        
      {:error, reason} ->
        {:error, reason}
    end
  end
  
  defp validate_source_map_format(source_map_data) do
    cond do
      not Map.has_key?(source_map_data, "version") ->
        {:error, "Missing version field in source map"}
        
      source_map_data["version"] != 3 ->
        {:error, "Unsupported source map version: #{source_map_data["version"]}"}
        
      not Map.has_key?(source_map_data, "mappings") ->
        {:error, "Missing mappings field in source map"}
        
      not Map.has_key?(source_map_data, "sources") ->
        {:error, "Missing sources field in source map"}
        
      true ->
        :ok
    end
  end
  
  defp decode_vlq_mappings(mappings_string, sources) do
    # Decode VLQ mappings according to Source Map v3 specification
    # This is a simplified implementation - in production, you might want to use
    # a dedicated VLQ decoding library for better performance
    
    lines = String.split(mappings_string, ";")
    
    # State tracking for delta decoding
    state = %{
      generated_column: 0,
      source_index: 0,
      source_line: 0,
      source_column: 0
    }
    
    {decoded_lines, _final_state} = Enum.map_reduce(lines, state, fn line, acc_state ->
      decode_vlq_line(line, sources, acc_state)
    end)
    
    # Convert to indexed structure for fast lookups
    decoded_lines
    |> Enum.with_index()
    |> Enum.flat_map(fn {line_mappings, line_index} ->
      Enum.map(line_mappings, fn mapping ->
        Map.put(mapping, :generated_line, line_index)
      end)
    end)
  end
  
  defp decode_vlq_line(line, sources, state) do
    if String.trim(line) == "" do
      # Empty line
      {[], state}
    else
      # Reset generated column for new line
      line_state = %{state | generated_column: 0}
      
      segments = String.split(line, ",")
      {decoded_segments, final_state} = Enum.map_reduce(segments, line_state, fn segment, acc_state ->
        decode_vlq_segment(segment, sources, acc_state)
      end)
      
      {decoded_segments, final_state}
    end
  end
  
  defp decode_vlq_segment(segment, sources, state) do
    # Simplified VLQ decoding - decode the deltas and update state
    # In a full implementation, you would properly decode VLQ Base64 values
    
    # For now, create a mock mapping to demonstrate the structure
    # TODO: Implement proper VLQ Base64 decoding
    
    mock_mapping = %{
      generated_column: state.generated_column,
      source_file: Enum.at(sources, state.source_index, "unknown.hx"),
      source_line: state.source_line,
      source_column: state.source_column
    }
    
    # Update state with mock deltas (in real implementation, decode from segment)
    new_state = %{
      generated_column: state.generated_column + 5,
      source_index: state.source_index,
      source_line: state.source_line,
      source_column: state.source_column + 3
    }
    
    {mock_mapping, new_state}
  end
  
  defp find_mapping_for_position(source_map, line_index, column) do
    # Find the closest mapping for the given position
    case Enum.find(source_map.mappings, fn mapping ->
      mapping.generated_line == line_index and mapping.generated_column <= column
    end) do
      nil ->
        {:error, "No mapping found for position #{line_index + 1}:#{column}"}
        
      mapping ->
        {:ok, mapping}
    end
  end
  
  defp find_source_map_for_error(error) do
    file = Map.get(error, :file, "")
    
    cond do
      String.ends_with?(file, ".hx") ->
        # Haxe source file - look for corresponding .ex.map
        elixir_file = String.replace(file, ".hx", ".ex")
        source_map_path = elixir_file <> ".map"
        
        if File.exists?(source_map_path) do
          {:ok, source_map_path}
        else
          {:error, "Source map not found: #{source_map_path}"}
        end
        
      String.ends_with?(file, ".ex") ->
        # Generated Elixir file - look for corresponding .map
        source_map_path = file <> ".map"
        
        if File.exists?(source_map_path) do
          {:ok, source_map_path}
        else
          {:error, "Source map not found: #{source_map_path}"}
        end
        
      true ->
        {:error, "Unknown file type for source mapping: #{file}"}
    end
  end
  
  defp enhance_error_with_mapping(error, source_map) do
    line = Map.get(error, :line, 1)
    column = Map.get(error, :column_start, 0)
    
    case lookup_haxe_position(source_map, line, column) do
      {:ok, haxe_position} ->
        Map.merge(error, %{
          source_mapping: %{
            original_haxe: %{
              file: haxe_position.file,
              line: haxe_position.line,
              column: haxe_position.column
            },
            generated_elixir: %{
              file: error.file,
              line: line,
              column: column
            },
            source_map_file: source_map.source_map_path
          }
        })
        
      {:error, _reason} ->
        # If lookup fails, just mark that source mapping was attempted
        Map.put(error, :source_mapping_attempted, true)
    end
  end
end