This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.devcontainer/
  devcontainer.json
  Dockerfile
.github/
  workflows/
    ci.yml
haxe_libraries/
  ansi.hxml
  hxcpp.hxml
  hxnodejs.hxml
  tink_chunk.hxml
  tink_cli.hxml
  tink_core.hxml
  tink_io.hxml
  tink_macro.hxml
  tink_streams.hxml
  tink_stringly.hxml
  tink_testrunner.hxml
  travix.hxml
src/
  tink/
    testrunner/
      Assertion.hx
      Assertions.hx
      Batch.hx
      Case.hx
      Helper.hx
      Reporter.hx
      Result.hx
      Runner.hx
      Suite.hx
      Timer.hx
tests/
  RunTests.hx
.gitignore
.haxerc
.travis.yml
dev.hxml
extraParams.hxml
haxelib.json
README.md
tests.hxml

================================================================
Files
================================================================

================
File: .devcontainer/devcontainer.json
================
// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at:
// https://github.com/microsoft/vscode-dev-containers/tree/v0.159.0/containers/php
{
	"name": "PHP",
	"build": {
		"dockerfile": "Dockerfile",
		"args": { 
			// Update VARIANT to pick a PHP version: 8, 8.0, 7, 7.4, 7.3
			"VARIANT": "8",
			"INSTALL_NODE": "true",
			"NODE_VERSION": "lts/*"
		}
	},
	
	// Set *default* container specific settings.json values on container create.
	"settings": { 
		"terminal.integrated.shell.linux": "/bin/bash",
		"php.validate.executablePath": "/usr/local/bin/php"
	},

	// Add the IDs of extensions you want installed when the container is created.
	"extensions": [
		"felixfbecker.php-debug",
		"bmewburn.vscode-intelephense-client",
		"mrmlnc.vscode-apache"
	],

	// Use 'forwardPorts' to make a list of ports inside the container available locally.
	// "forwardPorts": [8080],

	// Use 'portsAttributes' to set default properties for specific forwarded ports. More info: https://code.visualstudio.com/docs/remote/devcontainerjson-reference.
	"portsAttributes": {
		"8000": {
			"label": "Hello Remote World",
			"onAutoForward": "notify"
		}
	},

	// Use 'otherPortsAttributes' to configure any ports that aren't configured using 'portsAttributes'.
	// "otherPortsAttributes": {
	// 		"onAutoForward": "silent"
	// },

	// Use 'postCreateCommand' to run commands after the container is created.
	// "postCreateCommand": "sudo chmod a+x \"$(pwd)\" && sudo rm -rf /var/www/html && sudo ln -s \"$(pwd)\" /var/www/html"

	// Comment out connect as root instead. More info: https://aka.ms/vscode-remote/containers/non-root.
	"remoteUser": "vscode"
}

================
File: .devcontainer/Dockerfile
================
# See here for image contents: https://github.com/microsoft/vscode-dev-containers/tree/v0.159.0/containers/php/.devcontainer/base.Dockerfile

# [Choice] PHP version: 8, 8.0, 7, 7.4, 7.3
ARG VARIANT="7"
FROM mcr.microsoft.com/vscode/devcontainers/php:0-${VARIANT}

# [Option] Install Node.js
ARG INSTALL_NODE="true"
ARG NODE_VERSION="lts/*"
RUN if [ "${INSTALL_NODE}" = "true" ]; then su vscode -c "umask 0002 && . /usr/local/share/nvm/nvm.sh && nvm install ${NODE_VERSION} 2>&1"; fi

# [Optional] Uncomment this section to install additional OS packages.
# RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
#     && apt-get -y install --no-install-recommends <your-package-list-here>

# [Optional] Uncomment this line to install global node packages.
# RUN su vscode -c "source /usr/local/share/nvm/nvm.sh && npm install -g <your-package-here>" 2>&1

================
File: .github/workflows/ci.yml
================
name: CI

on:
  push:
  pull_request:
    branches: [ master ]

jobs:
  test:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: 
          - ubuntu-latest
          # - windows-latest
          - macos-latest
        haxe-version:
          - 4.0.5
          - 4.1.5
          - stable
          - nightly
        tink_core:
          - v1
          - master
        target: 
          - interp
          - node
          - neko
          - python
          - php
          - cpp
          - js
          - java -D jvm
        exclude:
          - haxe-version: 4.0.5
            target: java -D jvm

    steps:
    - name: Check out repo
      uses: actions/checkout@v2
    
    - name: Get yarn cache directory path
      id: yarn-cache-dir-path
      run: echo "::set-output name=dir::$(yarn cache dir)"

    - name: Cache Yarn
      uses: actions/cache@v1
      with:
        path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
        
    - name: Cache Haxe
      uses: actions/cache@v1
      with:
        path: ${{ startsWith(runner.os, 'windows') && '%AppData%' || '~/haxe' }}
        key: ${{ runner.os }}-haxe
        
    - name: Install Lix
      uses: lix-pm/setup-lix@master
      
    - name: Install Haxe
      run: lix install haxe ${{ matrix.haxe-version }}
    
    - name: Install Haxe Libraries
      run: lix download
      
    - run: lix +tink 'core#${{ matrix.tink_core }}'
      
    - name: Run Test
      run: lix run travix ${{ matrix.target }}

  release:
    runs-on: ubuntu-latest
    needs: test
    if: startsWith(github.ref, 'refs/tags/') # consider using the "release" event. see: https://docs.github.com/en/actions/reference/events-that-trigger-workflows#release
    
    steps:
    - name: Check out repo
      uses: actions/checkout@v2
    
    - name: Get yarn cache directory path
      id: yarn-cache-dir-path
      run: echo "::set-output name=dir::$(yarn cache dir)"

    - name: Cache Yarn
      uses: actions/cache@v1
      with:
        path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
        
    - name: Cache Haxe
      uses: actions/cache@v1
      with:
        path: ${{ startsWith(runner.os, 'windows') && '%AppData%' || '~/haxe' }}
        key: ${{ runner.os }}-haxe
        
    - name: Install Lix
      uses: lix-pm/setup-lix@master
      
    - name: Install Haxe
      run: lix install haxe stable
    
    - name: Install Haxe Libraries
      run: lix download
      
    - name: Release to Haxelib
      run: lix run travix release
      env:
        HAXELIB_AUTH: ${{ secrets.HAXELIB_AUTH }}

================
File: haxe_libraries/ansi.hxml
================
# @install: lix --silent download haxelib:ansi#1.0.0 into ansi/1.0.0/haxelib
-D ansi=1.0.0
-cp ${HAXESHIM_LIBCACHE}/ansi/1.0.0/haxelib/src

================
File: haxe_libraries/hxcpp.hxml
================
# @install: lix --silent download "haxelib:/hxcpp#4.2.1" into hxcpp/4.2.1/haxelib
# @run: haxelib run-dir hxcpp ${HAXE_LIBCACHE}/hxcpp/4.2.1/haxelib
-cp ${HAXE_LIBCACHE}/hxcpp/4.2.1/haxelib/
-D hxcpp=4.2.1

================
File: haxe_libraries/hxnodejs.hxml
================
# @install: lix --silent download haxelib:hxnodejs#4.0.9 into hxnodejs/4.0.9/haxelib
-D hxnodejs=4.0.9
-cp ${HAXESHIM_LIBCACHE}/hxnodejs/4.0.9/haxelib/src
-D nodejs
--macro allowPackage('sys')
--macro _hxnodejs.VersionWarning.include()

================
File: haxe_libraries/tink_chunk.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_chunk#d58e35ce6985a9e40e76a9771e8eee30c6efa5aa" into tink_chunk/0.4.0/github/d58e35ce6985a9e40e76a9771e8eee30c6efa5aa
-cp ${HAXE_LIBCACHE}/tink_chunk/0.4.0/github/d58e35ce6985a9e40e76a9771e8eee30c6efa5aa/src
-D tink_chunk=0.4.0

================
File: haxe_libraries/tink_cli.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_cli#1278ad2a34fd5e2403e414aefe09bb938d0c8825" into tink_cli/0.5.1/github/1278ad2a34fd5e2403e414aefe09bb938d0c8825
-lib tink_io
-lib tink_macro
-lib tink_stringly
-cp ${HAXE_LIBCACHE}/tink_cli/0.5.1/github/1278ad2a34fd5e2403e414aefe09bb938d0c8825/src
-D tink_cli=0.5.1
# Make sure docs are generated
-D use-rtti-doc

================
File: haxe_libraries/tink_core.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_core#abee932c4e724517090238b6527eac28874c0354" into tink_core/1.27.1/github/abee932c4e724517090238b6527eac28874c0354
-cp ${HAXE_LIBCACHE}/tink_core/1.27.1/github/abee932c4e724517090238b6527eac28874c0354/src
-D tink_core=1.27.1

================
File: haxe_libraries/tink_io.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_io#ea6c6eec70f480082c6d8c4deed1cda4ae805fcf" into tink_io/0.8.0/github/ea6c6eec70f480082c6d8c4deed1cda4ae805fcf
-lib tink_chunk
-lib tink_streams
-cp ${HAXE_LIBCACHE}/tink_io/0.8.0/github/ea6c6eec70f480082c6d8c4deed1cda4ae805fcf/src
-D tink_io=0.8.0

================
File: haxe_libraries/tink_macro.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_macro#f1010a518fdefb484eaff8727ff022ba51658e53" into tink_macro/0.23.0/github/f1010a518fdefb484eaff8727ff022ba51658e53
-lib tink_core
-cp ${HAXE_LIBCACHE}/tink_macro/0.23.0/github/f1010a518fdefb484eaff8727ff022ba51658e53/src
-D tink_macro=0.23.0

================
File: haxe_libraries/tink_streams.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_streams#5066a96c4a8b483479b6a8df8893eaf8922d3bea" into tink_streams/0.4.0/github/5066a96c4a8b483479b6a8df8893eaf8922d3bea
-lib tink_core
-cp ${HAXE_LIBCACHE}/tink_streams/0.4.0/github/5066a96c4a8b483479b6a8df8893eaf8922d3bea/src
-D tink_streams=0.4.0
# temp for development, delete this file when pure branch merged
-D pure

================
File: haxe_libraries/tink_stringly.hxml
================
# @install: lix --silent download "gh://github.com/haxetink/tink_stringly#38fcef46679d45bdfc33fe31f341d8d0787cc98c" into tink_stringly/0.5.0/github/38fcef46679d45bdfc33fe31f341d8d0787cc98c
-lib tink_core
-cp ${HAXE_LIBCACHE}/tink_stringly/0.5.0/github/38fcef46679d45bdfc33fe31f341d8d0787cc98c/src
-D tink_stringly=0.5.0

================
File: haxe_libraries/tink_testrunner.hxml
================
-D tink_testrunner=0.9.0
-lib ansi
-lib tink_macro
-lib tink_streams
-cp src

extraParams.hxml

================
File: haxe_libraries/travix.hxml
================
# @install: lix --silent download "gh://github.com/back2dos/travix#354c2b2a82cc3b03e2f87cc1b6f0ddc0a6a5c133" into travix/0.15.0/github/354c2b2a82cc3b03e2f87cc1b6f0ddc0a6a5c133
# @post-install: cd ${HAXE_LIBCACHE}/travix/0.15.0/github/354c2b2a82cc3b03e2f87cc1b6f0ddc0a6a5c133 && haxe -cp src --run travix.PostDownload
# @run: haxelib run-dir travix ${HAXE_LIBCACHE}/travix/0.15.0/github/354c2b2a82cc3b03e2f87cc1b6f0ddc0a6a5c133
-lib tink_cli
-cp ${HAXE_LIBCACHE}/travix/0.15.0/github/354c2b2a82cc3b03e2f87cc1b6f0ddc0a6a5c133/src
-D travix=0.15.0
--macro travix.Macro.setup()

================
File: src/tink/testrunner/Assertion.hx
================
package tink.testrunner;

import haxe.PosInfos;

using tink.CoreApi;

class Assertion {
	
	public var holds(default, null):AssertionResult;
	public var description(default, null):String;
	public var pos(default, null):PosInfos;

	public function new(holds, description, ?pos:PosInfos) {
		this.holds = holds;
		this.description = description;
		this.pos = pos;
	}

}

abstract AssertionResult(Outcome<Noise, String>) from Outcome<Noise, String> to Outcome<Noise, String> {
	@:from
	public static function ofBool(v:Bool):AssertionResult
		return v ? Success(Noise) : Failure(null);
		
	@:from
	public static function ofOutcome<T>(v:Outcome<T, Error>):AssertionResult
		return switch v {
			case Success(_): Success(Noise);
			case Failure(e): Failure('${e.toString()} ${e.data}');
		}
		
	@:to
	public inline function toBool():Bool
		return this.isSuccess();
		
	@:op(!A) inline function not() return !toBool();
	@:op(A && B) static inline function and_(a:AssertionResult, b:Bool) return a.toBool() && b;
	@:op(A || B) static inline function or_(a:AssertionResult, b:Bool) return a.toBool() || b;
	@:op(A && B) static inline function _and(a:Bool, b:AssertionResult) return a && b.toBool();
	@:op(A || B) static inline function _or(a:Bool, b:AssertionResult) return a || b.toBool();
}

================
File: src/tink/testrunner/Assertions.hx
================
package tink.testrunner;

import tink.streams.Stream;
import haxe.PosInfos;

using tink.CoreApi;

private typedef Impl = Stream<Assertion, Error>;

@:forward @:transitive
abstract Assertions(Impl) from Impl to Impl {
	@:from
	public static inline function ofAssertion(o:Assertion):Assertions {
		return [o].iterator();
	}
	@:from
	public static inline function ofArray(o:Array<Assertion>):Assertions {
		return o.iterator();
	}
	@:from
	public static inline function ofPromiseArray(o:Promise<Array<Assertion>>):Assertions {
		return o.next(function(o):Impl return o.iterator());
	}
	
	@:from
	public static function ofFutureAssertion(p:Future<Assertion>):Assertions {
		#if java // HACK: somehow this passes the java native compilation
		return Stream.future(p.map(function(a):Stream<Dynamic, Dynamic> return Stream.single(a)));
		#else
		return p.map(function(a) return Success(ofAssertion(a)));
		#end
	}
	
	@:from
	public static function ofFutureAssertions(p:Future<Assertions>):Assertions {
		return p.map(Success);
	}
	
	@:from
	public static function ofSurpriseAssertion(p:Surprise<Assertion, Error>):Assertions {
		return Stream.future(p.map(function(o):Stream<Dynamic, Dynamic> return switch o {
			case Success(a): Stream.single(a);
			case Failure(e): Stream.ofError(e);
		}));
	}
	
	@:from
	public static inline function ofOutcomeAssertions(o:Outcome<Assertions, Error>):Assertions {
		return ofSurpriseAssertions(Future.sync(o));
	}
	
	@:from
	public static inline function ofPromiseAssertions(p:Promise<Assertions>):Assertions {
		return ofSurpriseAssertions(p);
	}
	
	@:from
	public static inline function ofSurpriseAssertions(p:Surprise<Assertions, Error>):Assertions {
		#if java // HACK: somehow this passes the java native compilation
		return Stream.future(p.map(function(o):Stream<Dynamic, Dynamic> return switch o {
			case Success(a): (a:Stream<Assertion, Error>);
			case Failure(e): Stream.ofError(e);
		}));
		#else
		return Stream.promise((p:Surprise<Impl, Error>));
		#end
	}
	
	#if tink_unittest
	// TODO: use solution from https://github.com/HaxeFoundation/haxe/issues/9611
	@:from
	public static inline function ofFutureAssertionBuffer(p:Future<tink.unit.AssertionBuffer>):Assertions {
		return ofFutureAssertions(cast p);
	}
	@:from
	public static inline function ofPromiseAssertionBuffer(p:Promise<tink.unit.AssertionBuffer>):Assertions {
		return ofPromiseAssertions(cast p);
	}
	#end
}

================
File: src/tink/testrunner/Batch.hx
================
package tink.testrunner;

#if macro 
import haxe.macro.Context;
using tink.MacroApi;
#end

@:forward
abstract Batch(Array<Suite>) from Array<Suite> to Array<Suite> {
	
	public var suites(get, never):Array<Suite>;
	
	public inline function new(suites:Array<Suite>)
		this = suites;
		
	@:from
	public static macro function ofAny(expr:haxe.macro.Expr) {
		var type = Context.typeof(expr);
		
		inline function isType(type, c:String)
			return Context.unify(type, Context.getType('tink.testrunner.$c'));
		
		return switch type {
			case TInst(_.get() => {name: 'Array', pack: []}, [param]) if(isType(param, 'Case')) : 
				macro @:pos(expr.pos) tink.testrunner.Batch.ofCases($expr);
			case TInst(_.get() => {name: 'Array', pack: []}, [param]) if(isType(param, 'Suite')) : 
				macro @:pos(expr.pos) tink.testrunner.Batch.ofSuites($expr);
			case _ if(isType(type, 'Case')):
				macro @:pos(expr.pos) tink.testrunner.Batch.ofCase($expr);
			case _ if(isType(type, 'Suite')):
				macro @:pos(expr.pos) tink.testrunner.Batch.ofSuite($expr);
			case _:
				expr.pos.error('Cannot cast $type to tink.testrunner.Batch');
		}
	}
	
	public static inline function ofSuites<T:Suite>(suites:Array<T>):Batch
		return new Batch(cast suites);
		
	public static inline function ofSuite(suite:Suite):Batch
		return ofSuites([suite]);
	
	public static inline function ofCases<T:Case>(cases:Array<T>, ?pos:haxe.PosInfos):Batch
		return ofSuite(Suite.ofCases(cases, pos));
		
	public static inline function ofCase(caze:Case, ?pos:haxe.PosInfos):Batch
		return ofCases([caze], pos);
		
	inline function get_suites()
		return this;
}

================
File: src/tink/testrunner/Case.hx
================
package tink.testrunner;

import haxe.PosInfos;
import tink.testrunner.Suite;

@:forward
abstract Case(CaseObject) from CaseObject to CaseObject {
	public function shouldRun(includeMode:Bool):Bool {
		return !this.exclude && (!includeMode || this.include);
	}
}

interface CaseObject {
	var suite:Suite;
	var info:CaseInfo;
	var timeout:Int;
	var include:Bool;
	var exclude:Bool;
	var pos:PosInfos;
	function execute():Assertions;
}

typedef CaseInfo = {
	name:String,
	description:String,
	pos:PosInfos,
}

class BasicCase implements CaseObject {
	public var suite:Suite;
	public var info:CaseInfo;
	public var timeout:Int = 5000;
	public var include:Bool = false;
	public var exclude:Bool = false;
	public var pos:PosInfos = null;
	
	public function new(?pos:PosInfos) {
		info = {
			name: Type.getClassName(Type.getClass(this)),
			description: null,
			pos: pos,
		}
	}
	
	public function execute():Assertions {
		return [].iterator();
	}
}

================
File: src/tink/testrunner/Helper.hx
================
package tink.testrunner;

class Helper {
	public static inline function exit(code:Int) {
		#if travix travix.Logger.exit
		#elseif (air || air3) untyped __global__["flash.desktop.NativeApplication"].nativeApplication.exit
		#elseif flash flash.system.System.exit
		#elseif (sys || nodejs) Sys.exit
		#elseif phantomjs untyped __js__('phantom').exit
		#else throw "not supported";
		#end (code);
	}
}

================
File: src/tink/testrunner/Reporter.hx
================
package tink.testrunner;

import tink.testrunner.Suite;
import tink.testrunner.Case;
import tink.testrunner.Result;

using tink.CoreApi;
using Lambda;
using StringTools;

interface Reporter {
	function report(type:ReportType):Future<Noise>; // reporter cannot fail, so it won't ruin the test
}

enum ReportType {
	BatchStart;
	SuiteStart(info:SuiteInfo, hasCasesToRun:Bool);
	CaseStart(info:CaseInfo, shouldRun:Bool);
	Assertion(assertion:Assertion);
	CaseFinish(result:CaseResult);
	SuiteFinish(result:SuiteResult);
	BatchFinish(result:BatchResult);
}

interface Formatter {
	function success(v:String):String;
	function error(v:String):String;
	function warning(v:String):String;
	function info(v:String):String;
	function extra(v:String):String;
	function mute(v:String):String;
	function normal(v:String):String;
	function color(v:String, color:String):String;
}

class BasicFormatter implements Formatter {
	public function new() {}
	
	public function success(v:String):String return color(v, 'green');
	public function error(v:String):String return color(v, 'red');
	public function warning(v:String):String return color(v, 'yellow');
	public function info(v:String):String return color(v, 'yellow');
	public function extra(v:String):String return color(v, 'cyan');
	public function mute(v:String):String return color(v, 'blue');
	public function normal(v:String):String return color(v, '');
	public function color(v:String, c:String):String return v;
}

#if ansi
class AnsiFormatter extends BasicFormatter {
	override function color(v:String, c:String):String
		return switch c {
			case 'red': ANSI.aset([ANSI.Attribute.Red]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			case 'green': ANSI.aset([ANSI.Attribute.Green]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			case 'blue': ANSI.aset([ANSI.Attribute.Blue]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			case 'yellow': ANSI.aset([ANSI.Attribute.Yellow]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			case 'magenta': ANSI.aset([ANSI.Attribute.Magenta]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			case 'cyan': ANSI.aset([ANSI.Attribute.Cyan]) + v + ANSI.aset([ANSI.Attribute.DefaultForeground]);
			default: ANSI.aset([ANSI.Attribute.DefaultForeground]) + v;
		}
}
#end

class BasicReporter implements Reporter {
	#if (ansi && (sys || nodejs))
	static var inited = false;
	#end
	var formatter:Formatter;
	
	public function new(?formatter) {
		#if (ansi && (sys || nodejs))
		if(!inited) {
			inited = true;
			init();
		}
		#end
		this.formatter =
			if(formatter != null)
				formatter;
			else {
				#if (ansi && (sys || nodejs))
					if(ANSI.available) {
						ANSI.stripIfUnavailable = false;
						new AnsiFormatter();
					} else {
						new BasicFormatter();
					}
				#elseif(ansi && js && travix) {
					ANSI.stripIfUnavailable = false;
					new AnsiFormatter();
				}
				#else
					new BasicFormatter();
				#end
			}
	}

	#if (ansi && (sys || nodejs))
	static function init() {
		if(Sys.systemName() == 'Windows') { 
			// HACK: use the "ANSICON" env var to force enable ANSI if running in PowerShell
			var value = Sys.getEnv('PSModulePath');
			var isPowerShell = value != null && value.split(';').length >= 3;
			#if !java // Java cannot do this ... perhaps it's possible via Sys.command, but since this is a hack anyway, I'll forgo the pleasure of messing with this
			if(isPowerShell) Sys.putEnv('ANSICON', '1');
			#end
		}
	}
	#end
	
	public function report(type:ReportType):Future<Noise> {
		switch type {
			case BatchStart:
				reportBatchStart();
			case SuiteStart(info, hasCasesToRun):
				reportSuiteStart(info, hasCasesToRun);
			case CaseStart(info, shouldRun):
				reportCaseStart(info, shouldRun);
			case Assertion(assertion):
				reportAssertion(assertion);
			case CaseFinish(result):
				reportCaseFinish(result);
			case SuiteFinish(result):
				reportSuiteFinish(result);
			case BatchFinish(result):
				reportBatchFinish(result);
		}
		return Future.NOISE;
	}

	function reportBatchStart() {}

	function reportSuiteStart(info:SuiteInfo, hasCasesToRun:Bool) {
		if (hasCasesToRun) {
			println(' ');
			var m = formatter.info(info.name) + ': ';
			if (info.pos != null)
				m += formatter.extra('[${info.pos.fileName}:${info.pos.lineNumber}]');
			println(m);
		}
	}

	function reportCaseStart(info:CaseInfo, shouldRun:Bool) {
		if (shouldRun) {
			var m = formatter.info(indent(info.name, 2)) + ': ';
			if (info.pos != null)
				m += formatter.extra('[${info.pos.fileName}:${info.pos.lineNumber}] ');
			if (info.description != null)
				m += formatter.mute(info.description);
			println(m);
		}
	}

	function reportAssertion(assertion:Assertion) {
		var failure = null;
		var holds = switch assertion.holds {
			case Success(_): formatter.success('[OK]');
			case Failure(msg):
				failure = msg;
				formatter.error('[FAIL]');
		}
		var pos = formatter.extra('[${assertion.pos.fileName}:${assertion.pos.lineNumber}]');
		var m = indent('- $holds $pos ${indent(assertion.description, 4, true)}', 4);
		println(m);
		if (failure != null)
			println(formatter.error(indent(failure, 8)));
	}

	function reportCaseFinish(result:CaseResult) {
		switch result.result {
			case Failed(e):
				println(formatter.error(indent('- ${formatError(e)}', 4)));
			case _:
		}
	}

	function reportSuiteFinish(result:SuiteResult) {
		switch result.result {
			case Succeeded(_): // ok
			case SetupFailed(e):
				println(formatter.error(indent('Setup Failed: ${formatError(e)}', 2)));
			case TeardownFailed(e, _):
				println(formatter.error(indent('Teardown Failed: ${formatError(e)}', 2)));
		}
	}

	function reportBatchFinish(result:BatchResult) {
		var summary = result.summary();
		var total = summary.assertions.length;
		var failures = 0, errors = 0;
		for (f in summary.failures)
			switch f {
				case AssertionFailed(_):
					failures++;
				default:
					errors++;
			}
		var success = total - failures;

		var m = new StringBuf();
		m.add(total);
		m.add(' Assertion');
		if (total > 1)
			m.add('s');
		m.add('   ');

		m.add(success);
		m.add(' Success');
		m.add('   ');

		m.add(failures);
		m.add(' Failure');
		if (failures > 1)
			m.add('s');
		m.add('   ');

		m.add(errors);
		m.add(' Error');
		if (errors > 1)
			m.add('s');
		m.add('   ');

		var m = m.toString();

		println(' ');
		println(failures == 0 && errors == 0 ? formatter.success(m) : formatter.error(m));
		println(' ');
	}

	function println(v:String)
		#if travix
			travix.Logger.println(v);
		#elseif (flash || air || air3)
			flash.Lib.trace(v);
		#elseif (sys || nodejs)
			Sys.println(v);
		#elseif js
			js.Browser.window.console.log(v);
		#else
			throw "Not supported yet";
		#end
	
	function indent(v:String, i = 0, skipFirst = false) {
		var prefix = ''.lpad(' ', i);
		var ret = v.split('\n')
			.map(function(line) return prefix + line)
			.join('\n');
		return skipFirst ? ret.substr(i) : ret;
	}
	
	function formatError(e:Error) {
		var str = e.toString();
		if(e.data != null) str += '\n' + Std.string(e.data);
		return str;
	}
}

class CompactReporter extends BasicReporter {
	var count = 0;

	override function reportCaseStart(info, shouldRun) {
		count = 0;
		super.reportCaseStart(info, shouldRun);
	}

	override function reportAssertion(assertion:Assertion) {
		if (assertion.holds) {
			count++;
		} else {
			super.reportAssertion(assertion);
		}
	}

	override function reportCaseFinish(result) {
		println(formatter.success(indent('+ $count assertion(s) succeeded', 4)));
		super.reportCaseFinish(result);
	}
}

================
File: src/tink/testrunner/Result.hx
================
package tink.testrunner;

import tink.testrunner.Case;
import tink.testrunner.Suite;
import tink.testrunner.Batch;

using tink.CoreApi;

@:forward
abstract BatchResult(Array<SuiteResult>) from Array<SuiteResult> to Array<SuiteResult> {
	public function summary() {
		var ret = {
			assertions: [],
			failures: [],
		};
		
		function handleCases(cases:Array<CaseResult>)
			for(c in cases) switch c.result {
				case Succeeded(assertions):
					ret.assertions = ret.assertions.concat(assertions);
					ret.failures = ret.failures.concat(
						assertions.filter(function(a) return !a.holds)
							.map(function(a) return AssertionFailed(a))
					);
				case Failed(e):
					ret.failures.push(CaseFailed(e, c.info));
				case Excluded:
					// do nothing
			}
		
		for(s in this) switch s.result {
			case Succeeded(cases):
				handleCases(cases);
			case SetupFailed(e):
				ret.failures.push(SuiteFailed(e, s.info));
			case TeardownFailed(e, cases): 
			 	handleCases(cases);
				ret.failures.push(SuiteFailed(e, s.info));
		}
		
		return ret;
	}
}

typedef SuiteResult = {
	info:SuiteInfo,
	result:SuiteResultType,
}

typedef CaseResult = {
	info:CaseInfo,
	result:CaseResultType,
}

enum SuiteResultType {
	Succeeded(cases:Array<CaseResult>);
	SetupFailed(e:Error);
	TeardownFailed(e:Error, cases:Array<CaseResult>);
}

enum CaseResultType {
	Succeeded(assertions:Array<Assertion>);
	Failed(e:Error);
	Excluded;
}

enum FailureType {
	AssertionFailed(assertion:Assertion);
	CaseFailed(err:Error, info:CaseInfo);
	SuiteFailed(err:Error, info:SuiteInfo);
}

================
File: src/tink/testrunner/Runner.hx
================
package tink.testrunner;

import tink.streams.Stream;
import tink.testrunner.Case;
import tink.testrunner.Suite;
import tink.testrunner.Reporter;
import tink.testrunner.Result;
import tink.testrunner.Timer;
import haxe.PosInfos;

using tink.testrunner.Runner.TimeoutHelper;
using tink.CoreApi;

class Runner {
	
	public static function exit(result:BatchResult) {
		Helper.exit(result.summary().failures.length);
	}
	
	public static function run(batch:Batch, ?reporter:Reporter, ?timers:TimerManager):Future<BatchResult> {
		
		if(reporter == null) reporter = new BasicReporter();
		if(timers == null) {
			#if ((haxe_ver >= 3.3) || flash || js || openfl)
				timers = new HaxeTimerManager();
			#end
		}
			
		var includeMode = false;
		for(s in batch.suites) {
			if(includeMode) break;
			for(c in s.cases) if(c.include) {
				includeMode = true;
				break;
			}
		}
		
		return Future #if (tink_core >= "2") .irreversible #else .async #end(function(cb) {
			reporter.report(BatchStart).handle(function(_) {
				var iter = batch.suites.iterator();
				var results:BatchResult = [];
				function next() {
					if(iter.hasNext()) {
						var suite = iter.next();
						runSuite(suite, reporter, timers, includeMode).handle(function(o) {
							results.push(o);
							reporter.report(SuiteFinish(o)).handle(next);
						});
					} else {
						reporter.report(BatchFinish(results)).handle(cb.bind(results));
					}
				}
				next();
			});
		});
	}
	
	
	static function runSuite(suite:Suite, reporter:Reporter, timers:TimerManager, includeMode:Bool):Future<SuiteResult> {
		return Future #if (tink_core >= "2") .irreversible #else .async #end(function(cb) {
			var cases = suite.getCasesToBeRun(includeMode);
			var hasCases = cases.length > 0;
			reporter.report(SuiteStart(suite.info, hasCases)).handle(function(_) {
				
				function setup() return hasCases ? suite.setup() : Promise.NOISE;
				function teardown() return hasCases ? suite.teardown() : Promise.NOISE;
				
				var iter = suite.cases.iterator();
				var results = [];
				function next() {
					if(iter.hasNext()) {
						var caze = iter.next();
						runCase(caze, suite, reporter, timers, caze.shouldRun(includeMode)).handle(function(r) {
							results.push(r);
							next();
						});
					} else {
						teardown().handle(function(o) cb({
							info: suite.info,
							result: switch o {
								case Success(_): Succeeded(results);
								case Failure(e): TeardownFailed(e, results);
							}
						}));
					}
				}
				setup().handle(function(o) switch o {
					case Success(_): next();
					case Failure(e): cb({info: suite.info, result: SetupFailed(e)});
				});
			});
		});
	}
	
	static function runCase(caze:Case, suite:Suite, reporter:Reporter, timers:TimerManager, shouldRun:Bool):Future<CaseResult> {
		return Future #if (tink_core >= "2") .irreversible #else .async #end(function(cb) {
			if(shouldRun) {
				reporter.report(CaseStart(caze.info, shouldRun)).handle(function(_) {
					suite.before().timeout(caze.timeout, timers, caze.pos)
						.next(function(_) {
							var assertions = [];
							return caze.execute().forEach(function(a) {
									assertions.push(a);
									return reporter.report(Assertion(a)).map(function(_) return Resume);
								})
								.next(function(o):Outcome<Array<Assertion>, Error> return switch o {
									case Depleted: Success(assertions);
									case Halted(_): throw 'unreachable';
									case Failed(e): Failure(e);
								})
								.timeout(caze.timeout, timers);
						})
						.flatMap(function(outcome) return suite.after().timeout(caze.timeout, timers, caze.pos).next(function(_) return outcome))
						.handle(function(result) {
							var results:CaseResult = {
								info: caze.info,
								result: switch result {
									case Success(v): Succeeded(v);
									case Failure(e): Failed(e);
								},
							}
							reporter.report(CaseFinish(results)).handle(function(_) cb(results));
						});
				});
			} else {
				reporter.report(CaseStart(caze.info, shouldRun))
					.handle(function(_) {
						var results:CaseResult = {
							info: caze.info,
							result: Excluded,
						}
						reporter.report(CaseFinish(results)).handle(function(_) cb(results));
					});
			}
		});
	}
	
}

class TimeoutHelper {
	public static function timeout<T>(promise:Promise<T>, ms:Int, timers:TimerManager, ?pos:PosInfos):Promise<T> {
		return Future #if (tink_core >= "2") .irreversible #else .async #end(function(cb) {
			var done = false;
			var timer = null;
			var link = promise.handle(function(o) {
				done = true;
				if(timer != null) timer.stop();
				cb(o);
			});
			if(!done && timers != null) {
				timer = timers.schedule(ms, function() {
					link.cancel();
					cb(Failure(new Error('Timed out after $ms ms', pos)));
				});
			}
		});
	}
}

================
File: src/tink/testrunner/Suite.hx
================
package tink.testrunner;

import tink.testrunner.Case;
import haxe.PosInfos;

using tink.CoreApi;

#if macro 
import haxe.macro.Context;
using tink.MacroApi;
#end

@:forward
abstract Suite(SuiteObject) from SuiteObject to SuiteObject {
	
	@:from
	public static macro function ofAny(expr:haxe.macro.Expr) {
		var type = Context.typeof(expr);
		
		inline function isType(type, c:String)
			return Context.unify(type, Context.getType('tink.testrunner.$c'));
		
		return switch type {
			case TInst(_.get() => {name: 'Array', pack: []}, [param]) if(isType(param, 'Case')): 
				macro @:pos(expr.pos) tink.testrunner.Suite.ofCases($expr);
			case _ if(isType(type, 'Case')):
				macro @:pos(expr.pos) tink.testrunner.Suite.ofCase($expr);
			case _ if(isType(type, 'Suite.SuiteObject')):
				expr;
			case _:
				expr.pos.error('Cannot cast $type to tink.testrunner.Suite');
		}
	}
	
	public static inline function ofCases<T:Case>(cases:Array<T>, ?pos:PosInfos):Suite
		return new BasicSuite({
			name: [for(c in cases) switch Type.getClass(c) {
				case null: null;
				case c: Type.getClassName(c);
			}].join(', '),
			pos: pos,
		}, cast cases);
	
	public static inline function ofCase(caze:Case, ?pos:PosInfos):Suite
		return ofCases([caze], pos);
		
	public function getCasesToBeRun(includeMode:Bool) {
		return this.cases.filter(function(c) return c.shouldRun(includeMode));
	}
}

typedef SuiteInfo = {
	name:String,
	?pos:PosInfos,
}

interface SuiteObject {
	var info:SuiteInfo;
	var cases:Array<Case>;
	function setup():Promise<Noise>;
	function before():Promise<Noise>;
	function after():Promise<Noise>;
	function teardown():Promise<Noise>;
}

class BasicSuite implements SuiteObject {
	public var info:SuiteInfo;
	public var cases:Array<Case>;
	
	public function new(info:SuiteInfo, cases, ?pos:haxe.PosInfos) {
		this.info = info;
		this.cases = cases;
		if(info.pos == null) info.pos = pos;
		for(c in cases) c.suite = this;
	}
	
	public function setup() return Promise.NOISE;
	public function before() return Promise.NOISE;
	public function after() return Promise.NOISE;
	public function teardown() return Promise.NOISE;
}

================
File: src/tink/testrunner/Timer.hx
================
package tink.testrunner;

interface Timer {
	function stop():Void;
}

interface TimerManager {
	function schedule(ms:Int, f:Void->Void):Timer;
}

#if ((haxe_ver >= 3.3) || flash || js || openfl)
class HaxeTimer implements Timer {
	
	var timer:haxe.Timer;
	
	public function new(ms:Int, f:Void->Void) {
		timer = haxe.Timer.delay(f, ms);
	}
	
	public function stop() {
		if(timer != null) {
			timer.stop();
			timer = null;
		}
	}
}

class HaxeTimerManager implements TimerManager {
	public function new() {}
	
	public function schedule(ms:Int, f:Void->Void):Timer {
		return new HaxeTimer(ms, f);
	}
}
#end

================
File: tests/RunTests.hx
================
package;

import tink.testrunner.*;
import tink.testrunner.Assertion.*;
import tink.testrunner.Case;
import tink.testrunner.Suite;
import tink.testrunner.Reporter;
import travix.Logger.*;

using tink.CoreApi;
using Lambda;

class RunTests {
	static function main() {
		
		var code = 0;
		
		function assertEquals<T>(expected:T, actual:T, ?pos:haxe.PosInfos) {
			if(expected != actual) {
				println('${pos.fileName}:${pos.lineNumber}: Expected $expected but got $actual ');
				code++;
			}
		}
		
		var futures = [];
		
		// Test: cast from single case
		var single = new SingleCase();
		futures.push(
			function() return Runner.run(single).map(function(result) {
				assertEquals(0, result.summary().failures.length);
				return Noise;
			})
		);
		
		// Test: cast from multiple cases
		futures.push(
			function() return Runner.run([
				single, 
				new FutureCase(),
				new PromiseCase(),
				new SurpriseCase(),
				new FuturesCase(),
				new PromisesCase(),
				new SurprisesCase(),
			]).map(function(result) {
				assertEquals(0, result.summary().failures.length);
				return Noise;
			})
		);
		
		// Test: empty suite (reporter should not print the empty suite)
		var reporter = new MemoryReporter();
		futures.push(
			function() return Runner.run([
				new BasicSuite({name: 'SingleSuite'}, [
					single,
				]),
				new BasicSuite({name: 'EmptySuite'}, [
					new ExcludedCase(),
				]),
				new BasicSuite({name: 'MixedSuite'}, [
					single,
					new ExcludedCase(),
				]),
			], reporter).map(function(result) {
				assertEquals(0, result.summary().failures.length);
				assertEquals(3, reporter.logs.filter(function(t) return t.match(SuiteStart(_))).length);
				assertEquals(true, reporter.logs.exists(function(t) return t.match(SuiteStart({name: 'SingleSuite'}, true))));
				assertEquals(true, reporter.logs.exists(function(t) return t.match(SuiteStart({name: 'EmptySuite'}, false))));
				assertEquals(true, reporter.logs.exists(function(t) return t.match(SuiteStart({name: 'MixedSuite'}, true))));
				assertEquals(2, reporter.logs.filter(function(t) return t.match(CaseStart({name: 'SingleCase'}, true))).length);
				assertEquals(2, reporter.logs.filter(function(t) return t.match(CaseStart({name: 'ExcludedCase'}, false))).length);
				assertEquals(2, reporter.logs.filter(function(t) return t.match(CaseFinish({info: {name: 'SingleCase'}, result: Succeeded(_)}))).length);
				assertEquals(2, reporter.logs.filter(function(t) return t.match(CaseFinish({info: {name: 'ExcludedCase'}, result: Excluded}))).length);
				return Noise;
			})
		);
		
		// Test: after/teardown should be run even if case errored
		var suite = new ActionSuite({name: 'ErrorSuite'}, [
			new ErrorCase(),
		]);
		futures.push(
			function() return Runner.run([
				suite,
			]).map(function(result) {
				assertEquals(suite.actions.join(','), 'setup,before,after,teardown');
				assertEquals(1, result.summary().failures.length);
				return Noise;
			})
		);
		
		var iter = futures.iterator();
		function next() {
			if(iter.hasNext()) iter.next()().handle(next);
			else {
				trace('Exiting with code: $code');
				exit(code);
			}
		}
		next();
	}
}

class SingleCase extends BasicCase {
	override function execute():Assertions {
		return new Assertion(true, 'Dummy');
	}
}
class FutureCase extends BasicCase {
	override function execute():Assertions {
		return Future.sync(new Assertion(true, 'Dummy'));
	}
}
class PromiseCase extends BasicCase {
	override function execute():Assertions {
		return (new Assertion(true, 'Dummy'):Promise<Assertion>);
	}
}
class SurpriseCase extends BasicCase {
	override function execute():Assertions {
		return Future.sync(Success(new Assertion(true, 'Dummy')));
	}
}
class FuturesCase extends BasicCase {
	override function execute():Assertions {
		return Future.sync((new Assertion(true, 'Dummy'):Assertions));
	}
}
class PromisesCase extends BasicCase {
	override function execute():Assertions {
		return ((new Assertion(true, 'Dummy'):Assertions):Promise<Assertions>);
	}
}
class SurprisesCase extends BasicCase {
	override function execute():Assertions {
		return Future.sync(Success((new Assertion(true, 'Dummy'):Assertions)));
	}
}
class ExcludedCase extends BasicCase {
	public function new() {
		super();
		exclude = true;
	}
	override function execute():Assertions {
		return new Assertion(true, 'Dummy');
	}
}
class ErrorCase extends BasicCase {
	override function execute():Assertions {
		return Failure(new Error('Errored'));
	}
}

class ActionSuite extends BasicSuite {
	public var actions:Array<String> = [];
	
	override function setup() {
		actions.push('setup');
		return Promise.NOISE;
	}
	override function before() {
		actions.push('before');
		return Promise.NOISE;
	}
	override function after() {
		actions.push('after');
		return Promise.NOISE;
	}
	override function teardown() {
		actions.push('teardown');
		return Promise.NOISE;
	}
}

class MemoryReporter implements Reporter {
	
	public var logs:Array<ReportType> = [];
	
	public function new() {}
	
	public function report(type:ReportType):Future<Noise> {
		logs.push(type);
		return Future.NOISE;
	}
}

================
File: .gitignore
================
bin/
node_modules

================
File: .haxerc
================
{
  "version": "4.2.1",
  "resolveLibs": "scoped"
}

================
File: .travis.yml
================
sudo: required
dist: xenial

stages:
  - test
  - deploy

language: node_js
node_js: 8

cache:
  directories:
    - $HOME/haxe

os:
  - linux
  # - osx

env:
  - HAXE_VERSION=3.4.7
  - HAXE_VERSION=latest
  
install:
  - npm i -g lix
  - lix install haxe $HAXE_VERSION
  - lix download
  
script:
  - lix run travix interp
  - lix run travix neko
  - lix run travix python
  - lix run travix node
  - lix run travix js
  # - lix run travix flash
  # - lix run travix java
  - lix run travix cpp
  # - lix run travix cs
  - lix run travix php
  - lix run travix lua


jobs:
  include:
    # - stage: test # should uncomment this when there is no matrix above (e.g. only one os, one env, etc)
    - stage: deploy
      os: linux
      install:
        - npm i -g lix
        - lix download
      script: skip
      env:
        secure: lR+Y+c2+yXXwd5LUR+zgQs/og9Cx2xRqdcPn77iZooIBnx33XGmGVN/AJEEsnFTQqBfDi0duwhBxeQ9wvlYkPCmp/9XPVcJS3RRnaVhEP6O4KWV3UVJaBlljNYhPBJ+xaz+FQ2xlECasUg8rCHbXeiL2TiadfPtvo96np9+TEXmcCySzrK4hy9Iv1Ad0M1WmFUZorpDrTqgcBpHnnLmc75gbwmu3UXeKkDodsYOsRnQSY59EO6yMSs4q6PiLiAto7cJc5kE/IptcUoxUUTe+9rV0D66fnMGVAHr3L+UMLfi92XYz1MCEtOh1lpViVFmLgyClPrjUg3QzeBYaPW1dJhilrOoAB6BUxRwjtkH9c57Ix4FQ3vR3NF+8k3ZdSYlE6CImOKCpx3WgfmII9gPmoVxX4/kw4GM4hcr2ODBPEr8rQpMchTd/QHx+QBq3vPolP9t3wPaXOUY+GitaSFRgs9u9vqZNWgBiq0y/Ym5qslOli0KhhHHl+b1/yJ6vWCJ8hR8YwXoKiTCxLpg0BEzKyTo9j5y8JDGSgawy3l9WIlqMP4kuNcu8XyNt8b3jac3GlFA6sV7/DxoRpqKCUD8KWis4O+wRwmIak5T7EfPsnD+a4Kk3WdMYMtWPZ0+0YxQGpjKmsBBjQ6E2OYGG16L9D0ieT3YfdY9r/t6wFSR/xaU=
      after_success:
        - lix run travix install
        - lix run travix release

================
File: dev.hxml
================
tests.hxml

-lib tink_testrunner
-lib travix

================
File: extraParams.hxml
================
--macro addGlobalMetadata('ANSI.Attribute', "@:native('ANSIAttribute')", false)

================
File: haxelib.json
================
{
	"name": "tink_testrunner",
	"license": "MIT",
	"tags": [],
	"classPath": "src",
	"contributors": [
		"kevinresol"
	],
	"releasenote": "Various bug fixes and drop haxe3 support",
	"version": "0.9.0",
	"url": "https://github.com/haxetink/tink_testrunner/",
	"dependencies": {
		"ansi": "",
		"tink_macro": "",
		"tink_streams": ""
	}
}

================
File: README.md
================
# Tinkerbell Test Runner

[![Build Status](https://travis-ci.org/haxetink/tink_testrunner.svg)](https://travis-ci.org/haxetink/tink_testrunner)
[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/haxetink/public)


tink_testrunner logically breaks down a test suite into several major parts:

Documentation: https://haxetink.github.io/tink_testrunner

================
File: tests.hxml
================
-cp tests
-main RunTests

-dce full
# -lib tink_await

-D no-deprecation-warnings



================================================================
End of Codebase
================================================================
