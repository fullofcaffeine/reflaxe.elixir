This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/reflaxe/elixir/ast/ElixirASTTransformer.hx, src/reflaxe/elixir/ast/ElixirASTBuilder.hx, src/reflaxe/elixir/ast/TemplateHelpers.hx, src/reflaxe/elixir/macros/HXX.hx, src/reflaxe/elixir/macros/ModuleMacro.hx, src/reflaxe/elixir/macros/RouterBuildMacro.hx, src/reflaxe/elixir/macros/EctoQueryMacros.hx, examples/todo-app/src_haxe/**/*.hx, examples/todo-app/build*.hxml, examples/todo-app/mix.exs, scripts/qa-sentinel.sh, docs/prds/**/*.md, docs/03-compiler-development/TRANSFORMER_PERF_TODOLIVE.md, docs/03-compiler-development/TRANSFORMER_ESSENTIAL_PASSES_TODOLIVE.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  03-compiler-development/
    TRANSFORMER_ESSENTIAL_PASSES_TODOLIVE.md
    TRANSFORMER_PERF_TODOLIVE.md
  prds/
    HAXE_ELIXIR_1_0_COMPILER_TODOAPP_PRD.md
    infrastructure-variable-elimination-fix.md
examples/
  todo-app/
    src_haxe/
      client/
        extern/
          Phoenix.hx
        hooks/
          AutoFocus.hx
          Hooks.hx
          LiveSync.hx
          ThemeToggle.hx
          TodoFilter.hx
          TodoForm.hx
        utils/
          DarkMode.hx
          LocalStorage.hx
        Boot.hx
        TodoApp.hx
      server/
        components/
          CoreComponents.hx
        contexts/
          Users.hx
        controllers/
          UserController.hx
        i18n/
          Gettext.hx
        infrastructure/
          Endpoint.hx
          Gettext.hx
          GettextErrorMessages.hx
          GettextUIMessages.hx
          Repo.hx
          Telemetry.hx
          TodoAppWeb.hx
          TranslationBindings.hx
        layouts/
          AppLayout.hx
          Layouts.hx
          RootLayout.hx
        live/
          SafeAssigns.hx
          TodoLive.hx
          UserLive.hx
        migrations/
          CreateTodos.hx
          CreateUsers.hx
        presence/
          TodoPresence.hx
        pubsub/
          TodoPubSub.hx
        schemas/
          Todo.hx
          User.hx
        services/
          UserGenServer.hx
        types/
          LiveViewTypes.hx
          Types.hx
      shared/
        PrewarmDummy.hx
        TodoTypes.hx
      test/
        contexts/
          UsersTest.hx
        live/
          TodoLiveClassTest.hx
          TodoLiveCrudTest.hx
          TodoLiveDueDateTest.hx
          TodoLiveOptimisticLatencyTest.hx
          TodoLiveTest.hx
        schemas/
          TodoTest.hx
        support/
          ConnCase.hx
          DataCase.hx
        web/
          HealthTest.hx
          TodoLiveCrudTest.hx
        AsyncAnonymousTest.hx
        AsyncTest.hx
        test_helper.hx
      TestAbstract.hx
      TestInjection.hx
      TestInline.hx
      TestStringBuf.hx
      TodoApp.hx
      TodoAppRouter.hx
    build-all.hxml
    build-client.hxml
    build-js.hxml
    build-prewarm-fast.hxml
    build-prewarm.hxml
    build-server-fast.hxml
    build-server-multipass.hxml
    build-server-passA1.hxml
    build-server-passA2.hxml
    build-server-passA3.hxml
    build-server-passB.hxml
    build-server-passC.hxml
    build-server-passD.hxml
    build-server-passE.hxml
    build-server-passF.hxml
    build-server.hxml
    build-test-async.hxml
    build-test-hang.hxml
    build-tests.hxml
    build.hxml
    mix.exs
scripts/
  qa-sentinel.sh
src/
  reflaxe/
    elixir/
      ast/
        ElixirASTBuilder.hx
        ElixirASTTransformer.hx
        TemplateHelpers.hx
      macros/
        EctoQueryMacros.hx
        HXX.hx
        ModuleMacro.hx
        RouterBuildMacro.hx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/prds/infrastructure-variable-elimination-fix.md">
# PRD: Infrastructure Variable Elimination System Fix

**Date**: January 2025
**Status**: In Progress
**Priority**: P0 (Blocking 1.0 release)

## Problem Statement

The infrastructure variable elimination system in TypedExprPreprocessor has two critical bugs that prevent successful compilation:

### Bug 1: Missing Infrastructure Variable Assignments
**Symptom**: Generated code contains `case g do` with no preceding `g = ...` assignment, causing "undefined variable 'g'" errors.

**Example**:
```elixir
# Generated (BROKEN):
def parse_message_impl(msg) do
    if not SafePubSub.isValidMessage(msg) do
      :none
    end
    case g do  # ERROR: undefined variable 'g'
      "bulk_update" -> ...
```

**Expected**:
```elixir
# Should generate:
def parse_message_impl(msg) do
    if not SafePubSub.isValidValid(msg) do
      :none
    end
    case Map.get(msg, :type) do  # Inlined expression
      "bulk_update" -> ...
```

### Bug 2: Empty Blocks in Expression Contexts
**Symptom**: Empty blocks generate empty strings (`''`) in expression positions, causing syntax errors.

**Example**:
```elixir
# Generated (BROKEN):
if c == nil, do: , else:   # SYNTAX ERROR

# Should generate:
if c == nil, do: nil, else: nil
```

## Root Cause Analysis

### Researcher Agent Findings

The researcher agent conducted a comprehensive investigation and identified:

#### Bug 1 Root Cause: Inverted Substitution Logic
**Location**: `TypedExprPreprocessor.hx:239`

**Original Code**:
```haxe
case TLocal(v) if (isInfrastructureVar(v.name) && !substitutions.exists(v.name)):
    // Only handles UNDEFINED variables (inverted logic!)
```

**What Happens**:
1. Pattern detection registers substitution: `_g ‚Üí msg.type` (lines 553-559)
2. Switch processing checks: `!substitutions.exists("_g")`
3. Result: `false` ‚Üí substitution NOT applied
4. Switch compiles with undefined variable reference

**The Fix**:
```haxe
case TLocal(v) if (isInfrastructureVar(v.name) && substitutions.exists(v.name)):
    // Apply substitution when it EXISTS
    substitutions.get(v.name);
```

#### Bug 2 Root Cause: No Context Awareness
**Location**: `ElixirASTPrinter.hx:1053-1057`

Empty blocks always generate empty strings regardless of context:
```haxe
case EBlock(expressions):
    if (expressions.length == 0) {
        '';  // ALWAYS empty string - no context awareness
    }
```

In Elixir, expression contexts (if branches, case branches) MUST return values.

## Attempted Solutions

### Attempt 1: BlockBuilder Fix
**What**: Changed `BlockBuilder.hx:86` from `return ENil` to `return EBlock([])`
**Result**: Removed `nil` from statement contexts but broke expression contexts (Bug 2)

### Attempt 2: Printer Fix
**What**: Changed `ElixirASTPrinter.hx:1057` from `'nil'` to `''`
**Result**: Fixed statement contexts but broke expression contexts

### Attempt 3: Substitution Logic Fix
**What**: Fixed condition in `TypedExprPreprocessor.hx:240` from `!substitutions.exists()` to `substitutions.exists()`
**Result**: Bug still persists - suggests different code path

## Current Hypothesis

The fix targets `processExpr TSwitch` case, but the actual switch may be processed through:
1. **processBlock** pattern detection (lines 476-565)
2. **processSwitchExpr** (line 681) which calls `processExpr(e, substitutions)`

The substitution may not reach the switch due to:
- Multiple processing paths
- Substitutions not propagating correctly
- Pattern detection failing in certain AST structures

## Required Investigation

### Phase 1: Diagnostic Instrumentation
1. Add comprehensive debug traces to track:
   - Where substitutions are registered
   - Where switches are processed
   - Which code path is taken
   - Why substitutions aren't applied

2. Test with minimal reproduction case

### Phase 2: Architectural Solution
Based on researcher agent recommendation:

#### Fix 1: Correct Substitution Application
**File**: `TypedExprPreprocessor.hx:237-249`

Ensure substitutions are applied in ALL code paths:
- Direct `processExpr TSwitch` case
- `processBlock` pattern detection
- `processSwitchExpr` processing

#### Fix 2: Context-Aware Empty Block Handling

**Step A**: Add context metadata
```haxe
// ElixirAST.hx
typedef ElixirMetadata = {
    ?inExpressionContext: Bool,
    // ... existing fields
}
```

**Step B**: Mark expression contexts
```haxe
// ConditionalBuilder.hx
var thenAst = compileExpressionImpl(eif, false);
if (thenAst.metadata == null) thenAst.metadata = {};
thenAst.metadata.inExpressionContext = true;
```

**Step C**: Context-aware printing
```haxe
// ElixirASTPrinter.hx:1053
case EBlock(expressions):
    if (expressions.length == 0) {
        var inExprCtx = ast.metadata?.inExpressionContext == true;
        inExprCtx ? 'nil' : '';  // Context-aware
    }
```

## Success Criteria

### Bug 1 Fixed
- [ ] `parseMessageImpl` generates `case Map.get(msg, :type) do`
- [ ] No undefined variable `g` errors
- [ ] Mix compilation succeeds
- [ ] All test cases pass

### Bug 2 Fixed
- [ ] Empty if branches generate `nil` not `''`
- [ ] No syntax errors in expression contexts
- [ ] `json_printer.ex` compiles successfully
- [ ] Context-aware empty block handling works

### Regression Prevention
- [ ] Snapshot tests updated with correct intended output
- [ ] New tests added for infrastructure variable patterns
- [ ] Documentation updated with architectural explanation

## Files Requiring Changes

1. **TypedExprPreprocessor.hx**:
   - Lines 237-249: Fix substitution logic
   - Add comprehensive debug traces

2. **ElixirAST.hx**:
   - Add `inExpressionContext` metadata field

3. **ConditionalBuilder.hx** (or similar):
   - Mark if/case expression branches with context metadata

4. **ElixirASTPrinter.hx**:
   - Lines 1053-1057: Context-aware empty block printing

5. **BlockBuilder.hx**:
   - Verify empty block handling is correct

## Testing Strategy

### Unit Tests
- Test substitution registration
- Test substitution application
- Test context metadata propagation

### Integration Tests
- `examples/todo-app` compilation must succeed
- `parseMessageImpl` generates correct code
- `json_printer.ex` generates correct code

### Regression Tests
- All existing snapshot tests must pass
- Add new tests for edge cases

## Timeline Estimate

- **Phase 1 (Diagnostics)**: 2-3 hours
- **Phase 2 (Implementation)**: 3-4 hours
- **Phase 3 (Testing)**: 2-3 hours
- **Total**: 7-10 hours

## Dependencies

- Researcher agent analysis (completed)
- Understanding of Haxe TypedExpr processing
- Knowledge of Reflaxe AST pipeline

## Risks

1. **Multiple Code Paths**: Switch processing may have multiple paths we haven't identified
2. **Metadata Propagation**: Context metadata may not propagate correctly through transformers
3. **Regression Impact**: Changes may affect other compilation patterns

## Mitigation Strategies

1. **Comprehensive Debugging**: Add extensive traces before making changes
2. **Incremental Testing**: Test each fix independently
3. **Snapshot Validation**: Update intended outputs carefully
4. **Rollback Plan**: Git branches for each attempted fix

## References

- [Researcher Agent Analysis](../infrastructure-variable-bug-analysis.md)
- [TypedExprPreprocessor Source](../../src/reflaxe/elixir/preprocessor/TypedExprPreprocessor.hx)
- [ElixirASTPrinter Source](../../src/reflaxe/elixir/ast/ElixirASTPrinter.hx)
- [Todo-App parseMessageImpl](../../examples/todo-app/src_haxe/server/pubsub/TodoPubSub.hx:189-226)
</file>

<file path="examples/todo-app/src_haxe/client/extern/Phoenix.hx">
package client.extern;

import js.html.Element;

/**
 * Phoenix LiveView JavaScript API extern definitions
 * Provides type-safe interfaces for Phoenix LiveView hooks
 */

/**
 * Phoenix LiveView Hook interface
 * All hooks must implement these methods
 */
interface LiveViewHook {
    /**
     * Element that the hook is attached to
     */
    var el: Element;
}

// Also fix the closing brace to be on its own line

/**
 * Phoenix LiveView Socket extern
 */
extern class LiveSocket {
    public function new(url: String, socket: Dynamic, ?options: Dynamic);
    public function connect(): Void;
    public function disconnect(): Void;
    public function isConnected(): Bool;
    public function pushEvent(event: String, payload: Dynamic): Void;
    public var hooks: Dynamic;
}

/**
 * Phoenix Socket extern
 */
extern class Socket {
    public function new(url: String, ?options: Dynamic);
    public function connect(): Void;
    public function disconnect(): Void;
    public function isConnected(): Bool;
}

/**
 * Phoenix Channel extern
 */
extern class Channel {
    public function new(topic: String, payload: Dynamic, socket: Socket);
    public function join(): Dynamic;
    public function leave(): Dynamic;
    public function push(event: String, payload: Dynamic): Dynamic;
    public function on(event: String, callback: Dynamic -> Void): Void;
}

/**
 * LiveView test utilities (for testing)
 */
extern class LiveViewTest {
    public static function live(conn: Dynamic, path: String): Dynamic;
    public static function render_click(view: Dynamic, selector: String): String;
    public static function render_submit(form: Dynamic): String;
    public static function form(view: Dynamic, selector: String, params: Dynamic): Dynamic;
    public static function element(view: Dynamic, selector: String): Dynamic;
    public static function has_element(view: Dynamic, selector: String): Bool;
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/AutoFocus.hx">
package client.hooks;

import js.html.Element;
import js.html.InputElement;
import js.html.TextAreaElement;
import client.extern.Phoenix.LiveViewHook;

/**
 * AutoFocus hook for automatic focus on form inputs
 * Focuses the element when mounted and optionally when updated
 */
class AutoFocus implements LiveViewHook {
    
    public var el: Element;
    
    public function new() {}
    
    /**
     * Focus the element when mounted
     */
    public function mounted(): Void {
        focusElement();
    }
    
    /**
     * Optionally focus again when updated (if specified in data attributes)
     */
    public function updated(): Void {
        var refocusOnUpdate = el.getAttribute("data-refocus-on-update");
        if (refocusOnUpdate == "true") {
            focusElement();
        }
    }
    
    /**
     * Focus the element with proper type checking
     */
    private function focusElement(): Void {
        // Small delay to ensure the element is fully rendered
        js.Browser.window.setTimeout(function() {
            try {
                if (Std.isOfType(el, InputElement)) {
                    var input: InputElement = cast el;
                    input.focus();
                    
                    // Position cursor at end if it's a text input
                    if (input.type == "text" || input.type == "email" || input.type == "search") {
                        var length = input.value.length;
                        input.setSelectionRange(length, length);
                    }
                } else if (Std.isOfType(el, TextAreaElement)) {
                    var textarea: TextAreaElement = cast el;
                    textarea.focus();
                    
                    // Position cursor at end
                    var length = textarea.value.length;
                    textarea.setSelectionRange(length, length);
                } else {
                    // Generic focus for other elements
                    el.focus();
                }
            } catch (e: Dynamic) {
                trace('AutoFocus error: $e');
            }
        }, 10);
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/Hooks.hx">
package client.hooks;

/**
 * Hooks registry for Phoenix LiveView
 * Exports all available hooks for LiveView to use
 */
class Hooks {
    
    /**
     * Get all available hooks as a dynamic object
     * This is what gets exported to Phoenix LiveView
     */
    public static function getAll(): Dynamic {
        return {
            AutoFocus: AutoFocus,
            ThemeToggle: ThemeToggle,
            TodoForm: TodoForm,
            TodoFilter: TodoFilter,
            LiveSync: LiveSync
        };
    }
    
    /**
     * Individual hook getters for direct access
     */
    public static function getAutoFocus(): Dynamic {
        return AutoFocus;
    }
    
    public static function getThemeToggle(): Dynamic {
        return ThemeToggle;
    }
    
    public static function getTodoForm(): Dynamic {
        return TodoForm;
    }
    
    public static function getTodoFilter(): Dynamic {
        return TodoFilter;
    }
    
    public static function getLiveSync(): Dynamic {
        return LiveSync;
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/LiveSync.hx">
package client.hooks;

import js.html.Element;
import client.extern.Phoenix.LiveViewHook;
import client.utils.LocalStorage;
import shared.TodoTypes;

/**
 * LiveSync hook for real-time synchronization and offline support
 * Handles PubSub events, offline detection, and state synchronization
 */
class LiveSync implements LiveViewHook {
    
    public var el: Element;
    
    private var isOnline: Bool = true;
    private var syncQueue: Array<Dynamic> = [];
    private var lastSyncTime: Float = 0;
    
    public function new() {}
    
    /**
     * Set up real-time sync when mounted
     */
    public function mounted(): Void {
        setupOnlineDetection();
        setupPubSubHandlers();
        setupPeriodicSync();
        restoreOfflineQueue();
        
        // Mark as online and attempt initial sync
        setOnlineStatus(js.Browser.navigator.onLine);
        
        // Subscribe to todo updates
        subscribeToUpdates();
    }
    
    /**
     * Handle updates from LiveView
     */
    public function updated(): Void {
        updateLastSyncTime();
        processIncomingUpdates();
    }
    
    /**
     * Clean up when destroyed
     */
    public function destroyed(): Void {
        unsubscribeFromUpdates();
    }
    
    /**
     * Set up online/offline detection
     */
    private function setupOnlineDetection(): Void {
        js.Browser.window.addEventListener("online", function() {
            setOnlineStatus(true);
            processSyncQueue();
        });
        
        js.Browser.window.addEventListener("offline", function() {
            setOnlineStatus(false);
            showOfflineIndicator();
        });
        
        // Initial status
        setOnlineStatus(js.Browser.navigator.onLine);
    }
    
    /**
     * Set up PubSub event handlers
     */
    private function setupPubSubHandlers(): Void {
        // Handle different types of PubSub events
        handleEventIfAvailable("todo_added", handleTodoAdded);
        handleEventIfAvailable("todo_updated", handleTodoUpdated);
        handleEventIfAvailable("todo_deleted", handleTodoDeleted);
        handleEventIfAvailable("user_joined", handleUserJoined);
        handleEventIfAvailable("user_left", handleUserLeft);
        handleEventIfAvailable("sync_state", handleSyncState);
    }
    
    /**
     * Set up periodic sync for data consistency
     */
    private function setupPeriodicSync(): Void {
        // Sync every 30 seconds when online
        js.Browser.window.setInterval(function() {
            if (isOnline) {
                requestSync();
            }
        }, 30000);
    }
    
    /**
     * Subscribe to todo updates channel
     */
    private function subscribeToUpdates(): Void {
        pushEventIfAvailable("subscribe_to_updates", {
            user_id: getCurrentUserId(),
            timestamp: Date.now().getTime()
        });
    }
    
    /**
     * Unsubscribe from updates
     */
    private function unsubscribeFromUpdates(): Void {
        pushEventIfAvailable("unsubscribe_from_updates", {
            user_id: getCurrentUserId()
        });
    }
    
    /**
     * Set online status and update UI
     */
    private function setOnlineStatus(online: Bool): Void {
        var wasOnline = isOnline;
        isOnline = online;
        
        // Update status indicator
        updateStatusIndicator(online);
        
        // If we came back online, process pending actions
        if (!wasOnline && online) {
            showOnlineIndicator();
            processSyncQueue();
        }
    }
    
    /**
     * Update status indicator in UI
     */
    private function updateStatusIndicator(online: Bool): Void {
        var indicator = js.Browser.document.querySelector(".connection-status");
        if (indicator != null) {
            if (online) {
                indicator.classList.remove("offline");
                indicator.classList.add("online");
                indicator.textContent = "‚ö° Real-time sync enabled";
            } else {
                indicator.classList.remove("online");
                indicator.classList.add("offline");
                indicator.textContent = "üì¥ Offline mode";
            }
        }
    }
    
    /**
     * Handle todo added event
     */
    private function handleTodoAdded(payload: Dynamic): Void {
        trace('Todo added: ${payload.todo.title}');
        
        // Update local cache
        var todos = getCachedTodos();
        todos.push(payload.todo);
        cacheTodos(todos);
        
        // Show notification if it's from another user
        if (payload.todo.user_id != getCurrentUserId()) {
            showNotification("New Todo", 'A new todo "${payload.todo.title}" was added', "üìù");
        }
    }
    
    /**
     * Handle todo updated event
     */
    private function handleTodoUpdated(payload: Dynamic): Void {
        trace('Todo updated: ${payload.todo.title}');
        
        // Update local cache
        var todos = getCachedTodos();
        var index = findTodoIndex(todos, payload.todo.id);
        if (index >= 0) {
            todos[index] = payload.todo;
            cacheTodos(todos);
        }
        
        // Visual feedback for updates
        highlightUpdatedTodo(payload.todo.id);
    }
    
    /**
     * Handle todo deleted event
     */
    private function handleTodoDeleted(payload: Dynamic): Void {
        trace('Todo deleted: ${payload.id}');
        
        // Update local cache
        var todos = getCachedTodos();
        var index = findTodoIndex(todos, payload.id);
        if (index >= 0) {
            todos.splice(index, 1);
            cacheTodos(todos);
        }
    }
    
    /**
     * Handle user joined event
     */
    private function handleUserJoined(payload: Dynamic): Void {
        showNotification("User Joined", '${payload.user.name} joined the session', "üëã");
    }
    
    /**
     * Handle user left event
     */
    private function handleUserLeft(payload: Dynamic): Void {
        showNotification("User Left", '${payload.user.name} left the session', "üëã");
    }
    
    /**
     * Handle sync state event
     */
    private function handleSyncState(payload: Dynamic): Void {
        lastSyncTime = payload.timestamp;
        updateLastSyncIndicator();
    }
    
    /**
     * Process the offline sync queue
     */
    private function processSyncQueue(): Void {
        if (!isOnline || syncQueue.length == 0) return;
        
        trace('Processing ${syncQueue.length} queued actions');
        
        for (action in syncQueue) {
            pushEventIfAvailable(action.event, action.payload);
        }
        
        // Clear the queue after successful sync
        syncQueue = [];
        LocalStorage.remove("sync_queue");
        
        showNotification("Sync Complete", 'Synchronized ${syncQueue.length} offline changes', "‚úÖ");
    }
    
    /**
     * Queue an action for offline sync
     */
    public function queueAction(event: String, payload: Dynamic): Void {
        var action = {
            event: event,
            payload: payload,
            timestamp: Date.now().getTime()
        };
        
        syncQueue.push(action);
        LocalStorage.setObject("sync_queue", syncQueue);
        
        showNotification("Action Queued", "Action saved for sync when online", "üíæ");
    }
    
    /**
     * Restore offline queue from localStorage
     */
    private function restoreOfflineQueue(): Void {
        var stored = LocalStorage.getObject("sync_queue");
        if (stored != null && Std.isOfType(stored, Array)) {
            syncQueue = stored;
            trace('Restored ${syncQueue.length} queued actions');
        }
    }
    
    /**
     * Request sync from server
     */
    private function requestSync(): Void {
        pushEventIfAvailable("request_sync", {
            last_sync: lastSyncTime,
            client_timestamp: Date.now().getTime()
        });
    }
    
    /**
     * Update last sync time
     */
    private function updateLastSyncTime(): Void {
        lastSyncTime = Date.now().getTime();
        updateLastSyncIndicator();
    }
    
    /**
     * Update last sync time indicator
     */
    private function updateLastSyncIndicator(): Void {
        var indicator = js.Browser.document.querySelector(".last-sync-time");
        if (indicator != null) {
            var timeAgo = getTimeAgo(lastSyncTime);
            indicator.textContent = 'Last updated: $timeAgo';
        }
    }
    
    /**
     * Process incoming updates from LiveView
     */
    private function processIncomingUpdates(): Void {
        // Check for data attributes with update information
        var updateType = el.getAttribute("data-update-type");
        var updateData = el.getAttribute("data-update-data");
        
        if (updateType != null && updateData != null) {
            try {
                var data = haxe.Json.parse(updateData);
                handleIncomingUpdate(updateType, data);
            } catch (e: Dynamic) {
                trace('Error processing update: $e');
            }
        }
    }
    
    /**
     * Handle incoming update based on type
     */
    private function handleIncomingUpdate(type: String, data: Dynamic): Void {
        switch (type) {
            case "todo_list_updated":
                handleTodoListUpdate(data);
            case "filter_changed":
                handleFilterChange(data);
            case "search_results":
                handleSearchResults(data);
        }
    }
    
    /**
     * Handle todo list update
     */
    private function handleTodoListUpdate(data: Dynamic): Void {
        if (data.todos != null) {
            cacheTodos(data.todos);
        }
    }
    
    /**
     * Handle filter change
     */
    private function handleFilterChange(data: Dynamic): Void {
        LocalStorage.setString("current_filter", data.filter);
    }
    
    /**
     * Handle search results
     */
    private function handleSearchResults(data: Dynamic): Void {
        // Could cache search results for offline access
        LocalStorage.setObject("last_search_results", data);
    }
    
    /**
     * Cache todos in localStorage
     */
    private function cacheTodos(todos: Array<Dynamic>): Void {
        LocalStorage.setObject("todos_cache", {
            todos: todos,
            timestamp: Date.now().getTime()
        });
    }
    
    /**
     * Get cached todos
     */
    private function getCachedTodos(): Array<Dynamic> {
        var cache = LocalStorage.getObject("todos_cache");
        return (cache != null && cache.todos != null) ? cache.todos : [];
    }
    
    /**
     * Find todo index in array
     */
    private function findTodoIndex(todos: Array<Dynamic>, id: Int): Int {
        for (i in 0...todos.length) {
            if (todos[i].id == id) return i;
        }
        return -1;
    }
    
    /**
     * Highlight updated todo for visual feedback
     */
    private function highlightUpdatedTodo(id: Int): Void {
        var todoElement = js.Browser.document.querySelector('[data-todo-id="$id"]');
        if (todoElement != null) {
            todoElement.classList.add("updated-highlight");
            js.Browser.window.setTimeout(function() {
                todoElement.classList.remove("updated-highlight");
            }, 2000);
        }
    }
    
    /**
     * Show notification
     */
    private function showNotification(title: String, message: String, icon: String): Void {
        // For now, just use console - could integrate with browser notifications
        trace('$icon $title: $message');
    }
    
    /**
     * Show online indicator
     */
    private function showOnlineIndicator(): Void {
        showNotification("Back Online", "Reconnected to server", "üåê");
    }
    
    /**
     * Show offline indicator
     */
    private function showOfflineIndicator(): Void {
        showNotification("Gone Offline", "Working in offline mode", "üì¥");
    }
    
    /**
     * Get current user ID
     */
    private function getCurrentUserId(): Int {
        var userId = el.getAttribute("data-user-id");
        return userId != null ? Std.parseInt(userId) : 0;
    }
    
    /**
     * Get time ago string
     */
    private function getTimeAgo(timestamp: Float): String {
        var now = Date.now().getTime();
        var diff = now - timestamp;
        var seconds = Math.floor(diff / 1000);
        
        if (seconds < 60) return "just now";
        if (seconds < 3600) return '${Math.floor(seconds / 60)} minutes ago';
        if (seconds < 86400) return '${Math.floor(seconds / 3600)} hours ago';
        return '${Math.floor(seconds / 86400)} days ago';
    }
    
    /**
     * Handle event if available
     */
    private function handleEventIfAvailable(event: String, handler: Dynamic -> Void): Void {
        try {
            var handleEvent = Reflect.field(this, "handleEvent");
            if (handleEvent != null && Reflect.isFunction(handleEvent)) {
                handleEvent(event, handler);
            }
        } catch (e: Dynamic) {
            trace('Could not set up handler for event ${event}: ${e}');
        }
    }
    
    /**
     * Push event to LiveView if available
     */
    private function pushEventIfAvailable(event: String, payload: Dynamic): Void {
        if (!isOnline) {
            queueAction(event, payload);
            return;
        }
        
        try {
            var pushEvent = Reflect.field(this, "pushEvent");
            if (pushEvent != null && Reflect.isFunction(pushEvent)) {
                pushEvent(event, payload);
            }
        } catch (e: Dynamic) {
            trace('Could not push event ${event}: ${e}');
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/ThemeToggle.hx">
package client.hooks;

import js.html.Element;
import js.html.ButtonElement;
import client.extern.Phoenix.LiveViewHook;
import client.utils.DarkMode;

/**
 * Theme toggle hook for dark/light mode switching
 * Manages theme toggle button state and interactions
 */
class ThemeToggle implements LiveViewHook {
    
    public var el: Element;
    
    public function new() {}
    
    /**
     * Set up theme toggle when mounted
     */
    public function mounted(): Void {
        setupToggleButton();
        updateButtonState();
    }
    
    /**
     * Update button state when the component updates
     */
    public function updated(): Void {
        updateButtonState();
    }
    
    /**
     * Set up click event listener for the toggle button
     */
    private function setupToggleButton(): Void {
        if (!Std.isOfType(el, ButtonElement)) {
            trace("ThemeToggle hook must be attached to a button element");
            return;
        }
        
        var button: ButtonElement = cast el;
        
        button.addEventListener("click", function(e) {
            e.preventDefault();
            
            // Toggle the theme
            DarkMode.toggle();
            
            // Update button visual state
            updateButtonState();
            
            // Optional: Notify LiveView of theme change
            var theme = DarkMode.isEnabled() ? "dark" : "light";
            pushEventIfAvailable("theme_changed", {theme: theme});
            
            // Add visual feedback
            addClickFeedback(button);
        });
    }
    
    /**
     * Update the button's visual state based on current theme
     */
    private function updateButtonState(): Void {
        var button: ButtonElement = cast el;
        var isDark = DarkMode.isEnabled();
        
        // Update button title/tooltip
        button.title = isDark ? "Switch to light mode" : "Switch to dark mode";
        
        // Update aria-label for accessibility
        button.setAttribute("aria-label", isDark ? "Switch to light mode" : "Switch to dark mode");
        
        // Update data attribute for CSS styling
        button.setAttribute("data-theme", isDark ? "dark" : "light");
        
        // Update icon visibility if icons are present
        updateIconVisibility(isDark);
    }
    
    /**
     * Update icon visibility for dark/light mode icons
     */
    private function updateIconVisibility(isDark: Bool): Void {
        var darkIcon = el.querySelector("#theme-toggle-dark-icon");
        var lightIcon = el.querySelector("#theme-toggle-light-icon");
        
        if (darkIcon != null && lightIcon != null) {
            if (isDark) {
                // Dark mode active, show light icon (to switch to light)
                darkIcon.classList.add("hidden");
                lightIcon.classList.remove("hidden");
            } else {
                // Light mode active, show dark icon (to switch to dark)
                darkIcon.classList.remove("hidden");
                lightIcon.classList.add("hidden");
            }
        }
    }
    
    /**
     * Add visual feedback when button is clicked
     */
    private function addClickFeedback(button: ButtonElement): Void {
        // Add a temporary class for click animation
        button.classList.add("theme-toggle-clicked");
        
        // Remove the class after animation
        js.Browser.window.setTimeout(function() {
            button.classList.remove("theme-toggle-clicked");
        }, 200);
    }
    
    /**
     * Push event to LiveView if the pushEvent function is available
     */
    private function pushEventIfAvailable(event: String, payload: Dynamic): Void {
        try {
            // Check if pushEvent is available on this hook instance
            var pushEvent = Reflect.field(this, "pushEvent");
            if (pushEvent != null && Reflect.isFunction(pushEvent)) {
                pushEvent(event, payload);
            }
        } catch (e: Dynamic) {
            // Silently handle if pushEvent is not available
            trace('Could not push event ${event}: ${e}');
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/TodoFilter.hx">
package client.hooks;

import js.html.Element;
import js.html.InputElement;
import js.html.KeyboardEvent;
import client.extern.Phoenix.LiveViewHook;
import client.utils.LocalStorage;
import shared.TodoTypes;

/**
 * TodoFilter hook for search and filtering functionality
 * Handles search input, filter persistence, and keyboard shortcuts
 */
class TodoFilter implements LiveViewHook {
    
    public var el: Element;
    
    private var searchTimer: Int = -1;
    private var searchDelay: Int = 300; // 300ms debounce
    
    public function new() {}
    
    /**
     * Set up filter functionality when mounted
     */
    public function mounted(): Void {
        setupSearchInput();
        setupFilterButtons();
        setupKeyboardShortcuts();
        restoreFilterState();
    }
    
    /**
     * Clean up when destroyed
     */
    public function destroyed(): Void {
        clearSearchTimer();
    }
    
    /**
     * Set up search input with debouncing
     */
    private function setupSearchInput(): Void {
        var searchInput = el.querySelector("input[type='text']");
        if (searchInput == null) return;
        
        var input: InputElement = cast searchInput;
        
        input.addEventListener("input", function(e) {
            scheduleSearch(input.value);
        });
        
        input.addEventListener("keydown", function(e: KeyboardEvent) {
            // Escape: Clear search
            if (e.key == "Escape") {
                e.preventDefault();
                clearSearch(input);
            }
            
            // Enter: Execute search immediately
            if (e.key == "Enter") {
                e.preventDefault();
                executeSearch(input.value);
            }
        });
        
        // Placeholder text based on current filter
        updateSearchPlaceholder(input);
    }
    
    /**
     * Set up filter button interactions
     */
    private function setupFilterButtons(): Void {
        var filterButtons = el.querySelectorAll("[phx-click='filter_todos']");
        
        for (i in 0...filterButtons.length) {
            var button = filterButtons[i];
            
            button.addEventListener("click", function(e) {
                var filterValue = cast(button, js.html.Element).getAttribute("phx-value-filter");
                saveFilterState(filterValue);
                updateActiveButton(cast(button, js.html.Element));
            });
        }
    }
    
    /**
     * Set up keyboard shortcuts for filtering
     */
    private function setupKeyboardShortcuts(): Void {
        js.Browser.document.addEventListener("keydown", function(e: KeyboardEvent) {
            // Only handle if this filter component is active
            if (!isComponentActive()) return;
            
            // Ctrl/Cmd + F: Focus search
            if ((e.ctrlKey || e.metaKey) && e.key == "f") {
                e.preventDefault();
                focusSearch();
            }
            
            // Alt + 1/2/3: Filter shortcuts
            if (e.altKey && !e.ctrlKey && !e.metaKey) {
                var filterMap = ["all", "active", "completed"];
                var index = Std.parseInt(e.key) - 1;
                
                if (index >= 0 && index < filterMap.length) {
                    e.preventDefault();
                    setFilter(filterMap[index]);
                }
            }
        });
    }
    
    /**
     * Schedule search with debouncing
     */
    private function scheduleSearch(query: String): Void {
        clearSearchTimer();
        
        searchTimer = js.Browser.window.setTimeout(function() {
            executeSearch(query);
        }, searchDelay);
    }
    
    /**
     * Clear the search timer
     */
    private function clearSearchTimer(): Void {
        if (searchTimer != -1) {
            js.Browser.window.clearTimeout(searchTimer);
            searchTimer = -1;
        }
    }
    
    /**
     * Execute the search
     */
    private function executeSearch(query: String): Void {
        // Save search query
        LocalStorage.setString("todo_search_query", query);
        
        // Push event to LiveView
        pushEventIfAvailable("search_todos", {query: query});
        
        // Update URL if supported
        updateURL(query);
    }
    
    /**
     * Clear search input and results
     */
    private function clearSearch(input: InputElement): Void {
        input.value = "";
        executeSearch("");
        input.blur();
    }
    
    /**
     * Focus the search input
     */
    private function focusSearch(): Void {
        var searchInput = el.querySelector("input[type='text']");
        if (searchInput != null) {
            searchInput.focus();
        }
    }
    
    /**
     * Set active filter
     */
    private function setFilter(filter: String): Void {
        // Find and click the appropriate filter button
        var button = el.querySelector('[phx-value-filter="$filter"]');
        if (button != null) {
            button.click();
        }
    }
    
    /**
     * Save filter state to localStorage
     */
    private function saveFilterState(filter: String): Void {
        LocalStorage.setString("todo_filter", filter);
        LocalStorage.setNumber("todo_filter_timestamp", Date.now().getTime());
    }
    
    /**
     * Restore filter state from localStorage
     */
    private function restoreFilterState(): Void {
        var savedFilter = LocalStorage.getString("todo_filter");
        var timestamp = LocalStorage.getNumber("todo_filter_timestamp");
        
        // Only restore if recent (within last hour)
        var now = Date.now().getTime();
        var maxAge = 60 * 60 * 1000; // 1 hour
        
        if (savedFilter != null && (now - timestamp) < maxAge) {
            // Set the saved filter if different from current
            var currentFilter = getCurrentFilter();
            if (currentFilter != savedFilter) {
                setFilter(savedFilter);
            }
        }
        
        // Restore search query
        var savedQuery = LocalStorage.getString("todo_search_query", "");
        var searchInput = el.querySelector("input[type='text']");
        if (searchInput != null && savedQuery != "") {
            var input: InputElement = cast searchInput;
            input.value = savedQuery;
        }
    }
    
    /**
     * Get current active filter
     */
    private function getCurrentFilter(): String {
        var activeButton = el.querySelector(".bg-blue-500, [data-active='true']");
        if (activeButton != null) {
            return activeButton.getAttribute("phx-value-filter") ?? "all";
        }
        return "all";
    }
    
    /**
     * Update active button styling
     */
    private function updateActiveButton(clickedButton: Element): Void {
        // Remove active styling from all buttons
        var allButtons = el.querySelectorAll("[phx-click='filter_todos']");
        for (i in 0...allButtons.length) {
            var button = allButtons[i];
            cast(button, js.html.Element).classList.remove("bg-blue-500", "text-white");
            cast(button, js.html.Element).classList.add("bg-white", "text-gray-700");
            cast(button, js.html.Element).setAttribute("data-active", "false");
        }
        
        // Add active styling to clicked button
        clickedButton.classList.remove("bg-white", "text-gray-700");
        clickedButton.classList.add("bg-blue-500", "text-white");
        clickedButton.setAttribute("data-active", "true");
    }
    
    /**
     * Update search placeholder based on current filter
     */
    private function updateSearchPlaceholder(input: InputElement): Void {
        var currentFilter = getCurrentFilter();
        var placeholders = [
            "all" => "Search all todos...",
            "active" => "Search active todos...",
            "completed" => "Search completed todos..."
        ];
        
        input.placeholder = placeholders[currentFilter] ?? "Search todos...";
    }
    
    /**
     * Check if this component is currently active/visible
     */
    private function isComponentActive(): Bool {
        return el.offsetParent != null; // Simple visibility check
    }
    
    /**
     * Update URL with search/filter state (if browser supports history API)
     */
    private function updateURL(query: String): Void {
        if (js.Browser.window.history != null && js.Browser.window.history.pushState != null) {
            try {
                var url = new js.html.URL(js.Browser.window.location.href);
                
                if (query != "") {
                    url.searchParams.set("search", query);
                } else {
                    url.searchParams.delete("search");
                }
                
                js.Browser.window.history.replaceState(null, "", url.href);
            } catch (e: Dynamic) {
                // Silently fail if URL manipulation is not supported
                trace('Could not update URL: $e');
            }
        }
    }
    
    /**
     * Push event to LiveView if available
     */
    private function pushEventIfAvailable(event: String, payload: Dynamic): Void {
        try {
            var pushEvent = Reflect.field(this, "pushEvent");
            if (pushEvent != null && Reflect.isFunction(pushEvent)) {
                pushEvent(event, payload);
            }
        } catch (e: Dynamic) {
            trace('Could not push event ${event}: ${e}');
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/hooks/TodoForm.hx">
package client.hooks;

import js.html.Element;
import js.html.FormElement;
import js.html.InputElement;
import js.html.TextAreaElement;
import js.html.KeyboardEvent;
import client.extern.Phoenix.LiveViewHook;
import client.utils.LocalStorage;

/**
 * TodoForm hook for enhanced form interactions
 * Handles auto-save, keyboard shortcuts, and form validation
 */
class TodoForm implements LiveViewHook {
    
    public var el: Element;
    
    private var autoSaveTimer: Int = -1;
    private var autoSaveDelay: Int = 1000; // 1 second
    
    public function new() {}
    
    /**
     * Set up form enhancements when mounted
     */
    public function mounted(): Void {
        if (!Std.isOfType(el, FormElement)) {
            trace("TodoForm hook must be attached to a form element");
            return;
        }
        
        setupKeyboardShortcuts();
        setupAutoSave();
        setupFormValidation();
        restoreFormData();
    }
    
    /**
     * Clean up when destroyed
     */
    public function destroyed(): Void {
        clearAutoSaveTimer();
        clearFormData();
    }
    
    /**
     * Set up keyboard shortcuts for the form
     */
    private function setupKeyboardShortcuts(): Void {
        var form: FormElement = cast el;
        
        form.addEventListener("keydown", function(e: KeyboardEvent) {
            // Ctrl/Cmd + Enter: Submit form
            if ((e.ctrlKey || e.metaKey) && e.key == "Enter") {
                e.preventDefault();
                submitForm();
            }
            
            // Escape: Clear form or cancel edit
            if (e.key == "Escape") {
                e.preventDefault();
                clearForm();
                pushEventIfAvailable("cancel_edit", {});
            }
            
            // Ctrl/Cmd + S: Save draft
            if ((e.ctrlKey || e.metaKey) && e.key == "s") {
                e.preventDefault();
                saveDraft();
            }
        });
    }
    
    /**
     * Set up auto-save functionality
     */
    private function setupAutoSave(): Void {
        var inputs = el.querySelectorAll("input, textarea, select");
        
        for (i in 0...inputs.length) {
            var input = inputs[i];
            
            input.addEventListener("input", function(e) {
                scheduleAutoSave();
            });
            
            input.addEventListener("change", function(e) {
                scheduleAutoSave();
            });
        }
    }
    
    /**
     * Set up form validation enhancements
     */
    private function setupFormValidation(): Void {
        var form: FormElement = cast el;
        
        form.addEventListener("submit", function(e) {
            if (!validateForm()) {
                e.preventDefault();
                showValidationErrors();
            }
        });
        
        // Real-time validation on blur
        var inputs = el.querySelectorAll("input[required], textarea[required]");
        for (i in 0...inputs.length) {
            var input = inputs[i];
            input.addEventListener("blur", function(e) {
                validateField(cast e.target);
            });
        }
    }
    
    /**
     * Schedule auto-save with debouncing
     */
    private function scheduleAutoSave(): Void {
        clearAutoSaveTimer();
        
        // Only auto-save if enabled in settings
        if (!LocalStorage.getBoolean("autoSave", true)) return;
        
        autoSaveTimer = js.Browser.window.setTimeout(function() {
            saveDraft();
        }, autoSaveDelay);
    }
    
    /**
     * Clear the auto-save timer
     */
    private function clearAutoSaveTimer(): Void {
        if (autoSaveTimer != -1) {
            js.Browser.window.clearTimeout(autoSaveTimer);
            autoSaveTimer = -1;
        }
    }
    
    /**
     * Save form data as draft
     */
    private function saveDraft(): Void {
        var formData = getFormData();
        var formId = el.getAttribute("id") ?? "default_form";
        
        LocalStorage.setObject('form_draft_${formId}', {
            data: formData,
            timestamp: Date.now().getTime()
        });
        
        // Visual feedback for auto-save
        showSaveIndicator();
    }
    
    /**
     * Restore form data from draft
     */
    private function restoreFormData(): Void {
        var formId = el.getAttribute("id") ?? "default_form";
        var draft = LocalStorage.getObject('form_draft_${formId}');
        
        if (draft != null && draft.data != null) {
            // Check if draft is recent (within 24 hours)
            var now = Date.now().getTime();
            var age = now - draft.timestamp;
            var maxAge = 24 * 60 * 60 * 1000; // 24 hours
            
            if (age < maxAge) {
                setFormData(draft.data);
                showDraftRestoredIndicator();
            } else {
                // Clean up old draft
                clearFormData();
            }
        }
    }
    
    /**
     * Get form data as an object
     */
    private function getFormData(): Dynamic {
        var form: FormElement = cast el;
        var formData = new js.html.FormData(form);
        var data = {};
        
        // Convert FormData to plain object
        untyped __js__("
            for (let [key, value] of formData.entries()) {
                data[key] = value;
            }
        ");
        
        return data;
    }
    
    /**
     * Set form data from an object
     */
    private function setFormData(data: Dynamic): Void {
        for (field in Reflect.fields(data)) {
            var value = Reflect.field(data, field);
            var input = el.querySelector('[name="$field"]');
            
            if (input != null) {
                if (Std.isOfType(input, InputElement)) {
                    var inputEl: InputElement = cast input;
                    inputEl.value = Std.string(value);
                } else if (Std.isOfType(input, TextAreaElement)) {
                    var textareaEl: TextAreaElement = cast input;
                    textareaEl.value = Std.string(value);
                }
            }
        }
    }
    
    /**
     * Validate the entire form
     */
    private function validateForm(): Bool {
        var form: FormElement = cast el;
        var isValid = true;
        
        var requiredInputs = el.querySelectorAll("input[required], textarea[required]");
        for (i in 0...requiredInputs.length) {
            var input = requiredInputs[i];
            if (!validateField(cast input)) {
                isValid = false;
            }
        }
        
        return isValid;
    }
    
    /**
     * Validate a single field
     */
    private function validateField(input: Element): Bool {
        var isValid = true;
        
        if (Std.isOfType(input, InputElement)) {
            var inputEl: InputElement = cast input;
            
            // Check required
            if (inputEl.required && StringTools.trim(inputEl.value) == "") {
                showFieldError(inputEl, "This field is required");
                isValid = false;
            } else {
                clearFieldError(inputEl);
            }
        }
        
        return isValid;
    }
    
    /**
     * Show validation error for a field
     */
    private function showFieldError(input: InputElement, message: String): Void {
        input.classList.add("border-red-500", "focus:border-red-500");
        input.classList.remove("border-gray-300", "focus:border-blue-500");
        
        // Find or create error message element
        var errorId = '${input.name}_error';
        var existingError = js.Browser.document.getElementById(errorId);
        
        if (existingError == null) {
            var errorEl = js.Browser.document.createDivElement();
            errorEl.id = errorId;
            errorEl.className = "text-red-500 text-sm mt-1";
            errorEl.textContent = message;
            input.parentElement.appendChild(errorEl);
        } else {
            existingError.textContent = message;
        }
    }
    
    /**
     * Clear validation error for a field
     */
    private function clearFieldError(input: InputElement): Void {
        input.classList.remove("border-red-500", "focus:border-red-500");
        input.classList.add("border-gray-300", "focus:border-blue-500");
        
        var errorId = '${input.name}_error';
        var errorEl = js.Browser.document.getElementById(errorId);
        if (errorEl != null) {
            errorEl.remove();
        }
    }
    
    /**
     * Submit the form
     */
    private function submitForm(): Void {
        var form: FormElement = cast el;
        if (validateForm()) {
            form.submit();
            clearFormData(); // Clear draft after successful submit
        }
    }
    
    /**
     * Clear the form
     */
    private function clearForm(): Void {
        var form: FormElement = cast el;
        form.reset();
        clearFormData();
    }
    
    /**
     * Clear saved form data
     */
    private function clearFormData(): Void {
        var formId = el.getAttribute("id") ?? "default_form";
        LocalStorage.remove('form_draft_${formId}');
    }
    
    /**
     * Show visual indicator for auto-save
     */
    private function showSaveIndicator(): Void {
        // Implementation would show a subtle "saved" indicator
        // For now, just log it
        trace("Form auto-saved");
    }
    
    /**
     * Show indicator that draft was restored
     */
    private function showDraftRestoredIndicator(): Void {
        // Implementation would show "draft restored" message
        trace("Form draft restored");
    }
    
    /**
     * Show validation errors
     */
    private function showValidationErrors(): Void {
        // Focus on first invalid field
        var firstInvalid = el.querySelector(".border-red-500");
        if (firstInvalid != null) {
            firstInvalid.focus();
        }
    }
    
    /**
     * Push event to LiveView if available
     */
    private function pushEventIfAvailable(event: String, payload: Dynamic): Void {
        try {
            var pushEvent = Reflect.field(this, "pushEvent");
            if (pushEvent != null && Reflect.isFunction(pushEvent)) {
                pushEvent(event, payload);
            }
        } catch (e: Dynamic) {
            trace('Could not push event ${event}: ${e}');
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/utils/DarkMode.hx">
package client.utils;

import js.Browser;
import js.html.Element;

/**
 * Dark mode management utility
 * Handles theme detection, toggling, and persistence
 */
class DarkMode {
    
    private static inline var THEME_KEY = "theme";
    private static inline var DARK_CLASS = "dark";
    
    /**
     * Initialize dark mode system
     */
    public static function initialize(): Void {
        // Apply saved theme or system preference immediately
        applyTheme();
        
        // Set up theme toggle button if present
        setupToggleButton();
    }
    
    /**
     * Check if dark mode is currently enabled
     */
    public static function isEnabled(): Bool {
        return Browser.document.documentElement.classList.contains(DARK_CLASS);
    }
    
    /**
     * Toggle between light and dark mode
     */
    public static function toggle(): Void {
        if (isEnabled()) {
            setLightMode();
        } else {
            setDarkMode();
        }
    }
    
    /**
     * Enable dark mode
     */
    public static function setDarkMode(): Void {
        Browser.document.documentElement.classList.add(DARK_CLASS);
        LocalStorage.setString(THEME_KEY, "dark");
        updateToggleButton();
    }
    
    /**
     * Enable light mode
     */
    public static function setLightMode(): Void {
        Browser.document.documentElement.classList.remove(DARK_CLASS);
        LocalStorage.setString(THEME_KEY, "light");
        updateToggleButton();
    }
    
    /**
     * Get the current theme preference
     */
    public static function getTheme(): String {
        var saved = LocalStorage.getString(THEME_KEY);
        if (saved != null) return saved;
        
        // Check system preference
        if (Browser.window.matchMedia != null) {
            var darkMediaQuery = Browser.window.matchMedia("(prefers-color-scheme: dark)");
            return darkMediaQuery.matches ? "dark" : "light";
        }
        
        return "light";
    }
    
    /**
     * Apply the theme based on saved preference or system setting
     */
    private static function applyTheme(): Void {
        if (getTheme() == "dark") {
            Browser.document.documentElement.classList.add(DARK_CLASS);
        } else {
            Browser.document.documentElement.classList.remove(DARK_CLASS);
        }
    }
    
    /**
     * Set up the theme toggle button functionality
     */
    private static function setupToggleButton(): Void {
        var toggleButton = Browser.document.getElementById("theme-toggle");
        if (toggleButton == null) return;
        
        toggleButton.addEventListener("click", function(e) {
            e.preventDefault();
            toggle();
        });
        
        updateToggleButton();
    }
    
    /**
     * Update the toggle button icons based on current theme
     */
    private static function updateToggleButton(): Void {
        var darkIcon = Browser.document.getElementById("theme-toggle-dark-icon");
        var lightIcon = Browser.document.getElementById("theme-toggle-light-icon");
        
        if (darkIcon == null || lightIcon == null) return;
        
        if (isEnabled()) {
            // Dark mode is active, show light icon (to switch to light)
            darkIcon.classList.add("hidden");
            lightIcon.classList.remove("hidden");
        } else {
            // Light mode is active, show dark icon (to switch to dark)
            darkIcon.classList.remove("hidden");
            lightIcon.classList.add("hidden");
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/utils/LocalStorage.hx">
package client.utils;

import js.Browser;
import js.html.Storage;

/**
 * Type-safe localStorage utility wrapper around js.Browser.getLocalStorage()
 * 
 * Provides convenient methods for storing and retrieving data with
 * proper error handling and type conversions.
 * 
 * Uses Haxe's built-in js.html.Storage API for maximum compatibility
 * and type safety.
 */
class LocalStorage {
    
    private static var storage: Null<Storage> = Browser.getLocalStorage();
    
    /**
     * Initialize localStorage utilities
     */
    public static function initialize(): Void {
        // Check if localStorage is available
        if (!isAvailable()) {
            trace("Warning: localStorage is not available");
        }
    }
    
    /**
     * Check if localStorage is available in the browser
     */
    public static function isAvailable(): Bool {
        try {
            var test = "test";
            storage.setItem(test, test);
            storage.removeItem(test);
            return true;
        } catch (e: Dynamic) {
            return false;
        }
    }
    
    /**
     * Store a string value
     */
    public static function setString(key: String, value: String): Void {
        if (!isAvailable()) return;
        
        try {
            storage.setItem(key, value);
        } catch (e: Dynamic) {
            trace('Failed to store string in localStorage: $e');
        }
    }
    
    /**
     * Retrieve a string value
     */
    public static function getString(key: String, ?defaultValue: String): Null<String> {
        if (!isAvailable()) return defaultValue;
        
        try {
            var value = storage.getItem(key);
            return value != null ? value : defaultValue;
        } catch (e: Dynamic) {
            trace('Failed to retrieve string from localStorage: $e');
            return defaultValue;
        }
    }
    
    /**
     * Store a boolean value
     */
    public static function setBoolean(key: String, value: Bool): Void {
        setString(key, value ? "true" : "false");
    }
    
    /**
     * Retrieve a boolean value
     */
    public static function getBoolean(key: String, defaultValue: Bool = false): Bool {
        var value = getString(key);
        if (value == null) return defaultValue;
        
        return value == "true";
    }
    
    /**
     * Store a number value
     */
    public static function setNumber(key: String, value: Float): Void {
        setString(key, Std.string(value));
    }
    
    /**
     * Retrieve a number value
     */
    public static function getNumber(key: String, defaultValue: Float = 0): Float {
        var value = getString(key);
        if (value == null) return defaultValue;
        
        var parsed = Std.parseFloat(value);
        return Math.isNaN(parsed) ? defaultValue : parsed;
    }
    
    /**
     * Store an object as JSON
     */
    public static function setObject(key: String, value: Dynamic): Void {
        try {
            var json = haxe.Json.stringify(value);
            setString(key, json);
        } catch (e: Dynamic) {
            trace('Failed to store object in localStorage: $e');
        }
    }
    
    /**
     * Retrieve an object from JSON
     */
    public static function getObject(key: String, ?defaultValue: Dynamic): Dynamic {
        var value = getString(key);
        if (value == null) return defaultValue;
        
        try {
            return haxe.Json.parse(value);
        } catch (e: Dynamic) {
            trace('Failed to parse object from localStorage: $e');
            return defaultValue;
        }
    }
    
    /**
     * Remove a value from localStorage
     */
    public static function remove(key: String): Void {
        if (!isAvailable()) return;
        
        try {
            storage.removeItem(key);
        } catch (e: Dynamic) {
            trace('Failed to remove item from localStorage: $e');
        }
    }
    
    /**
     * Remove a value from localStorage (alias for remove)
     * This method provides compatibility with common localStorage usage patterns
     */
    public static function removeItem(key: String): Void {
        remove(key);
    }
    
    /**
     * Clear all localStorage data
     */
    public static function clear(): Void {
        if (!isAvailable()) return;
        
        try {
            storage.clear();
        } catch (e: Dynamic) {
            trace('Failed to clear localStorage: $e');
        }
    }
    
    /**
     * Get all keys in localStorage
     */
    public static function getAllKeys(): Array<String> {
        if (!isAvailable()) return [];
        
        var keys = [];
        try {
            for (i in 0...storage.length) {
                var key = storage.key(i);
                if (key != null) keys.push(key);
            }
        } catch (e: Dynamic) {
            trace('Failed to get localStorage keys: $e');
        }
        
        return keys;
    }
    
    /**
     * Get the total size of localStorage in bytes (approximate)
     */
    public static function getUsedSpace(): Int {
        var total = 0;
        for (key in getAllKeys()) {
            var value = getString(key, "");
            total += key.length + value.length;
        }
        return total;
    }
}
</file>

<file path="examples/todo-app/src_haxe/client/Boot.hx">
package client;

// Phoenix Hook type with only the callbacks we use
typedef PhoenixHook = {
  var mounted: Void->Void;
}

// Typed Hooks registry shape
typedef Hooks = {
  var AutoFocus: PhoenixHook;
  var Ping: PhoenixHook;
}

/**
 * Minimal, typed Phoenix LiveView hook registry for bootstrapping interactivity.
 * Avoids Dynamic on public surfaces per No‚ÄëDynamic policy; uses inline JS only
 * at the boundary to call into the LiveView hook context (this.*).
 */
class Boot {
  public static function main() {
    var hooks: Hooks = {
      AutoFocus: {
        mounted: function(): Void {
          // Focus element if possible (boundary call to hook context)
          js.Syntax.code("this.el && this.el.focus && this.el.focus()");
        }
      },
      Ping: {
        mounted: function(): Void {
          // Validate pushEvent wiring once on mount (non-blocking)
          js.Syntax.code("try { this.pushEvent && this.pushEvent('ping', {}) } catch (_) {} ");
        }
      }
    };

    // Publish hooks for phoenix_app.js to pick up
    js.Syntax.code("window.Hooks = window.Hooks || {0}", hooks);
  }
}
</file>

<file path="examples/todo-app/src_haxe/client/TodoApp.hx">
package client;

import shared.TodoTypes;
import reflaxe.js.Async;
import client.hooks.Hooks;
import client.utils.DarkMode;
import client.utils.LocalStorage;
// genes async/await support

/**
 * Main client-side entry point for Todo App
 * Compiles to JavaScript and integrates with Phoenix LiveView
 * 
 * This provides a clean, modular architecture for client-side functionality
 * while maintaining type safety throughout the application.
 */
@:build(reflaxe.js.Async.build())
class TodoApp {
    
    private static var isInitialized: Bool = false;
    
    /**
     * Application entry point
     * Called when the JavaScript loads in the browser
     */
    @:expose
    public static function main(): Void {
        if (isInitialized) {
            trace("TodoApp already initialized");
            return;
        }
        
        trace("Todo App client initializing...");
        
        // Initialize client-side utilities
        initializeUtilities();
        
        // Set up global error handling
        setupGlobalErrorHandling();
        
        // Export hooks for Phoenix LiveView
        exportHooks();
        
        // Initialize UI enhancements
        initializeEnhancements();
        
        isInitialized = true;
        trace("Todo App client ready!");
    }
    
    /**
     * Initialize client-side utilities
     */
    private static function initializeUtilities(): Void {
        DarkMode.initialize();
        LocalStorage.initialize();
    }
    
    /**
     * Set up global error handling for the client
     */
    private static function setupGlobalErrorHandling(): Void {
        js.Browser.window.addEventListener("error", function(event) {
            trace('Client error: ${event.error}');
            // Log error asynchronously (fire and forget)
            js.Syntax.code("(async () => {
                try {
                    await {0}('javascript_error', {
                        message: {1},
                        filename: {2},
                        lineno: {3},
                        colno: {4},
                        timestamp: Date.now()
                    });
                } catch (e) {
                    console.warn('Failed to log error:', e);
                }
            })()", logErrorToServerAsync, event.message, event.filename, event.lineno, event.colno);
        });
        
        js.Browser.window.addEventListener("unhandledrejection", function(event) {
            trace('Unhandled promise rejection: ${event.reason}');
            // Log promise rejection asynchronously (fire and forget)
            js.Syntax.code("(async () => {
                try {
                    await {0}('promise_rejection', {
                        reason: {1},
                        timestamp: Date.now()
                    });
                } catch (e) {
                    console.warn('Failed to log promise rejection:', e);
                }
            })()", logErrorToServerAsync, Std.string(event.reason));
        });
    }
    
    /**
     * Export hooks for Phoenix LiveView to use
     * This makes our Haxe hooks available to the Phoenix JavaScript runtime
     */
    private static function exportHooks(): Void {
        var hooks = Hooks.getAll();
        
        // Export to global scope for Phoenix LiveView using modern js.Syntax.code
        js.Syntax.code("
            // Make hooks available globally
            if (typeof window !== 'undefined') {
                window.TodoAppHooks = {0};
                
                // Also export individual hooks for direct access
                window.AutoFocus = {1};
                window.ThemeToggle = {2};
                window.TodoForm = {3};
                window.TodoFilter = {4};
                window.LiveSync = {5};
            }
            
            // Export as ES6 module
            if (typeof module !== 'undefined' && module.exports) {
                module.exports = {
                    Hooks: {0},
                    AutoFocus: {1},
                    ThemeToggle: {2},
                    TodoForm: {3},
                    TodoFilter: {4},
                    LiveSync: {5}
                };
            }
        ", 
            hooks,
            Hooks.getAutoFocus(),
            Hooks.getThemeToggle(),
            Hooks.getTodoForm(),
            Hooks.getTodoFilter(),
            Hooks.getLiveSync()
        );
        
        trace("Phoenix LiveView hooks exported successfully");
    }
    
    /**
     * Initialize UI enhancements and additional features
     */
    private static function initializeEnhancements(): Void {
        // Set up keyboard shortcuts
        setupGlobalKeyboardShortcuts();
        
        // Initialize performance monitoring
        setupPerformanceMonitoring();
        
        // Add CSS enhancements
        addDynamicStyles();
        
        // Initialize accessibility features
        setupAccessibilityFeatures();
    }
    
    /**
     * Set up global keyboard shortcuts
     */
    private static function setupGlobalKeyboardShortcuts(): Void {
        js.Browser.document.addEventListener("keydown", function(e: js.html.KeyboardEvent) {
            // Only handle shortcuts if not in input/textarea (type-safe casting)
            var target = e.target;
            if (target != null && js.Syntax.instanceof(target, js.html.Element)) {
                var element = cast(target, js.html.Element);
                if (element.nodeName == "INPUT" || element.nodeName == "TEXTAREA") {
                    return;
                }
            }
            
            // Global shortcuts
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case "k": // Cmd/Ctrl + K: Quick search
                        e.preventDefault();
                        focusSearch();
                    
                    case "n": // Cmd/Ctrl + N: New todo
                        e.preventDefault();
                        triggerNewTodo();
                    
                    case "/": // Cmd/Ctrl + /: Show keyboard shortcuts
                        e.preventDefault();
                        showKeyboardShortcuts();
                }
            }
            
            // Other shortcuts
            switch (e.key) {
                case "?": // Show help
                    if (e.shiftKey) {
                        e.preventDefault();
                        showKeyboardShortcuts();
                    }
            }
        });
    }
    
    /**
     * Set up performance monitoring with async/await for cleaner error handling
     */
    private static function setupPerformanceMonitoring(): Void {
        // Monitor page load performance using modern PerformanceNavigationTiming API
        js.Browser.window.addEventListener("load", function() {
            // Use async IIFE to handle performance measurement with proper error handling
            js.Syntax.code("(async () => {
                try {
                    await {0}();
                } catch (error) {
                    console.error('Performance monitoring failed:', error);
                }
            })()", measurePagePerformance);
        });
        
        // Monitor LiveView connection time
        monitorLiveViewPerformance();
    }
    
    /**
     * Async function to measure page performance and log metrics
     */
    @:async
    private static function measurePagePerformance(): js.lib.Promise<Void> {
        if (js.Browser.window.performance == null) {
            return js.lib.Promise.resolve();
        }
        
        // Use modern PerformanceNavigationTiming API instead of deprecated timing
        var entries = js.Browser.window.performance.getEntriesByType("navigation");
        if (entries.length == 0) {
            // Fallback for browsers that don't support PerformanceNavigationTiming
            trace("PerformanceNavigationTiming not supported, using basic measurement");
            return js.lib.Promise.resolve();
        }
        
        var navTiming: js.html.PerformanceNavigationTiming = cast entries[0];
        var domLoadTime = navTiming.domContentLoadedEventEnd - navTiming.domContentLoadedEventStart;
        var fullLoadTime = navTiming.loadEventEnd - navTiming.fetchStart;
        
        trace('DOM load time: ${domLoadTime}ms, Full page load: ${fullLoadTime}ms');
        
        // Log metrics asynchronously with proper error handling
        logMetricToServerAsync("dom_load_time", domLoadTime);
        logMetricToServerAsync("page_load_time", fullLoadTime);
        
        // Log additional performance metrics
        var resourceLoadTime = navTiming.loadEventEnd - navTiming.domContentLoadedEventEnd;
        if (resourceLoadTime > 0) {
            logMetricToServerAsync("resource_load_time", resourceLoadTime);
        }
        
        // Check for performance issues and report them
        if (fullLoadTime > 3000) { // Slow page load > 3 seconds
            logErrorToServerAsync("performance_warning", {
                type: "slow_page_load",
                load_time: fullLoadTime,
                threshold: 3000
            });
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Add dynamic CSS styles for enhancements
     */
    private static function addDynamicStyles(): Void {
        var style = js.Browser.document.createStyleElement();
        style.textContent = '
            /* Todo App Enhanced Styles */
            .todo-item {
                transition: all 0.2s ease;
            }
            
            .todo-item:hover {
                transform: translateX(2px);
            }
            
            .updated-highlight {
                background: rgba(59, 130, 246, 0.1);
                border-left: 3px solid #3B82F6;
                animation: highlightFade 2s ease-out;
            }
            
            @keyframes highlightFade {
                from { 
                    background: rgba(59, 130, 246, 0.3);
                    transform: scale(1.01);
                }
                to { 
                    background: rgba(59, 130, 246, 0.1);
                    transform: scale(1);
                }
            }
            
            .theme-toggle-clicked {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
            
            .connection-status {
                font-size: 0.75rem;
                color: #6B7280;
            }
            
            .connection-status.online {
                color: #10B981;
            }
            
            .connection-status.offline {
                color: #EF4444;
            }
            
            /* Keyboard shortcuts overlay */
            .keyboard-shortcuts-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .keyboard-shortcuts-panel {
                background: white;
                dark:bg-gray-800;
                border-radius: 0.5rem;
                padding: 2rem;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
            }
        ';
        js.Browser.document.head.appendChild(style);
    }
    
    /**
     * Set up accessibility features
     */
    private static function setupAccessibilityFeatures(): Void {
        // Add skip links for keyboard navigation
        addSkipLinks();
        
        // Enhance focus management
        setupFocusManagement();
        
        // Add ARIA live regions for status updates
        setupLiveRegions();
    }
    
    /**
     * Add skip links for accessibility
     */
    private static function addSkipLinks(): Void {
        var skipLinks = js.Browser.document.createDivElement();
        skipLinks.className = "sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 z-50";
        skipLinks.innerHTML = '
            <a href="#main-content" class="bg-blue-600 text-white px-4 py-2 rounded-md">
                Skip to main content
            </a>
            <a href="#todo-form" class="bg-blue-600 text-white px-4 py-2 rounded-md ml-2">
                Skip to new todo form
            </a>
        ';
        js.Browser.document.body.insertBefore(skipLinks, js.Browser.document.body.firstChild);
    }
    
    /**
     * Set up focus management
     */
    private static function setupFocusManagement(): Void {
        // Trap focus in modals when open
        // This would be expanded based on specific modal implementations
    }
    
    /**
     * Set up ARIA live regions for status updates
     */
    private static function setupLiveRegions(): Void {
        var liveRegion = js.Browser.document.createDivElement();
        liveRegion.id = "live-region";
        liveRegion.setAttribute("aria-live", "polite");
        liveRegion.setAttribute("aria-atomic", "true");
        liveRegion.className = "sr-only";
        js.Browser.document.body.appendChild(liveRegion);
    }
    
    /**
     * Focus the search input
     */
    private static function focusSearch(): Void {
        var searchInput = js.Browser.document.querySelector('input[type="text"][placeholder*="Search"]');
        if (searchInput != null) {
            searchInput.focus();
        }
    }
    
    /**
     * Trigger new todo creation
     */
    private static function triggerNewTodo(): Void {
        var newTodoButton = js.Browser.document.querySelector('[phx-click="toggle_form"]');
        if (newTodoButton != null) {
            newTodoButton.click();
        }
    }
    
    /**
     * Show keyboard shortcuts overlay
     */
    private static function showKeyboardShortcuts(): Void {
        var overlay = js.Browser.document.querySelector(".keyboard-shortcuts-overlay");
        if (overlay != null) {
            overlay.style.display = "flex";
            return;
        }
        
        // Create shortcuts overlay
        overlay = js.Browser.document.createDivElement();
        overlay.className = "keyboard-shortcuts-overlay";
        overlay.innerHTML = '
            <div class="keyboard-shortcuts-panel">
                <h3 class="text-lg font-bold mb-4">Keyboard Shortcuts</h3>
                <div class="space-y-2 text-sm">
                    <div><kbd>Ctrl/Cmd + K</kbd> - Focus search</div>
                    <div><kbd>Ctrl/Cmd + N</kbd> - New todo</div>
                    <div><kbd>Ctrl/Cmd + /</kbd> - Show shortcuts</div>
                    <div><kbd>Alt + 1/2/3</kbd> - Filter todos</div>
                    <div><kbd>Escape</kbd> - Close forms/modals</div>
                    <div><kbd>Ctrl/Cmd + Enter</kbd> - Submit form</div>
                </div>
                <button class="mt-4 px-4 py-2 bg-gray-200 rounded close-shortcuts">Close</button>
            </div>
        ';
        
        // Add close functionality
        overlay.addEventListener("click", function(e) {
            if (e.target == overlay || e.target.classList.contains("close-shortcuts")) {
                overlay.style.display = "none";
            }
        });
        
        js.Browser.document.body.appendChild(overlay);
    }
    
    /**
     * Monitor LiveView performance
     */
    private static function monitorLiveViewPerformance(): Void {
        // This would hook into Phoenix LiveView events to monitor connection performance
        // For now, just a placeholder
        trace("LiveView performance monitoring initialized");
    }
    
    
    /**
     * Async error logging to server with retry logic and batching
     */
    @:async
    private static function logErrorToServerAsync(type: String, details: Dynamic): js.lib.Promise<Void> {
        try {
            // Store locally first as fallback
            LocalStorage.setObject('last_error_${type}', {
                type: type,
                details: details,
                timestamp: Date.now().getTime()
            });
            
            // Attempt to send to server via LiveView
            var errorData: Dynamic = {
                error_type: type,
                details: details,
                timestamp: Date.now().getTime(),
                user_agent: js.Browser.navigator.userAgent,
                url: js.Browser.location.href
            };
            sendToLiveViewAsync("error_log", errorData);
            
            trace('Error logged to server: ${type}');
            
        } catch (e: Dynamic) {
            // Server communication failed, error is already stored locally
            trace('Failed to send error to server: ${e}');
            
            // Queue for retry later
            queueForRetryAsync("error", {
                type: type,
                details: details,
                timestamp: Date.now().getTime()
            });
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Async metric logging to server with batching for performance
     */
    @:async
    private static function logMetricToServerAsync(metric: String, value: Float): js.lib.Promise<Void> {
        try {
            // Store locally first as fallback
            LocalStorage.setNumber('metric_${metric}', value);
            
            // Batch metrics for efficient server communication
            var metricData: Dynamic = {
                metric: metric,
                value: value,
                timestamp: Date.now().getTime()
            };
            addToBatchAsync("metrics", metricData);
            
            // Send batch if it's full or enough time has passed
            maybeSendBatchAsync("metrics");
            
        } catch (e: Dynamic) {
            trace('Failed to process metric: ${e}');
            // Metric is still stored locally, so we don't lose data
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Send data to Phoenix LiveView with error handling and timeout
     */
    @:async
    private static function sendToLiveViewAsync(event: String, data: Dynamic): js.lib.Promise<Void> {
        // Create a promise that resolves when LiveView responds or times out
        var promise = new js.lib.Promise(function(resolve, reject) {
            var timeout = js.Browser.window.setTimeout(function() {
                reject("LiveView communication timeout");
            }, 5000); // 5 second timeout
            
            try {
                // Simulated LiveView push - in real implementation this would use LiveView hooks
                js.Syntax.code("
                    if (window.liveSocket && window.liveSocket.channel) {
                        window.liveSocket.channel.push({0}, {1})
                            .receive('ok', (resp) => {
                                clearTimeout({2});
                                {3}(resp);
                            })
                            .receive('error', (resp) => {
                                clearTimeout({2});
                                {4}(resp);
                            });
                    } else {
                        clearTimeout({2});
                        {4}('LiveView not available');
                    }
                ", event, data, timeout, resolve, reject);
            } catch (e: Dynamic) {
                js.Browser.window.clearTimeout(timeout);
                reject(e);
            }
        });
        
        Async.await(promise);
    }
    
    /**
     * Queue data for retry when server communication fails
     */
    @:async
    private static function queueForRetryAsync(category: String, data: Dynamic): js.lib.Promise<Void> {
        var queueKey = 'retry_queue_${category}';
        var queue = LocalStorage.getObject(queueKey);
        
        if (queue == null) {
            queue = [];
        }
        
        queue.push(data);
        
        // Limit queue size to prevent memory issues
        if (queue.length > 100) {
            queue = queue.slice(-50); // Keep last 50 items
        }
        
        LocalStorage.setObject(queueKey, queue);
        
        // Schedule retry attempt
        scheduleRetryAsync(category);
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Add data to batch for efficient server communication
     */
    @:async
    private static function addToBatchAsync(batchType: String, data: Dynamic): js.lib.Promise<Void> {
        var batchKey = 'batch_${batchType}';
        var batch = LocalStorage.getObject(batchKey);
        
        if (batch == null) {
            batch = {
                items: [],
                created_at: Date.now().getTime()
            };
        }
        
        batch.items.push(data);
        LocalStorage.setObject(batchKey, batch);
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Send batch to server if conditions are met
     */
    @:async
    private static function maybeSendBatchAsync(batchType: String): js.lib.Promise<Void> {
        var batchKey = 'batch_${batchType}';
        var batch = LocalStorage.getObject(batchKey);
        
        if (batch == null || batch.items.length == 0) {
            return js.lib.Promise.resolve();
        }
        
        var shouldSend = false;
        var now = Date.now().getTime();
        
        // Send if batch is full (10 items) or old (30 seconds)
        if (batch.items.length >= 10 || (now - batch.created_at) > 30000) {
            shouldSend = true;
        }
        
        if (shouldSend) {
            try {
                sendToLiveViewAsync('batch_${batchType}', {
                    items: batch.items,
                    count: batch.items.length,
                    created_at: batch.created_at,
                    sent_at: now
                });
                
                // Clear batch after successful send
                LocalStorage.removeItem(batchKey);
                trace('Sent batch of ${batch.items.length} ${batchType} to server');
                
            } catch (e: Dynamic) {
                trace('Failed to send batch ${batchType}: ${e}');
                // Batch remains in LocalStorage for retry
            }
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Schedule retry attempt for failed communications
     */
@:async
private static function scheduleRetryAsync(category: String): js.lib.Promise<Void> {
        // Use exponential backoff: 1s, 2s, 4s, 8s, then 30s max
        var retryKey = 'retry_count_${category}';
        var retryCount = LocalStorage.getNumber(retryKey, 0);
        var delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
        
        // Defer processing by delay using a Promise so we avoid statement-level await
        return new js.lib.Promise(function(resolve, _reject) {
            js.Browser.window.setTimeout(function() {
                try {
                    processRetryQueueAsync(category);
                    // Reset retry count on success
                    LocalStorage.removeItem(retryKey);
                } catch (e: Dynamic) {
                    // Increment retry count and try again later
                    LocalStorage.setNumber(retryKey, retryCount + 1);
                    trace('Retry ${category} failed (attempt ${retryCount + 1}): ${e}');
                }
                resolve(null);
            }, Std.int(delay));
        });
    }
    
    /**
     * Process queued items for retry
     */
    @:async
    private static function processRetryQueueAsync(category: String): js.lib.Promise<Void> {
        var queueKey = 'retry_queue_${category}';
        var queue = LocalStorage.getObject(queueKey);
        
        if (queue == null || queue.length == 0) {
            return js.lib.Promise.resolve();
        }
        
        // Process items in batch
        sendToLiveViewAsync('retry_${category}', {
            items: queue,
            count: queue.length,
            retry_timestamp: Date.now().getTime()
        });
        
        // Clear queue after successful send
        LocalStorage.removeItem(queueKey);
        trace('Successfully sent ${queue.length} queued ${category} items');
        
        return js.lib.Promise.resolve();
    }

    /**
     * Sleep utility returning a Promise that resolves after ms
     */
    private static function sleep(ms:Int): js.lib.Promise<Void> {
        return new js.lib.Promise(function(resolve, _reject) {
            js.Browser.window.setTimeout(function() resolve(null), ms);
        });
    }
    
    // Async Data Fetching Utilities
    
    /**
     * Fetch todos from server with proper error handling and caching
     */
    @:async
    public static function fetchTodosAsync(): js.lib.Promise<Array<Dynamic>> {
        try {
            // Check cache first (5 minute expiry)
            var cacheKey = "todos_cache";
            var cacheData = LocalStorage.getObject(cacheKey);
            var now = Date.now().getTime();
            
            if (cacheData != null && (now - cacheData.timestamp) < 300000) { // 5 minutes
                trace("Returning cached todos");
                return cacheData.todos;
            }
            
            // Fetch from server
            var response = Async.await(fetchFromAPIAsync("/api/todos", "GET"));
            var todos: Array<Dynamic> = response.data;
            
            // Cache the result
            LocalStorage.setObject(cacheKey, {
                todos: todos,
                timestamp: now
            });
            
            trace('Fetched ${todos.length} todos from server');
            return todos;
            
        } catch (e: Dynamic) {
            trace('Failed to fetch todos: ${e}');
            
            // Return cached data as fallback, even if expired
            var fallbackData: Dynamic = LocalStorage.getObject("todos_cache");
            if (fallbackData != null) {
                trace("Returning stale cached todos as fallback");
                return fallbackData.todos;
            }
            
            // Return empty array if no cache available
            return [];
        }
    }
    
    /**
     * Create a new todo on the server
     */
    @:async
    public static function createTodoAsync(title: String, ?description: String, ?priority: String): js.lib.Promise<Dynamic> {
        try {
            var todoData = {
                title: title,
                description: description ?? "",
                priority: priority ?? "medium",
                completed: false
            };
            
            var response = Async.await(fetchFromAPIAsync("/api/todos", "POST", todoData));
            
            // Invalidate cache after successful creation
            LocalStorage.removeItem("todos_cache");
            
            // Log successful creation
            logMetricToServerAsync("todo_created", 1);
            
            trace('Created todo: ${title}');
            return response.data;
            
        } catch (e: Dynamic) {
            trace('Failed to create todo: ${e}');
            
            // Log error
            logErrorToServerAsync("todo_creation_failed", {
                title: title,
                error: Std.string(e)
            });
            
            throw e; // Re-throw to let caller handle it
        }
    }
    
    /**
     * Update an existing todo on the server
     */
    @:async
    public static function updateTodoAsync(id: Int, updates: Dynamic): js.lib.Promise<Dynamic> {
        try {
            var response = Async.await(fetchFromAPIAsync('/api/todos/${id}', "PUT", updates));
            
            // Invalidate cache after successful update
            LocalStorage.removeItem("todos_cache");
            
            // Log successful update
            logMetricToServerAsync("todo_updated", 1);
            
            trace('Updated todo ${id}');
            return response.data;
            
        } catch (e: Dynamic) {
            trace('Failed to update todo ${id}: ${e}');
            
            // Log error
            logErrorToServerAsync("todo_update_failed", {
                todo_id: id,
                updates: updates,
                error: Std.string(e)
            });
            
            throw e;
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Delete a todo from the server
     */
    @:async
    public static function deleteTodoAsync(id: Int): js.lib.Promise<Void> {
        try {
            Async.await(fetchFromAPIAsync('/api/todos/${id}', "DELETE"));
            
            // Invalidate cache after successful deletion
            LocalStorage.removeItem("todos_cache");
            
            // Log successful deletion
            logMetricToServerAsync("todo_deleted", 1);
            
            trace('Deleted todo ${id}');
            
        } catch (e: Dynamic) {
            trace('Failed to delete todo ${id}: ${e}');
            
            // Log error
            logErrorToServerAsync("todo_deletion_failed", {
                todo_id: id,
                error: Std.string(e)
            });
            
            throw e;
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Sync local changes with server
     */
    @:async
    public static function syncWithServerAsync(): js.lib.Promise<Void> {
        try {
            trace("Starting server sync...");
            
            // Process any queued offline changes
            Async.await(processOfflineChangesAsync());
            
            // Fetch latest data from server
            var serverTodos = Async.await(fetchTodosAsync());
            
            // Update local state (this would typically trigger UI updates)
            announceStatus('Synced ${serverTodos.length} todos with server');
            
            // Log successful sync
            logMetricToServerAsync("sync_completed", 1);
            
            trace("Server sync completed successfully");
            
        } catch (e: Dynamic) {
            trace('Server sync failed: ${e}');
            
            // Log sync failure
            logErrorToServerAsync("sync_failed", {
                error: Std.string(e),
                timestamp: Date.now().getTime()
            });
            
            announceStatus("Sync failed - working offline");
        }
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Generic API fetch utility with retry logic and proper error handling
     */
    @:async
    private static function fetchFromAPIAsync(url: String, method: String, ?data: Dynamic): js.lib.Promise<Dynamic> {
        var maxRetries = 3;
        var retryDelay = 1000; // Start with 1 second
        
        for (attempt in 0...maxRetries) {
            try {
                var requestOptions: Dynamic = {
                    method: method,
                    headers: {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    }
                };
                
                if (data != null && (method == "POST" || method == "PUT" || method == "PATCH")) {
                    requestOptions.body = haxe.Json.stringify(data);
                }
                
                // Create Promise for fetch request
                var promise = new js.lib.Promise(function(resolve, reject) {
                    js.Syntax.code("
                        fetch({0}, {1})
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(data => {2}({
                                data: data,
                                status: 'success'
                            }))
                            .catch(error => {3}(error));
                    ", url, requestOptions, resolve, reject);
                });
                
                var response = Async.await(promise);
                return response;
                
            } catch (e: Dynamic) {
                if (attempt == maxRetries - 1) {
                    // Last attempt failed, throw error
                    throw e;
                }
                
                // Wait before retry with exponential backoff (non-blocking schedule)
                trace('API request failed (attempt ${attempt + 1}/${maxRetries}): ${e}');
                retryDelay *= 2; // Exponential backoff
            }
        }
        
        throw "API request failed after all retries";
    }
    
    /**
     * Process any offline changes that haven't been synced
     */
    @:async
    private static function processOfflineChangesAsync(): js.lib.Promise<Void> {
        var offlineChanges = LocalStorage.getObject("offline_changes");
        
        if (offlineChanges == null || offlineChanges.length == 0) {
            return js.lib.Promise.resolve();
        }
        
        trace('Processing ${offlineChanges.length} offline changes');
        
        for (change in offlineChanges) {
            try {
                switch (change.type) {
                    case "create":
                        Async.await(createTodoAsync(change.data.title, change.data.description, change.data.priority));
                    case "update":
                        Async.await(updateTodoAsync(change.data.id, change.data.updates));
                    case "delete":
                        Async.await(deleteTodoAsync(change.data.id));
                }
            } catch (e: Dynamic) {
                trace('Failed to process offline change: ${e}');
                // Keep the change for next sync attempt
                continue;
            }
        }
        
        // Clear processed changes
        LocalStorage.removeItem("offline_changes");
        trace("Offline changes processed successfully");
        
        return js.lib.Promise.resolve();
    }
    
    /**
     * Queue changes for offline processing
     */
    public static function queueOfflineChange(type: String, data: Dynamic): Void {
        var changes = LocalStorage.getObject("offline_changes");
        if (changes == null) {
            changes = [];
        }
        
        changes.push({
            type: type,
            data: data,
            timestamp: Date.now().getTime()
        });
        
        LocalStorage.setObject("offline_changes", changes);
        trace('Queued offline change: ${type}');
    }
    
    /**
     * Get hook definitions for PhoenixApp integration.
     * 
     * Called by PhoenixApp to retrieve hook definitions without
     * automatically initializing everything. This allows PhoenixApp
     * to control initialization timing and error handling.
     */
    public static function getHooks(): Dynamic {
        return Hooks.getAll();
    }
    
    /**
     * Utility function for client-side state management
     */
    public static function getClientState(): ClientState {
        return {
            darkMode: DarkMode.isEnabled(),
            autoSave: LocalStorage.getBoolean("autoSave", true),
            lastSync: Date.now().getTime()
        };
    }
    
    /**
     * Update client state
     */
    public static function updateClientState(state: ClientState): Void {
        if (state.darkMode != DarkMode.isEnabled()) {
            DarkMode.toggle();
        }
        
        LocalStorage.setBoolean("autoSave", state.autoSave);
    }
    
    /**
     * Announce status update to screen readers
     */
    public static function announceStatus(message: String): Void {
        var liveRegion = js.Browser.document.getElementById("live-region");
        if (liveRegion != null) {
            liveRegion.textContent = message;
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/components/CoreComponents.hx">
package server.components;

import HXX;

/**
 * Type-safe assigns for Phoenix components
 */
typedef ComponentAssigns = {
    ?id: String,
    ?className: String,
    ?show: Bool,
    ?inner_content: String
}

typedef ModalAssigns = {
    id: String,
    show: Bool,
    ?inner_content: String
}

typedef ButtonAssigns = {
    ?type: String,
    ?className: String,
    ?disabled: Bool,
    inner_content: String
}

typedef InputAssigns = {
    field: FormField,
    ?type: String,
    label: String,
    ?placeholder: String,
    ?required: Bool
}

typedef FormField = {
    id: String,
    name: String,
    value: String,
    ?errors: Array<String>
}

/**
 * Type-safe abstract for Phoenix form targets
 * Compiles to the appropriate Elixir representation
 */
abstract FormTarget(String) {
    public function new(target: String) {
        this = target;
    }
    
    @:from public static function fromString(s: String): FormTarget {
        return new FormTarget(s);
    }
    
    @:to public function toString(): String {
        return this;
    }
}

typedef ErrorAssigns = {
    field: FormField
}

typedef FormAssigns = {
    formFor: FormTarget, // Changeset or schema
    action: String,
    ?method: String,
    inner_content: String
}

typedef HeaderAssigns = {
    title: String,
    ?actions: String
}

typedef TableColumn = {
    field: String,
    label: String
}

typedef TableRowData = Map<String, String>;

typedef TableAssigns = {
    rows: Array<TableRowData>,
    columns: Array<TableColumn>
}

typedef ListAssigns = {
    items: Array<String>
}

typedef BackAssigns = {
    navigate: String
}

typedef IconAssigns = {
    name: String,
    ?className: String
}

typedef LabelAssigns = {
    ?htmlFor: String,
    ?className: String,
    inner_content: String
}

/**
 * Core UI components for Phoenix applications
 * 
 * Provides reusable, type-safe UI components like modals, forms, buttons, etc.
 * These components follow Phoenix LiveView conventions and compile to proper
 * Phoenix.Component functions.
 */
@:native("TodoAppWeb.CoreComponents")
@:component
class CoreComponents {
    
    /**
     * Renders a modal dialog
     */
    @:component
    public static function modal(assigns: ModalAssigns): String {
        return HXX.hxx('<div id={@id} class="modal" phx-show={@show}>
            <%= @inner_content %>
        </div>');
    }
    
    /**
     * Renders a button component
     */
    @:component
    public static function button(assigns: ButtonAssigns): String {
        return HXX.hxx('<button type={@type || "button"} class={@className} disabled={@disabled}>
            <%= @inner_content %>
        </button>');
    }
    
    /**
     * Renders a form input field
     */
    @:component
    public static function input(assigns: InputAssigns): String {
        return HXX.hxx('<div class="form-group">
            <label for={@field.id}><%= @label %></label>
            <input 
                type={@type || "text"} 
                id={@field.id}
                name={@field.name}
                value={@field.value}
                placeholder={@placeholder}
                class="form-control"
                required={@required}
            />
            <%= if @field.errors && length(@field.errors) > 0 do %>
                <span class="error"><%= Enum.join(@field.errors, ", ") %></span>
            <% end %>
        </div>');
    }
    
    /**
     * Renders form error messages
     */
    @:component
    public static function error(assigns: ErrorAssigns): String {
        return HXX.hxx('<%= if @field && @field.errors && length(@field.errors) > 0 do %>
            <div class="error-message">
                <%= Enum.join(@field.errors, ", ") %>
            </div>
        <% end %>');
    }
    
    /**
     * Renders a simple form
     */
    @:component  
    public static function simple_form(assigns: FormAssigns): String {
        // Use `_f` to avoid unused variable warnings when slot variable is not referenced
        return HXX.hxx('<.form :let={_f} for={@formFor} action={@action} method={@method || "post"}>
            <%= @inner_content %>
        </.form>');
    }
    
    /**
     * Renders a header with title and actions
     */
    @:component
    public static function header(assigns: HeaderAssigns): String {
        return HXX.hxx('<header class="header">
            <h1><%= @title %></h1>
            <%= if @actions do %>
                <div class="actions">
                    <%= @actions %>
                </div>
            <% end %>
        </header>');
    }
    
    /**
     * Renders a data table
     */
    @:component
    public static function table(assigns: TableAssigns): String {
        return HXX.hxx('<table class="table">
            <thead>
                <tr>
                    <%= for col <- @columns do %>
                        <th><%= col.label %></th>
                    <% end %>
                </tr>
            </thead>
            <tbody>
                <%= for row <- @rows do %>
                    <tr>
                        <%= for col <- @columns do %>
                            <td><%= Map.get(row, col.field) %></td>
                        <% end %>
                    </tr>
                <% end %>
            </tbody>
        </table>');
    }
    
    /**
     * Renders a list of items
     */
    @:component
    public static function list(assigns: ListAssigns): String {
        return HXX.hxx('<ul class="list">
            <%= for item <- @items do %>
                <li><%= item %></li>
            <% end %>
        </ul>');
    }
    
    /**
     * Renders a back navigation link
     */
    @:component
    public static function back(assigns: BackAssigns): String {
        return HXX.hxx('<div class="back-link">
            <.link navigate={@navigate}>
                ‚Üê Back
            </.link>
        </div>');
    }
    
    /**
     * Renders an icon
     */
    @:component
    public static function icon(assigns: IconAssigns): String {
        return HXX.hxx('<%= if @className do %>
            <span class={"icon icon-" <> @name <> " " <> @className}></span>
        <% else %>
            <span class={"icon icon-" <> @name}></span>
        <% end %>');
    }
    
    /**
     * Renders a form label
     */
    @:component
    public static function label(assigns: LabelAssigns): String {
        return HXX.hxx('<%= if @htmlFor do %>
            <label for={@htmlFor} class={@className}><%= @inner_content %></label>
        <% else %>
            <label class={@className}><%= @inner_content %></label>
        <% end %>');
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/contexts/Users.hx">
package contexts;

import elixir.types.Result;
import ecto.Changeset;
import ecto.TypedQuery;
import server.infrastructure.Repo;
using reflaxe.elixir.macros.TypedQueryLambda; // ensure extension where(...) is available

/**
 * Complete user management context with Ecto integration
 * Demonstrates schemas, changesets, queries, and business logic
 */

typedef UserFilter = {
    ?name: String,
    ?email: String,
    ?isActive: Bool
}

@:schema("users")
class User {
    @:primary_key
    public var id: Int;
    
    @:field({type: "string", nullable: false})
    public var name: String;
    
    @:field({type: "string", nullable: false})
    public var email: String;
    
    @:field({type: "integer"})
    public var age: Int;
    
    @:field({type: "boolean", defaultValue: true})
    public var active: Bool;
    
    @:timestamps
    public var insertedAt: String;
    public var updatedAt: String;
    
    @:has_many("posts", "Post", "user_id")
    public var posts: Array<Post>;
}

/**
 * UserChangeset provides custom changeset logic for User validation
 * 
 * This is separate from the auto-generated changeset in the User @:schema class.
 * The User.changeset function is generated by @:schema, but this allows custom validation.
 */
class UserChangeset {
    public static function changeset(?user: User, attrs: UserParams): Changeset<User, UserParams> {
        // Create a typed changeset for compile-time safety
        // The actual Ecto validations would be added by the generated Elixir code
        // Return inline to avoid losing the binding during hygiene passes
        return new Changeset(user, attrs);
    }
}

@:native("TodoApp.Users")
class Users {
    /**
     * Get all users with optional filtering
     */
    public static function listUsers(?filter: UserFilter): Array<User> {
        // Build a single query variable and refine it conditionally; return at the end.
        var query = TypedQuery.from(contexts.User);
        if (filter != null && filter.name != null) {
            query = query.where(u -> u.name == '%${filter.name}%');
        }
        if (filter != null && filter.email != null) {
            query = query.where(u -> u.email == '%${filter.email}%');
        }
        if (filter != null && filter.isActive != null) {
            query = query.where(u -> u.active == filter.isActive);
        }
        return Repo.all(query);
    }
    
    /**
     * Create changeset for user (required by LiveView example)
     */
    public static function changeUser(?user: User): Changeset<User, UserParams> {
        // Create Ecto changeset for form validation
        // For new users, pass null and let the changeset handle the empty struct
        return new Changeset(user, {});
    }
    
    /**
     * Main function for compilation testing
     */
    public static function main(): Void {
        trace("Users context with User schema compiled successfully!");
    }
    
    /**
     * Get user by ID with error handling
     */
    public static function getUser(id: Int): User {
        // Use typed Repo extern - throws if not found
        var user = Repo.get(User, id);
        if (user == null) {
            throw 'User not found with id: $id';
        }
        return user;
    }
    
    /**
     * Get user by ID, returns null if not found
     */
    public static function getUserSafe(id: Int): Null<User> {
        // Use typed Repo extern for safe lookup
        return Repo.get(User, id);
    }
    
    /**
     * Create a new user
     * Returns Result with either the created User or the invalid Changeset
     */
    public static function createUser(attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Inline changeset to avoid temp var naming drift
        return Repo.insert(UserChangeset.changeset(null, attrs));
    }
    
    /**
     * Update existing user
     * Returns Result with either the updated User or the invalid Changeset
     */
    public static function updateUser(user: User, attrs: UserParams): Result<User, Changeset<User, UserParams>> {
        // Inline changeset to avoid temp var naming drift
        return Repo.update(UserChangeset.changeset(user, attrs));
    }
    
    /**
     * Delete user (hard delete from database)
     * Returns Result with either the deleted User or a Changeset with errors
     */
    public static function deleteUser(user: User): Result<User, Changeset<User, {}>> {
        // Delete user using typed Repo
        return Repo.delete(user);
    }
    
    /**
     * Search users by name or email
     */
    public static function searchUsers(term: String): Array<User> {
        // Query DSL implementation will be handled by future @:query annotation
        return [];
    }
    
    /**
     * Get user statistics
     */
    public static function userStats(): UserStats {
        // Query DSL implementation will be handled by future @:query annotation
        return {total: 0, active: 0, inactive: 0};
    }
}

// Supporting types
typedef UserParams = {
    ?name: String,
    ?email: String,
    ?age: Int,
    ?active: Bool
}

typedef UserStats = {
    total: Int,
    active: Int,
    inactive: Int
}

typedef Post = {
    id: Int,
    title: String,
    user_id: Int
}
</file>

<file path="examples/todo-app/src_haxe/server/controllers/UserController.hx">
package controllers;

import plug.Conn;
import contexts.Users;
import contexts.Users.UserParams;
import elixir.types.Result;

// Type-safe parameter definitions for each action
typedef IndexParams = {}  // Empty params for index
typedef ShowParams = {id: String};
typedef CreateParams = UserParams;
typedef UpdateParams = {id: String} & UserParams;  // Combine ID with user params
typedef DeleteParams = {id: String};

/**
 * UserController: Type-safe Phoenix controller showcasing Haxe‚ÜíElixir benefits
 * 
 * This controller demonstrates how Haxe brings compile-time type safety to Phoenix
 * web applications while generating idiomatic Elixir code that Phoenix developers
 * will find familiar and maintainable.
 * 
 * ## Annotations Explained
 * 
 * @:native("TodoAppWeb.UserController")
 * - **Purpose**: Specifies the exact Elixir module name to generate
 * - **Why**: Phoenix expects controllers in the `AppNameWeb` namespace
 * - **Benefit**: Follows Phoenix conventions while keeping Haxe package structure clean
 * - **Generated**: `defmodule TodoAppWeb.UserController do`
 * 
 * @:controller  
 * - **Purpose**: Marks this class as a Phoenix controller
 * - **Why**: Triggers controller-specific compilation (adds `use TodoAppWeb, :controller`)
 * - **Benefit**: Automatic Phoenix controller boilerplate and proper action signatures
 * - **Generated**: Includes all Phoenix.Controller functionality
 * 
 * ## Type Safety Benefits
 * 
 * Traditional Phoenix controllers have no compile-time parameter validation:
 * ```elixir
 * def show(conn, %{"id" => id}) do  # Runtime crash if "id" missing
 * ```
 * 
 * With Haxe, we get compile-time guarantees:
 * ```haxe
 * function show(conn: Conn, params: {id: String}): Conn  // Won't compile without id
 * ```
 * 
 * ## Best Practices
 * 
 * 1. **Type your params**: Use anonymous structures for known parameters
 * 2. **Return Conn**: All actions must return a Conn for the pipeline
 * 3. **Use Conn methods**: conn.json(), conn.render(), conn.redirect()
 * 4. **Leverage type inference**: Let Haxe catch missing fields at compile time
 * 
 * @see https://hexdocs.pm/phoenix/Phoenix.Controller.html
 */
@:native("TodoAppWeb.UserController")
@:controller
class UserController {
    
    /**
     * Generate a unique ID for new users
     * Uses timestamp and random for uniqueness
     */
    private static function generateUniqueId(): String {
        // Use Haxe's standard library instead of __elixir__()
        var timestamp = Date.now().getTime();
        var random = Math.floor(Math.random() * 10000);
        return '${timestamp}_${random}';
    }
    
    /**
     * List all users (GET /api/users)
     * 
     * Traditional Phoenix:
     * ```elixir
     * def index(conn, _params) do
     *   users = Users.listUsers()
     *   json(conn, %{users: users})
     * end
     * ```
     * 
     * With Haxe, we get type-safe JSON responses and can refactor safely.
     */
    public static function index(conn: Conn<IndexParams>, _params: IndexParams): Conn<IndexParams> {
        // Fetch all users from database
        var users = Users.listUsers(null);
        return conn.json({users: users});
    }
    
    /**
     * Show a specific user (GET /api/users/:id)
     * 
     * Notice the type-safe params structure - we KNOW at compile time
     * that 'id' must exist. No runtime pattern matching needed!
     * 
     * @param conn The request connection (typed with ShowParams)
     * @param params Must contain 'id' field (compile-time enforced)
     * @return JSON response with user data
     */
    public static function show(conn: Conn<ShowParams>, params: ShowParams): Conn<ShowParams> {
        // Fetch user from database
        var userId = Std.parseInt(params.id);
        var user = Users.getUserSafe(userId);
        
        if (user != null) {
            return conn.json({user: user});
        } else {
            return conn
                .putStatus(404)
                .json({error: "User not found"});
        }
    }
    
    /**
     * Create a new user (POST /api/users)
     * 
     * In production, you'd define a proper User type:
     * ```haxe
     * typedef UserParams = {
     *     name: String,
     *     email: String,
     *     ?age: Int  // Optional field
     * }
     * function create(conn: Conn, params: UserParams): Conn
     * ```
     * 
     * This gives you compile-time validation of required fields!
     */
    public static function create(conn: Conn<CreateParams>, params: CreateParams): Conn<CreateParams> {
        // Create user through Users context with database persistence
        var result = Users.createUser(params);
        
        return switch(result) {
            case Ok(value):
                conn
                    .putStatus(201)
                    .json({
                        user: value,
                        created: true,
                        message: "User created successfully"
                    });
                    
            case Error(reason):
                conn
                    .putStatus(422)
                    .json({
                        error: "Failed to create user",
                        changeset: reason
                    });
        }
    }
    
    /**
     * Update an existing user (PUT /api/users/:id)
     * 
     * Combines URL parameters (id) with body parameters.
     * Type-safe with UpdateParams ensuring id always exists.
     */
    public static function update(conn: Conn<UpdateParams>, params: UpdateParams): Conn<UpdateParams> {
        // Fetch existing user first
        var userId = Std.parseInt(params.id);
        var user = Users.getUserSafe(userId);
        
        if (user == null) {
            return conn
                .putStatus(404)
                .json({error: "User not found"});
        }
        
        // Update user through Users context
        var updateAttrs: UserParams = {
            name: params.name,
            email: params.email,
            age: params.age,
            active: params.active
        };
        
        var result = Users.updateUser(user, updateAttrs);
        
        return switch(result) {
            case Ok(value):
                // Use a named local to avoid any intermediate aliasing of the json/2 payload
                final payload = {
                    user: value,
                    updated: true,
                    message: 'User ${params.id} updated successfully'
                };
                conn.json(payload);
                
            case Error(reason):
                conn
                    .putStatus(422)
                    .json({
                        error: "Failed to update user",
                        changeset: reason
                    });
        }
    }
    
    /**
     * Delete a user (DELETE /api/users/:id)
     * 
     * Type-safe deletion - the compiler ensures 'id' exists.
     * No need for defensive programming or nil checks!
     */
    public static function delete(conn: Conn<DeleteParams>, params: DeleteParams): Conn<DeleteParams> {
        // Fetch user to delete
        var userId = Std.parseInt(params.id);
        var user = Users.getUserSafe(userId);
        
        if (user == null) {
            return conn
                .putStatus(404)
                .json({error: "User not found"});
        }
        
        // Delete user through Users context
        var result = Users.deleteUser(user);
        
        return switch(result) {
            case Ok(_value):
                // Use a named local to avoid any intermediate aliasing of the json/2 payload
                final payload = {
                    deleted: params.id,
                    success: true,
                    message: 'User ${params.id} deleted successfully'
                };
                conn.json(payload);
                
            case Error(_reason):
                conn
                    .putStatus(500)
                    .json({
                        error: "Failed to delete user",
                        success: false
                    });
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/i18n/Gettext.hx">
package server.i18n;

/**
 * Gettext module for internationalization
 * 
 * Provides translation and localization support for the Phoenix application.
 * This module wraps the Elixir Gettext functionality with type-safe Haxe interfaces.
 */
@:native("TodoAppWeb.Gettext")
@:gettext
class Gettext {
    /**
     * Default locale for the application
     */
    public static inline var DEFAULT_LOCALE = "en";
    
    /**
     * Translate a message
     * 
     * @param msgid The message ID to translate
     * @return Translated string
     */
    public static extern function gettext(msgid: String): String;
    
    /**
     * Translate a message with pluralization
     * 
     * @param msgid Singular message ID
     * @param msgid_plural Plural message ID
     * @param count Count for pluralization
     * @return Translated string
     */
    public static extern function ngettext(msgid: String, msgid_plural: String, count: Int): String;
    
    /**
     * Translate within a specific domain
     * 
     * @param domain Translation domain
     * @param msgid Message ID
     * @return Translated string
     */
    public static extern function dgettext(domain: String, msgid: String): String;
    
    /**
     * Translate with domain and pluralization
     * 
     * @param domain Translation domain
     * @param msgid Singular message ID
     * @param msgid_plural Plural message ID
     * @param count Count for pluralization
     * @return Translated string
     */
    public static extern function dngettext(domain: String, msgid: String, msgid_plural: String, count: Int): String;
    
    /**
     * Get the current locale
     * 
     * @return Current locale string
     */
    public static extern function getLocale(): String;
    
    /**
     * Set the current locale
     * 
     * @param locale Locale to set
     */
    public static extern function putLocale(locale: String): Void;
    
    /**
     * Helper function for error messages
     * 
     * @param msgid Error message ID
     * @param bindings Variable bindings for interpolation
     * @return Translated error message
     */
    public static function error(msgid: String, ?bindings: Map<String, String>): String {
        // This would handle error message translation with variable interpolation
        return gettext(msgid);
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/Endpoint.hx">
package server.infrastructure;

/**
 * TodoAppWeb HTTP endpoint
 * Handles incoming HTTP requests and WebSocket connections
 * 
 * Now using proper @:endpoint annotation with AST transformation
 * This generates a complete Phoenix.Endpoint module structure
 */
@:native("TodoAppWeb.Endpoint")
@:endpoint
@:appName("todo_app")
class Endpoint {
    /**
     * Get static paths for asset serving
     * This function is referenced by the generated endpoint module
     */
    public static function static_paths(): Array<String> {
        return ["assets", "fonts", "images", "favicon.ico", "robots.txt"];
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/Gettext.hx">
package server.infrastructure;

import server.infrastructure.TranslationBindings;

/**
 * Internationalization support module using Phoenix's Gettext.
 * 
 * This module provides translation and localization functionality
 * for the TodoApp application. It wraps Phoenix's Gettext system
 * to provide compile-time type safety for translations.
 */
@:native("TodoAppWeb.Gettext")
extern class Gettext {
    
    /**
     * Default locale for the application.
     */
    public static var DEFAULT_LOCALE: String;
    
    /**
     * Translates a message in the default domain.
     * 
     * @param msgid The message identifier to translate
     * @param bindings Optional variable bindings for interpolation
     * @return The translated string
     */
    public static function gettext(msgid: String, ?bindings: TranslationBindings): String;
    
    /**
     * Translates a message in a specific domain.
     * 
     * @param domain The translation domain (e.g., "errors", "forms")
     * @param msgid The message identifier to translate
     * @param bindings Optional variable bindings for interpolation
     * @return The translated string
     */
    public static function dgettext(domain: String, msgid: String, ?bindings: TranslationBindings): String;
    
    /**
     * Translates a plural message based on count.
     * 
     * @param msgid The singular message identifier
     * @param msgid_plural The plural message identifier
     * @param count The count for determining singular/plural
     * @param bindings Optional variable bindings for interpolation
     * @return The translated string
     */
    public static function ngettext(msgid: String, msgid_plural: String, count: Int, ?bindings: TranslationBindings): String;
    
    /**
     * Translates a plural message in a specific domain.
     * 
     * @param domain The translation domain
     * @param msgid The singular message identifier
     * @param msgid_plural The plural message identifier
     * @param count The count for determining singular/plural
     * @param bindings Optional variable bindings for interpolation
     * @return The translated string
     */
    public static function dngettext(domain: String, msgid: String, msgid_plural: String, count: Int, ?bindings: TranslationBindings): String;
    
    /**
     * Gets the current locale.
     * 
     * @return The current locale string (e.g., "en", "es", "fr")
     */
    public static function get_locale(): String;
    
    /**
     * Sets the current locale for translations.
     * 
     * @param locale The locale to set (e.g., "en", "es", "fr")
     */
    public static function put_locale(locale: String): Void;
    
    /**
     * Returns all available locales for the application.
     * 
     * @return Array of available locale codes
     */
    public static function known_locales(): Array<String>;

}

// Explicit alias to ensure fully-qualified module printing for calls
@:native("TodoAppWeb.Gettext")
extern class WebGettext {
    public static function gettext(msgid: String, ?bindings: TranslationBindings): String;
    public static function dgettext(domain: String, msgid: String, ?bindings: TranslationBindings): String;
    public static function ngettext(msgid: String, msgid_plural: String, count: Int, ?bindings: TranslationBindings): String;
    public static function dngettext(domain: String, msgid: String, msgid_plural: String, count: Int, ?bindings: TranslationBindings): String;
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/GettextErrorMessages.hx">
package server.infrastructure;

import server.infrastructure.Gettext;
import server.infrastructure.TranslationBindings;

/**
 * Common error message translations for the application.
 * 
 * This class provides pre-defined error messages using Gettext
 * for internationalization. All messages are in the "errors" domain
 * and can be translated to different languages.
 */
@:native("TodoAppWeb.Gettext.ErrorMessages")
class GettextErrorMessages {
    /**
     * Returns the "required field" error message.
     * @return Translated error message for required fields
     */
    public static function required_field(): String {
        return WebGettext.dgettext("errors", "can't be blank");
    }
    
    /**
     * Returns the "invalid format" error message.
     * @return Translated error message for invalid format
     */
    public static function invalid_format(): String {
        return WebGettext.dgettext("errors", "has invalid format");
    }
    
    /**
     * Returns the "too short" error message with minimum length.
     * @param min The minimum required length
     * @return Translated error message with count interpolation
     */
    public static function too_short(min: Int): String {
        var bindings = TranslationBindings.create()
            .setInt("count", min);
        return WebGettext.dgettext("errors", "should be at least %{count} character(s)", bindings);
    }
    
    /**
     * Returns the "too long" error message with maximum length.
     * @param max The maximum allowed length
     * @return Translated error message with count interpolation
     */
    public static function too_long(max: Int): String {
        var bindings = TranslationBindings.create()
            .setInt("count", max);
        return WebGettext.dgettext("errors", "should be at most %{count} character(s)", bindings);
    }
    
    /**
     * Returns the "not found" error message.
     * @return Translated error message for not found resources
     */
    public static function not_found(): String {
        return WebGettext.dgettext("errors", "not found");
    }
    
    /**
     * Returns the "unauthorized" error message.
     * @return Translated error message for unauthorized access
     */
    public static function unauthorized(): String {
        return WebGettext.dgettext("errors", "unauthorized");
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/GettextUIMessages.hx">
package server.infrastructure;

import server.infrastructure.Gettext;
import server.infrastructure.TranslationBindings;

/**
 * Common UI message translations for the application.
 * 
 * This class provides pre-defined UI messages using Gettext
 * for internationalization. These messages are commonly used
 * throughout the application's user interface.
 */
@:native("TodoAppWeb.Gettext.UIMessages")
class GettextUIMessages {
    /**
     * Returns a welcome message with the user's name.
     * @param name The name to include in the welcome message
     * @return Translated welcome message with name interpolation
     */
    public static function welcome(name: String): String {
        var bindings = TranslationBindings.create()
            .set("name", name);
        return WebGettext.gettext("Welcome %{name}!", bindings);
    }
    
    /**
     * Returns a generic success message.
     * @return Translated success message
     */
    public static function success(): String {
        return WebGettext.gettext("Operation completed successfully");
    }
    
    /**
     * Returns a loading message.
     * @return Translated loading message
     */
    public static function loading(): String {
        return WebGettext.gettext("Loading...");
    }
    
    /**
     * Returns the "Save" button label.
     * @return Translated save label
     */
    public static function save(): String {
        return WebGettext.gettext("Save");
    }
    
    /**
     * Returns the "Cancel" button label.
     * @return Translated cancel label
     */
    public static function cancel(): String {
        return WebGettext.gettext("Cancel");
    }
    
    /**
     * Returns the "Delete" button label.
     * @return Translated delete label
     */
    public static function delete(): String {
        return WebGettext.gettext("Delete");
    }
    
    /**
     * Returns the "Edit" button label.
     * @return Translated edit label
     */
    public static function edit(): String {
        return WebGettext.gettext("Edit");
    }
    
    /**
     * Returns a confirmation message for delete actions.
     * @return Translated delete confirmation message
     */
    public static function confirm_delete(): String {
        return WebGettext.gettext("Are you sure you want to delete this item?");
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/Repo.hx">
package server.infrastructure;

import elixir.types.Result;
import ecto.Changeset;
import ecto.Query.EctoQuery;
import ecto.DatabaseAdapter.*;

/**
 * Database repository for TodoApp
 * 
 * This class uses @:repo annotation with typed configuration to generate:
 * 1. The Ecto.Repo module with proper adapter settings
 * 2. A companion PostgrexTypes module for JSON encoding/decoding
 * 
 * The typed configuration ensures compile-time validation and
 * automatic generation of all required database modules.
 * 
 * Generated Elixir:
 * ```elixir
 * defmodule TodoApp.Repo do
 *   use Ecto.Repo, otp_app: :todo_app, adapter: Ecto.Adapters.Postgres
 * end
 * 
 * defmodule TodoApp.PostgrexTypes do
 *   Postgrex.Types.define(TodoApp.PostgrexTypes, [], json: Jason)
 * end
 * ```
 */
@:native("TodoApp.Repo")
@:repo({
    adapter: Postgres,
    json: Jason,
    extensions: [],
    poolSize: 10
})
extern class Repo {
    // These are extern declarations for the functions injected by Ecto.Repo
    
    @:overload(function<T>(query: EctoQuery<T>): Array<T> {})
    @:overload(function<T>(query: ecto.TypedQuery.TypedQuery<T>): Array<T> {})
    public static function all<T>(queryable: Class<T>): Array<T>;
    
    public static function get<T>(queryable: Class<T>, id: Int): Null<T>;
    
    public static function insert<T, P>(changeset: Changeset<T, P>): Result<T, Changeset<T, P>>;
    
    public static function update<T, P>(changeset: Changeset<T, P>): Result<T, Changeset<T, P>>;
    
    public static function delete<T>(struct: T): Result<T, Changeset<T, {}>>;
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/Telemetry.hx">
package server.infrastructure;

import elixir.otp.Supervisor;
import elixir.otp.Application;
import elixir.otp.TypeSafeChildSpec;

/**
 * Type definition for telemetry supervisor options
 */
typedef TelemetryOptions = {
    ?name: String,
    ?metrics_port: Int,
    ?reporters: Array<String>
}

/**
 * Type definition for OTP child specification
 */
typedef ChildSpec = {
    id: String,
    start: {
        module: String,
        func: String,
        args: Array<TelemetryOptions>
    },
    type: String,
    restart: String,
    shutdown: String
}

/**
 * Type definition for telemetry metrics
 */
typedef TelemetryMetric = {
    name: String,
    event: String,
    measurement: String,
    ?unit: String,
    ?tags: Array<String>
}

/**
 * TodoAppWeb telemetry supervisor
 * Handles application metrics, monitoring, and observability
 * 
 * This module compiles to TodoAppWeb.Telemetry with proper Phoenix telemetry
 * configuration for monitoring web requests, database queries, and custom metrics.
 */
@:native("TodoAppWeb.Telemetry")
@:supervisor
@:appName("TodoApp")
class Telemetry {
    /**
     * Child specification for OTP supervisor
     * 
     * Returns a proper child spec map for Supervisor.start_link
     * 
     * NOTE: @:keep is still required until we implement macro-time preservation
     * for supervisor functions. The AST transformation happens too late to prevent DCE.
     */
    @:keep
    public static function child_spec(opts: TelemetryOptions): ChildSpec {
        // Return a properly typed child spec structure
        return {
            id: "TodoAppWeb.Telemetry",
            start: {
                module: "TodoAppWeb.Telemetry",
                func: "start_link",
                args: [opts]
            },
            type: "supervisor",
            restart: "permanent", 
            shutdown: "infinity"
        };
    }
    
    /**
     * Start the telemetry supervisor
     * 
     * Initializes application metrics collection including:
     * - Phoenix endpoint metrics (request duration, status codes)
     * - Ecto repository metrics (query time, connection pool)
     * - LiveView metrics (mount time, event handling)
     * - Custom application metrics
     * 
     * @param args Telemetry configuration options
     * @return Application result with supervisor PID
     * 
     * NOTE: @:keep is still required until we implement macro-time preservation
     */
    @:keep
    public static function start_link(args: TelemetryOptions): ApplicationResult {
        // Start a telemetry supervisor with no children; reporters are added dynamically.
        // Inline empty list directly to avoid intermediate temp and ensure WAE=0.
        return untyped __elixir__('Supervisor.start_link([], [strategy: :one_for_one, max_restarts: 3, max_seconds: 5])');
    }
    
    /**
     * Get telemetry metrics configuration
     * 
     * Returns the list of telemetry events and handlers configured
     * for this application, used for debugging and monitoring.
     */
    public static function metrics(): Array<TelemetryMetric> {
        // Returns configured telemetry metrics
        // In a real application, this would return actual metric definitions
        return [];
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/TodoAppWeb.hx">
package server.infrastructure;

/**
 * TodoAppWeb module providing Phoenix framework helpers.
 * 
 * This module acts as the central hub for Phoenix web functionality,
 * providing `use` macros for router, controller, LiveView, and other
 * Phoenix components. It follows Phoenix conventions for web modules.
 * 
 * The @:phoenixWebModule annotation triggers generation of all necessary
 * Phoenix macros including router, controller, live_view, etc.
 */
@:phoenixWebModule
@:native("TodoAppWeb")
class TodoAppWeb {
    /**
     * Returns the static paths for the application.
     * This is used by Phoenix for serving static assets.
     */
    public static function static_paths(): Array<String> {
        return ["assets", "fonts", "images", "favicon.ico", "robots.txt"];
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/infrastructure/TranslationBindings.hx">
package server.infrastructure;

/**
 * Type-safe translation bindings for Gettext interpolation.
 * 
 * This abstract type provides a type-safe way to pass variable bindings
 * to Gettext translation functions without using Dynamic. It internally
 * uses a Map but provides a clean API for setting interpolation values.
 * 
 * ## Usage
 * ```haxe
 * var bindings = TranslationBindings.create()
 *     .set("name", "John")
 *     .set("count", 5);
 * Gettext.gettext("Hello %{name}, you have %{count} items", bindings);
 * ```
 */
abstract TranslationBindings(Map<String, String>) {
    /**
     * Creates a new TranslationBindings instance from a map.
     */
    inline function new(map: Map<String, String>) {
        this = map;
    }
    
    /**
     * Creates an empty TranslationBindings instance.
     * 
     * @return A new empty TranslationBindings
     */
    public static function create(): TranslationBindings {
        return new TranslationBindings(new Map<String, String>());
    }
    
    /**
     * Sets a string value for interpolation.
     * 
     * @param key The interpolation key
     * @param value The string value
     * @return This TranslationBindings for chaining
     */
    public function set(key: String, value: String): TranslationBindings {
        this.set(key, value);
        return cast this;
    }
    
    /**
     * Sets an integer value for interpolation.
     * Automatically converts to string.
     * 
     * @param key The interpolation key
     * @param value The integer value
     * @return This TranslationBindings for chaining
     */
    public function setInt(key: String, value: Int): TranslationBindings {
        this.set(key, Std.string(value));
        return cast this;
    }
    
    /**
     * Sets a float value for interpolation.
     * Automatically converts to string.
     * 
     * @param key The interpolation key
     * @param value The float value
     * @return This TranslationBindings for chaining
     */
    public function setFloat(key: String, value: Float): TranslationBindings {
        this.set(key, Std.string(value));
        return cast this;
    }
    
    /**
     * Sets a boolean value for interpolation.
     * Automatically converts to string.
     * 
     * @param key The interpolation key
     * @param value The boolean value
     * @return This TranslationBindings for chaining
     */
    public function setBool(key: String, value: Bool): TranslationBindings {
        this.set(key, value ? "true" : "false");
        return cast this;
    }
    
    /**
     * Gets the underlying map for framework interop.
     * This is marked @:noCompletion to hide it from IntelliSense.
     * 
     * @return The underlying Map<String, String>
     */
    @:noCompletion
    public inline function toMap(): Map<String, String> {
        return this;
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/layouts/AppLayout.hx">
package server.layouts;

// HXX calls are transformed at compile-time by the Reflaxe.Elixir compiler

/**
 * Application layout component
 * Provides the main container and navigation structure for the app
 */
class AppLayout {
    
    /**
     * Main application wrapper template
     * Includes navigation, breadcrumbs, and content area
     */
    public static function render(assigns: Dynamic): String {
        return HXX.hxx('
            <div class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 dark:from-gray-900 dark:via-gray-800 dark:to-blue-900">
                
                <!-- Header Navigation -->
                <header class="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm border-b border-gray-200 dark:border-gray-700 sticky top-0 z-40">
                    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                        <div class="flex justify-between items-center h-16">
                            
                            <!-- Logo and App Name -->
                            <div class="flex items-center space-x-4">
                                <div class="flex-shrink-0">
                                    <div class="w-8 h-8 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-lg flex items-center justify-center">
                                        <span class="text-white font-bold text-sm">üìù</span>
                                    </div>
                                </div>
                                <div>
                                    <h1 class="text-xl font-bold text-gray-900 dark:text-white">
                                        Todo App
                                    </h1>
                                    <p class="text-xs text-gray-500 dark:text-gray-400">
                                        Haxe ‚ù§Ô∏è Phoenix LiveView
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Navigation Links -->
                            <nav class="hidden md:flex space-x-8">
                                <a href="/" class="text-gray-600 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400 transition-colors font-medium">
                                    Dashboard
                                </a>
                                <a href="/todos" class="text-blue-600 dark:text-blue-400 font-medium">
                                    Todos
                                </a>
                                <a href="/profile" class="text-gray-600 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400 transition-colors font-medium">
                                    Profile
                                </a>
                            </nav>
                            
                            <!-- User Menu -->
                            <div class="flex items-center space-x-4">
                                <div class="text-sm text-gray-700 dark:text-gray-300">
                                    Welcome, <span class="font-semibold">${getUserDisplayName(assigns.current_user)}</span>
                                </div>
                                <div class="w-8 h-8 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
                                    <span class="text-white text-sm font-medium">
                                        ${getInitials(getUserDisplayName(assigns.current_user))}
                                    </span>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                </header>
                
                <!-- Breadcrumbs -->
                <nav class="bg-white/60 dark:bg-gray-800/60 backdrop-blur-sm border-b border-gray-100 dark:border-gray-700" aria-label="Breadcrumb">
                    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                        <div class="flex items-center space-x-4 h-12 text-sm">
                            <a href="/" class="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300">
                                üè† Home
                            </a>
                            <span class="text-gray-400 dark:text-gray-500">/</span>
                            <span class="text-gray-900 dark:text-white font-medium">
                                ${getPageTitle(assigns.page_title)}
                            </span>
                        </div>
                    </div>
                </nav>
                
                <!-- Main Content Area -->
                <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                    
                    <!-- Page Header -->
                    <div class="mb-8">
                        <div class="md:flex md:items-center md:justify-between">
                            <div class="flex-1 min-w-0">
                                <h2 class="text-2xl font-bold leading-7 text-gray-900 dark:text-white sm:text-3xl sm:truncate">
                                    ${getPageTitle(assigns.page_title)}
                                </h2>
                                <div class="mt-1 flex flex-col sm:flex-row sm:flex-wrap sm:mt-0 sm:space-x-6">
                                    <div class="mt-2 flex items-center text-sm text-gray-500 dark:text-gray-400">
                                        <span class="mr-2">üïí</span>
                                        Last updated: ${formatTimestamp(getLastUpdated(assigns.last_updated))}
                                    </div>
                                    <div class="mt-2 flex items-center text-sm text-gray-500 dark:text-gray-400">
                                        <span class="mr-2">‚ö°</span>
                                        Real-time sync enabled
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Quick Actions -->
                            <div class="mt-4 flex md:mt-0 md:ml-4 space-x-2">
                                <button type="button" class="inline-flex items-center px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                                    üìä Stats
                                </button>
                                <button type="button" class="inline-flex items-center px-3 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                                    ‚ûï New Todo
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Content -->
                    <div class="space-y-6">
                        ${assigns.inner_content}
                    </div>
                    
                </main>
                
                <!-- Footer -->
                <footer class="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm border-t border-gray-200 dark:border-gray-700 mt-auto">
                    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
                        <div class="flex justify-between items-center">
                            <div class="text-sm text-gray-500 dark:text-gray-400">
                                Built with ‚ù§Ô∏è using Haxe and Phoenix LiveView
                            </div>
                            <div class="flex space-x-6 text-sm text-gray-500 dark:text-gray-400">
                                <a href="/about" class="hover:text-gray-700 dark:hover:text-gray-300 transition-colors">About</a>
                                <a href="/help" class="hover:text-gray-700 dark:hover:text-gray-300 transition-colors">Help</a>
                                <a href="https://github.com/reflaxe/elixir" class="hover:text-gray-700 dark:hover:text-gray-300 transition-colors">GitHub</a>
                            </div>
                        </div>
                    </div>
                </footer>
                
            </div>
        ');
    }
    
    /**
     * Get user display name with fallback
     */
    private static function getUserDisplayName(user: Null<{name: Null<String>}>): String {
        if (user != null && user.name != null) {
            return user.name;
        }
        return "User";
    }
    
    /**
     * Get page title with fallback
     */
    private static function getPageTitle(title: Null<String>): String {
        if (title != null) {
            return title;
        }
        return "Todo Dashboard";
    }
    
    /**
     * Get last updated timestamp with fallback
     */
    private static function getLastUpdated(timestamp: Null<String>): String {
        if (timestamp != null) {
            return timestamp;
        }
        return "now";
    }
    
    /**
     * Get user initials for avatar
     */
    private static function getInitials(name: String): String {
        if (name == null || name == "") return "U";
        var parts = name.split(" ");
        if (parts.length >= 2) {
            return parts[0].charAt(0).toUpperCase() + parts[1].charAt(0).toUpperCase();
        }
        return name.charAt(0).toUpperCase();
    }
    
    /**
     * Format timestamp for display
     */
    private static function formatTimestamp(timestamp: String): String {
        // Simple implementation - would use proper date formatting in real app
        return timestamp;
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/layouts/Layouts.hx">
package server.layouts;

import HXX; // Compile-time HXX ‚Üí ~H macro

/**
 * Main layouts module for Phoenix application
 * Provides the layout functions that Phoenix expects
 */
@:native("TodoAppWeb.Layouts")
class Layouts {
    /**
     * Root layout function
     *
     * WHY
     * - Previously this returned only `inner_content`, so the page lacked the
     *   required `<link>`/`<script>` tags and Tailwind never loaded.
     *
     * HOW
     * - Return a real HEEx root document that includes tracked static assets
     *   and yields `@inner_content`. This mirrors Phoenix 1.7 defaults and
     *   lets our HEEx transformer convert this string into a `~H` sigil.
     */
    @:keep public static function root(assigns: Dynamic): Dynamic {
        return HXX.hxx('
            <!DOCTYPE html>
            <html lang="en" class="h-full">
                <head>
                    <meta charset="utf-8"/>
                    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
                    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
                    <title>Todo App</title>
                    <meta name="csrf-token" content={Phoenix.Controller.get_csrf_token()}/>
                    
                    <!-- Static assets (served by Phoenix Endpoint) -->
                    <link phx-track-static rel="stylesheet" href="/assets/app.css"/>
                    <!-- Bundle that bootstraps LiveSocket and loads Haxe hooks -->
                    <script defer phx-track-static type="text/javascript" src="/assets/phoenix_app.js"></script>
                </head>
                <body class="h-full bg-gray-50 dark:bg-gray-900 font-inter antialiased">
                    <main id="main-content" class="h-full">
                        <%= @inner_content %>
                    </main>
                </body>
            </html>
        ');
    }

    /**
     * Application layout function
     * - Wraps content in a responsive container and basic page chrome.
     */
    @:keep public static function app(assigns: Dynamic): Dynamic {
        return HXX.hxx('
            <div class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 dark:from-gray-900 dark:via-gray-800 dark:to-blue-900">
                <div class="container mx-auto px-4 py-8 max-w-6xl">
                    <%= @inner_content %>
                </div>
            </div>
        ');
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/layouts/RootLayout.hx">
package server.layouts;

import phoenix.Component;

// HXX calls are transformed at compile-time by the Reflaxe.Elixir compiler

/**
 * Root layout component for the Phoenix application
 * Handles HTML document structure, meta tags, and asset loading
 * 
 * IMPORTANT: JavaScript Architecture Decision
 * =========================================
 * 
 * This template deliberately avoids inline JavaScript code inside <script> tags.
 * Phoenix's HEEx parser treats JavaScript syntax (parentheses, quotes) as template 
 * syntax, causing compilation errors like "expected closing `"` for attribute value".
 * 
 * CORRECT PATTERN (This file):
 * - Reference external JavaScript files: <script src="/assets/app.js"></script>
 * - Keep templates clean with only HTML and Elixir interpolation
 * - Place all JavaScript logic in app.js or hook files
 * 
 * INCORRECT PATTERN (Causes compilation errors):
 * - Inline JavaScript: <script>if (condition) { ... }</script>
 * - Complex JavaScript expressions in templates
 * - JavaScript variables and functions defined in HEEx
 * 
 * Dark Mode Implementation:
 * - Theme detection/application: Handled by DarkMode.hx -> app.js
 * - Theme toggle button logic: Handled by ThemeToggle hook in client/hooks/
 * - Theme persistence: Handled by LocalStorage.hx utility
 * 
 * This architecture ensures:
 * 1. Clean separation between templates and JavaScript
 * 2. No HEEx parser conflicts with JavaScript syntax  
 * 3. Better maintainability and testability
 * 4. Proper Phoenix/LiveView best practices
 * 
 * @see /src_haxe/client/utils/DarkMode.hx - Theme logic implementation
 * @see /src_haxe/client/hooks/ThemeToggle.hx - Theme toggle hook
 * @see /assets/js/app.js - Compiled JavaScript output
 */
class RootLayout {
    
    /**
     * Root HTML document template
     * Includes Tailwind CSS, proper meta tags, and Phoenix LiveView setup
     */
    public static function render(assigns: Dynamic): String {
        return HXX.hxx('
            <!DOCTYPE html>
            <html lang="en" class="h-full">
                <head>
                    <meta charset="utf-8"/>
                    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
                    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
                    <meta name="csrf-token" content={Phoenix.Controller.get_csrf_token()}/>
                    
                    <title>Todo App - Haxe ‚ù§Ô∏è Phoenix LiveView</title>
                    <meta name="description" content="A beautiful todo application built with Haxe and Phoenix LiveView, showcasing modern UI and type-safe development"/>
                    
                    <!-- Favicon -->
                    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">
                    
                    <!-- Preconnect to Google Fonts for performance -->
                    <link rel="preconnect" href="https://fonts.googleapis.com">
                    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                    
                    <!-- Inter font for modern typography -->
                    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
                    
                    <!-- Phoenix LiveView assets -->
                    <script defer phx-track-static type="text/javascript" src="/assets/phoenix_app.js"></script>
                    <link phx-track-static rel="stylesheet" href="/assets/app.css"/>
                    
                    <!-- Dark mode detection handled by app.js -->
                </head>
                
                <body class="h-full bg-gray-50 dark:bg-gray-900 font-inter antialiased">
                    <!-- Skip to main content for accessibility -->
                    <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-blue-600 text-white px-4 py-2 rounded-md">
                        Skip to main content
                    </a>
                    
                    <!-- Theme toggle button -->
                    <div class="fixed top-4 right-4 z-50">
                        <button 
                            id="theme-toggle"
                            type="button"
                            class="p-2 text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-200 dark:focus:ring-gray-700 transition-colors"
                            title="Toggle dark mode">
                            <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                            </svg>
                            <svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Main content -->
                    <main id="main-content" class="h-full">
                        ${assigns.inner_content}
                    </main>
                    
                    <!-- Dark mode toggle handled by app.js -->
                </body>
            </html>
        ');
    }
    
}
</file>

<file path="examples/todo-app/src_haxe/server/live/SafeAssigns.hx">
package server.live;

import phoenix.Phoenix.Socket;
import phoenix.LiveSocket;
import server.live.TodoLive.TodoLiveAssigns;

// Bridge to the generated LiveView module for reuse of server-side helpers
@:native("TodoAppWeb.TodoLive")
extern class TodoLiveNative {
    public static function filter_and_sort_todos(
        todos: Array<server.schemas.Todo>,
        filter: shared.TodoTypes.TodoFilter,
        sortBy: shared.TodoTypes.TodoSort,
        searchQuery: String
    ): Array<server.schemas.Todo>;
}

/**
 * Type-safe socket assign operations for TodoLive using LiveSocket patterns
 * 
 * This class demonstrates how to use the Phoenix framework's LiveSocket
 * type-safe assign patterns. The LiveSocket provides compile-time validation
 * of field names WITHOUT needing Dynamic, cast, or string field names.
 * 
 * ## Architecture Benefits:
 * - **Compile-time field validation**: The `_.fieldName` pattern validates fields exist
 * - **No cast needed**: LiveSocket methods return properly typed sockets
 * - **No Dynamic needed**: Field access is validated at compile time
 * - **No strings for field names**: The underscore pattern provides type safety
 * - **Automatic camelCase conversion**: Field names are converted to snake_case for Phoenix
 * - **IntelliSense support**: Full IDE autocomplete for all operations
 * 
 * ## Usage Patterns:
 * ```haxe
 * // Type-safe individual assignments with _.fieldName pattern
 * var liveSocket: LiveSocket<TodoLiveAssigns> = socket;
 * socket = liveSocket.assign(_.editingTodo, todo);
 * socket = liveSocket.assign(_.selectedTags, tags);
 * 
 * // Type-safe bulk assignments with merge
 * socket = liveSocket.merge({
 *     todos: newTodos,
 *     totalTodos: newTodos.length,
 *     completedTodos: completed,
 *     pendingTodos: pending
 * });
 * ```
 * 
 * ## Why This Pattern Exists:
 * Phoenix LiveView uses dynamic assigns that could cause runtime errors.
 * The LiveSocket wrapper provides compile-time validation that:
 * 1. Fields exist in the assigns typedef
 * 2. Values match the expected types
 * 3. Field names are correctly converted to snake_case
 * 
 * This prevents the #1 source of LiveView bugs: typos in assign keys.
 * 
 * ## Future Improvements:
 * While the `_.fieldName` syntax works well, we're exploring more intuitive alternatives.
 * See [Future Assign Syntax Ideas](../../../docs/07-patterns/future-assign-syntax-ideas.md)
 * for proposals like typed field descriptors and fluent builders that might feel more natural.
 */
class SafeAssigns {
    
    /**
     * Set the editingTodo field using LiveSocket's type-safe assign pattern
     * 
     * The _.editingTodo syntax is validated at compile time to ensure:
     * - The field exists in TodoLiveAssigns
     * - The type matches (Null<Todo>)
     * - The field name is converted to :editing_todo in Elixir
     */
    public static function setEditingTodo(socket: Socket<TodoLiveAssigns>, todo: Null<server.schemas.Todo>): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(_.editing_todo, todo);
    }
    
    /**
     * Set the selectedTags field using LiveSocket's type-safe assign pattern
     */
    public static function setSelectedTags(socket: Socket<TodoLiveAssigns>, tags: Array<String>): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(_.selected_tags, tags);
    }
    
    /**
     * Set the filter field using LiveSocket's type-safe assign pattern
     */
    public static function setFilter(socket: Socket<TodoLiveAssigns>, filter: String): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(
            _.filter,
            switch (filter) {
                case "active": shared.TodoTypes.TodoFilter.Active;
                case "completed": shared.TodoTypes.TodoFilter.Completed;
                case _: shared.TodoTypes.TodoFilter.All;
            }
        );
    }
    
    /**
     * Set the sortBy field using LiveSocket's type-safe assign pattern
     */
    public static function setSortBy(socket: Socket<TodoLiveAssigns>, sortBy: String): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(
            _.sort_by,
            switch (sortBy) {
                case "priority": shared.TodoTypes.TodoSort.Priority;
                case "due_date": shared.TodoTypes.TodoSort.DueDate;
                case _: shared.TodoTypes.TodoSort.Created;
            }
        );
    }

    /**
     * Set sort_by only; caller should trigger recompute_visible afterwards.
     * This keeps SafeAssigns zero-logic and typed while avoiding
     * cross-module helper dependencies.
     */
    public static function setSortByAndResort(socket: Socket<TodoLiveAssigns>, sortBy: String): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(
            _.sort_by,
            switch (sortBy) {
                case "priority": shared.TodoTypes.TodoSort.Priority;
                case "due_date": shared.TodoTypes.TodoSort.DueDate;
                case _: shared.TodoTypes.TodoSort.Created;
            }
        );
    }
    
    /**
     * Set the searchQuery field using LiveSocket's type-safe assign pattern
     */
    public static function setSearchQuery(socket: Socket<TodoLiveAssigns>, query: String): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(_.search_query, query);
    }
    
    /**
     * Set the showForm field using LiveSocket's type-safe assign pattern
     */
    public static function setShowForm(socket: Socket<TodoLiveAssigns>, showForm: Bool): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(_.show_form, showForm);
    }
    
    /**
     * Update todos and automatically recalculate statistics
     * 
     * Uses LiveSocket's merge pattern for type-safe bulk updates.
     * The merge method validates all field names at compile time
     * and ensures type compatibility. No Dynamic, cast, or strings needed!
     */
    public static function updateTodosAndStats(socket: Socket<TodoLiveAssigns>, todos: Array<server.schemas.Todo>): Socket<TodoLiveAssigns> {
        var completed = countCompleted(todos);
        var pending = countPending(todos);
        
        // Use LiveSocket's type-safe merge for bulk updates
        return (cast socket: LiveSocket<TodoLiveAssigns>).merge({
            todos: todos,
            total_todos: todos.length,
            completed_todos: completed,
            pending_todos: pending
        });
    }
    
    /**
     * Update just the todos list without stats recalculation
     * 
     * Uses LiveSocket's assign pattern for single field update.
     */
    public static function setTodos(socket: Socket<TodoLiveAssigns>, todos: Array<server.schemas.Todo>): Socket<TodoLiveAssigns> {
        return (cast socket: LiveSocket<TodoLiveAssigns>).assign(_.todos, todos);
    }
    
    /**
     * Helper function to count completed todos
     */
    private static function countCompleted(todos: Array<server.schemas.Todo>): Int {
        var count = 0;
        for (todo in todos) {
            if (todo.completed) count++;
        }
        return count;
    }
    
    /**
     * Helper function to count pending todos
     */
    private static function countPending(todos: Array<server.schemas.Todo>): Int {
        var count = 0;
        for (todo in todos) {
            if (!todo.completed) count++;
        }
        return count;
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/live/TodoLive.hx">
package server.live;

import HXX; // Import HXX for template rendering
import ecto.Changeset; // Import Ecto Changeset from the correct location
import ecto.Query; // Import Ecto Query from the correct location
import elixir.Task; // Background work via Task.start
import haxe.functional.Result; // Import Result type properly
import phoenix.LiveSocket; // Type-safe socket wrapper
import phoenix.types.Flash.FlashType;
import phoenix.Phoenix.HandleEventResult;
import phoenix.Phoenix.HandleInfoResult;
import phoenix.Phoenix.LiveView; // Use the comprehensive Phoenix module version
import phoenix.Phoenix.MountResult;
import phoenix.Phoenix.Socket;
import phoenix.Presence; // Import Presence module for PresenceEntry typedef
import server.infrastructure.Repo; // Import the TodoApp.Repo module
import server.live.SafeAssigns;
import server.presence.TodoPresence;
import server.pubsub.TodoPubSub.TodoPubSubMessage;
import server.pubsub.TodoPubSub.TodoPubSubTopic;
import server.pubsub.TodoPubSub;
import server.schemas.Todo;
import server.types.Types.BulkOperationType;
import server.types.Types.EventParams;
import server.types.Types.MountParams;
import server.types.Types.PubSubMessage;
import server.types.Types.Session;
import server.types.Types.User;

using StringTools;

/**
 * Type-safe event definitions for TodoLive.
 * 
 * This enum replaces string-based events with compile-time validated ADTs.
 * Each event variant carries its own strongly-typed parameters.
 * 
 * Benefits:
 * - Compile-time validation of event names
 * - Type-safe parameters for each event
 * - Exhaustiveness checking in handle_event
 * - IntelliSense/autocomplete support
 * - No Dynamic types or manual conversions
 */
enum TodoLiveEvent {
    // Todo CRUD operations
    CreateTodo(params: server.schemas.Todo.TodoParams);
    ToggleTodo(id: Int);
    DeleteTodo(id: Int);
    EditTodo(id: Int);
    SaveTodo(params: server.schemas.Todo.TodoParams);
    CancelEdit;
    
    // Filtering and sorting
    FilterTodos(filter: String);
    SortTodos(sortBy: String);
    SearchTodos(query: String);
    ToggleTag(tag: String);
    
    // Priority management
    SetPriority(id: Int, priority: String);
    
    // UI interactions
    ToggleForm;
    
    // Bulk operations
    BulkComplete;
    BulkDeleteCompleted;
}

/**
 * Type-safe assigns structure for TodoLive socket
 * 
 * This structure defines all the state that can be stored in the LiveView socket.
 * Using this typedef ensures compile-time type safety for all socket operations.
 */
typedef TodoLiveAssigns = {
	var todos: Array<server.schemas.Todo>;
	var filter: shared.TodoTypes.TodoFilter; // All | Active | Completed
	var sort_by: shared.TodoTypes.TodoSort;  // Created | Priority | DueDate
	var current_user: User;
	var editing_todo: Null<server.schemas.Todo>;
	var show_form: Bool;
	var search_query: String;
	var selected_tags: Array<String>;
    // Optimistic UI state: ids currently flipped client-first, pending server reconcile
    /**
     * optimistic_toggle_ids
     *
     * WHAT
     * - Minimal optimistic state (ids only) for instant checkbox flips.
     *
     * WHY
     * - Keep UX snappy for idempotent single-field toggles without duplicating rows.
     *
     * HOW
     * - On toggle, push id here and recompute rows so completed_for_view reflects the change.
     *   Persist to DB and reconcile via PubSub broadcast of the authoritative row.
     */
    var optimistic_toggle_ids: Array<Int>;
    // Precomputed view rows for HXX (zero-logic rendering)
    var visible_todos: Array<TodoView>;
	// Statistics
	var total_todos: Int;
	var completed_todos: Int;
	var pending_todos: Int;
	// Presence tracking (idiomatic Phoenix pattern: single flat map)
    var online_users: Map<String, phoenix.Presence.PresenceEntry<server.presence.TodoPresence.PresenceMeta>>;
    // UI convenience fields for zero-logic HXX
    var visible_count: Int;
    var filter_btn_all_class: String;
    var filter_btn_active_class: String;
    var filter_btn_completed_class: String;
    var sort_selected_created: Bool;
    var sort_selected_priority: Bool;
    var sort_selected_due_date: Bool;
}

/**
 * Row view model for HXX zero-logic rendering.
 * All derived fields are computed in Haxe, so HXX only binds assigns.
 */
typedef TodoView = {
    var id: Int;
    var title: String;
    var description: String;
    var completedForView: Bool;
    var completedStr: String;
    var domId: String;
    var containerClass: String;
    var titleClass: String;
    var descClass: String;
    var priority: String;
    var hasDue: Bool;
    var dueDisplay: String;
    var hasTags: Bool;
    var hasDescription: Bool;
    var isEditing: Bool;
    var tags: Array<String>;
}

/**
 * LiveView component for todo management with real-time updates
 */
@:native("TodoAppWeb.TodoLive")
@:liveview
class TodoLive {
	// All socket state is now defined in TodoLiveAssigns typedef for type safety
	
	/**
	 * Mount callback with type-safe assigns
	 * 
	 * The TAssigns type parameter will be inferred as TodoLiveAssigns from the socket parameter.
	 */
    public static function mount(_params: MountParams, session: Session, socket: phoenix.Phoenix.Socket<TodoLiveAssigns>): MountResult<TodoLiveAssigns> {
        // Prepare LiveSocket wrapper
        var sock: LiveSocket<TodoLiveAssigns> = (cast socket: LiveSocket<TodoLiveAssigns>);

        var currentUser = getUserFromSession(session);
        var todos = loadTodos(currentUser.id);

        var assigns: TodoLiveAssigns = {
            todos: todos,
            filter: shared.TodoTypes.TodoFilter.All,
            sort_by: shared.TodoTypes.TodoSort.Created,
            current_user: currentUser,
            editing_todo: null,
            show_form: false,
            search_query: "",
            selected_tags: [],
            optimistic_toggle_ids: [],
            visible_todos: [],
            visible_count: 0,
            filter_btn_all_class: filterBtnClass(shared.TodoTypes.TodoFilter.All, shared.TodoTypes.TodoFilter.All),
            filter_btn_active_class: filterBtnClass(shared.TodoTypes.TodoFilter.All, shared.TodoTypes.TodoFilter.Active),
            filter_btn_completed_class: filterBtnClass(shared.TodoTypes.TodoFilter.All, shared.TodoTypes.TodoFilter.Completed),
            sort_selected_created: sortSelected(shared.TodoTypes.TodoSort.Created, shared.TodoTypes.TodoSort.Created),
            sort_selected_priority: sortSelected(shared.TodoTypes.TodoSort.Created, shared.TodoTypes.TodoSort.Priority),
            sort_selected_due_date: sortSelected(shared.TodoTypes.TodoSort.Created, shared.TodoTypes.TodoSort.DueDate),
            total_todos: todos.length,
            completed_todos: countCompleted(todos),
            pending_todos: countPending(todos),
            online_users: new Map()
        };

        sock = LiveView.assignMultiple(sock, assigns);
        var ls: LiveSocket<TodoLiveAssigns> = recomputeVisible(sock);
        return Ok(ls);
    }
	
	/**
	 * Handle events with fully typed event system.
	 * 
	 * No more string matching or Dynamic params!
	 * Each event carries its own typed parameters.
	 */
    public static function handleEvent(event: TodoLiveEvent, socket: Socket<TodoLiveAssigns>): HandleEventResult<TodoLiveAssigns> {
        var resultSocket = switch (event) {
            // Todo CRUD operations - params are already typed!
            case CreateTodo(params):
                createTodo(params, socket);
			
			case ToggleTodo(id):
				toggleTodoStatus(id, socket);
			
            case DeleteTodo(id):
                trace('[TodoLive] handleEvent DeleteTodo');
                deleteTodo(id, socket);
			
			case EditTodo(id):
				startEditing(id, socket);
			
			case SaveTodo(params):
				saveEditedTodoTyped(params, socket);
			
            case CancelEdit:
                // Clear editing state and recompute view
                recomputeVisible(SafeAssigns.setEditingTodo(socket, null));
			
			// Filtering and sorting
            case FilterTodos(filter):
                recomputeVisible(SafeAssigns.setFilter(socket, filter));
			
            case SortTodos(sortBy):
                recomputeVisible(SafeAssigns.setSortByAndResort(socket, sortBy));
			
            case SearchTodos(query):
                recomputeVisible(SafeAssigns.setSearchQuery(socket, query));
			
            case ToggleTag(tag):
                // Inline toggleTagFilter to avoid relying on helper emission ordering
                // Compute toggled tags list deterministically
                var currentlySelected = socket.assigns.selected_tags;
                var newSelected = currentlySelected.contains(tag)
                    ? currentlySelected.filter(function(t) return t != tag)
                    : currentlySelected.concat([tag]);
                recomputeVisible(SafeAssigns.setSelectedTags(socket, newSelected));
			
			// Priority management
            case SetPriority(id, priority):
                updateTodoPriority(id, priority, socket);
			
			// UI interactions
            case ToggleForm:
                recomputeVisible(SafeAssigns.setShowForm(socket, !socket.assigns.show_form));
			
			// Bulk operations
            case BulkComplete:
                completeAllTodos(socket);
			
            case BulkDeleteCompleted:
                deleteCompletedTodos(socket);
			
			// No default case needed - compiler ensures exhaustiveness!
		};
		
		return NoReply(resultSocket);
	}
	
	/**
	 * Handle real-time updates from other users with type-safe assigns
	 * 
	 * The TAssigns type parameter will be inferred as TodoLiveAssigns from the socket parameter.
	 */
    public static function handleInfo(msg: PubSubMessage, socket: Socket<TodoLiveAssigns>): HandleInfoResult<TodoLiveAssigns> {
        // Handle PubSub messages with a two-step match to avoid alias churn
        return switch (TodoPubSub.parseMessage(msg)) {
            case Some(payload):
                switch (payload) {
                    case TodoCreated(_created):
                        NoReply(
                            recomputeVisible(
                                (cast socket: LiveSocket<TodoLiveAssigns>)
                                    .merge({ todos: loadTodos(socket.assigns.current_user.id) })
                            )
                        );
                    case TodoUpdated(todo):
                        NoReply(recomputeVisible(updateTodoInList(todo, socket)));
                    case TodoDeleted(id):
                        NoReply(recomputeVisible(removeTodoFromList(id, socket)));
                    case BulkUpdate(action):
                        switch (action) {
                            case CompleteAll, DeleteCompleted:
                                NoReply(
                                    recomputeVisible(
                                        (cast socket: LiveSocket<TodoLiveAssigns>).merge({
                                            todos: loadTodos(socket.assigns.current_user.id),
                                            total_todos: loadTodos(socket.assigns.current_user.id).length,
                                            completed_todos: countCompleted(loadTodos(socket.assigns.current_user.id)),
                                            pending_todos: countPending(loadTodos(socket.assigns.current_user.id))
                                        })
                                    )
                                );
                            case SetPriority(_):
                                NoReply(socket);
                            case AddTag(_):
                                NoReply(socket);
                            case RemoveTag(_):
                                NoReply(socket);
                        }
                    case UserOnline(_):
                        NoReply(socket);
                    case UserOffline(_):
                        NoReply(socket);
                    case SystemAlert(_message, _level):
                        NoReply(socket);
                }
            case None:
                trace("Received unknown PubSub message: " + msg);
                NoReply(socket);
        };
    }

	// Legacy function for backward compatibility - will be removed
	static function createNewTodo(params: EventParams, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
		// Convert EventParams (with String dates) to TodoParams (with Date type)
		var todoParams: server.schemas.Todo.TodoParams = {
			title: params.title,
			description: params.description,
			completed: false,
			priority: params.priority != null ? params.priority : "medium",
			dueDate: params.dueDate != null ? Date.fromString(params.dueDate) : null,
			tags: params.tags != null ? parseTags(params.tags) : [],
            userId: socket.assigns.current_user.id
		};
		
		// Pass the properly typed TodoParams to changeset
		var changeset = server.schemas.Todo.changeset(new server.schemas.Todo(), todoParams);
		
		// Use type-safe Repo operations
		switch (Repo.insert(changeset)) {
			case Ok(todo):
				// Best-effort broadcast; ignore result
				TodoPubSub.broadcast(TodoUpdates, TodoCreated(todo));
				
				var todos = [todo].concat(socket.assigns.todos);
				// Use LiveSocket for type-safe assigns manipulation
        var liveSocket: LiveSocket<TodoLiveAssigns> = socket;
				var updatedSocket = liveSocket.merge({
					todos: todos,
					show_form: false
				});
                    return LiveView.putFlash(updatedSocket, FlashType.Success, "Todo created successfully!");
				
			case Error(reason):
                    return LiveView.putFlash(socket, FlashType.Error, "Failed to create todo: " + reason);
		}
	}

    /**
     * Create a new todo using typed TodoParams.
     */
    static function createTodo(params: server.schemas.Todo.TodoParams, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        // LiveView form params arrive as a map with string keys; extract safely.
        var rawTitle: Null<String> = Reflect.field(params, "title");
        var rawDesc: Null<String> = Reflect.field(params, "description");
        var rawPriority: Null<String> = Reflect.field(params, "priority");
        var rawDue: Null<String> = Reflect.field(params, "due_date");
        var rawTags: Null<String> = Reflect.field(params, "tags");

        // Normalize values and convert shapes
        var title = (rawTitle != null) ? rawTitle : "";
        var description = (rawDesc != null) ? rawDesc : "";
        var priority = (rawPriority != null && rawPriority != "") ? rawPriority : "medium";
        var tagsArr: Array<String> = (rawTags != null && rawTags != "") ? parseTags(rawTags) : [];

        // Build a params object with camelCase keys; normalize to snake_case + proper types via std helper
        var rawParams: Dynamic = {
            title: title,
            description: description,
            completed: false,
            priority: priority,
            dueDate: (rawDue != null && rawDue != "") ? rawDue : null,
            tags: tagsArr,
            userId: socket.assigns.current_user.id
        };
        var todoStruct = new server.schemas.Todo();
        var permitted = ["title","description","completed","priority","due_date","tags","user_id"];
        var castParams: Dynamic = {
            title: title,
            description: description,
            completed: false,
            priority: priority,
            due_date: (rawDue != null && rawDue != "") ? ((rawDue.indexOf(":") == -1) ? (rawDue + " 00:00:00") : rawDue) : null,
            tags: tagsArr,
            user_id: socket.assigns.current_user.id
        };
        var cs = ecto.ChangesetTools.castWithStringFields(todoStruct, castParams, permitted);
        switch (Repo.insert(cs)) {
            case Ok(value):
                // Best-effort broadcast; ignore result
                TodoPubSub.broadcast(TodoUpdates, TodoCreated(value));
                var todos = [value].concat(socket.assigns.todos);
                var updated = LiveView.assignMultiple(socket, {
                    todos: todos,
                    show_form: false,
                    total_todos: socket.assigns.total_todos + 1,
                    pending_todos: socket.assigns.pending_todos + (value.completed ? 0 : 1),
                    completed_todos: socket.assigns.completed_todos + (value.completed ? 1 : 0)
                });
                var lsCreated: LiveSocket<TodoLiveAssigns> = recomputeVisible(updated);
                return LiveView.putFlash(lsCreated, FlashType.Success, "Todo created successfully!");
            case Error(_reason):
                return LiveView.putFlash(socket, FlashType.Error, "Failed to create todo");
        }
    }

/**
 * toggleTodoStatus
 *
 * WHAT
 * - Server-driven optimistic toggle with safe reconciliation.
 *
 * WHY
 * - Provide immediate user feedback while keeping LiveView authoritative.
 *
 * HOW
 * - Mark id as optimistic ‚Üí flip local row ‚Üí persist (Repo.update) ‚Üí broadcast TodoUpdated.
 *   handle_info updates the list with the authoritative record; on error we broadcast the
 *   current DB row to revert.
 */
static function toggleTodoStatus(id: Int, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
    var s: LiveSocket<TodoLiveAssigns> = (cast socket: LiveSocket<TodoLiveAssigns>);
    var ids = s.assigns.optimistic_toggle_ids;
    var contains = ids.indexOf(id) != -1;
    var computedIds = contains ? ids.filter(function(x) return x != id) : [id].concat(ids);
    var sOptimistic = s.assign(_.optimistic_toggle_ids, computedIds);
    // Also update the local todo immediately for instant visual feedback
    var local = findTodo(id, s.assigns.todos);
    if (local != null) {
        // Copy from existing struct and flip only the completed flag
        var toggled: server.schemas.Todo = local;
        toggled.completed = !local.completed;
        sOptimistic = updateTodoInList(toggled, sOptimistic);
    }
    // Persist synchronously; PubSub broadcast will reconcile actual state
    var db = Repo.get(server.schemas.Todo, id);
    if (db != null) {
        var updateResult = Repo.update(server.schemas.Todo.toggleCompleted(db));
        switch (updateResult) {
            case Ok(value):
                TodoPubSub.broadcast(TodoUpdates, TodoUpdated(value));
            case Error(_):
                // Best effort: revert optimistic UI by broadcasting current db state
                TodoPubSub.broadcast(TodoUpdates, TodoUpdated(db));
        }
    }
    return recomputeVisible(sOptimistic);
}

// Background reconcile for optimistic toggle
// Handle in-process persistence request in handleInfo
	
    static function deleteTodo(id: Int, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        trace("[TodoLive] deleteTodo id=" + id + ", before_count=" + socket.assigns.todos.length);
        var todo = findTodo(id, socket.assigns.todos);
        if (todo == null) return socket;
        
        // Perform delete. On error, show flash and exit; otherwise proceed.
        switch (Repo.delete(todo)) {
            case Ok(_):
                // continue
            case Error(_reason):
                return LiveView.putFlash(socket, FlashType.Error, "Failed to delete todo");
        }
        // Reflect locally, then broadcast best-effort to others
        var updated = removeTodoFromList(id, socket);
        TodoPubSub.broadcast(TodoUpdates, TodoDeleted(id));
        return recomputeVisible(updated);
    }
	
static function updateTodoPriority(id: Int, priority: String, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
    var todo = findTodo(id, socket.assigns.todos);
    if (todo == null) return socket;
    switch (Repo.update(server.schemas.Todo.updatePriority(todo, priority))) {
        case Ok(_):
        case Error(_reason):
            return LiveView.putFlash(socket, FlashType.Error, "Failed to update priority");
    }
    var refreshed = Repo.get(server.schemas.Todo, id);
    if (refreshed != null) {
        TodoPubSub.broadcast(TodoUpdates, TodoUpdated(refreshed));
        var s1 = updateTodoInList(refreshed, socket);
        return recomputeVisible(s1);
    }
    return socket;
}
	
	// List management helpers with type-safe socket handling
	static function addTodoToList(todo: server.schemas.Todo, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
		// Don't add if it's our own todo (already added)
		if (todo.userId == socket.assigns.current_user.id) {
			return socket;
		}
		
		var todos = [todo].concat(socket.assigns.todos);
		// Use LiveSocket for type-safe assigns manipulation
		var liveSocket: LiveSocket<TodoLiveAssigns> = socket;
		return liveSocket.merge({ todos: todos });
	}
	
	
    static function loadTodos(userId: Int): Array<server.schemas.Todo> {
        // Inline query to avoid ephemeral local renames
        return Repo.all(
            ecto.TypedQuery
                .from(server.schemas.Todo)
                .where(t -> t.userId == userId)
        );
    }
	
	static function findTodo(id: Int, todos: Array<server.schemas.Todo>): Null<server.schemas.Todo> {
		for (todo in todos) {
			if (todo.id == id) return todo;
		}
		return null;
	}
	
    static function countCompleted(todos: Array<server.schemas.Todo>): Int {
        // Prefer filter+length to enable Enum.count generation on Elixir
        return todos.filter(function(t) return t.completed).length;
    }
	
    static function countPending(todos: Array<server.schemas.Todo>): Int {
        // Prefer filter+length to enable Enum.count generation on Elixir
        return todos.filter(function(t) return !t.completed).length;
    }
	
    static function parseTags(tagsString: String): Array<String> {
		if (tagsString == null || tagsString == "") return [];
            return tagsString.split(",").map(function(t) return StringTools.trim(t));
    }
	
    static function getUserFromSession(session: Dynamic): User {
    // Robust nil-safe session handling: avoid Map.get on nil
    var uid: Int = if (session == null) {
        1;
    } else {
        var idVal: Null<Int> = Reflect.field(session, "user_id");
        idVal != null ? idVal : 1;
    };
    return {
        id: uid,
        name: "Demo User",
        email: "demo@example.com", 
        passwordHash: "hashed_password",
        confirmedAt: null,
        lastLoginAt: null,
        active: true
    };
}
	
	// Missing helper functions
	static function loadAndAssignTodos(socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
		var todos = loadTodos(socket.assigns.current_user.id);
		// Use LiveSocket's merge for type-safe bulk updates
		var liveSocket: LiveSocket<TodoLiveAssigns> = socket;
		return liveSocket.merge({
			todos: todos,
			total_todos: todos.length,
			completed_todos: countCompleted(todos),
			pending_todos: countPending(todos)
		});
	}
	
    static function updateTodoInList(todo: server.schemas.Todo, socket: LiveSocket<TodoLiveAssigns>): LiveSocket<TodoLiveAssigns> {
        var newTodos = socket.assigns.todos.map(function(t) return t.id == todo.id ? todo : t);
        return socket.merge({
            todos: newTodos,
            total_todos: newTodos.length,
            completed_todos: countCompleted(newTodos),
            pending_todos: countPending(newTodos)
        });
    }

    /**
     * Build typed view rows for zero-logic HXX rendering.
     */
    static function buildVisibleTodos(a: TodoLiveAssigns): Array<TodoView> {
        // Build from already-filtered/sorted list to keep map body purely a row constructor
        var base = filterAndSortTodos(a.todos, a.filter, a.sort_by, a.search_query, a.selected_tags);
        var optimistic = (a.optimistic_toggle_ids != null) ? a.optimistic_toggle_ids : [];
        return base.map(function(todoItem) return makeViewRow(a, optimistic, todoItem));
    }

    // Small, pure helper to keep Enum.map body simple and unambiguous for transforms
    static inline function makeViewRow(a: TodoLiveAssigns, optimisticIds: Array<Int>, t: server.schemas.Todo): TodoView {
        var flipped = optimisticIds.contains(t.id);
        var completedForView = flipped ? !t.completed : t.completed;
        var border = borderForPriority(t.priority);
        var containerClass = "bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 border-l-4 "
            + border
            + (completedForView ? " opacity-60" : "")
            + " transition-all hover:shadow-xl";
        var hasDue = (t.dueDate != null);
        var dueDisplay = hasDue ? format_due_date(t.dueDate) : "";
        var hasTags = (t.tags != null && t.tags.length > 0);
        var hasDescription = (t.description != null && t.description != "");
        var isEditing = (a.editing_todo != null && a.editing_todo.id == t.id);
        return {
            id: t.id,
            title: t.title,
            description: t.description,
            completedForView: completedForView,
            completedStr: completedForView ? "true" : "false",
            domId: "todo-" + Std.string(t.id),
            containerClass: containerClass,
            titleClass: "text-lg font-semibold text-gray-800 dark:text-white" + (completedForView ? " line-through" : ""),
            descClass: "text-gray-600 dark:text-gray-400 mt-1" + (completedForView ? " line-through" : ""),
            priority: t.priority,
            hasDue: hasDue,
            dueDisplay: dueDisplay,
            hasTags: hasTags,
            hasDescription: hasDescription,
            isEditing: isEditing,
            tags: (t.tags != null ? t.tags : [])
        };
    }

    /**
     * Recompute and merge visible_todos into assigns; returns a typed LiveSocket.
     */
    static function recomputeVisible(socket: Socket<TodoLiveAssigns>): LiveSocket<TodoLiveAssigns> {
        var ls: LiveSocket<TodoLiveAssigns> = socket;
        var rows = buildVisibleTodos(ls.assigns);
        // Precompute UI helpers
        var selected = ls.assigns.sort_by;
        var filter = ls.assigns.filter;
        return ls.merge({
            visible_todos: rows,
            visible_count: rows.length,
            filter_btn_all_class: filterBtnClass(filter, shared.TodoTypes.TodoFilter.All),
            filter_btn_active_class: filterBtnClass(filter, shared.TodoTypes.TodoFilter.Active),
            filter_btn_completed_class: filterBtnClass(filter, shared.TodoTypes.TodoFilter.Completed),
            sort_selected_created: sortSelected(selected, shared.TodoTypes.TodoSort.Created),
            sort_selected_priority: sortSelected(selected, shared.TodoTypes.TodoSort.Priority),
            sort_selected_due_date: sortSelected(selected, shared.TodoTypes.TodoSort.DueDate)
        });
    }
	
    static function removeTodoFromList(id: Int, socket: LiveSocket<TodoLiveAssigns>): LiveSocket<TodoLiveAssigns> {
        // Merge filtered list directly without intermediate locals
        return socket.merge({
            todos: socket.assigns.todos.filter(function(t) return t.id != id),
            total_todos: socket.assigns.todos.filter(function(t) return t.id != id).length,
            completed_todos: countCompleted(socket.assigns.todos.filter(function(t) return t.id != id)),
            pending_todos: countPending(socket.assigns.todos.filter(function(t) return t.id != id))
        });
    }
	
    static function startEditing(id: Int, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        // Update presence to show user is editing (idiomatic Phoenix pattern)
        return SafeAssigns.setEditingTodo(socket, findTodo(id, socket.assigns.todos));
    }
	
	// Bulk operations with type-safe socket handling
    static function completeAllTodos(socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        // Toggle completion using index loop to avoid enumerator rewrite edge cases
        var list = socket.assigns.todos;
        for (item in list) {
            if (!item.completed) {
                var cs = server.schemas.Todo.toggleCompleted(item);
                switch (Repo.update(cs)) { case Ok(_): case Error(_): }
            }
        }
        // Broadcast (best-effort)
        TodoPubSub.broadcast(TodoUpdates, BulkUpdate(CompleteAll));
        // Merge refreshed assigns inline
        var ls: LiveSocket<TodoLiveAssigns> = (cast socket: LiveSocket<TodoLiveAssigns>).merge({
                todos: loadTodos(socket.assigns.current_user.id),
                filter: socket.assigns.filter,
                sort_by: socket.assigns.sort_by,
                current_user: socket.assigns.current_user,
                editing_todo: socket.assigns.editing_todo,
                show_form: socket.assigns.show_form,
                search_query: socket.assigns.search_query,
                selected_tags: socket.assigns.selected_tags,
                total_todos: loadTodos(socket.assigns.current_user.id).length,
                completed_todos: loadTodos(socket.assigns.current_user.id).length,
                pending_todos: 0,
                online_users: socket.assigns.online_users
            });
        return LiveView.putFlash(ls, FlashType.Info, "All todos marked as completed!");
    }
	
    static function deleteCompletedTodos(socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        // Delete completed todos using index loop to avoid enumerator rewrite edge cases
        var list = socket.assigns.todos;
        for (item in list) {
            if (item.completed) Repo.delete(item);
        }
        // Notify others (best-effort)
        TodoPubSub.broadcast(TodoUpdates, BulkUpdate(DeleteCompleted));
        // Merge recomputed assigns inline
        var ls2: LiveSocket<TodoLiveAssigns> = (cast socket: LiveSocket<TodoLiveAssigns>).merge({
                todos: socket.assigns.todos.filter(function(t) return !t.completed),
                filter: socket.assigns.filter,
                sort_by: socket.assigns.sort_by,
                current_user: socket.assigns.current_user,
                editing_todo: socket.assigns.editing_todo,
                show_form: socket.assigns.show_form,
                search_query: socket.assigns.search_query,
                selected_tags: socket.assigns.selected_tags,
                total_todos: socket.assigns.todos.filter(function(t) return !t.completed).length,
                completed_todos: 0,
                pending_todos: socket.assigns.todos.filter(function(t) return !t.completed).length,
                online_users: socket.assigns.online_users
            });
        return LiveView.putFlash(ls2, FlashType.Info, "Completed todos deleted!");
    }
	
	// Additional helper functions with type-safe socket handling
	static function startEditingOld(id: Int, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
		var todo = findTodo(id, socket.assigns.todos);
		return SafeAssigns.setEditingTodo(socket, todo);
	}
	
	/**
	 * Save edited todo with typed parameters.
	 */
    static function saveEditedTodoTyped(params: server.schemas.Todo.TodoParams, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        if (socket.assigns.editing_todo == null) return socket;
        var todo = socket.assigns.editing_todo;
        // Inline computed title into changeset map to avoid local-binder rename mismatches
        switch (Repo.update(server.schemas.Todo.changeset(todo, {
            title: (Reflect.field(params, "title") != null)
                ? (cast Reflect.field(params, "title") : String)
                : todo.title
        }))) {
            case Ok(value):
                // Best-effort broadcast
                TodoPubSub.broadcast(TodoUpdates, TodoUpdated(value));
                var ls: LiveSocket<TodoLiveAssigns> = updateTodoInList(value, socket);
                ls = ls.assign(_.editing_todo, null);
                ls = recomputeVisible(ls);
                return ls;
            case Error(_):
                return LiveView.putFlash(socket, FlashType.Error, "Failed to update todo");
        }
    }

    // Optimistic helpers
    static inline function is_optimistically_toggled(assigns: TodoLiveAssigns, id: Int): Bool {
        return assigns.optimistic_toggle_ids != null && assigns.optimistic_toggle_ids.contains(id);
    }
    static inline function effective_completed(todo: server.schemas.Todo, assigns: TodoLiveAssigns): Bool {
        return is_optimistically_toggled(assigns, todo.id) ? !todo.completed : todo.completed;
    }

    // Local helpers to bridge typed enums ‚Üî UI strings
    static inline function card_class_for2(todo: server.schemas.Todo): String {
        var border = switch (todo.priority) {
            case "high": "border-red-500";
            case "low": "border-green-500";
            case "medium": "border-yellow-500";
            case _: "border-gray-300";
        };
        var base = "bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 border-l-4 "+ border;
        if (todo.completed) base += " opacity-60";
        return base + " transition-all hover:shadow-xl";
    }

    // Compatibility shim: legacy event handler expects create_todo_typed/2
    // Bridge dynamic params to strongly-typed TodoParams and delegate to createTodoTyped/2
    static function create_todo_typed(params: Dynamic, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        var rawTitle: Null<String> = Reflect.field(params, "title");
        var rawDesc: Null<String> = Reflect.field(params, "description");
        var rawPriority: Null<String> = Reflect.field(params, "priority");
        var rawDue: Null<String> = Reflect.field(params, "due_date");
        var rawTags: Null<String> = Reflect.field(params, "tags");

        var todoParams: server.schemas.Todo.TodoParams = {
            title: rawTitle != null ? rawTitle : "",
            description: rawDesc != null ? rawDesc : "",
            completed: false,
            priority: (rawPriority != null && rawPriority != "") ? rawPriority : "medium",
            dueDate: (rawDue != null && rawDue != "") ? Date.fromString(rawDue) : null,
            tags: (rawTags != null && rawTags != "") ? parseTags(rawTags) : [],
            userId: socket.assigns.current_user.id
        };
        return createTodo(todoParams, socket);
    }
    static inline function format_due_date(d: Dynamic): String {
        return d == null ? "" : Std.string(d);
    }
    static inline function encodeSort(s: shared.TodoTypes.TodoSort): String {
        return switch (s) { case Created: "created"; case Priority: "priority"; case DueDate: "due_date"; };
    }
    static inline function encodeFilter(f: shared.TodoTypes.TodoFilter): String {
        return switch (f) { case All: "all"; case Active: "active"; case Completed: "completed"; };
    }

    // Typed UI helpers (no inline HEEx ops in HXX)
    static inline function filterBtnClass(current: shared.TodoTypes.TodoFilter, expect: shared.TodoTypes.TodoFilter): String {
        // Build final class without intermediate locals to avoid underscore/rename hygiene issues
        return "px-4 py-2 rounded-lg font-medium transition-colors"
            + (current == expect
                ? " bg-blue-500 text-white"
                : " bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300");
    }
    static inline function sortSelected(current: shared.TodoTypes.TodoSort, expect: shared.TodoTypes.TodoSort): Bool {
        return current == expect;
    }
    static inline function boolToStr(b: Bool): String {
        return b ? "true" : "false";
    }
    static inline function cardId(id: Int): String {
        return "todo-" + Std.string(id);
    }
    static inline function borderForPriority(p: String): String {
        return switch (p) { case "high": "border-red-500"; case "medium": "border-yellow-500"; case "low": "border-green-500"; default: "border-gray-300"; };
    }
    static inline function cardClassFor(todo: server.schemas.Todo): String {
        return "bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 border-l-4 "
            + borderForPriority(todo.priority)
            + (todo.completed ? " opacity-60" : "")
            + " transition-all hover:shadow-xl";
    }
    static inline function titleClass(completed: Bool): String {
        return "text-lg font-semibold text-gray-800 dark:text-white"
            + (completed ? " line-through" : "");
    }
    static inline function descClass(completed: Bool): String {
        return "text-gray-600 dark:text-gray-400 mt-1"
            + (completed ? " line-through" : "");
    }
	
	// Legacy function for backward compatibility - will be removed
	static function saveEditedTodo(params: EventParams, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
		var todo = socket.assigns.editing_todo;
		if (todo == null) return socket;
		
		// Convert EventParams (with String dates) to TodoParams (with Date type)
		var todoParams: server.schemas.Todo.TodoParams = {
			title: params.title,
			description: params.description,
			priority: params.priority,
			dueDate: params.dueDate != null ? Date.fromString(params.dueDate) : null,
			tags: params.tags != null ? parseTags(params.tags) : null,
			completed: params.completed
		};
		var changeset = server.schemas.Todo.changeset(todo, todoParams);
		
		// Use type-safe Repo operations
		switch (Repo.update(changeset)) {
			case Ok(updatedTodo):
				// Best-effort broadcast
				TodoPubSub.broadcast(TodoUpdates, TodoUpdated(updatedTodo));
				
				var updatedSocket = updateTodoInList(updatedTodo, socket);
				// Convert to LiveSocket to use assign for single field
				var liveSocket: LiveSocket<TodoLiveAssigns> = updatedSocket;
				return liveSocket.assign(_.editing_todo, null);
				
			case Error(reason):
				return LiveView.putFlash(socket, FlashType.Error, "Failed to save todo");
		}
	}
	
	// Handle bulk update messages from PubSub with type-safe socket handling
	static function handleBulkUpdate(action: BulkOperationType, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        return switch (action) {
            case CompleteAll:
                // Reload todos and apply in a single merge without temporaries
                (cast socket: LiveSocket<TodoLiveAssigns>).merge({
                    todos: loadTodos(socket.assigns.current_user.id),
                    total_todos: loadTodos(socket.assigns.current_user.id).length,
                    completed_todos: countCompleted(loadTodos(socket.assigns.current_user.id)),
                    pending_todos: countPending(loadTodos(socket.assigns.current_user.id))
                });
            
            case DeleteCompleted:
                (cast socket: LiveSocket<TodoLiveAssigns>).merge({
                    todos: loadTodos(socket.assigns.current_user.id),
                    total_todos: loadTodos(socket.assigns.current_user.id).length,
                    completed_todos: countCompleted(loadTodos(socket.assigns.current_user.id)),
                    pending_todos: countPending(loadTodos(socket.assigns.current_user.id))
                });
			
			case SetPriority(priority):
				// Could handle bulk priority changes in future
				socket;
			
			case AddTag(tag):
				// Could handle bulk tag addition in future
				socket;
			
			case RemoveTag(tag):
				// Could handle bulk tag removal in future
				socket;
		};
	}
	
    static function toggleTagFilter(tag: String, socket: Socket<TodoLiveAssigns>): Socket<TodoLiveAssigns> {
        return SafeAssigns.setSelectedTags(
            socket,
            socket.assigns.selected_tags.contains(tag)
                ? socket.assigns.selected_tags.filter(function(t) return t != tag)
                : socket.assigns.selected_tags.concat([tag])
        );
    }
	
	/**
	 * Router action handlers for LiveView routes
	 * These are called when the router dispatches to specific actions
	 */
	
	/**
	 * Handle index route - main todo list view
	 */
	public static function index(): String {
		// For LiveView routes, these actions are typically handled through mount()
		// This is a placeholder implementation to satisfy the router validation
		return "index";
	}
	
	/**
	 * Handle show route - display a specific todo
	 */
	public static function show(): String {
		// Show specific todo - parameters would be passed through mount()
		return "show";
	}
	
	/**
	 * Handle edit route - edit a specific todo
	 */
	public static function edit(): String {
		// Edit specific todo - editing state would be handled in mount()
		return "edit";
	}
	
	/**
	 * Render function for the LiveView component
	 * This generates the HTML template that gets sent to the browser
	 */
    public static function render(assigns: TodoLiveAssigns): Dynamic {
        return HXX.hxx('
			<div class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-blue-900">
				<div id="root" class="container mx-auto px-4 py-8 max-w-6xl" phx-hook="Ping">
					
					<!-- Header -->
					<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-8 mb-8">
						<div class="flex justify-between items-center mb-6">
							<div>
								<h1 class="text-4xl font-bold text-gray-800 dark:text-white mb-2">
									üìù Todo Manager
								</h1>
								<p class="text-gray-600 dark:text-gray-400">
									Welcome, ${assigns.current_user.name}!
								</p>
							</div>
							
							<!-- Statistics -->
							<div class="flex space-x-6">
								<div class="text-center">
									<div class="text-3xl font-bold text-blue-600 dark:text-blue-400">
										${assigns.total_todos}
									</div>
									<div class="text-sm text-gray-600 dark:text-gray-400">Total</div>
								</div>
								<div class="text-center">
									<div class="text-3xl font-bold text-green-600 dark:text-green-400">
										${assigns.completed_todos}
									</div>
									<div class="text-sm text-gray-600 dark:text-gray-400">Completed</div>
								</div>
								<div class="text-center">
									<div class="text-3xl font-bold text-amber-600 dark:text-amber-400">
										${assigns.pending_todos}
									</div>
									<div class="text-sm text-gray-600 dark:text-gray-400">Pending</div>
								</div>
							</div>
						</div>
						
						<!-- Add Todo Button -->
						<button phx-click="toggle_form" data-testid="btn-new-todo" class="w-full py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-medium rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-200 shadow-md">
							${assigns.show_form ? "‚úñ Cancel" : "‚ûï Add New Todo"}
						</button>
					</div>
					
					<!-- New Todo Form -->
					<if {assigns.show_form}>
						<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8 border-l-4 border-blue-500">
							<form phx-submit="create_todo" class="space-y-4">
								<div>
									<label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
										Title *
									</label>
									<input type="text" name="title" required data-testid="input-title"
										class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
										placeholder="What needs to be done?" />
								</div>

								<div>
									<label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
										Description
									</label>
									<textarea name="description" rows="3"
										class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
										placeholder="Add more details..."></textarea>
								</div>

								<div class="grid grid-cols-2 gap-4">
									<div>
										<label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
											Priority
										</label>
										<select name="priority"
											class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white">
											<option value="low">Low</option>
											<option value="medium" selected>Medium</option>
											<option value="high">High</option>
										</select>
									</div>

									<div>
										<label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
											Due Date
										</label>
                            <input type="date" name="due_date"
                                placeholder="YYYY-MM-DD"
                                class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white" />
									</div>
								</div>

								<div>
									<label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
										Tags (comma-separated)
									</label>
									<input type="text" name="tags"
										class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
										placeholder="work, personal, urgent" />
								</div>

									<button type="submit" data-testid="btn-create-todo"
									class="w-full py-3 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 transition-colors shadow-md">
									‚úÖ Create Todo
								</button>
							</form>
						</div>
					</if>
					
					<!-- Filters and Search -->
					<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
						<div class="flex flex-wrap gap-4">
							<!-- Search -->
							<div class="flex-1 min-w-[300px]">
                            <form phx-change="search_todos" class="relative">
									<input type="search" name="query" value={@search_query}
										class="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
										placeholder="Search todos..." />
									<span class="absolute left-3 top-2.5 text-gray-400">üîç</span>
								</form>
							</div>
							
                        <!-- Filter Buttons -->
                        <div class="flex space-x-2">
                            <button phx-click="filter_todos" phx-value-filter="all" data-testid="btn-filter-all"
                                class={@filter_btn_all_class}>All</button>
                            <button phx-click="filter_todos" phx-value-filter="active" data-testid="btn-filter-active"
                                class={@filter_btn_active_class}>Active</button>
                            <button phx-click="filter_todos" phx-value-filter="completed" data-testid="btn-filter-completed"
                                class={@filter_btn_completed_class}>Completed</button>
                        </div>
							
							<!-- Sort Dropdown -->
							<div>
                            <select phx-change="sort_todos" name="sort_by"
                                class="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white">
                                <option value="created" selected={@sort_selected_created}>Sort by Date</option>
                                <option value="priority" selected={@sort_selected_priority}>Sort by Priority</option>
                                <option value="due_date" selected={@sort_selected_due_date}>Sort by Due Date</option>
                            </select>
							</div>
						</div>
					</div>
					
					<!-- Online Users Panel -->
                    <!-- Presence panel (optional) -->
					
					<!-- Bulk Actions -->
                    <!-- Bulk Actions (typed HXX) -->
                    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4 mb-6 flex justify-between items-center">
                        <div class="text-sm text-gray-600 dark:text-gray-400">
                            Showing #{@visible_count} of #{@total_todos} todos
                        </div>
                        <div class="flex space-x-2">
                            <button phx-click="bulk_complete"
                                class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-sm">‚úÖ Complete All</button>
                            <button phx-click="bulk_delete_completed" data-confirm="Are you sure you want to delete all completed todos?"
                                class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm">üóëÔ∏è Delete Completed</button>
                        </div>
                    </div>
					
					<!-- Todo List -->
                    <div id="todo-list" class="space-y-4">
                        <for {v in assigns.visible_todos}>
                            <if {v.is_editing}>
                                <div id={v.dom_id} data-testid="todo-card" data-completed={v.completed_str}
                                    class={v.container_class}>
                                    <form phx-submit="save_todo" class="space-y-4">
                                        <input type="text" name="title" value={v.title} required data-testid="input-title"
                                            class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white" />
                                        <textarea name="description" rows="2"
                                            class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white">#{v.description}</textarea>
                                        <div class="flex space-x-2">
                                            <button type="submit" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600">Save</button>
                                            <button type="button" phx-click="cancel_edit" class="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">Cancel</button>
                                        </div>
                                    </form>
                                </div>
                            <else>
                                <div id={v.dom_id} data-testid="todo-card" data-completed={v.completed_str}
                                    class={v.container_class}>
                                    <div class="flex items-start space-x-4">
                                        <!-- Checkbox -->
                                        <button type="button" phx-click="toggle_todo" phx-value-id={v.id} data-testid="btn-toggle-todo"
                                            class="mt-1 w-6 h-6 rounded border-2 border-gray-300 dark:border-gray-600 flex items-center justify-center hover:border-blue-500 transition-colors">
                                            <if {v.completed_for_view}>
                                                <span class="text-green-500">‚úì</span>
                                            </if>
                                        </button>

                                        <!-- Content -->
                                        <div class="flex-1">
                                            <h3 class={v.title_class}>
                                                #{v.title}
                                            </h3>
                                            <if {v.has_description}>
                                                <p class={v.desc_class}>
                                                    #{v.description}
                                                </p>
                                            </if>

                                            <!-- Meta info -->
                                            <div class="flex flex-wrap gap-2 mt-3">
                                                <span class="px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded text-xs">
                                                    Priority: #{v.priority}
                                                </span>
                                                <if {v.has_due}>
                                                    <span class="px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded text-xs">
                                                        Due: #{v.due_display}
                                                    </span>
                                                </if>
                                                <if {v.has_tags}>
                                                    <for {tag in v.tags}>
                                                        <button phx-click="search_todos" phx-value-query={tag}
                                                            class="px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-400 rounded text-xs hover:bg-blue-200">#{tag}</button>
                                                    </for>
                                                </if>
                                            </div>
                                        </div>

                                        <!-- Actions -->
                                        <div class="flex space-x-2">
                                            <button type="button" phx-click="edit_todo" phx-value-id={v.id} data-testid="btn-edit-todo"
                                                class="p-2 text-blue-600 hover:bg-blue-100 rounded-lg transition-colors">‚úèÔ∏è</button>
                                            <button type="button" phx-click="delete_todo" phx-value-id={v.id} data-testid="btn-delete-todo"
                                                class="p-2 text-red-600 hover:bg-red-100 rounded-lg transition-colors">üóëÔ∏è</button>
                                        </div>
                                    </div>
                                </div>
                            </if>
                        </for>
                    </div>
                </div>
            </div>
        ');
    }
	
	/**
	 * Render presence panel showing online users and editing status
	 * 
	 * Uses idiomatic Phoenix pattern: single presence map with all user state
	 */
    @:keep public static function renderPresencePanel(_onlineUsers: Map<String, phoenix.Presence.PresenceEntry<server.presence.TodoPresence.PresenceMeta>>): String {
        // TEMP: Presence panel disabled pending compiler Map iteration fix.
        // Keeps runtime clean while we finalize Presence iteration transform in AST pipeline.
        return "";
    }
	
	/**
	 * Render bulk actions section
	 */
    @:keep public static function renderBulkActions(assigns: TodoLiveAssigns): String {
		if (assigns.todos.length == 0) {
			return "";
		}
		
		var filteredCount = filterTodos(assigns.todos, assigns.filter, assigns.search_query).length;
		
		return '<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4 mb-6 flex justify-between items-center">
				<div class="text-sm text-gray-600 dark:text-gray-400">
					Showing ${filteredCount} of ${assigns.total_todos} todos
				</div>
				<div class="flex space-x-2">
					<button phx-click="bulk_complete"
						class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-sm">
						‚úÖ Complete All
					</button>
					<button phx-click="bulk_delete_completed" 
						data-confirm="Are you sure you want to delete all completed todos?"
						class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm">
						üóëÔ∏è Delete Completed
					</button>
				</div>
			</div>';
	}
	
	/**
	 * Render the todo list section
	 */
    @:keep public static function renderTodoList(assigns: TodoLiveAssigns): String {
		if (assigns.todos.length == 0) {
			return HXX.hxx('
				<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-16 text-center">
					<div class="text-6xl mb-4">üìã</div>
					<h3 class="text-xl font-semibold text-gray-800 dark:text-white mb-2">
						No todos yet!
					</h3>
					<p class="text-gray-600 dark:text-gray-400">
						Click "Add New Todo" to get started.
					</p>
				</div>
			');
		}
		
        var filteredTodos:Array<server.schemas.Todo> = filterAndSortTodos(
            assigns.todos,
            assigns.filter,
            assigns.sort_by,
            assigns.search_query,
            assigns.selected_tags
        );
        var todoItems:Array<String> = filteredTodos.map(function(todo) {
            return renderTodoItem(todo, assigns.editing_todo);
        });
        return todoItems.join("\n");
	}
	
	/**
	 * Render individual todo item
	 */
	static function renderTodoItem(todo: server.schemas.Todo, editingTodo: Null<server.schemas.Todo>): String {
		var isEditing = editingTodo != null && editingTodo.id == todo.id;
		var priorityColor = switch(todo.priority) {
			case "high": "border-red-500";
			case "medium": "border-yellow-500";
			case "low": "border-green-500";
			case _: "border-gray-300";
		};
		
		if (isEditing) {
			return '<div id="todo-${todo.id}" data-testid="todo-card" data-completed="${Std.string(todo.completed)}" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 border-l-4 ${priorityColor}">
					<form phx-submit="save_todo" class="space-y-4">
						<input type="text" name="title" value="${todo.title}" required data-testid="input-title"
							class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white" />
						<textarea name="description" rows="2"
							class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white">${todo.description}</textarea>
						<div class="flex space-x-2">
							<button type="submit" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600">
								Save
							</button>
							<button type="button" phx-click="cancel_edit" class="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">
								Cancel
							</button>
						</div>
					</form>
				</div>';
		} else {
			var completedClass = todo.completed ? "opacity-60" : "";
			var textDecoration = todo.completed ? "line-through" : "";
			var checkmark = todo.completed ? '<span class="text-green-500">‚úì</span>' : '';
			
			return '<div id="todo-${todo.id}" data-testid="todo-card" data-completed="${Std.string(todo.completed)}" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 border-l-4 ${priorityColor} ${completedClass} transition-all hover:shadow-xl">
					<div class="flex items-start space-x-4">
                        <!-- Checkbox -->
                            <button type="button" phx-click="toggle_todo" phx-value-id="${todo.id}" data-testid="btn-toggle-todo"
                                class="mt-1 w-6 h-6 rounded border-2 border-gray-300 dark:border-gray-600 flex items-center justify-center hover:border-blue-500 transition-colors">
                                ${checkmark}
                            </button>
						
						<!-- Content -->
						<div class="flex-1">
							<h3 class="text-lg font-semibold text-gray-800 dark:text-white ${textDecoration}">
								${todo.title}
							</h3>
							${todo.description != null && todo.description != "" ? 
								'<p class="text-gray-600 dark:text-gray-400 mt-1 ${textDecoration}">${todo.description}</p>' : 
								''}
							
							<!-- Meta info -->
							<div class="flex flex-wrap gap-2 mt-3">
								<span class="px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded text-xs">
									Priority: ${todo.priority}
								</span>
                                ${todo.dueDate != null ? 
                                    '<span class="px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded text-xs">Due: ${format_due_date(todo.dueDate)}</span>' : 
                                    ''}
								${renderTags(todo.tags)}
							</div>
						</div>
						
						<!-- Actions -->
						<div class="flex space-x-2">
                                            <button type="button" phx-click="edit_todo" phx-value-id="${todo.id}" data-testid="btn-edit-todo"
                                    class="p-2 text-blue-600 hover:bg-blue-100 rounded-lg transition-colors">
                                    ‚úèÔ∏è
                                </button>
                                            <button type="button" phx-click="delete_todo" phx-value-id="${todo.id}" data-testid="btn-delete-todo"
                                    class="p-2 text-red-600 hover:bg-red-100 rounded-lg transition-colors">
                                    üóëÔ∏è
                                </button>
						</div>
					</div>
				</div>';
		}
	}
	
	/**
	 * Render tags for a todo item
	 */
	static function renderTags(tags: Array<String>): String {
		if (tags == null || tags.length == 0) {
			return "";
		}
		
        var tagsNorm:Array<String> = (tags != null) ? tags : [];
        var tagElements:Array<String> = tagsNorm.map(function(tag) {
            return '<button phx-click="search_todos" phx-value-query="${tag}" class="px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-400 rounded text-xs hover:bg-blue-200">#${tag}</button>';
        });
        return tagElements.join("");
	}
	
	/**
	 * Helper to filter todos based on filter and search query
	 */
    static function filterTodos(todos: Array<server.schemas.Todo>, filter: shared.TodoTypes.TodoFilter, searchQuery: String): Array<server.schemas.Todo> {
        var base = switch (filter) {
            case Active: todos.filter(function(t) return !t.completed);
            case Completed: todos.filter(function(t) return t.completed);
            case All: todos;
        };
        var qlOpt: Null<String> = (searchQuery != null && searchQuery != "") ? searchQuery.toLowerCase() : null;
        return (qlOpt == null)
            ? base
            : base.filter(function(t) {
                var title = t.title != null ? t.title.toLowerCase() : "";
                var desc = t.description != null ? t.description.toLowerCase() : "";
                return title.indexOf(qlOpt) >= 0 || desc.indexOf(qlOpt) >= 0;
            });
    }
	
	/**
	 * Helper to filter and sort todos
	 */
    public static function filterAndSortTodos(todos: Array<server.schemas.Todo>, filter: shared.TodoTypes.TodoFilter, sortBy: shared.TodoTypes.TodoSort, searchQuery: String, selectedTags: Array<String>): Array<server.schemas.Todo> {
        var filtered = filterTodos(todos, filter, searchQuery);
        if (selectedTags != null && selectedTags.length > 0) {
            filtered = filtered.filter(function(t) {
                var tags = (t.tags != null) ? t.tags : [];
                for (sel in selectedTags) {
                    if (tags.indexOf(sel) != -1) return true;
                }
                return false;
            });
        }
        // Delegate sorting to std helper (emitted under app namespace), avoid app __elixir__
        return phoenix.Sorting.by(encodeSort(sortBy), filtered);
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/live/UserLive.hx">
package server.live;

import HXX; // Import HXX for template rendering
import contexts.Users.User;
import contexts.Users;
import ecto.Changeset;
import elixir.types.Result; // For type-safe error handling
import phoenix.LiveSocket; // Type-safe socket wrapper
import phoenix.Phoenix.LiveView; // Use the comprehensive Phoenix module version
import phoenix.Phoenix.Socket;

// HXX template calls are processed at compile-time by the Reflaxe.Elixir compiler

/**
 * Type-safe event definitions for UserLive.
 * 
 * This enum replaces string-based events with compile-time validated ADTs.
 * Each event variant carries its own strongly-typed parameters.
 */
enum UserLiveEvent {
    // User CRUD operations
    NewUser;
    EditUser(id: Int);
    SaveUser(params: {user: Dynamic}); // User form params
    DeleteUser(id: Int);
    
    // Search and filtering
    Search(params: {search_term: String});
    FilterStatus(params: {status: String});
    ClearSearch;
    
    // UI interactions
    Cancel;
}

/**
 * Type-safe assigns structure for UserLive socket
 */
typedef UserLiveAssigns = {
    var users: Array<User>;
    var selectedUser: Null<User>;
    var changeset: Changeset<User, Dynamic>;
    var searchTerm: String;
    var showForm: Bool;
}

/**
 * Phoenix LiveView for user management
 * Demonstrates real-time user CRUD operations
 */
@:native("TodoAppWeb.UserLive")
@:liveview
class UserLive {
    static function mount(_params: Dynamic, _session: Dynamic, socket: Socket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var users = Users.listUsers(null);
        var liveSocket: LiveSocket<UserLiveAssigns> = socket;
        
        return {
            status: "ok", 
            socket: liveSocket.merge({
                users: users,
                selectedUser: null,
                changeset: Users.changeUser(null),
                searchTerm: "",
                showForm: false
            })
        };
    }
    
    static function handleEvent(event: UserLiveEvent, socket: Socket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var liveSocket: LiveSocket<UserLiveAssigns> = socket;
        return switch(event) {
            case NewUser:
                handleNewUser(liveSocket);
                
            case EditUser(id):
                handleEditUser(id, liveSocket);
                
            case SaveUser(params):
                handleSaveUser(params, liveSocket);
                
            case DeleteUser(id):
                handleDeleteUser(id, liveSocket);
                
            case Search(params):
                handleSearch(params.search_term, liveSocket);
                
            case FilterStatus(params):
                handleFilterStatus(params.status, liveSocket);
                
            case ClearSearch:
                handleClearSearch(liveSocket);
                
            case Cancel:
                handleCancel(liveSocket);
        }
    }
    
    static function handleNewUser(socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var changeset = Users.changeUser(null);
        var selectedUser = null;
        var showForm = true;
        
        return {
            status: "noreply",
            socket: socket.merge({
                changeset: changeset,
                selectedUser: selectedUser,
                showForm: showForm
            })
        };
    }
    
    static function handleEditUser(userId: Int, socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var selectedUser = Users.getUser(userId);
        var changeset = Users.changeUser(selectedUser);
        var showForm = true;
        
        return {
            status: "noreply",
            socket: socket.merge({
                selectedUser: selectedUser,
                changeset: changeset,
                showForm: showForm
            })
        };
    }
    
    static function handleSaveUser(params: {user: Dynamic}, socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var userParams = params.user;
        var selectedUser = socket.assigns.selectedUser;
        var result = selectedUser == null 
            ? Users.createUser(userParams)
            : Users.updateUser(selectedUser, userParams);
            
        return switch(result) {
            case Ok(user):
                // Successfully created/updated user
                var users = Users.listUsers(null);
                
                {
                    status: "noreply",
                    socket: socket.merge({
                        users: users,
                        showForm: false,
                        selectedUser: null,
                        changeset: Users.changeUser(null)
                    })
                };
                
            case Error(changeset):
                // Validation errors in changeset
                {
                    status: "noreply",
                    socket: socket.assign(_.changeset, changeset)
                };
        }
    }
    
    static function handleDeleteUser(userId: Int, socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var user = Users.getUser(userId);
        var result = Users.deleteUser(user);
        
        return switch(result) {
            case Ok(deletedUser):
                // Successfully deleted user
                var users = Users.listUsers(null);
                {
                    status: "noreply",
                    socket: socket.assign(_.users, users)
                };
                
            case Error(changeset):
                // Failed to delete (e.g., foreign key constraint)
                // Could add error message to socket here
                {status: "noreply", socket: socket};
        }
    }
    
    static function handleSearch(searchTerm: String, socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        // Use the new filtering functionality
        var filter = searchTerm.length > 0 
            ? {
                name: searchTerm,
                email: searchTerm,
                isActive: null
              }
            : null;
            
        var users = Users.listUsers(filter);
            
        return {
            status: "noreply",
            socket: socket.merge({
                users: users,
                searchTerm: searchTerm
            })
        };
    }
    
    static function handleFilterStatus(status: String, socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var filter = status.length > 0 
            ? {
                name: null,
                email: null,
                isActive: status == "active"
              }
            : null;
            
        var users = Users.listUsers(filter);
            
        return {
            status: "noreply",
            socket: socket.assign(_.users, users)
        };
    }
    
    static function handleClearSearch(socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        var users = Users.listUsers(null);
        
        return {
            status: "noreply",
            socket: socket.merge({
                users: users,
                searchTerm: ""
            })
        };
    }
    
    static function handleCancel(socket: LiveSocket<UserLiveAssigns>): {status: String, socket: Socket<UserLiveAssigns>} {
        return {
            status: "noreply",
            socket: socket.merge({
                showForm: false,
                selectedUser: null,
                changeset: Users.changeUser(null)
            })
        };
    }
    
    static function render(assigns: Dynamic): String {
        return HXX.hxx('
        <div class="min-h-screen bg-gray-50 py-8">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <!-- Header with gradient background -->
                <div class="bg-gradient-to-r from-blue-600 to-indigo-600 rounded-lg shadow-lg p-6 mb-8">
                    <div class="flex justify-between items-center">
                        <div>
                            <h1 class="text-3xl font-bold text-white">User Management</h1>
                            <p class="text-blue-100 mt-1">Manage your application users</p>
                        </div>
                        <button 
                            phx-click="new_user" 
                            class="bg-white text-blue-600 hover:bg-blue-50 px-6 py-3 rounded-lg font-semibold flex items-center gap-2 transition-colors shadow-md"
                        >
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                            </svg>
                            New User
                        </button>
                    </div>
                </div>
                
                <!-- Search and Filter Section -->
                <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="md:col-span-2">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Search Users</label>
                            <form phx-change="search" phx-submit="search">
                                <div class="relative">
                                    <input 
                                        name="search_term"
                                        value={@searchTerm}
                                        placeholder="Search by name or email..."
                                        type="text"
                                        class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                    />
                                    <svg class="absolute left-3 top-2.5 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                    </svg>
                                </div>
                            </form>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Filter by Status</label>
                            <select phx-change="filter_status" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                <option value="">All Users</option>
                                <option value="active">Active</option>
                                <option value="inactive">Inactive</option>
                            </select>
                        </div>
                    </div>
                    
                    <%= if @searchTerm != "" do %>
                        <div class="mt-4 flex items-center text-sm text-gray-600">
                            <span>Showing results for: <span class="font-semibold">{@searchTerm}</span></span>
                            <button phx-click="clear_search" class="ml-2 text-blue-600 hover:text-blue-800">Clear</button>
                        </div>
                    <% end %>
                </div>
                
                ${renderUserList(assigns)}
                ${renderUserForm(assigns)}
            </div>
        </div>
        ');
    }
    
    static function renderUserList(assigns: Dynamic): String {
        return HXX.hxx('
        <div class="bg-white rounded-lg shadow-md overflow-hidden">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Name
                        </th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Email
                        </th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Age
                        </th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Status
                        </th>
                        <th scope="col" class="relative px-6 py-3">
                            <span class="sr-only">Actions</span>
                        </th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                    <%= for user <- @users do %>
                        <tr class="hover:bg-gray-50 transition-colors">
                            <td class="px-6 py-4 whitespace-nowrap">
                                <div class="flex items-center">
                                    <div class="flex-shrink-0 h-10 w-10">
                                        <div class="h-10 w-10 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center text-white font-semibold">
                                            <%= String.first(user.name) %>
                                        </div>
                                    </div>
                                    <div class="ml-4">
                                        <div class="text-sm font-medium text-gray-900">
                                            <%= user.name %>
                                        </div>
                                    </div>
                                </div>
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap">
                                <div class="text-sm text-gray-900"><%= user.email %></div>
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap">
                                <div class="text-sm text-gray-900"><%= user.age %></div>
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap">
                                <%= if user.is_active do %>
                                    <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                                        Active
                                    </span>
                                <% else %>
                                    <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">
                                        Inactive
                                    </span>
                                <% end %>
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                <button 
                                    phx-click="edit_user" 
                                    phx-value-id={user.id}
                                    class="text-indigo-600 hover:text-indigo-900 mr-3"
                                >
                                    Edit
                                </button>
                                <button 
                                    phx-click="delete_user" 
                                    phx-value-id={user.id}
                                    data-confirm="Are you sure you want to delete this user?"
                                    class="text-red-600 hover:text-red-900"
                                >
                                    Delete
                                </button>
                            </td>
                        </tr>
                    <% end %>
                </tbody>
            </table>
            
            <%= if length(@users) == 0 do %>
                <div class="text-center py-12">
                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-900">No users found</h3>
                    <p class="mt-1 text-sm text-gray-500">
                        <%= if @searchTerm != "" do %>
                            Try adjusting your search criteria
                        <% else %>
                            Get started by creating a new user
                        <% end %>
                    </p>
                </div>
            <% end %>
    </div>
        ');
    }
    
    static function renderUserRow(assigns: Dynamic): String {
        var user = assigns.user;
        return HXX.hxx('
        <tr>
            <td>${user.name}</td>
            <td>${user.email}</td>
            <td>${user.age}</td>
            <td>
                <span class={getStatusClass(user.active)}>
                    ${getStatusText(user.active)}
                </span>
            </td>
            <td class="actions">
                <.button phx-click="edit_user" phx-value-id={user.id} size="sm">
                    Edit
                </.button>
                <.button 
                    phx-click="delete_user" 
                    phx-value-id={user.id} 
                    data-confirm="Are you sure?"
                    variant="danger"
                    size="sm"
                >
                    Delete
                </.button>
            </td>
        </tr>
        ');
    }
    
    /**
     * Get CSS class for user status
     */
    private static function getStatusClass(active: Bool): String {
        return active ? "status active" : "status inactive";
    }
    
    /**
     * Get display text for user status
     */
    private static function getStatusText(active: Bool): String {
        return active ? "Active" : "Inactive";
    }
    
    static function renderUserForm(assigns: Dynamic): String {
        if (!assigns.showForm) return "";
        
        return HXX.hxx('
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2><%= if @selectedUser, do: "Edit User", else: "New User" %></h2>
                    <button phx-click="cancel" class="close">&times;</button>
                </div>
                
                <.form for={@changeset} phx-submit="save_user">
                    <div class="form-group">
                        <.label for="name">Name</.label>
                        <.input field={@changeset[:name]} type="text" required />
                        <.error field={@changeset[:name]} />
                    </div>
                    
                    <div class="form-group">
                        <.label for="email">Email</.label>
                        <.input field={@changeset[:email]} type="email" required />
                        <.error field={@changeset[:email]} />
                    </div>
                    
                    <div class="form-group">
                        <.label for="age">Age</.label>
                        <.input field={@changeset[:age]} type="number" />
                        <.error field={@changeset[:age]} />
                    </div>
                    
                    <div class="form-group">
                        <.input 
                            field={@changeset[:active]} 
                            type="checkbox" 
                            label="Active"
                        />
                    </div>
                    
                    <div class="form-actions">
                        <.button type="submit">
                            <%= if @selectedUser, do: "Update", else: "Create" %> User
                        </.button>
                        <.button type="button" phx-click="cancel" variant="secondary">
                            Cancel
                        </.button>
                    </div>
                </.form>
            </div>
        </div>
        ');
    }
    
    // Main function for compilation testing
    public static function main(): Void {
        trace("UserLive with @:liveview annotation compiled successfully!");
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/migrations/CreateTodos.hx">
package server.migrations;

import ecto.Migration;
import ecto.Migration.*;

/**
 * Migration to create the todos table with proper indexes
 * 
 * Uses the new typed Migration DSL for compile-time validation
 * and idiomatic Elixir code generation.
 */
@:migration
class CreateTodos extends Migration {
    
    public function up(): Void {
        createTable("todos")
            .addColumn("title", String(), {nullable: false})
            .addColumn("description", Text)
            .addColumn("completed", Boolean, {defaultValue: false})
            .addColumn("priority", String())
            .addColumn("due_date", DateTime)
            .addColumn("tags", Json)
            .addColumn("user_id", Integer)
            .addTimestamps()
            .addIndex(["user_id"])
            .addIndex(["completed"]);
    }
    
    public function down(): Void {
        dropTable("todos");
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/migrations/CreateUsers.hx">
package server.migrations;

import ecto.Migration;
import ecto.Migration.*;

/**
 * Migration to create the users table with authentication fields
 * 
 * Uses the new typed Migration DSL for compile-time validation
 * and proper index/constraint generation.
 */
@:migration
class CreateUsers extends Migration {
    
    public function up(): Void {
        createTable("users")
            // User identification and profile fields
            .addColumn("name", String(), {nullable: false})
            .addColumn("email", String(), {nullable: false})
            
            // Authentication fields
            .addColumn("password_hash", String(), {nullable: false})
            .addColumn("confirmed_at", DateTime)
            .addColumn("last_login_at", DateTime)
            .addColumn("active", Boolean, {defaultValue: true})
            
            // Timestamps
            .addTimestamps()
            
            // Indexes for performance
            .addUniqueConstraint(["email"], "users_email_unique")
            .addIndex(["active"])
            .addIndex(["confirmed_at"])
            .addIndex(["last_login_at"])
            
            // Data integrity constraints
            .addCheckConstraint("email_format", "email ~ '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'")
            .addCheckConstraint("name_length", "length(name) >= 2");
    }
    
    public function down(): Void {
        dropTable("users");
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/presence/TodoPresence.hx">
package server.presence;

import phoenix.Phoenix.Socket;
import phoenix.Presence;
import phoenix.PresenceBehavior;
import phoenix.LiveSocket;
import server.types.Types.User;
import server.types.Types.PresenceTopic;
import server.types.Types.PresenceTopics;

/**
 * Unified presence metadata following idiomatic Phoenix patterns
 * 
 * In Phoenix apps, each user has a single presence entry with all their state.
 * This avoids complex nested structures and multiple presence topics.
 */
typedef PresenceMeta = {
    var onlineAt: Float;
    var userName: String;
    var userEmail: String;
    var avatar: Null<String>;
    // Editing state is part of the same presence entry (Phoenix pattern)
    var editingTodoId: Null<Int>;  // null = not editing, Int = editing todo ID
    var editingStartedAt: Null<Float>;  // When they started editing
}

// PresenceEntry is defined in phoenix.Presence module as a generic typedef
// This provides type-safe presence metadata across all Phoenix applications

/**
 * Idiomatic Phoenix Presence implementation with type-safe Haxe augmentation
 * 
 * This module follows standard Phoenix Presence patterns:
 * - Single presence entry per user (not multiple topics)
 * - All user state in one metadata structure
 * - Updates via Presence.update() rather than track/untrack
 * 
 * The generated Elixir code is indistinguishable from hand-written Phoenix,
 * but with compile-time type safety that Phoenix developers wish they had.
 * 
 * TYPE SAFETY PATTERNS:
 * 
 * Option 1: Use string constant (simple but less type-safe)
 * @:presenceTopic("users")
 * 
 * Option 2: Use static constant (better for shared topics)
 * static inline final TOPIC = "users";
 * @:presenceTopic(TOPIC)  // Note: This requires macro enhancement
 * 
 * Option 3: Use enum + helper (most type-safe, compile-time validation)
 * // Define topic in Types.hx enum, use string in annotation
 * @:presenceTopic("users")  // Must match PresenceTopic.Users mapping
 * 
 * The enum approach provides compile-time validation through the
 * PresenceTopics.toString() helper, ensuring consistency across the app.
 */
@:native("TodoAppWeb.Presence")
@:presence
@:presenceTopic("users")  // Must match PresenceTopics.toString(Users)
class TodoPresence implements PresenceBehavior {
    /**
     * Type-safe topic reference for compile-time validation
     * Use this to ensure consistency with the @:presenceTopic annotation
     */
    public static inline final TOPIC_ENUM = PresenceTopic.Users;
    public static inline final TOPIC = "users"; // Must match PresenceTopics.toString(TOPIC_ENUM)
    /**
     * Track a user's presence in the todo app (idiomatic Phoenix pattern)
     * 
     * Uses the new simplified API with class-level topic configuration.
     * 
     * @param socket The LiveView socket
     * @param user The user to track
     */
    public static function trackUser<T>(socket: Socket<T>, user: User): Socket<T> {
        var meta: PresenceMeta = {
            onlineAt: Date.now().getTime(),
            userName: user.name,
            userEmail: user.email,
            avatar: null,
            editingTodoId: null,  // Not editing initially
            editingStartedAt: null
        };
        // Use the simplified API - no need to pass topic!
        trackSimple(Std.string(user.id), meta);
        return socket;
    }
    
    /**
     * Update user's editing state (idiomatic Phoenix pattern)
     * 
     * Instead of track/untrack on different topics, we update the metadata
     * on the single user presence entry - this is the Phoenix way.
     * 
     * @param socket The LiveView socket
     * @param user The user whose state to update
     * @param todoId The todo being edited (null to stop editing)
     */
    public static function updateUserEditing<T>(socket: Socket<T>, user: User, todoId: Null<Int>): Socket<T> {
        // Update the metadata with new editing state (assume track happened elsewhere)
        var updatedMeta: PresenceMeta = {
            onlineAt: Date.now().getTime(),
            userName: user.name,
            userEmail: user.email,
            avatar: null,
            editingTodoId: todoId,
            editingStartedAt: todoId != null ? Date.now().getTime() : null
        };
        // Use the simplified API - topic is configured at class level
        updateSimple(Std.string(user.id), updatedMeta);
        return socket;
    }
    
    // Removed getUserPresence helper to avoid unused function warning in generated code when
    // presence update is simplified by transforms.
    
    /**
     * Get list of users currently online
     */
    public static function listOnlineUsers<T>(socket: Socket<T>): haxe.DynamicAccess<phoenix.Presence.PresenceEntry<PresenceMeta>> {
        // Use the generated listSimple() method
        return listSimple();
    }
    
    /**
     * Get users currently editing a specific todo (idiomatic Phoenix pattern)
     * 
     * Filters the single presence list by editing state rather than
     * querying separate topics - more maintainable and Phoenix-like.
     */
    public static function getUsersEditingTodo<T>(socket: Socket<T>, todoId: Int): Array<PresenceMeta> {
        // Get all users through the generated listSimple() method
        var allUsers = listSimple();
        var metas:Array<PresenceMeta> = [];
        for (userId in Reflect.fields(allUsers)) {
            var entry: phoenix.Presence.PresenceEntry<PresenceMeta> = Reflect.field(allUsers, userId);
            if (entry.metas.length > 0) {
                var meta = entry.metas[0];
                if (meta.editingTodoId == todoId) metas.push(meta);
            }
        }
        return metas;
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/pubsub/TodoPubSub.hx">
package server.pubsub;

import phoenix.SafePubSub;
import haxe.ds.Option;
import haxe.functional.Result;
import server.types.Types.TodoPriority;
import server.types.Types.BulkOperationType;
import server.types.Types.AlertLevel;

/**
 * Todo-app specific PubSub topics and messages with complete type safety
 * 
 * This module demonstrates how applications should extend the framework's
 * SafePubSub infrastructure with their own domain-specific types.
 * 
 * ## Usage Examples
 * 
 * ```haxe
 * // Type-safe broadcasting - IntelliSense shows all options
 * TodoPubSub.broadcast(TodoUpdates, TodoCreated(newTodo));
 * 
 * // Type-safe subscription
 * TodoPubSub.subscribe(UserActivity);
 * 
 * // Type-safe message parsing in LiveView handle_info
 * switch (TodoPubSub.parseMessage(msg)) {
 *     case Some(TodoCreated(todo)): addTodoToUI(todo);
 *     case Some(TodoUpdated(todo)): updateTodoInUI(todo);
 *     case None: trace("Unknown message");
 * }
 * ```
 * 
 * ## Compile-Time Safety Examples
 * 
 * ```haxe
 * // ‚ùå This will be caught at compile-time:
 * TodoPubSub.broadcast(TodoUpades, TodoCreated(todo)); // "Unknown constructor"
 * 
 * // ‚ùå This will be caught at compile-time:
 * TodoPubSub.broadcast(TodoUpdates, TodoCreated(null)); // "Missing argument"
 * 
 * // ‚úÖ This compiles and has IntelliSense support:
 * TodoPubSub.broadcast(TodoUpdates, TodoUpdated(updatedTodo));
 * ```
 */

/**
 * Type-safe PubSub topics for the todo application
 * 
 * Adding new topics requires:
 * 1. Add enum case here
 * 2. Add case to topicToString function
 * 3. Compiler ensures exhaustiveness
 */
enum TodoPubSubTopic {
    TodoUpdates;          // "todo:updates"
    UserActivity;         // "user:activity"  
    SystemNotifications;  // "system:notifications"
}

/**
 * Type-safe PubSub message types with compile-time validation
 * 
 * Each message type is strongly typed with required parameters.
 * Adding new messages requires updating parseMessage function.
 */
enum TodoPubSubMessage {
    TodoCreated(todo: server.schemas.Todo);
    TodoUpdated(todo: server.schemas.Todo);
    TodoDeleted(id: Int);
    BulkUpdate(action: BulkOperationType);
    UserOnline(user_id: Int);
    UserOffline(user_id: Int);
    SystemAlert(message: String, level: AlertLevel);
}

// BulkOperationType and AlertLevel are imported from server.types.Types

/**
 * Todo-app specific SafePubSub wrapper with complete type safety
 * 
 * This class provides a convenient API for the todo application while
 * using the framework's SafePubSub infrastructure underneath.
 */
class TodoPubSub {
    
    /**
     * Type-safe subscribe to a topic
     * 
     * @param topic Topic to subscribe to (with IntelliSense support)
     * @return Result indicating success or failure with descriptive error
     */
    public static function subscribe(topic: TodoPubSubTopic): Result<Void, String> {
        return SafePubSub.subscribeTopic(topicToString(topic));
    }
    
    /**
     * Type-safe broadcast with topic and message validation
     * 
     * @param topic Topic to broadcast to (compile-time validated)
     * @param message Message to broadcast (compile-time structure validated)
     * @return Result indicating success or failure with descriptive error
     */
    public static function broadcast(topic: TodoPubSubTopic, message: TodoPubSubMessage): Result<Void, String> {
        return SafePubSub.broadcastTopicPayload(topicToString(topic), messageToElixir(message));
    }
    
    /**
     * Parse incoming PubSub messages back to typed enums
     * 
     * @param msg Raw Dynamic message from Phoenix PubSub
     * @return Typed message or None if parsing failed
     * 
     * NOTE: This function should be auto-generated by macro in Phase 2.
     * Manual implementation ensures type safety until macro is available.
     */
    public static function parseMessage(msg: Dynamic): Option<TodoPubSubMessage> {
        // Pass an explicit function value to avoid capture/camelCase issues
        return SafePubSub.parseWithConverter(msg, (m) -> parseMessageImpl(m));
    }
    
    // ========================================================================
    // Private Implementation Functions
    // ========================================================================
    
    /**
     * Convert TodoPubSubTopic enum to string for Elixir compatibility
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function topicToString(topic: TodoPubSubTopic): String {
        return switch (topic) {
            case TodoUpdates: "todo:updates";
            case UserActivity: "user:activity";
            case SystemNotifications: "system:notifications";
        };
    }
    
    /**
     * Convert typed message to Dynamic object for Elixir PubSub
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function messageToElixir(message: TodoPubSubMessage): Dynamic {
        // Avoid ephemeral locals: build payload inline and add timestamp
        return SafePubSub.addTimestamp(switch (message) {
            case TodoCreated(todo):
                { type: "todo_created", todo: todo };
            case TodoUpdated(todo):
                { type: "todo_updated", todo: todo };
            case TodoDeleted(id):
                cast { type: "todo_deleted", todo_id: id };
            case BulkUpdate(action):
                cast { type: "bulk_update", action: bulkActionToString(action) };
            case UserOnline(user_id):
                cast { type: "user_online", user_id: user_id };
            case UserOffline(user_id):
                cast { type: "user_offline", user_id: user_id };
            case SystemAlert(message, level):
                cast { type: "system_alert", message: message, level: alertLevelToString(level) };
        });
    }
    
    /**
     * Parse Dynamic message to typed enum (implementation)
     * Note: Must be public to be passed as function reference in Elixir
     */
    public static function parseMessageImpl(msg: Dynamic): Option<TodoPubSubMessage> {
        if (!SafePubSub.isValidMessage(msg)) {
            trace(SafePubSub.createMalformedMessageError(msg));
            return None;
        }
        
        return switch (msg.type) {
            case "todo_created":
                if (msg.todo != null) Some(TodoCreated(msg.todo)) else None;
            case "todo_updated":
                if (msg.todo != null) Some(TodoUpdated(msg.todo)) else None;
            case "todo_deleted":
                if (msg.todo_id != null) Some(TodoDeleted(msg.todo_id)) else None;
            case "bulk_update":
                if (msg.action != null) {
                    return switch (msg.action) {
                        case "complete_all": Some(BulkUpdate(CompleteAll));
                        case "delete_completed": Some(BulkUpdate(DeleteCompleted));
                        case "set_priority": Some(BulkUpdate(SetPriority(TodoPriority.Medium)));
                        case "add_tag": Some(BulkUpdate(AddTag("")));
                        case "remove_tag": Some(BulkUpdate(RemoveTag("")));
                        case _: None;
                    };
                } else None;
            case "user_online":
                if (msg.user_id != null) Some(UserOnline(msg.user_id)) else None;
            case "user_offline":
                if (msg.user_id != null) Some(UserOffline(msg.user_id)) else None;
            case "system_alert":
                if (msg.message != null && msg.level != null) {
                    return switch (msg.level) {
                        case "info": Some(SystemAlert(msg.message, Info));
                        case "warning": Some(SystemAlert(msg.message, Warning));
                        case "error": Some(SystemAlert(msg.message, Error));
                        case "critical": Some(SystemAlert(msg.message, Critical));
                        case _: None;
                    };
                } else None;
            case _:
                trace(SafePubSub.createUnknownMessageError(msg.type));
                None;
        };
    }
    
    /**
     * Convert bulk action enum to string
     */
    private static function bulkActionToString(action: BulkOperationType): String {
        return switch (action) {
            case CompleteAll: "complete_all";
            case DeleteCompleted: "delete_completed";
            case SetPriority(priority): "set_priority";
            case AddTag(tag): "add_tag";
            case RemoveTag(tag): "remove_tag";
        };
    }
    
    /**
     * Parse bulk action string back to enum
     */
    @:keep private static function parseBulkAction(action: String): Null<BulkOperationType> {
        return switch (action) {
            case "complete_all": CompleteAll;
            case "delete_completed": DeleteCompleted;
            case "set_priority": SetPriority(TodoPriority.Medium);
            case "add_tag": AddTag("");
            case "remove_tag": RemoveTag("");
            case _: null;
        };
    }
    
    /**
     * Convert alert level enum to string
     */
    private static function alertLevelToString(level: AlertLevel): String {
        return switch (level) {
            case Info: "info";
            case Warning: "warning";  
            case Error: "error";
            case Critical: "critical";
        };
    }
    
    /**
     * Parse alert level string back to enum
     */
    @:keep private static function parseAlertLevel(level: String): Null<AlertLevel> {
        return switch (level) {
            case "info": Info;
            case "warning": Warning;  
            case "error": Error;
            case "critical": Critical;
            case _: null;
        };
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/schemas/Todo.hx">
package server.schemas;

import ecto.Changeset;
import haxe.ds.Option;

/**
 * Parameters for Todo changeset operations.
 * Strongly typed to avoid Dynamic usage.
 */
typedef TodoParams = {
	?title: String,
	?description: String,
	?completed: Bool,
	?priority: String,
	?dueDate: Date,
	?tags: Array<String>,
	?userId: Int
}

/**
 * Todo schema for managing tasks
 */
@:native("TodoApp.Todo")
@:schema("todos")
@:timestamps
class Todo {
	@:field public var id: Int;
	@:field public var title: String;
	@:field public var description: String;
	@:field public var completed: Bool = false;
	@:field public var priority: String = "medium"; // low, medium, high
	@:field public var dueDate: Null<Date>; // Type-safe nullable Date
	@:field public var tags: Array<String> = [];
	@:field public var userId: Int;
	
	public function new() {
		this.tags = [];
		this.completed = false;
		this.priority = "medium";
	}
	
    @:changeset
    public static function changeset(todo: Todo, params: TodoParams): Changeset<Todo, TodoParams> {
        // Fully typed pipeline: return idiomatic Ecto changeset without intermediate binders
        return new Changeset(todo, params)
            .validateRequired(["title", "userId"]) 
            .validateLength("title", {min: 3, max: 200})
            .validateLength("description", {max: 1000});
    }
	
	
	// Helper functions for business logic with proper types
	public static function toggleCompleted(todo: Todo): Changeset<Todo, TodoParams> {
		var params: TodoParams = {
			completed: !todo.completed
		};
		return changeset(todo, params);
	}
	
	public static function updatePriority(todo: Todo, priority: String): Changeset<Todo, TodoParams> {
		var params: TodoParams = {
			priority: priority
		};
		return changeset(todo, params);
	}
	
	public static function addTag(todo: Todo, tag: String): Changeset<Todo, TodoParams> {
		var tags: Array<String> = todo.tags != null ? todo.tags.copy() : [];
		tags.push(tag);
		var params: TodoParams = {
			tags: tags
		};
		return changeset(todo, params);
	}
}
</file>

<file path="examples/todo-app/src_haxe/server/schemas/User.hx">
package server.schemas;

import phoenix.Ecto;

/**
 * User schema for authentication and todo ownership
 * 
 * Provides a simple user model with basic authentication fields
 * and relationship to todos for user-specific task management.
 */
@:schema
@:timestamps
@:keep
class User {
    @:field public var id: Int;
    @:field public var name: String;
    @:field public var email: String;
    @:field public var passwordHash: String;
    @:field public var confirmedAt: Dynamic; // Date type for email confirmation
    @:field public var lastLoginAt: Dynamic; // Date type for tracking activity
    @:field public var active: Bool = true;
    
    // Virtual field for password input (not stored in database)
    @:virtual @:field public var password: String;
    @:virtual @:field public var passwordConfirmation: String;
    
    public function new() {
        this.active = true;
    }
    
    /**
     * Registration changeset for new user creation
     * Includes password validation and hashing
     */
    @:changeset
    @:keep
    public static function registrationChangeset(user: Dynamic, params: Dynamic): Dynamic {
        var changeset = phoenix.Ecto.EctoChangeset.castChangeset(user, params, [
            "name", "email", "password", "passwordConfirmation"
        ]);
        
        // Basic validations
        changeset = phoenix.Ecto.EctoChangeset.validate_required(changeset, ["name", "email", "password"]);
        changeset = phoenix.Ecto.EctoChangeset.validate_length(changeset, "name", {min: 2, max: 100});
        var emailPattern = ~/^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        changeset = phoenix.Ecto.EctoChangeset.validate_format(changeset, "email", emailPattern);
        changeset = phoenix.Ecto.EctoChangeset.validate_length(changeset, "password", {min: 8, max: 128});
        changeset = phoenix.Ecto.EctoChangeset.validate_confirmation(changeset, "password");
        changeset = phoenix.Ecto.EctoChangeset.unique_constraint(changeset, "email");
        
        // Hash password if valid
        if (phoenix.Ecto.EctoChangeset.get_change(changeset, "password") != null) {
            changeset = putPasswordHash(changeset);
        }
        
        return changeset;
    }
    
    /**
     * Update changeset for existing user modifications
     * Allows updating name and email without password changes
     */
    @:changeset
    @:keep
    public static function changeset(user: Dynamic, params: Dynamic): Dynamic {
        var changeset = phoenix.Ecto.EctoChangeset.castChangeset(user, params, [
            "name", "email", "active"
        ]);
        
        changeset = phoenix.Ecto.EctoChangeset.validate_required(changeset, ["name", "email"]);
        changeset = phoenix.Ecto.EctoChangeset.validate_length(changeset, "name", {min: 2, max: 100});
        changeset = phoenix.Ecto.EctoChangeset.validate_format(changeset, "email", {pattern: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$"});
        changeset = phoenix.Ecto.EctoChangeset.unique_constraint(changeset, "email");
        
        return changeset;
    }
    
    /**
     * Password change changeset for updating user passwords
     */
    @:changeset
    public static function passwordChangeset(user: Dynamic, params: Dynamic): Dynamic {
        var changeset = phoenix.Ecto.EctoChangeset.castChangeset(user, params, [
            "password", "passwordConfirmation"
        ]);
        
        changeset = phoenix.Ecto.EctoChangeset.validate_required(changeset, ["password"]);
        changeset = phoenix.Ecto.EctoChangeset.validate_length(changeset, "password", {min: 8, max: 128});
        changeset = phoenix.Ecto.EctoChangeset.validate_confirmation(changeset, "password");
        
        if (phoenix.Ecto.EctoChangeset.get_change(changeset, "password") != null) {
            changeset = putPasswordHash(changeset);
        }
        
        return changeset;
    }
    
    /**
     * Email confirmation changeset
     */
    public static function confirmChangeset(user: Dynamic): Dynamic {
        var changeset = phoenix.Ecto.EctoChangeset.change(user, {confirmedAt: now()});
        return changeset;
    }
    
    /**
     * Login tracking changeset
     */
    public static function loginChangeset(user: Dynamic): Dynamic {
        var changeset = phoenix.Ecto.EctoChangeset.change(user, {lastLoginAt: now()});
        return changeset;
    }
    
    // Helper functions for authentication
    
    /**
     * Hash password and put in changeset
     */
    static function putPasswordHash(changeset: Dynamic): Dynamic {
        var password = phoenix.Ecto.EctoChangeset.get_change(changeset, "password");
        if (password != null) {
            var hashed = hashPassword(password);
            return phoenix.Ecto.EctoChangeset.put_change(changeset, "passwordHash", hashed);
        }
        return changeset;
    }
    
    /**
     * Hash password using bcrypt (simplified for demo)
     * In production, would use proper bcrypt library
     */
    static function hashPassword(password: String): String {
        // In a real application, use Bcrypt.hash_pwd_salt(password)
        // For demo purposes, using a simple hash (NOT secure)
        return "hashed_" + password;
    }
    
    /**
     * Verify password against hash
     */
    public static function verifyPassword(user: Dynamic, password: String): Bool {
        // In a real application, use Bcrypt.verify_pass(password, user.passwordHash)
        // For demo purposes, simple verification
        return user.passwordHash == "hashed_" + password;
    }
    
    /**
     * Check if user is confirmed
     */
    public static function confirmed(user: Dynamic): Bool {
        return user.confirmedAt != null;
    }
    
    /**
     * Check if user is active
     */
    public static function active(user: Dynamic): Bool {
        return user.active == true;
    }
    
    /**
     * Get current timestamp
     */
    static function now(): Dynamic {
        // Would use DateTime.utc_now() in real Elixir
        return "2024-01-01T00:00:00Z"; // Demo timestamp
    }
    
    /**
     * Create a demo user for development
     */
    public static function createDemoUser(): Dynamic {
        return {
            id: 1,
            name: "Demo User",
            email: "demo@example.com",
            passwordHash: "hashed_demopassword",
            confirmedAt: now(),
            lastLoginAt: now(),
            active: true
        };
    }
    
    /**
     * Display name for user (for UI)
     */
    public static function displayName(user: Dynamic): String {
        return user.name != null && user.name != "" ? user.name : user.email;
    }
    
    /**
     * User initials for avatars
     */
    public static function initials(user: Dynamic): String {
        var name = displayName(user);
        var parts = name.split(" ");
        if (parts.length >= 2) {
            return parts[0].charAt(0).toUpperCase() + parts[1].charAt(0).toUpperCase();
        }
        return name.charAt(0).toUpperCase();
    }
}
</file>

<file path="examples/todo-app/src_haxe/server/services/UserGenServer.hx">
package services;

import contexts.Users;
import contexts.Users.User;

/**
 * OTP GenServer for user-related background processes
 * Demonstrates caching, background jobs, and user analytics
 */
@:genserver
class UserGenServer {
    var userCache: Map<Int, User> = new Map();
    var statsCache: Dynamic = null;
    var lastStatsUpdate: Float = 0;
    
    function init(initialState: Dynamic): {status: String, state: Dynamic} {
        // Initialize the GenServer with empty cache
        trace("UserGenServer starting...");
        
        // Schedule periodic stats refresh
        scheduleStatsRefresh();
        
        return {
            status: "ok",
            state: {
                userCache: userCache,
                statsCache: null,
                lastStatsUpdate: 0
            }
        };
    }
    
    function handle_call(request: String, from: Dynamic, state: Dynamic): CallResponse {
        return switch(request) {
            case "get_user":
                handleGetUser(from, state);
                
            case "get_stats":
                handleGetStats(from, state);
                
            case "cache_user":
                handleCacheUser(from, state);
                
            case "clear_cache":
                handleClearCache(from, state);
                
            default:
                {status: "reply", response: "unknown_request", state: state};
        }
    }
    
    function handle_cast(message: String, state: Dynamic): {status: String, state: Dynamic} {
        return switch(message) {
            case "refresh_stats":
                handleRefreshStats(state);
                
            case "invalidate_user_cache":
                handleInvalidateUserCache(state);
                
            case "preload_active_users":
                handlePreloadActiveUsers(state);
                
            default:
                {status: "noreply", state: state};
        }
    }
    
    function handle_info(message: String, state: Dynamic): {status: String, state: Dynamic} {
        return switch(message) {
            case "stats_refresh_timer":
                // Periodic stats refresh
                var newState = refreshUserStats(state);
                scheduleStatsRefresh(); // Reschedule
                {status: "noreply", state: newState};
                
            case "cleanup_cache":
                // Periodic cache cleanup
                var newState = cleanupOldCacheEntries(state);
                {status: "noreply", state: newState};
                
            default:
                {status: "noreply", state: state};
        }
    }
    
    // Call handlers
    function handleGetUser(from: Dynamic, state: Dynamic): CallResponse {
        var userId = from.userId; // Would extract from proper message format
        
        if (userCache.exists(userId)) {
            var user = userCache.get(userId);
            return {status: "reply", response: {user: user}, state: state};
        } else {
            // Load from database and cache
            var user = Users.get_user_safe(userId);
            if (user != null) {
                userCache.set(userId, user);
                return {status: "reply", response: {user: user}, state: updateState(state, "userCache", userCache)};
            } else {
                return {status: "reply", response: "user_not_found", state: state};
            }
        }
    }
    
    function handleGetStats(from: Dynamic, state: Dynamic): CallResponse {
        var now = Date.now().getTime();
        var cacheAge = now - lastStatsUpdate;
        
        // Return cached stats if less than 5 minutes old
        if (statsCache != null && cacheAge < 300000) {
            return {status: "reply", response: statsCache, state: state};
        } else {
            // Refresh stats and cache
            var stats = Users.user_stats();
            statsCache = stats;
            lastStatsUpdate = now;
            
            return {
                status: "reply", 
                response: stats, 
                state: updateStateMultiple(state, {
                    statsCache: stats,
                    lastStatsUpdate: now
                })
            };
        }
    }
    
    function handleCacheUser(from: Dynamic, state: Dynamic): CallResponse {
        var user = from.user; // Would extract from proper message format
        userCache.set(user.id, user);
        
        return {
            status: "reply",
            response: "cached",
            state: updateState(state, "userCache", userCache)
        };
    }
    
    function handleClearCache(from: Dynamic, state: Dynamic): CallResponse {
        userCache = new Map();
        statsCache = null;
        lastStatsUpdate = 0;
        
        return {
            status: "reply",
            response: "cache_cleared",
            state: {
                userCache: userCache,
                statsCache: null,
                lastStatsUpdate: 0
            }
        };
    }
    
    // Cast handlers
    function handleRefreshStats(state: Dynamic): {status: String, state: Dynamic} {
        var stats = Users.user_stats();
        statsCache = stats;
        lastStatsUpdate = Date.now().getTime();
        
        return {
            status: "noreply",
            state: updateStateMultiple(state, {
                statsCache: stats,
                lastStatsUpdate: lastStatsUpdate
            })
        };
    }
    
    function handleInvalidateUserCache(state: Dynamic): {status: String, state: Dynamic} {
        userCache = new Map();
        
        return {
            status: "noreply",
            state: updateState(state, "userCache", userCache)
        };
    }
    
    function handlePreloadActiveUsers(state: Dynamic): {status: String, state: Dynamic} {
        var activeUsers = Users.list_users({active: true});
        
        for (user in activeUsers) {
            userCache.set(user.id, user);
        }
        
        trace('Preloaded ${activeUsers.length} active users into cache');
        
        return {
            status: "noreply",
            state: updateState(state, "userCache", userCache)
        };
    }
    
    // Helper functions
    function refreshUserStats(state: Dynamic): Dynamic {
        var stats = Users.user_stats();
        return updateStateMultiple(state, {
            statsCache: stats,
            lastStatsUpdate: Date.now().getTime()
        });
    }
    
    function cleanupOldCacheEntries(state: Dynamic): Dynamic {
        // In a real implementation, would remove entries older than X time
        // For demo, just log cache size
        var keyArray = [for (key in userCache.keys()) key];
        trace('User cache contains ${keyArray.length} entries');
        return state;
    }
    
    function scheduleStatsRefresh(): Void {
        // Would schedule timer message - implementation varies by platform
        trace("Scheduling stats refresh in 5 minutes");
    }
    
    function updateState(state: Dynamic, key: String, value: Dynamic): Dynamic {
        // Helper to update state
        return state;
    }
    
    function updateStateMultiple(state: Dynamic, updates: Dynamic): Dynamic {
        // Helper to update multiple state fields
        return state;
    }
    
    // Main function for compilation testing
    public static function main(): Void {
        trace("UserGenServer with @:genserver annotation compiled successfully!");
    }
}

// Public API for interacting with UserGenServer
class UserService {
    static var serverName = "UserGenServer";
    
    public static function getCachedUser(userId: Int): User {
        // Would call GenServer.call(serverName, {:get_user, userId})
        return null;
    }
    
    public static function getUserStats(): Dynamic {
        // Would call GenServer.call(serverName, :get_stats)
        return null;
    }
    
    public static function cacheUser(user: User): Void {
        // Would call GenServer.cast(serverName, {:cache_user, user})
    }
    
    public static function refreshStats(): Void {
        // Would call GenServer.cast(serverName, :refresh_stats)
    }
    
    public static function clearCache(): Void {
        // Would call GenServer.call(serverName, :clear_cache)
    }
    
    // Main function for compilation testing
    public static function main(): Void {
        trace("UserGenServer with @:genserver annotation compiled successfully!");
    }
}

// Type definitions
typedef CallResponse = {
    status: String,
    response: Dynamic,
    state: Dynamic
}
</file>

<file path="examples/todo-app/src_haxe/server/types/LiveViewTypes.hx">
package types;

/**
 * Type definitions for Phoenix LiveView interactions
 */

// Socket type removed - use phoenix.Phoenix.Socket<T> or phoenix.LiveSocket<T> instead
// This avoids conflicts with the proper Phoenix LiveView extern

// Socket assigns structure
typedef SocketAssigns = {
    var todos: Array<schemas.Todo>;
    var filter: String;
    var sort_by: String;
    var current_user: User;
    var editing_todo: Null<schemas.Todo>;
    var show_form: Bool;
    var search_query: String;
    var selected_tags: Array<String>;
    var total_todos: Int;
    var completed_todos: Int;
    var pending_todos: Int;
}

// User type
typedef User = {
    var id: Int;
    var name: String;
    var email: String;
}

// Use the actual Todo schema from schemas.Todo
// We don't redefine it here to avoid conflicts

// Params for LiveView events
typedef EventParams = {
    ?id: Int,
    ?title: String,
    ?description: String,
    ?priority: String,
    ?due_date: String,
    ?tags: String,
    ?filter: String,
    ?sort_by: String,
    ?query: String,
    ?tag: String
}

// Message types for PubSub
typedef PubSubMessage = {
    var type: String;
    var ?todo: schemas.Todo;
    var ?id: Int;
    var ?action: String;
}

// Session type
typedef Session = {
    var ?user_id: Int;
    var ?token: String;
}

// Mount params
typedef MountParams = {
    var ?id: String;
    var ?action: String;
}

// Changeset type for Ecto
typedef Changeset = {
    var valid: Bool;
    var changes: {};
    var errors: Array<{field: String, message: String}>;
    var data: Any;
}

// Repo result types
typedef RepoResult<T> = {
    var success: Bool;
    var data: T;
    var ?error: String;
}
</file>

<file path="examples/todo-app/src_haxe/server/types/Types.hx">
package server.types;

/**
 * Comprehensive Phoenix LiveView types for the todo-app
 * 
 * These types provide full type safety for Phoenix LiveView interactions,
 * socket operations, event handling, and database operations.
 */

// ============================================================================
// Core Phoenix LiveView Types
// ============================================================================

/**
 * Enhanced User type matching the User schema
 */
typedef User = {
    var id: Int;
    var name: String;
    var email: String;
    var passwordHash: String;  // camelCase
    var confirmedAt: Null<Dynamic>;  // camelCase
    var lastLoginAt: Null<Dynamic>;  // camelCase
    var active: Bool;
}

// Socket type removed - use phoenix.Phoenix.Socket<T> instead
// This avoids conflicts with the proper Phoenix LiveView extern

/**
 * Socket assigns structure for type-safe assign access
 */
typedef SocketAssigns = {
    var todos: Array<server.schemas.Todo>;
    var filter: String;
    var sortBy: String;  // camelCase
    var currentUser: User;  // camelCase
    var editingTodo: Null<server.schemas.Todo>;  // camelCase
    var showForm: Bool;  // camelCase
    var searchQuery: String;  // camelCase
    var selectedTags: Array<String>;  // camelCase
    var totalTodos: Int;  // camelCase
    var completedTodos: Int;  // camelCase
    var pendingTodos: Int;  // camelCase
    var flash: FlashMessages;
}

/**
 * Flash message types
 */
typedef FlashMessages = {
    var ?info: String;
    var ?error: String;
    var ?success: String;
    var ?warning: String;
}

/**
 * Redirect options for navigation
 */
typedef RedirectOptions = {
    var ?to: String;
    var ?external: String;
}

/**
 * Patch options for live navigation  
 */
typedef PatchOptions = {
    var ?to: String;
    var ?replace: Bool;
}

// ============================================================================
// Event System Types  
// ============================================================================

/**
 * Comprehensive event parameters with validation
 */
typedef EventParams = {
    // Todo CRUD fields
    var ?id: Int;
    var ?title: String;
    var ?description: String;
    var ?priority: String;
    var ?dueDate: String;  // camelCase
    var ?tags: String;
    var ?completed: Bool;
    
    // UI interaction fields
    var ?filter: String;
    var ?sortBy: String;  // camelCase
    var ?query: String;
    var ?tag: String;
    var ?action: String;
    
    // Form validation metadata
    var ?_target: Array<String>;
    var ?_csrf_token: String;
    
    // Additional dynamic fields for extensibility
    var ?value: Dynamic;
    var ?key: String;
    var ?index: Int;
}

// ============================================================================
// Real-time Communication Types - TYPE-SAFE PUBSUB & PRESENCE
// ============================================================================

/**
 * Type-safe Presence topics - compile-time validation of presence channels
 * Use with @:presenceTopic annotation for type safety
 */
enum PresenceTopic {
    Users;           // "users" - Track online users
    EditingTodos;    // "editing:todos" - Track who's editing what
    ActiveRooms;     // "active:rooms" - Track active chat rooms
}

/**
 * Helper class for type-safe presence topic conversion
 * Provides compile-time validation while generating proper topic strings
 */
class PresenceTopics {
    /**
     * Convert a type-safe PresenceTopic to its string representation
     * for use with @:presenceTopic annotation
     */
    public static function toString(topic: PresenceTopic): String {
        return switch(topic) {
            case Users: "users";
            case EditingTodos: "editing:todos";
            case ActiveRooms: "active:rooms";
        }
    }
    
    /**
     * Parse a string back to PresenceTopic (for runtime validation if needed)
     */
    public static function fromString(topic: String): Null<PresenceTopic> {
        return switch(topic) {
            case "users": Users;
            case "editing:todos": EditingTodos;
            case "active:rooms": ActiveRooms;
            default: null;
        }
    }
}

/**
 * Type-safe PubSub topics - prevents typos and invalid topic strings
 */
enum PubSubTopic {
    TodoUpdates;          // "todo:updates"
    UserActivity;         // "user:activity"  
    SystemNotifications;  // "system:notifications"
}

/**
 * Type-safe PubSub message types - compile-time validation of message structure
 */
enum PubSubMessageType {
    TodoCreated(todo: server.schemas.Todo);
    TodoUpdated(todo: server.schemas.Todo);
    TodoDeleted(id: Int);
    BulkUpdate(action: BulkOperationType);
    UserOnline(user_id: Int);
    UserOffline(user_id: Int);
    SystemAlert(message: String, level: AlertLevel);
}

/**
 * Bulk operation types for type-safe bulk actions
 */
enum BulkOperationType {
    CompleteAll;
    DeleteCompleted;
    SetPriority(priority: TodoPriority);
    AddTag(tag: String);
    RemoveTag(tag: String);
}

// SafePubSub class moved to framework level: /std/phoenix/SafePubSub.hx
// Application-specific PubSub types moved to: server/pubsub/TodoPubSub.hx
// 
// This demonstrates the framework-level development principle:
// Common patterns discovered in applications should become framework features
// so ALL Phoenix apps benefit from the same type safety improvements.

/**
 * Alert levels for system notifications
 */
enum AlertLevel {
    Info;
    Warning;
    Error;
    Critical;
}

/**
 * Enhanced PubSub message with type safety
 */
typedef PubSubMessage = {
    var type: PubSubMessageType;
    var ?metadata: PubSubMetadata;
}

/**
 * PubSub metadata for message tracking
 */
typedef PubSubMetadata = {
    var ?timestamp: Dynamic;
    var ?source: String;
    var ?version: String;
    var ?user_id: Int;
}

// ============================================================================
// Session and Authentication Types
// ============================================================================

/**
 * Session data structure
 */
typedef Session = {
    var ?userId: Int;  // camelCase
    var ?token: String;
    var ?csrfToken: String;  // camelCase
    var ?locale: String;
    var ?timezone: String;
    var ?userAgent: String;  // camelCase
    var ?ipAddress: String;  // camelCase
    var ?loginAt: Dynamic;  // camelCase
}

/**
 * Mount parameters for LiveView initialization
 */
typedef MountParams = {
    var ?id: String;
    var ?action: String;
    var ?slug: String;
    var ?page: String;
    var ?filter: String;
    var ?sort: String;
    var ?search: String;
}

// ============================================================================
// Database Operation Types
// ============================================================================

/**
 * Ecto repository operation result
 */
typedef RepoResult<T> = {
    var success: Bool;
    var ?data: T;
    var ?error: String;
    var ?changeset: Dynamic;
}

/**
 * Ecto changeset type
 */
typedef Changeset<T> = {
    var valid: Bool;
    var data: T;
    var changes: Dynamic;
    var errors: Array<FieldError>;
    var action: Null<String>;
}

/**
 * Field validation error
 */
typedef FieldError = {
    var field: String;
    var message: String;
    var validation: String;
}

// ============================================================================
// Form and Validation Types
// ============================================================================

/**
 * Form field metadata for HEEx templates
 */
typedef FormField = {
    var id: String;
    var name: String;
    var value: Dynamic;
    var errors: Array<String>;
    var valid: Bool;
    var data: Dynamic;
}

/**
 * Form structure for changesets
 */
typedef Form<T> = {
    var source: Changeset<T>;
    var impl: String;
    var id: String;
    var name: String;
    var data: T;
    var params: Dynamic;
    var hidden: Array<FormField>;
    var options: FormOptions;
}

/**
 * Form rendering options
 */
typedef FormOptions = {
    var ?method: String;
    var ?multipart: Bool;
    var ?csrf_token: String;
    var ?as: String;
}

// ============================================================================
// Component and Template Types
// ============================================================================

/**
 * Component assigns for HXX templates
 */
typedef ComponentAssigns = {
    var ?className: String;
    var ?id: String;
    var ?phx_click: String;
    var ?phx_submit: String;
    var ?phx_change: String;
    var ?phx_keyup: String;
    var ?phx_blur: String;
    var ?phx_focus: String;
    var ?phx_hook: String;
    var ?phx_update: String;
    var ?phx_target: String;
    var ?phx_debounce: String;
    var ?phx_throttle: String;
    var ?rest: Dynamic;
}

// ============================================================================
// LiveView Lifecycle Types
// ============================================================================

// MountResult, HandleEventResult, and HandleInfoResult moved to framework level:
// - phoenix.Phoenix.MountResult<TAssigns> for type-safe mount operations
// - phoenix.Phoenix.HandleEventResult<TAssigns> for type-safe event handling
// - phoenix.Phoenix.HandleInfoResult<TAssigns> for type-safe info handling
// 
// Use framework types instead of application duplicates:
// import phoenix.Phoenix.MountResult;
// import phoenix.Phoenix.HandleEventResult;
// import phoenix.Phoenix.HandleInfoResult;
//
// This demonstrates the framework-level development principle:
// LiveView lifecycle types discovered in applications should become framework features
// so ALL Phoenix apps benefit from the same type safety improvements.

// ============================================================================
// Utility Types
// ============================================================================

// Result<T,E> and Option<T> moved to framework level:
// - haxe.functional.Result<T,E> for error handling
// - haxe.ds.Option<T> for null safety
// 
// Use framework types instead of application duplicates:
// import haxe.functional.Result;
// import haxe.ds.Option;

/**
 * Pagination metadata
 */
typedef Pagination = {
    var page: Int;
    var per_page: Int;
    var total_count: Int;
    var total_pages: Int;
    var has_next: Bool;
    var has_prev: Bool;
}

/**
 * Sort direction
 */
enum SortDirection {
    Asc;
    Desc;
}

/**
 * Sort configuration
 */
typedef SortConfig = {
    var field: String;
    var direction: SortDirection;
}

// ============================================================================
// Application-Specific Types
// ============================================================================

/**
 * Todo filter options
 */
enum TodoFilter {
    All;
    Active;
    Completed;
    ByTag(tag: String);
    ByPriority(priority: String);
    ByDueDate(date: Dynamic);
}

/**
 * Todo sort options
 */
enum TodoSort {
    Created;
    Priority;
    DueDate;
    Title;
    Status;
}

/**
 * Todo priority levels
 */
enum TodoPriority {
    Low;
    Medium;
    High;
}

/**
 * Bulk operation types
 */
enum BulkOperation {
    CompleteAll;
    DeleteCompleted;
    SetPriority(priority: TodoPriority);
    AddTag(tag: String);
    RemoveTag(tag: String);
}
</file>

<file path="examples/todo-app/src_haxe/shared/TodoTypes.hx">
package shared;

/**
 * Shared type definitions for Todo application
 * Used by both client (Haxe‚ÜíJS) and server (Haxe‚ÜíElixir) code
 */

/**
 * Todo item data structure
 */
typedef Todo = {
    id: Int,
    title: String,
    description: Null<String>,
    completed: Bool,
    priority: TodoPriority,
    due_date: Null<String>,
    tags: Null<String>,
    user_id: Int,
    inserted_at: String,
    updated_at: String
};

/**
 * User data structure
 */
typedef User = {
    id: Int,
    name: String,
    email: String,
    inserted_at: String,
    updated_at: String
};

/**
 * Todo priority levels
 */
enum TodoPriority {
    Low;
    Medium;
    High;
}

/**
 * Filter options for todos
 */
enum TodoFilter {
    All;
    Active;
    Completed;
}

/**
 * Sort options for todos
 */
enum TodoSort {
    Created;
    Priority;
    DueDate;
}

/**
 * LiveView socket assigns structure
 */
typedef TodoLiveAssigns = {
    todos: Array<Todo>,
    filter: TodoFilter,
    sort_by: TodoSort,
    current_user: User,
    editing_todo: Null<Todo>,
    show_form: Bool,
    search_query: String,
    selected_tags: Array<String>,
    total_todos: Int,
    completed_todos: Int,
    pending_todos: Int,
    page_title: String,
    last_updated: String
};

/**
 * Phoenix LiveView event payloads
 */
typedef TodoEvents = {
    toggle_todo: {id: Int},
    delete_todo: {id: Int},
    create_todo: {title: String, description: String, priority: String, due_date: String, tags: String},
    edit_todo: {id: Int},
    save_todo: {id: Int, title: String, description: String},
    cancel_edit: {},
    toggle_form: {},
    filter_todos: {filter: String},
    sort_todos: {sort_by: String},
    search_todos: {query: String},
    set_priority: {id: Int, priority: String},
    bulk_complete: {},
    bulk_delete_completed: {}
};

/**
 * Client-side state for JavaScript hooks
 */
typedef ClientState = {
    darkMode: Bool,
    autoSave: Bool,
    lastSync: Float
};

/**
 * Phoenix PubSub message types
 */
typedef PubSubMessages = {
    todo_added: {todo: Todo},
    todo_updated: {todo: Todo},
    todo_deleted: {id: Int},
    user_joined: {user: User},
    user_left: {user: User}
};

/**
 * Helper class to make this module findable by Haxe
 * Required because Haxe needs at least one class/enum in a file
 */
class TodoTypes {
    // Empty class just to make the module findable
}
</file>

<file path="examples/todo-app/src_haxe/test/contexts/UsersTest.hx">
package test.contexts;

import test.support.DataCase;
import server.contexts.Users;
import server.schemas.Todo;

/**
 * Tests for the Users context
 * Validates todo management functions and business logic
 */
@:exunit
class UsersTest extends DataCase {
    
    /**
     * Test creating a todo with valid attributes
     */
    public function testCreateTodo(): Void {
        var attrs = {
            title: "Test todo",
            description: "A test todo item",
            completed: false,
            priority: "medium"
        };
        
        var result = Users.createTodo(attrs);
        
        assertOkTuple(result);
        var todo = getTupleValue(result);
        assertEqual("Test todo", todo.title);
        assertEqual("A test todo item", todo.description);
        assertEqual(false, todo.completed);
        assertEqual("medium", todo.priority);
        assertNotNull(todo.id);
    }
    
    /**
     * Test creating a todo with invalid attributes
     */
    public function testCreateTodoWithInvalidAttributes(): Void {
        var attrs = {
            title: "", // Invalid: empty title
            completed: false
        };
        
        var result = Users.createTodo(attrs);
        
        assertErrorTuple(result);
        var changeset = getTupleValue(result);
        assertInvalidChangeset(changeset);
    }
    
    /**
     * Test listing all todos
     */
    public function testListTodos(): Void {
        // Create test todos
        createTestTodo("First todo", false, "high");
        createTestTodo("Second todo", true, "low");
        createTestTodo("Third todo", false, "medium");
        
        var todos = Users.listTodos();
        
        assertTrue(isArray(todos));
        assertEqual(3, arrayLength(todos));
    }
    
    /**
     * Test getting a specific todo by ID
     */
    public function testGetTodo(): Void {
        var createdTodo = createTestTodo("Get me", false, "high");
        
        var result = Users.getTodo(createdTodo.id);
        
        assertNotNull(result);
        assertEqual(createdTodo.id, result.id);
        assertEqual("Get me", result.title);
        assertEqual("high", result.priority);
    }
    
    /**
     * Test getting a non-existent todo returns null
     */
    public function testGetNonExistentTodo(): Void {
        var result = Users.getTodo(999999);
        assertNull(result);
    }
    
    /**
     * Test updating a todo with valid attributes
     */
    public function testUpdateTodo(): Void {
        var todo = createTestTodo("Original title", false, "low");
        
        var updateAttrs = {
            title: "Updated title",
            completed: true,
            priority: "high"
        };
        
        var result = Users.updateTodo(todo, updateAttrs);
        
        assertOkTuple(result);
        var updatedTodo = getTupleValue(result);
        assertEqual("Updated title", updatedTodo.title);
        assertEqual(true, updatedTodo.completed);
        assertEqual("high", updatedTodo.priority);
    }
    
    /**
     * Test updating a todo with invalid attributes
     */
    public function testUpdateTodoWithInvalidAttributes(): Void {
        var todo = createTestTodo("Valid todo", false, "medium");
        
        var updateAttrs = {
            title: "", // Invalid: empty title
            priority: "invalid_priority" // Invalid priority
        };
        
        var result = Users.updateTodo(todo, updateAttrs);
        
        assertErrorTuple(result);
        var changeset = getTupleValue(result);
        assertInvalidChangeset(changeset);
    }
    
    /**
     * Test deleting a todo
     */
    public function testDeleteTodo(): Void {
        var todo = createTestTodo("Delete me", false, "low");
        
        var result = Users.deleteTodo(todo);
        
        assertOkTuple(result);
        var deletedTodo = getTupleValue(result);
        assertEqual(todo.id, deletedTodo.id);
        
        // Verify todo is actually deleted
        var getTodo = Users.getTodo(todo.id);
        assertNull(getTodo);
    }
    
    /**
     * Test filtering todos by completion status
     */
    public function testFilterTodosByCompletion(): Void {
        createTestTodo("Completed todo", true, "high");
        createTestTodo("Pending todo 1", false, "medium");
        createTestTodo("Pending todo 2", false, "low");
        
        var completedTodos = Users.filterTodos("completed");
        var activeTodos = Users.filterTodos("active");
        var allTodos = Users.filterTodos("all");
        
        assertEqual(1, arrayLength(completedTodos));
        assertEqual(2, arrayLength(activeTodos));
        assertEqual(3, arrayLength(allTodos));
    }
    
    /**
     * Test sorting todos by priority
     */
    public function testSortTodosByPriority(): Void {
        createTestTodo("Low priority", false, "low");
        createTestTodo("High priority", false, "high");
        createTestTodo("Medium priority", false, "medium");
        
        var sortedTodos = Users.sortTodos("priority");
        
        assertEqual(3, arrayLength(sortedTodos));
        assertEqual("high", sortedTodos[0].priority);
        assertEqual("medium", sortedTodos[1].priority);
        assertEqual("low", sortedTodos[2].priority);
    }
    
    /**
     * Test searching todos by title
     */
    public function testSearchTodos(): Void {
        createTestTodo("Work on project", false, "high");
        createTestTodo("Buy groceries", false, "low");
        createTestTodo("Work meeting", false, "medium");
        
        var workTodos = Users.searchTodos("work");
        var buyTodos = Users.searchTodos("buy");
        
        assertEqual(2, arrayLength(workTodos));
        assertEqual(1, arrayLength(buyTodos));
    }
    
    /**
     * Test bulk operations on todos
     */
    public function testBulkCompleteAllTodos(): Void {
        createTestTodo("Todo 1", false, "high");
        createTestTodo("Todo 2", false, "medium");
        createTestTodo("Todo 3", true, "low"); // Already completed
        
        var result = Users.bulkCompleteAllTodos();
        
        assertEqual(2, result); // Should update 2 todos
        
        var allTodos = Users.listTodos();
        for (todo in allTodos) {
            assertTrue(todo.completed);
        }
    }
    
    /**
     * Test deleting completed todos
     */
    public function testDeleteCompletedTodos(): Void {
        createTestTodo("Active todo", false, "high");
        createTestTodo("Completed todo 1", true, "medium");
        createTestTodo("Completed todo 2", true, "low");
        
        var result = Users.deleteCompletedTodos();
        
        assertEqual(2, result); // Should delete 2 todos
        
        var remainingTodos = Users.listTodos();
        assertEqual(1, arrayLength(remainingTodos));
        assertEqual(false, remainingTodos[0].completed);
    }
    
    // Helper methods
    
    /**
     * Create a test todo with given attributes
     */
    private function createTestTodo(title: String, completed: Bool, priority: String): Dynamic {
        var attrs = {
            title: title,
            completed: completed,
            priority: priority
        };
        
        var result = Users.createTodo(attrs);
        assertOkTuple(result);
        return getTupleValue(result);
    }
    
    /**
     * Assert that result is an {:ok, value} tuple
     */
    private function assertOkTuple(result: Dynamic): Void {
        if (!isOkTuple(result)) {
            throw 'Expected {:ok, value} tuple, but got: ${result}';
        }
    }
    
    /**
     * Assert that result is an {:error, value} tuple
     */
    private function assertErrorTuple(result: Dynamic): Void {
        if (!isErrorTuple(result)) {
            throw 'Expected {:error, value} tuple, but got: ${result}';
        }
    }
    
    /**
     * Check if result is an {:ok, value} tuple
     */
    private function isOkTuple(result: Dynamic): Bool {
        return result.atom == "ok";
    }
    
    /**
     * Check if result is an {:error, value} tuple
     */
    private function isErrorTuple(result: Dynamic): Bool {
        return result.atom == "error";
    }
    
    /**
     * Get the value from a tuple
     */
    private function getTupleValue(tuple: Dynamic): Dynamic {
        return tuple.value;
    }
    
    /**
     * Check if value is an array
     */
    private function isArray(value: Dynamic): Bool {
        return Std.isOfType(value, Array);
    }
    
    /**
     * Get array length
     */
    private function arrayLength(array: Array<Dynamic>): Int {
        return array.length;
    }
    
    /**
     * Assert equality
     */
    private function assertEqual(expected: Dynamic, actual: Dynamic): Void {
        if (expected != actual) {
            throw 'Expected ${expected}, but got ${actual}';
        }
    }
    
    /**
     * Assert not null
     */
    private function assertNotNull(value: Dynamic): Void {
        if (value == null) {
            throw "Expected value to not be null";
        }
    }
    
    /**
     * Assert null
     */
    private function assertNull(value: Dynamic): Void {
        if (value != null) {
            throw 'Expected value to be null, but got: ${value}';
        }
    }
    
    /**
     * Assert true
     */
    private function assertTrue(value: Bool): Void {
        if (!value) {
            throw "Expected value to be true";
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/live/TodoLiveClassTest.hx">
package test.live;

import exunit.TestCase;
import exunit.Assert.*;
import phoenix.test.ConnTest;
import phoenix.test.LiveViewTest;
import phoenix.test.LiveView;

/**
 * TodoLiveClassTest
 *
 * WHAT
 * - Verifies that priority and completion state produce the expected card CSS classes
 *   in the rendered LiveView (indirectly exercising the typed helper).
 *
 * WHY
 * - Ensures our HXX ‚Üí HEEx pipeline and typed helper produce idiomatic classes without
 *   relying on private helper visibility.
 */
@:exunit
class TodoLiveClassTest extends TestCase {
  @:test
  public function testHighPriorityClass(): Void {
    var conn = ConnTest.build_conn();
    var lv: LiveView = LiveViewTest.live(conn, "/todos");
    // Open form and create a High priority todo
    lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
    var data: Map<String, Dynamic> = new Map();
    data.set("title", "Priority High");
    data.set("priority", "high");
    lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
    var html = LiveViewTest.render(lv);
    assertTrue(html.indexOf("border-red-500") != -1);
  }

  @:test
  public function testCompletedOpacity(): Void {
    var conn = ConnTest.build_conn();
    var lv: LiveView = LiveViewTest.live(conn, "/todos");
    // Create and complete a todo
    lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
    var data: Map<String, Dynamic> = new Map();
    data.set("title", "Done Item");
    lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
    lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_todo']");
    var html = LiveViewTest.render(lv);
    assertTrue(html.indexOf("opacity-60") != -1);
  }
}
</file>

<file path="examples/todo-app/src_haxe/test/live/TodoLiveCrudTest.hx">
package test.live;

import exunit.TestCase;
import exunit.Assert.*;
import phoenix.test.ConnTest;
import phoenix.test.LiveViewTest;
import phoenix.test.LiveView;

/**
 * TodoLiveCrudTest
 *
 * WHAT
 * - Server-side LiveView integration tests authored in Haxe, compiled to ExUnit.
 *
 * WHY
 * - Provides fast, deterministic tests of CRUD + filters without a browser.
 * - Complements Playwright smokes (Testing Trophy).
 *
 * HOW
 * - Uses Phoenix.ConnTest and Phoenix.LiveViewTest externs.
 */
@:exunit
class TodoLiveCrudTest extends TestCase {
    @:test
    public function testMountTodos(): Void {
        var conn = ConnTest.build_conn();
        // LiveViewTest.live(conn, "/todos") should return a LiveView handle
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        assertTrue(lv != null);
        // Basic render contains page title
        var html = LiveViewTest.render(lv);
        assertTrue(html != null);
    }

    @:test
    public function testCreateTodoViaLiveView(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        // Toggle form
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        // Submit minimal form (title only)
        var data: Map<String, Dynamic> = new Map();
        data.set("title", "LV created");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
        // Render and assert content contains the title
        var html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("LV created") != -1);
    }

    @:test
    public function testToggleTodoStatus(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        // Create a fresh todo
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var data: Map<String, Dynamic> = new Map();
        data.set("title", "Toggle Me");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
        // Click the first toggle button
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_todo']");
        var html = LiveViewTest.render(lv);
        // Completed item should have line-through or container opacity
        var hasLine = html.indexOf("line-through") != -1;
        var hasOpacity = html.indexOf("opacity-60") != -1;
        assertTrue(hasLine || hasOpacity);
    }

    @:test
    public function testEditTodo(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        // Create
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var data: Map<String, Dynamic> = new Map();
        data.set("title", "Edit Me");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
        // Click edit
        lv = LiveViewTest.render_click(lv, "button[phx-click='edit_todo']");
        // Fill and save
        var newData: Map<String, Dynamic> = new Map();
        newData.set("title", "Edited Title");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='save_todo']", newData);
        var html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("Edited Title") != -1);
    }

    @:test
    public function testDeleteTodo(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        // Create
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var data: Map<String, Dynamic> = new Map();
        data.set("title", "Delete Me");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
        // Delete
        lv = LiveViewTest.render_click(lv, "button[phx-click='delete_todo']");
        var html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("Delete Me") == -1);
    }

    @:test
    public function testFilters(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        // Create Active
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var a: Map<String, Dynamic> = new Map();
        a.set("title", "Active One");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", a);
        // Create another and toggle complete
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var c: Map<String, Dynamic> = new Map();
        c.set("title", "Completed One");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", c);
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_todo']");
        // Filter Completed
        lv = LiveViewTest.render_click(lv, "button[phx-click='filter_todos'][phx-value-filter='completed']");
        var html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("Active One") == -1);
        assertTrue(html.indexOf("Completed One") != -1);
        // Filter Active
        lv = LiveViewTest.render_click(lv, "button[phx-click='filter_todos'][phx-value-filter='active']");
        html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("Completed One") == -1);
        assertTrue(html.indexOf("Active One") != -1);
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/live/TodoLiveDueDateTest.hx">
package live;

import exunit.TestCase;
import exunit.Assert.*;
import phoenix.test.ConnTest;
import phoenix.test.LiveViewTest;
import phoenix.test.LiveView;

/**
 * TodoLiveDueDateTest
 *
 * WHAT
 * - Verifies creating a todo with a due_date renders a "Due:" label.
 *
 * WHY
 * - Guards the due_date normalization and rendering path (date-only -> 00:00:00).
 */
@:exunit
class TodoLiveDueDateTest extends TestCase {
    @:test
    public function testCreateTodoWithDueDateRenders(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = LiveViewTest.live(conn, "/todos");
        lv = LiveViewTest.render_click(lv, "button[phx-click='toggle_form']");
        var data: Map<String, Dynamic> = new Map();
        data.set("title", "DueEarly");
        data.set("due_date", "2025-11-01");
        lv = LiveViewTest.render_submit(lv, "form[phx-submit='create_todo']", data);
        var html = LiveViewTest.render(lv);
        assertTrue(html.indexOf("Due:") != -1);
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/live/TodoLiveTest.hx">
package test.live;

import test.support.ConnCase;
import server.live.TodoLive;

/**
 * Tests for the TodoLive LiveView module
 * Validates LiveView functionality, event handling, and state management
 */
@:exunit
class TodoLiveTest extends ConnCase {
    
    /**
     * Test that the todo page loads successfully
     */
    public function testTodoPageMount(): Void {
        var conn = build_conn();
        conn = get(conn, "/todos");
        
        assertResponseOk(conn);
        assertResponseContains(conn, "Todo App");
        assertResponseContains(conn, "Built with Haxe ‚Üí Elixir + Phoenix LiveView");
    }
    
    /**
     * Test that the new todo form can be toggled
     */
    public function testToggleNewTodoForm(): Void {
        var liveView = connectLiveView("/todos");
        
        // Initially form should be hidden
        assertFormNotVisible(liveView);
        
        // Click to show form
        liveView = clickElement(liveView, "[phx-click='toggle_form']");
        assertFormVisible(liveView);
        
        // Click to hide form
        liveView = clickElement(liveView, "[phx-click='toggle_form']");
        assertFormNotVisible(liveView);
    }
    
    /**
     * Test creating a new todo via LiveView form
     */
    public function testCreateTodoViaForm(): Void {
        var liveView = connectLiveView("/todos");
        
        // Show the form
        liveView = clickElement(liveView, "[phx-click='toggle_form']");
        
        // Fill and submit the form
        var formData = {
            title: "New test todo",
            description: "Created via LiveView test",
            priority: "high"
        };
        
        liveView = submitForm(liveView, "#new-todo-form", formData);
        
        // Verify todo was created and appears in list
        assertElementPresent(liveView, "[data-todo-title='New test todo']");
        assertElementContains(liveView, "[data-todo-description]", "Created via LiveView test");
        assertElementContains(liveView, "[data-todo-priority]", "HIGH");
        
        // Form should be hidden after successful creation
        assertFormNotVisible(liveView);
    }
    
    /**
     * Test creating a todo with invalid data shows errors
     */
    public function testCreateTodoWithInvalidData(): Void {
        var liveView = connectLiveView("/todos");
        
        // Show the form
        liveView = clickElement(liveView, "[phx-click='toggle_form']");
        
        // Submit form with invalid data (empty title)
        var invalidData = {
            title: "",
            description: "No title provided"
        };
        
        liveView = submitForm(liveView, "#new-todo-form", invalidData);
        
        // Form should still be visible with error messages
        assertFormVisible(liveView);
        assertElementContains(liveView, ".error-message", "can't be blank");
    }
    
    /**
     * Test toggling a todo's completion status
     */
    public function testToggleTodoCompletion(): Void {
        // Create a test todo first
        var todo = createTestTodo("Toggle me", false, "medium");
        var liveView = connectLiveView("/todos");
        
        // Verify todo is not completed initially
        assertElementNotHasClass(liveView, '[data-todo-id="${todo.id}"]', "completed");
        
        // Click to complete the todo
        liveView = clickElement(liveView, '[phx-click="toggle_todo"][phx-value-id="${todo.id}"]');
        
        // Verify todo is now completed
        assertElementHasClass(liveView, '[data-todo-id="${todo.id}"]', "completed");
        
        // Click again to uncomplete
        liveView = clickElement(liveView, '[phx-click="toggle_todo"][phx-value-id="${todo.id}"]');
        
        // Verify todo is not completed again
        assertElementNotHasClass(liveView, '[data-todo-id="${todo.id}"]', "completed");
    }
    
    /**
     * Test filtering todos by status
     */
    public function testFilterTodos(): Void {
        // Create test todos with different statuses
        var activeTodo = createTestTodo("Active todo", false, "high");
        var completedTodo = createTestTodo("Completed todo", true, "low");
        
        var liveView = connectLiveView("/todos");
        
        // Test "All" filter (default)
        assertElementPresent(liveView, '[data-todo-id="${activeTodo.id}"]');
        assertElementPresent(liveView, '[data-todo-id="${completedTodo.id}"]');
        
        // Test "Active" filter
        liveView = clickElement(liveView, '[phx-click="filter_todos"][phx-value-filter="active"]');
        assertElementPresent(liveView, '[data-todo-id="${activeTodo.id}"]');
        assertElementNotPresent(liveView, '[data-todo-id="${completedTodo.id}"]');
        
        // Test "Completed" filter
        liveView = clickElement(liveView, '[phx-click="filter_todos"][phx-value-filter="completed"]');
        assertElementNotPresent(liveView, '[data-todo-id="${activeTodo.id}"]');
        assertElementPresent(liveView, '[data-todo-id="${completedTodo.id}"]');
    }
    
    /**
     * Test searching todos by title
     */
    public function testSearchTodos(): Void {
        // Create test todos
        createTestTodo("Work on project", false, "high");
        createTestTodo("Buy groceries", false, "low");
        
        var liveView = connectLiveView("/todos");
        
        // Search for "work"
        liveView = typeInInput(liveView, '[phx-keyup="search_todos"]', "work");
        
        // Should show work todo, hide groceries todo
        assertElementContains(liveView, ".todo-item", "Work on project");
        assertElementNotContains(liveView, ".todo-item", "Buy groceries");
        
        // Clear search
        liveView = typeInInput(liveView, '[phx-keyup="search_todos"]', "");
        
        // Both todos should be visible again
        assertElementContains(liveView, ".todo-item", "Work on project");
        assertElementContains(liveView, ".todo-item", "Buy groceries");
    }
    
    /**
     * Test sorting todos by different criteria
     */
    public function testSortTodos(): Void {
        // Create todos with different priorities and dates
        createTestTodo("Low priority", false, "low");
        createTestTodo("High priority", false, "high");
        createTestTodo("Medium priority", false, "medium");
        
        var liveView = connectLiveView("/todos");
        
        // Sort by priority
        liveView = selectOption(liveView, '[phx-change="sort_todos"]', "priority");
        
        // Verify order: high, medium, low
        var todoElements = getElementsText(liveView, ".todo-title");
        assertEqual("High priority", todoElements[0]);
        assertEqual("Medium priority", todoElements[1]);
        assertEqual("Low priority", todoElements[2]);
    }
    
    /**
     * Test editing a todo inline
     */
    public function testEditTodo(): Void {
        var todo = createTestTodo("Original title", false, "medium");
        var liveView = connectLiveView("/todos");
        
        // Click edit button
        liveView = clickElement(liveView, '[phx-click="edit_todo"][phx-value-id="${todo.id}"]');
        
        // Verify edit form is shown
        assertElementPresent(liveView, '[data-todo-id="${todo.id}"] form');
        
        // Update the todo
        var updatedData = {
            title: "Updated title",
            description: "Updated description"
        };
        
        liveView = submitForm(liveView, '[data-todo-id="${todo.id}"] form', updatedData);
        
        // Verify todo was updated
        assertElementContains(liveView, '[data-todo-id="${todo.id}"] .todo-title', "Updated title");
        assertElementContains(liveView, '[data-todo-id="${todo.id}"] .todo-description', "Updated description");
        
        // Edit form should be hidden
        assertElementNotPresent(liveView, '[data-todo-id="${todo.id}"] form');
    }
    
    /**
     * Test deleting a todo
     */
    public function testDeleteTodo(): Void {
        var todo = createTestTodo("Delete me", false, "low");
        var liveView = connectLiveView("/todos");
        
        // Verify todo is present
        assertElementPresent(liveView, '[data-todo-id="${todo.id}"]');
        
        // Click delete button (will show confirmation)
        liveView = clickElementWithConfirm(liveView, '[phx-click="delete_todo"][phx-value-id="${todo.id}"]');
        
        // Verify todo is removed
        assertElementNotPresent(liveView, '[data-todo-id="${todo.id}"]');
    }
    
    /**
     * Test bulk complete all todos
     */
    public function testBulkCompleteAllTodos(): Void {
        // Create some active todos
        createTestTodo("Todo 1", false, "high");
        createTestTodo("Todo 2", false, "medium");
        createTestTodo("Todo 3", true, "low"); // Already completed
        
        var liveView = connectLiveView("/todos");
        
        // Click bulk complete button
        liveView = clickElement(liveView, '[phx-click="bulk_complete"]');
        
        // Verify all todos are completed
        var completedElements = getElements(liveView, ".todo-item.completed");
        assertEqual(3, completedElements.length);
    }
    
    /**
     * Test bulk delete completed todos
     */
    public function testBulkDeleteCompleted(): Void {
        // Create todos with different statuses
        createTestTodo("Active todo", false, "high");
        createTestTodo("Completed todo 1", true, "medium");
        createTestTodo("Completed todo 2", true, "low");
        
        var liveView = connectLiveView("/todos");
        
        // Click bulk delete completed button
        liveView = clickElementWithConfirm(liveView, '[phx-click="bulk_delete_completed"]');
        
        // Verify only active todo remains
        var remainingTodos = getElements(liveView, ".todo-item");
        assertEqual(1, remainingTodos.length);
        assertElementContains(liveView, ".todo-item", "Active todo");
    }
    
    /**
     * Test empty state messages
     */
    public function testEmptyStateMessages(): Void {
        var liveView = connectLiveView("/todos");
        
        // No todos - should show empty state
        assertElementContains(liveView, ".empty-state", "No todos yet");
        
        // Create a completed todo
        createTestTodo("Completed", true, "low");
        liveView = refreshLiveView(liveView);
        
        // Filter by active - should show "no active todos"
        liveView = clickElement(liveView, '[phx-click="filter_todos"][phx-value-filter="active"]');
        assertElementContains(liveView, ".empty-state", "No active todos");
    }
    
    // Helper methods
    
    /**
     * Create a test todo
     */
    private function createTestTodo(title: String, completed: Bool, priority: String): Dynamic {
        // This would use the Users context to create a todo
        return {
            id: Math.floor(Math.random() * 1000000),
            title: title,
            completed: completed,
            priority: priority
        };
    }
    
    /**
     * Connect to a LiveView at the given path
     */
    private function connectLiveView(path: String): Dynamic {
        // Implementation would use Phoenix.LiveViewTest helpers
        return {};
    }
    
    /**
     * Click an element in the LiveView
     */
    private function clickElement(liveView: Dynamic, selector: String): Dynamic {
        // Implementation would trigger the click event
        return liveView;
    }
    
    /**
     * Click an element that shows a confirmation dialog
     */
    private function clickElementWithConfirm(liveView: Dynamic, selector: String): Dynamic {
        // Implementation would handle the confirmation
        return liveView;
    }
    
    /**
     * Submit a form in the LiveView
     */
    private function submitForm(liveView: Dynamic, formSelector: String, data: Dynamic): Dynamic {
        // Implementation would submit the form with data
        return liveView;
    }
    
    /**
     * Type text into an input field
     */
    private function typeInInput(liveView: Dynamic, inputSelector: String, text: String): Dynamic {
        // Implementation would trigger keyup events
        return liveView;
    }
    
    /**
     * Select an option from a dropdown
     */
    private function selectOption(liveView: Dynamic, selectSelector: String, value: String): Dynamic {
        // Implementation would trigger change event
        return liveView;
    }
    
    /**
     * Refresh the LiveView
     */
    private function refreshLiveView(liveView: Dynamic): Dynamic {
        // Implementation would re-render the view
        return liveView;
    }
    
    // Assertion helpers
    
    private function assertFormVisible(liveView: Dynamic): Void {
        assertElementPresent(liveView, "#new-todo-form");
    }
    
    private function assertFormNotVisible(liveView: Dynamic): Void {
        assertElementNotPresent(liveView, "#new-todo-form");
    }
    
    private function assertElementPresent(liveView: Dynamic, selector: String): Void {
        // Implementation would check if element exists
    }
    
    private function assertElementNotPresent(liveView: Dynamic, selector: String): Void {
        // Implementation would check if element doesn't exist
    }
    
    private function assertElementContains(liveView: Dynamic, selector: String, text: String): Void {
        // Implementation would check element content
    }
    
    private function assertElementNotContains(liveView: Dynamic, selector: String, text: String): Void {
        // Implementation would check element doesn't contain text
    }
    
    private function assertElementHasClass(liveView: Dynamic, selector: String, className: String): Void {
        // Implementation would check CSS class
    }
    
    private function assertElementNotHasClass(liveView: Dynamic, selector: String, className: String): Void {
        // Implementation would check CSS class absence
    }
    
    private function getElements(liveView: Dynamic, selector: String): Array<Dynamic> {
        // Implementation would return matching elements
        return [];
    }
    
    private function getElementsText(liveView: Dynamic, selector: String): Array<String> {
        // Implementation would return element text content
        return [];
    }
    
    private function assertEqual(expected: Dynamic, actual: Dynamic): Void {
        if (expected != actual) {
            throw 'Expected ${expected}, but got ${actual}';
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/schemas/TodoTest.hx">
package test.schemas;

import test.support.DataCase;
import server.schemas.Todo;
import ecto.Changeset;
import haxe.ds.Option;

using ecto.Changeset.ChangesetTools;

/**
 * Tests for the Todo schema
 * Validates changeset logic, validations, and field constraints
 */
@:exunit
class TodoTest extends DataCase {
    
    /**
     * Test that valid todo attributes create a valid changeset
     */
    @:test
    public function testValidChangeset(): Void {
        var attrs = {
            title: "Complete project",
            description: "Finish the Haxe‚ÜíElixir todo app",
            completed: false,
            priority: "medium",
            due_date: "2025-08-20",
            tags: "work, haxe, elixir"
        };
        
        var changeset: Changeset<Todo> = Todo.changeset(new Todo(), attrs);
        assertValidChangeset(changeset);
    }
    
    /**
     * Test that missing title makes changeset invalid
     */
    @:test
    public function testRequiredTitle(): Void {
        var attrs = {
            description: "Todo without title",
            completed: false
        };
        
        var changeset: Changeset<Todo> = Todo.changeset(new Todo(), attrs);
        assertInvalidChangeset(changeset);
        assertChangesetError(changeset, "title", "can't be blank");
    }
    
    /**
     * Test that empty title makes changeset invalid
     */
    public function testEmptyTitle(): Void {
        var attrs = {
            title: "",
            description: "Todo with empty title",
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertInvalidChangeset(changeset);
        assertChangesetError(changeset, "title", "can't be blank");
    }
    
    /**
     * Test that title length validation works
     */
    public function testTitleLength(): Void {
        // Title too long (over 200 characters)
        var longTitle = "";
        for (i in 0...210) {
            longTitle += "a";
        }
        
        var attrs = {
            title: longTitle,
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertInvalidChangeset(changeset);
        assertChangesetError(changeset, "title", "should be at most 200 character(s)");
    }
    
    /**
     * Test that priority validation works
     */
    public function testPriorityValidation(): Void {
        var attrs = {
            title: "Test todo",
            priority: "invalid_priority",
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertInvalidChangeset(changeset);
        assertChangesetError(changeset, "priority", "is invalid");
    }
    
    /**
     * Test valid priority values
     */
    public function testValidPriorities(): Void {
        var validPriorities = ["low", "medium", "high"];
        
        for (priority in validPriorities) {
            var attrs = {
                title: "Test todo",
                priority: priority,
                completed: false
            };
            
            var changeset = Todo.changeset(Todo.new(), attrs);
            assertValidChangeset(changeset);
        }
    }
    
    /**
     * Test that completed defaults to false
     */
    public function testCompletedDefault(): Void {
        var attrs = {
            title: "Test todo"
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertValidChangeset(changeset);
        
        var completed = getChangesetValue(changeset, "completed");
        assertEqual(false, completed);
    }
    
    /**
     * Test that description is optional
     */
    public function testOptionalDescription(): Void {
        var attrs = {
            title: "Todo without description",
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertValidChangeset(changeset);
    }
    
    /**
     * Test that due_date accepts valid dates
     */
    public function testValidDueDate(): Void {
        var attrs = {
            title: "Todo with due date",
            due_date: "2025-12-31",
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertValidChangeset(changeset);
    }
    
    /**
     * Test that tags are stored as comma-separated string
     */
    public function testTagsHandling(): Void {
        var attrs = {
            title: "Todo with tags",
            tags: "work, personal, urgent",
            completed: false
        };
        
        var changeset = Todo.changeset(Todo.new(), attrs);
        assertValidChangeset(changeset);
        
        var tags = getChangesetValue(changeset, "tags");
        assertEqual("work, personal, urgent", tags);
    }
    
    /**
     * Helper to assert specific changeset errors
     */
    private function assertChangesetError(changeset: Dynamic, field: String, message: String): Void {
        var errors = getChangesetErrors(changeset);
        var fieldErrors = getFieldErrors(errors, field);
        
        if (!arrayContains(fieldErrors, message)) {
            throw 'Expected changeset to have error "${message}" on field "${field}", but got: ${fieldErrors}';
        }
    }
    
    /**
     * Helper to get value from changeset
     */
    private function getChangesetValue(changeset: Dynamic, field: String): Dynamic {
        var changes = changeset.changes;
        return Reflect.field(changes, field);
    }
    
    /**
     * Helper to get field-specific errors
     */
    private function getFieldErrors(errors: Dynamic, field: String): Array<String> {
        var fieldErrors = Reflect.field(errors, field);
        return fieldErrors != null ? fieldErrors : [];
    }
    
    /**
     * Helper to check if array contains value
     */
    private function arrayContains(array: Array<String>, value: String): Bool {
        for (item in array) {
            if (item == value) return true;
        }
        return false;
    }
    
    /**
     * Helper to assert equality
     */
    private function assertEqual(expected: Dynamic, actual: Dynamic): Void {
        if (expected != actual) {
            throw 'Expected ${expected}, but got ${actual}';
        }
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/support/ConnCase.hx">
package test.support;

import haxe.test.phoenix.ConnCase as BaseConnCase;
import test.support.DataCase;

/**
 * ConnCase provides the foundation for Phoenix controller and LiveView tests.
 * 
 * Following Phoenix patterns, this module extends the standard library ConnCase
 * with todo-app specific helpers for integration testing.
 */
@:exunit
class ConnCase extends BaseConnCase {
    
    /**
     * Override endpoint for todo-app
     */
    override public static var endpoint(default, null): String = "TodoAppWeb.Endpoint";
    
    // Todo-app specific test helpers can be added here
    // The base ConnCase already provides all the standard functionality
}
</file>

<file path="examples/todo-app/src_haxe/test/support/DataCase.hx">
package test.support;

import haxe.test.phoenix.DataCase as BaseDataCase;
import ecto.Changeset;
import server.schemas.Todo;

/**
 * DataCase provides the foundation for Ecto schema and data tests.
 * 
 * This module extends the standard library DataCase with todo-app specific
 * helpers for testing schemas, changesets, and database operations.
 */
@:exunit
class DataCase extends BaseDataCase {
    
    /**
     * Override repository for todo-app
     */
    override public static var repo(default, null): String = "TodoApp.Repo";
    
    /**
     * Create a valid Todo changeset for testing.
     */
    override public static function validChangeset<T>(schema: Class<T>, attrs: Dynamic): Changeset<T> {
        // For Todo schema specifically
        if (schema == Todo) {
            var validAttrs = {
                title: "Test Todo",
                description: "A test todo item",
                completed: false,
                priority: "medium"
            };
            
            // Merge with provided attrs
            for (key in Reflect.fields(attrs)) {
                Reflect.setField(validAttrs, key, Reflect.field(attrs, key));
            }
            
            return cast Todo.changeset(new Todo(), validAttrs);
        }
        
        throw 'Unknown schema type: ${schema}';
    }
    
    /**
     * Create an invalid Todo changeset for testing.
     */
    override public static function invalidChangeset<T>(schema: Class<T>, attrs: Dynamic): Changeset<T> {
        // For Todo schema specifically
        if (schema == Todo) {
            var invalidAttrs = {
                title: "", // Invalid: empty title
                priority: "invalid_priority" // Invalid priority
            };
            
            // Merge with provided attrs
            for (key in Reflect.fields(attrs)) {
                Reflect.setField(invalidAttrs, key, Reflect.field(attrs, key));
            }
            
            return cast Todo.changeset(new Todo(), invalidAttrs);
        }
        
        throw 'Unknown schema type: ${schema}';
    }
    
    /**
     * Create a Todo struct for testing.
     */
    override public static function struct<T>(schema: Class<T>): T {
        if (schema == Todo) {
            return cast new Todo();
        }
        
        throw 'Unknown schema type: ${schema}';
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/web/HealthTest.hx">
package web;

import exunit.TestCase;
import exunit.Assert.*;
import phoenix.test.ConnTest;

/**
 * HealthTest
 *
 * WHAT
 * - Minimal ExUnit test authored in Haxe to validate that the app boots and renders the home page.
 *
 * WHY
 * - Provides a quick server-side integration check (ConnTest) compiled from Haxe, exercising our
 *   @:exunit pipeline and standard externs without relying on browser automation.
 *
 * HOW
 * - Uses Phoenix.ConnTest externs to build a connection and GET "/".
 * - Asserts 200 OK and basic content presence.
 */
@:exunit
class HealthTest extends TestCase {
    @:test
    public function testHomePageLoads(): Void {
        var conn = ConnTest.build_conn();
        conn = ConnTest.get(conn, "/");
        // Basic assertions: 200 OK and non-empty body via ConnTest helper
        assertTrue(conn != null);
        // Assert status directly from Conn struct type
        var status: Int = conn.status;
        assertEqual(200, status);
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/web/TodoLiveCrudTest.hx">
package web;

import exunit.TestCase;
import exunit.Assert.*;
import phoenix.test.ConnTest;
import phoenix.test.LiveViewTest;
import phoenix.test.LiveView;

@:exunit
class TodoLiveCrudTest extends TestCase {
    @:test
    public function testMountTodos(): Void {
        var conn = ConnTest.build_conn();
        var lv: LiveView = untyped __elixir__("case Phoenix.LiveViewTest.live({0}, {1}) do {:ok, v, _html} -> v end", conn, "/todos");
        assertTrue(lv != null);
        var html: String = untyped __elixir__('Phoenix.LiveViewTest.render({0})', lv);
        assertTrue(html != null);
    }

    // Keep additional CRUD steps in Playwright E2E for now; minimal LV mount here
}
</file>

<file path="examples/todo-app/src_haxe/test/AsyncAnonymousTest.hx">
package test;

import reflaxe.js.Async;
import js.lib.Promise;
import js.Browser;

/**
 * Test file demonstrating @:async anonymous function support.
 * This shows JavaScript-parity async/await with identical ergonomics.
 */
class AsyncAnonymousTest {
    
    public static function main(): Void {
        // Test 1: Event handler with @:async anonymous function
        Browser.document.addEventListener("DOMContentLoaded", @:async function(event) {
            trace("DOM loaded, starting async operations...");
            
            // Use await inside anonymous function
            var data = await(fetchDataAsync());
            trace("Fetched data: " + data);
            
            // Chain multiple async operations
            var processed = await(processDataAsync(data));
            trace("Processed: " + processed);
        });
        
        // Test 2: Array methods with @:async
        var urls = ["api/1", "api/2", "api/3"];
        
        // Map with async function
        var promises = urls.map(@:async function(url) {
            var response = await(fetchFromUrl(url));
            return response.toUpperCase();
        });
        
        // Test 3: Nested @:async functions
        var complexOperation = @:async function(): Promise<String> {
            trace("Starting complex operation");
            
            // Inner async function
            var innerAsync = @:async function(value: String): Promise<String> {
                var result = await(Async.delay(value, 100));
                return "Inner: " + result;
            };
            
            var result = await(innerAsync("test"));
            return "Outer: " + result;
        };
        
        // Test 4: Async IIFE (Immediately Invoked Function Expression)
        (@:async function() {
            trace("Async IIFE starting");
            var config = await(loadConfig());
            trace("Config loaded: " + config);
        })();
        
        // Test 5: Callback conversion with @:async
        setTimeout(@:async function() {
            trace("Timer fired, doing async work");
            var result = await(doAsyncWork());
            trace("Async work complete: " + result);
        }, 1000);
        
        // Test 6: Promise constructor with @:async executor
        var customPromise = new Promise(@:async function(resolve, reject) {
            try {
                var data = await(riskyOperation());
                resolve(data);
            } catch (e: Dynamic) {
                reject(e);
            }
        });
        
        // Test 7: Object methods with @:async
        var handler = {
            onClick: @:async function(event): Promise<Void> {
                var target = event.target;
                var data = await(fetchDataForElement(target));
                updateUI(data);
            },
            
            onSubmit: @:async function(event): Promise<Bool> {
                event.preventDefault();
                var formData = await(validateForm(event.target));
                var success = await(submitForm(formData));
                return success;
            }
        };
    }
    
    // Helper async functions for testing
    
    static function fetchDataAsync(): Promise<String> {
        return Async.delay("sample data", 100);
    }
    
    static function processDataAsync(data: String): Promise<String> {
        return Async.delay(data.toUpperCase(), 50);
    }
    
    static function fetchFromUrl(url: String): Promise<String> {
        return Async.delay("Response from " + url, 200);
    }
    
    static function loadConfig(): Promise<Dynamic> {
        return Async.resolve({apiUrl: "https://api.example.com", timeout: 5000});
    }
    
    static function doAsyncWork(): Promise<String> {
        return Async.delay("work completed", 300);
    }
    
    static function riskyOperation(): Promise<String> {
        return Math.random() > 0.5 
            ? Async.resolve("success")
            : Async.reject("random failure");
    }
    
    static function fetchDataForElement(element: Dynamic): Promise<Dynamic> {
        return Async.resolve({id: "el-1", value: "clicked"});
    }
    
    static function updateUI(data: Dynamic): Void {
        trace("Updating UI with: " + data);
    }
    
    static function validateForm(form: Dynamic): Promise<Dynamic> {
        return Async.resolve({valid: true, data: {}});
    }
    
    static function submitForm(formData: Dynamic): Promise<Bool> {
        return Async.delay(true, 500);
    }
    
    static function setTimeout(callback: Void -> Void, ms: Int): Void {
        Browser.window.setTimeout(callback, ms);
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/AsyncTest.hx">
package test;

import reflaxe.js.Async;

/**
 * Test class for async/await functionality.
 * 
 * Demonstrates the new @:async syntax and await() macro usage
 * with type-safe Promise handling.
 */
@:build(reflaxe.js.Async.build())
class AsyncTest {
    
    /**
     * Test basic async function with await.
     * 
     * This function should compile to:
     * ```javascript
     * async function testBasicAsync() {
     *     var result = await Promise.resolve("Hello");
     *     return result + " World";
     * }
     * ```
     */
    @:async
    public static function testBasicAsync(): js.lib.Promise<String> {
        var result = Async.await(js.lib.Promise.resolve("Hello"));
        return js.lib.Promise.resolve(result + " World");
    }
    
    /**
     * Test async function with multiple awaits.
     * 
     * Demonstrates sequential async operations with proper type inference.
     */
    @:async
    public static function testMultipleAwaits(): js.lib.Promise<String> {
        var greeting = Async.await(js.lib.Promise.resolve("Hello"));
        var target = Async.await(js.lib.Promise.resolve("Phoenix"));
        var punctuation = Async.await(js.lib.Promise.resolve("!"));
        
        return js.lib.Promise.resolve(greeting + " " + target + punctuation);
    }
    
    /**
     * Test async function with error handling.
     * 
     * Uses try/catch with async/await for proper error propagation.
     */
    @:async
    public static function testErrorHandling(): js.lib.Promise<String> {
        try {
            var result = Async.await(js.lib.Promise.reject("Error occurred"));
            return js.lib.Promise.resolve(result);
        } catch (error: Dynamic) {
            return js.lib.Promise.resolve("Caught: " + error);
        }
    }
    
    /**
     * Test async function with conditional await.
     * 
     * Demonstrates await usage in conditional expressions.
     */
    @:async
    public static function testConditionalAwait(useAsync: Bool): js.lib.Promise<String> {
        if (useAsync) {
            var result = Async.await(js.lib.Promise.resolve("Async result"));
            return js.lib.Promise.resolve(result);
        } else {
            return js.lib.Promise.resolve("Sync result");
        }
    }
    
    /**
     * Helper function that returns a Promise for testing.
     */
    public static function createDelayedPromise(value: String, delayMs: Int): js.lib.Promise<String> {
        return new js.lib.Promise(function(resolve, reject) {
            js.Browser.window.setTimeout(function() {
                resolve(value);
            }, delayMs);
        });
    }
    
    /**
     * Test async function with delayed operations.
     * 
     * Demonstrates real-world async patterns with delays.
     */
    @:async
    public static function testDelayedOperations(): js.lib.Promise<String> {
        var first = Async.await(createDelayedPromise("First", 100));
        var second = Async.await(createDelayedPromise("Second", 50));
        var third = Async.await(createDelayedPromise("Third", 25));
        
        return js.lib.Promise.resolve(first + " -> " + second + " -> " + third);
    }
    
    /**
     * Entry point for testing async functionality.
     * 
     * This function can be called from PhoenixApp to verify
     * that async/await compilation works correctly.
     */
    public static function main(): Void {
        js.Browser.console.log("üß™ Starting async/await tests...");
        runTests();
    }
    
    /**
     * Runs all async/await tests.
     * 
     * This function can be called from PhoenixApp to verify
     * that async/await compilation works correctly.
     */
    public static function runTests(): js.lib.Promise<String> {
        js.Browser.console.log("üß™ Running async/await tests...");
        
        // Test basic async functionality
        return testBasicAsync().then(function(result) {
            js.Browser.console.log("‚úÖ Basic async test:", result);
            return testMultipleAwaits();
        }).then(function(result) {
            js.Browser.console.log("‚úÖ Multiple awaits test:", result);
            return testErrorHandling();
        }).then(function(result) {
            js.Browser.console.log("‚úÖ Error handling test:", result);
            return testConditionalAwait(true);
        }).then(function(result) {
            js.Browser.console.log("‚úÖ Conditional await test:", result);
            return testDelayedOperations();
        }).then(function(result) {
            js.Browser.console.log("‚úÖ Delayed operations test:", result);
            js.Browser.console.log("üéâ All async/await tests completed successfully!");
            return "All tests passed";
        }).catchError(function(error) {
            js.Browser.console.error("‚ùå Async test failed:", error);
            return "Tests failed: " + error;
        });
    }
}
</file>

<file path="examples/todo-app/src_haxe/test/test_helper.hx">
package test;

/**
 * Test helper configuration for the todo-app test suite
 * Sets up ExUnit, Ecto sandbox, and test environment
 */
class TestHelper {
    
    /**
     * Main test setup function
     * Configures the test environment and starts necessary services
     */
    public static function main(): Void {
        setupExUnit();
        setupEctoSandbox();
        startApplication();
    }
    
    /**
     * Configure ExUnit test framework
     */
    private static function setupExUnit(): Void {
        // Configure ExUnit with custom formatters and options
        ExUnit.configure([
            "capture_log" => true,
            "trace" => true,
            "timeout" => 60000, // 60 seconds timeout for tests
            "max_cases" => 4,   // Run tests in parallel with 4 processes
            "exclude" => ["integration"] // Exclude integration tests by default
        ]);
        
        // Start ExUnit
        ExUnit.start();
    }
    
    /**
     * Set up Ecto sandbox for test database isolation
     */
    private static function setupEctoSandbox(): Void {
        // Configure Ecto for test mode
        Ecto.Sandbox.mode(TodoApp.Repo, "manual");
        
        // Set up test database if needed
        ensureTestDatabase();
    }
    
    /**
     * Start the application for testing
     */
    private static function startApplication(): Void {
        // Start the TodoApp application
        Application.ensure_all_started("todo_app");
        
        // Ensure Phoenix endpoint is started for LiveView tests
        TodoAppWeb.Endpoint.start_link();
    }
    
    /**
     * Ensure test database exists and is migrated
     */
    private static function ensureTestDatabase(): Void {
        // Create test database if it doesn't exist
        Mix.Task.run("ecto.create", ["--quiet"]);
        
        // Run migrations
        Mix.Task.run("ecto.migrate", ["--quiet"]);
    }
    
    /**
     * Clean up test environment after all tests
     */
    public static function cleanup(): Void {
        // Stop the application
        Application.stop("todo_app");
        
        // Clean up test database
        cleanupTestDatabase();
    }
    
    /**
     * Clean up test database
     */
    private static function cleanupTestDatabase(): Void {
        // Drop test database
        Mix.Task.run("ecto.drop", ["--quiet"]);
    }
}

/**
 * External references to Elixir modules
 * These would be proper extern definitions in a real implementation
 */
@:native("ExUnit")
extern class ExUnit {
    public static function configure(options: Dynamic): Void;
    public static function start(): Void;
}

@:native("Ecto.Sandbox")
extern class EctoSandbox {
    public static function mode(repo: Dynamic, mode: String): Void;
}

@:native("Application")
extern class Application {
    public static function ensure_all_started(app: String): Dynamic;
    public static function stop(app: String): Void;
}

@:native("Mix.Task")
extern class MixTask {
    public static function run(task: String, args: Array<String>): Dynamic;
}

@:native("TodoApp.Repo")
extern class TodoAppRepo {
    // Repository functions would be defined here
}

@:native("TodoAppWeb.Endpoint")
extern class TodoAppWebEndpoint {
    public static function start_link(): Dynamic;
}
</file>

<file path="examples/todo-app/src_haxe/TestAbstract.hx">
abstract TestAbstract(String) from String to String {
    public function new(s: String) {
        this = s;
    }
    
    public function getValue(): String {
        return this;
    }
    
    public static function staticTest(value: TestAbstract): String {
        return value;
    }
}

class TestMain {
    static function main() {
        var t = new TestAbstract("test");
        trace(t.getValue());
    }
}
</file>

<file path="examples/todo-app/src_haxe/TestInjection.hx">
/**
 * Test and documentation for __elixir__() code injection mechanism
 * 
 * CRITICAL: Understanding __elixir__() Injection Syntax
 * ======================================================
 * 
 * The __elixir__() function allows injecting raw Elixir code into generated output.
 * However, it has specific requirements for how variables are substituted.
 * 
 * WHY $variable SYNTAX DOESN'T WORK:
 * -----------------------------------
 * When you write: untyped __elixir__('$x * 2')
 * 
 * Haxe's parser sees the $ and interprets this as STRING INTERPOLATION at compile-time.
 * This means Haxe tries to concatenate strings: "" + x + " * 2"
 * 
 * The result is that the TypedExpr becomes:
 *   TBinop(OpAdd, TConst(""), TBinop(OpAdd, TLocal(x), TConst(" * 2")))
 * 
 * This is NOT a constant string, so Reflaxe's TargetCodeInjection.checkTargetCodeInjection
 * cannot process it because it requires the first parameter to be TConst(TString(s)).
 * 
 * HOW {N} PLACEHOLDERS WORK:
 * ---------------------------
 * The correct syntax uses numbered placeholders: {0}, {1}, {2}, etc.
 * 
 * When you write: untyped __elixir__('{0} * 2', x)
 * 
 * 1. The first parameter IS a constant string: "{0} * 2"
 * 2. Reflaxe's injection system recognizes this pattern
 * 3. It compiles the variable x separately to get its Elixir representation
 * 4. It replaces {0} with the compiled result
 * 
 * RULES FOR __elixir__() USAGE:
 * ------------------------------
 * 1. First parameter MUST be a constant string literal (no concatenation)
 * 2. Use {0}, {1}, {2}... for variable substitution
 * 3. Variables are passed as additional parameters
 * 4. Variables are compiled to Elixir and substituted at their placeholder positions
 * 5. Keyword lists and atoms should be written directly in the string
 * 
 * EXAMPLES:
 * ---------
 * WRONG: untyped __elixir__('$x * 2')                    // $ causes string interpolation
 * WRONG: untyped __elixir__(myString)                    // Not a constant
 * WRONG: untyped __elixir__('func(' + x + ')')          // String concatenation
 * 
 * RIGHT: untyped __elixir__('{0} * 2', x)               // Placeholder substitution
 * RIGHT: untyped __elixir__('func({0}, {1})', a, b)     // Multiple variables
 * RIGHT: untyped __elixir__(':ok')                      // Direct atom injection
 * RIGHT: untyped __elixir__('[a: 1, b: 2]')            // Direct keyword list
 * 
 * @see https://github.com/SomeRanDev/reflaxe - Reflaxe documentation
 * @see reflaxe.compiler.TargetCodeInjection - The injection implementation
 */
class TestInjection {
    public static function testDirectInjection(): String {
        // Test 1: Simple string injection
        return untyped __elixir__('"Hello from Elixir"');
    }
    
    public static function testVariableSubstitution(): Int {
        // Test 2: Variable substitution in injection using {N} placeholders
        var x = 42;
        return untyped __elixir__('{0} * 2', x);
    }
    
    public static function testSupervisorCall() {
        // Test 3: What Telemetry needs - inject keyword list directly
        var children = [];
        // For keyword lists, inject them directly into the Elixir code
        return untyped __elixir__('Supervisor.start_link({0}, [strategy: :one_for_one, name: TestSupervisor])', children);
    }
    
    public static function testComplexInjection() {
        // Test 4: More complex injection with multiple variables
        var module = "TestModule";
        var func = "test_func";
        var args = [1, 2, 3];
        return untyped __elixir__('{0}.{1}({2})', module, func, args);
    }
}
</file>

<file path="examples/todo-app/src_haxe/TestInline.hx">
package;

import phoenix.Phoenix.LiveView;
import phoenix.Phoenix.Socket;

class TestInline {
    public static function testBoth() {
        var socket: Socket<{name: String}> = null;
        
        // Test inline function - should expand at compile time
        var s1 = LiveView.assign_multiple(socket, {name: "Test"});
        
        // Test direct function
        var s2 = LiveView.assign(socket, {name: "Test2"});
        
        return s1;
    }
}
</file>

<file path="examples/todo-app/src_haxe/TestStringBuf.hx">
class TestStringBuf {
    public static function test(): String {
        var buf = new StringBuf();
        buf.add("Testing ");
        buf.add("StringBuf ");
        buf.add("in todo-app");
        
        var result = buf.toString();
        trace('StringBuf test: $result');
        
        // Test with numbers
        var buf2 = new StringBuf();
        buf2.add("Count: ");
        for (i in 1...4) {
            buf2.add(i);
            buf2.add(" ");
        }
        trace('Numbers: ${buf2.toString()}');
        
        return result;
    }
}
</file>

<file path="examples/todo-app/src_haxe/TodoApp.hx">
package;

import phoenix.Phoenix;
import elixir.otp.Application;
import elixir.otp.Supervisor.SupervisorExtern;
import elixir.otp.Supervisor.SupervisorStrategy;
import elixir.otp.Supervisor.SupervisorOptions;
import elixir.otp.TypeSafeChildSpec;
import elixir.otp.Supervisor.ChildSpecFormat;

/**
 * Main TodoApp application module
 * Defines the OTP application supervision tree
 */
@:application
@:appName("TodoApp")  
class TodoApp {
    /**
     * Start the application
     */
    @:keep
    public static function start(type: ApplicationStartType, args: ApplicationArgs): ApplicationResult {
        // Define children for the supervision tree using type-safe child specs
        var children: Array<ChildSpecFormat> = [
            // Database repository - Ecto.Repo handles Postgrex.TypeManager internally
            ModuleRef("TodoApp.Repo"),
            
            // PubSub system with proper child spec
            TypeSafeChildSpec.pubSub("TodoApp.PubSub"),
            
            // Presence tracker - starts Phoenix.Tracker backing ETS tables
            // Presence module defines child_spec via `use Phoenix.Presence`
            ModuleRef("TodoAppWeb.Presence"),
            
            // Telemetry supervisor
            TypeSafeChildSpec.telemetry("TodoAppWeb.Telemetry"),
            
            // Web endpoint
            TypeSafeChildSpec.endpoint("TodoAppWeb.Endpoint")
        ];

        // Start supervisor with children using type-safe SupervisorExtern + options builder
        return SupervisorExtern.startLink(children, elixir.otp.Supervisor.SupervisorOptionsBuilder.defaults());
    }

    /**
     * Called when application is preparing to shut down
     * State is whatever was returned from start/2
     */
    @:keep
    public static function prep_stop(state: Dynamic): Dynamic {
        // For now, keep Dynamic since this is rarely customized
        // and state type varies based on application needs
        return state;
    }
}
</file>

<file path="examples/todo-app/src_haxe/TodoAppRouter.hx">
package;

import reflaxe.elixir.macros.HttpMethod;

/**
 * Type-safe Router DSL example demonstrating enhanced syntax
 * 
 * This example shows how to use HttpMethod enum and class references
 * instead of error-prone string literals for better compile-time safety.
 */
@:native("TodoAppWeb.Router")
@:router
@:build(reflaxe.elixir.macros.RouterBuildMacro.generateRoutes())
@:routes([
    // Type-safe method using HttpMethod enum
    {
        name: "root", 
        method: HttpMethod.LIVE, 
        path: "/", 
        controller: "server.live.TodoLive",  // this is not type safe, needs to be the actual controller type. This DSL should be as expressive as the Elixir one, but typesafe.
        action: "index"
    },
    
    // Standard HTTP methods with enum
    {
        name: "todosIndex", 
        method: HttpMethod.LIVE, 
        path: "/todos", 
        controller: "server.live.TodoLive", 
        action: "index"
    },
    
    {
        name: "todosShow", 
        method: HttpMethod.LIVE, 
        path: "/todos/:id", 
        controller: "server.live.TodoLive", 
        action: "show"
    },
    
    {
        name: "todosEdit", 
        method: HttpMethod.LIVE, 
        path: "/todos/:id/edit", 
        controller: "server.live.TodoLive", 
        action: "edit"
    },
    
    // API endpoints temporarily removed until User context/schema stabilized
    
    // LiveDashboard with enum
    {
        name: "dashboard", 
        method: HttpMethod.LIVE_DASHBOARD, 
        path: "/dev/dashboard"
    }
])
class TodoAppRouter {
    // Functions auto-generated with type-safe route helpers!
    // 
    // Generated functions:
    // public static function root(): String { return "/"; }
    // public static function todosIndex(): String { return "/todos"; }
    // public static function apiTodos(): String { return "/api/todos"; }
    // etc.
}
</file>

<file path="examples/todo-app/build-all.hxml">
# Build both Elixir backend and JavaScript frontend

# Elixir backend compilation
--next
-cp src_haxe
-lib reflaxe.elixir
-D reflaxe.output=lib
-D reflaxe_runtime
--main Main
--cmd echo "‚úÖ Elixir compilation complete!"

# JavaScript frontend compilation  
--next
-cp src_haxe/client
-main TodoApp
-js priv/static/js/todo-app.js
-dce full
# NOTE: -D analyzer-optimize removed - destroys functional patterns
--cmd echo "‚úÖ JavaScript compilation complete!"

--cmd echo "üöÄ Full compilation complete! Both Elixir and JavaScript targets built."
</file>

<file path="examples/todo-app/build-client.hxml">
# Haxe‚ÜíJavaScript compilation for Phoenix LiveView client-side code
# Generates efficient ES6 modules compatible with esbuild

# Source directories (client only)
-cp src_haxe/client
-cp src_haxe
# Enable Genes ES6 generator (uses haxe_libraries/genes.hxml)
-lib genes

# JavaScript target output (separate from Phoenix bootstrap to avoid overwriting LiveView init)
-js assets/js/hx_app.js
-D js-unflatten               # Better module structure
# NOTE: -D analyzer-optimize removed - destroys functional patterns
--dce=full

# Haxe 4.3+ optimizations
-D real-position              # Better source maps
-D js-source-map              # Generate source maps

# Exclude server code from client compilation
--macro exclude('server')

# Main client entry point - minimal boot for Phoenix hooks
-main client.Boot
</file>

<file path="examples/todo-app/build-js.hxml">
# Haxe to JavaScript compilation for client-side code
-cp src_haxe
-main client.TodoApp
-js assets/js/todo-app-haxe.js
-dce full
# NOTE: -D analyzer-optimize removed - destroys functional patterns
-D js-es=6
-D no-traces

# Optimize for production
-D production
-D dead-code-elimination

# Browser target (no Node.js)
--cmd echo "‚úÖ Haxe JavaScript compilation complete!"
</file>

<file path="examples/todo-app/build-server-multipass.hxml">
# Aggregated server build using micro-passes A..F
#
# This file exists to let tools like Mix.Tasks.Compile.Haxe run the same
# micro-pass partitioning strategy that QA sentinel uses, without hard-coding
# pass names in the compiler. It simply chains the existing pass hxml files.
#
# Passes:
#   - A1..A3: Repo and core infrastructure
#   - B..E:   additional server modules and infrastructure
#   - F:      LiveView main (TodoLive)

--next build-server-passA1.hxml
--next build-server-passA2.hxml
--next build-server-passA3.hxml
--next build-server-passB.hxml
--next build-server-passC.hxml
--next build-server-passD.hxml
--next build-server-passE.hxml
--next build-server-passF.hxml
</file>

<file path="examples/todo-app/build-test-async.hxml">
-cp src_haxe
-cp ../../std
-main test.AsyncTest
-js test_async.js

# Enable the custom async JavaScript generator
--macro reflaxe.js.AsyncJSGenerator.use()

-D js-es=6
</file>

<file path="examples/todo-app/build-test-hang.hxml">
-cp .
--main TestHang
-lib reflaxe
-cp ../../src
-cp ../../std
--macro reflaxe.elixir.CompilerInit.Start()
-D elixir_output=./test_output
-D debug_output_iterator
-D debug_module_sorting
-D debug_compilation_flow
</file>

<file path="examples/todo-app/build-tests.hxml">
# Haxe‚ÜíElixir compilation for ExUnit tests (MIX_ENV=test)

# Include Reflaxe.Elixir compiler sources and stdlib overlays/externs
 -cp ../../src
 -cp ../../std
 -lib reflaxe

# Test sources only (avoid compiling app/server code into test output)
-cp src_haxe/test

# Output directory for generated test modules (isolated)
-D elixir_output=test/generated

# Required flags
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full

# Initialize compiler
-D reflaxe.elixir=0.1.0
--macro reflaxe.elixir.CompilerInit.Start()

# Include test modules (explicit for now; add more as needed)
web.HealthTest
web.TodoLiveCrudTest
live.TodoLiveDueDateTest
</file>

<file path="examples/todo-app/build.hxml">
# Main build configuration - delegates to server build
# Use build-client.hxml for JavaScript compilation
# Use build-server.hxml for Elixir compilation (default)

--next build-server.hxml
</file>

<file path="examples/todo-app/mix.exs">
defmodule TodoApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :todo_app,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      # Ensure Haxe server-side code compiles as part of `mix compile`
      compilers: [:haxe] ++ Mix.compilers(),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps(),
      haxe: [
        # Use the micro-pass server build so Mix.compilers align with QA sentinel
        # and keep Haxe server builds bounded and incremental.
        hxml_file: "build-server-multipass.hxml",
        source_dir: "src_haxe",
        target_dir: "lib",
        # Keep watcher disabled here; we start a watcher via Endpoint watchers (dev.exs)
        watch: false,
        verbose: false
      ]
    ]
  end

  # Configuration for the OTP application.
  def application do
    [
      mod: {TodoApp.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(:e2e), do: ["lib"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  defp deps do
    [
      # Add parent project as dependency for Haxe compilation functionality
      {:reflaxe_elixir, path: "../..", only: [:dev, :test, :e2e]},
      {:phoenix, "~> 1.7.0"},
      {:phoenix_ecto, "~> 4.4"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:phoenix_html, "~> 3.3"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 0.20.0"},
      {:floki, ">= 0.30.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.8.0"},
      {:esbuild, "~> 0.8", runtime: Mix.env() == :dev},
      {:tailwind, "~> 0.2", runtime: Mix.env() == :dev},
      {:telemetry_metrics, "~> 0.6"},
      {:telemetry_poller, "~> 1.0"},
      {:telemetry_metrics_prometheus_core, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      # Webserver stack pinned for OTP 27 compatibility (see TODOAPP_COWBOY_TOOLCHAIN_ISSUE_REPORT.md)
      {:plug_cowboy, "~> 2.7.5", override: true},
      {:cowboy, "~> 2.14.2", override: true},
      {:cowlib, "~> 2.16.0", override: true},
      {:ranch, "~> 2.2", override: true},
      {:file_system, "~> 1.1", only: [:dev, :test]}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup", "assets.setup", "assets.build"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      # Compile Haxe ExUnit tests before running mix test
      test: ["haxe.compile.tests", "ecto.create --quiet", "ecto.migrate --quiet", "test"],
      "assets.setup": ["tailwind.install --if-missing", "esbuild.install --if-missing"],
      "assets.build": ["haxe.compile.client", "tailwind todo_app", "esbuild todo_app"],
      "assets.deploy": ["haxe.compile.client", "tailwind todo_app --minify", "esbuild todo_app --minify --tree-shaking=true --drop:debugger --drop:console", "phx.digest"],
      "haxe.compile.client": ["cmd haxe build-client.hxml"],
      "haxe.compile.tests": ["cmd haxe build-tests.hxml"]
    ]
  end
end
</file>

<file path="docs/03-compiler-development/TRANSFORMER_ESSENTIAL_PASSES_TODOLIVE.md">
Transformer Essential Passes ‚Äì TodoLive/LiveView Focus
=====================================================

Context
-------

- Regression analysis shows the first Haxe compile ‚Äúhang‚Äù for the todo‚Äëapp server build at commit `76abdeb3`, which introduced a large batch of binder/assign hygiene transforms and rewired the pass registry.
- Profiling on HEAD using `-D hxx_instrument_sys` and a bounded `build-server-passF.hxml` run indicates:
  - Individual transformer passes all report `<1ms` (`ms=0` after rounding) for modules that complete before timeout.
  - `ElixirASTTransformer.total` per module is typically `4‚Äì11 ms`, so no **single** transform pass currently dominates wall‚Äëclock time.
- The hang behavior must therefore be explained by **aggregate work** across many passes and/or by **typed/macro phases** (HXX/TemplateHelpers/etc.), not by one pathological AST pass.

This document identifies **essential** transformer passes that are critical for semantics on LiveView modules like `server.live.TodoLive`, distinguishes them from late hygiene, and records design/complexity expectations for each.

Essential Semantic Pass Families
--------------------------------

The following are considered essential in the context of TodoLive and Phoenix idioms. They must remain active even in fast profiles (fast_boot) and must be kept algorithmically bounded.

### 1. LiveViewTypedEventBridgeTransforms

File: `src/reflaxe/elixir/ast/transformers/LiveViewTypedEventBridgeTransforms.hx`

**Role**

- Generates idiomatic `handle_event/3` callbacks from a typed `handleEvent(enum, socket)` function in `@:liveview` modules.
- Bridges fully typed Haxe event enums to the runtime `handle_event/3` API Phoenix expects.

**Complexity Notes**

- Operates per module:
  - Scans top‚Äëlevel definitions of a LiveView module.
  - Locates a single `handleEvent/2` (or `handle_event/2`) and its `case` on the event argument.
  - Synthesizes one handle_event clause per case branch, plus a rewrite pass over existing `handle_event/3` clauses.
- Complexity is effectively linear in the size of the module body.
- Profiling does not show it as a wall‚Äëclock hotspot on HEAD for TodoLive.

**Requirements**

- Must not grow beyond linear complexity in the number of clauses and functions in a module.
- Any future changes must:
  - Avoid nested full‚Äëmodule rescans.
  - Preserve shape‚Äëbased behavior (no app‚Äëname heuristics).

### 2. CaseSuccessVarUnifyTransforms (+ CaseSuccessVarUnifier)

File: `src/reflaxe/elixir/ast/transformers/CaseSuccessVarUnifyTransforms.hx`

**Role**

- Reconciles success binders in `{:ok, _x}` patterns with the names actually used in clause bodies, to fix undefined variable issues introduced by earlier underscore hygiene.
- Works in tandem with CaseSuccessVarUnifier to ensure bodies reference a declared success variable.

**Complexity Notes**

- Operates per case expression:
  - For each `ECase`, iterates its clauses once.
  - For each clause, walks the clause body to collect used names into a `Map<String,Bool>`.
  - Applies a simple pattern rewrite when a single underscored binder has a matching usage in the body.
- Complexity is linear in the number of clauses and in the size of each clause body.
- Profiling shows no evidence that this pass is a millisecond‚Äëscale hotspot on TodoLive.

**Requirements**

- Must preserve O(N) behavior (N = total AST nodes in case bodies).
- Future modifications must:
  - Reuse collected usage maps instead of recomputing them.
  - Avoid nested traversals beyond what is strictly necessary for each clause.

### 3. RepoGetBinderRepairTransforms

File: `src/reflaxe/elixir/ast/transformers/RepoGetBinderRepairTransforms.hx`

**Role**

- Repairs trivial `get_*` helpers that accidentally return undeclared locals (e.g., `def get_user(id), do: user`) by reconstructing a `Repo.get(schema, id)` call using shape‚Äëderived data from sibling `Repo.get/2` or `Repo.all/1` calls.
- Prevents hard compile errors without introducing app‚Äëspecific naming heuristics.

**Complexity Notes**

- Phases:
  - `collectRepoGetInfo` walks the module‚Äôs AST once, collecting repository+schema info into a `Map`.
  - `rewriteFunctions` walks function bodies to identify bare variable returns that match known schema bases.
- Both phases are single‚Äëwalk and re‚Äëuse the same `Map`, so complexity is linear in the size of the module.
- Profiling does not show it as an outlier; it remains below 1ms per module.

**Requirements**

- Must remain single‚Äëpass per module for info collection and rewrite.
- Future enhancements should:
  - Avoid additional full‚Äëmodule scans; any extra data should be piggy‚Äëbacked onto the existing walk.
  - Maintain the strict shape‚Äëbased matching (no dependence on todo‚Äëapp names such as ‚Äútodo‚Äù).

### 4. GuardGrouping and PatternMatchingTransforms

Files:

- `src/reflaxe/elixir/ast/transformers/GuardConditionFlattener/GuardGrouping` (via `alias_guardGroupingPass`)
- `src/reflaxe/elixir/ast/transformers/PatternMatchingTransforms.hx`

**Role**

- Normalize nested `if`‚Äëbased guard chains in `case` expressions into flatter, idiomatic patterns and conds.
- Serve as foundation for many Phoenix and Ecto pattern rewrites.

**Complexity Notes**

- Grouped around:
  - One pass over the AST to find `ECase` nodes with guard patterns.
  - Per‚Äëclause guard extraction and validation, with bounded, local traversal.
- Profiling indicates these passes are not currently wall‚Äëclock bottlenecks for TodoLive; they remain <1ms per module in timed runs.

**Requirements**

- Continue to operate in at most linear time w.r.t. clause bodies.
- Any additional pattern forms or validations must reuse existing visitor logic and avoid new global rescans.

Summary and Guidance
--------------------

- Essential semantic transforms used by TodoLive (LiveViewTypedEventBridge, CaseSuccessVar* passes, RepoGetBinderRepair, GuardGrouping/PatternMatching) are **already structured as single‚Äëpass or locally scoped traversals**.
- Current profiling shows **no single transform dominates module‚Äëlevel time**; each pass is effectively sub‚Äëmillisecond per module, while `ElixirASTTransformer.total` per module is only a few milliseconds.
- The observed >60s behavior for `build-server-passF.hxml` is therefore more likely due to:
  - The macro/typing phase (HXX/HXXMacro, TemplateHelpers, macro validation), or
  - The cumulative cost of running many passes across many modules, rather than any one essential pass.

For future work:

- If a transform in this list is extended or refactored, the default expectation is:
  - Keep it single‚Äëpass over the module or expression tree.
  - Reuse analysis results via maps/indices instead of scanning the same structures multiple times.
  - Add `-D hxx_instrument_sys`‚Äëaware timing if deeper investigation is needed, but do not couple any logic to todo‚Äëapp specifics.
</file>

<file path="docs/03-compiler-development/TRANSFORMER_PERF_TODOLIVE.md">
# Transformer Performance on `server.live.TodoLive`

## Context

- Regression: first Haxe compile hang for the todo-app appears at commit `76abdeb3`.
- TodoLive.hx is unchanged across the regression; the slowdown is in compiler pipeline.
- This document records transformer timing measurements for the LiveView server pass (`build-server-passF.hxml`) on HEAD using `-D hxx_instrument_sys` and the new `[PassTiming]` instrumentation in `ElixirASTTransformer`.

## Instrumentation Setup

- Added flag‚Äëgated timing in `ElixirASTTransformer.transform`:
  - Per‚Äëpass timing: `[PassTiming] name=<passName> ms=<elapsed>` for each pass in the registry when `-D hxx_instrument_sys` is defined.
  - Pipeline total: `[PassTiming] name=ElixirASTTransformer.total ms=<elapsed>` per module.
- This code is entirely behind `#if hxx_instrument_sys` and does not affect normal builds.

## Measurement Command (HEAD)

```bash
cd examples/todo-app
HAXE_USE_SERVER=0 ../../scripts/with-timeout.sh --secs 60 -- \
  haxe -D hxx_instrument_sys build-server-passF.hxml \
  > /tmp/passF-head.log 2>&1
```

Notes:
- We use `with-timeout.sh` to keep the run bounded (60s) per AGENTS constraints.
- The timeout fired with exit code 143; the log still contains complete timing for many modules and passes prior to the kill.

## High-Level Findings

- The log contains ~19,800 `[PassTiming]` lines.
- For the modules that completed their transform phase before timeout:
  - **All individual passes report `ms=0`** at integer millisecond resolution.
  - The only entries with non‚Äëzero timings are `ElixirASTTransformer.total` per module, typically `4‚Äì11 ms`:

    ```text
    [PassTiming] name=ElixirASTTransformer.total ms=7
    [PassTiming] name=ElixirASTTransformer.total ms=4
    ...
    [PassTiming] name=ElixirASTTransformer.total ms=11
    ```

- This indicates:
  - Each individual transform pass runs in <1ms for the observed modules (rounded down to `0` by `Std.int`).
  - The **transformer pipeline as a whole** per module is on the order of single‚Äëdigit milliseconds.
  - The 60‚Äësecond timeout is dominated by earlier phases (typing, macros such as HXX/TemplateHelpers, and/or repeated compilation of many modules), not by a single pathological AST transform.

## Impact on Hypotheses

- Original suspicion: the batch of LHS/binder/assign hygiene passes added at `76abdeb3` caused the hang via expensive AST walks.
- Measurement suggests a more nuanced picture:
  - For modules reached before the timeout, hygiene and case/binder passes are individually cheap.
  - The slowdown may instead be due to:
    - Macros that run before the AST transformer (HXX, TemplateHelpers, HEEx macros).
    - The cumulative cost of running many passes across many modules.
    - The overall Haxe typing and macro evaluation phase, not the transform loop itself.

## Next Steps

1. Keep `[PassTiming]` instrumentation in `ElixirASTTransformer` as a diagnostic tool.
2. For further analysis, add similar timing wrappers around:
   - Macro entry points (HXX/HXXMacro/RouterBuildMacro/ModuleMacro).
   - TemplateHelpers operations in the macro phase.
3. Combine transformer timing with macro timing to build a complete wall‚Äëclock picture of where time is spent during the `build-server-passF.hxml` run.
4. Use this combined data to decide whether to:
   - Gate cosmetic passes under `fast_boot` / `disable_hygiene_final` (still useful to reduce work), and/or
   - Prioritize macro‚Äëlevel optimizations and caching for TodoLive templates.

At this stage, the key conclusion is that **no single AST transform pass stands out as a dominant millisecond‚Äëscale hotspot on HEAD**; the hang behavior must be explained by earlier phases or aggregate work across many transformations.
</file>

<file path="docs/prds/HAXE_ELIXIR_1_0_COMPILER_TODOAPP_PRD.md">
Reflaxe.Elixir 1.0 ‚Äì Compiler + Todo-App PRD
============================================

Vision
------

Deliver a production‚Äëquality Haxe‚ÜíElixir compiler that:

- Uses a **pure AST pipeline** (TypedExpr ‚Üí ElixirAST ‚Üí transforms ‚Üí printer).
- Generates **idiomatic Elixir/Phoenix/Ecto/OTP** code that looks hand‚Äëwritten.
- Builds and runs the **todo-app** as a first‚Äëclass end‚Äëto‚Äëend test with:
  - Zero Haxe compiler warnings.
  - Zero Mix compile warnings (warnings‚Äëas‚Äëerrors clean).
  - Zero runtime warnings/errors in Phoenix logs under LiveView + Playwright smoke.
- Compiles within **bounded time** ‚Äì no apparent hangs, no unbounded passes.

This document ties together the existing 1.0 PRD (docs/08-roadmap/1.0-PRD.md) and the active todo‚Äëapp PRD (docs/08-roadmap/ACTIVE_PRD.md) with the latest findings about transformer performance and the regression at commit `76abdeb3`.

Non‚ÄëNegotiable Constraints
--------------------------

- **AST pipeline only**
  - All compilation must go through ElixirAST; no string concatenation emitters.
  - No alternative backdoors that bypass builders/transformers/printer.

- **No band‚Äëaids**
  - Fix root causes instead of masking symptoms.
  - No TODOs left in production code as ‚Äútemporary‚Äù workarounds.
  - No arbitrary limits added just to break infinite loops.
  - No string post‚Äëprocessing to patch bad output.
  - No `-D analyzer-optimize` in server builds.

- **No app‚Äëspecific heuristics**
  - Transformers must not key behavior on todo‚Äëapp names, atoms, routes or variable names.
  - Allowed decisions are based on shape (AST, annotations, types) and documented APIs, never on domain words like ‚Äútodo‚Äù, ‚Äúupdated_todo‚Äù, ‚Äútoggle_todo‚Äù.

- **Runtime artifact rule**
  - Do not edit generated `.ex` files to fix behavior.
  - All fixes must be made in compiler `.hx` sources or std/_std Haxe sources and validated via snapshots and QA sentinel.

- **Module size constraint**
  - Any compiler `.hx` module (builders, transformers, helpers) must remain **< 2000 LOC**.
  - If approaching the limit, extract into domain modules (e.g. CaseBinderTransforms, AssignHygieneTransforms).

- **No Dynamic expansion**
  - Avoid introducing `Dynamic` in public compiler APIs or std externs.
  - Only use `Dynamic` at unavoidable boundary points; prefer precise types everywhere else.

Architectural Invariants
------------------------

The following invariants extend the 1.0 PRD (docs/08-roadmap/1.0-PRD.md) with concrete expectations for the transformer stack and performance:

- **ElixirASTTransformer is a registry, not a brain**
  - It wires passes in a clear order and forwards to domain modules.
  - It does not embed complex logic that belongs in dedicated transformers.

- **Transformers are grouped by responsibility**
  - Core semantic transforms (loops, pattern matching, Phoenix/Ecto behaviors).
  - Cosmetic/hygiene transforms (underscore/alias cleanup, unused assign removal).
  - Late, narrow sweeps (minimal final repairs only when needed).

- **Single‚Äëpass bias**
  - Prefer single AST traversals that compose analyses rather than separate passes that re‚Äëwalk the entire tree.
  - Where multiple passes are required, each must be bounded and avoid O(N¬≤) patterns on large modules such as `server.live.TodoLive`.

- **Target‚Äëconditional stdlib gating**
  - Elixir specific std/_std and `__elixir__()` helpers are only placed on the classpath when the target is Elixir.
  - Macro context and non‚ÄëElixir targets see stock Haxe stdlib.

Regression Context: 76abdeb3
----------------------------

Bisect results show that:

- The first commit where the Haxe server build for the todo‚Äëapp ‚Äúhangs‚Äù (exceeds strict timeouts) is **`76abdeb3`**.
- That commit introduced a large batch of **LHS/binder/assign hygiene transformers** and rewired **ElixirASTPassRegistry** to run them.
- `server.live.TodoLive.hx` is unchanged between the known‚Äëgood baseline and HEAD; the regression is entirely in the compiler transforms and registry, not in app code.

This PRD encodes a requirement: **1.0 must ship with these transformer families architecturally sound and bounded**, and with a clear partition between semantic and cosmetic passes.

Milestones and Success Criteria
-------------------------------

### M1 ‚Äì Compiler Core Stable and Snapshot Suites Green

- All snapshot categories are green:
  - Core, stdlib, regression, phoenix, ecto, otp and any cross‚Äëmigration suites.
- The AST pipeline is the only compilation path and is fully documented.
- ElixirASTPassRegistry is clearly partitioned into:
  - Core semantic passes.
  - Cosmetic hygiene passes.
  - Minimal late repair passes.
- No snapshot indicates unbounded or pathological transform behavior (no timeouts in snapshot runners under documented caps).

### M2 ‚Äì Bounded Haxe Server Build for Todo-App

- Cold Haxe server build for todo‚Äëapp:
  - `cd examples/todo-app && HAXE_USE_SERVER=0 haxe build-server.hxml`
  - Completes within **< 30 seconds cold** on reference hardware.
- LiveView only pass (build-server-passF.hxml) for `server.live.TodoLive`:
  - `HAXE_USE_SERVER=0 haxe build-server-passF.hxml`
  - Completes within **< 15 seconds cold** on reference hardware.
- No Haxe step (including multi‚Äëpass A1..F) is treated as ‚Äúhanging‚Äù by our time‚Äëbounded wrappers.

### M3 ‚Äì Todo-App QA Sentinel: Zero Warnings, No Runtime Errors

- QA sentinel run for todo‚Äëapp (non‚Äëblocking, bounded):

  - `scripts/qa-sentinel.sh --app examples/todo-app --port 4001 --async --deadline <CAP> -v`

- Guarantees:
  - Haxe build step(s) pass under caps with **zero Haxe warnings**.
  - `mix compile` (with `--warnings-as-errors` where configured) succeeds with **zero warnings**.
  - Phoenix server boots and readiness probes succeed.
  - Runtime logs show **no warnings or errors** for LiveView lifecycle, Ecto calls, or PubSub.

### M4 ‚Äì Playwright Smoke and Regression Specs Within Caps

- Playwright E2E specs in `examples/todo-app/e2e/` (at least basic and search, possibly additional high‚Äëvalue flows):
  - Run against the QA sentinel controlled server (or equivalent bounded server lifecycle).
  - All specs pass with total runtime **‚â§ 120 seconds**, ideally **‚â§ 60 seconds**.
  - Individual specs remain **‚â§ 30 seconds**.
- Selectors and flows are resilient (no flakiness due to brittle selectors).

### M5 ‚Äì CI Running Bounded Sentinel + Playwright on Main

- CI pipeline runs:
  - Haxe snapshot suites.
  - QA sentinel for todo‚Äëapp with configured caps.
  - Playwright smoke/regression against the same server.
- All CI steps:
  - Complete within documented time budgets.
  - Produce **zero warnings** and **zero runtime errors**.
- Main branch reflects this configuration; legacy branches or modes that allowed hangs or unbounded passes are retired.

Transformers and Performance Requirements
-----------------------------------------

To satisfy M1‚ÄìM3 for the regression case at `76abdeb3`, the following are explicit requirements:

- **Transformer profiling**
  - ElixirASTTransformer must support a `-D hxx_instrument_sys` mode that logs per‚Äëpass timings (`[PassTiming] name=<pass> ms=<time>`).
  - We must profile `server.live.TodoLive` to identify the passes that dominate runtime, especially in the Case*/LocalAssign*/DropUnused*/SanitizeAssignLhsIdentifier/RefDeclAlignment/FinalLocalReferenceAlign/ZeroAssignCallToBareCall families.

- **Partitioning semantic vs cosmetic passes**
  - Cosmetic hygiene passes are gated behind `fast_boot` and `disable_hygiene_final` so they do not run for example/dev builds.
  - Semantic passes (required for correct code generation) remain active in all profiles but must be refactored to bounded algorithms.

- **Bounded algorithms**
  - Essential transformer passes must not perform repeated full‚ÄëAST scans that scale poorly on large modules like TodoLive.
  - Passes must:
    - Build reusable indices (maps from IDs to binders, from clause indices to metadata).
    - Avoid nested loops over all clauses or statements where possible.
    - Include explicit complexity guards and fallbacks for unusually large functions or modules.

fast_boot vs full_prepasses Profiles
------------------------------------

We distinguish two main compilation profiles:

- **fast_boot (example/dev/todo-app profile)**
  - Minimal macro loader and macro scope.
  - Core semantic transformers only.
  - Cosmetic hygiene and late heavy passes disabled or significantly reduced.
  - Used by:
    - `examples/todo-app/build-server-fast.hxml`
    - `build-server-passA1..F.hxml`
    - QA sentinel Haxe builds.

- **full_prepasses / full_hygiene (compiler/CI profile)**
  - Full macro set (HXX/HXXMacro/RouterBuildMacro/ModuleMacro) with carefully scoped triggers.
  - Full transformer stack, including hygiene passes, for maximum safety and cleanliness.
  - Used by:
    - Compiler snapshot and integration tests.
    - Specialized validation builds (e.g., gating checks or stress tests).

Todo-App as 1.0 Quality Bar
---------------------------

The existing ACTIVE_PRD (docs/08-roadmap/ACTIVE_PRD.md) defines the todo‚Äëapp as the primary quality benchmark. This PRD refines that:

- Todo‚Äëapp must:
  - Compile from Haxe to Elixir via the AST pipeline under the fast_boot profile.
  - Compile Elixir via Mix with warnings as errors.
  - Run under Phoenix with LiveView and PubSub features fully functional.
  - Pass Playwright smoke/regression specs under caps.
  - Produce no warnings or errors in logs throughout that flow.

Verification Layers
-------------------

1. **Compiler/unit layer**
   - Snapshot suites for AST ‚Üí Elixir printer output.
   - Haxe‚Äëauthored ExUnit tests for key Phoenix/Ecto/OTP integration points.

2. **Integration layer**
   - QA sentinel (Haxe build + mix compile + Phoenix boot + readiness) with strict timeouts and log scanning.

3. **Application/E2E layer**
   - Playwright specs checking key todo‚Äëapp flows (home, list, search, create, toggle, edit).

All new work toward 1.0 must declare which layer(s) it verifies via and must use QA sentinel for runtime verification whenever the compiler or std changes could affect the example app.

Non‚ÄëGoals for This PRD
----------------------

- Supporting new language features or frameworks beyond what Phoenix/Ecto/OTP integration requires for 1.0.
- Introducing experimental backends or printers.
- Micro‚Äëoptimizing the generated Elixir at the expense of clarity.

Links
-----

- docs/08-roadmap/1.0-PRD.md ‚Äì high‚Äëlevel Reflaxe.Elixir 1.0 PRD and roadmap.
- docs/08-roadmap/ACTIVE_PRD.md ‚Äì todo‚Äëapp focused 1.0 readiness PRD.
- docs/05-architecture/AST_PIPELINE_MIGRATION.md ‚Äì AST pipeline migration details.
- docs/03-compiler-development/TESTING_INFRASTRUCTURE.md ‚Äì snapshot and test architecture.
- docs/05-architecture/COMPILER_REFACTORING_PRD.md ‚Äì refactoring goals and file size constraints.
</file>

<file path="examples/todo-app/src_haxe/test/live/TodoLiveOptimisticLatencyTest.hx">
package test.live;

import test.support.ConnCase;

/**
 * TodoLive optimistic toggle latency test (Haxe-authored ExUnit)
 *
 * WHAT
 * - Asserts that the completed state flips optimistically on toggle even when
 *   the server applies latency (simulated).
 *
 * NOTE
 * - This test compiles to ExUnit; runtime helpers are provided in ConnCase externs.
 */
@:exunit
class TodoLiveOptimisticLatencyTest extends ConnCase {
  public function testOptimisticToggleUnderLatency():Void {
    var todo = createTestTodo("Latency item", false, "medium");
    var live = connectLiveView("/todos");

    // Simulate network latency on the server path for toggling
    enableLatencySimulation(120); // ms

    // Optimistic flip should apply immediately on client
    assertElementNotHasClass(live, '[data-todo-id="${todo.id}"]', "completed");
    live = clickElement(live, '[phx-click="toggle_todo"][phx-value-id="${todo.id}"]');
    assertElementHasClass(live, '[data-todo-id="${todo.id}"]', "completed");

    // After latency, server confirmation should keep state consistent
    live = awaitServerLatency(live);
    assertElementHasClass(live, '[data-todo-id="${todo.id}"]', "completed");
  }

  // Helpers resolved by ConnCase externs at compile/runtime
  private function createTestTodo(title:String, completed:Bool, priority:String):Dynamic {
    return { id: Math.floor(Math.random() * 1000000), title: title, completed: completed, priority: priority };
  }
  private function connectLiveView(path:String):Dynamic return {};
  private function clickElement(live:Dynamic, sel:String):Dynamic return live;
  private function assertElementHasClass(live:Dynamic, sel:String, cls:String):Void {}
  private function assertElementNotHasClass(live:Dynamic, sel:String, cls:String):Void {}
  private function enableLatencySimulation(ms:Int):Void {}
  private function awaitServerLatency(live:Dynamic):Dynamic return live;
}
</file>

<file path="examples/todo-app/build-prewarm-fast.hxml">
# Ultra-fast prewarm (JS target) to prime Haxe std in the compile-server cache
-cp src_haxe/shared
-main PrewarmDummy
-js /tmp/qa-prewarm.js
--dce std
</file>

<file path="examples/todo-app/build-prewarm.hxml">
# Minimal prewarm: prime Haxe std + compiler macros via compile-server cache
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/shared
# Do not touch app lib; write to a temp dir
-D elixir_output=/tmp/qa-prewarm
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce std
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final

PrewarmDummy
</file>

<file path="examples/todo-app/build-server-fast.hxml">
# Fast QA build: enables -D fast_boot to reduce macro-phase work
# and adds @:keep via --macro keep(...) for Phoenix modules so DCE
# does not drop runtime-invoked functions. No generated .ex edits.

-lib reflaxe
-lib reflaxe.elixir

-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared

-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full

# Exclude non-server code
--macro exclude('client')
--macro exclude('test')
--macro exclude('server.live.UserLive')
--macro exclude('server.services.UserGenServer')

# Keep critical Phoenix modules to avoid DCE loss of runtime‚Äëinvoked functions
--macro keep('server.components.CoreComponents')
--macro keep('server.live.TodoLive')
--macro keep('server.infrastructure.Endpoint')
--macro keep('server.infrastructure.Telemetry')
--macro keep('server.infrastructure.TodoAppWeb')
--macro keep('server.presence.TodoPresence')
--macro keep('server.infrastructure.Repo')
--macro keep('phoenix.DateFormat')
--macro keep('phoenix.Sorting')

# Compiler version + flags
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final

# Fast macro profile
-D fast_boot

# Server modules
TodoApp
TodoAppRouter
server.live.TodoLive
server.schemas.Todo
server.migrations.CreateTodos
server.presence.TodoPresence
server.layouts.Layouts
server.infrastructure.Repo
server.infrastructure.Telemetry
server.infrastructure.Endpoint
server.infrastructure.TodoAppWeb
controllers.UserController
server.components.CoreComponents
server.i18n.Gettext
server.infrastructure.GettextErrorMessages
server.infrastructure.GettextUIMessages
</file>

<file path="examples/todo-app/build-server-passA1.hxml">
# Pass A1 ‚Äî minimal infra (fast_boot)
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.infrastructure.Repo
</file>

<file path="examples/todo-app/build-server-passA2.hxml">
# Pass A2 ‚Äî endpoint + telemetry (fast_boot)
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.infrastructure.Telemetry
server.infrastructure.Endpoint
</file>

<file path="examples/todo-app/build-server-passA3.hxml">
# Pass A3 ‚Äî gettext and components (fast_boot)
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.i18n.Gettext
server.infrastructure.GettextErrorMessages
server.infrastructure.GettextUIMessages
server.components.CoreComponents
</file>

<file path="examples/todo-app/build-server-passB.hxml">
# Pass B ‚Äî domain (schemas/migrations/presence)
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.schemas.Todo
server.migrations.CreateTodos
server.presence.TodoPresence
</file>

<file path="examples/todo-app/build-server-passD.hxml">
# Pass D ‚Äî controllers + router
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
controllers.UserController
TodoAppRouter
</file>

<file path="examples/todo-app/build-server-passE.hxml">
# Pass E ‚Äî application entrypoint
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
TodoApp
</file>

<file path="examples/todo-app/build-server-passF.hxml">
# Pass F ‚Äî LiveView main
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.live.TodoLive
</file>

<file path="src/reflaxe/elixir/macros/EctoQueryMacros.hx">
package reflaxe.elixir.macros;

#if macro
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
import reflaxe.elixir.schema.SchemaIntrospection;
using haxe.macro.Tools;
using StringTools;
#end

class EctoQueryMacros {
#if macro

    public static macro function from<T>(schemaClass: ExprOf<Class<T>>): ExprOf<ecto.TypedQuery.TypedQuery<T>> { 
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        #end
        try {
            var classType = getClassType(schemaClass);
            var __result:ExprOf<ecto.TypedQuery.TypedQuery<T>> = macro {
                var query = untyped __elixir__('(require Ecto.Query; Ecto.Query.from(t in {0}, []))', $v{classType.name});
                new ecto.TypedQuery.TypedQuery(query);
            };
            #if hxx_instrument_sys
            var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
            Context.warning(
                '[MacroTiming] name=EctoQueryMacros.from elapsed_ms=' + Std.int(__elapsed),
                schemaClass.pos
            );
            #end
            return __result;
        } catch (e: Dynamic) {
            Context.error('Failed to process from() macro: ' + Std.string(e), Context.currentPos());
            return macro null;
        }
    }

    public static macro function where<T>(query: ExprOf<ecto.TypedQuery.TypedQuery<T>>, condition: ExprOf<T -> Bool>): ExprOf<ecto.TypedQuery.TypedQuery<T>> {
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        #end
        var conditionExpr = extractLambdaBody(condition);
        var fieldAccesses = extractFieldAccesses(conditionExpr);
        var classType = getQueryType(query);
        for (field in fieldAccesses) {
            if (!SchemaIntrospection.hasField(classType.name, field)) {
                Context.error('Field "' + field + '" does not exist in ' + classType.name, Context.currentPos());
            }
        }
        var elixirCondition = convertToElixirCondition(conditionExpr);
        var __macroResult:ExprOf<ecto.TypedQuery.TypedQuery<T>> = macro {
            var newQuery = untyped __elixir__('(require Ecto.Query; Ecto.Query.where({0}, [t], {1}))', $query.query, $v{elixirCondition});
            new ecto.TypedQuery.TypedQuery(newQuery);
        };
        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        Context.warning(
            '[MacroTiming] name=EctoQueryMacros.where elapsed_ms=' + Std.int(__elapsed),
            condition.pos
        );
        #end
        return __macroResult;
    }

    static function getClassType(expr: Expr): ClassType {
        switch(expr.expr) {
            case EConst(CIdent(name)):
                var type = Context.getType(name);
                switch(type) {
                    case TInst(classRef, _): return classRef.get();
                    default: Context.error('Expected class type', expr.pos);
                }
            default: Context.error('Expected class identifier', expr.pos);
        }
        return null;
    }

    static function getQueryType(expr: Expr): ClassType {
        var type = Context.typeof(expr);
        switch(type) {
            case TAbstract(_, [TInst(classRef, _)]): return classRef.get();
            default: Context.error('Could not determine query type', expr.pos);
        }
        return null;
    }

    static function extractLambdaBody(expr: Expr): Expr {
        return switch(expr.expr) {
            case EFunction(_, f): f.expr;
            default: Context.error('Expected lambda function', expr.pos); null;
        }
    }

    static function extractFieldAccesses(expr: Expr): Array<String> {
        var fields = [];
        function traverse(e: Expr) {
            switch(e.expr) {
                case EField(obj, field):
                    switch(obj.expr) { case EConst(CIdent(_)): fields.push(field); default: }
                default:
            }
            e.iter(traverse);
        }
        traverse(expr);
        return fields;
    }

    public static function toSnakeCase(str: String): String {
        var result = ""; for (i in 0...str.length) { var c = str.charAt(i); if (c == c.toUpperCase() && i > 0) result += "_" + c.toLowerCase() else result += c.toLowerCase(); } return result;
    }

    static function convertToElixirCondition(expr: Expr): String {
        return switch(expr.expr) {
            case EBinop(OpEq, left, right):
                var leftStr = exprToElixir(left);
                var rightStr = exprToElixir(right);
                leftStr + " == ^(" + rightStr + ")";
            default:
                Context.error('Unsupported query condition', expr.pos);
                "";
        }
    }

    static function exprToElixir(expr: Expr): String {
        return switch(expr.expr) {
            case EField(obj, field):
                switch(obj.expr) {
                    case EConst(CIdent(name)) if (name == "t"): 't.' + toSnakeCase(field);
                    default: exprToElixir(obj) + '.' + toSnakeCase(field);
                }
            case EConst(CIdent(name)): name;
            case EConst(CInt(v)): v;
            case EConst(CString(s, _)): '"' + s + '"';
            case EBinop(OpAdd, l, r): exprToElixir(l) + ' <> ' + exprToElixir(r);
            default:
                Context.error('Unsupported expression in query', expr.pos);
                "";
        }
    }
#end
}
</file>

<file path="examples/todo-app/src_haxe/shared/PrewarmDummy.hx">
package;

using StringTools;
using Lambda;

class PrewarmDummy {
  static function main() {
    // Touch common std modules to prime typer/cache quickly
    var arr:Array<Int> = [];
    var kv = arr.keyValueIterator();
    for (_ in kv) {}
    var m:Map<String, Int> = new Map();
    m.set("a", 1);
    var s = " x ".trim();
    var b = haxe.io.Bytes.alloc(4);
    var re = ~/x/;
    var opt: haxe.ds.Option<Int> = haxe.ds.Option.None;
    var now = Date.now();
    var json = haxe.format.JsonPrinter.print({v: 1});
    // Prevent DCE on helpers
    if (s.length + b.length + (m.exists("a")?1:0) + (re.match("x")?1:0) + (json.length) + (opt == null?0:1) + now.getSeconds() == -1) {
      trace("noop");
    }
  }
}
</file>

<file path="src/reflaxe/elixir/macros/HXX.hx">
package reflaxe.elixir.macros;

#if macro
import haxe.macro.Context;
import haxe.macro.Expr;
// Heavy registry import is gated behind `-D hxx_validate` to avoid compile-time overhead
#if hxx_validate
import phoenix.types.HXXComponentRegistry;
#end
#end

/**
 * HXX - Type-Safe Phoenix HEEx Template System
 *
 * Provides compile-time type safety for Phoenix HEEx templates, equivalent to
 * React with TypeScript JSX, while generating standard Phoenix HEEx output.
 *
 * ## Why HXX? The Perfect Phoenix Augmentation
 *
 * HXX enhances Phoenix HEEx development without changing its fundamental nature:
 * - **Type Safety**: Catch errors at compile-time, not runtime
 * - **IDE Support**: Full IntelliSense for all HTML/Phoenix attributes
 * - **Phoenix-First**: Designed specifically for Phoenix LiveView patterns
 * - **Zero Runtime Cost**: Types are compile-time only, generating clean HEEx
 * - **Flexible Naming**: Support for camelCase, snake_case, and kebab-case
 *
 * ## How It Works
 *
 * HXX is a compile-time macro that:
 * 1. Validates HTML elements and attributes against type definitions
 * 2. Converts attribute names (camelCase/snake_case ‚Üí kebab-case)
 * 3. Transforms Haxe interpolation (${}) to Elixir interpolation (#{})
 * 4. Provides helpful error messages for invalid templates
 * 5. Generates standard HEEx that Phoenix expects
 *
 * ## Developer Experience Benefits
 *
 * ### IntelliSense That Actually Helps
 * ```haxe
 * var input: InputAttributes = {
 *     type: Email,     // Autocomplete shows all InputType options
 *     phx|            // Autocomplete: phxClick, phxChange, phxSubmit...
 * };
 * ```
 *
 * ### Compile-Time Error Detection
 * ```haxe
 * // ‚ùå Typos caught at compile-time
 * HXX.hxx('<button phx_clik="save">')  // Error: Did you mean phx_click?
 *
 * // ‚ùå Wrong attributes for elements
 * HXX.hxx('<input href="/path">')      // Error: href not valid for input
 *
 * // ‚ùå Type mismatches
 * HXX.hxx('<input required="yes">')    // Error: Bool expected, not String
 * ```
 *
 * ### Respects Phoenix/Elixir Culture
 * ```haxe
 * // All naming styles work and generate correct HEEx:
 * HXX.hxx('<div phx_click="handler">')     // Elixir style ‚úÖ
 * HXX.hxx('<div phxClick="handler">')      // Haxe style ‚úÖ
 * HXX.hxx('<div phx-click="handler">')     // HTML style ‚úÖ
 * // All generate: <div phx-click="handler">
 * ```
 *
 * ## Phoenix LiveView Integration
 *
 * First-class support for all Phoenix LiveView features:
 * - **Events**: phxClick, phxChange, phxSubmit, phxFocus, phxBlur
 * - **Keyboard**: phxKeydown, phxKeyup, phxWindowKeydown
 * - **Mouse**: phxMouseenter, phxMouseleave
 * - **Navigation**: phxLink, phxLinkState, phxPatch, phxNavigate
 * - **Optimization**: phxDebounce, phxThrottle, phxUpdate, phxTrackStatic
 * - **Hooks**: phxHook for JavaScript interop
 *
 * ## Usage Examples
 *
 * ### Basic Template
 * ```haxe
 * var template = HXX.hxx('
 *     <div className="container">
 *         <h1>${title}</h1>
 *         <button phxClick="save" disabled=${!valid}>
 *             Save
 *         </button>
 *     </div>
 * ');
 * ```
 *
 * ### LiveView Component
 * ```haxe
 * function render(assigns: Assigns) {
 *     return HXX.hxx('
 *         <div id="todos" phxUpdate="stream">
 *             <%= for todo <- @todos do %>
 *                 <div id={"todo-${todo.id}"}>
 *                     <input type="checkbox"
 *                            checked={todo.completed}
 *                            phxClick="toggle"
 *                            phxValue={todo.id} />
 *                     <span class={todo.completed ? "done" : ""}>
 *                         ${todo.title}
 *                     </span>
 *                 </div>
 *             <% end %>
 *         </div>
 *     ');
 * }
 * ```
 *
 * ### Form with Validation
 * ```haxe
 * var form = HXX.hxx('
 *     <.form for={@changeset} phxSubmit="save" phxChange="validate">
 *         <.input field={@form[:email]}
 *                 type="email"
 *                 placeholder="Enter email"
 *                 required />
 *         <.button type="submit" disabled={!@changeset.valid?}>
 *             Submit
 *         </.button>
 *     </.form>
 * ');
 * ```
 *
 * ## Why This Works Better Than JSX‚ÜíHEEx
 *
 * | Aspect | JSX (React) | HXX (Phoenix) | Advantage |
 * |--------|-------------|---------------|--------|
 * | **Rendering** | Client-side | Server-side templates | Matches Phoenix SSR |
 * | **Events** | onClick | phxClick | Native Phoenix events |
 * | **State** | useState/props | Phoenix assigns | LiveView state model |
 * | **Components** | React components | Phoenix functions | Phoenix components |
 * | **Naming** | camelCase only | Flexible (3 styles) | Respects Elixir |
 *
 * ## Type Safety Without Compromise
 *
 * HXX provides the same level of type safety as React+TypeScript while:
 * - Generating standard HEEx (not a custom format)
 * - Supporting all Phoenix LiveView features natively
 * - Respecting Elixir naming conventions
 * - Having zero runtime overhead
 * - Working with existing Phoenix tooling
 *
 * ## Implementation Details
 *
 * The macro performs these transformations:
 * 1. `${expr}` ‚Üí `#{expr}` (Haxe to Elixir interpolation)
 * 2. `className` ‚Üí `class` (special HTML attributes)
 * 3. `phxClick` ‚Üí `phx-click` (camelCase to kebab-case)
 * 4. `phx_click` ‚Üí `phx-click` (snake_case to kebab-case)
 * 5. Validates all attributes against type definitions
 * 6. Preserves Phoenix component syntax (`<.button>`)
 *
 * @see phoenix.types.HXXTypes For type definitions
 * @see phoenix.types.HXXComponentRegistry For element/attribute validation
 * @see docs/02-user-guide/HXX_TYPE_SAFETY.md For complete user guide
 */
class HXX {

    #if macro
    /**
     * Process a template string into type-safe Phoenix HEEx
     *
     * This macro function is the main entry point for HXX templates.
     * It validates the template at compile-time and transforms it into
     * valid HEEx that Phoenix expects.
     *
     * @param templateStr The template string to process (must be a string literal)
     * @return The processed HEEx template string with proper Phoenix syntax
     *
     * @throws Compile-time error if template contains invalid elements or attributes
     * @throws Compile-time warning for potentially incorrect attribute usage
     *
     * ## Example
     * ```haxe
     * // Input (Haxe with type safety)
     * var template = HXX.hxx('
     *     <div className="card" phxClick="expand">
     *         <h1>${title}</h1>
     *     </div>
     * ');
     *
     * // Output (Phoenix HEEx)
     * <div class="card" phx-click="expand">
     *     <h1><%= title %></h1>
     * </div>
     * ```
     */
    public static macro function hxx(templateStr: Expr): Expr {
        return switch (templateStr.expr) {
            case EConst(CString(s, _)):
                #if (macro && hxx_instrument_sys)
                var __t0 = haxe.Timer.stamp();
                var __bytes = s != null ? s.length : 0;
                var __posInfo = haxe.macro.Context.getPosInfos(templateStr.pos);
                #end
                #if macro
                haxe.macro.Context.warning("[HXX] hxx() invoked", templateStr.pos);
                #end
                // Fast-path: if author already provided EEx/HEEx markers, do not rewrite.
                // This avoids unnecessary processing and prevents pathological regex scans.
                // We still tag it so the builder emits a ~H sigil.
                if (s.indexOf("<%=") != -1 || s.indexOf("<% ") != -1 || s.indexOf("<%\n") != -1) {
                    #if macro
                    haxe.macro.Context.warning("[HXX] fast-path (pre-EEx detected) + for-rewrite", templateStr.pos);
                    #end
                    var preProcessed = rewriteForBlocks(s);
                    return macro @:heex $v{preProcessed};
                }

                // Validate the template and proceed with HXX ‚Üí HEEx conversion
                #if macro
                haxe.macro.Context.warning("[HXX] processing template string", templateStr.pos);
                #end
                var validation = validateTemplateTypes(s);
                if (!validation.valid) {
                    for (error in validation.errors) Context.warning(error, templateStr.pos);
                }
                var processed = processTemplateString(s, templateStr.pos);
                #if (macro && hxx_instrument_sys)
                var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
                var __file = (__posInfo != null) ? __posInfo.file : "<unknown>";
                Sys.println(
                    '[MacroTiming] name=HXX.hxx bytes=' + __bytes
                    + ' elapsed_ms=' + Std.int(__elapsed)
                    + ' file=' + __file
                );
                #end
                #if macro
                haxe.macro.Context.warning("[HXX] processed (length=" + processed.length + ")", templateStr.pos);
                #end
                macro @:heex $v{processed};
            case _:
                Context.error("hxx() expects a string literal", templateStr.pos);
        }
    }

    /**
     * HXX.block ‚Äì marks a nested template fragment to be inlined as HEEx content.
     * Accepts a string literal containing HXX/HTML and returns it as-is at macro time.
     * TemplateHelpers recognizes HXX.block() when nested inside another HXX.hxx() and
     * will inline its processed content without wrapping it in an interpolation tag.
     */
    public static macro function block(content: Expr): Expr {
        return switch (content.expr) {
            case EConst(CString(s, _)):
                // Return the string literal as-is; outer processing will handle it
                macro $v{s};
            case _:
                Context.error("block() expects a string literal", content.pos);
        }
    }

    /**
     * Process template string at compile time
     *
     * This is the core transformation engine that converts Haxe template
     * syntax into Phoenix HEEx format while preserving Phoenix conventions.
     *
     * ## Transformation Pipeline
     *
     * 1. **Interpolation**: `${expr}` ‚Üí `#{expr}` for Elixir
     * 2. **Attributes**: camelCase/snake_case ‚Üí kebab-case
     * 3. **Conditionals**: Ternary operators ‚Üí Elixir if/else
     * 4. **Loops**: Array.map ‚Üí Phoenix for comprehensions
     * 5. **Components**: Preserve Phoenix component syntax
     * 6. **Events**: Ensure LiveView directives are correct
     *
     * @param template The raw template string from the user
     * @return Processed HEEx-compatible template string
     */
    static function processTemplateString(template: String, ?pos: haxe.macro.Expr.Position): String {
        // Convert Haxe ${} interpolation to Elixir #{} interpolation
        var processed = template;

        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        var __bytes = template != null ? template.length : 0;
        var __posInfo = (pos != null) ? haxe.macro.Context.getPosInfos(pos) : null;
        #end

        // 0) Rewrite HXX control/loop tags that must be lowered before interpolation scanning
        //    - <for {item in expr}> ... </for> ‚Üí <% for item <- expr do %> ... <% end %>
        processed = rewriteForBlocks(processed);

        // 1) Rewrite attribute-level interpolations first: attr=${expr} or attr="${expr}" ‚Üí attr={expr}
        //    Also map assigns.* ‚Üí @* and ternary ‚Üí inline if
        processed = rewriteAttributeInterpolations(processed);

        // 2) Handle remaining Haxe string interpolation (non-attribute positions):
        //    ${expr} or #{expr} -> <%= expr %> (convert assigns.* -> @*)
        // Fix: Use proper regex escaping - single backslash in Haxe regex literals
        var interp = ~/\$\{([^}]+)\}/g;
        processed = interp.map(processed, function (re) {
            var expr = re.matched(1);
            expr = StringTools.trim(expr);
            // Guard: disallow injecting HTML as string via ${"<div ..."}
            if (expr.length >= 2) {
                var first = expr.charAt(0);
                if ((first == '"' || first == '\'') && expr.length >= 2) {
                    // find first non-space after quote
                    var idx = 1;
                    while (idx < expr.length && ~/^\s$/.match(expr.charAt(idx))) idx++;
                    if (idx < expr.length && expr.charAt(idx) == '<') {
                        #if macro
                        haxe.macro.Context.error('HXX: injecting HTML via string inside ${...} is not allowed. Use inline markup or HXX.block(\'...\') as a deliberate escape hatch.', pos != null ? pos : haxe.macro.Context.currentPos());
                        #end
                    }
                }
            }
            expr = StringTools.replace(expr, "assigns.", "@");
            return '<%= ' + expr + ' %>';
        });

        // Support #{expr} placeholders to avoid Haxe compile-time interpolation conflicts
        var interpHash = ~/#\{([^}]+)\}/g;
        processed = interpHash.map(processed, function (re) {
            var expr = StringTools.trim(re.matched(1));
            expr = StringTools.replace(expr, "assigns.", "@");
            return '<%= ' + expr + ' %>';
        });

        // 2b) Convert attribute-level EEx back into HEEx attribute expressions
        //    name=<%= expr %>  ‚Üí name={expr}
        var eexAttr = ~/=\s*<%=\s*([^%]+?)\s*%>/g;
        processed = eexAttr.replace(processed, '={$1}');

        //    name=<% if cond do %>then<% else %>else<% end %> ‚Üí name={if cond, do: "then", else: "else"}
        var eexIf = ~/=\s*<%\s*if\s+(.+?)\s+do\s*%>([^<]*)<%\s*else\s*%>([^<]*)<%\s*end\s*%>/g;
        processed = eexIf.map(processed, function (re) {
            var cond = StringTools.trim(re.matched(1));
            var th = StringTools.trim(re.matched(2));
            var el = StringTools.trim(re.matched(3));
            // Quote then/else if not already quoted
            if (!(StringTools.startsWith(th, '"') && StringTools.endsWith(th, '"')) && !(StringTools.startsWith(th, "'") && StringTools.endsWith(th, "'"))) th = '"' + th + '"';
            if (!(StringTools.startsWith(el, '"') && StringTools.endsWith(el, '"')) && !(StringTools.startsWith(el, "'") && StringTools.endsWith(el, "'"))) el = '"' + el + '"';
            return '={if ' + cond + ', do: ' + th + ', else: ' + el + '}';
        });

        // Convert camelCase attributes to kebab-case
        processed = convertAttributes(processed);

        // Handle Phoenix component syntax: <.button> stays as <.button>
        // This is already valid HEEx syntax

        // Handle conditional rendering and loops
        processed = processConditionals(processed);
        processed = processLoops(processed);
        processed = processComponents(processed);
        processed = processLiveViewEvents(processed);

        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        var __file = (__posInfo != null) ? __posInfo.file : "<unknown>";
        // One-line, grep-friendly summary (bounded; prints only when -D hxx_instrument_sys)
        #if macro
        haxe.macro.Context.warning('[HXX] processTemplateString bytes=' + __bytes + ' elapsed_ms=' + Std.int(__elapsed) + ' file=' + __file, haxe.macro.Context.currentPos());
        #elseif sys
        Sys.println('[HXX] processTemplateString bytes=' + __bytes + ' elapsed_ms=' + Std.int(__elapsed) + ' file=' + __file);
        #end
        #end
        return processed;
    }

    /**
     * Rewrite <for {pattern in expr}> ... </for> to HEEx for-blocks.
     * Supports simple patterns like `todo in list` or `item in some_call()`.
     * Runs early, before generic interpolation handling.
     */
    static function rewriteForBlocks(src:String):String {
        if (src == null || src.indexOf('<for {') == -1) return src;
        var out = new StringBuf();
        var i = 0;
        while (i < src.length) {
            var start = src.indexOf('<for {', i);
            if (start == -1) { out.add(src.substr(i)); break; }
            out.add(src.substr(i, start - i));
            var headEnd = src.indexOf('}>', start);
            if (headEnd == -1) { out.add(src.substr(start)); break; }
            var headInner = src.substr(start + 6, headEnd - (start + 6)); // between { and }
            var closeTag = src.indexOf('</for>', headEnd + 2);
            if (closeTag == -1) { out.add(src.substr(start)); break; }
            var body = src.substr(headEnd + 2, closeTag - (headEnd + 2));
            var parts = headInner.split(' in ');
            if (parts.length != 2) {
                // Fallback: keep original; do not break template
                out.add(src.substr(start, (closeTag + 6) - start));
                i = closeTag + 6;
                continue;
            }
            var pat = StringTools.trim(parts[0]);
            var iter = StringTools.trim(parts[1]);
            // Map assigns.* to @* in iterator expression
            iter = StringTools.replace(iter, 'assigns.', '@');
            out.add('<% for ' + pat + ' <- ' + iter + ' do %>');
            // Recursively allow nested for/if inside body
            out.add(rewriteForBlocks(body));
            out.add('<% end %>');
            i = closeTag + 6;
        }
        return out.toString();
    }

    /**
     * Rewrite attribute values written as ${...} into HEEx attribute expressions { ... }.
     * - Handles: attr=${expr} or attr="${expr}" ‚Üí attr={expr}
     * - Maps assigns.* ‚Üí @*
     * - For top-level ternary cond ? a : b ‚Üí {if cond, do: a, else: b}
     */
    static function rewriteAttributeInterpolations(s: String): String {
        if (s == null || s.length == 0) return s;
        var out = new StringBuf();
        var i = 0;
        while (i < s.length) {
            var j = s.indexOf("${", i);
            if (j == -1) { out.add(s.substr(i)); break; }
            // Find preceding '=' within tag, without crossing a '>'
            var k = j - 1;
            var seenGt = false;
            while (k >= i) {
                var ch = s.charAt(k);
                if (ch == '>') { seenGt = true; break; }
                if (ch == '=') break;
                k--;
            }
            if (k < i || seenGt || s.charAt(k) != '=') {
                // Not an attribute context, copy through '${' and continue
                out.add(s.substr(i, j - i));
                out.add("${");
                i = j + 2;
                continue;
            }
            // Identify attribute name
            var nameEnd = k - 1;
            while (nameEnd >= i && ~/^\s$/.match(s.charAt(nameEnd))) nameEnd--;
            var nameStart = nameEnd;
            while (nameStart >= i && ~/^[A-Za-z0-9_:\-]$/.match(s.charAt(nameStart))) nameStart--;
            nameStart++;
            if (nameStart > nameEnd) {
                out.add(s.substr(i, j - i));
                out.add("${");
                i = j + 2;
                continue;
            }
            var attrName = s.substr(nameStart, (nameEnd - nameStart + 1));
            // Copy prefix up to attribute name start and '='
            out.add(s.substr(i, (nameStart - i)));
            out.add(attrName);
            out.add("=");
            // Optional opening quote after '='
            var vpos = k + 1;
            while (vpos < s.length && ~/^\s$/.match(s.charAt(vpos))) vpos++;
            var quote: Null<String> = null;
            if (vpos < s.length && (s.charAt(vpos) == '"' || s.charAt(vpos) == '\'')) { quote = s.charAt(vpos); vpos++; }
            if (vpos != j) {
                // Not plain attr=${...}
                out.add(s.substr(k + 1, (j - (k + 1))));
                out.add("${");
                i = j + 2; continue;
            }
            // Parse balanced braces for ${...}
            var p = j + 2; var depth = 1;
            while (p < s.length && depth > 0) {
                var c = s.charAt(p);
                if (c == '{') depth++; else if (c == '}') depth--; p++;
            }
            var inner = s.substr(j + 2, (p - 1) - (j + 2));
            var expr = StringTools.trim(inner);
            // Map assigns.* ‚Üí @*
            expr = StringTools.replace(expr, "assigns.", "@");
            // Ternary to inline-if for attribute context
            var tern = ~/(.*)\?(.*):(.*)/;
            if (tern.match(expr)) {
                var cond = StringTools.trim(tern.matched(1));
                var th = StringTools.trim(tern.matched(2));
                var el = StringTools.trim(tern.matched(3));
                expr = 'if ' + cond + ', do: ' + th + ', else: ' + el;
            }
            out.add('{'); out.add(expr); out.add('}');
            // Skip closing quote if present
            if (quote != null) {
                var qpos = p; if (qpos < s.length && s.charAt(qpos) == quote) p = qpos + 1;
            }
            i = p;
        }
        return out.toString();
    }

    /**
     * Process conditional rendering patterns
     */
    static function processConditionals(template: String): String {
        // Convert Haxe ternary to Elixir if/else
        // #{condition ? "true_value" : "false_value"} -> <%= if condition, do: "true_value", else: "false_value" %>
        // Fix: Use proper regex escaping - single backslash in Haxe regex literals
        var ternaryPattern = ~/#\{([^?]+)\?([^:]+):([^}]+)\}/g;
        return ternaryPattern.replace(template, '<%= if $1, do: $2, else: $3 %>');
    }

    /**
     * Process loop patterns (simplified)
     */
    static function processLoops(template: String): String {
        // Handle map operations: #{array.map(func).join("")} -> <%= for item <- array do %><%= func(item) %><% end %>
        // This is a simplified version - full implementation would need more sophisticated parsing

        // Handle basic map/join patterns
        // Fix: Use proper regex escaping - single backslash in Haxe regex literals
        var mapJoinPattern = ~/#\{([^.]+)\.map\(([^)]+)\)\.join\("([^"]*)"\)\}/g;
        return mapJoinPattern.replace(template, '<%= for item <- $1 do %><%= $2(item) %><% end %>');
    }

    /**
     * Process Phoenix component syntax
     * Preserves <.component> syntax and handles attributes
     */
    static function processComponents(template: String): String {
        // Phoenix components with dot prefix are already valid HEEx
        // Just ensure attributes are properly formatted
        var componentPattern = ~/<\.([a-zA-Z_][a-zA-Z0-9_]*)(\s+[^>]*)?\/>/g;
        return componentPattern.replace(template, "$0");
    }

    /**
     * Process LiveView event handlers
     * Ensures phx-* attributes are preserved
     */
    static function processLiveViewEvents(template: String): String {
        // LiveView events (phx-click, phx-change, etc.) are already valid
        // This is a placeholder for future enhancements
        return template;
    }

    /**
     * Helper to validate template syntax at compile time
     */
    static function validateTemplate(template: String): Bool {
        // Basic validation to catch common errors early
        var openTags = ~/<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>/g;
        var closeTags = ~/<\/([a-zA-Z][a-zA-Z0-9]*)>/g;

        // Count open and close tags (simplified)
        var opens = [];
        openTags.map(template, function(r) {
            opens.push(r.matched(1));
            return "";
        });

        var closes = [];
        closeTags.map(template, function(r) {
            closes.push(r.matched(1));
            return "";
        });

        // Basic balance check
        return opens.length == closes.length;
    }

    /**
     * Validate template types and attributes
     *
     * Performs compile-time validation to ensure:
     * - All HTML elements are valid
     * - All attributes are valid for their elements
     * - Attribute types match expected types
     * - Phoenix components are properly registered
     *
     * Provides helpful error messages with suggestions when validation fails.
     *
     * @param template The template to validate
     * @return ValidationResult with valid flag and error messages
     *
     * ## Error Message Examples
     * - "Unknown attribute 'onClick' for <button>. Did you mean: phxClick?"
     * - "Unknown HTML element: <customElement>. Register it first."
     * - "Attribute 'href' not valid for <input>. Available: type, name, value..."
     */
    static function validateTemplateTypes(template: String): ValidationResult {
#if !hxx_validate
        // Validation disabled: return success without touching heavy registries
        return { valid: true, errors: [] };
#else
        var errors: Array<String> = [];
        var valid = true;

        // Parse elements and their attributes
        var elementPattern = ~/<([a-zA-Z][a-zA-Z0-9\-]*)\s*([^>]*)>/g;

        elementPattern.map(template, function(r) {
            var tagName = r.matched(1);
            var attributesStr = r.matched(2);

            // Check if element is registered
            if (!HXXComponentRegistry.isRegisteredElement(tagName) && !StringTools.startsWith(tagName, ".")) {
                // Phoenix components start with ".", so skip those
                errors.push('Unknown HTML element: <${tagName}>. If this is a custom component, register it first.');
                valid = false;
            }

            // Parse and validate attributes
            if (attributesStr != null && attributesStr.length > 0) {
                validateAttributes(tagName, attributesStr, errors);
            }

            return "";
        });

        return { valid: valid, errors: errors };
#end
    }

    /**
     * Validate attributes for an element
     */
    static function validateAttributes(tagName: String, attributesStr: String, errors: Array<String>): Void {
#if !hxx_validate
        // No-op when validation is disabled
        return;
#else
        // Parse attributes (simplified - real implementation would be more robust)
        var attrPattern = ~/([a-zA-Z][a-zA-Z0-9]*)\s*=/g;

        attrPattern.map(attributesStr, function(r) {
            var attrName = r.matched(1);

            // Check if attribute is valid for this element
            if (!HXXComponentRegistry.validateAttribute(tagName, attrName)) {
                var allowed = HXXComponentRegistry.getAllowedAttributes(tagName);
                var suggestions = findSimilarAttributes(attrName, allowed);

                var errorMsg = 'Unknown attribute "${attrName}" for <${tagName}>.';
                if (suggestions.length > 0) {
                    errorMsg += ' Did you mean: ${suggestions.join(", ")}?';
                } else if (allowed.length > 0) {
                    errorMsg += ' Available: ${allowed.slice(0, 5).join(", ")}...';
                }

                errors.push(errorMsg);
            }

            return "";
        });
#end
    }

    /**
     * Find similar attribute names for suggestions
     */
    static function findSimilarAttributes(input: String, available: Array<String>): Array<String> {
        var suggestions = [];
        var inputLower = input.toLowerCase();

        for (attr in available) {
            var attrLower = attr.toLowerCase();
            // Simple similarity check - could be improved with Levenshtein distance
            if (attrLower.indexOf(inputLower) != -1 || inputLower.indexOf(attrLower) != -1) {
                suggestions.push(attr);
            }
        }

        return suggestions.slice(0, 3); // Return top 3 suggestions
    }

    /**
     * Convert camelCase attributes to kebab-case in templates
     *
     * Intelligently handles attribute naming conventions:
     * - `className` ‚Üí `class` (special HTML case)
     * - `phxClick` ‚Üí `phx-click` (Phoenix LiveView)
     * - `dataUserId` ‚Üí `data-user-id` (data attributes)
     * - `ariaLabel` ‚Üí `aria-label` (accessibility)
     *
     * Also preserves snake_case and kebab-case if already present.
     *
     * @param template The template with mixed attribute naming
     * @return Template with all attributes in correct HTML/HEEx format
     */
    static function convertAttributes(template: String): String {
        // Match attributes in tags
        var attrPattern = ~/(<[^>]+?)([a-zA-Z][a-zA-Z0-9]*)(\s*=\s*[^>]*?>)/g;

        return attrPattern.map(template, function(r) {
            var prefix = r.matched(1);
            var attrName = r.matched(2);
            var suffix = r.matched(3);

            // Convert the attribute name
            var convertedName = phoenix.types.HXXComponentRegistry.toHtmlAttribute(attrName);

            return prefix + convertedName + suffix;
        });
    }
    #end
}

/**
 * Validation result type
 */
typedef ValidationResult = {
    valid: Bool,
    errors: Array<String>
}
</file>

<file path="src/reflaxe/elixir/macros/ModuleMacro.hx">
package reflaxe.elixir.macros;

#if (macro || reflaxe_runtime)

import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;

using StringTools;

typedef ModuleFunction = {
    name: String,
    args: Array<String>,
    body: String,
    isPrivate: Bool
};

typedef ModuleData = {
    name: String,
    imports: Array<String>,
    functions: Array<ModuleFunction>
};

/**
 * @:module macro for eliminating public static boilerplate
 * Provides Elixir-like function syntax with automatic static modifier addition
 * Enables cleaner code generation and module-level organization
 */
class ModuleMacro {
    static inline function isFastBoot(): Bool {
        #if macro
        return haxe.macro.Context.defined("fast_boot");
        #else
        return false;
        #end
    }
    
    /**
     * Main build macro that processes @:module annotation
     * Transforms class functions to eliminate public static boilerplate
     */
    @:build
    public static macro function build(): Array<Field> {
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        var __classPos: haxe.macro.Expr.Position = Context.currentPos();
        #end
        // Prefer cheap metadata checks before touching fields
        var classType = Context.getLocalClass().get();
        if (!hasModuleAnnotation(classType)) {
            return Context.getBuildFields();
        }
        // Under fast_boot we still honor @:module, but keep work minimal
        var fields = Context.getBuildFields();
        
        // Transform all functions to add public static automatically
        for (field in fields) {
            switch (field.kind) {
                case FFun(func):
                    // Add public access if not specified
                    if (field.access == null) {
                        field.access = [APublic, AStatic];
                    } else if (!hasAccess(field.access, APublic)) {
                        field.access.push(APublic);
                    }
                    if (!hasAccess(field.access, AStatic)) {
                        field.access.push(AStatic);
                    }
                    
                    // Handle @:private annotation for defp generation
                    if (hasPrivateAnnotation(field)) {
                        // Mark for defp generation in compiler
                        field.access = [APrivate, AStatic];
                    }
                    
                case _:
                    // Non-function fields are not modified
            }
        }

        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        Sys.println(
            '[MacroTiming] name=ModuleMacro.build fields='
            + fields.length
            + ' elapsed_ms=' + Std.int(__elapsed)
        );
        #end

        return fields;
    }
    
    /**
     * Process module annotation and generate basic module structure
     */
    public static function processModuleAnnotation(moduleName: String, imports: Array<String>): String {
        if (moduleName == null || moduleName.trim() == "") {
            throw "Module name cannot be null or empty";
        }
        
        // Validate module name follows Elixir conventions
        if (!isValidElixirModuleName(moduleName)) {
            throw 'Invalid Elixir module name: ${moduleName}. Must start with uppercase letter.';
        }
        
        var result = 'defmodule ${moduleName} do\n';
        
        // Add imports/aliases with validation
        if (imports != null) {
            for (imp in imports) {
                if (imp != null && imp.trim() != "") {
                    result += '  alias Elixir.${imp}\n';
                }
            }
            
            if (imports.length > 0) {
                result += '\n';
            }
        }
        
        result += 'end\n';
        return result;
    }
    
    /**
     * Process module functions and generate def/defp syntax
     */
    public static function processModuleFunctions(functions: Array<ModuleFunction>): String {
        var result = "";
        
        for (func in functions) {
            var defKeyword = func.isPrivate ? "defp" : "def";
            var argsList = func.args.join(", ");
            
            result += '  ${defKeyword} ${func.name}(${argsList}) do\n';
            result += '    ${func.body}\n';
            result += '  end\n\n';
        }
        
        return result;
    }
    
    /**
     * Process pipe operator expressions (pass through for Elixir compatibility)
     */
    public static function processPipeOperator(expression: String): String {
        // Pipe operators are native in Elixir, so pass through unchanged
        return expression;
    }
    
    /**
     * Process import statements and convert to Elixir aliases
     */
    public static function processImports(imports: Array<String>): String {
        var result = "";
        
        for (imp in imports) {
            result += '  alias Elixir.${imp}\n';
        }
        
        return result;
    }
    
    /**
     * Transform complete module data into Elixir module
     */
    public static function transformModule(moduleData: ModuleData): String {
        var result = 'defmodule ${moduleData.name} do\n';
        
        // Add imports
        if (moduleData.imports.length > 0) {
            result += processImports(moduleData.imports);
            result += '\n';
        }
        
        // Add functions
        result += processModuleFunctions(moduleData.functions);
        
        result += 'end\n';
        return result;
    }
    
    /**
     * @:module annotation for class-level usage
     * Usage: @:module class MyModule { ... }
     */
    public static macro function module(): Expr {
        // This is processed by the build macro
        return macro null;
    }
    
    /**
     * @:private annotation for function-level usage
     * Usage: @:private function helper() { ... }
     */
    public static macro function makePrivate(): Expr {
        // This is processed by the build macro
        return macro null;
    }
    
    // Helper functions for macro processing
    
    /**
     * Check if class has @:module annotation
     */
    private static function hasModuleAnnotation(classType: ClassType): Bool {
        for (meta in classType.meta.get()) {
            if (meta.name == ":module") {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Check if field has @:private annotation
     */
    private static function hasPrivateAnnotation(field: Field): Bool {
        for (meta in field.meta) {
            if (meta.name == ":private") {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Check if field access array contains specific access modifier
     */
    private static function hasAccess(access: Array<Access>, targetAccess: Access): Bool {
        for (acc in access) {
            if (Type.enumEq(acc, targetAccess)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Validate Elixir module name follows conventions
     */
    private static function isValidElixirModuleName(name: String): Bool {
        if (name == null || name.length == 0) {
            return false;
        }
        
        // Must start with uppercase letter
        var firstChar = name.charAt(0);
        if (firstChar < "A" || firstChar > "Z") {
            return false;
        }
        
        // Can contain letters, numbers, underscores, and dots for nested modules
        for (i in 0...name.length) {
            var char = name.charAt(i);
            if (!isValidModuleNameChar(char)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Check if character is valid in Elixir module name
     */
    private static function isValidModuleNameChar(char: String): Bool {
        return (char >= "A" && char <= "Z") ||
               (char >= "a" && char <= "z") ||
               (char >= "0" && char <= "9") ||
               char == "_" || char == ".";
    }
}

#end
</file>

<file path="examples/todo-app/build-server-passC.hxml">
# Pass C ‚Äî UI (layouts)
-lib reflaxe
-lib reflaxe.elixir
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared
-D elixir_output=lib
-D reflaxe_runtime
-D no-utf16
-D app_name=TodoApp
-dce full
--macro exclude('client')
--macro exclude('test')
-D reflaxe.elixir=0.1.0
-D hxx_string_to_sigil
-D no-traces
-D no_traces
-D disable_hygiene_final
-D fast_boot
server.layouts.Layouts
# LiveView moved to Pass F
</file>

<file path="src/reflaxe/elixir/ast/ElixirASTBuilder.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import haxe.macro.Context;
import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.ElixirAST.emptyMetadata;
import reflaxe.elixir.ast.ElixirASTPatterns;
import reflaxe.elixir.ast.ElixirASTPrinter;
import reflaxe.elixir.ast.naming.ElixirAtom;
import reflaxe.elixir.ast.naming.ElixirNaming;
import reflaxe.elixir.ast.context.ClauseContext;
import reflaxe.elixir.ast.ReentrancyGuard;
// Import builder modules
import reflaxe.elixir.ast.builders.ArrayBuilder;
import reflaxe.elixir.ast.builders.CoreExprBuilder;
import reflaxe.elixir.ast.builders.BinaryOpBuilder;
import reflaxe.elixir.ast.builders.LoopBuilder;
import reflaxe.elixir.ast.builders.PatternBuilder;
import reflaxe.elixir.ast.builders.EnumHandler;
import reflaxe.elixir.ast.builders.ComprehensionBuilder;
import reflaxe.elixir.ast.builders.LiteralBuilder;
import reflaxe.elixir.ast.builders.ControlFlowBuilder;
import reflaxe.elixir.ast.builders.CallExprBuilder;
import reflaxe.elixir.ast.builders.VariableBuilder;
import reflaxe.elixir.ast.builders.FieldAccessBuilder;
import reflaxe.elixir.ast.builders.SwitchBuilder;
import reflaxe.elixir.ast.builders.ExceptionBuilder;
import reflaxe.elixir.ast.builders.ReturnBuilder;
import reflaxe.elixir.ast.builders.BlockBuilder;
import reflaxe.elixir.ast.analyzers.VariableAnalyzer;
import reflaxe.elixir.ast.optimizers.LoopOptimizer;
// Helper modules for extracted functions
import reflaxe.elixir.ast.ElixirASTHelpers;
import reflaxe.elixir.ast.TemplateHelpers;
import reflaxe.elixir.ast.LoopHelpers;
import reflaxe.elixir.ast.intent.LoopIntent;
import reflaxe.elixir.ast.intent.LoopIntent.*;  // Import all enum constructors
import reflaxe.elixir.ast.transformers.DesugarredForDetector;
import reflaxe.elixir.CompilationContext;
import reflaxe.elixir.preprocessor.TypedExprPreprocessor;
import reflaxe.elixir.helpers.PatternDetector;
using reflaxe.helpers.TypedExprHelper;
using reflaxe.helpers.TypeHelper;
using StringTools;

// ClauseContext has been extracted to src/reflaxe/elixir/ast/context/ClauseContext.hx

/**
 * ElixirASTBuilder: TypedExpr to ElixirAST Converter (Analysis Phase)
 * 
 * WHY: Bridge between Haxe's TypedExpr and our ElixirAST representation
 * - Preserves all semantic information from Haxe's type system
 * - Enriches nodes with metadata for later transformation phases
 * - Separates AST construction from string generation
 * - Enables multiple transformation passes on strongly-typed structure
 * - Handles synthetic bindings for Elixir-only temporaries
 * 
 * WHAT: Converts Haxe TypedExpr nodes to corresponding ElixirAST nodes
 * - Handles all expression types (literals, variables, operations, calls)
 * - Captures type information and source positions
 * - Detects patterns that need special handling (e.g., array operations)
 * - Maintains context through metadata enrichment
 * - Generates synthetic bindings for variables only used in Elixir injections
 * 
 * HOW: Recursive pattern matching on TypedExpr with metadata preservation
 * - Each TypedExpr constructor maps to one or more ElixirAST nodes
 * - Metadata carries context through the entire pipeline
 * - Complex expressions decomposed into simpler AST nodes
 * - Pattern detection integrated into conversion process
 * - Synthetic bindings wrapped around case clause bodies as needed
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Only converts AST formats, no code generation
 * - Open/Closed: Easy to add new node types without modifying existing
 * - Testability: Can test AST conversion independently of generation
 * - Maintainability: Clear separation from transformation and printing
 * - Robustness: Handles Haxe optimizer removing "unused" variables
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTBuilder {
    // All state has been moved to CompilationContext - no more static variables!
    // This eliminates static state contamination during parallel test execution.

    // Module-level state (will be migrated to context in future)
    public static var currentModule: String = null;
    public static var currentModuleHasPresence: Bool = false;
    // REMOVED: currentClauseContext - Now using context.currentClauseContext for proper context propagation
    public static var switchNestingLevel: Int = 0; // Track how deep we are in nested switches

    // ================================================================
    // Compilation Instrumentation for Hanging Diagnosis
    // ================================================================
    #if debug_compilation_hang
    private static var recursionDepth: Int = 0;
    private static var maxRecursionDepth: Int = 0;
    private static var nodeProcessingCount: Map<String, Int> = new Map();
    private static var currentNodeStack: Array<String> = [];
    private static var lastProgressTime: Float = 0;
    private static var progressInterval: Float = 1000; // Log every 1 second
    private static var compilationStartTime: Float = 0;
    private static var totalNodesProcessed: Int = 0;
    private static var cycleDetectionMap: Map<String, Int> = new Map();
    private static var MAX_SAME_NODE_VISITS: Int = 100; // Detect cycles
    private static var MAX_TOTAL_NODES: Int = 100000; // Hang detection threshold

    private static function logCompilationProgress(message: String) {
        var now = haxe.Timer.stamp() * 1000;
        var elapsed = now - compilationStartTime;
        Sys.println('[HANG DEBUG ${elapsed}ms] Depth:${recursionDepth}/${maxRecursionDepth} Nodes:${totalNodesProcessed} - ${message}');
        lastProgressTime = now;
    }

    

    private static function enterNode(nodeType: String, exprDetails: String = "") {
        recursionDepth++;
        totalNodesProcessed++;
        if (recursionDepth > maxRecursionDepth) {
            maxRecursionDepth = recursionDepth;
        }

        // Check for compilation hang
        if (totalNodesProcessed > MAX_TOTAL_NODES) {
            Sys.println('[HANG DETECTED] Compilation exceeded ${MAX_TOTAL_NODES} nodes');
            Sys.println('[HANG DETECTED] Last node type: ${nodeType}');
            Sys.println('[HANG DETECTED] Expression details: ${exprDetails}');
            Sys.println('[HANG DETECTED] Stack depth: ${recursionDepth}');
            Sys.println('[HANG DETECTED] Current stack:');
            for (i in 0...Math.floor(Math.min(10, currentNodeStack.length))) {
                var idx = currentNodeStack.length - 1 - i;
                Sys.println('  [${idx}] ${currentNodeStack[idx]}');
            }
            throw 'Compilation hang detected after processing ${totalNodesProcessed} nodes. Possible infinite loop in AST processing.';
        }

        // Log progress every 10k nodes
        if (totalNodesProcessed % 10000 == 0) {
            logCompilationProgress('Processing node ${totalNodesProcessed}: ${nodeType}');
        }

        var nodeKey = '${nodeType}@depth${recursionDepth}';
        currentNodeStack.push(nodeKey);

        // Track visit count for cycle detection
        var visitCount = nodeProcessingCount.get(nodeType);
        if (visitCount == null) visitCount = 0;
        visitCount++;
        nodeProcessingCount.set(nodeType, visitCount);

        // Detect potential infinite loops
        if (visitCount > MAX_SAME_NODE_VISITS) {
            Sys.println('[HANG DEBUG] ‚ö†Ô∏è POTENTIAL INFINITE LOOP: ${nodeType} visited ${visitCount} times!');
            Sys.println('[HANG DEBUG] Current stack: ${currentNodeStack.join(" -> ")}');
            if (exprDetails != "") {
                Sys.println('[HANG DEBUG] Expression details: ${exprDetails}');
            }
        }

        // Progress logging
        var now = haxe.Timer.stamp() * 1000;
        if (now - lastProgressTime > progressInterval) {
            logCompilationProgress('Processing ${nodeType} ${exprDetails}');
        }

        // Log entry for significant nodes
        if (recursionDepth <= 3 || nodeType.indexOf("Module") >= 0 || nodeType.indexOf("Class") >= 0) {
            Sys.println('[HANG DEBUG] ‚Üí Entering ${nodeType} at depth ${recursionDepth} ${exprDetails}');
        }
    }

    private static function exitNode(nodeType: String) {
        if (currentNodeStack.length > 0) {
            currentNodeStack.pop();
        }
        recursionDepth--;

        // Log exit for significant nodes
        if (recursionDepth <= 2 || nodeType.indexOf("Module") >= 0 || nodeType.indexOf("Class") >= 0) {
            Sys.println('[HANG DEBUG] ‚Üê Exiting ${nodeType} at depth ${recursionDepth}');
        }
    }

    private static function detectCycle(nodeId: String): Bool {
        var count = cycleDetectionMap.get(nodeId);
        if (count == null) count = 0;
        count++;
        cycleDetectionMap.set(nodeId, count);

        if (count > 10) { // Same exact node processed too many times
            Sys.println('[HANG DEBUG] üîÑ CYCLE DETECTED: Node ${nodeId} processed ${count} times!');
            return true;
        }
        return false;
    }
    #end
    
    /**
     * Reference to the compiler for dependency tracking
     * Set by ElixirCompiler when calling buildFromTypedExpr
     */
    @:allow(reflaxe.elixir.ElixirCompiler)
    @:allow(reflaxe.elixir.ast.builders.ModuleBuilder)
    public static var compiler: reflaxe.elixir.ElixirCompiler = null;
    
    // Small utility: check if a string is composed only of digits (always available)
    private static function isAllDigitsStr(s:String):Bool {
        if (s == null || s.length == 0) return false;
        for (i in 0...s.length) {
            var c = s.charCodeAt(i);
            if (c < '0'.code || c > '9'.code) return false;
        }
        return true;
    }
    
    /**
     * BehaviorTransformer: Pluggable behavior transformation system
     * 
     * WHY: Phoenix.Presence and other Elixir behaviors inject local functions
     * that have different calling conventions than their module counterparts.
     * The main compiler shouldn't have hardcoded knowledge of specific behaviors.
     * 
     * WHAT: Manages behavior-specific method call transformations based on
     * module metadata (@:presence, @:genserver, etc.) instead of hardcoded logic.
     * 
     * HOW: When compiling a module with behavior annotations, the transformer
     * is activated and intercepts method calls for behavior-specific handling.
     * 
     * @see reflaxe.elixir.behaviors.BehaviorTransformer
     * @see reflaxe.elixir.behaviors.PresenceBehaviorTransformer
     */
    public static var behaviorTransformer: reflaxe.elixir.behaviors.BehaviorTransformer = null;
    
    /**
     * Track module dependency when generating remote calls
     * 
     * WHY: Need to ensure modules are loaded in correct order for scripts
     * WHAT: Records that the current module depends on the specified module
     * HOW: Updates the compiler's moduleDependencies map
     */
    static function trackDependency(moduleName: String): Void {
        // Skip built-in Elixir modules that don't need loading
        var builtins = ["Map", "Enum", "String", "Kernel", "List", "IO", 
                        "Process", "GenServer", "Supervisor", "Agent", 
                        "File", "Path", "System", "Code", "Module", "Application",
                        "Integer", "Float", "Regex", "Date", "DateTime", "NaiveDateTime"];
        
        if (builtins.indexOf(moduleName) >= 0) {
            return; // Don't track built-in modules
        }
        
        if (currentContext.compiler != null && currentContext.compiler.currentCompiledModule != null) {
            var deps = currentContext.compiler.moduleDependencies.get(currentContext.compiler.currentCompiledModule);
            if (deps != null && moduleName != currentContext.compiler.currentCompiledModule) {
                // Don't track self-dependencies
                deps.set(moduleName, true);
                
                #if debug_dependencies
                #if debug_ast_builder
                trace('[ElixirASTBuilder] Module ${compiler.currentCompiledModule} depends on ${moduleName}');
                #end
                #end
            }
        }
    }
    
    /**
     * Get variable initialization value with infrastructure variable support
     * 
     * WHY: Infrastructure variables (_g, _g1) need their actual initialization values
     *      not their names when building accumulators
     * WHAT: Returns the tracked init value for infrastructure vars, or EVar for regular vars
     * HOW: Checks context.infrastructureVarInitValues map first, falls back to EVar
     * 
     * @param varName The variable name to get value for
     * @param context The current compilation context with tracking info
     * @return ElixirAST representing the variable's initial value
     */
    static function getVariableInitValue(varName: String, context: CompilationContext): ElixirAST {
        if (context.infrastructureVarInitValues != null && context.infrastructureVarInitValues.exists(varName)) {
            // Use the tracked initialization value (e.g., 0 for _g, 5 for _g1)
            return context.infrastructureVarInitValues.get(varName);
        } else {
            // For regular variables, use the variable reference
            return makeAST(EVar(varName));
        }
    }
    
    /**
     * Main entry point: Convert TypedExpr to ElixirAST
     * 
     * WHY: Single entry point for all AST conversion
     * WHAT: Recursively converts TypedExpr tree to ElixirAST tree
     * HOW: Pattern matches on expr type and delegates to specific handlers
     */
    /**
     * Replace TLocal references to a temp var with inline null coalescing pattern
     */
    // Delegate to SubstitutionHelpers
    static inline function replaceNullCoalVar(expr: TypedExpr, varId: Int, initExpr: TypedExpr): TypedExpr {
        return SubstitutionHelpers.replaceNullCoalVar(expr, varId, initExpr);
    }
    
    /**
     * Substitute all occurrences of a variable with another expression.
     * Used for eliminating infrastructure variables by replacing them with their init expressions.
     */
    // Delegate to SubstitutionHelpers
    static inline function substituteVariable(expr: TypedExpr, varToReplace: TVar, replacement: TypedExpr): TypedExpr {
        return SubstitutionHelpers.substituteVariable(expr, varToReplace, replacement);
    }
    
    // Store the current context for recursive calls
    private static var currentContext: reflaxe.elixir.CompilationContext = null;

    // Public entry point for the compiler
    public static function buildFromTypedExpr(expr: TypedExpr, context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_compilation_hang
        if (compilationStartTime == 0) {
            compilationStartTime = haxe.Timer.stamp() * 1000;
            Sys.println('[HANG DEBUG] === COMPILATION STARTED ===');
        }
        #end

        return buildFromTypedExprWithContext(expr, context);
    }

    // Helper for recursive calls - creates context from usage map if needed (for backward compatibility)
    private static function buildFromTypedExprHelper(expr: TypedExpr, usageMapOrContext: Dynamic): ElixirAST {
        // Check if we got a context or a usage map
        if (Std.isOfType(usageMapOrContext, reflaxe.elixir.CompilationContext)) {
            return buildFromTypedExprWithContext(expr, cast usageMapOrContext);
        } else {
            // Legacy call with usage map - use current context
            if (currentContext != null) {
                // Update the usage map in current context if provided
                if (usageMapOrContext != null) {
                    currentContext.variableUsageMap = cast usageMapOrContext;
                }
                return buildFromTypedExprWithContext(expr, currentContext);
            } else {
                // This shouldn't happen, but create a minimal context
                var ctx = new reflaxe.elixir.CompilationContext();
                ctx.variableUsageMap = cast usageMapOrContext;
                return buildFromTypedExprWithContext(expr, ctx);
            }
        }
    }

    private static function buildFromTypedExprWithContext(expr: TypedExpr, context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_compilation_hang
        var exprType = Type.enumConstructor(expr.expr);
        var exprId = '${exprType}_${expr.pos}';

        // Debug circular reference issue
        if (exprType == "TParenthesis" || exprType == "TVar" || exprType == "TBinop") {
            Sys.println('[HANG DEBUG] Processing ${exprType} at ${expr.pos}');
            switch(expr.expr) {
                case TVar(v, _):
                    Sys.println('[HANG DEBUG]   TVar: ${v.name} (id: ${v.id})');
                case TParenthesis(e):
                    Sys.println('[HANG DEBUG]   TParenthesis wrapping: ${Type.enumConstructor(e.expr)}');
                case TBinop(op, _, _):
                    Sys.println('[HANG DEBUG]   TBinop operator: ${op}');
                default:
            }
        }

        // Only detect and report cycles - don't interfere with compilation
        detectCycle(exprId);
        enterNode(exprType, exprId);
        #end

        // Ensure compiler reference is set in context
        if (context.compiler == null && compiler != null) {
            context.compiler = compiler;
        }
        
        // Store context for recursive calls
        var previousContext = currentContext;

        #if debug_variable_renaming
        var entriesBeforeSet = Lambda.count(context.tempVarRenameMap);
        var prevEntries = if (previousContext != null) Lambda.count(previousContext.tempVarRenameMap) else 0;
        trace('[ElixirASTBuilder.buildFromTypedExprWithContext] About to set currentContext - incoming: $entriesBeforeSet entries, previous had: $prevEntries');
        #end

        // FIXED: Preserve tempVarRenameMap from previous context when nested calls occur
        // Nested buildFromTypedExpr calls were overwriting currentContext with contexts that had empty maps
        // This was losing the parameter registrations from buildClassAST
        if (previousContext != null && Lambda.count(context.tempVarRenameMap) == 0 && Lambda.count(previousContext.tempVarRenameMap) > 0) {
            #if debug_variable_renaming
            trace('[ElixirASTBuilder.buildFromTypedExprWithContext] PRESERVING ${Lambda.count(previousContext.tempVarRenameMap)} map entries from previous context');
            #end
            // Copy entries from previous context to preserve registrations
            for (key in previousContext.tempVarRenameMap.keys()) {
                context.tempVarRenameMap.set(key, previousContext.tempVarRenameMap.get(key));
            }
        }

        currentContext = context;

        #if debug_variable_renaming
        var entriesAfterSet = Lambda.count(currentContext.tempVarRenameMap);
        trace('[ElixirASTBuilder.buildFromTypedExprWithContext] Set currentContext - now has $entriesAfterSet map entries');
        #end

        // Store the compilation context's usage map for context-aware variable naming
        // If no usage map provided in context, analyze now
        if (context.variableUsageMap != null) {
            // variableUsageMap is accessed via currentContext
        } else {
            // TODO: Restore when VariableUsageAnalyzer is available
            // Analyze usage for this expression if not already done
            // var variableUsageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(expr);
            // context.variableUsageMap = variableUsageMap;
            context.variableUsageMap = new Map();  // Temporary empty map
        }

        // Set compiler reference from context
        compiler = context.compiler;

        // Set behavior transformer from context
        behaviorTransformer = context.behaviorTransformer;

        // Also copy over other critical state from context to static variables
        // This is temporary during the migration phase
        // tempVarRenameMap is accessed via currentContext
        // underscorePrefixedVars is accessed via currentContext
        // Context fields are accessed via currentContext
        // Method context is now properly set by ElixirCompiler
        currentModule = context.currentModule;
        currentModuleHasPresence = context.currentModuleHasPresence;
        // No need to set currentClauseContext here - it's already part of the context

        #if debug_ast_builder
        trace('[XRay AST Builder] Converting TypedExpr: ${expr.expr}');
        if (currentContext.variableUsageMap != null) {
            #if debug_ast_builder
            trace('[XRay AST Builder] Using variable usage map with ${Lambda.count(currentContext.variableUsageMap)} entries');
            #end
        }
        #end

        // Check context-local builder cache to avoid re-converting identical subtrees
        var cached: Null<ElixirAST> = null;
        if (currentContext != null && currentContext.builderCache != null) {
            cached = currentContext.builderCache.get(expr);
            if (cached != null) {
                #if debug_compilation_hang Sys.println('[HANG DEBUG] Cache hit for ' + Type.enumConstructor(expr.expr) + ' at ' + expr.pos); #end
                currentContext = previousContext;
                #if debug_compilation_hang exitNode(exprType); #end
                return cached;
            }
        }

        // Normalize trivial wrappers to avoid deep recursive walks on large trees
        expr = flattenNoOpWrappers(expr);

        // Do the actual conversion
        var metadata = createMetadata(expr);
        var astDef = convertExpression(expr);

        // CRITICAL FIX: If conversion returns null (skipped assignment), propagate the null
        // This allows TBlock to properly filter out redundant assignments
        if (astDef == null) {
            // Restore context before returning null
            currentContext = previousContext;
            return null;
        }

        // ONLY mark metadata - NO transformation in builder!
        // Check both direct enum constructor calls AND function calls that return idiomatic enums
        switch(expr.expr) {
            case TCall(e, _) if (e != null && PatternDetector.isEnumConstructor(e) && hasIdiomaticMetadata(e)):
                // Direct enum constructor call (e.g., ModuleRef("MyModule"))
                metadata.requiresIdiomaticTransform = true;
                metadata.idiomaticEnumType = switch(e.expr) {
                    case TField(_, FEnum(enumRef, _)): enumRef.get().name;
                    default: "";
                };
                #if debug_ast_builder
                trace('[AST Builder] Marked direct enum constructor for transformer: ${metadata.idiomaticEnumType}');
                #end
            case TCall(_, _):
                // Function call - check if it returns an idiomatic enum
                switch(expr.t) {
                    case TEnum(enumRef, _):
                        var enumType = enumRef.get();
                        if (enumType.meta.has(":elixirIdiomatic")) {
                            metadata.requiresIdiomaticTransform = true;
                            metadata.idiomaticEnumType = enumType.name;
                            #if debug_ast_builder
                            trace('[AST Builder] Marked function return value as idiomatic enum: ${enumType.name}');
                            #end
                        }
                    default:
                }
            default:
        }

        // Attach typed HEEx AST to metadata when emitting ESigil("H", ...)
        switch (astDef) {
            case ESigil(type, content, _mods) if (type == "H"):
                try {
                    var typedFrags = reflaxe.elixir.ast.builders.HeexFragmentBuilder.build(content);
                    (cast metadata : Dynamic).heexAST = typedFrags;
                } catch (_:Dynamic) {}
            default:
        }

        var result = makeASTWithMeta(astDef, metadata, expr.pos);
        if (currentContext != null && currentContext.builderCache != null) {
            currentContext.builderCache.set(expr, result);
        }

        #if debug_ast_builder
        trace('[XRay AST Builder] Generated AST: ${astDef}');
        #end

        // Restore previous context
        currentContext = previousContext;

        #if debug_compilation_hang
        exitNode(exprType);
        #end

        return result;
    }

    /**
     * Fast-path flattener for non-semantic wrappers to reduce recursion depth
     * - Removes TParenthesis
     * - Removes TBlock with single expression
     * - Keeps semantic TMeta (e.g., :heex, :untyped) but unwraps other metas
     */
    static function flattenNoOpWrappers(e: TypedExpr): TypedExpr {
        var seen = 0;
        var limit = 1000; // guard against pathological shapes
        var cur = e;
        while (seen < limit) {
            switch (cur.expr) {
                case TParenthesis(inner):
                    cur = inner; seen++;
                case TMeta(meta, inner):
                    // Preserve metas with known semantic effect; unwrap others
                    var name = meta.name;
                    if (name == ":heex" || name == ":untyped") {
                        // stop unwrapping at semantic meta
                        return cur;
                    } else {
                        cur = inner; seen++;
                    }
                case TBlock(exprs) if (exprs != null && exprs.length == 1):
                    cur = exprs[0]; seen++;
                default:
                    return cur;
            }
        }
        return cur;
    }
    
    /**
     * Convert TypedExprDef to ElixirASTDef
     */
    static function convertExpression(expr: TypedExpr): ElixirASTDef {
        #if debug_compilation_hang
        var nodeType = Type.enumConstructor(expr.expr);
        if (nodeType == "TSwitch" || nodeType == "TEnumIndex" || nodeType == "TWhile" || nodeType == "TFor") {
            Sys.println('[HANG DEBUG] üéØ Processing critical node: ${nodeType} at pos ${expr.pos}');
        }
        #end

        #if debug_ast_builder
        // DEBUG: Trace TVar expressions at entry point
        var exprType = Type.enumConstructor(expr.expr);
        if (exprType == "TVar") {
            switch(expr.expr) {
                case TVar(tvar, init):
                    trace('[convertExpression ENTRY] üîç TVar detected: ${tvar.name}');
                    trace('[convertExpression ENTRY]   TVar init: ${init != null ? Type.enumConstructor(init.expr) : "null"}');
                default:
            }
        }
        #end

        return switch(expr.expr) {
            // ================================================================
            // Literals and Constants
            // ================================================================
            case TConst(c):
                // Delegate to LiteralBuilder for all constant handling
                LiteralBuilder.buildConst(c, expr, currentContext);
                
            // ================================================================
            // Variables and Binding
            // ================================================================
            case TLocal(v):
                // TLocal represents a local variable reference (reading/using a variable)
                //
                // DIFFERENCE FROM TVar:
                // - TLocal: Variable usage/reference - when you READ a variable (x in "x + 1")
                // - TVar: Variable declaration/assignment - when you WRITE to a variable (var x = 5)
                //
                // EXAMPLES:
                // var x = 5;        // TVar(x, TConst(5)) - declaration with init
                // x = 10;           // TVar(x, TConst(10)) - assignment (reassignment in Elixir)
                // return x + 1;     // TLocal(x) in the expression - reading the variable
                // if (x > 0) ...    // TLocal(x) in the condition - reading the variable
                //
                // CRITICAL FIX: TLocal must check context for renamed variables
                // This ensures references match declarations (e.g., _changeset references use _changeset)
                // Without this check, we get "undefined variable" errors when TVar adds underscore prefix
                // but TLocal uses the original name.

                // Dual-key lookup: Try ID first (pattern matching), then name (EVar reference)
                var idKey = Std.string(v.id);
                var nameKey = v.name;

                // PRIORITY 0: Check ClauseContext for case-local TLocal variables
                // WHY: Guard expressions use TLocal references that need consistent names with patterns
                // WHAT: ClauseContext.localToName maps TLocal IDs to canonical pattern variable names
                // HOW: SwitchBuilder registers mappings when extracting pattern variables
                var clauseMapping: Null<String> = null;
                if (currentContext.currentClauseContext != null) {
                    clauseMapping = currentContext.currentClauseContext.lookupVariable(v.id);
                    if (clauseMapping != null) {
                        #if debug_clause_context
                        trace('[TLocal ClauseContext] Found mapping for ${v.name} (id=${v.id}) -> $clauseMapping');
                        #end
                    }
                }

                var varName = if (clauseMapping != null) {
                    // Use ClauseContext mapping (highest priority)
                    clauseMapping;
                } else if (currentContext.tempVarRenameMap.exists(idKey)) {
                    // ID-based lookup succeeds (builder phase registered this variable)
                    var renamed = currentContext.tempVarRenameMap.get(idKey);
                    #if debug_hygiene
                    trace('[TLocal] Variable ${v.name} (id=${v.id}) found in context via ID: $renamed');
                    #end
                    renamed;
                } else if (currentContext.tempVarRenameMap.exists(nameKey)) {
                    // Name-based lookup succeeds (transformer phase or builder phase)
                    var renamed = currentContext.tempVarRenameMap.get(nameKey);
                    #if debug_hygiene
                    trace('[TLocal] Variable ${v.name} (id=${v.id}) found in context via NAME: $renamed');
                    #end
                    renamed;
                } else if (currentContext.isInConstructorArgContext) {
                    // Constructor argument context - strip Haxe's numeric shadowing suffix
                    // Pattern: replacer2 -> replacer, space3 -> space
                    var pattern = ~/^(.+?)(\d+)$/;
                    var baseName = if (pattern.match(v.name)) {
                        var base = pattern.matched(1);
                        var suffix = pattern.matched(2);
                        #if debug_constructor_args
                        trace('[TLocal Constructor] Stripping shadow suffix: ${v.name} -> $base (removed: $suffix)');
                        #end
                        base;
                    } else {
                        v.name;
                    };
                    // Convert to Elixir variable name
                    VariableAnalyzer.toElixirVarName(baseName);
                } else {
                    // Not in context - use standard snake_case conversion
                    var converted = VariableAnalyzer.toElixirVarName(v.name);
                    #if debug_hygiene
                    trace('[TLocal] Variable ${v.name} (id=${v.id}) NOT in context, using converted: $converted');
                    #end
                    converted;
                };

                EVar(varName);
                
            case TVar(v, init):
                #if debug_ast_builder
                // DEBUG: Track what TVar compilation returns for infrastructure variables
                trace('[DEBUG TVar] Compiling TVar: ${v.name}');
                if (v.name.indexOf("g") >= 0 || v.name.indexOf("_") >= 0) {
                    trace('[DEBUG TVar]   Name contains g or underscore: ${v.name}');
                    trace('[DEBUG TVar]   Init type: ${init != null ? Type.enumConstructor(init.expr) : "null"}');
                    trace('[DEBUG TVar]   Is simple init: ${init == null || isSimpleInit(init)}');
                }
                #end

                // CRITICAL FIX: Skip TVar generation for pattern-bound variables BEFORE delegation
                // When a variable is already bound by the pattern (e.g., {:ok, value}),
                // generating "value = nil" is incorrect - the pattern already provides the value
                #if debug_ast_builder
                trace('[TVar CHECK] var=${v.name} id=${v.id} hasClauseContext=${currentContext.currentClauseContext != null}');
                if (currentContext.currentClauseContext != null) {
                    trace('[TVar CHECK]   localToName has ${v.id}? ${currentContext.currentClauseContext.localToName.exists(v.id)}');
                    trace('[TVar CHECK]   localToName size: ${Lambda.count(currentContext.currentClauseContext.localToName)}');
                }
                #end

                if (currentContext.currentClauseContext != null) {
                    #if debug_ast_builder
                    #if sys
                    var debugFile4 = sys.io.File.append("/tmp/enum_debug.log");
                    debugFile4.writeString('[TVar CHECK] var=${v.name} id=${v.id}\n');
                    debugFile4.writeString('[TVar CHECK]   init: ${init != null ? Type.enumConstructor(init.expr) : "null"}\n');
                    debugFile4.writeString('[TVar CHECK]   localToName.exists(${v.id})?: ${currentContext.currentClauseContext.localToName.exists(v.id)}\n');
                    debugFile4.writeString('[TVar CHECK]   localToName keys: [${[for (k in currentContext.currentClauseContext.localToName.keys()) k].join(", ")}]\n');
                    debugFile4.close();
                    #end
                    #end

                    // Check localToName mapping (pattern variable bindings)
                    // CRITICAL: Check by ID first (exact match)
                    if (currentContext.currentClauseContext.localToName.exists(v.id)) {
                        #if debug_ast_builder
                        #if sys
                        var debugFile5 = sys.io.File.append("/tmp/enum_debug.log");
                        debugFile5.writeString('[TVar] ‚úÖ SKIPPING (by ID): Variable ${v.name} (id=${v.id}) already bound by pattern\n');
                        debugFile5.close();
                        #end
                        #end
                        // Return null to skip this TVar - the pattern already bound the variable
                        return null;
                    }

                    // CRITICAL FIX: Also check by NAME for cases where Haxe creates different IDs
                    // In empty case bodies, Haxe generates new TVars with different IDs but same names
                    var patternVarNames = [for (name in currentContext.currentClauseContext.localToName) name];
                    if (patternVarNames.contains(v.name)) {
                        #if debug_ast_builder
                        #if sys
                        var debugFile6 = sys.io.File.append("/tmp/enum_debug.log");
                        debugFile6.writeString('[TVar] ‚úÖ SKIPPING (by NAME): Variable ${v.name} (id=${v.id}) matches pattern variable\n');
                        debugFile6.close();
                        #end
                        #end
                        // Return null to skip this TVar - the pattern already bound a variable with this name
                        return null;
                    }
                }

                // Delegate simple variable declarations to VariableBuilder
                // Complex patterns (blocks, comprehensions) are handled below
                if (init == null || isSimpleInit(init)) {
                    var result = VariableBuilder.buildVariableDeclaration(v, init, currentContext);

                    #if debug_ast_builder
                    if (v.name == "_g" || v.name == "g") {
                        trace('[DEBUG TVar]   VariableBuilder result: ${result != null ? Type.enumConstructor(result) : "null"}');
                    }
                    #end

                    if (result != null) {
                        return result;
                    }
                }
                
                // COMPLETE FIX: Eliminate ALL infrastructure variable assignments at source
                // Use centralized detection from TypedExprPreprocessor
                var isInfrastructureVar = reflaxe.elixir.preprocessor.TypedExprPreprocessor.isInfrastructureVar(v.name);
                
                // Debug: trace all infrastructure variable assignments to understand their structure
                #if debug_infrastructure_vars
                if (isInfrastructureVar && init != null) {
                    trace('[Infrastructure Variable Debug] TVar ${v.name} (id: ${v.id}) init type: ${Type.enumConstructor(init.expr)}');
                    switch(init.expr) {
                        case TField(obj, fa):
                            trace('[Infrastructure Variable Debug]   TField detected');
                        case TLocal(lv):
                            trace('[Infrastructure Variable Debug]   TLocal: ${lv.name}');
                        case _:
                            trace('[Infrastructure Variable Debug]   Other init type');
                    }
                }
                #end
                
                // CRITICAL: Track infrastructure variable mappings for switch targets
                // When _g = msg.type, we need to know that _g should use msg_type in the switch
                if (isInfrastructureVar && init != null) {
                    // First check if this is a field access that will be extracted in patterns
                    switch(init.expr) {
                        case TField(obj, fa):
                            // This is _g = something.field
                            // In switch patterns, this field will be extracted as a variable
                            var fieldName = extractFieldName(fa);
                            switch(obj.expr) {
                                case TLocal(localVar):
                                    // Pattern like _g = msg.type
                                    // When the switch extracts msg fields, type becomes msg_type
                                    var extractedVarName = VariableAnalyzer.toElixirVarName(localVar.name) + "_" + reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                                    
                                    // Store this mapping for later use in switch expressions
                                    // CRITICAL: Use variable NAME as key, not ID, since Haxe creates different IDs for the same variable
                                    if (currentContext.tempVarRenameMap == null) {
                                        currentContext.tempVarRenameMap = new Map();
                                    }
                                    // Map the infrastructure variable name to the extracted variable name
                                    currentContext.tempVarRenameMap.set(v.name, extractedVarName);
                                    
                                    #if debug_infrastructure_vars
                                    trace('[Infrastructure Variable Mapping] ${v.name} (id: ${v.id}) = ${localVar.name}.${fieldName} -> will use ${extractedVarName}');
                                    trace('[Infrastructure Variable Mapping] Storing in tempVarRenameMap: key="${v.name}" (name, not ID) value="${extractedVarName}"');
                                    #end

                                    // FIXED: Don't skip the assignment! We need to generate the variable binding
                                    // The mapping is for pattern matching, but the variable still needs to exist
                                    // for the switch expression to reference it.
                                    // Fall through to let VariableBuilder generate: g = Map.get(msg, :type)
                                default:
                                    // Field access on something other than a local variable
                            }
                        case TEnumParameter(_, _, _):
                            // This is the problematic pattern: g = elem(tuple, index)
                            // In most cases, we skip it because the pattern already extracts these values
                            // BUT: We need to keep it if the variable is actually referenced later
                            #if debug_ast_builder
                            trace('[Infrastructure Variable Fix] TEnumParameter assignment for: ${v.name}');
                            #end
                            // Don't skip - let it be processed normally
                            // The assignment might be needed for later references
                            
                        case TLocal(localVar):
                            // Check if assigning from another infrastructure variable
                            var sourceVar = localVar.name;
                            if (sourceVar == "g" || sourceVar == "_g" || 
                                (sourceVar.length > 1 && sourceVar.charAt(0) == 'g') ||
                                (sourceVar.length > 2 && sourceVar.substr(0, 2) == "_g")) {
                                // Skip infrastructure variable chains like: g1 = g
                                #if debug_ast_builder
                                trace('[Infrastructure Variable Fix] Skipping chain assignment: ${v.name} = ${sourceVar}');
                                #end
                                return null;
                            }
                            
                        default:
                            // Other uses of infrastructure variables might be legitimate
                    }
                }
                
                #if debug_variable_usage
                if (v.name == "value" || v.name == "msg" || v.name == "err") {
                    #if debug_ast_builder
                    trace('[AST Builder] Processing TVar: ${v.name} (id: ${v.id})');
                    #end
                }
                #end

                // Don't register renamed variables here - we'll register them where we decide to emit clean names
                // This avoids false positives from legitimate variable names like "this1"
                #if debug_variable_renaming
                var renamedPattern = ~/^(.+?)(\d+)$/;
                if (renamedPattern.match(v.name)) {
                    #if debug_ast_builder
                    trace('[RENAME DEBUG] TVar: Found variable with numeric suffix "${v.name}" (id: ${v.id}) - will be handled at emission point');
                    #end
                }
                #end
                
                #if debug_loop_bodies
                // Debug TVar declarations that might be lost in loop bodies
                if (v.name == "meta" || v.name == "entry" || v.name == "userId") {
                    #if debug_ast_builder
                    trace('[XRay LoopBody] TVar declaration: ${v.name} = ${init != null ? "..." : "null"}');
                    #end
                    if (init != null) {
                        #if debug_ast_builder
                        trace('[XRay LoopBody] Init type: ${Type.enumConstructor(init.expr)}');
                        #end
                    }
                }
                #end
                
                #if debug_null_coalescing
                #if debug_ast_builder
                trace('[AST Builder] TVar: ${v.name}, init type: ${init != null ? Type.enumConstructor(init.expr) : "null"}');
                #end
                #end
                
                #if debug_assignment_context
                #if debug_ast_builder
                trace('[XRay AssignmentContext] TVar: ${v.name}');
                #end
                if (init != null) {
                    #if debug_ast_builder
                    trace('[XRay AssignmentContext] Init expr: ${Type.enumConstructor(init.expr)}');
                    #end
                    switch(init.expr) {
                        case TField(e, _):
                            #if debug_ast_builder
                            trace('[XRay AssignmentContext] TField access detected - likely in expression context');
                            #end
                        case _:
                    }
                }
                #end
                
                #if debug_ast_pipeline
                if (v.name == "p1" || v.name == "p2" || v.name == "p" || v.name == "p_1" || v.name == "p_2") {
                    #if debug_ast_builder
                    trace('[AST Builder] TVar declaration: name="${v.name}", id=${v.id}');
                    #end
                }
                #end
                
                #if debug_array_patterns
                if (init != null) {
                    #if debug_ast_builder
                    trace('[XRay ArrayPattern] TVar ${v.name} init: ${Type.enumConstructor(init.expr)}');
                    #end
                    // Check if this is an array map/filter initialization
                    switch(init.expr) {
                        case TBlock(exprs):
                            #if debug_ast_builder
                            trace('[XRay ArrayPattern] TVar contains TBlock with ${exprs.length} expressions');
                            #end
                        case _:
                    }
                }
                #end
                
                // Check for conditional comprehension pattern: var evens = { var g = []; if statements; g }
                // AND for unrolled comprehension pattern: var doubled = { doubled = n = 1; [] ++ [n*2]; ... }
                if (init != null) {
                    switch(init.expr) {
                        case TBlock(blockStmts) if (blockStmts.length >= 3):
#if debug_map_literal
                            #if debug_ast_builder
                            trace('[MapLiteral Debug] TVar name=${v.name} id=${v.id} with block init (length=${blockStmts.length})');
                            #end
                            for (i in 0...blockStmts.length) {
                                #if debug_ast_builder
                                trace('  stmt[' + i + '] = ' + Type.enumConstructor(blockStmts[i].expr));
                                #end
                                switch(blockStmts[i].expr) {
                                    case TVar(tempVar, tempInit):
                                        var initKind = tempInit != null ? Type.enumConstructor(tempInit.expr) : "null";
                                        #if debug_ast_builder
                                        trace('    TVar ' + tempVar.name + ' init=' + initKind);
                                        #end
                                    case TBinop(op, lhs, rhs):
                                        #if debug_ast_builder
                                        trace('    TBinop op=' + Std.string(op) + ' lhs=' + Type.enumConstructor(lhs.expr) + ' rhs=' + Type.enumConstructor(rhs.expr));
                                        #end
                                    case TCall(func, args):
                                        #if debug_ast_builder
                                        trace('    TCall func=' + Type.enumConstructor(func.expr) + ' args=' + [for (a in args) Type.enumConstructor(a.expr)].join(","));
                                        #end
                                    case TLocal(localVar):
                                        #if debug_ast_builder
                                        trace('    TLocal name=' + localVar.name);
                                        #end
                                    case _:
                                }
                            }
#end
                            var mapLiteral = tryBuildMapLiteralFromBlock(blockStmts, currentContext);
                            if (mapLiteral != null) {
                                return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), mapLiteral);
                            }

                            // NEW: Check for unrolled array comprehension pattern FIRST
                            // Pattern: var doubled = { doubled = n = 1; [] ++ [expr]; n = 2; ...; [] }
                            #if debug_ast_builder
                            trace('[TVar COMPREHENSION CHECK] Checking if TBlock is unrolled comprehension');
                            trace('[TVar COMPREHENSION CHECK] Block has ${blockStmts.length} statements');
                            #end

                            var comprehensionAST = reflaxe.elixir.ast.builders.ComprehensionBuilder.tryBuildArrayComprehensionFromBlock(blockStmts, currentContext);
                            if (comprehensionAST != null) {
                                #if debug_ast_builder
                                trace('[TVar COMPREHENSION] ‚úÖ Detected unrolled comprehension in TVar initialization!');
                                trace('[TVar COMPREHENSION] Variable: ${v.name}');
                                trace('[TVar COMPREHENSION] Converting to idiomatic Elixir comprehension');
                                #end
                                // Return assignment: doubled = for n <- [1,2,3], do: n * 2
                                var varName = VariableAnalyzer.toElixirVarName(v.name);
                                return EMatch(PVar(varName), comprehensionAST);
                            }

                            // FALLBACK: Check if this is a conditional comprehension pattern
                            var isConditionalComp = false;
                            var tempVarName = "";
                            
                            // First: var g = []
                            switch(blockStmts[0].expr) {
                                case TVar(tempVar, tempInit) if (tempInit != null && (tempVar.name.startsWith("g") || tempVar.name.startsWith("_g"))):
                                    switch(tempInit.expr) {
                                        case TArrayDecl([]):
                                            tempVarName = tempVar.name;
                                            
                                            // Check middle: TBlock with if statements
                                            if (blockStmts.length >= 3) {
                                                switch(blockStmts[1].expr) {
                                                    case TBlock(ifStmts):
                                                        // Check if all are if statements
                                                        var allIfs = true;
                                                        for (stmt in ifStmts) {
                                                            switch(stmt.expr) {
                                                                case TIf(_, _, null): // if with no else
                                                                    continue;
                                                                default:
                                                                    allIfs = false;
                                                                    break;
                                                            }
                                                        }
                                                        
                                                        // Check last: return g
                                                        if (allIfs && blockStmts.length > 2) {
                                                            switch(blockStmts[blockStmts.length - 1].expr) {
                                                                case TLocal(retVar) if (retVar.name == tempVarName):
                                                                    isConditionalComp = true;
                                                                default:
                                                            }
                                                        }
                                                    default:
                                                }
                                            }
                                        default:
                                    }
                                default:
                            }
                            
                            if (isConditionalComp) {
                                // trace('[DEBUG] Found conditional comprehension for var ${v.name}');
                                var reconstructed = ComprehensionBuilder.tryReconstructConditionalComprehension(blockStmts, tempVarName, currentContext);
                                if (reconstructed != null) {
                                    // trace('[DEBUG] Successfully reconstructed as for comprehension');
                                    return EMatch(PVar(VariableAnalyzer.toElixirVarName(v.name)), reconstructed);
                                }
                            }

                            // FINAL FALLBACK: if the initializer block is a canonical list-building
                            // shape (var g = []; g = g ++ [..]; ...; g), synthesize a list literal
                            // and assign it to the declared variable. This preserves statement order
                            // (var init occurs before any following trace/return) and avoids leaking
                            // inner concatenation statements.
                            if (reflaxe.elixir.ast.builders.ComprehensionBuilder.looksLikeListBuildingBlock(blockStmts)) {
                                var strictVals = reflaxe.elixir.ast.builders.ComprehensionBuilder.extractListElements(blockStmts);
                                var valueAst: ElixirAST = null;
                                if (strictVals != null && strictVals.length > 0) {
                                    var built = [for (e in strictVals) buildFromTypedExpr(e, currentContext)];
                                    valueAst = makeAST(EList(built));
                                } else {
                                    var loose = reflaxe.elixir.ast.builders.ComprehensionBuilder.extractListElementsLoose(blockStmts, currentContext);
                                    if (loose != null && loose.length > 0) valueAst = makeAST(EList(loose));
                                }
                                if (valueAst != null) {
                                    var lhs = PVar(VariableAnalyzer.toElixirVarName(v.name));
                                    return EMatch(lhs, valueAst);
                                }
                            }
                        default:
                    }
                }
                
                // Special handling for enum extraction patterns with variable origin tracking
                // When Haxe compiles case Ok(value), it generates:
                // 1. TVar(_g, TEnumParameter(...)) - extracts to temp (ExtractionTemp origin)
                // 2. TVar(value, TLocal(_g)) - assigns temp to actual variable (PatternBinder origin)
                // We track the origin to distinguish legitimate "g" variables from temp vars
                var isEnumExtraction = false;
                var extractedFromTemp = "";
                var shouldSkipRedundantExtraction = false;
                var varOrigin: ElixirAST.VarOrigin = UserDefined;  // Default to user-defined
                var tempToBinderMap: Map<Int, Int> = null;

                if (init != null) {
                    switch(init.expr) {
                        case TEnumParameter(e, _, index):
                            // This is the temp extraction: _g = result.elem(1)
                            isEnumExtraction = true;
                            varOrigin = ExtractionTemp;  // Mark as extraction temp

                            // Check if this is extracting from a pattern variable in a switch case
                            // Temp vars follow the pattern: g, g1, g2, etc.
                            var tempVarName = VariableAnalyzer.toElixirVarName(v.name);

                            #if debug_variable_origin
                            #if debug_ast_builder
                            trace('[Variable Origin] TEnumParameter extraction:');
                            #end
                            #if debug_ast_builder
                            trace('  - Variable: ${v.name} (id=${v.id})');
                            #end
                            #if debug_ast_builder
                            trace('  - Temp name: $tempVarName');
                            #end
                            #if debug_ast_builder
                            trace('  - Origin: ExtractionTemp');
                            #end
                            #if debug_ast_builder
                            trace('  - Index: $index');
                            #end
                            #end

                            // CRITICAL: Register pattern binding with ClauseContext
                            // When patterns use temp vars (g), we must track which TVar they map to
                            if (currentContext.currentClauseContext != null && tempVarName.charAt(0) == 'g') {
                                // This temp var will be used in the pattern, register the binding
                                // The pattern will have 'g' and this TVar extracts to 'g'
                                currentContext.currentClauseContext.pushPatternBindings([{varId: v.id, binderName: tempVarName}]);

                                #if debug_clause_context
                                #if debug_ast_builder
                                trace('[ClauseContext Integration] Registered pattern binding for TEnumParameter:');
                                #end
                                #if debug_ast_builder
                                trace('  - TVar ID ${v.id} maps to pattern var "$tempVarName"');
                                #end
                                #end
                            }

                            // Check if EnumBindingPlan already provides this variable
                            // If so, the pattern already extracts it correctly and we should skip this assignment
                            if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
                                var plan = currentContext.currentClauseContext.enumBindingPlan;
                                if (plan.exists(index)) {
                                    // The binding plan already handles this extraction in the pattern
                                    shouldSkipRedundantExtraction = true;
                                    #if debug_enum_extraction
                                    #if debug_ast_builder
                                    trace('[TVar] Skipping redundant TEnumParameter extraction - binding plan provides variable at index $index');
                                    #end
                                    #end
                                    return null; // Skip this assignment entirely
                                }
                            }

                            // Only treat as temp if it matches the g/g1/g2 pattern
                            if ((tempVarName == "g" || (tempVarName.length > 1 && tempVarName.charAt(0) == "g" &&
                                tempVarName.charAt(1) >= '0' && tempVarName.charAt(1) <= '9'))) {
                                // This variable assignment is redundant - the pattern already extracted it
                                shouldSkipRedundantExtraction = true;
                                #if debug_redundant_extraction
                                #if debug_ast_builder
                                trace('[TVar] Detected redundant extraction for $tempVarName (will be filtered at TBlock level)');
                                #end
                                #end
                            }

                        case TLocal(tempVar):
                            // Check if this is assignment from a temp var
                            if (tempVar.name.startsWith("_g") || tempVar.name == "g" || ~/^g\d+$/.match(tempVar.name)) {
                                // This is assignment from temp: value = g
                                extractedFromTemp = tempVar.name;
                                varOrigin = PatternBinder;  // This is the actual pattern variable

                                // CRITICAL: Update pattern binding in ClauseContext
                                // This is the second assignment: value = g
                                // After this point, references should use 'value' not 'g'
                                if (currentContext.currentClauseContext != null) {
                                    // Override the temp var binding with the user variable name
                                    var userVarName = VariableAnalyzer.toElixirVarName(v.name);
                                    currentContext.currentClauseContext.pushPatternBindings([{varId: v.id, binderName: userVarName}]);

                                    #if debug_clause_context
                                    #if debug_ast_builder
                                    trace('[ClauseContext Integration] Updated pattern binding after assignment:');
                                    #end
                                    #if debug_ast_builder
                                    trace('  - TVar ID ${v.id} now maps to user var "$userVarName" (was temp "${tempVar.name}")');
                                    #end
                                    #end
                                }

                                // If we have an EnumBindingPlan, these assignments are redundant
                                // because the pattern already uses the correct names
                                if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan != null) {
                                    #if debug_enum_extraction
                                    #if debug_ast_builder
                                    trace('[TVar] Skipping redundant temp assignment ${v.name} = ${tempVar.name} - binding plan handles it');
                                    #end
                                    #end
                                    return null; // Skip this assignment entirely
                                }

                                // Create mapping from temp var ID to pattern var ID
                                if (tempToBinderMap == null) {
                                    tempToBinderMap = new Map<Int, Int>();
                                }
                                tempToBinderMap.set(tempVar.id, v.id);

                                #if debug_variable_origin
                                #if debug_ast_builder
                                trace('[Variable Origin] Pattern assignment from temp:');
                                #end
                                #if debug_ast_builder
                                trace('  - Pattern var: ${v.name} (id=${v.id})');
                                #end
                                #if debug_ast_builder
                                trace('  - Temp var: ${tempVar.name} (id=${tempVar.id})');
                                #end
                                #if debug_ast_builder
                                trace('  - Origin: PatternBinder');
                                #end
                                #if debug_ast_builder
                                trace('  - Mapping: ${tempVar.id} -> ${v.id}');
                                #end
                                #end

                                // Within a case clause, pattern already binds the variable.
                                // Skip emitting temp‚Üíbinder assignment to avoid `lhs = _g*` in case arms.
                                if (currentContext.currentClauseContext != null) {
                                    #if debug_ast_builder
                                    trace('[TVar] Skipping temp‚Üíbinder assignment inside case clause: ' + v.name + ' = ' + tempVar.name);
                                    #end
                                    return null;
                                }

                            } else {
                                // Regular local assignment, check if the source is a pattern variable
                                // from an enum constructor (like RGB(r, g, b))
                                varOrigin = UserDefined;

                                #if debug_variable_origin
                                #if debug_ast_builder
                                trace('[Variable Origin] Regular local assignment:');
                                #end
                                #if debug_ast_builder
                                trace('  - Variable: ${v.name} (id=${v.id})');
                                #end
                                #if debug_ast_builder
                                trace('  - From: ${tempVar.name}');
                                #end
                                #if debug_ast_builder
                                trace('  - Origin: UserDefined');
                                #end
                                #end
                            }

                        case TSwitch(switchExpr, cases, edef):
                            #if debug_ast_builder
                            trace('[TSwitch] Switch expression detected in TVar init - delegating to SwitchBuilder');
                            trace('[TSwitch]   Switch has ${cases.length} cases');
                            trace('[TSwitch]   Has default: ${edef != null}');
                            #end
                            
                            // EverythingIsExprSanitizer lifts switch expressions to temp vars
                            // We need to properly build the switch expression here
                            varOrigin = UserDefined;

                            #if debug_everythingisexpr
                            trace('[TVar] Switch expression lifted by EverythingIsExprSanitizer detected');
                            trace('[TVar] Variable: ${v.name} will hold switch result');
                            trace('[TVar] Building proper case expression using SwitchBuilder');
                            #end

                            // CRITICAL FIX: Delegate to SwitchBuilder for proper handling
                            // Without this, the switch body is lost and only "value" appears
                            // This handles cases like unwrapOr where EverythingIsExprSanitizer lifts the switch

                        case _:
                            varOrigin = UserDefined;  // Default for other cases
                    }
                }
                
                // DON'T rename underscore variables in TVar - keep them as-is
                // The underscore indicates they are compiler-generated temporaries
                // and should be preserved to maintain consistency
                var varName = v.name;
                var idKey = Std.string(v.id);
                
                // Don't trust Reflaxe's unused metadata for TVar declarations
                // It's often incorrect for variables used in complex expressions
                //
                // EXAMPLE: In BalancedTree.balance(), variables like this:
                //   var k = match.k;  // TVar declaration, marked as -reflaxe.unused
                //   var v = match.v;  // TVar declaration, marked as -reflaxe.unused
                //   return new Node(k, v, left, right);  // Used here in TNew!
                //
                // The variables ARE used in the Node constructor call, but Reflaxe's
                // MarkUnusedVariablesImpl only detects TLocal references, missing TNew usage.
                // This causes incorrect underscore prefixing (_k, _v) while references
                // remain as (k, v), resulting in undefined variable errors.
                //
                // SOLUTION: We need the full function body context to properly detect usage,
                // which we don't have at TVar declaration time. That's why we handle this
                // in TFunction (lines 1100+) where we have access to the complete body
                // and can use our UsageDetector to accurately determine unused parameters.
                //
                var isUnused = false; // Disabled - proper detection happens at function level
                
                // For renamed temp variables, use the name directly without further conversion
                // Otherwise apply toElixirVarName for CamelCase conversion
                var baseName = if (currentContext.tempVarRenameMap.exists(idKey)) {
                    currentContext.tempVarRenameMap.get(idKey); // Use mapped name
                } else {
                    // Check if we have usage information from VariableUsageAnalyzer
                    var isUsed = if (currentContext.variableUsageMap != null) {
                        currentContext.variableUsageMap.exists(v.id) && currentContext.variableUsageMap.get(v.id);
                    } else {
                        true; // Conservative default: assume used if no usage map
                    };
                    
                    // For _g variables from Haxe, always strip the underscore
                    // Haxe generates _g, _g1, etc. for temporaries but in Elixir we want g, g1
                    // This keeps the names consistent between declaration and reference
                    if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
                        // Always strip underscore from _g variables for consistency
                        VariableAnalyzer.toElixirVarName(varName, false); // false = strip underscore
                    } else {
                        // For non-_g variables, normal conversion
                        VariableAnalyzer.toElixirVarName(varName, false);
                    }
                };
                
                // ARCHITECTURAL FIX (January 2025): Remove premature underscore prefixing
                //
                // PROBLEM: The builder was making renaming decisions BEFORE usage analysis ran.
                // This caused:
                // 1. TVar registers "changeset -> _changeset" prematurely
                // 2. TLocal can't find "changeset" (stored as "_changeset")
                // 3. HygieneTransforms sees "_changeset" and marks IT as unused
                // 4. Result: "_changeset = user" then "changeset" (undefined variable!)
                //
                // SOLUTION: Builder phase should ONLY build AST nodes, NOT transform them.
                // Let HygieneTransforms (transformer phase) handle ALL renaming decisions.
                //
                // The builder's job: Convert TypedExpr ‚Üí ElixirAST faithfully
                // The transformer's job: Analyze usage and apply underscore prefixes
                //
                // See: /docs/03-compiler-development/HYGIENE_TRANSFORM_TLOCAL_BUG.md

                var finalVarName = baseName;  // Just use the snake_case converted name

                #if debug_hygiene
                trace('[Hygiene] TVar built faithfully: id=${v.id} name=${v.name} -> $finalVarName (no premature underscore)');
                #end

                // Handle variable initialization
                var matchNode = if (init != null) {
                    #if debug_everythingisexpr
                    #if debug_ast_builder
                    trace('[TVar init] Processing init for ${v.name}, type: ${Type.enumConstructor(init.expr)}');
                    #end

                    // Check if this looks like a lifted switch (static methods returning switches often get this pattern)
                    if (v.name.startsWith("_g") || v.name == "temp_result" || v.name.contains("result")) {
                        #if debug_ast_builder
                        trace('[TVar init] Possible lifted switch variable: ${v.name}');
                        #end

                        // Log what we actually have
                        switch(init.expr) {
                            case TLocal(localVar):
                                #if debug_ast_builder
                                trace('[TVar init]   Init is TLocal: ${localVar.name}');
                                #end
                                // This is the problem - EverythingIsExprSanitizer replaced the switch with just a local reference
                            case TBlock(exprs):
                                #if debug_ast_builder
                                trace('[TVar init]   Init is TBlock with ${exprs.length} expressions');
                                #end
                                for (i in 0...exprs.length) {
                                    #if debug_ast_builder
                                    trace('[TVar init]     Expr[$i]: ${Type.enumConstructor(exprs[i].expr)}');
                                    #end
                                }
                            case TSwitch(e, cases, edef):
                                #if debug_ast_builder
                                trace('[TVar init]   TSwitch detected with ${cases.length} cases, default: ${edef != null}');
                                #end
                            default:
                                #if debug_ast_builder
                                trace('[TVar init]   Other type: ${Type.enumConstructor(init.expr)}');
                                #end
                        }
                    }
                    #end

                    // Check if init is a TBlock with null coalescing pattern
                    var initValue = switch(init.expr) {
                        case TBlock([{expr: TVar(tmpVar, tmpInit)}, {expr: TBinop(OpNullCoal, {expr: TLocal(localVar)}, defaultExpr)}])
                            if (localVar.id == tmpVar.id && tmpInit != null):
                            // This is null coalescing pattern: generate inline if expression
                            var tmpVarName = VariableAnalyzer.toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
                            var initAst = buildFromTypedExpr(tmpInit, currentContext);
                            var defaultAst = buildFromTypedExpr(defaultExpr, currentContext);
                            
                            // Generate: if (tmp = init) != nil, do: tmp, else: default
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, 
                                    makeAST(EMatch(PVar(tmpVarName), initAst)),
                                    makeAST(ENil)
                                )),
                                makeAST(EVar(tmpVarName)),
                                defaultAst
                            ));
                            // Mark as inline for null coalescing
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            ifExpr;
                            
                        case _:
                            // Check if init is an unrolled array comprehension pattern
                            // Pattern: TBlock containing "g = []" followed by "g = g ++ [value]" statements
                            var initExpr = switch(init.expr) {
                                case TBlock(stmts) if (stmts.length > 2):
                                    #if debug_array_patterns
                                    #if debug_ast_builder
                                    trace('[XRay ArrayPattern] Checking TBlock with ${stmts.length} statements for unrolled comprehension');
                                    #end
                                    for (i in 0...stmts.length) {
                                        #if debug_ast_builder
                                        trace('[XRay ArrayPattern]   stmt[$i]: ${Type.enumConstructor(stmts[i].expr)}');
                                        #end
                                        // Check if stmt[1] is a nested TBlock
                                        if (i == 1) {
                                            switch(stmts[i].expr) {
                                                case TBlock(innerStmts):
                                                    #if debug_ast_builder
                                                    trace('[XRay ArrayPattern]     stmt[1] is a TBlock with ${innerStmts.length} inner statements');
                                                    #end
                                                    for (j in 0...Std.int(Math.min(3, innerStmts.length))) {
                                                        #if debug_ast_builder
                                                        trace('[XRay ArrayPattern]       inner[$j]: ${Type.enumConstructor(innerStmts[j].expr)}');
                                                        #end
                                                    }
                                                default:
                                            }
                                        }
                                    }
                                    #end
                                    
                                    // Check for unrolled comprehension pattern:
                                    // 1. First stmt: var g = []
                                    // 2. Middle stmts: g = g ++ [value]
                                    // 3. Last stmt: g (return the temp var)
                                    var isUnrolled = false;
                                    var tempVarName = "";
                                    var values = [];
                                    
                                    // Check first statement
                                    if (stmts.length > 0) {
                                        switch(stmts[0].expr) {
                                            case TVar(v, initExpr) if (initExpr != null && (v.name.startsWith("g") || v.name.startsWith("_g"))):
                                                #if debug_array_patterns
                                                #if debug_ast_builder
                                                trace('[XRay ArrayPattern] Found TVar for ${v.name}, checking init type: ${initExpr != null ? Type.enumConstructor(initExpr.expr) : "null"}');
                                                #end
                                                #end
                                                switch(initExpr.expr) {
                                                    case TArrayDecl([]):
                                                        isUnrolled = true;
                                                        tempVarName = v.name;
                                                        #if debug_array_patterns
                                                        #if debug_ast_builder
                                                        trace('[XRay ArrayPattern] First statement matches: var ${v.name} = []');
                                                        #end
                                                        #end
                                                    default:
                                                        #if debug_array_patterns
                                                        #if debug_ast_builder
                                                        trace('[XRay ArrayPattern] First statement init is not empty array');
                                                        #end
                                                        #end
                                                }
                                            default:
                                                #if debug_array_patterns
                                                #if debug_ast_builder
                                                trace('[XRay ArrayPattern] First statement is not a TVar with g-prefix');
                                                #end
                                                #end
                                        }
                                    }
                                    
                                    // If first statement matches, check for concatenations
                                    // Note: The concatenations might be in a nested TBlock at position 1
                                    if (isUnrolled && stmts.length > 1) {
                                        var concatStatements = [];
                                        
                                        // Check if stmt[1] is a nested TBlock
                                        switch(stmts[1].expr) {
                                            case TBlock(innerStmts):
                                                // Concatenations are inside this nested block
                                                concatStatements = innerStmts;
                                            default:
                                                // Concatenations are directly in the main block
                                                concatStatements = [for (i in 1...stmts.length - 1) stmts[i]];
                                        }
                                        
                                        // Now check all concatenation/push statements
                                        for (stmt in concatStatements) {
                                            switch(stmt.expr) {
                                                // Pattern 1: g = g ++ [value]
                                                case TBinop(OpAssign, {expr: TLocal(v)}, {expr: TBinop(OpAdd, {expr: TLocal(v2)}, {expr: TArrayDecl([elem])})})
                                                    if (v.name == tempVarName && v2.name == tempVarName):
                                                    // Found concatenation: g = g ++ [value]
                                                    values.push(elem);
                                                    
                                                // Pattern 2: g.push(value) - this is what Haxe generates for constant ranges
                                                case TCall({expr: TField({expr: TLocal(v)}, FInstance(_, _, cf))}, [arg])
                                                    if (v.name == tempVarName && cf.get().name == "push"):
                                                    // Found push: g.push(value)
                                                    values.push(arg);
                                                    
                                                default:
                                                    // Not a concatenation or push, continue
                                            }
                                        }
                                        
                                        // If we found no values, it's not an unrolled comprehension
                                        if (values.length == 0) {
                                            isUnrolled = false;
                                        }
                                    }
                                    
                                    // Check last statement returns the temp var
                                    if (isUnrolled && stmts.length > 0) {
                                        switch(stmts[stmts.length - 1].expr) {
                                            case TLocal(v) if (v.name == tempVarName):
                                                // Valid pattern
                                            default:
                                                isUnrolled = false;
                                        }
                                    }
                                    
                                    if (isUnrolled && values.length > 0) {
                                        #if debug_array_patterns
                                        #if debug_ast_builder
                                        trace('[XRay ArrayPattern] TVar init detected as unrolled comprehension with ${values.length} values');
                                        #end
                                        #end
                                        
                                        // Build a proper list from the extracted values
                                        var valueASTs = [for (v in values) buildFromTypedExpr(v, currentContext)];
                                        makeAST(EList(valueASTs));
                                    } else {
                                        // Not an unrolled comprehension, build normally
                                        buildFromTypedExpr(init, currentContext);
                                    }
                                    
                                case TSwitch(_, _, _):
                                    // Special handling for switch expressions lifted by EverythingIsExprSanitizer
                                    // These need to be built as complete case expressions
                                    #if debug_everythingisexpr
                                    #if debug_ast_builder
                                    trace('[TVar init] Building TSwitch expression for ${v.name}');
                                    #end
                                    #end

                                    // Build the switch expression directly
                                    var switchAST = buildFromTypedExpr(init, currentContext);

                                    #if debug_everythingisexpr
                                    if (switchAST != null) {
                                        #if debug_ast_builder
                                        trace('[TVar init] Switch AST generated successfully');
                                        #end
                                    } else {
                                        #if debug_ast_builder
                                        trace('[TVar init] WARNING: Switch AST is null!');
                                        #end
                                    }
                                    #end

                                    switchAST;

                                default:
                                    // Regular init expression
                                    buildFromTypedExpr(init, currentContext);
                            };

                            initExpr;
                    };
                    
                    // Check if we should skip this assignment
                    // Following Codex's architecture guidance: use ID-based tracking
                    var shouldSkipAssignment = false;

                    // ID-BASED TRACKING: Check if this TVar ID is satisfied by pattern extraction
                    if (init != null && currentContext.currentClauseContext != null &&
                        currentContext.currentClauseContext.isVarIdSatisfiedByPattern(v.id)) {

                        // This variable is already extracted by the pattern - skip redundant assignment
                        shouldSkipAssignment = true;

                        #if debug_redundant_extraction
                        #if debug_ast_builder
                        trace('[TVar] ID-based detection: Skipping assignment for TVar ${v.id} (${v.name}) - already satisfied by pattern');
                        #end
                        #end
                    } else if (init != null) {
                        // Fallback: Check for self-assignments that would be problematic
                        switch(init.expr) {
                            case TEnumParameter(e, ef, index):
                                // CRITICAL: Check what TEnumParameter would return BEFORE building it
                                // This avoids creating g = g assignments
                                if (currentContext.currentClauseContext != null) {
                                    var hasPlan = currentContext.currentClauseContext.enumBindingPlan.exists(index);

                                    if (hasPlan) {
                                        var info = currentContext.currentClauseContext.enumBindingPlan.get(index);

                                        if (info.finalName == finalVarName) {
                                            // This would create g = g
                                            shouldSkipAssignment = true;
                                        } else {
                                            // Fall through to check initValue
                                        }

                                        if (!shouldSkipAssignment && info.finalName != null && info.finalName.length > 0) {
                                            var planIsTemp = PatternDetector.isTempPatternVarName(info.finalName);
                                            var lhsIsTemp = PatternDetector.isTempPatternVarName(finalVarName);
                                            if (lhsIsTemp && !planIsTemp) {
                                                shouldSkipAssignment = true;
                                            }
                                        }
                                    }
                                }

                                // Fallback: check the already-built initValue
                                if (!shouldSkipAssignment && initValue != null) {
                                    switch(initValue.def) {
                                        case EVar(varName):
                                            if (varName == finalVarName) {
                                                // This would create a self-assignment like "g = g"
                                                shouldSkipAssignment = true;
                                                #if debug_enum_extraction
                                                #if debug_ast_builder
                                                trace('[TVar] Skipping self-assignment from TEnumParameter: $finalVarName = $varName');
                                                #end
                                                #end
                                            }
                                        case _:
                                            // Normal extraction, keep it
                                            #if debug_enum_extraction
                                            #if debug_ast_builder
                                            trace('[TVar] Keeping TEnumParameter extraction: $finalVarName');
                                            #end
                                            #end
                                    }
                                } else if (!shouldSkipAssignment) {
                                    // TEnumParameter already returned null, skip the assignment
                                    shouldSkipAssignment = true;
                                    #if debug_enum_extraction
                                    #if debug_ast_builder
                                    trace('[TVar] Skipping TEnumParameter assignment - initValue is null');
                                    #end
                                    #end
                                    return null;  // ‚úÖ FIX: Immediate return prevents fallthrough to error code
                                }
                            default:
                        }

                        // Fallback TLocal handling (separate from enum-specific logic above)
                        if (!shouldSkipAssignment && init != null) {
                            switch(init.expr) {
                                case TLocal(tempVar):
                                var tempVarName = tempVar.name;

                                #if debug_ast_builder
                                trace('[DEBUG EMBEDDED] Checking assignment: $finalVarName = $tempVarName');
                                #end
                                #if debug_ast_builder
                                trace('[DEBUG EMBEDDED] Is in case clause: ${currentContext.currentClauseContext != null}');
                                #end
                                #if debug_enum_extraction
                                #if debug_ast_builder
                                trace('[TVar TLocal] Checking assignment: $finalVarName = $tempVarName');
                                #end
                                #if debug_ast_builder
                                trace('[TVar TLocal] Is in case clause: ${currentContext.currentClauseContext != null}');
                                #end
                                #end

                                // FIX: When patterns use canonical names, assignments from temp vars that don't exist
                                // should be skipped entirely. The pattern already binds the correct variable.
                                // Example: pattern {:ok, value} already binds value, so "value = g" is wrong (g doesn't exist)
                                // Handle both bare "g" patterns and underscore-prefixed "_g" patterns
                                var isTempVar = false;
                                if (tempVarName == "g" || tempVarName == "_g") {
                                    isTempVar = true;
                                } else if (tempVarName.length > 1) {
                                    // Check for g1, g2, etc. OR _g1, _g2, etc.
                                    if (tempVarName.charAt(0) == "g" && tempVarName.charAt(1) >= '0' && tempVarName.charAt(1) <= '9') {
                                        isTempVar = true;
                                    } else if (tempVarName.length > 2 && tempVarName.charAt(0) == "_" &&
                                               tempVarName.charAt(1) == "g" && tempVarName.charAt(2) >= '0' && tempVarName.charAt(2) <= '9') {
                                        isTempVar = true;
                                    }
                                }

                                #if debug_ast_builder
                                trace('[DEBUG EMBEDDED] Temp analysis -> tempVar? $isTempVar, lhsTemp? ${PatternDetector.isTempPatternVarName(finalVarName)}');
                                #end

                                #if debug_enum_extraction
                                #if debug_ast_builder
                                trace('[TVar TLocal] Is temp var: $isTempVar');
                                #end
                                #end

                                if (isTempVar) {
                                    // This is trying to assign from a temp var (g, g1, g2, _g, _g1, _g2, etc.)
                                    // Check if we're assigning to a variable that was already bound by the pattern
                                    var elixirTempName = VariableAnalyzer.toElixirVarName(tempVarName);

                                    // EMBEDDED SWITCH FIX: Skip assignments where pattern already extracted the value
                                    // Pattern {:some, action} already binds "action", so "action = g" is invalid
                                    if (elixirTempName == "g" ||
                                        (elixirTempName.charAt(0) == "g" && elixirTempName.length > 1 &&
                                         elixirTempName.charAt(1) >= '0' && elixirTempName.charAt(1) <= '9')) {
                                        shouldSkipAssignment = true;
                                        #if debug_ast_builder
                                        trace('[DEBUG EMBEDDED] WILL SKIP: $finalVarName = $elixirTempName');
                                        #end
                                        #if debug_enum_extraction
                                        #if debug_ast_builder
                                        trace('[TVar TLocal] EMBEDDED SWITCH FIX: Skipping invalid temp var assignment: $finalVarName = $elixirTempName');
                                        #end
                                        #end
                                    }

                                    // Additional check: Skip redundant self-assignments like "value = value"
                                    if (finalVarName == tempVarName) {
                                        shouldSkipAssignment = true;
                                        #if debug_enum_extraction
                                        #if debug_ast_builder
                                        trace('[TVar] Skipping redundant self-assignment: $finalVarName = $tempVarName');
                                        #end
                                        #end
                                    }
                                } else {
                                    // Check if this is a non-temp var assignment that creates redundancy
                                    // For example, when pattern uses canonical names and we try to assign from them
                                    if (finalVarName == tempVarName) {
                                        // Skip self-assignments like "value = value"
                                        shouldSkipAssignment = true;
                                        #if debug_enum_extraction
                                        #if debug_ast_builder
                                        trace('[TVar] Skipping redundant self-assignment: $finalVarName = $tempVarName');
                                        #end
                                        #end
                                    }
                                }
                                case _:
                                    // Other init expressions
                            }
                        }
                    }

                    // Note: Redundant enum extraction is now handled at TBlock level
                    // We generate the assignment here, but TBlock will filter it out if redundant
                    #if debug_ast_builder
                    trace('[DEBUG TVar] Final decision for ${finalVarName}: shouldSkipAssignment=${shouldSkipAssignment}');
                    #end
                    var result = if (shouldSkipAssignment) {
                        // Skip the assignment, return null to be filtered out by TBlock
                        // The TBlock handler at line 3036 filters out null expressions
                        null;
                    } else if (initValue == null) {
                        // If initValue is null (e.g., from skipped TEnumParameter or failed TCall), handle carefully
                        #if debug_ast_builder
                        trace('[DEBUG EMBEDDED TVar] WARNING: initValue is null for: $finalVarName (extractedFromTemp: $extractedFromTemp)');
                        trace('[TVar] This will cause undefined variable errors in generated code!');
                        #end
                        
                        // CRITICAL FIX: When initialization expression fails to build (returns null),
                        // we need to provide a fallback value to prevent undefined variables in the generated code.
                        // This typically happens with complex expressions like TodoPubSub.subscribe(TodoUpdates)
                        // that fail to build in certain contexts.
                        // 
                        // Generate a descriptive error value that will make the issue visible
                        // rather than silently producing broken code with undefined variables.
                        var fallbackValue = makeAST(ERaw('{:error, "[Compiler Error] Failed to build initialization for ' + finalVarName + '"}'));
                        
                        #if debug_ast_builder
                        trace('[TVar] Using fallback error tuple for null initValue to prevent undefined variable');
                        #end
                        
                        // Create the assignment with the fallback value
                        var matchNode = makeAST(EMatch(
                            PVar(finalVarName),
                            fallbackValue
                        ));
                        
                        // Add metadata to indicate this is a fallback
                        if (matchNode.metadata == null) matchNode.metadata = {};
                        // Using requiresTempVar to indicate special handling (isFallbackInit field doesn't exist)
                        matchNode.metadata.requiresTempVar = true;
                        matchNode.metadata.varOrigin = varOrigin;
                        matchNode.metadata.varId = v.id;
                        
                        // But if this was supposed to be an assignment from a temp var, we have a problem!
                        if (extractedFromTemp != null) {
                            #if debug_ast_builder
                            trace('[DEBUG g=g] ERROR: initValue is null but we need assignment from temp var $extractedFromTemp to $finalVarName');
                            #end
                        }
                        
                        matchNode;
                    } else {
                        // Check for self-assignment right before creating the match node
                        var shouldSkipSelfAssignment = false;
                        #if debug_ast_builder
                        trace('[DEBUG TVar Assignment] Checking assignment: $finalVarName = ${initValue.def}');
                        #end
                        switch(initValue.def) {
                            case EVar(varName):
                                #if debug_ast_builder
                                trace('[DEBUG TVar Assignment] Comparing: finalVarName="$finalVarName" vs varName="$varName"');
                                #end
                                if (varName == finalVarName) {
                                    // This is a self-assignment like "g = g" or "content = content"
                                    shouldSkipSelfAssignment = true;
                                    #if debug_ast_builder
                                    trace('[DEBUG TVar Assignment] SKIPPING self-assignment: $finalVarName = $varName');
                                    #end
                                }
                            case _:
                                #if debug_ast_builder
                                trace('[DEBUG TVar Assignment] Not a var assignment: ${initValue.def}');
                                #end
                                // Normal assignment
                        }

                        if (shouldSkipSelfAssignment) {
                            null;  // Skip self-assignments
                        } else {
                            var matchNode = makeAST(EMatch(
                            PVar(finalVarName),
                            initValue
                        ));

                        // Add variable origin metadata for use in transformer and printer phases
                        if (matchNode.metadata == null) matchNode.metadata = {};
                        matchNode.metadata.varOrigin = varOrigin;
                        matchNode.metadata.varId = v.id;
                        if (tempToBinderMap != null) {
                            matchNode.metadata.tempToBinderMap = tempToBinderMap;
                        }

                        #if debug_variable_origin
                        #if debug_ast_builder
                        trace('[Variable Origin] Added metadata to match node:');
                        #end
                        #if debug_ast_builder
                        trace('  - Variable: $finalVarName');
                        #end
                        #if debug_ast_builder
                        trace('  - Origin: $varOrigin');
                        #end
                        #if debug_ast_builder
                        trace('  - ID: ${v.id}');
                        #end
                        if (tempToBinderMap != null) {
                            #if debug_ast_builder
                            trace('  - Mappings: $tempToBinderMap');
                            #end
                        }
                        #end

                        matchNode;
                        }  // end shouldSkipSelfAssignment check
                    };
                    result;
                } else {
                    // Uninitialized variable - use nil
                    makeAST(EMatch(
                        PVar(finalVarName),
                        makeAST(ENil)
                    ));
                };
                if (matchNode != null) {
                    matchNode.def;  // Return the ElixirASTDef for TVar case  
                } else {
                    // Handle uninitialized variable declaration
                    EMatch(PVar(finalVarName), makeAST(ENil));
                }
                
            // ================================================================
            // Binary Operations
            // ================================================================
            case TBinop(op, e1, e2):
                // Handle assignments specially since they need pattern extraction
                var result = switch(op) {
                    case OpAssign:
                        // Assignment needs pattern extraction for the left side
                        // SPECIAL: Map/struct-like field assignment on a local variable
                        // params.userId = value -> params = Map.put(params, "user_id", value)
                        var isLocalFieldAssign = false;
                        var baseLocalName: Null<String> = null;
                        var fieldNameForPut: Null<String> = null;
                        var baseIsSchemaStruct: Bool = false;
                        switch (e1.expr) {
                            case TField(baseExpr, fa):
                                switch (baseExpr.expr) {
                                    case TLocal(v):
                                        var baseVarName = ElixirASTHelpers.toElixirVarName(v.name);
                                        // Avoid transforming instance field (this/_this)
                                        if (baseVarName != "this" && baseVarName != "_this") {
                                            isLocalFieldAssign = true;
                                            baseLocalName = baseVarName;
                                            // Extract field name from FieldAccess
                                            var rawFieldName = switch (fa) {
                                                case FInstance(_, _, cf): cf.get().name;
                                                case FStatic(_, cf): cf.get().name;
                                                case FAnon(cf): cf.get().name;
                                                case FClosure(_, cf): cf.get().name;
                                                case FEnum(_, ef): ef.name;
                                                case FDynamic(s): s;
                                            };
                                            fieldNameForPut = reflaxe.elixir.ast.NameUtils.toSnakeCase(rawFieldName);
                                            // Detect when base is an Ecto schema struct to prefer struct update syntax
                                            baseIsSchemaStruct = switch (baseExpr.t) {
                                                case TInst(c, _):
                                                    var ct = c.get();
                                                    ct != null && ct.meta != null && ct.meta.has("schema");
                                                default: false;
                                            };
                                        }
                                    default:
                                }
                            default:
                        }

                        var pattern = (isLocalFieldAssign && baseLocalName != null)
                            ? PVar(baseLocalName)
                            : PatternBuilder.extractPattern(e1);

                        // Flatten nested underscore assignment: x = _ = expr ‚Üí x = expr
                        var rightIsUnderscoreAssign = false;
                        var flattenedRight: Null<TypedExpr> = null;
                        switch (e2.expr) {
                            case TBinop(OpAssign, innerLhs, innerRhs):
                                switch (innerLhs.expr) {
                                    case TLocal(v) if (v.name == "_"):
                                        rightIsUnderscoreAssign = true;
                                        flattenedRight = innerRhs;
                                    default:
                                }
                            default:
                        }

                        var rightAST = if (isLocalFieldAssign && baseLocalName != null && fieldNameForPut != null) {
                            // Prefer struct update syntax when assigning a field on a schema struct;
                            // otherwise, fall back to Map.put on maps.
                            var valueAST = buildFromTypedExpr(rightIsUnderscoreAssign && flattenedRight != null ? flattenedRight : e2, currentContext);
                            if (baseIsSchemaStruct) {
                                // %{base | field: value}
                                makeAST(EStructUpdate(
                                    makeAST(EVar(baseLocalName)),
                                    [{ key: fieldNameForPut, value: valueAST }]
                                ));
                            } else {
                                // Map.put(base, "field", value)
                                makeAST(ERemoteCall(
                                    makeAST(EVar("Map")),
                                    "put",
                                    [
                                        makeAST(EVar(baseLocalName)),
                                        makeAST(EString(fieldNameForPut)),
                                        valueAST
                                    ]
                                ));
                            }
                        } else if (rightIsUnderscoreAssign && flattenedRight != null) {
                            buildFromTypedExpr(flattenedRight, currentContext);
                        } else {
                            buildFromTypedExpr(e2, currentContext);
                        }
                        var shouldSkipAssign = false;
                        switch(pattern) {
                            case PVar(name):
                                var valueName = switch(rightAST != null ? rightAST.def : null) {
                                    case EVar(varName): varName;
                                    default: null;
                                };

                                if (PatternDetector.isTempPatternVarName(name)) {
                                    shouldSkipAssign = switch(rightAST != null ? rightAST.def : null) {
                                        case EVar(varName) if (varName == name || PatternDetector.isTempPatternVarName(varName)):
                                            true;
                                        default:
                                            false;
                                    };
                                } else if (valueName != null) {
                                    if (valueName == name) {
                                        shouldSkipAssign = true;
                                    } else if (PatternDetector.isTempPatternVarName(valueName)) {
                                        shouldSkipAssign = true;
                                    }
                                }
                            default:
                        }

                        if (shouldSkipAssign) {
                            null;
                        } else {
                            // Build a match node so we can attach metadata (varId) for binder retention
                            var matchNode = makeAST(EMatch(pattern, rightAST));
                            // Attach varId when left is a local variable (or base when rewriting field assign)
                            switch (e1.expr) {
                                case TLocal(v):
                                    if (matchNode.metadata == null) matchNode.metadata = {};
                                    matchNode.metadata.varId = v.id;
                                case TField(baseExpr, _):
                                    switch (baseExpr.expr) {
                                        case TLocal(v2):
                                            if (matchNode.metadata == null) matchNode.metadata = {};
                                            matchNode.metadata.varId = v2.id;
                                        default:
                                    }
                                default:
                            }
                            matchNode.def;
                        }

                    case OpAssignOp(innerOp):
                        // Compound assignment: x += 1 becomes x = x + 1
                        var pattern = PatternBuilder.extractPattern(e1);
                        var leftAST = buildFromTypedExpr(e1, currentContext);
                        var rightAST = buildFromTypedExpr(e2, currentContext);

                        // Build the inner binary operation
                        var innerBinop = BinaryOpBuilder.buildBinopFromAST(
                            innerOp, leftAST, rightAST,
                            e1, e2,
                            function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s)
                        );
                        EMatch(pattern, innerBinop);

                    default:
                        // Regular binary operations
                        var leftAST = buildFromTypedExpr(e1, currentContext);
                        var rightAST = buildFromTypedExpr(e2, currentContext);

                        // Pass pre-built ASTs to BinaryOpBuilder
                        var ast = BinaryOpBuilder.buildBinopFromAST(
                            op, leftAST, rightAST,
                            e1, e2,  // Keep original exprs for type checking
                            function(s) return reflaxe.elixir.ast.NameUtils.toSnakeCase(s)
                        );
                        ast.def;
                };
                result;

            // ================================================================
            // Unary Operations
            // ================================================================
            case TUnop(op, postFix, e):
                // Special handling for OpNot with TBlock
                // This happens when Haxe desugars complex expressions like !map.exists(key)
                switch(op) {
                    case OpNot:
                        switch(e.expr) {
                            case TBlock([]):
                                // Empty block - just return not(nil)
                                EUnary(Not, makeAST(ENil));
                            case TBlock(exprs) if (exprs.length == 1):
                                // Single expression block - unwrap it
                                EUnary(Not, buildFromTypedExpr(exprs[0], currentContext));
                            case TBlock(exprs):
                                // Multiple expressions - this is the problematic case
                                // Extract all but the last expression as statements
                                var statements = [];
                                for (i in 0...exprs.length - 1) {
                                    statements.push(buildFromTypedExpr(exprs[i], currentContext));
                                }
                                // Apply not to the last expression
                                var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], currentContext);
                                statements.push(makeAST(EUnary(Not, lastExpr)));
                                // Return a block with statements
                                EBlock(statements);
                            default:
                                // Normal case - just apply not
                                var expr = buildFromTypedExpr(e, currentContext).def;
                                EUnary(Not, makeAST(expr));
                        }
                    case OpNeg: 
                        var expr = buildFromTypedExpr(e, currentContext).def;
                        EUnary(Negate, makeAST(expr));
                    case OpNegBits:
                        var expr = buildFromTypedExpr(e, currentContext).def;
                        EUnary(BitwiseNot, makeAST(expr));
                    case OpIncrement, OpDecrement:
                        // Elixir is immutable, so we need to handle increment/decrement carefully
                        // Pre-increment (++x): returns the incremented value
                        // Post-increment (x++): returns the original value (not supported in Elixir)
                        var one = makeAST(EInteger(1));
                        var builtExpr = buildFromTypedExpr(e, currentContext);
                        
                        if (!postFix) {
                            // Pre-increment/decrement: just return the computed value
                            // When used in TVar(i, TUnop(OpIncrement, g)), this becomes: i = g + 1
                            var operation = if (op == OpIncrement) {
                                EBinary(Add, builtExpr, one);
                            } else {
                                EBinary(Subtract, builtExpr, one);
                            };
                            operation;
                        } else {
                            // Post-increment/decrement: return the computed value
                            // When used in TVar context, let TVar handle the assignment
                            // This avoids double assignment like "i = g = g + 1"
                            var operation = if (op == OpIncrement) {
                                EBinary(Add, builtExpr, one);
                            } else {
                                EBinary(Subtract, builtExpr, one);
                            };
                            operation;
                        };
                    case OpSpread:
                        // Spread operator for destructuring
                        var builtExpr = buildFromTypedExpr(e, currentContext);
                        EUnquoteSplicing(builtExpr);
                }
                
            // ================================================================
            // Function Calls
            // ================================================================
            case TCall(e, el):
                // Delegated to CallExprBuilder for modularization
                CallExprBuilder.buildCall(e, el, currentContext);

            // ================================================================
            // Field Access
            // ================================================================
            case TField(e, fa):
                // Delegate simple field access to FieldAccessBuilder
                // But keep complex cases (ExUnit test context) here for now
                
                // Check if this is a simple case we can delegate
                var isSimpleCase = switch(fa) {
                    case FEnum(_, _): true;  // Enum constructors - delegate
                    case FStatic(_, _): !currentContext.isInExUnitTest;  // Static fields - delegate unless in test
                    case FAnon(_): !currentContext.isInExUnitTest;  // Anonymous fields - delegate unless in test  
                    case FInstance(_, _, _): !currentContext.isInExUnitTest;  // Instance fields - delegate unless in test
                    case FDynamic(_): true;  // Dynamic fields - delegate
                    case FClosure(_, _): true;  // Closures - delegate
                };
                
                if (isSimpleCase) {
                    var result = FieldAccessBuilder.build(e, fa, currentContext);
                    if (result != null) {
                        result;  // Return delegated result
                    } else {
                        // Fallback to original implementation if builder returns null
                        switch(fa) {
                            case FEnum(enumType, ef):
                                // Enum constructor reference (no arguments)
                                // Check if this enum is marked as @:elixirIdiomatic
                                var enumT = enumType.get();
                                if (enumT.meta.has(":elixirIdiomatic")) {
                                    // For idiomatic enums, generate atoms instead of tuples
                                    // OneForOne ‚Üí :one_for_one
                                    var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
                                    EAtom(atomName);
                                } else {
                                    // Regular enums: check if constructor has parameters
                                    // Simple constructors (no params) ‚Üí :atom
                                    // Parameterized constructors ‚Üí {:atom}
                                    
                                    // Check if the enum constructor has parameters
                                    var hasParameters = switch(ef.type) {
                                        case TFun(args, _): args.length > 0;
                                        default: false;
                                    };
                                    
                                    var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
                                    
                                    if (hasParameters) {
                                        // Parameterized constructor - generate tuple
                                        // RGB(r, g, b) ‚Üí {:rgb}  (parameters come later)
                                        ETuple([makeAST(EAtom(atomName))]);
                                    } else {
                                        // Simple constructor - generate plain atom
                                        // Red ‚Üí :red
                                        // None ‚Üí :none
                                        EAtom(atomName);
                                    }
                                }
                            default:
                                null;  // Other cases will fall through to original implementation
                        }
                    }
                } else {
                    // Complex cases (ExUnit test context) - keep original implementation
                    switch(fa) {
                    case FEnum(enumType, ef):
                        // This shouldn't happen since enum cases are simple, but keep as fallback
                        var enumT = enumType.get();
                        if (enumT.meta.has(":elixirIdiomatic")) {
                            var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
                            EAtom(atomName);
                        } else {
                            var hasParameters = switch(ef.type) {
                                case TFun(args, _): args.length > 0;
                                default: false;
                            };
                            var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
                            if (hasParameters) {
                                ETuple([makeAST(EAtom(atomName))]);
                            } else {
                                EAtom(atomName);
                            }
                        }
                    case FStatic(classRef, cf):
                        // Static field access
                        var className = classRef.get().name;
                        var fieldName = extractFieldName(fa);
                        
                        #if debug_ast_builder
                        trace('[AST TField] FStatic - className: $className, fieldName: $fieldName');
                        #if debug_ast_builder
                        trace('[AST TField] cf.get().name: ${cf.get().name}');
                        #end
                        #end
                        
                        #if debug_atom_generation
                        #if debug_ast_builder
                        trace('[Atom Debug TField] FStatic access: ${className}.${fieldName}');
                        #end
                        #end
                        
                        /**
                         * ENUM ABSTRACT WITH ATOM TYPE DETECTION
                         * 
                         * WHY: Enum abstract fields like TimeUnit.Millisecond lose their
                         * abstract type information when accessed. We need to check if
                         * the field's value should be an atom.
                         * 
                         * WHAT: Check if the field's type indicates it should be an Atom
                         * and if it has a constant string value.
                         * 
                         * HOW: 
                         * 1. Check the field's type to see if it's elixir.types.Atom
                         * 2. If it has a constant expression, extract the string value
                         * 3. Generate an EAtom instead of a field access
                         */
                        var field = cf.get();
                        var isAtomField = false;
                        
                        // Check if the field's type is elixir.types.Atom
                        // For enum abstract fields, the field type resolves to String,
                        // so we also need to check the containing class
                        switch (field.type) {
                            case TAbstract(abstractRef, _):
                                var abstractType = abstractRef.get();
                                if (abstractType.pack.join(".") == "elixir.types" && abstractType.name == "Atom") {
                                    isAtomField = true;
                                }
                            case _:
                        }
                        
                        // If not detected via field type, check the containing class
                        // This handles enum abstract fields like TimeUnit.Millisecond
                        if (!isAtomField) {
                            var classType = classRef.get();
                            #if debug_atom_generation
                            #if debug_ast_builder
                            trace('[Atom Debug TField] Checking class ${classType.name} kind: ${classType.kind}');
                            #end
                            #end
                            switch (classType.kind) {
                                case KAbstractImpl(abstractRef):
                                    // Get the abstract type definition
                                    var abstractType = abstractRef.get();
                                    #if debug_atom_generation
                                    #if debug_ast_builder
                                    trace('[Atom Debug TField] Found abstract impl: ${abstractType.name}');
                                    #end
                                    #if debug_ast_builder
                                    trace('[Atom Debug TField] Abstract type: ${abstractType.type}');
                                    #end
                                    #end
                                    // Check the underlying type of the abstract
                                    switch (abstractType.type) {
                                        case TAbstract(underlyingRef, _):
                                            var underlyingType = underlyingRef.get();
                                            #if debug_atom_generation
                                            #if debug_ast_builder
                                            trace('[Atom Debug TField] Underlying type: ${underlyingType.pack.join(".")}.${underlyingType.name}');
                                            #end
                                            #end
                                            if (underlyingType.pack.join(".") == "elixir.types" && underlyingType.name == "Atom") {
                                                isAtomField = true;
                                                #if debug_atom_generation
                                                #if debug_ast_builder
                                                trace('[Atom Debug TField] DETECTED: Field is Atom type!');
                                                #end
                                                #end
                                            }
                                        case _:
                                    }
                                case _:
                            }
                        }
                        
                        // If this is an Atom-typed field with a constant value, generate an atom
                        if (isAtomField && field.expr() != null) {
                            #if debug_atom_generation
                            #if debug_ast_builder
                            trace('[Atom Debug TField] Field has expr, extracting value...');
                            #end
                            #end
                            // Get the field's expression value
                            switch (field.expr().expr) {
                                case TConst(TString(s)):
                                    // This is the string value of the enum abstract field
                                    // Generate an atom directly
                                    #if debug_atom_generation
                                    #if debug_ast_builder
                                    trace('[Atom Debug TField] Extracted string value: "${s}" -> generating atom :${s}');
                                    #end
                                    #end
                                    EAtom(s);
                                case _:
                                    #if debug_atom_generation
                                    #if debug_ast_builder
                                    trace('[Atom Debug TField] Field expr is not TConst(TString), falling through');
                                    #end
                                    #end
                                    // Not a string constant, fall back to normal field access
                                    fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                                    var target = buildFromTypedExpr(e, currentContext);
                                    EField(target, fieldName);
                            }
                        } else {
                            #if debug_atom_generation
                            #if debug_ast_builder
                            trace('[Atom Debug TField] Not an atom field or no expr, using normal field access');
                            #end
                            #end
                            // Normal static field access
                            // Convert to snake_case for Elixir function names
                            fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                            
                            // Always use full qualification for function references
                            // When a static method is passed as a function reference (not called directly),
                            // it needs to be fully qualified even within the same module
                            if (false) { // Disabled for now - always qualify
                                // Same module - just use the function name without module prefix
                                // This allows private functions to be called without qualification
                                EVar(fieldName);
                            } else {
                                // Different module or no current module context - use full qualification
                                
                                // CRITICAL FIX: For static fields on regular (non-extern) classes,
                                // we need to generate the module name directly when the base expression
                                // is TTypeExpr. This handles cases like TodoPubSub.subscribe properly.
                                var target = if (e != null) {
                                    switch(e.expr) {
                                        case TTypeExpr(m):
                                            // Direct module reference - use the module name
                                            var moduleName = moduleTypeToString(m);
                                            makeAST(EVar(moduleName));
                                        default:
                                            // Other expressions - build normally
                                            buildFromTypedExpr(e, currentContext);
                                    }
                                } else {
                                    null;
                                };
                                
                                // If target is null, we can't generate a proper field access
                                if (target == null) {
                                    #if debug_ast_builder
                                    trace('[ERROR TField] Failed to build target for static field ${className}.${fieldName}');
                                    #end
                                    // Return a placeholder that will be caught by TCall
                                    EVar("UnknownModule." + fieldName);
                                } else {
                                    // For static fields on extern classes with @:native, we already have the full module name
                                    // in the target. Just return EField which will be handled properly by TCall
                                    // when this is used in a function call context.
                                    //
                                    // The TCall handler will detect that this is a static method call on an extern class
                                    // and will generate the proper ERemoteCall.
                                    //
                                    // Note: Function references are now handled at the TCall level
                                    // when a function is passed as an argument to another function
                                    EField(target, fieldName);
                                }
                            }
                        }
                    case FAnon(cf):
                        // Anonymous field access - check for tuple pattern
                        var fieldName = cf.get().name;
                        var target = buildFromTypedExpr(e, currentContext);
                        
                        if (~/^_\d+$/.match(fieldName)) {
                            // This is a tuple field access like tuple._1, tuple._2
                            // Convert to elem(tuple, index) where index is 0-based
                            var index = Std.parseInt(fieldName.substr(1)) - 1; // _1 -> 0, _2 -> 1
                            ECall(null, "elem", [target, makeAST(EInteger(index))]);
                        } else {
                            // Regular anonymous field access - convert to snake_case
                            fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                            EField(target, fieldName);
                        }
                    default:
                        // Regular field access (includes FInstance for instance methods)
                        var target = buildFromTypedExpr(e, currentContext);
                        var fieldName = extractFieldName(fa);
                        
                        // Convert to snake_case for Elixir method names
                        // This ensures struct.setLoop becomes struct.set_loop
                        var originalFieldName = fieldName;
                        fieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                        
                        #if debug_field_names
                        if (originalFieldName != fieldName) {
                            #if debug_ast_builder
                            trace('[AST Builder] Converting field name: $originalFieldName -> $fieldName');
                            #end
                        }
                        #end
                        
                        #if debug_ast_pipeline
                        // Debug field access on p1/p2 variables
                        switch(e.expr) {
                            case TLocal(v) if (v.name == "p1" || v.name == "p2"):
                                #if debug_ast_builder
                                trace('[AST Builder] Field access: ${v.name}.${fieldName} (id=${v.id})');
                                #end
                            default:
                        }
                        #end
                        
                        // Special handling for ExUnit test instance variable access
                        // In ExUnit tests, instance variables are accessed via the context map
                        // Transform: this.test_data -> context[:test_data]
                        if (currentContext.isInExUnitTest) {
                            #if debug_exunit
                            trace('[AST Builder] TField in ExUnit test - field: ${fieldName}, e.expr: ${Type.enumConstructor(e.expr)}');
                            switch(e.expr) {
                                case TLocal(v): trace('[AST Builder]   TLocal var: ${v.name}');
                                default:
                            }
                            #end
                            switch(e.expr) {
                                case TConst(TThis):
                                    // This is an instance variable access in an ExUnit test
                                    // Generate context[:field_name] pattern
                                    #if debug_exunit
                                    trace('[AST Builder] ExUnit instance field access via this: context[:${fieldName}]');
                                    #end
                                    // Convert field name to snake_case for Elixir
                                    var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                                    // Return context[:field_name] pattern
                                    EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));
                                case TLocal(v) if (v.name == "struct"):
                                    // Sometimes the compiler generates a local variable named "struct"
                                    // In ExUnit tests, this should also map to context
                                    #if debug_exunit
                                    trace('[AST Builder] ExUnit field access via struct var: context[:${fieldName}]');
                                    #end
                                    var snakeFieldName = reflaxe.elixir.ast.NameUtils.toSnakeCase(fieldName);
                                    EAccess(makeAST(EVar("context")), makeAST(EAtom(snakeFieldName)));
                                default:
                                    // Not a 'this' reference, handle normally
                                    if (fieldName == "elem") {
                                        // Mark this as a tuple element access for later transformation
                                        // The transformer will convert this to proper elem() calls
                                        EField(target, fieldName);
                                    } else if (isMapAccess(e.t)) {
                                        // Detect map/struct access patterns
                                        EAccess(target, makeAST(EAtom(fieldName)));
                                    } else {
                                        EField(target, fieldName);
                                    }
                            }
                        } else {
                            // Special handling for tuple.elem(N) field access
                            // This occurs when switch statements on Result enums generate field access
                            // We need to prepare for transformation to elem(tuple, N) function calls
                            if (fieldName == "elem") {
                                // Mark this as a tuple element access for later transformation
                                // The transformer will convert this to proper elem() calls
                                EField(target, fieldName);
                            } else if (isMapAccess(e.t)) {
                                // Detect map/struct access patterns
                                EAccess(target, makeAST(EAtom(fieldName)));
                            } else {
                                EField(target, fieldName);
                            }
                        }
                    }  // Close switch(fa) for complex cases
                }
                
            // ================================================================
            // Array Operations (Delegated to ArrayBuilder)
            // ================================================================
            case TArrayDecl(el):
                ArrayBuilder.buildArrayDecl(el, currentContext);
                
            case TArray(e, index):
                ArrayBuilder.buildArrayAccess(e, index, currentContext);
                
            // ================================================================
            // Control Flow (Basic)
            // ================================================================
            case TIf(econd, eif, eelse):
                // Delegated to ControlFlowBuilder for modularization
                ControlFlowBuilder.buildIf(econd, eif, eelse, currentContext);
                
            case TBlock(el):
                #if debug_ast_builder
                // DEBUG: Check if this block contains infrastructure variable + switch pattern
                if (el.length == 2) {
                    var hasVar = switch(el[0].expr) { case TVar(_,_): true; default: false; };
                    var hasSwitch = switch(el[1].expr) { case TSwitch(_,_,_): true; default: false; };
                    if (hasVar && hasSwitch) {
                        trace('[ElixirASTBuilder] TBlock with TVar + TSwitch detected!');
                        switch(el[0].expr) {
                            case TVar(tvar, init):
                                trace('[ElixirASTBuilder]   TVar name: ${tvar.name}');
                                trace('[ElixirASTBuilder]   TVar init: ${init != null ? Type.enumConstructor(init.expr) : "null"}');
                            default:
                        }
                        switch(el[1].expr) {
                            case TSwitch(target, _, _):
                                trace('[ElixirASTBuilder]   TSwitch target: ${Type.enumConstructor(target.expr)}');
                            default:
                        }
                    }
                }
                #end

                // SPECIAL CASE: User variable declaration hoist for canonical initializer blocks
                // WHAT
                // - Detect a common Haxe pattern where a function begins with a user variable
                //   declaration `var name = <expr>` and ends by returning the same variable.
                // - Example (array comprehensions):
                //     var grid = [ for (...) [ for (...) ... ] ];
                //     trace(grid);
                //     grid;
                // WHY
                // - Downstream loose list-building recovery may interleave or obscure the
                //   declaration, resulting in traces appearing before initialization and
                //   infrastructure temps (`g`, `g2`, ‚Ä¶) leaking into the top-level block.
                // HOW
                // - When block[0] is `TVar(v, init)` and block[last] is `TLocal(v)`, build the
                //   assignment first as a single `EMatch(PVar(v), build(init))`, then emit the
                //   middle statements in order, and finally return the variable.
                // - This preserves the intended statement order and gives ArrayBuilder/
                //   ComprehensionBuilder the first shot at reconstructing nested comprehensions
                //   inside the initializer.
                if (el.length >= 2) {
                    // Look at the last expression; if it returns a local variable, try to find
                    // its declaration within the block and hoist it to the top.
                    var retVar: Null<TVar> = null;
                    switch (el[el.length - 1].expr) {
                        case TLocal(v): retVar = v;
                        case TReturn(e):
                            switch (e.expr) { case TLocal(v2): retVar = v2; default: }
                        default:
                    }
                    if (retVar != null) {
                        var declIdx = -1;
                        var declVar: Null<TVar> = null;
                        var declInit: Null<TypedExpr> = null;
                        for (i in 0...el.length - 1) {
                            switch (el[i].expr) {
                                case TVar(v, init) if (init != null && (v.id == retVar.id || v.name == retVar.name)):
                                    // Skip infrastructure temps
                                    var nm = v.name;
                                    var isInfra = (nm == "g" || nm == "_g" 
                                        || (nm.length > 1 && nm.charAt(0) == 'g' && ElixirASTBuilder.isAllDigitsStr(nm.substr(1)))
                                        || (nm.length > 2 && nm.substr(0,2) == "_g" && ElixirASTBuilder.isAllDigitsStr(nm.substr(2))));
                                    if (!isInfra) {
                                        declIdx = i; declVar = v; declInit = init; break;
                                    }
                                default:
                            }
                        }
                        if (declIdx != -1 && declVar != null && declInit != null) {
                            var varName = VariableAnalyzer.toElixirVarName(declVar.name);
                            var initAST = buildFromTypedExpr(declInit, currentContext);
                            var stmts: Array<ElixirAST> = [];
                            if (initAST != null) stmts.push({def: EMatch(PVar(varName), initAST), metadata: {}, pos: null});
                            // Emit every statement except the original declaration and the last return
                            for (i in 0...el.length - 1) if (i != declIdx) {
                                var midNode = buildFromTypedExpr(el[i], currentContext);
                                if (midNode != null) stmts.push(midNode);
                            }
                            // Return variable
                            stmts.push({def: EVar(varName), metadata: {}, pos: null});
                            return EBlock(stmts);
                        }
                    }

                    // Fallback A: First statement is a user variable initialized from a canonical
                    // list‚Äëbuilding block or single‚Äëelement array block. Hoist assignment first,
                    // then emit all remaining statements, and finally return the variable to
                    // preserve intended shape (var = comprehension; trace(var); var).
                    switch (el[0].expr) {
                        case TVar(v0, init0) if (init0 != null):
                            var nm0 = v0.name;
                            var isInfra0 = (nm0 == "g" || nm0 == "_g"
                                || (nm0.length > 1 && nm0.charAt(0) == 'g' && isAllDigitsStr(nm0.substr(1)))
                                || (nm0.length > 2 && nm0.substr(0,2) == "_g" && isAllDigitsStr(nm0.substr(2))));
                            if (!isInfra0) {
                                var canonicalInit = false;
                                switch (init0.expr) {
                                    case TArrayDecl([inner]) if (switch(inner.expr) { case TBlock(_): true; default: false; }):
                                        canonicalInit = true;
                                    case TBlock(sts) if (reflaxe.elixir.ast.builders.ComprehensionBuilder.looksLikeListBuildingBlock(sts)):
                                        canonicalInit = true;
                                    default:
                                }
                                if (canonicalInit) {
                                    var varName3 = VariableAnalyzer.toElixirVarName(nm0);
                                    var initAST3 = buildFromTypedExpr(init0, currentContext);
                                    var seq: Array<ElixirAST> = [];
                                    if (initAST3 != null) seq.push({def: EMatch(PVar(varName3), initAST3), metadata: {}, pos: null});
                                    // Emit all remaining statements except the original declaration
                                    for (i in 1...el.length) {
                                        var mid3 = buildFromTypedExpr(el[i], currentContext);
                                        if (mid3 != null) seq.push(mid3);
                                    }
                                    // If the last expression is not a return of the same variable, append it
                                    var lastIsSame = switch (el[el.length - 1].expr) { case TLocal(vx) if (vx.id == v0.id || vx.name == v0.name): true; default: false; };
                                    if (!lastIsSame) seq.push({def: EVar(varName3), metadata: {}, pos: null});
                                    return EBlock(seq);
                                }
                            }
                        default:
                    }

                    // Fallback B: Find any later user TVar with canonical initializer and hoist
                    // it to the top to preserve intended order for comprehensions.
                    var hoisted = false;
                    var declAt: Int = -1;
                    var declV: Null<TVar> = null;
                    var declI: Null<TypedExpr> = null;
                    for (i in 0...el.length) {
                        switch (el[i].expr) {
                            case TVar(vh, ih) if (ih != null):
                                var nmh = vh.name;
                                var infra = (nmh == "g" || nmh == "_g"
                                    || (nmh.length > 1 && nmh.charAt(0) == 'g' && isAllDigitsStr(nmh.substr(1)))
                                    || (nmh.length > 2 && nmh.substr(0,2) == "_g" && isAllDigitsStr(nmh.substr(2))));
                                if (!infra) {
                                    var canon = false;
                                    switch (ih.expr) {
                                        case TArrayDecl([inner]) if (switch(inner.expr) { case TBlock(_): true; default: false; }): canon = true;
                                        case TBlock(sts) if (reflaxe.elixir.ast.builders.ComprehensionBuilder.looksLikeListBuildingBlock(sts)): canon = true;
                                        default:
                                    }
                                    if (canon) { declAt = i; declV = vh; declI = ih; break; }
                                }
                            default:
                        }
                    }
                    if (declAt > 0 && declV != null && declI != null) {
                        var vname = VariableAnalyzer.toElixirVarName(declV.name);
                        var initASTx = buildFromTypedExpr(declI, currentContext);
                        var seqx: Array<ElixirAST> = [];
                        if (initASTx != null) seqx.push({def: EMatch(PVar(vname), initASTx), metadata: {}, pos: null});
                        for (i in 0...el.length) if (i != declAt) {
                            var midx = buildFromTypedExpr(el[i], currentContext);
                            if (midx != null) seqx.push(midx);
                        }
                        var lastIsVar = switch (el[el.length - 1].expr) { case TLocal(vx) if (vx.id == declV.id || vx.name == declV.name): true; default: false; };
                        if (!lastIsVar) seqx.push({def: EVar(vname), metadata: {}, pos: null});
                        return EBlock(seqx);
                    }
                }

                // Delegate to BlockBuilder for modular handling
                var result = BlockBuilder.build(el, currentContext);
                if (result != null) {
                    return result;
                }
                
                
                // If BlockBuilder fails, return an error placeholder
                trace('[ERROR] BlockBuilder returned null for TBlock - returning placeholder');
                return ERaw("# ERROR: BlockBuilder failed to compile block");
                
            case TReturn(e):
                // Delegate to ReturnBuilder for proper return handling
                var result = ReturnBuilder.build(e, currentContext);
                if (result != null) {
                    return result;
                }
                
                // If ReturnBuilder fails, return an error placeholder
                trace('[ERROR] ReturnBuilder returned null for TReturn - returning placeholder');
                return ERaw("# ERROR: ReturnBuilder failed to compile return statement");
                
            case TBreak:
                // Delegate to ExceptionBuilder for break control flow
                ExceptionBuilder.buildBreak();
                
            case TContinue:
                // Delegate to ExceptionBuilder for continue control flow
                ExceptionBuilder.buildContinue();
                
            // ================================================================
            // Pattern Matching (Switch/Case)
            // ================================================================
            case TSwitch(e, cases, edef):
                // Ensure compiler is set before delegation
                if (currentContext.compiler == null && compiler != null) {
                    currentContext.compiler = compiler;
                }
                
                // Delegate to SwitchBuilder for proper handling
                var result = SwitchBuilder.build(e, cases, edef, currentContext);
                if (result != null) {
                    return result;
                }
                
                // If SwitchBuilder fails, return a placeholder to avoid compilation hang
                // This should be investigated and fixed properly
                trace('[ERROR] SwitchBuilder returned null for TSwitch - returning placeholder');
                return ERaw("# ERROR: SwitchBuilder failed to compile switch expression");
                
                
            case TTry(e, catches):
                // Delegate to ExceptionBuilder for proper exception handling
                var result = ExceptionBuilder.buildTry(e, catches, currentContext);
                if (result != null) {
                    return result;
                }
                
                // If ExceptionBuilder fails, return an error placeholder
                trace('[ERROR] ExceptionBuilder returned null for TTry - returning placeholder');
                return ERaw("# ERROR: ExceptionBuilder failed to compile try expression");
                
            // ================================================================
            // Lambda/Anonymous Functions
            // ================================================================
            case TFunction(f):
                // TODO: FunctionBuilder delegation is temporarily disabled due to variable naming issues
                // The extraction broke the variable renaming map integration
                // var result = reflaxe.elixir.ast.builders.FunctionBuilder.build(f, currentContext);
                // if (result != null) {
                //     return result;
                // }
                
                // Use legacy implementation until FunctionBuilder is fixed
                // Debug: Check for abstract method "this" parameter issue
                #if debug_ast_pipeline
                for (arg in f.args) {
                    #if debug_ast_builder
                    trace('[AST Builder] TFunction arg: ${arg.v.name} (id=${arg.v.id})');
                    #end
                }
                #end

                #if debug_everythingisexpr
                // Special debug for ChangesetUtils methods that are failing
                if (currentContext != null && currentModule != null && currentModule.contains("ChangesetUtils")) {
                    #if debug_ast_builder
                    trace('[TFunction] Processing function in module: ${currentModule}');
                    #end
                    if (f.expr != null) {
                        #if debug_ast_builder
                        trace('[TFunction] Function body type: ${Type.enumConstructor(f.expr.expr)}');
                        #end

                        // Check what the function body looks like
                        switch(f.expr.expr) {
                            case TBlock(exprs):
                                #if debug_ast_builder
                                trace('[TFunction] Function body is TBlock with ${exprs.length} expressions');
                                #end
                                for (i in 0...exprs.length) {
                                    #if debug_ast_builder
                                    trace('[TFunction]   Expr[$i]: ${Type.enumConstructor(exprs[i].expr)}');
                                    #end

                                    // Check if it's a TVar with problematic init
                                    switch(exprs[i].expr) {
                                        case TVar(v, init):
                                            #if debug_ast_builder
                                            trace('[TFunction]     TVar ${v.name}');
                                            #end
                                            if (init != null) {
                                                #if debug_ast_builder
                                                trace('[TFunction]       Init type: ${Type.enumConstructor(init.expr)}');
                                                #end

                                                // Check if it's TLocal(value)
                                                switch(init.expr) {
                                                    case TLocal(localVar):
                                                        #if debug_ast_builder
                                                        trace('[TFunction]       Init is TLocal: ${localVar.name}');
                                                        #end
                                                    default:
                                                }
                                            }
                                        default:
                                    }
                                }
                            case TReturn(expr):
                                if (expr != null) {
                                    #if debug_ast_builder
                                    trace('[TFunction] Direct return, expr type: ${Type.enumConstructor(expr.expr)}');
                                    #end
                                }
                            default:
                                #if debug_ast_builder
                                trace('[TFunction] Other body type');
                                #end
                        }
                    }
                }
                #end
                
                // Detect fluent API patterns
                var fluentPattern = PatternDetector.detectFluentAPIPattern(f);
                
                var args = [];
                var paramRenaming = new Map<String, String>();
                
                // FIXED: Don't reset tempVarRenameMap - preserve registrations from buildClassAST
                // ElixirCompiler.buildClassAST already registered parameter mappings in the context
                // Creating a new map here would lose those critical registrations
                // This was causing priority2 bug where registered "priority" mapping was lost

                #if debug_variable_renaming
                var existingEntries = Lambda.count(currentContext.tempVarRenameMap);
                var funcInfo = if (f.args.length > 0) {
                    'with ${f.args.length} args: ${f.args.map(a -> a.v.name).join(", ")}';
                } else {
                    'with no args';
                };
                trace('[ElixirASTBuilder TFunction] Processing function $funcInfo - map has $existingEntries entries');
                #end

                // Keep existing map with buildClassAST registrations instead of creating new one
                var oldTempVarRenameMap = currentContext.tempVarRenameMap;
                // NO RESET: Use the map as-is with all existing registrations
                
                // Process all parameters: handle naming, unused prefixing, and registration
                var isFirstParam = true;
                for (arg in f.args) {
                    var originalName = arg.v.name;
                    var idKey = Std.string(arg.v.id);

                    #if debug_variable_renaming
                    #if debug_ast_builder
                    trace('[RENAME DEBUG] TFunction: Processing parameter "$originalName" (ID: ${arg.v.id})');
                    #end
                    #end
                    
                    // Use Reflaxe's metadata to detect unused parameters
                    // First check if parameter has the -reflaxe.unused metadata
                    var isActuallyUnused = if (arg.v.meta != null && arg.v.meta.has("-reflaxe.unused")) {
                        true;  // Parameter is marked as unused by Reflaxe preprocessor
                    } else if (f.expr != null) {
                        // Use our UsageDetector to check if parameter is actually used
                        !reflaxe.elixir.helpers.UsageDetector.isParameterUsed(arg.v, f.expr);
                    } else {
                        false; // If no body, consider parameter as potentially used
                    };
                    
                    // Check if this parameter has a numeric suffix that indicates shadowing
                    var strippedName = originalName;
                    var hasNumericSuffix = false;
                    var renamedPattern = ~/^(.+?)(\d+)$/;
                    if (renamedPattern.match(originalName)) {
                        var baseWithoutSuffix = renamedPattern.matched(1);
                        var suffix = renamedPattern.matched(2);

                        // Only strip suffix if it looks like a shadowing rename (suffix 2 or 3, common field names)
                        var commonFieldNames = ["options", "columns", "name", "value", "type", "data", "fields", "items", "priority"];
                        if ((suffix == "2" || suffix == "3") && commonFieldNames.indexOf(baseWithoutSuffix) >= 0) {
                            strippedName = baseWithoutSuffix;
                            hasNumericSuffix = true;

                            #if debug_variable_renaming
                            #if debug_ast_builder
                            trace('[RENAME DEBUG] TFunction: Detected renamed parameter "$originalName" -> "$strippedName" (suffix: "$suffix", ID: ${arg.v.id})');
                            #end
                            #end
                        }
                    }

                    // Convert to snake_case for Elixir conventions
                    var baseName = ElixirASTHelpers.toElixirVarName(strippedName);
                    
                    // Debug: Check if reserved keyword
                    #if debug_reserved_keywords
                    if (isElixirReservedKeyword(baseName)) {
                        #if debug_ast_builder
                        trace('[AST Builder] Reserved keyword detected in parameter: $baseName -> ${baseName}_param');
                        #end
                    }
                    #end
                    
                    // Prefix with underscore if unused (using TypedExpr-based detection which is more accurate)
                    // This is done here rather than in a transformer because we have full semantic information
                    // Re-enable underscore prefixing for 1.0 quality
                    var finalName = if (isActuallyUnused && !StringTools.startsWith(baseName, "_")) {
                        "_" + baseName;
                    } else {
                        baseName;
                    };
                    
                    // Register the mapping for TLocal references in the body with dual-key storage
                    if (!currentContext.tempVarRenameMap.exists(idKey)) {
                        // Dual-key storage: ID for pattern positions, name for EVar references
                        currentContext.tempVarRenameMap.set(idKey, finalName);           // ID-based (pattern matching)
                        currentContext.tempVarRenameMap.set(originalName, finalName);    // NAME-based (EVar renaming)

                        #if debug_hygiene
                        trace('[Hygiene] Dual-key registered (TFunction param): id=$idKey name=$originalName -> $finalName');
                        #end

                        #if debug_variable_renaming
                        #if debug_ast_builder
                        trace('[RENAME DEBUG] TFunction: Registered in tempVarRenameMap - ID: $idKey -> "$finalName" (original: "$originalName", stripped: "$strippedName")');
                        #end
                        #end
                    }
                    
                    // Track parameter mappings for collision detection
                    if (originalName != finalName) {
                        paramRenaming.set(originalName, finalName);
                        #if debug_ast_pipeline
                        #if debug_ast_builder
                        trace('[AST Builder] Function parameter will be renamed: $originalName -> $finalName');
                        #end
                        #end
                    }

                    // Register the renamed variable mapping if we stripped a suffix
                    // This follows Codex's recommendation to register at the point of emission decision
                    if (hasNumericSuffix && currentContext != null && currentContext.astContext != null) {
                        // Register that this variable ID should use the clean name (without suffix)
                        currentContext.astContext.registerRenamedVariable(arg.v.id, strippedName, originalName);

                        #if debug_variable_renaming
                        #if debug_ast_builder
                        trace('[RENAME DEBUG] TFunction: Registered renamed mapping for id ${arg.v.id}: "$originalName" -> "$strippedName"');
                        #end
                        #end
                    }
                    
                    // Handle special case for abstract "this" parameters
                    if (originalName == "this1") {
                        // The body might try to rename this1 -> this due to collision detection
                        // We need to prevent that and use the parameter name instead
                        paramRenaming.set("this", finalName); // Map "this" to final name as well
                        #if debug_ast_pipeline
                        #if debug_ast_builder
                        trace('[AST Builder] Abstract this parameter detected, mapping both this1 and this to: $finalName');
                        #end
                        #end
                    }
                    
                    // Track the first parameter as the receiver for instance methods
                    // This will be used for TThis references
                    if (isFirstParam && currentContext.isInClassMethodContext) {
                        currentContext.currentReceiverParamName = finalName;
                        isFirstParam = false;
                    }
                    
                    // Add the parameter to the function signature
                    args.push(PVar(finalName));
                    
                    currentContext.functionParameterIds.set(idKey, true); // Mark as function parameter
                    #if debug_ast_pipeline
                    #if debug_ast_builder
                    trace('[AST Builder] Registering parameter in rename map: id=$idKey');
                    #end
                    #end
                }
                
                // Analyze variable usage in the function body
                // TODO: Restore when VariableUsageAnalyzer is available
                // This is critical for proper underscore prefixing of unused variables
                var functionUsageMap: Map<Int, Bool> = null; // if (f.expr != null) {
                    // reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(f.expr);
                // } else {
                    // null;
                // };
                
                // Update context with function-specific usage map
                if (functionUsageMap != null) {
                    currentContext.variableUsageMap = functionUsageMap;
                }

                #if (debug_ast_builder && !no_traces)
                #if !no_traces
                trace('[TFunction DEBUG] BEFORE body compilation: tempVarRenameMap has ${Lambda.count(currentContext.tempVarRenameMap)} entries');
                #end
                if (currentContext.tempVarRenameMap.keys().hasNext()) {
                    #if !no_traces
                    trace('[TFunction DEBUG] Map contents:');
                    #end
                    for (k in currentContext.tempVarRenameMap.keys()) {
                        #if !no_traces
                        trace('[TFunction DEBUG]   "$k" -> "${currentContext.tempVarRenameMap.get(k)}"');
                        #end
                    }
                }
                #end

                var body = buildFromTypedExpr(f.expr, currentContext);

                #if (debug_ast_builder && !no_traces)
                #if !no_traces
                trace('[TFunction DEBUG] AFTER body compilation: tempVarRenameMap has ${Lambda.count(currentContext.tempVarRenameMap)} entries');
                #end
                #end
                
                // Restore the original map and clean up function parameter tracking
                currentContext.tempVarRenameMap = oldTempVarRenameMap;
                for (arg in f.args) {
                    currentContext.functionParameterIds.remove(Std.string(arg.v.id));
                }
                
                // Apply any remaining parameter renaming if needed
                if (paramRenaming.keys().hasNext()) {
                    #if debug_ast_pipeline
                    #if debug_ast_builder
                    trace('[AST Builder] Applying parameter renaming to function body');
                    #end
                    #end
                    body = applyParameterRenaming(body, paramRenaming);
                }
                
                // Create the function AST with fluent API metadata if detected
                var fnAst = makeAST(EFn([{
                    args: args,
                    guard: null,
                    body: body
                }]));
                
                // Add fluent API metadata if patterns were detected
                if (fluentPattern.returnsThis || fluentPattern.fieldMutations.length > 0) {
                    fnAst.metadata.isFluentMethod = true;
                    fnAst.metadata.returnsThis = fluentPattern.returnsThis;
                    
                    if (fluentPattern.fieldMutations.length > 0) {
                        fnAst.metadata.mutatesFields = [];
                        fnAst.metadata.fieldMutations = [];
                        for (mutation in fluentPattern.fieldMutations) {
                            fnAst.metadata.mutatesFields.push(mutation.field);
                            fnAst.metadata.fieldMutations.push({
                                field: mutation.field,
                                expr: buildFromTypedExpr(mutation.expr, currentContext)
                            });
                        }
                    }
                }
                
                fnAst.def;
                
            // ================================================================
            // Object/Anonymous Structure
            // ================================================================
            /**
             * Handles TObjectDecl conversion to either EMap or EKeywordList based on usage context.
             * 
             * Two special patterns are detected and handled:
             * 
             * 1. SUPERVISOR OPTIONS PATTERN:
             *    When an object contains OTP supervisor configuration fields (strategy, max_restarts, max_seconds),
             *    it's compiled to a keyword list instead of a map. This is required because Supervisor.start_link/2
             *    expects options as a keyword list, not a map.
             * 
             *    Example:
             *    ```haxe
             *    // Haxe source
             *    var opts = {strategy: OneForOne, max_restarts: 3, max_seconds: 5};
             *    ```
             *    
             *    ```elixir
             *    # Generated Elixir (keyword list, not map)
             *    opts = [strategy: :OneForOne, max_restarts: 3, max_seconds: 5]
             *    ```
             * 
             * 2. NULL COALESCING IN OBJECT FIELDS:
             *    Haxe generates a specific AST pattern for null coalescing operators (??) in object field values.
             *    This pattern is detected and transformed into idiomatic Elixir inline if-expressions.
             * 
             *    Example:
             *    ```haxe
             *    // Haxe source
             *    {field: someValue ?? defaultValue}
             *    ```
             *    
             *    ```elixir
             *    # Generated Elixir
             *    %{field: if (tmp = some_value) != nil, do: tmp, else: default_value}
             *    ```
             * 
             * @param fields Array of object field declarations from Haxe's TypedExpr
             * @return Either EKeywordList for supervisor options or EMap for regular objects
             */
            case TObjectDecl(fields):
                // Delegate to ObjectBuilder for modular handling
                var result = reflaxe.elixir.ast.builders.ObjectBuilder.build(fields, currentContext);
                if (result != null) return result;
                
                
                // If ObjectBuilder fails, return an error placeholder
                trace('[ERROR] ObjectBuilder returned null for TObjectDecl - returning placeholder');
                return ERaw("# ERROR: ObjectBuilder failed to compile object declaration");
                
            // ================================================================
            case TNew(c, params, el):
                // Delegate to ConstructorBuilder for modular handling
                var result = reflaxe.elixir.ast.builders.ConstructorBuilder.build(c, params, el, currentContext);
                if (result != null) return result;
                
                
                // If ConstructorBuilder fails, return an error placeholder
                trace('[ERROR] ConstructorBuilder returned null for TNew - returning placeholder');
                return ERaw("# ERROR: ConstructorBuilder failed to compile constructor call");
                
            case TFor(v, e1, e2):
                #if debug_ast_builder
                trace('[TFor] Processing for loop, var: ${v.name}');
                trace('[TFor] Body expression type: ${Type.enumConstructor(e2.expr)}');
                switch(e2.expr) {
                    case TBlock(exprs):
                        trace('[TFor] Body is TBlock with ${exprs.length} expressions');
                        for (i in 0...exprs.length) {
                            trace('[TFor]   [$i]: ${Type.enumConstructor(exprs[i].expr)}');
                        }
                    case TSwitch(switchExpr, _, _):
                        trace('[TFor] Body is direct TSwitch on: ${Type.enumConstructor(switchExpr.expr)}');
                    default:
                        trace('[TFor] Body is: ${Type.enumConstructor(e2.expr)}');
                }
                #end
                
                // Delegate ALL for loop compilation to LoopBuilder
                // Create adapter for BuildContext interface
                var buildContext: reflaxe.elixir.ast.builders.LoopBuilder.BuildContext = {
                    isFeatureEnabled: function(f) return currentContext.isFeatureEnabled(f),
                    buildFromTypedExpr: function(e, ?ctx) return buildFromTypedExpr(e, currentContext),
                    whileLoopCounter: currentContext.whileLoopCounter
                };
                return LoopBuilder.buildFor(v, e1, e2, expr, buildContext, name -> VariableAnalyzer.toElixirVarName(name));
                
            case TWhile(econd, e, normalWhile):
                // Delegate ALL while loop compilation to LoopBuilder
                // Create adapter for BuildContext interface
                var buildContext: reflaxe.elixir.ast.builders.LoopBuilder.BuildContext = {
                    isFeatureEnabled: function(f) return currentContext.isFeatureEnabled(f),
                    buildFromTypedExpr: function(e, ?ctx) return buildFromTypedExpr(e, currentContext),
                    whileLoopCounter: currentContext.whileLoopCounter
                };
                return LoopBuilder.buildWhileComplete(econd, e, normalWhile, expr, buildContext, name -> VariableAnalyzer.toElixirVarName(name)); 
                
            case TEnumParameter(e, ef, index):
                /**
                 * TEnumParameter extraction for enum constructor parameters
                 *
                 * WHY: When Haxe compiles enum patterns like `case Ok(value):`, it generates
                 *      TEnumParameter expressions to extract the parameters. However, in Elixir
                 *      pattern matching, the pattern `{:ok, value}` already extracts the value.
                 *
                 * PROBLEM: When patterns have ignored parameters like `case Ok(_):`, Haxe still
                 *          generates TEnumParameter which tries to extract from the already-extracted
                 *          value. This causes runtime errors like `elem(nil, 1)` when the extracted
                 *          value is nil.
                 *
                 * SOLUTION: Use the EnumBindingPlan from ClauseContext which provides a single
                 *           source of truth for variable names at each parameter index.
                 *
                 * EDGE CASES:
                 * - Ignored parameters: Pattern extracts to temp var but it's not used
                 * - Nested enums: Multiple levels of extraction
                 * - Abstract types: May not have ClauseContext mappings
                 * - ChangesetUtils: Patterns use canonical names but body expects temp vars
                 */

                // Debug trace to understand the extraction context
                #if debug_enum_extraction
                #if debug_ast_builder
                trace('[TEnumParameter] Attempting extraction:');
                #end
                #if debug_ast_builder
                trace('  - Expression type: ${e.expr}');
                #end
                #if debug_ast_builder
                trace('  - Enum field: ${ef.name}');
                #end
                #if debug_ast_builder
                trace('  - Index: $index');
                #end
                #if debug_ast_builder
                trace('  - Has ClauseContext: ${currentContext.currentClauseContext != null}');
                #end
                if (currentContext.currentClauseContext != null) {
                    #if debug_ast_builder
                    trace('  - Has EnumBindingPlan: ${currentContext.currentClauseContext.enumBindingPlan != null && currentContext.currentClauseContext.enumBindingPlan.keys().hasNext()}');
                    #end
                    if (currentContext.currentClauseContext.enumBindingPlan.exists(index)) {
                        var info = currentContext.currentClauseContext.enumBindingPlan.get(index);
                        #if debug_ast_builder
                        trace('  - Binding plan for index $index: ${info.finalName} (used: ${info.isUsed})');
                        #end
                    }
                }
                #end

                // TASK 4.5 FIX: Check if this parameter was already extracted by the pattern
                // If the enum field name is in patternExtractedParams, the pattern already bound it

                // DEBUG: Show what we're checking BEFORE the condition
                #if sys
                var debugFile = sys.io.File.append("/tmp/enum_debug.log");
                debugFile.writeString('[TEnumParameter] *** PRE-CHECK DEBUG ***\n');
                debugFile.writeString('[TEnumParameter]   ef.name: "${ef.name}"\n');
                debugFile.writeString('[TEnumParameter]   Has currentClauseContext: ${currentContext.currentClauseContext != null}\n');
                if (currentContext.currentClauseContext != null) {
                    debugFile.writeString('[TEnumParameter]   patternExtractedParams: [${currentContext.currentClauseContext.patternExtractedParams.join(", ")}]\n');
                    debugFile.writeString('[TEnumParameter]   Contains ef.name?: ${currentContext.currentClauseContext.patternExtractedParams.contains(ef.name)}\n');
                }
                debugFile.close();
                #end

                if (currentContext.currentClauseContext != null &&
                    currentContext.currentClauseContext.patternExtractedParams.contains(ef.name)) {

                    #if debug_enum_parameter
                    var debugFile3 = sys.io.File.append("/tmp/enum_debug.log");
                    debugFile3.writeString('[TEnumParameter] ‚úÖ CONDITION MATCHED: Parameter "${ef.name}" already extracted by pattern\n');
                    debugFile3.close();
                    #end

                    // The pattern already extracted this parameter
                    // Use the binding plan to find the actual variable name
                    if (currentContext.currentClauseContext.enumBindingPlan.exists(index)) {
                        var info = currentContext.currentClauseContext.enumBindingPlan.get(index);

                        #if debug_enum_parameter
                        trace('[TEnumParameter]   *** BINDING PLAN DATA ***');
                        trace('[TEnumParameter]     finalName: "${info.finalName}"');
                        trace('[TEnumParameter]     isUsed: ${info.isUsed}');
                        trace('[TEnumParameter]     charAt(0): "${info.finalName.charAt(0)}"');
                        trace('[TEnumParameter]     charAt(0) == "_": ${info.finalName.charAt(0) == "_"}');
                        #end

                        // CRITICAL FIX: If parameter is unused (has underscore prefix), return null to skip TVar
                        // This prevents generating: x = _x (where _x is the unused pattern variable)
                        // Instead we skip the assignment entirely since the pattern already has _x
                        if (!info.isUsed || (info.finalName != null && info.finalName.charAt(0) == "_")) {
                            #if debug_enum_parameter trace('[TEnumParameter]   *** RETURNING NULL - Parameter is UNUSED ***'); #end
                            return null;
                        }

                        // Return the pattern-bound variable directly
                        return EVar(info.finalName);
                    } else {
                        // Fallback: use the enum field name as variable name
                        var varName = VariableAnalyzer.toElixirVarName(ef.name);

                        #if debug_enum_extraction
                        trace('[TEnumParameter]   No binding plan, using enum field name: $varName');
                        #end

                        return EVar(varName);
                    }
                }

                // CRITICAL FIX for ChangesetUtils pattern-body mismatch:
                // When TEnumParameter tries to extract from a variable like 'g' that doesn't exist
                // because the pattern used canonical names directly (like {:ok, value}),
                // we need to detect this and return the correct variable.

                // First, check what variable we're trying to extract from
                var sourceVarName: String = null;
                switch(e.expr) {
                    case TLocal(v):
                        sourceVarName = VariableAnalyzer.toElixirVarName(v.name);
                        #if debug_enum_extraction
                        #if debug_ast_builder
                        trace('[TEnumParameter] Extracting from variable: $sourceVarName');
                        #end
                        #end
                    default:
                        // Not a local variable
                }

                // Check if we have a binding plan for this index
                if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.enumBindingPlan.exists(index)) {
                    // Use the variable name from the binding plan
                    var info = currentContext.currentClauseContext.enumBindingPlan.get(index);

                    #if debug_ast_builder
                    trace('[DEBUG EMBEDDED TEnumParameter] Binding plan says to use: ${info.finalName}, sourceVarName: $sourceVarName');
                    #end

                    #if debug_enum_extraction
                    #if debug_ast_builder
                    trace('  - Binding plan says to use: ${info.finalName}');
                    #end
                    #end

                    // CRITICAL: Check if we're trying to extract from a temp var that doesn't exist
                    // This happens when the pattern used canonical names directly
                    if (sourceVarName != null && TypedExprPreprocessor.isInfrastructureVar(sourceVarName)) {
                        // We're trying to extract from an infrastructure var like 'g', '_g', 'g1', '_g1'
                        // But if the binding plan uses a different name, the pattern already extracted it
                        if (info.finalName != sourceVarName) {
                            #if debug_ast_builder
                            trace('[DEBUG EMBEDDED TEnumParameter] RETURNING DIRECT VAR: ${info.finalName}');
                            #end
                            #if debug_enum_extraction
                            #if debug_ast_builder
                            trace('[TEnumParameter] Pattern used ${info.finalName}, not temp var $sourceVarName');
                            #end
                            #if debug_ast_builder
                            trace('[TEnumParameter] Returning ${info.finalName} directly (already extracted by pattern)');
                            #end
                            #end
                            // The pattern already extracted to the correct variable
                            return EVar(info.finalName);
                        }
                    }

                    // ID-BASED TRACKING: Check if this would create a redundant assignment
                    // If the binding plan says to use the same name as the source, it would create g = g
                    if (info.finalName == sourceVarName && sourceVarName != null) {
                        #if debug_ast_builder
                        trace('[DEBUG g=g FOUND] Self-assignment detected: ${sourceVarName} = ${sourceVarName}, skipping');
                        #end
                        // This would create g = g, skip the assignment by returning null
                        return null;
                    }

                    // CRITICAL FIX: If the pattern already extracted to a real variable name (not temp var),
                    // return null to skip the redundant TVar assignment entirely.
                    // Example: pattern {:ok, value} already binds 'value', so TVar(value, TEnumParameter(...))
                    // should be skipped - the value is already available from the pattern.
                    //
                    // This prevents generating:
                    //   {:ok, value} ->
                    //     value = value  # or value = nil
                    //
                    // When we should generate:
                    //   {:ok, value} ->
                    //     # value already available from pattern
                    //
                    // Check if the final name is NOT a temporary/infrastructure variable
                    var finalNameIsTemp = (info.finalName != null &&
                                          (info.finalName == "_" ||
                                           TypedExprPreprocessor.isInfrastructureVar(info.finalName)));

                    // ALWAYS skip TVar assignment for pattern-extracted variables
                    // Whether temp var (like "_g") or real var (like "value"),
                    // the pattern already extracted it - no assignment needed
                    #if debug_ast_builder
                    if (finalNameIsTemp) {
                        trace('[TEnumParameter] Temp/infrastructure var ${info.finalName}, returning null to skip TVar assignment');
                    } else {
                        trace('[TEnumParameter] Real variable ${info.finalName}, returning null - pattern already extracted');
                    }
                    #end
                    return null;
                } else {
                    #if debug_ast_builder
                    trace('[DEBUG EMBEDDED TEnumParameter] NO BINDING PLAN! ClauseContext: ${currentContext.currentClauseContext != null}, index: $index, sourceVarName: $sourceVarName');
                    #end

                    // CRITICAL FIX: When there's no binding plan and we're trying to extract from
                    // a temp var that doesn't exist (like 'g', '_g'), return null to skip the assignment
                    // This happens in embedded switches where the pattern uses the actual variable name
                    if (sourceVarName != null && TypedExprPreprocessor.isInfrastructureVar(sourceVarName)) {
                        #if debug_ast_builder
                        trace('[DEBUG EMBEDDED TEnumParameter] Skipping extraction from non-existent infrastructure var: $sourceVarName');
                        #end
                        // Return null to skip the assignment - the pattern already extracted the value
                        return null;
                    }

                    // Fallback to the old logic for backward compatibility

                    // Check if this is extracting from an already-extracted pattern variable
                    var skipExtraction = false;
                    var extractedVarName: String = null;

                    // Check if we're in a switch case context where patterns have already extracted values
                    // This avoids redundant extraction like: case {:ok, g} -> g = elem(result, 1)

                    // Check for local variables that might be extracted pattern variables
                    if (!skipExtraction) {
                        switch(e.expr) {
                            case TLocal(v):
                                var varName = VariableAnalyzer.toElixirVarName(v.name);

                                #if debug_enum_extraction
                                #if debug_ast_builder
                                trace('  - TLocal variable: ${v.name} -> $varName');
                                #end
                                if (currentContext.currentClauseContext != null) {
                                    #if debug_ast_builder
                                    trace('  - ClauseContext has mapping: ${currentContext.currentClauseContext.localToName.exists(v.id)}');
                                    #end
                                    if (currentContext.currentClauseContext.localToName.exists(v.id)) {
                                        #if debug_ast_builder
                                        trace('  - Mapped to: ${currentContext.currentClauseContext.localToName.get(v.id)}');
                                        #end
                                    }
                                }
                                #end

                                // Check if this variable was extracted by the pattern
                                // Pattern extraction creates variables like 'g', 'g1', 'g2' for ignored params
                                // or uses actual names for named params
                                if (currentContext.currentClauseContext != null && currentContext.currentClauseContext.localToName.exists(v.id)) {
                                    // This variable was mapped in the pattern, it's already extracted
                                    extractedVarName = currentContext.currentClauseContext.localToName.get(v.id);
                                    skipExtraction = true;

                                    #if debug_enum_extraction
                                    #if debug_ast_builder
                                    trace('  - SKIPPING extraction, already extracted to: $extractedVarName');
                                    #end
                                    #end
                                } else {
                                    // Check metadata to see if this is truly a temp extraction variable
                                    var isExtractionTemp = false;

                                    // First check if we have VarOrigin metadata
                                    if (currentContext.tempVarRenameMap.exists(Std.string(v.id))) {
                                        // This is a renamed temp variable
                                        isExtractionTemp = true;
                                    } else if (varName == "g" || (varName.startsWith("g") && varName.length > 1 &&
                                              varName.charAt(1) >= '0' && varName.charAt(1) <= '9')) {
                                        // Name pattern suggests temp var, but need more context
                                        // Check if this variable was created from TEnumParameter
                                        // For now, be conservative and only treat as temp if we're sure
                                        // TODO: Use VarOrigin metadata when available
                                        isExtractionTemp = false; // Conservative: avoid false positives
                                    }

                                    if (isExtractionTemp) {
                                        // This is definitely a temp extraction variable
                                        extractedVarName = varName;
                                        skipExtraction = true;

                                        #if debug_enum_extraction
                                        #if debug_ast_builder
                                        trace('  - SKIPPING extraction, detected as pattern temp var: $varName');
                                        #end
                                        #end
                                    }
                                }
                            case _:
                                // Not a local variable, normal extraction needed
                                #if debug_enum_extraction
                                #if debug_ast_builder
                                trace('  - Not a TLocal, proceeding with extraction');
                                #end
                                #end
                        }
                    }

                    if (skipExtraction && extractedVarName != null) {
                        // The pattern already extracted this value, just return the variable reference
                        EVar(extractedVarName);
                    } else {
                        // Normal case: generate the elem() extraction
                        var exprAST = buildFromTypedExpr(e, currentContext);

                        #if debug_enum_extraction
                        #if debug_ast_builder
                        trace('  - Generating elem() extraction');
                        #end
                        #end

                        // Will be transformed to proper pattern extraction
                        // +1 because Elixir tuples are 0-based but first element is the tag
                        ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]);
                    }
                }
                
            case TEnumIndex(e):
                // Get enum tag index - always use the enum value directly for atom-based matching
                // We don't use elem() because we're matching on atom tuples like {:TodoUpdates}
                // The switch will generate patterns like: {:TodoUpdates} -> ... {:UserActivity} -> ...
                var enumExpr = buildFromTypedExpr(e, currentContext);
                if (enumExpr != null) {
                    enumExpr.def;
                } else {
                    // Fallback if the expression couldn't be built
                    EVar("nil");
                }
                
            case TThrow(e):
                // Delegate to ExceptionBuilder for throw expressions
                var result = ExceptionBuilder.buildThrow(e, currentContext);
                if (result != null) {
                    return result;
                }
                // Fallback to legacy implementation
                EThrow(buildFromTypedExpr(e, currentContext));
                
            case TMeta(meta, e):
                // Handle expression-level metadata with semantic meaning
                switch (meta.name) {
                    case ":heex":
                        // HXX.hxx macro tagged this string as HEEx content.
                        // Emit ~H sigil directly. Prefer fast-path for literal strings to avoid
                        // unnecessary template collection for already-EEx content.
                        var innerAst = buildFromTypedExpr(e, currentContext);
                        var content: String = null;
                        switch (innerAst.def) {
                            case EString(s):
                                content = s;
                            default:
                                content = collectTemplateContent(innerAst);
                        }
                        ESigil("H", content, "");
                    default:
                        // Other metadata is compile-time only; process inner expression
                        convertExpression(e);
                }

            case TParenthesis(e):
                // Parentheses are for grouping, just process inner expression
                // No EParens node in ElixirAST - Elixir handles precedence naturally
                convertExpression(e);

            case TCast(e, _):
                // Elixir has no explicit casts - uses pattern matching instead
                // Just process the expression, ignoring the module type hint
                convertExpression(e);

            case TTypeExpr(m):
                // Type expressions become module references (ModuleName), not atoms
                // Reuse existing moduleTypeToString utility function and emit a bare module ref
                var moduleName = moduleTypeToString(m);
                EVar(moduleName);

            case TIdent(s):
                // Identifier reference
                EVar(VariableAnalyzer.toElixirVarName(s));
        }
    }
    
    /**
     * Build a switch that pattern matches on object fields
     * 
     * WHY: When Haxe desugars switch(obj.field), we need to generate idiomatic
     *      Elixir pattern matching on the object with field patterns
     * WHAT: Transforms switch(field_value) to case obj do %{field: value} -> ... end
     * HOW: Builds map patterns for each case value and extracts other object fields
     * 
     * @param rootObj The root object to switch on (e.g., msg)
     * @param fieldName The field name being matched (e.g., "type")
     * @param cases The original switch cases
     * @param edef The default case (if any)
     * @param pos Position for error reporting
     * @param context Current build context
     * @return ElixirAST representing the field pattern switch
     */
    static function buildFieldPatternSwitch(rootObj: TypedExpr, fieldName: String, 
                                           cases: Array<{values: Array<TypedExpr>, expr: TypedExpr}>,
                                           edef: Null<TypedExpr>, pos: Position, 
                                           context: reflaxe.elixir.CompilationContext): ElixirASTDef {
        #if debug_ast_builder
        trace('[buildFieldPatternSwitch] Building field pattern switch on ${fieldName}');
        trace('[buildFieldPatternSwitch] Root object type: ${Type.enumConstructor(rootObj.expr)}');
        #end
        
        // Build the switch target (the root object)
        var targetAST = buildFromTypedExpr(rootObj, context);
        
        // Check if we got nil (which happens when the rootObj is not properly resolved)
        // This can happen with infrastructure variables where the object is not available
        if (targetAST.def == ENil) {
            #if debug_ast_builder
            trace('[buildFieldPatternSwitch] WARNING: targetAST is nil, falling back to direct switch');
            #end
            // Fallback: generate a simple switch on nil which won't work but at least compiles
            // This should be fixed properly by ensuring rootObj is correctly passed
        }
        
        // Extract all fields from the object type for pattern extraction
        var objectFields: Array<String> = [];
        switch(rootObj.t) {
            case TAnonymous(anonRef):
                var anon = anonRef.get();
                for (field in anon.fields) {
                    objectFields.push(field.name);
                    #if debug_ast_builder
                    trace('[buildFieldPatternSwitch] Found field: ${field.name}');
                    #end
                }
            default:
                // Not an anonymous object - can't extract fields
                #if debug_ast_builder
                trace('[buildFieldPatternSwitch] Root object is not anonymous, cannot extract fields');
                #end
        }
        
        // Build the case clauses with field patterns
        var clauses: Array<ECaseClause> = [];
        
        for (switchCase in cases) {
            for (value in switchCase.values) {
                // Build the pattern - we want %{field: value, other_field: other_field_var}
                var patternPairs: Array<{key: ElixirAST, value: EPattern}> = [];
                
                // Add the main field we're matching on
                var fieldValue = buildFromTypedExpr(value, context);
                
                // Convert the field value to a pattern
                var fieldPattern = switch(fieldValue.def) {
                    case EString(s): PLiteral(makeAST(EString(s)));
                    case EInteger(i): PLiteral(makeAST(EInteger(i)));
                    case EFloat(f): PLiteral(makeAST(EFloat(f)));
                    case EBoolean(b): PLiteral(makeAST(EBoolean(b)));
                    case EAtom(a): PLiteral(makeAST(EAtom(a)));
                    case ENil: PLiteral(makeAST(ENil));
                    default: 
                        // For complex patterns, use a variable
                        PVar("_matched_value");
                };
                
                patternPairs.push({
                    key: makeAST(EAtom(fieldName)),
                    value: fieldPattern
                });
                
                // Add patterns for other fields to extract them
                for (otherField in objectFields) {
                    if (otherField != fieldName) {
                        // Generate a variable name for this field (e.g., msg_data for "data" field)
                        // Extract the root object name
                        var rootName = switch(rootObj.expr) {
                            case TLocal(v): v.name;
                            case TField(_, FAnon(cf)): cf.get().name;
                            case TField(_, FInstance(_, _, cf)): cf.get().name;
                            default: "obj";
                        };
                        
                        var varName = VariableAnalyzer.toElixirVarName(rootName + "_" + otherField);
                        #if debug_ast_builder
                        trace('[buildFieldPatternSwitch] Extracting field ${otherField} as ${varName}');
                        #end
                        
                        patternPairs.push({
                            key: makeAST(EAtom(otherField)),
                            value: PVar(varName)
                        });
                    }
                }
                
                // Build the map pattern (not wrapped in makeAST - it's already a pattern)
                var pattern = PMap(patternPairs);
                
                // Build the body
                var body = buildFromTypedExpr(switchCase.expr, context);
                
                // Create the clause directly as ECaseClause (no makeAST wrapper)
                var clauseDef: ECaseClause = {
                    pattern: pattern,
                    guard: null,
                    body: body
                };
                clauses.push(clauseDef);
            }
        }
        
        // Add default case if present
        if (edef != null) {
            var defaultBody = buildFromTypedExpr(edef, context);
            var defaultClauseDef: ECaseClause = {
                pattern: PWildcard,
                guard: null,
                body: defaultBody
            };
            clauses.push(defaultClauseDef);
        }
        
        #if debug_ast_builder
        trace('[buildFieldPatternSwitch] Generated ${clauses.length} clauses');
        #end
        
        // Return the case expression
        return ECase(targetAST, clauses);
    }
    
    /**
     * Try to detect and optimize array iteration patterns
     * 
     * WHY: Haxe desugars array.map/filter into while loops with index counters
     * WHAT: Detects these patterns and generates idiomatic Enum calls instead
     * HOW: Analyzes condition and body to identify map/filter/reduce patterns
     * 
     * @param econd The while loop condition
     * @param ebody The while loop body
     * @return Optimized ElixirAST using Enum functions, or null if no pattern detected
     */
    static function tryOptimizeArrayPattern(econd: TypedExpr, ebody: TypedExpr): Null<ElixirAST> {
        // Debug: Print the condition to understand its structure
        #if debug_array_patterns
        #if debug_ast_builder
        trace("[Array Pattern] Checking condition: " + haxe.macro.ExprTools.toString(Context.getTypedExpr(econd)));
        #end
        #end
        
        // Simple pattern check for _g1 < _g2.length
        // When Haxe desugars array.map, it creates: _g1 = 0; _g2 = array; while(_g1 < _g2.length)
        var isArrayPattern = false;
        var arrayVarName = "";
        var indexVarName = "";
        
        switch(econd.expr) {
            case TBinop(OpLt, e1, e2):
                switch(e1.expr) {
                    case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
                        switch(e2.expr) {
                            case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
                                // We have _gX < something.length
                                switch(arrayRef.expr) {
                                    case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
                                        // Pattern: _g1 < _g2.length
                                        isArrayPattern = true;
                                        indexVarName = indexVar.name;
                                        arrayVarName = arrayVar.name;
                                        #if debug_array_patterns
                                        #if debug_ast_builder
                                        trace("[Array Pattern] DETECTED: " + indexVarName + " < " + arrayVarName + ".length");
                                        #end
                                        #end
                                    case _:
                                        // Direct array: _g < array.length
                                        isArrayPattern = true;
                                        indexVarName = indexVar.name;
                                }
                            case _:
                        }
                    case _:
                }
            case _:
        }
        
        if (!isArrayPattern) {
            #if debug_array_patterns
            #if debug_ast_builder
            trace("[Array Pattern] No array pattern detected");
            #end
            #end
            return null;
        }
        
        // Delegate to LoopOptimizer for loop body analysis
        var bodyAnalysis = LoopOptimizer.analyzeLoopBody(ebody);
        
        // For _g2 pattern, we need to generate a reference to the actual array variable
        // The actual array should be available as a local variable named _g2
        var arrayExpr = makeAST(EVar(VariableAnalyzer.toElixirVarName(arrayVarName.length > 0 ? arrayVarName : "_g2")));
        
        // Generate appropriate Enum call based on pattern
        if (bodyAnalysis.hasMapPattern) {
            // Generate Enum.map with extracted transformation
            var loopVar = bodyAnalysis.loopVar != null ? VariableAnalyzer.toElixirVarName(bodyAnalysis.loopVar.name) : "item";
            var transformation = LoopOptimizer.extractMapTransformation(ebody, bodyAnalysis.loopVar);
            return EnumHandler.generateEnumMap(arrayExpr, loopVar, transformation, currentContext);
        } else if (bodyAnalysis.hasFilterPattern) {
            // Generate Enum.filter with extracted condition
            var loopVar = bodyAnalysis.loopVar != null ? VariableAnalyzer.toElixirVarName(bodyAnalysis.loopVar.name) : "item";
            var condition = LoopOptimizer.extractFilterCondition(ebody);
            return EnumHandler.generateEnumFilter(arrayExpr, loopVar, condition, currentContext);
        } else if (bodyAnalysis.hasReducePattern) {
            // Reduce patterns are more complex, skip for now
            return null;
        }
        
        // No clear pattern detected, return null to use regular while loop
        return null;
    }
    
    // detectArrayIterationPattern deleted - now delegated to LoopOptimizer
    
    // analyzeLoopBody deleted - now delegated to LoopOptimizer
    
    // extractMapTransformation, extractFilterCondition, containsPush deleted - now delegated to LoopOptimizer
    
    /**
     * Build AST with variable substitution for lambda parameters
     */
    static function buildFromTypedExprWithSubstitution(expr: TypedExpr, loopVar: Null<TVar>): ElixirAST {
        // For now, just use the regular build function
        // TODO: Implement proper variable substitution
        return buildFromTypedExpr(expr, currentContext);
    }
    
    /**
     * Create metadata from TypedExpr
     */
    static function createMetadata(expr: TypedExpr): ElixirMetadata {
        return {
            sourceExpr: expr,
            sourceLine: expr.pos != null ? Context.getPosInfos(expr.pos).min : 0,
            sourceFile: expr.pos != null ? Context.getPosInfos(expr.pos).file : null,
            type: expr.t,
            elixirType: typeToElixir(expr.t),
            purity: PatternDetector.isPure(expr),
            tailPosition: false, // Will be set by transformer
            async: false, // Will be detected by transformer
            requiresReturn: false, // Will be set by context
            requiresTempVar: false, // Will be set by transformer
            inPipeline: false, // Will be set by transformer
            inComprehension: false, // Will be set by context
            inGuard: false, // Will be set by context
            canInline: canBeInlined(expr),
            isConstant: PatternDetector.isConstant(expr),
            sideEffects: hasSideEffects(expr)
        };
    }
    
    /**
     * Convert Haxe values to patterns with extracted parameter names
     * 
     * WHY: Regular enums need access to user-specified variable names from switch cases
     * WHAT: Like convertPattern but uses extractedParams for enum constructor arguments
     * HOW: Delegates to PatternBuilder for centralized pattern handling
     */
    
    
    
    
    /**
    /**
     * Check if an enum has @:elixirIdiomatic metadata
     */
    static function hasIdiomaticMetadata(expr: TypedExpr): Bool {
        // First try the direct field access case
        switch(expr.expr) {
            case TField(_, FEnum(enumRef, _)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for ${enumType.name}: $hasIt');
                #end
                return hasIt;
            case TTypeExpr(TEnumDecl(enumRef)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for enum type expr: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        // Check the return type if this is a function that returns an enum
        switch(expr.t) {
            case TFun(_, ret):
                switch(ret) {
                    case TEnum(enumRef, _):
                        var enumType = enumRef.get();
                        var hasIt = enumType.meta.has(":elixirIdiomatic");
                        #if debug_ast_builder
                        trace('[AST Builder] Checking @:elixirIdiomatic via return type: $hasIt');
                        #end
                        return hasIt;
                    default:
                }
            case TEnum(enumRef, _):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic via direct enum type: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        return false;
    }
    
    // REMOVED buildEnumConstructor - Builder should NOT transform, only build!
    
    
    /**
     * Convert Haxe identifier to Elixir atom name
     * 
     * GENERAL RULE: When Haxe identifiers become Elixir atoms,
     * they should follow Elixir naming conventions (snake_case).
     * This ensures generated code looks idiomatic.
     * 
     * Examples:
     * - OneForOne ‚Üí one_for_one
     * - RestForOne ‚Üí rest_for_one
     * - SimpleOneForOne ‚Üí simple_one_for_one
     */
    static function toElixirAtomName(name: String): String {
        var result = [];
        for (i in 0...name.length) {
            var c = name.charAt(i);
            if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
                result.push("_");
                result.push(c.toLowerCase());
            } else {
                result.push(c.toLowerCase());
            }
        }
        return result.join("");
    }
    
    /**
     * Check if a TypedExpr contains an if statement
     * Used to determine when variable declarations should be preserved
     */
    static function containsIfStatement(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TIf(_, _, _): true;
            case TBlock(el): 
                // Check if any expression in the block is an if statement
                for (e in el) {
                    if (containsIfStatement(e)) return true;
                }
                false;
            case TWhile(_, body, _): containsIfStatement(body);
            case TFor(_, _, body): containsIfStatement(body);
            case TSwitch(_, cases, _):
                for (c in cases) {
                    if (containsIfStatement(c.expr)) return true;
                }
                false;
            case TCall(_, args):
                for (arg in args) {
                    if (containsIfStatement(arg)) return true;
                }
                false;
            case TVar(_, init) if (init != null): containsIfStatement(init);
            case TBinop(_, e1, e2): containsIfStatement(e1) || containsIfStatement(e2);
            case TUnop(_, _, e): containsIfStatement(e);
            case TParenthesis(e): containsIfStatement(e);
            case TMeta(_, e): containsIfStatement(e);
            case TCast(e, _): containsIfStatement(e);
            case TTry(e, catches):
                if (containsIfStatement(e)) return true;
                for (c in catches) {
                    if (containsIfStatement(c.expr)) return true;
                }
                false;
            default: false;
        }
    }
    
    /**
     * Check if type is an array type
     */
    // Delegate to ElixirASTHelpers
    static inline function isArrayType(t: Type): Bool {
        return ElixirASTHelpers.isArrayType(t);
    }
    
    /**
     * Try to expand __elixir__() injection from a method body
     * 
     * WHY: When Array methods contain __elixir__(), we want to inline them
     * to generate idiomatic Elixir instead of method calls
     * 
     * @param methodExpr The method body expression
     * @param thisExpr The 'this' object (the array)
     * @param args The arguments passed to the method
     * @return The expanded Elixir AST or null if no __elixir__ found
     */
    static function tryExpandElixirInjection(methodExpr: TypedExpr, thisExpr: TypedExpr, args: Array<TypedExpr>, context: reflaxe.elixir.CompilationContext): Null<ElixirAST> {
        #if debug_ast_builder
        trace('[AST Builder] tryExpandElixirInjection examining: ${Type.enumConstructor(methodExpr.expr)}');
        #end
        
        // First check if this is a function, and if so, extract its body
        switch(methodExpr.expr) {
            case TFunction(tfunc):
                // Method is a function, check its body
                if (tfunc.expr != null) {
                    return tryExpandElixirInjection(tfunc.expr, thisExpr, args, context);
                }
            default:
        }
        
        // Look for return statement with __elixir__()
        switch(methodExpr.expr) {
            case TReturn(retOpt):
                // Check if there's a return value
                if (retOpt != null) {
                    return tryExpandElixirCall(retOpt, thisExpr, args, context);
                }
                
            case TBlock(exprs):
                // First, scan for a local var initialized via __elixir__() and expand it.
                // This covers patterns like:
                //   var query = __elixir__("(require Ecto.Query; Ecto.Query.from(...))", ...);
                //   return new TypedQuery(query)
                for (e in exprs) {
                    switch (e.expr) {
                        case TVar(_, init) if (init != null):
                            var expanded = tryExpandElixirCall(init, thisExpr, args, context);
                            if (expanded != null) {
                                return expanded;
                            }
                        default:
                    }
                }
                // Otherwise check the last expression (implicit return)
                if (exprs.length > 0) {
                    var lastExpr = exprs[exprs.length - 1];
                    return tryExpandElixirCall(lastExpr, thisExpr, args, context);
                }
                
            case TIf(cond, ifExpr, elseExpr):
                // Handle conditional __elixir__() calls (like in slice method)
                // We need to evaluate the condition and choose the right branch
                // For now, we'll try to detect if both branches have __elixir__
                var ifResult = tryExpandElixirCall(ifExpr, thisExpr, args, context);
                if (ifResult != null) {
                    // Both branches likely have __elixir__, create conditional
                    var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, args, context) : null;
                    if (elseResult != null) {
                        // Build conditional with expanded branches
                        var condAst = buildFromTypedExpr(cond, context);
                        return makeAST(EIf(condAst, ifResult, elseResult));
                    }
                    // Only if branch has __elixir__
                    return ifResult;
                }
                
            case TCall(_):
                // Direct call, check if it's __elixir__
                return tryExpandElixirCall(methodExpr, thisExpr, args, context);
                
            default:
        }
        return null;
    }
    
    // detectFluentAPIPattern deleted - now delegated to LoopOptimizer
    
    /**
     * Try to expand a specific __elixir__() call
     */
    static function tryExpandElixirCall(expr: TypedExpr, thisExpr: TypedExpr, methodArgs: Array<TypedExpr>, context: reflaxe.elixir.CompilationContext): Null<ElixirAST> {
        #if debug_elixir_injection
        #if debug_ast_builder
        trace("[XRay] tryExpandElixirCall checking expr type: " + expr.expr);
        #end
        #end
        
        switch(expr.expr) {
            // Handle return statements that wrap the actual call
            case TReturn(retExpr) if (retExpr != null):
                #if debug_elixir_injection
                #if debug_ast_builder
                trace("[XRay] Found TReturn wrapper, checking inner: " + retExpr.expr);
                #end
                #end
                return tryExpandElixirCall(retExpr, thisExpr, methodArgs, context);
                
            // Handle untyped __elixir__() calls (wrapped in metadata)
            case TMeta({name: ":untyped"}, untypedExpr):
                #if debug_elixir_injection
                #if debug_ast_builder
                trace("[XRay] Found untyped metadata, checking inner: " + untypedExpr.expr);
                #end
                #end
                return tryExpandElixirCall(untypedExpr, thisExpr, methodArgs, context);
                
            // Handle if-else statements with __elixir__() in branches
            case TIf(cond, ifExpr, elseExpr):
                #if debug_elixir_injection
                #if debug_ast_builder
                trace("[XRay] Found TIf in tryExpandElixirCall");
                #end
                #end
                var ifResult = tryExpandElixirCall(ifExpr, thisExpr, methodArgs, context);
                var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, methodArgs, context) : null;
                if (ifResult != null && elseResult != null) {
                    // Both branches have __elixir__, create conditional
                    var condAst = buildFromTypedExpr(cond, context);
                    return makeAST(EIf(condAst, ifResult, elseResult));
                } else if (ifResult != null) {
                    return ifResult;
                } else if (elseResult != null) {
                    return elseResult;
                }
                
            case TCall(e, callArgs):
                #if debug_elixir_injection
                #if debug_ast_builder
                trace("[XRay] TCall with target: " + e.expr);
                #end
                #end
                switch(e.expr) {
                    case TIdent("__elixir__"):
                        #if debug_elixir_injection
                        #if debug_ast_builder
                        trace("[XRay] Found __elixir__() call!");
                        #end
                        #end
                        // Found __elixir__() call!
                        if (callArgs.length > 0) {
                            // First argument should be the code string
                            switch(callArgs[0].expr) {
                                case TConst(TString(code)):
                                    // Presence fast-path: build pure AST for Phoenix.Presence calls
                                    // to expose effectful statements to downstream passes.
                                    inline function resolvePresenceModuleName(): String {
                                        var moduleName = "Phoenix.Presence";
                                        if (currentContext != null && currentContext.currentModuleHasPresence == true) {
                                            var appModulePrefix: Null<String> = null;
                                            if (currentModule != null) {
                                                var webIndex = currentModule.indexOf("Web");
                                                if (webIndex > 0) appModulePrefix = currentModule.substring(0, webIndex);
                                            }
                                            if (appModulePrefix == null) {
                                                try appModulePrefix = reflaxe.elixir.PhoenixMapper.getAppModuleName() catch (e:Dynamic) {}
                                            }
                                            if (appModulePrefix != null) moduleName = appModulePrefix + "Web.Presence";
                                        }
                                        return moduleName;
                                    }
                                    var presenceModuleName = resolvePresenceModuleName();
                                    // Helper to build Nth argument safely
                                    inline function buildArgAt(index:Int): ElixirAST {
                                        return (index < callArgs.length) ? buildFromTypedExpr(callArgs[index], currentContext) : makeAST(ENil);
                                    }
                                    if (StringTools.startsWith(code, "Phoenix.Presence.track")) {
                                        var socketOrPidAst = buildArgAt(1);
                                        var topicAst = buildArgAt(2);
                                        var keyAst = buildArgAt(3);
                                        var metaAst = buildArgAt(4);
                                        return makeAST(ERemoteCall(makeAST(EVar(presenceModuleName)), "track", [socketOrPidAst, topicAst, keyAst, metaAst]));
                                    } else if (StringTools.startsWith(code, "Phoenix.Presence.update")) {
                                        var socketOrPidUpdateAst = buildArgAt(1);
                                        var topicUpdateAst = buildArgAt(2);
                                        var keyUpdateAst = buildArgAt(3);
                                        var metaUpdateAst = buildArgAt(4);
                                        return makeAST(ERemoteCall(makeAST(EVar(presenceModuleName)), "update", [socketOrPidUpdateAst, topicUpdateAst, keyUpdateAst, metaUpdateAst]));
                                    } else if (StringTools.startsWith(code, "Phoenix.Presence.untrack")) {
                                        var socketOrPidUntrackAst = buildArgAt(1);
                                        var topicUntrackAst = buildArgAt(2);
                                        var keyUntrackAst = buildArgAt(3);
                                        return makeAST(ERemoteCall(makeAST(EVar(presenceModuleName)), "untrack", [socketOrPidUntrackAst, topicUntrackAst, keyUntrackAst]));
                                    } else if (StringTools.startsWith(code, "Phoenix.Presence.list")) {
                                        var listTopicAst = buildArgAt(1);
                                        return makeAST(ERemoteCall(makeAST(EVar(presenceModuleName)), "list", [listTopicAst]));
                                    }
                                    #if debug_elixir_injection
                                    #if debug_ast_builder
                                    trace('[XRay] Expanding __elixir__ with code: $code');
                                    #end
                                    #end
                                    // Process the injection with proper string interpolation handling
                                    var processedCode = "";
                                    var insideString = false;
                                    var i = 0;

                                    // Process character by character to detect quote state
                                    while (i < code.length) {
                                        var char = code.charAt(i);

                                        // Track string state
                                        if (char == '"' && (i == 0 || code.charAt(i-1) != '\\')) {
                                            insideString = !insideString;
                                            processedCode += char;
                                            i++;
                                            continue;
                                        }

                                        // Check for {N} placeholder
                                        if (char == '{' && i + 1 < code.length) {
                                            var j = i + 1;
                                            var numStr = "";

                                            // Collect digits
                                            while (j < code.length && code.charAt(j) >= '0' && code.charAt(j) <= '9') {
                                                numStr += code.charAt(j);
                                                j++;
                                            }

                                            // Check if we found a valid placeholder
                                            if (numStr != "" && j < code.length && code.charAt(j) == '}') {
                                                final num = Std.parseInt(numStr);
                                                var argStr:String = null;

                                                // Special case: {0} refers to 'this' (the array/object)
                                                if (num == 0) {
                                                    var thisAst = buildFromTypedExpr(thisExpr, context);
                                                    argStr = ElixirASTPrinter.printAST(thisAst);
                                                }
                                                // Other numbers refer to method arguments
                                                else if (num != null && num - 1 < methodArgs.length) {
                                                    var argAst = buildFromTypedExpr(methodArgs[num - 1], context);
                                                    argStr = ElixirASTPrinter.printAST(argAst);
                                                }

                                                // If we got an argument string, substitute it
                                                if (argStr != null) {
                                                    if (insideString) {
                                                        // Inside string: wrap in #{...} for interpolation
                                                        processedCode += '#{$argStr}';
                                                    } else {
                                                        // Outside string: direct substitution
                                                        processedCode += argStr;
                                                    }

                                                    // Skip past the placeholder
                                                    i = j + 1;
                                                    continue;
                                                }
                                            }
                                        }

                                        // Regular character - just append
                                        processedCode += char;
                                        i++;
                                    }
                                    
                                    #if debug_elixir_injection
                                    #if debug_ast_builder
                                    trace('[XRay] Processed code: $processedCode');
                                    #end
                                    #end
                                    
                                    // Collect variable references from substituted argument ASTs
                                    var referencedVars = new Map<String, Bool>();

                                    inline function collectVars(ast: ElixirAST): Void {
                                        if (ast == null) return;
                                        ElixirASTTransformer.transformNode(ast, function(x: ElixirAST): ElixirAST {
                                            switch (x.def) {
                                                case EVar(v): referencedVars.set(v, true);
                                                default:
                                            }
                                            return x;
                                        });
                                    }

                                    // Scan all method arguments for variable references
                                    // Note: 'thisAst' and each 'argAst' were built above when substituting
                                    // We conservatively rebuild to ensure coverage
                                    var tmpThisAst = buildFromTypedExpr(thisExpr, context);
                                    collectVars(tmpThisAst);
                                    for (mi in 0...methodArgs.length) {
                                        var tmpArgAst = buildFromTypedExpr(methodArgs[mi], context);
                                        collectVars(tmpArgAst);
                                    }

                                    // Prepare metadata with raw variable references
                                    var meta: Dynamic = {};
                                    var names: Array<String> = [];
                                    for (k in referencedVars.keys()) names.push(k);
                                    Reflect.setField(meta, "rawVarRefs", names);

                                    // Return the expanded raw Elixir code with metadata for hygiene
                                    return makeASTWithMeta(ERaw(processedCode), meta, expr.pos);
                                    
                                default:
                                    #if debug_elixir_injection
                                    #if debug_ast_builder
                                    trace("[XRay] First arg is not TString: " + callArgs[0].expr);
                                    #end
                                    #end
                            }
                        }
                    default:
                        #if debug_elixir_injection
                        #if debug_ast_builder
                        trace("[XRay] Not __elixir__, it's: " + e.expr);
                        #end
                        #end
                }
            default:
                #if debug_elixir_injection
                #if debug_ast_builder
                trace("[XRay] Not a call, it's: " + expr.expr);
                #end
                #end
        }
        return null;
    }
    
    /**
     * Check if type is a Map type
     */
    // Delegate to ElixirASTHelpers (note: simplified implementation there)
    static inline function isMapType(t: Type): Bool {
        return ElixirASTHelpers.isMapType(t);
    }
    
    
    /**
     * Convert assignment operator to binary operator
     */
    static function convertAssignOp(op: Binop): EBinaryOp {
        return switch(op) {
            case OpAdd: Add;
            case OpSub: Subtract;
            case OpMult: Multiply;
            case OpDiv: Divide;
            case OpMod: Remainder;
            case OpAnd: BitwiseAnd;
            case OpOr: BitwiseOr;
            case OpXor: BitwiseXor;
            case OpShl: ShiftLeft;
            case OpShr: ShiftRight;
            default: Add; // Fallback
        }
    }
    
    /**
     * Apply parameter renaming to an AST node
     * This is used when function parameters are renamed (e.g., "this" -> "this_1")
     * to ensure the body references the correct parameter names
     */
    static function applyParameterRenaming(ast: ElixirAST, renaming: Map<String, String>): ElixirAST {
        return switch(ast.def) {
            case EVar(name):
                if (renaming.exists(name)) {
                    makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
                } else {
                    ast;
                }
            
            // Recursively apply to all child nodes
            case EBlock(exprs):
                makeASTWithMeta(EBlock(exprs.map(e -> applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);
            
            case ECall(target, func, args):
                makeASTWithMeta(
                    ECall(
                        target != null ? applyParameterRenaming(target, renaming) : null,
                        func,
                        args.map(a -> applyParameterRenaming(a, renaming))
                    ),
                    ast.metadata, ast.pos
                );
            
            case EBinary(op, left, right):
                makeASTWithMeta(
                    EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)),
                    ast.metadata, ast.pos
                );
            
            case EUnary(op, expr):
                makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);
            
            case EIf(cond, then, else_):
                makeASTWithMeta(
                    EIf(
                        applyParameterRenaming(cond, renaming),
                        applyParameterRenaming(then, renaming),
                        else_ != null ? applyParameterRenaming(else_, renaming) : null
                    ),
                    ast.metadata, ast.pos
                );
                
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(
                        applyParameterRenaming(expr, renaming),
                        clauses.map(c -> {
                            pattern: c.pattern,  // Don't rename in patterns
                            guard: c.guard != null ? applyParameterRenaming(c.guard, renaming) : null,
                            body: applyParameterRenaming(c.body, renaming)
                        })
                    ),
                    ast.metadata, ast.pos
                );
            
            // For other node types, return as-is (can be extended as needed)
            default:
                ast;
        }
    }
    
    /**
     * Convert variable name to Elixir convention
     * Preserves special Elixir constants like __MODULE__, __FILE__, __ENV__
     */
    /**
     * Check if a variable name looks like a camelCase parameter
     * These are typically function parameters that should remain as-is
     */
    static function isCamelCaseParameter(name: String): Bool {
        if (name.length < 2) return false;
        
        // Check if it starts with lowercase and has uppercase letters
        var firstChar = name.charAt(0);
        if (firstChar != firstChar.toLowerCase()) return false;
        
        // Check if it contains uppercase letters (indicating camelCase)
        for (i in 1...name.length) {
            var char = name.charAt(i);
            if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
                return true; // Found uppercase letter, it's camelCase
            }
        }
        
        return false;
    }
    

    /**
     * Checks if a variable name is a Haxe compiler-generated temporary variable.
     * 
     * WHY THESE 'G' VARIABLES EXIST:
     * --------------------------------
     * These are NOT created by Reflaxe.Elixir - they're generated by Haxe itself during compilation.
     * When Haxe compiles certain expressions (especially switch expressions that return values),
     * it creates temporary variables to ensure proper evaluation order and prevent side effects.
     * 
     * PATTERN EXPLANATION:
     * - 'g' or '_g': First temporary in a scope
     * - 'g1', 'g2', etc.: Additional temporaries when multiple are needed
     * - '_g1', '_g2': Underscore variants (sometimes for unused values)
     * 
     * EXAMPLE TRANSFORMATION:
     * ```haxe
     * // Original Haxe code:
     * var result = switch(parseMessage(msg)) {
     *     case Some(x): processMessage(x);
     *     case None: defaultValue;
     * }
     * 
     * // Haxe internally transforms to:
     * var _g = parseMessage(msg);  // Temporary to hold switch target
     * var result = switch(_g) {
     *     case Some(x): processMessage(x);
     *     case None: defaultValue;
     * }
     * ```
     * 
     * WHY NOT RENAME THEM:
     * 1. Risk of name collisions with user variables
     * 2. Other Haxe compilation passes expect these names
     * 3. They're recognizable to Haxe developers as compiler-generated
     * 4. They have no semantic meaning - purely mechanical temporaries
     * 
     * @param name The variable name to check
     * @return True if this is a Haxe-generated temporary variable
     */
    public static function isTempPatternVarName(name: String): Bool {
        if (name == null || name.length == 0) {
            return false;
        }

        function isDigits(str: String): Bool {
            if (str == null || str.length == 0) {
                return false;
            }
            for (i in 0...str.length) {
                var c = str.charAt(i);
                if (c < '0' || c > '9') {
                    return false;
                }
            }
            return true;
        }

        function check(candidate: String): Bool {
            if (candidate == null || candidate.length == 0) {
                return false;
            }
            // Standard Haxe temporary variable patterns
            if (candidate == "g" || candidate == "_g") {
                return true;
            }
            // Numbered variants: g1, g2, g3...
            if (candidate.length > 1 && candidate.charAt(0) == "g" && isDigits(candidate.substr(1))) {
                return true;
            }
            // Underscore numbered variants: _g1, _g2, _g3...
            if (candidate.length > 2 && candidate.charAt(0) == "_" && candidate.charAt(1) == "g" && isDigits(candidate.substr(2))) {
                return true;
            }
            return false;
        }

        if (check(name)) {
            return true;
        }

        var canonical = ElixirNaming.toVarName(name);
        if (canonical != name && check(canonical)) {
            return true;
        }

        return false;
    }
    
    /**
     * Extract field name from FieldAccess
     */
    public static function extractFieldName(fa: FieldAccess): String {
        return switch(fa) {
            case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
                cf.get().name;
            case FDynamic(s):
                s;
            case FEnum(_, ef):
                ef.name;
        }
    }
    
    /**
     * Create variable mappings for alpha-renaming in case clauses
     *
     * WHY: Haxe's optimizer creates temporary variables (g, g1, etc.) for enum parameters
     *      but our patterns use canonical names (value, error, etc.). We need to map
     *      the temp var IDs to the canonical names for proper code generation.
     *
     * WHAT: Creates a Map<Int, String> that maps TVar.id to the canonical pattern name
     *
     * HOW: Analyzes the case body to find TVar declarations that extract enum parameters
     *      and builds a mapping from the temp var IDs to the canonical names from the pattern
     *
     * M0.2: Now uses EnumBindingPlan as the authoritative source for variable names
     */
    static function createVariableMappingsForCase(caseExpr: TypedExpr, extractedParams: Array<String>,
                                                   enumType: Null<EnumType>, values: Array<TypedExpr>,
                                                   enumBindingPlan: Map<Int, {finalName: String, isUsed: Bool}> = null): Map<Int, String> {
        var mapping = new Map<Int, String>();
        
        #if debug_ast_pipeline
        #if debug_ast_builder
        trace('[createVariableMappingsForCase] Called with extractedParams: $extractedParams, enumType: ${enumType != null ? enumType.name : "null"}');
        #end
        #end
        
        // For non-enum cases, still need to track variable mappings for abstract types
        // This ensures abstract type methods use the correct renamed variables
        if (enumType == null) {
            // Scan for variable assignments that might be renamings
            // e.g., email = value (where value comes from a pattern)
            function scanForVariableAssignments(expr: TypedExpr): Void {
                switch(expr.expr) {
                    case TBlock(exprs):
                        for (e in exprs) scanForVariableAssignments(e);
                        
                    case TVar(v, init) if (init != null):
                        switch(init.expr) {
                            case TLocal(sourceVar):
                                // For non-enum cases (like array patterns), don't create mappings
                                // Array patterns like [x, y] need to preserve x = g, y = g1
                                // We DON'T want to map g to x, because then we get x = x
                                // Just let the natural variable names flow through
                                #if debug_ast_pipeline
                                #if debug_ast_builder
                                trace('[Alpha-renaming] Skipping mapping for non-enum TLocal: ${v.name} = ${sourceVar.name}');
                                #end
                                #end
                                
                            default:
                        }
                        
                    default:
                        haxe.macro.TypedExprTools.iter(expr, scanForVariableAssignments);
                }
            }
            
            scanForVariableAssignments(caseExpr);
            return mapping;
        }
        
        // For both regular and idiomatic enums, we need to map TEnumParameter extractions
        // The difference is how we determine the target names:
        // - Idiomatic enums: Use extractedParams (generic names like g, g1, g2)
        // - Regular enums: Use canonical names from enum definition (r, g, b)
        
        // Get the constructor for this case
        if (values.length > 0) {
            switch(values[0].expr) {
                case TConst(TInt(index)):
                    // Get constructor at this index
                    var constructors = [];
                    for (name in enumType.constructs.keys()) {
                        var constructor = enumType.constructs.get(name);
                        constructors[constructor.index] = constructor;
                    }
                    
                    if (index >= 0 && index < constructors.length && constructors[index] != null) {
                        var constructor = constructors[index];
                        
                        // Get the canonical parameter names from the constructor
                        var canonicalNames = switch(constructor.type) {
                            case TFun(args, _):
                                [for (arg in args) arg.name];
                            default:
                                [];
                        };
                        
                        // Track which variables come from enum extraction
                        var enumExtractionVars = new Map<Int, Bool>();
                        
                        // Now scan the case body to find TVar declarations
                        function scanForTVars(expr: TypedExpr): Void {
                            switch(expr.expr) {
                                case TBlock(exprs):
                                    for (e in exprs) scanForTVars(e);
                                    
                                case TVar(v, init) if (init != null):
                                    switch(init.expr) {
                                        case TEnumParameter(_, _, paramIndex):
                                            // M0.2 FIX: Use EnumBindingPlan as the single source of truth
                                            // The binding plan already decided the final name for this parameter

                                            var finalName: String;

                                            if (enumBindingPlan != null && enumBindingPlan.exists(paramIndex)) {
                                                // Use the authoritative name from EnumBindingPlan
                                                finalName = enumBindingPlan.get(paramIndex).finalName;

                                                #if debug_ast_pipeline
                                                #if debug_ast_builder
                                                trace('[M0.2] Using EnumBindingPlan name for param ${paramIndex}: ${finalName}');
                                                #end
                                                #end
                                            } else {
                                                // Fallback if no binding plan (shouldn't happen after M0.1)
                                                var varName = VariableAnalyzer.toElixirVarName(v.name);
                                                if (varName.startsWith("_g")) {
                                                    varName = varName.substr(1); // _g -> g
                                                }
                                                finalName = varName;

                                                #if debug_ast_pipeline
                                                #if debug_ast_builder
                                                trace('[M0.2 WARNING] No EnumBindingPlan for param ${paramIndex}, using fallback: ${finalName}');
                                                #end
                                                #end
                                            }

                                            // Map this variable ID to the binding plan's final name
                                            mapping.set(v.id, finalName);

                                            // Mark this variable as coming from enum extraction
                                            enumExtractionVars.set(v.id, true);

                                            #if debug_ast_pipeline
                                            #if debug_ast_builder
                                            trace('[M0.2] Mapping TEnumParameter temp var ${v.name} (id=${v.id}) to binding plan name: ${finalName}');
                                            #end
                                            #end
                                            
                                        case TLocal(tempVar):
                                            // This is assignment from temp var to pattern var
                                            var tempVarName = VariableAnalyzer.toElixirVarName(tempVar.name);
                                            var patternVarName = VariableAnalyzer.toElixirVarName(v.name);
                                            
                                            // Check if the temp var is from enum extraction
                                            // ONLY apply special mapping for enum-related temp vars
                                            if (enumExtractionVars.exists(tempVar.id)) {
                                                // This IS an enum extraction temp var (like g from TEnumParameter)
                                                // The pattern variable should use its own name (data = g, then use 'data')
                                                mapping.set(v.id, patternVarName);
                                                
                                                #if debug_ast_pipeline
                                                #if debug_ast_builder
                                                trace('[Alpha-renaming] Enum pattern var assignment: ${patternVarName} = ${tempVarName}, mapping ${v.id} -> ${patternVarName}');
                                                #end
                                                #end
                                            } else if (mapping.exists(tempVar.id)) {
                                                // For other assignments, propagate the mapping
                                                var canonicalName = mapping.get(tempVar.id);
                                                mapping.set(v.id, canonicalName);
                                                
                                                // Also register in pattern registry if tempVar is registered
                                                if (currentContext.patternVariableRegistry.exists(tempVar.id)) {
                                                    currentContext.patternVariableRegistry.set(v.id, canonicalName);
                                                    #if debug_ast_pipeline
                                                    #if debug_ast_builder
                                                    trace('[Pattern Registry] Propagating pattern name to ${v.name} (id=${v.id}) -> ${canonicalName}');
                                                    #end
                                                    #end
                                                }
                                                
                                                #if debug_ast_pipeline
                                                #if debug_ast_builder
                                                trace('[Alpha-renaming] Mapping TVar ${v.name} (id=${v.id}) from temp ${tempVar.name} to: ${canonicalName}');
                                                #end
                                                #end
                                            } else {
                                                // No existing mapping - DON'T create one for non-enum cases
                                                // Array patterns should use their natural names
                                                // We don't need to map x to anything - it should use its own name
                                                #if debug_ast_pipeline
                                                #if debug_ast_builder
                                                trace('[Alpha-renaming] No mapping needed for TVar ${v.name} from ${tempVar.name}');
                                                #end
                                                #end
                                            }
                                            
                                        default:
                                    }
                                    
                                default:
                                    haxe.macro.TypedExprTools.iter(expr, scanForTVars);
                            }
                        }
                        
                        scanForTVars(caseExpr);
                    }
                    
                default:
            }
        }
        
        return mapping;
    }
    
    /**
     * Convert camelCase to snake_case
     */
    
    /**
     * Collect template content from HXX.hxx() argument
     * 
     * WHY: HXX.hxx() calls with string interpolation (${expr}) get compiled to
     *      string concatenation operations by Haxe. We need to collect all the
     *      pieces to build the complete template for the ~H sigil.
     * 
     * WHAT: Recursively collects and concatenates all string pieces from both
     *       simple strings and binary concatenation operations.
     * 
     * HOW: Handles EString directly and recursively processes EBinary(StringConcat)
     *      to collect all concatenated parts into a single template string.
     * 
     * Example: HXX.hxx('Hello ${name}') becomes concatenation that we collect into one template
     */
    // Delegate to TemplateHelpers
    static inline function collectTemplateContent(ast: ElixirAST): String {
        var raw = TemplateHelpers.collectTemplateContent(ast);
        // Rewrite HXX control tags (<if>/<else>) to proper HEEx blocks early,
        // so downstream passes operate on valid HEEx content.
        #if (macro || reflaxe_runtime)
        raw = reflaxe.elixir.ast.transformers.HeexControlTagTransforms.rewrite(raw);
        #end
        return raw;
    }
    
    // Delegate to TemplateHelpers
    static inline function collectTemplateArgument(ast: ElixirAST): String {
        return TemplateHelpers.collectTemplateArgument(ast);
    }
    
    /**
     * Check if expression is the HXX module (for Phoenix HEEx template processing)
     * 
     * WHY: HXX.hxx() is a compile-time macro that processes JSX-like template strings
     *      and converts them to Phoenix HEEx format. After macro expansion, we get a 
     *      processed string that needs to be wrapped in a ~H sigil for LiveView.
     * 
     * WHAT: Detects when a TTypeExpr refers to the HXX module class, which indicates
     *       we're about to handle an HXX.hxx() template call that needs special treatment.
     * 
     * HOW: Checks if the module type expression resolves to "HXX" by name.
     * 
     * Example: HXX.hxx("<div>Hello <%= @name %></div>") ‚Üí ~H"""<div>Hello <%= @name %></div>"""
     */
    // Delegate to TemplateHelpers
    static inline function isHXXModule(expr: TypedExpr): Bool {
        return TemplateHelpers.isHXXModule(expr);
    }
    
    /**
     * Check if expression is the Assert class (for ExUnit assertions)
     */
    static function isAssertClass(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(TClassDecl(classRef)):
                // Check if this is haxe.test.Assert
                var classType = classRef.get();
                var pack = classType.pack.join(".");
                var name = classType.name;
                pack == "haxe.test" && name == "Assert";
            default: false;
        }
    }
    
    /**
     * Check if expression is a module call
     */
    static function isModuleCall(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(_): true;
            default: false;
        }
    }
    
    /**
     * Check if type represents a map/struct
     */
    // Delegate to ElixirASTHelpers (simplified implementation)
    static inline function isMapAccess(t: Type): Bool {
        return ElixirASTHelpers.isMapAccess(t);
    }

    /**
     * If a type is an extern Elixir class with @:native, return its module name.
     */
    static function getExternNativeModuleNameFromType(t: Type): Null<String> {
        return switch(t) {
            case TInst(cRef, _):
                var c = cRef.get();
                if (c.isExtern && c.meta.has(":native")) {
                    var meta = c.meta.extract(":native");
                    if (meta.length > 0 && meta[0].params != null && meta[0].params.length > 0) {
                        switch(meta[0].params[0].expr) {
                            case EConst(CString(s, _)):
                                s;
                            default:
                                null;
                        }
                    } else null;
                } else null;
            case _:
                null;
        }
    }
    
    /**
     * Convert module type to string
     * Handles package-based module naming (e.g., ecto.Query ‚Üí Query for non-externs, Ecto.Query for externs)
     */
    static function moduleTypeToString(m: ModuleType): String {
        // Get the basic name first
        var name = switch(m) {
            case TClassDecl(c): c.get().name;
            case TEnumDecl(e): e.get().name;
            case TTypeDecl(t): t.get().name;
            case TAbstract(a): a.get().name;
        }
        
        // Check if this is an extern class - only externs should get package prefixes
        var isExtern = switch(m) {
            case TClassDecl(c): c.get().isExtern;
            default: false;
        };
        
        // Get the package information
        var pack = switch(m) {
            case TClassDecl(c): c.get().pack;
            case TEnumDecl(e): e.get().pack;
            case TTypeDecl(t): t.get().pack;
            case TAbstract(a): a.get().pack;
        }
        
        // Special handling for framework packages that should use proper Elixir module names
        if (pack.length > 0) {
            // Don't add package prefix for implementation classes (_Impl_)
            // These are compiler-generated and should not have the package prefix
            if (name.endsWith("_Impl_") || name.contains("_Impl_")) {
                return name;  // Return just the name without package prefix
            }
            
            // For non-extern application classes, qualify with App module prefix
            // e.g., server.schemas.Todo ‚Üí TodoApp.Todo (using -D app_name)
            if (!isExtern) {
                var app = reflaxe.elixir.PhoenixMapper.getAppModuleName();
                return (app != null && app.length > 0 ? (app + "." + name) : name);
            }
            
            // For extern classes, add the package prefix for proper Elixir module references
            switch(pack[0]) {
                case "ecto":
                    // Extern ecto modules should become Ecto.Module
                    return "Ecto." + name;
                case "phoenix":
                    // Extern phoenix modules should become Phoenix.Module
                    return "Phoenix." + name;
                case "plug":
                    // Extern plug modules should become Plug.Module
                    return "Plug." + name;
                default:
                    // Other packages keep their structure
            }
        }
        
        return name;
    }

    /**
     * Count occurrences of a variable name in an ElixirAST tree.
     */
    // Delegate to ElixirASTHelpers
    static inline function countVarOccurrencesInAST(ast: ElixirAST, name: String): Int {
        return ElixirASTHelpers.countVarOccurrencesInAST(ast, name);
    }

    /**
     * Replace all occurrences of a variable name with a replacement AST (wrapped in parentheses).
     */
    // Delegate to ElixirASTHelpers
    static inline function replaceVarInAST(ast: ElixirAST, name: String, replacement: ElixirAST): ElixirAST {
        return ElixirASTHelpers.replaceVarInAST(ast, name, replacement);
    }
    
    /**
     * Convert Haxe type to Elixir type string
     */
    static function typeToElixir(t: Type): String {
        if (t == null) return "any"; // Handle null types gracefully
        return switch(t) {
            case TInst(_.get() => {name: "String"}, _): "binary";
            case TInst(_.get() => {name: "Array"}, _): "list";
            case TAbstract(_.get() => {name: "Int"}, _): "integer";
            case TAbstract(_.get() => {name: "Float"}, _): "float";
            case TAbstract(_.get() => {name: "Bool"}, _): "boolean";
            case TDynamic(_): "any";
            default: "term";
        }
    }
    
    /**
     * Check if expression is pure (no side effects)
     */
    static function isPure(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_) | TTypeExpr(_): true;
            case TBinop(_, e1, e2): isPure(e1) && isPure(e2);
            case TUnop(_, _, e): isPure(e);
            case TField(e, _): isPure(e);
            case TParenthesis(e): isPure(e);
            default: false;
        }
    }
    
    /**
     * Check if expression can be inlined
     */
    static function canBeInlined(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_): true;
            case TBinop(_, e1, e2): canBeInlined(e1) && canBeInlined(e2);
            case TUnop(_, _, e): canBeInlined(e);
            default: false;
        }
    }
    
    /**
     * Check if expression is constant
     */
    static function isConstant(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_): true;
            default: false;
        }
    }
    
    /**
     * Check if expression has side effects
     */
    static function hasSideEffects(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TCall(_, _) | TNew(_, _, _) | TVar(_, _): true;
            case TBinop(OpAssign | OpAssignOp(_), _, _): true;
            case TUnop(OpIncrement | OpDecrement, _, _): true;
            case TThrow(_): true;
            default: false;
        }
    }
    
    /**
     * Check if an initialization expression is simple enough for VariableBuilder
     * 
     * WHY: Complex initializations (blocks, comprehensions) need special handling
     * WHAT: Identifies simple init patterns that VariableBuilder can handle
     * HOW: Checks expression type against simple patterns
     */
    static function isSimpleInit(init: TypedExpr): Bool {
        if (init == null) return true;
        
        return switch(init.expr) {
            case TConst(_): true;
            case TLocal(_): true;
            case TField(_, _): true;
            case TCall(_, _): true;
            case TNew(_, _, _): true;
            case TObjectDecl(_): true;
            case TArrayDecl(_): true;
            case TBinop(_, _, _): true;
            case TUnop(_, _, _): true;
            case TParenthesis(e): isSimpleInit(e);
            case TCast(e, _): isSimpleInit(e);
            case TMeta(_, e): isSimpleInit(e);
            // Complex patterns that need special handling
            case TBlock(_): false;
            case TIf(_, _, _): false;
            case TSwitch(_, _, _): false;
            case TWhile(_, _, _): false;
            case TFor(_, _, _): false;
            case TTry(_, _): false;
            case TFunction(_): false;
            default: true;
        };
    }
    
    /**
     * Check if a variable name is used within an ElixirAST
     * 
     * WHY: Need to detect unused variables in reduce_while patterns to prefix with underscore
     * WHAT: Recursively searches ElixirAST for EVar references to the given variable name
     * HOW: Pattern matches on all ElixirAST node types that can contain variables
     * 
     * @param varName The variable name to search for
     * @param ast The AST to search within
     * @return true if the variable is referenced, false otherwise
     */
    static function isVariableUsedInAST(varName: String, ast: ElixirAST): Bool {
        if (ast == null) return false;
        
        return switch(ast.def) {
            case EVar(name): name == varName;
            case EBlock(exprs): 
                for (e in exprs) {
                    if (isVariableUsedInAST(varName, e)) return true;
                }
                false;
            case EIf(cond, thenBranch, elseBranch):
                isVariableUsedInAST(varName, cond) || 
                isVariableUsedInAST(varName, thenBranch) || 
                (elseBranch != null && isVariableUsedInAST(varName, elseBranch));
            case ETuple(values):
                for (v in values) {
                    if (isVariableUsedInAST(varName, v)) return true;
                }
                false;
            case EList(values):
                for (v in values) {
                    if (isVariableUsedInAST(varName, v)) return true;
                }
                false;
            case EBinary(_, left, right):
                isVariableUsedInAST(varName, left) || isVariableUsedInAST(varName, right);
            case ECall(target, funcName, args):
                if (target != null && isVariableUsedInAST(varName, target)) return true;
                for (a in args) {
                    if (isVariableUsedInAST(varName, a)) return true;
                }
                false;
            case ERemoteCall(module, func, args):
                if (isVariableUsedInAST(varName, module)) return true;
                for (a in args) {
                    if (isVariableUsedInAST(varName, a)) return true;
                }
                false;
            case EFn(clauses):
                for (c in clauses) {
                    if (isVariableUsedInAST(varName, c.body)) return true;
                    if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
                }
                false;
            case ECase(expr, clauses):
                if (isVariableUsedInAST(varName, expr)) return true;
                for (c in clauses) {
                    if (isVariableUsedInAST(varName, c.body)) return true;
                    if (c.guard != null && isVariableUsedInAST(varName, c.guard)) return true;
                }
                false;
            case EAssign(name):
                name == varName;
            case _: false; // Other node types don't contain variable references
        };
    }
    
    /**
     * Detect array operation pattern in while loop body
     * 
     * WHY: Haxe desugars array operations (map/filter) into imperative while loops
     * that manually build arrays with push operations. We need to detect these
     * patterns to generate idiomatic Elixir Enum calls instead of Y-combinator loops.
     * 
     * WHAT: Analyzes the loop body to determine if it's a map, filter, or other
     * array transformation operation.
     * 
     * HOW: Looks for characteristic patterns like:
     * - var v = array[index]; index++; result.push(transform(v)) -> map
     * - var v = array[index]; index++; if(condition) result.push(v) -> filter
     * 
     * @return The type of array operation detected, or null if not an array pattern
     */
    // detectArrayOperationPattern deleted - now delegated to LoopOptimizer
    
    /**
     * Generate idiomatic Enum call for array operation
     * 
     * WHY: Instead of generating Y-combinator recursive functions for array operations,
     * we want to generate clean, idiomatic Elixir Enum.map/filter/reduce calls.
     * 
     * WHAT: Transforms the detected array pattern into the appropriate Enum call.
     * 
     * HOW: Extracts the transformation/filter function from the loop body and
     * generates the corresponding Enum call with a lambda function.
     * 
     * @param arrayRef The array being iterated over (_g2 in the pattern)
     * @param operation The type of operation ("map", "filter", etc.)
     * @param body The loop body containing the transformation logic
     * @return ElixirASTDef for the Enum call
     */
    // TODO: Future version - Use ElixirAST directly to build Enum calls instead of string manipulation
    // This would allow us to properly construct ERemoteCall(EAtom(ElixirAtom.raw("Enum")), "map", [array, lambda])
    // with proper EFn nodes for the lambda functions, giving us better control over the output
    static function generateIdiomaticEnumCall(arrayRef: TypedExpr, operation: String, body: TypedExpr): ElixirASTDef {
        // Extract the actual array from the reference
        // arrayRef is the _g2 variable that holds the array
        var arrayAST = buildFromTypedExpr(arrayRef, currentContext);
        
        // Extract the transformation from the loop body
        var lambdaBody: ElixirAST = null;
        var itemVar = "v"; // Default lambda parameter name
        
        // Analyze the body to extract the transformation
        switch(body.expr) {
            case TBlock(exprs):
                for (expr in exprs) {
                    switch(expr.expr) {
                        case TVar(tvar, _):
                            // Found the loop variable (e.g., var v = _g2[_g1])
                            itemVar = tvar.name;
                            
                        case TCall({expr: TField(_, FInstance(_, _, cf))}, [arg]) if (cf.get().name == "push"):
                            // Found the push operation - extract what's being pushed
                            lambdaBody = buildFromTypedExpr(arg, currentContext);
                            
                        case TIf(cond, thenExpr, _) if (operation == "filter"):
                            // For filter, extract the condition
                            lambdaBody = buildFromTypedExpr(cond, currentContext);
                            
                        case _:
                    }
                }
                
            case _:
        }
        
        // If we couldn't extract a proper transformation, fall back to identity
        if (lambdaBody == null) {
            lambdaBody = makeAST(EVar(itemVar));
        }
        
        // Create the lambda function
        var lambda = makeAST(EFn([{
            args: [PVar(itemVar)],
            guard: null,
            body: lambdaBody
        }]));
        
        // Generate the appropriate Enum call
        switch(operation) {
            case "map":
                return ERemoteCall(
                    makeAST(EAtom(ElixirAtom.raw("Enum"))),
                    "map",
                    [arrayAST, lambda]
                );
                
            case "filter":
                return ERemoteCall(
                    makeAST(EAtom(ElixirAtom.raw("Enum"))),
                    "filter",
                    [arrayAST, lambda]
                );
                
            default:
                // Fallback to map if operation is unknown
                return ERemoteCall(
                    makeAST(EAtom(ElixirAtom.raw("Enum"))),
                    "map",
                    [arrayAST, lambda]
                );
        }
    }
    
    /**
     * Check if an array of AST nodes uses a specific variable
     */
    
    // transformVariableReferences deleted - now delegated to LoopOptimizer
    
    // checkForEarlyReturns, transformReturnsToHalts, wrapWithHaltIfNeeded deleted - now delegated to LoopOptimizer
    
    /**
     * Recursively unwrap TMeta and TParenthesis wrappers from a TypedExpr
     * 
     * WHY: Haxe may add metadata annotations and parenthesis wrappers during compilation
     * WHAT: Strips these wrappers to access the actual expression for pattern matching
     * HOW: Recursively unwraps until finding a non-wrapper expression type
     */
    static function unwrapMetaParens(e: TypedExpr): TypedExpr {
        if (e == null) return null;
        
        return switch(e.expr) {
            case TMeta(_, expr):
                // Strip metadata wrapper and continue unwrapping
                unwrapMetaParens(expr);
            case TParenthesis(expr):
                // Strip parenthesis wrapper and continue unwrapping
                unwrapMetaParens(expr);
            case _:
                // Not a wrapper, return as-is
                e;
        };
    }
    
    
    static function tryBuildMapLiteralFromBlock(blockStmts: Array<TypedExpr>, context: CompilationContext): Null<ElixirAST> {
        if (blockStmts == null || blockStmts.length < 3) {
            return null;
        }

        var tempVar: TVar = null;
        var tempInit: TypedExpr = null;

        switch(blockStmts[0].expr) {
            case TVar(tv, init) if (init != null):
                tempVar = tv;
                tempInit = init;
            default:
                return null;
        }

        if (tempVar == null || tempInit == null) {
            return null;
        }

        var isMapCtor = switch(tempInit.expr) {
            case TNew(c, _, _):
                var className = c.get().name;
                className == "StringMap" || className == "Map" || className.endsWith("Map");
            default:
                false;
        };

        if (!isMapCtor) {
            return null;
        }

        var tempName = tempVar.name;
        var pairs: Array<EMapPair> = [];

        for (i in 1...blockStmts.length - 1) {
            var stmt = blockStmts[i];
            switch(stmt.expr) {
                case TCall({expr: TField({expr: TLocal(local)}, FInstance(_, _, cf))}, callArgs):
                    if (local.name != tempName || cf.get().name != "set" || callArgs.length != 2) {
                        return null;
                    }

                    var keyAst = buildFromTypedExpr(callArgs[0], context);
                    var valueAst = buildFromTypedExpr(callArgs[1], context);
                    pairs.push({key: keyAst, value: valueAst});
                default:
                    return null;
            }
        }

        switch(blockStmts[blockStmts.length - 1].expr) {
            case TLocal(retVar) if (retVar.name == tempName):
                return makeAST(EMap(pairs));
            default:
                return null;
        }
    }
    

    /**
     * Check if a pattern variable is actually used in the case body
     *
     * WHY: Unused pattern variables should become wildcards or have underscore prefix
     * WHAT: Checks if a given variable name appears as used in the usage map
     * HOW: Enhanced with alias awareness - tracks temp variables (g, g1) that represent
     *      pattern variables, since Haxe's optimizer may replace direct references with temps
     *
     * ALIAS TRACKING:
     * - First pass: Build alias sets by finding TEnumParameter extractions and assignments
     * - Second pass: Check if any alias of the pattern variable is used

    /**
     * Check if a case body is effectively empty (only nil or no-op)
     */
    static function isEmptyCaseBody(body: ElixirAST): Bool {
        return PatternBuilder.isEmptyCaseBody(body);
    }
    
    /**
     * Compute a structural pattern key for guard grouping
     * 
     * WHY: Multiple cases with the same pattern but different guards need to be grouped into cond
     * WHAT: Creates a unique key based on the pattern structure (not values or names)
     * HOW: Recursively traverses pattern structure and builds a string key
     * 
     * Examples:
     * - PTuple([PAtom(":rgb"), PVar(_), PVar(_), PVar(_)]) ‚Üí "tuple:rgb:3"
     * - PTuple([PAtom(":ok"), PVar(_)]) ‚Üí "tuple:ok:1"
     * - PVar(_) ‚Üí "var"
     */
    static function computePatternKey(pattern: EPattern): String {
        return PatternBuilder.computePatternKey(pattern);
    }
    
    /**
     * Extract all bound variable names from a pattern
     * 
     * WHY: Variables bound in patterns need to be accessible in guard conditions and body
     * WHAT: Collects all PVar names (except wildcards) from the pattern
     * HOW: Recursively traverses pattern structure collecting variable names
     */
    static function extractBoundVariables(pattern: EPattern): Array<String> {
        return PatternBuilder.extractBoundVariables(pattern);
    }
    
    // collectBoundVarsHelper has been moved to PatternBuilder
    
    /**
     * EXPRESSION PRESERVATION: Captures the textual representation of an expression
     * 
     * WHY: When Haxe evaluates expressions at compile-time (e.g., i * 2 + 1 becomes 1, 3, 5),
     *      we lose the original expression structure. By preserving the text representation,
     *      we can reconstruct idiomatic Elixir code in the transformer phase.
     * 
     * WHAT: Extracts a simplified string representation of the expression that can be
     *       reconstructed with proper variable substitution in generated Elixir code.
     * 
     * HOW: Analyzes the TypedExpr structure and builds a string representation,
     *      replacing loop variable references with placeholders for later substitution.
     * 
     * @param expr The expression to capture
     * @param loopVar The loop variable name to track in the expression
     * @return String representation of the expression, or null if too complex
     */
    // Loop helper functions moved to LoopBuilder.hx
    
    /**
     * Process a LoopIntent and generate corresponding ElixirAST
     * 
     * WHY: The LoopIntent pattern separates semantic intent from implementation.
     * This allows us to capture what the loop does before deciding how to
     * generate it, enabling better optimization and cleaner code generation.
     * 
     * WHAT: Transforms LoopIntent objects into idiomatic Elixir AST nodes,
     * handling variable preservation, accumulator initialization, and
     * infrastructure variable removal.
     * 
     * HOW: Pattern matches on LoopIntent variants and delegates to appropriate
     * generation logic, either using LoopBuilder for compatibility or
     * generating AST directly for simple cases.
     * 
     * @param intent The loop intent to process
     * @param metadata Additional metadata for the loop
     * @param context The current compilation context
     * @return The generated ElixirAST node
     */
    // Delegate to LoopHelpers
    static inline function processLoopIntent(intent: LoopIntent, metadata: LoopIntentMetadata, context: CompilationContext): ElixirAST {
        return LoopHelpers.processLoopIntent(intent, metadata, context);
    }
    
    /**
     * MAP ITERATION PATTERN DETECTION
     * 
     * WHY: Haxe desugars `for (key => value in map)` into complex TBlock+TWhile patterns
     *      with iterator method calls that don't exist in Elixir
     * 
     * WHAT: Detects the specific desugared pattern and extracts key/value variable names
     * 
     * HOW: Looks for:
     *      1. TVar with keyValueIterator() call  
     *      2. TWhile with hasNext() condition
     *      3. Body containing next() call with tuple destructuring
     * 
     * PATTERN:
     * ```
     * var iterator = map.keyValueIterator();
     * while (iterator.hasNext()) {
     *     var kv = iterator.next();
     *     var key = kv.key;
     *     var value = kv.value;
     *     // ... user code using key and value
     * }
     * ```
     */
    // detectMapIterationPattern deleted - now delegated to LoopOptimizer
    
    /**
     * BUILD MAP ITERATION AST
     * 
     * WHY: Generate idiomatic Elixir code for Map iteration instead of invalid iterator calls
     * 
     * WHAT: Transforms detected Map iteration pattern into Enum.each/map with tuple destructuring
     * 
     * HOW: Generates:
     *      - Enum.each for side effects only
     *      - Enum.map for collecting results
     *      - Proper tuple destructuring: fn {key, value} -> ... end
     */
    // Delegate to LoopHelpers (uses optimizers.LoopOptimizer.MapIterationPattern)
    static inline function buildMapIteration(pattern: reflaxe.elixir.ast.optimizers.LoopOptimizer.MapIterationPattern, context: CompilationContext): ElixirAST {
        return LoopHelpers.buildMapIteration(pattern, context);
    }
    
    // Delegate to LoopHelpers
    static inline function analyzesAsExpression(expr: TypedExpr): Bool {
        return LoopHelpers.analyzesAsExpression(expr);
    }
}

// MapIterationPattern typedef is now in LoopOptimizer.hx

#end
</file>

<file path="src/reflaxe/elixir/macros/RouterBuildMacro.hx">
package reflaxe.elixir.macros;

#if (macro || reflaxe_runtime)

import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;

using StringTools;

/**
 * Build macro for auto-generating router functions from declarative route definitions.
 * 
 * Transforms this declarative syntax:
 * ```haxe
 * @:router
 * @:routes([
 *     {name: "root", method: "LIVE", path: "/", controller: "TodoLive", action: "index"},
 *     {name: "todosList", method: "LIVE", path: "/todos", controller: "TodoLive"}
 * ])
 * class TodoAppRouter {}
 * ```
 * 
 * Into auto-generated functions with proper @:route metadata:
 * ```haxe
 * @:route({method: "LIVE", path: "/", controller: "TodoLive", action: "index"})
 * public static function root(): String { return "/"; }
 * ```
 * 
 * This eliminates the need for empty placeholder functions while maintaining full
 * RouterCompiler compatibility and providing optional type-safe route helpers.
 */
@:nullSafety(Off)
class RouterBuildMacro {
    static inline function isFastBoot(): Bool {
        #if macro
        return haxe.macro.Context.defined("fast_boot");
        #else
        return false;
        #end
    }
    // Memoization caches for controller/action existence during a single compilation run
    static var ctrlCache: Map<String,Bool> = new Map();
    static var actionCache: Map<String,Bool> = new Map();
    
    /**
     * Main build macro entry point - generates route functions from @:routes annotation
     */
    public static function generateRoutes(): Array<Field> {
        #if debug_perf var __p = reflaxe.elixir.debug.Perf.now(); #end
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        #end
        #if debug_compilation_hang
        Sys.println('[HANG DEBUG] üéØ RouterBuildMacro.generateRoutes START');
        var routerStartTime = haxe.Timer.stamp() * 1000;
        #end

        var fields = Context.getBuildFields();
        var classType = Context.getLocalClass().get();

        #if debug_compilation_hang
        Sys.println('[HANG DEBUG] Router class: ${classType.name}');
        #end

        // Extract route definitions from @:routes annotation
        var routeDefinitions = extractRoutesAnnotation(classType);
        if (routeDefinitions == null || routeDefinitions.length == 0) {
            // No @:routes annotation found - return existing fields unchanged
        #if debug_router_macro trace('RouterBuildMacro: No @:routes annotation found in ${classType.name}'); #end
            return fields;
        }
        
        #if debug_router_macro trace('RouterBuildMacro: Found ${routeDefinitions.length} route definitions in ${classType.name}'); #end
        
        // Validate route definitions (lightweight under fast_boot)
        validateRouteDefinitions(routeDefinitions, classType.pos);
        
        // Generate functions for each route definition
        for (routeDef in routeDefinitions) {
            #if debug_compilation_hang
            Sys.println('[HANG DEBUG] Generating route: ${routeDef.name} - ${routeDef.method} ${routeDef.path}');
            #end

            var generatedFunction = createRouteFunction(routeDef, classType.pos);
            fields.push(generatedFunction);
            #if debug_router_macro trace('RouterBuildMacro: Generated function ${routeDef.name} for route ${routeDef.method} ${routeDef.path}'); #end
        }
        
        #if debug_router_macro trace('RouterBuildMacro: Successfully generated ${routeDefinitions.length} route functions'); #end

        #if debug_compilation_hang
        var elapsed = (haxe.Timer.stamp() * 1000) - routerStartTime;
        Sys.println('[HANG DEBUG] ‚úÖ RouterBuildMacro.generateRoutes END - Took ${elapsed}ms, Generated ${routeDefinitions.length} routes');
        #end

        #if hxx_instrument_sys
        var __elapsedMacro = (haxe.Timer.stamp() - __t0) * 1000.0;
        Sys.println(
            '[MacroTiming] name=RouterBuildMacro.generateRoutes routes='
            + routeDefinitions.length
            + ' elapsed_ms=' + Std.int(__elapsedMacro)
        );
        #end

        #if debug_perf reflaxe.elixir.debug.Perf.add('RouterBuildMacro.generateRoutes', __p); #end
        return fields;
    }
    
    /**
     * Extract route definitions from @:routes class annotation
     */
    private static function extractRoutesAnnotation(classType: ClassType): Array<RouteDefinition> {
        if (!classType.meta.has(":routes")) {
            return null;
        }
        
        var routesMetadata = classType.meta.extract(":routes");
        if (routesMetadata.length == 0) {
            return null;
        }
        
        var routesEntry = routesMetadata[0];
        if (routesEntry.params == null || routesEntry.params.length == 0) {
            Context.error("@:routes annotation requires array parameter: @:routes([{...}])", routesEntry.pos);
            return null;
        }
        
        // Parse array of route objects
        var routesArrayExpr = routesEntry.params[0];
        return parseRoutesArray(routesArrayExpr);
    }
    
    /**
     * Parse array expression containing route definitions
     */
    private static function parseRoutesArray(arrayExpr: Expr): Array<RouteDefinition> {
        var routes = [];
        
        switch (arrayExpr.expr) {
            case EArrayDecl(values):
                for (routeExpr in values) {
                    var routeDef = parseRouteObject(routeExpr);
                    if (routeDef != null) {
                        routes.push(routeDef);
                    }
                }
            case _:
                Context.error("@:routes parameter must be an array: @:routes([{...}])", arrayExpr.pos);
        }
        
        return routes;
    }
    
    /**
     * Parse individual route object from expression
     */
    private static function parseRouteObject(routeExpr: Expr): RouteDefinition {
        switch (routeExpr.expr) {
            case EObjectDecl(fields):
                var routeDef = new RouteDefinition();
                
                for (field in fields) {
                    switch (field.field) {
                        case "name":
                            routeDef.name = extractStringValue(field.expr, "name");
                        case "method":
                            routeDef.method = extractStringValue(field.expr, "method");
                        case "path":
                            routeDef.path = extractStringValue(field.expr, "path");
                        case "controller":
                            routeDef.controller = extractStringValue(field.expr, "controller");
                        case "action":
                            routeDef.action = extractStringValue(field.expr, "action");
                        case "pipeline":
                            routeDef.pipeline = extractStringValue(field.expr, "pipeline");
                        case _:
                            Context.warning('Unknown route field: ${field.field}', field.expr.pos);
                    }
                }
                
                return routeDef;
                
            case _:
                Context.error("Route definition must be object: {name: \"...\", method: \"...\", ...}", routeExpr.pos);
                return null;
        }
    }
    
    /**
     * Extract string value from expression (supports both strings and enums)
     */
    private static function extractStringValue(expr: Expr, fieldName: String): String {
        switch (expr.expr) {
            case EConst(CString(s, _)):
                return s;
            case EField(e, field):
                // Handle enum values like HttpMethod.GET
                switch (e.expr) {
                    case EConst(CIdent("HttpMethod")):
                        return field; // Return the enum field name as string
                    case _:
                        // Could be a class reference - extract class name
                        return extractTypeReference(expr, fieldName);
                }
            case EConst(CIdent(ident)):
                // Handle direct identifiers (class names)
                return ident;
            case _:
                Context.error('${fieldName} must be a string literal, enum value, or class reference', expr.pos);
                return null;
        }
    }
    
    /**
     * Extract type reference for controller/action validation
     */
    private static function extractTypeReference(expr: Expr, fieldName: String): String {
        switch (expr.expr) {
            case EField(e, field):
                // Handle Class.method references
                var className = extractClassName(e);
                return className != null ? className : field;
            case EConst(CIdent(ident)):
                // Handle simple class names
                return ident;
            case _:
                return null;
        }
    }
    
    /**
     * Extract class name from expression
     */
    private static function extractClassName(expr: Expr): String {
        switch (expr.expr) {
            case EConst(CIdent(ident)):
                return ident;
            case EField(e, field):
                var base = extractClassName(e);
                return base != null ? '${base}.${field}' : field;
            case _:
                return null;
        }
    }
    
    /**
     * Validate route definitions for common errors
     */
    private static function validateRouteDefinitions(routes: Array<RouteDefinition>, pos: Position): Void {
        var usedNames = new Map<String, Bool>();
        var usedPaths = new Map<String, String>();
        var fastBoot = isFastBoot();
        
        for (route in routes) {
            // Validate required fields
            if (route.name == null || route.name == "") {
                Context.error("Route missing required 'name' field", pos);
            }
            if (route.method == null || route.method == "") {
                Context.error("Route missing required 'method' field", pos);
            }
            if (route.path == null || route.path == "") {
                Context.error("Route missing required 'path' field", pos);
            }
            
            // Check for duplicate function names
            if (usedNames.exists(route.name)) {
                Context.error('Duplicate route name: ${route.name}', pos);
            }
            usedNames.set(route.name, true);
            
            // Check for duplicate path + method combinations
            var pathMethodKey = '${route.method}:${route.path}';
            if (usedPaths.exists(pathMethodKey)) {
                Context.warning('Duplicate route path/method: ${pathMethodKey} (was ${usedPaths.get(pathMethodKey)})', pos);
            }
            usedPaths.set(pathMethodKey, route.name);
            
            // Validate HTTP method
            var validMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "LIVE", "LIVE_DASHBOARD"];
            if (!validMethods.contains(route.method)) {
                Context.warning('Unknown HTTP method: ${route.method}. Valid: ${validMethods.join(", ")}', pos);
            }
            
            // Skip expensive type checks under fast_boot; keep warnings lightweight
            if (!fastBoot) {
                if (route.controller != null && route.controller != "") {
                    validateControllerExists(route.controller, route.name, route.path, pos);
                }
                if (route.controller != null && route.action != null && route.controller != "" && route.action != "") {
                    validateActionExists(route.controller, route.action, route.name, pos);
                }
            }
        }
    }
    
    /**
     * Create function field from route definition
     */
    private static function createRouteFunction(routeDef: RouteDefinition, pos: Position): Field {
        // Create @:route annotation for the function
        var routeAnnotation: MetadataEntry = {
            name: ":route",
            params: [createRouteAnnotationObject(routeDef, pos)],
            pos: pos
        };
        
        // Generate function body that returns the path (for route helpers)
        var functionBody: Expr = {
            expr: EReturn({
                expr: EConst(CString(routeDef.path, DoubleQuotes)),
                pos: pos
            }),
            pos: pos
        };
        
        // Create function field
        var functionField: Field = {
            name: routeDef.name,
            access: [APublic, AStatic],
            kind: FFun({
                args: [],
                ret: macro: String,
                expr: functionBody
            }),
            pos: pos,
            meta: [routeAnnotation],
            doc: 'Auto-generated route function for ${routeDef.method} ${routeDef.path}'
        };
        
        return functionField;
    }
    
    /**
     * Create the object expression for @:route annotation
     */
    private static function createRouteAnnotationObject(routeDef: RouteDefinition, pos: Position): Expr {
        var objectFields: Array<ObjectField> = [
            {
                field: "method",
                expr: {expr: EConst(CString(routeDef.method, DoubleQuotes)), pos: pos}
            },
            {
                field: "path", 
                expr: {expr: EConst(CString(routeDef.path, DoubleQuotes)), pos: pos}
            }
        ];
        
        // Add optional fields if present
        if (routeDef.controller != null) {
            objectFields.push({
                field: "controller",
                expr: {expr: EConst(CString(routeDef.controller, DoubleQuotes)), pos: pos}
            });
        }
        
        if (routeDef.action != null) {
            objectFields.push({
                field: "action",
                expr: {expr: EConst(CString(routeDef.action, DoubleQuotes)), pos: pos}
            });
        }
        
        if (routeDef.pipeline != null) {
            objectFields.push({
                field: "pipeline",
                expr: {expr: EConst(CString(routeDef.pipeline, DoubleQuotes)), pos: pos}
            });
        }
        
        return {
            expr: EObjectDecl(objectFields),
            pos: pos
        };
    }
    
    /**
     * Validate that a controller class exists
     */
    private static function validateControllerExists(controllerName: String, routeName: String, routePath: String, pos: Position): Void {
        if (controllerName == null || controllerName == "") return;
        if (ctrlCache.exists(controllerName)) {
            if (!ctrlCache.get(controllerName)) {
                Context.warning('Controller "${controllerName}" not found in route "${routeName}" (path: "${routePath}"). Ensure the class exists and is in the classpath.', pos);
            }
            return;
        }
        var ok = true;
        try {
            // Try to resolve the controller as a type (costly; do once)
            var _ = Context.getType(controllerName);
            #if debug_router_macro trace('RouterBuildMacro: Controller ${controllerName} exists and is valid'); #end
        } catch (e: Dynamic) {
            ok = false;
            Context.warning('Controller "${controllerName}" not found in route "${routeName}" (path: "${routePath}"). Ensure the class exists and is in the classpath.', pos);
        }
        ctrlCache.set(controllerName, ok);
    }
    
    /**
     * Validate that an action method exists on the controller
     */
    private static function validateActionExists(controllerName: String, actionName: String, routeName: String, pos: Position): Void {
        if (controllerName == null || actionName == null || controllerName == "" || actionName == "") return;
        var key = controllerName + "#" + actionName;
        if (actionCache.exists(key)) return; // already validated
        try {
            // Get the controller type
            var controllerType = Context.getType(controllerName);
            
            switch (controllerType) {
                case TInst(ref, _):
                    var classType = ref.get();
                    
                    // Check if the action method exists
                    var methodExists = false;
                    for (field in classType.fields.get()) {
                        if (field.name == actionName) {
                            methodExists = true;
                            break;
                        }
                    }
                    
                    // Also check static fields
                    if (!methodExists) {
                        for (field in classType.statics.get()) {
                            if (field.name == actionName) {
                                methodExists = true;
                                break;
                            }
                        }
                    }
                    
                    if (methodExists) {
                        #if debug_router_macro trace('RouterBuildMacro: Action ${controllerName}.${actionName} exists and is valid'); #end
                    } else {
                        Context.warning('Action "${actionName}" not found on controller "${controllerName}" in route "${routeName}". Check that the method exists and is public static.', pos);
                    }
                    
                case _:
                    Context.warning('Controller "${controllerName}" is not a class. Actions can only be validated on class types.', pos);
            }
        } catch (e: Dynamic) {
            // Controller doesn't exist, but we already warned about this in validateControllerExists
            // So just silently skip action validation
        }
        actionCache.set(key, true);
    }
}

/**
 * Route definition structure extracted from @:routes annotation
 */
@:structInit
class RouteDefinition {
    public var name: String;        // Function name (required)
    public var method: String;      // HTTP method: GET, POST, LIVE, etc. (required)  
    public var path: String;        // URL path pattern (required)
    public var controller: String;  // Target controller/LiveView (optional)
    public var action: String;      // Action method (optional)
    public var pipeline: String;    // Pipeline to use (optional)
    
    public function new() {}
}

#end
</file>

<file path="examples/todo-app/build-server.hxml">
# Haxe‚ÜíElixir compilation for Phoenix LiveView server-side code
# Generates idiomatic Elixir code for the BEAM VM

# Use packaged libraries to avoid repo-level classpaths (faster, no shadowing)
-lib reflaxe
-lib reflaxe.elixir

# Source directories
-cp src_haxe
-cp src_haxe/server
-cp src_haxe/shared

# Output directory for generated .ex files
-D elixir_output=lib

# Required for Reflaxe targets
-D reflaxe_runtime

# Elixir is not a UTF-16 platform
-D no-utf16

# Application-specific configuration
-D app_name=TodoApp

# Enable dead code elimination to remove unused functions
# 
# DCE (Dead Code Elimination) is CRITICAL for abstract types with operator overloads.
# Without DCE, ALL @:op annotated methods in abstracts (like Date's comparison operators)
# are compiled to helper functions in the _Impl_ module, even if never used.
# 
# Example: Date abstract defines lt, lte, gt, gte, eq, neq operators
# - Without DCE: All 6 functions generated in Date_Impl_, causing "unused function" warnings
# - With DCE full: Only used functions are kept, eliminating warnings
#
# DCE levels:
# - no: Disable DCE (causes unused function warnings)
# - std: Remove unused std library classes only
# - full: Remove all unreachable code (RECOMMENDED for production)
#
# Note: Reflaxe.Elixir correctly respects DCE - eliminated code is removed before
# transpilation, resulting in cleaner and smaller Elixir output.
-dce full

# (Optional) Debug traces for dynamic assignment fix
# Disabled by default to avoid noisy generation in some modules
# -D debug_dynamic_assignment

# Exclude client code from server compilation
--macro exclude('client')
--macro exclude('test')
--macro exclude('server.live.UserLive')
--macro exclude('server.services.UserGenServer')
## Include controllers and contexts in server build (needed for test WAE)
## (Removed earlier excludes for server.controllers.UserController and contexts.*)

# Keep Phoenix CoreComponents even if not referenced directly in Haxe
# WHY: Phoenix imports TodoAppWeb.CoreComponents via `use TodoAppWeb, :html`
# which Haxe DCE cannot see. Force-keep to ensure the module is emitted.
--macro keep('server.components.CoreComponents')
--macro keep('phoenix.DateFormat')
--macro keep('phoenix.Sorting')

# Define library version and initialize compiler
-D reflaxe.elixir=0.1.0

# Debug flags are disabled by default to keep QA builds quiet and fast
# -D debug_success_unifier
# -D debug_presence

# Enable deterministic render string ‚Üí ~H conversion
-D hxx_string_to_sigil

# Silence compiler debug traces for QA speed and signal clarity
# Provide both hyphenated and underscored defines for preprocessor gating compatibility
-D no-traces
-D no_traces
-D disable_hygiene_final

# Main server classes to compile
TodoApp
TodoAppRouter
server.live.TodoLive
server.schemas.Todo
server.migrations.CreateTodos
server.presence.TodoPresence
server.layouts.Layouts
server.infrastructure.Repo
server.infrastructure.Telemetry
server.infrastructure.Endpoint
server.infrastructure.TodoAppWeb
controllers.UserController
server.components.CoreComponents
server.i18n.Gettext
server.infrastructure.GettextErrorMessages
server.infrastructure.GettextUIMessages
# PostgrexTypes is now auto-generated from Repo, not a separate class
# Temporarily exclude problematic stdlib modules
# -D exclude-bytes  # Removed to test assignment extraction fix
-D exclude-balanced-tree

# Force-keep controllers and contexts so WAE passes apply to their outputs
</file>

<file path="src/reflaxe/elixir/ast/TemplateHelpers.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTPrinter;
import haxe.macro.Type;
import haxe.macro.TypedExprTools;

/**
 * TemplateHelpers: HXX Template Processing Utilities
 * 
 * WHY: Centralize HXX ‚Üí HEEx template transformation logic
 * - Separate template concerns from main AST builder
 * - Provide reusable template utilities
 * - Encapsulate HXX-specific patterns
 * 
 * WHAT: Template content collection and transformation
 * - Extract template strings and embedded expressions
 * - Process template arguments
 * - Detect HXX module usage
 * 
 * HOW: Pattern matching on AST nodes to extract template content
 * - Collect string literals for template body
 * - Process embedded <%= %> expressions
 * - Handle template function arguments
 */
class TemplateHelpers {
    
    /**
     * Render an ElixirAST expression into a HEEx-safe Elixir expression string.
     * - Converts assigns.* access to @* for idiomatic HEEx
     * - Handles common expression nodes (vars, fields, calls, literals, binaries, if)
     */
    static function renderExpr(ast: ElixirAST): String {
        return switch (ast.def) {
            case EString(s): '"' + s + '"';
            case EInteger(i): Std.string(i);
            case EFloat(f): Std.string(f);
            case EBoolean(b): b ? "true" : "false";
            case ENil: "nil";
            case EAtom(a):
                // a is ElixirAtom; use its string form with preceding :
                ':' + Std.string(a);
            case EVar(name):
                name;
            case EField(obj, field):
                var base = renderExpr(obj);
                // If base starts with "assigns.", convert to HEEx assigns shorthand
                if (StringTools.startsWith(base, "assigns.")) {
                    '@' + base.substr("assigns.".length) + '.' + field;
                } else if (base == "assigns") {
                    '@' + field;
                } else {
                    base + '.' + field;
                }
            case EAccess(target, key):
                var t = renderExpr(target);
                var k = renderExpr(key);
                // Keep standard access syntax target[key]
                t + "[" + k + "]";
            case ECall(module, func, args):
                var callStr = if (module != null) {
                    switch (module.def) {
                        case EVar(m): m + "." + func;
                        case EField(_, _): renderExpr(module) + "." + func;
                        default: func;
                    }
                } else {
                    func;
                };
                if (args.length > 0) {
                    var argStrs = [];
                    for (arg in args) argStrs.push(renderExpr(arg));
                    callStr + "(" + argStrs.join(", ") + ")";
                } else {
                    callStr + "()";
                }
            case EBinary(op, left, right):
                var l = renderExpr(left);
                var r = renderExpr(right);
                var opStr = switch (op) {
                    case Add: "+";
                    case Subtract: "-";
                    case Multiply: "*";
                    case Divide: "/";
                    case Remainder: "rem";
                    case Power: "**";
                    case Equal: "==";
                    case NotEqual: "!=";
                    case StrictEqual: "===";
                    case StrictNotEqual: "!==";
                    case Less: "<";
                    case Greater: ">";
                    case LessEqual: "<=";
                    case GreaterEqual: ">=";
                    case And: "and";
                    case Or: "or";
                    case AndAlso: "&&";
                    case OrElse: "||";
                    case BitwiseAnd: "&&&";
                    case BitwiseOr: "|||";
                    case BitwiseXor: "^^^";
                    case ShiftLeft: "<<<";
                    case ShiftRight: ">>>";
                    case Concat: "++";
                    case ListSubtract: "--";
                    case StringConcat: "<>";
                    case In: "in";
                    case Match: "=";
                    case Pipe: "|>";
                    case TypeCheck: "::";
                    case When: "when";
                };
                '(' + l + ' ' + opStr + ' ' + r + ')';
            case EIf(condition, thenBranch, elseBranch):
                var c = renderExpr(condition);
                var t = renderExpr(thenBranch);
                var e = elseBranch != null ? renderExpr(elseBranch) : "nil";
                'if ' + c + ', do: ' + t + ', else: ' + e;
            case EParen(inner):
                '(' + renderExpr(inner) + ')';
            default:
                // Fallback: delegate to AST printer for a best-effort representation
                ElixirASTPrinter.print(ast, 0);
        };
    }
    
    /**
     * Collect template content from an ElixirAST node
     * 
     * Processes various AST patterns to extract template strings,
     * handling embedded expressions and string interpolation.
     */
    public static function collectTemplateContent(ast: ElixirAST): String {
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        #end
        var __result = switch(ast.def) {
            case EString(s): 
                // Simple string - process interpolations and HXX control tags into HEEx-safe content
                var processed = rewriteInterpolations(s);
                processed = rewriteControlTags(processed);
                processed;
                
            case EBinary(StringConcat, left, right):
                // String concatenation - collect both sides
                var l = collectTemplateContent(left);
                var r = collectTemplateContent(right);
                // Ensure HXX control tags remain balanced across boundaries
                rewriteControlTags(l + r);
                
            case EIf(condition, thenBranch, elseBranch):
                // Prefer inline-if when then/else are simple HTML strings (including HXX.block)
                var condStr = renderExpr(condition);
                if (StringTools.startsWith(condStr, "assigns.")) condStr = '@' + condStr.substr("assigns.".length);
                // Try to extract simple HTML bodies from branches
                var thenSimple: Null<String> = extractSimpleHtml(thenBranch);
                var elseSimple: Null<String> = (elseBranch != null) ? extractSimpleHtml(elseBranch) : "";
                if (thenSimple != null && elseSimple != null) {
                    '<%= if ' + condStr + ', do: ' + toQuoted(thenSimple) + ', else: ' + toQuoted(elseSimple) + ' %>';
                } else {
                    // Fallback to block-if
                    var thenStr = collectTemplateContent(thenBranch);
                    var elseStr = elseBranch != null ? collectTemplateContent(elseBranch) : "";
                    var out = new StringBuf();
                    out.add('<%= if ' + condStr + ' do %>');
                    out.add(thenStr);
                    if (elseStr != null && elseStr != "") {
                        out.add('<% else %>');
                        out.add(elseStr);
                    }
                    out.add('<% end %>');
                    out.toString();
                }

            case ECall(module, func, args):
                // Special handling for nested HXX helpers: HXX.block('...') or hxx.HXX.block('...')
                var isHxxModule = false;
                if (module != null) switch (module.def) {
                    case EVar(m): isHxxModule = (m == "HXX");
                    case EField(_, fld): isHxxModule = (fld == "HXX");
                    default:
                }
                if (isHxxModule && (func == "block" || func == "hxx") && args.length >= 1) {
                    var inner = collectTemplateContent(args[0]);
                    return rewriteControlTags(inner);
                }
                // Generic call rendering with block-arg wrapping for validity in template interpolation
                var callStr = (function() {
                    var callHead = if (module != null) {
                        switch (module.def) {
                            case EVar(m): m + "." + func;
                            case EField(_, _): renderExpr(module) + "." + func;
                            default: func;
                        }
                    } else func;
                    function renderArgForTemplate(a: ElixirAST): String {
                        return switch (a.def) {
                            case EBlock(sts) if (sts != null && sts.length > 1):
                                // Wrap multi-statement blocks as IIFE to form a single expression
                                '(fn -> ' + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + ' end).()';
                            case EParen(inner) if (switch (inner.def) { case EBlock(es) if (es.length > 1): true; default: false; }):
                                '(fn -> ' + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + ' end).()';
                            default:
                                renderExpr(a);
                        }
                    }
                    var parts = [];
                    for (a in args) parts.push(renderArgForTemplate(a));
                    return callHead + '(' + parts.join(', ') + ')';
                })();
                if (StringTools.startsWith(callStr, "assigns.")) callStr = '@' + callStr.substr("assigns.".length);
                '<%= ' + callStr + ' %>';

            case ERemoteCall(module, func, args):
                // Render remote calls similarly to ECall, with arg block wrapping
                var head = renderExpr(module) + "." + func;
                function renderArg2(a: ElixirAST): String {
                    return switch (a.def) {
                        case EBlock(sts) if (sts != null && sts.length > 1):
                            '(fn -> ' + StringTools.rtrim(ElixirASTPrinter.print(a, 0)) + ' end).()';
                        case EParen(inner) if (switch (inner.def) { case EBlock(es) if (es.length > 1): true; default: false; }):
                            '(fn -> ' + StringTools.rtrim(ElixirASTPrinter.print(inner, 0)) + ' end).()';
                        default:
                            renderExpr(a);
                    }
                }
                var argList2 = [];
                for (a in args) argList2.push(renderArg2(a));
                var full = head + '(' + argList2.join(', ') + ')';
                if (StringTools.startsWith(full, "assigns.")) full = '@' + full.substr("assigns.".length);
                '<%= ' + full + ' %>';

            case EVar(_)
                | EField(_, _)
                | EInteger(_)
                | EFloat(_)
                | EBoolean(_)
                | ENil
                | EAtom(_)
                | EBinary(_, _, _)
                | EParen(_):
                // Expression inside template ‚Äì render as HEEx interpolation
                var exprStr = renderExpr(ast);
                // Map assigns.* to @* for HEEx idioms
                if (StringTools.startsWith(exprStr, "assigns.")) {
                    exprStr = '@' + exprStr.substr("assigns.".length);
                }
                '<%= ' + exprStr + ' %>';
                
            default:
                // Fallback: embed expression in interpolation using generic renderer
                var exprAny = renderExpr(ast);
                if (StringTools.startsWith(exprAny, "assigns.")) exprAny = '@' + exprAny.substr("assigns.".length);
                '<%= ' + exprAny + ' %>';
        };
        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        #if sys
        Sys.println('[HXX] collectTemplateContent elapsed_ms=' + Std.int(__elapsed));
        #else
        trace('[HXX] collectTemplateContent elapsed_ms=' + Std.int(__elapsed));
        #end
        #end
        return __result;
    }

    /**
     * Convert #{...} and ${...} interpolations into HEEx <%= ... %> and map assigns.* ‚Üí @*
     * Also rewrites inline ternary to block HEEx when then/else are string or HXX.block.
     */
    public static function rewriteInterpolations(s:String):String {
        if (s == null) return s;
        // Fast-path: if there are no interpolation/control markers, return as-is
        if (s.indexOf("${") == -1 && s.indexOf("#{") == -1 && s.indexOf('<for {') == -1) {
            return s;
        }
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        var __bytes = s.length;
        var __iters = 0;
        #end
        // First, convert attribute-level ${...} into HEEx attribute expressions: attr={...}
        s = rewriteAttributeInterpolations(s);
        // Then, convert attribute-level <%= ... %> into HEEx attribute expressions: attr={...}
        s = rewriteAttributeEexInterpolations(s);
        // Normalize custom control tags first (so inner text gets rewritten next)
        s = rewriteForBlocks(s);
        var out = new StringBuf();
        var i = 0;
        while (i < s.length) {
            #if hxx_instrument_sys __iters++; #end
            var j1 = s.indexOf("#{", i);
            var j2 = s.indexOf("${", i);
            var j = (j1 == -1) ? j2 : (j2 == -1 ? j1 : (j1 < j2 ? j1 : j2));
            if (j == -1) { out.add(s.substr(i)); break; }
            out.add(s.substr(i, j - i));
            var k = j + 2;
            var depth = 1;
            while (k < s.length && depth > 0) {
                var ch = s.charAt(k);
                if (ch == '{') depth++;
                else if (ch == '}') depth--;
                k++;
            }
            var inner = s.substr(j + 2, (k - 1) - (j + 2));
            var expr = StringTools.trim(inner);
            // Guard: disallow injecting HTML as string via interpolation of a string literal starting with '<'
            if (expr.length >= 2 && expr.charAt(0) == '"' && expr.charAt(1) == '<') {
                #if macro
                haxe.macro.Context.error('HXX: injecting HTML via string inside interpolation is not allowed. Use HXX.block(\'...\') or inline markup.', haxe.macro.Context.currentPos());
                #else
                throw 'HXX: injecting HTML via string inside interpolation is not allowed. Use HXX.block(\'...\') or inline markup.';
                #end
            }
            // Try to split top-level ternary
            var tern = splitTopLevelTernary(expr);
            if (tern != null) {
                var cond = StringTools.replace(tern.cond, "assigns.", "@");
                var th = extractBlockHtml(StringTools.trim(tern.thenPart));
                var el = extractBlockHtml(StringTools.trim(tern.elsePart));
                if (th != null || el != null) {
                    // Prefer inline-if in body when both branches are HTML strings
                    var thenQ = (th != null) ? toQuoted(th) : '""';
                    var elseQ = (el != null && el != "") ? toQuoted(el) : '""';
                    out.add('<%= if ' + cond + ', do: ' + thenQ + ', else: ' + elseQ + ' %>');
                } else {
                    out.add('<%= ' + StringTools.replace(expr, "assigns.", "@") + ' %>');
                }
            } else {
                out.add('<%= ' + StringTools.replace(expr, "assigns.", "@") + ' %>');
            }
            i = k;
        }
        // Return as-is; attribute contexts are normalized elsewhere.
        var __res = out.toString();
        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        #if macro
        haxe.macro.Context.warning('[HXX] rewriteInterpolations bytes=' + __bytes + ' iters=' + __iters + ' elapsed_ms=' + Std.int(__elapsed), haxe.macro.Context.currentPos());
        #elseif sys
        Sys.println('[HXX] rewriteInterpolations bytes=' + __bytes + ' iters=' + __iters + ' elapsed_ms=' + Std.int(__elapsed));
        #end
        #end
        return __res;
    }

    /**
     * Rewrite <for {pattern in expr}> ... </for> to HEEx for-blocks.
     * Supports simple patterns like `todo in list` or `item in some_call()`.
     */
    public static function rewriteForBlocks(src:String):String {
        var out = new StringBuf();
        var i = 0;
        #if hxx_instrument_sys
        var __t0 = haxe.Timer.stamp();
        #end
        #if hxx_instrument
        var localIters = 0;
        #end
        while (i < src.length) {
            #if hxx_instrument localIters++; #end
            var start = src.indexOf('<for {', i);
            if (start == -1) { out.add(src.substr(i)); break; }
            out.add(src.substr(i, start - i));
            var headEnd = src.indexOf('}>', start);
            if (headEnd == -1) { out.add(src.substr(start)); break; }
            var headInner = src.substr(start + 6, headEnd - (start + 6)); // between { and }
            var closeTag = src.indexOf('</for>', headEnd + 2);
            if (closeTag == -1) { out.add(src.substr(start)); break; }
            var body = src.substr(headEnd + 2, closeTag - (headEnd + 2));
            var parts = headInner.split(' in ');
            if (parts.length != 2) {
                // Fallback: keep original; do not break template
                out.add(src.substr(start, (closeTag + 6) - start));
                i = closeTag + 6;
                continue;
            }
            var pat = StringTools.trim(parts[0]);
            var iter = StringTools.trim(parts[1]);
            // Map assigns.* to @* in iterator expression
            iter = StringTools.replace(iter, 'assigns.', '@');
            out.add('<%= for ' + pat + ' <- ' + iter + ' do %>');
            // Recursively allow nested for/if inside body
            out.add(rewriteForBlocks(body));
            out.add('<% end %>');
            i = closeTag + 6;
        }
        #if hxx_instrument
        trace('[HXX-INSTR] forBlocks: iters=' + localIters + ' len=' + (src != null ? src.length : 0));
        #end
        var __s = out.toString();
        #if hxx_instrument_sys
        var __elapsed = (haxe.Timer.stamp() - __t0) * 1000.0;
        #if macro
        haxe.macro.Context.warning('[HXX] rewriteForBlocks bytes=' + (src != null ? src.length : 0) + ' iters=' + ( #if hxx_instrument localIters #else 0 #end ) + ' elapsed_ms=' + Std.int(__elapsed), haxe.macro.Context.currentPos());
        #elseif sys
        Sys.println('[HXX] rewriteForBlocks bytes=' + (src != null ? src.length : 0) + ' iters=' + ( #if hxx_instrument localIters #else 0 #end ) + ' elapsed_ms=' + Std.int(__elapsed));
        #end
        #end
        return __s;
    }

    // Convert attribute values written as <%= ... %> (and conditional blocks) into HEEx { ... }
    static function rewriteAttributeEexInterpolations(s:String):String {
        // Fast-path: regex-based attribute EEx ‚Üí HEEx conversion (single pass), avoiding heavy scanning
        if (s == null || s.indexOf("<%") == -1) return s;
        // name=<%= expr %>  ‚Üí name={expr}
        var eexAttr = ~/=\s*<%=\s*([^%]+?)\s*%>/g;
        var result = eexAttr.replace(s, '={$1}');
        // name=<% if cond do %>then<% else %>else<% end %> ‚Üí name={if cond, do: "then", else: "else"}
        var eexIf = ~/=\s*<%\s*if\s+(.+?)\s+do\s*%>([^<]*)<%\s*else\s*%>([^<]*)<%\s*end\s*%>/g;
        result = eexIf.map(result, function (re) {
            var cond = StringTools.trim(re.matched(1));
            var th = StringTools.trim(re.matched(2));
            var el = StringTools.trim(re.matched(3));
            if (!(StringTools.startsWith(th, '"') && StringTools.endsWith(th, '"')) && !(StringTools.startsWith(th, "'") && StringTools.endsWith(th, "'"))) th = '"' + th + '"';
            if (!(StringTools.startsWith(el, '"') && StringTools.endsWith(el, '"')) && !(StringTools.startsWith(el, "'") && StringTools.endsWith(el, "'"))) el = '"' + el + '"';
            return '={if ' + cond + ', do: ' + th + ', else: ' + el + '}';
        });
        return result;
    }

    public static inline function toQuoted(s:String): String {
        var t = StringTools.trim(s);
        // If already quoted, keep as-is; otherwise wrap with quotes without escaping inner quotes
        if ((StringTools.startsWith(t, '"') && StringTools.endsWith(t, '"')) || (StringTools.startsWith(t, "'") && StringTools.endsWith(t, "'"))) {
            return t;
        }
        return '"' + t + '"';
    }

    /**
     * Rewrite attribute values written as ${...} into HEEx attribute expressions { ... }.
     * - Handles: attr=${expr} or attr="${expr}" ‚Üí attr={expr}
     * - Maps assigns.* ‚Üí @*
     * - For top-level ternary cond ? a : b ‚Üí {if cond, do: a, else: b}
     */
    static function rewriteAttributeInterpolations(s:String):String {
        var out = new StringBuf();
        var i = 0;
        while (i < s.length) {
            var prev = i;
            var j = s.indexOf("${", i);
            if (j == -1) { out.add(s.substr(i)); break; }
            // Attempt to detect an attribute assignment immediately preceding ${
            // Find the nearest '=' before j without encountering '>'
            var k = j - 1;
            var seenGt = false;
            while (k >= i) {
                var ch = s.charAt(k);
                if (ch == '>') { seenGt = true; break; }
                if (ch == '=') break;
                k--;
            }
            if (k < i || seenGt || s.charAt(k) != '=') {
                // Not an attr context; copy chunk up to j and continue generic handling later
                out.add(s.substr(i, (j - i)));
                // Copy marker to let generic pass handle it
                out.add("${");
                i = j + 2;
                continue;
            }
            // Find attribute name by scanning backwards from k-1
            var nameEnd = k - 1;
            while (nameEnd >= i && ~/^\s$/.match(s.charAt(nameEnd))) nameEnd--;
            var nameStart = nameEnd;
            while (nameStart >= i && ~/^[A-Za-z0-9_:\-]$/.match(s.charAt(nameStart))) nameStart--;
            nameStart++;
            if (nameStart > nameEnd) {
                // Fallback: not a valid attribute name, treat as generic
                out.add(s.substr(i, (j - i)));
                out.add("${");
                i = j + 2;
                continue;
            }
            var attrName = s.substr(nameStart, (nameEnd - nameStart + 1));
            // Copy prefix up to attribute name start
            out.add(s.substr(i, (nameStart - i)));
            out.add(attrName);
            out.add("=");
            // Skip whitespace and optional opening quote after '='
            var vpos = k + 1;
            while (vpos < s.length && ~/^\s$/.match(s.charAt(vpos))) vpos++;
            var quote: Null<String> = null;
            if (vpos < s.length && (s.charAt(vpos) == '"' || s.charAt(vpos) == '\'')) {
                quote = s.charAt(vpos);
                vpos++;
            }
            // We expect vpos == j (start of ${); otherwise, treat as generic
            if (vpos != j) {
                // Not a plain attr=${...}; emit original sequence and continue
                out.add(s.substr(k + 1, (j - (k + 1))));
                out.add("${");
                i = j + 2;
                continue;
            }
            // Parse balanced braces for ${...}
            var p = j + 2;
            var depth = 1;
            while (p < s.length && depth > 0) {
                var c = s.charAt(p);
                if (c == '{') depth++; else if (c == '}') depth--; p++;
            }
            var inner = s.substr(j + 2, (p - 1) - (j + 2));
            var expr = StringTools.trim(inner);
            // Map assigns.* ‚Üí @*
            expr = StringTools.replace(expr, "assigns.", "@");
            // Ternary to inline-if for attribute context
            var tern = splitTopLevelTernary(expr);
            if (tern != null) {
                var cond = StringTools.replace(StringTools.trim(tern.cond), "assigns.", "@");
                var th = StringTools.trim(tern.thenPart);
                var el = StringTools.trim(tern.elsePart);
                expr = 'if ' + cond + ', do: ' + th + ', else: ' + el;
            }
            out.add('{');
            out.add(expr);
            out.add('}');
            // Skip closing quote if present
            if (quote != null) {
                var qpos = p;
                // Advance until we see the matching quote or tag end; be conservative
                if (qpos < s.length && s.charAt(qpos) == quote) {
                    p = qpos + 1;
                }
            }
            // Advance index
            i = p;
            if (i <= prev) i = prev + 1;
        }
        return out.toString();
    }

    static function extractBlockHtml(part:String):Null<String> {
        if (part == null || part == "") return "";
        var p = part;
        if (StringTools.startsWith(p, "HXX.block(")) {
            var start = p.indexOf('(') + 1;
            var end = p.lastIndexOf(')');
            if (start > 0 && end > start) {
                var inner = StringTools.trim(p.substr(start, end - start));
                return unquote(inner);
            }
        }
        var uq = unquote(p);
        if (uq != null) return uq;
        return null;
    }

    // Extracts simple HTML from an AST branch when it's either HXX.block('...') or a string literal
    static function extractSimpleHtml(branch: ElixirAST): Null<String> {
        return switch (branch.def) {
            case ECall(module, func, args):
                var isHxx = false;
                if (module != null) switch (module.def) {
                    case EVar(m): isHxx = (m == "HXX");
                    case EField(_, fld): isHxx = (fld == "HXX");
                    default:
                }
                if (isHxx && (func == "block" || func == "hxx") && args.length >= 1) {
                    var inner = collectTemplateContent(args[0]);
                    // Ensure no nested EEx in inner
                    if (inner.indexOf("<%") == -1) inner else null;
                } else null;
            case EString(s):
                var uq = unquote(s);
                uq != null ? uq : s;
            default:
                null;
        }
    }

    static function unquote(s:String):Null<String> {
        if (s.length >= 2) {
            var a = s.charAt(0);
            var b = s.charAt(s.length - 1);
            if ((a == '"' && b == '"') || (a == '\'' && b == '\'')) {
                return s.substr(1, s.length - 2);
            }
        }
        return null;
    }

    static function splitTopLevelTernary(e:String):Null<{cond:String, thenPart:String, elsePart:String}> {
        var depth = 0;
        var inS = false, inD = false;
        var q = -1, col = -1;
        for (idx in 0...e.length) {
            var ch = e.charAt(idx);
            if (!inS && ch == '"' && !inD) { inD = true; continue; }
            else if (inD && ch == '"') { inD = false; continue; }
            if (!inD && ch == '\'' && !inS) { inS = true; continue; }
            else if (inS && ch == '\'') { inS = false; continue; }
            if (inS || inD) continue;
            if (ch == '(' || ch == '{' || ch == '[') depth++;
            else if (ch == ')' || ch == '}' || ch == ']') depth--;
            if (depth != 0) continue;
            if (ch == '?' && q == -1) { q = idx; }
            else if (ch == ':' && q != -1) { col = idx; break; }
        }
        if (q == -1 || col == -1) return null;
        var cond = StringTools.trim(e.substr(0, q));
        var thenPart = StringTools.trim(e.substr(q + 1, col - (q + 1)));
        var elsePart = StringTools.trim(e.substr(col + 1));
        return { cond: cond, thenPart: thenPart, elsePart: elsePart };
    }

    static function rewriteInlineIfDoToBlock(s:String):String {
        var out = new StringBuf();
        var i = 0;
        while (i < s.length) {
            var start = s.indexOf("<%=", i);
            if (start == -1) { out.add(s.substr(i)); break; }
            out.add(s.substr(i, start - i));
            var endTag = s.indexOf("%>", start + 3);
            if (endTag == -1) { out.add(s.substr(start)); break; }
            var inner = StringTools.trim(s.substr(start + 3, endTag - (start + 3)));
            if (StringTools.startsWith(inner, "if ")) {
                var rest = StringTools.trim(inner.substr(3));
                var idxDo = indexOfTopLevel(rest, ", do:");
                var cond:String = null;
                var doPart:String = null;
                var elsePart:String = null;
                if (idxDo != -1) {
                    cond = StringTools.trim(rest.substr(0, idxDo));
                    var afterDo = StringTools.trim(rest.substr(idxDo + 5));
                    var qv = extractQuoted(afterDo);
                    if (qv != null) {
                        doPart = qv.value;
                        var rem = StringTools.trim(afterDo.substr(qv.length));
                        if (StringTools.startsWith(rem, ",")) rem = StringTools.trim(rem.substr(1));
                        if (StringTools.startsWith(rem, "else:")) {
                            var afterElse = StringTools.trim(rem.substr(5));
                            var qv2 = extractQuoted(afterElse);
                            if (qv2 != null) elsePart = qv2.value;
                        }
                    }
                }
                if (cond != null && doPart != null) {
                    out.add('<%= if ' + StringTools.replace(cond, "assigns.", "@") + ' do %>');
                    out.add(doPart);
                    if (elsePart != null && elsePart != "") { out.add('<% else %>'); out.add(elsePart); }
                    out.add('<% end %>');
                } else {
                    out.add(s.substr(start, (endTag + 2) - start));
                }
            } else {
                out.add(s.substr(start, (endTag + 2) - start));
            }
            i = endTag + 2;
        }
        return out.toString();
    }

    static function extractQuoted(s:String):Null<{value:String, length:Int}> {
        if (s.length == 0) return null;
        var quote = s.charAt(0);
        if (quote != '"' && quote != '\'') return null;
        var i = 1;
        while (i < s.length) {
            var ch = s.charAt(i);
            if (ch == quote) {
                var val = s.substr(1, i - 1);
                return { value: val, length: i + 1 };
            }
            i++;
        }
        return null;
    }

    /**
     * Structured rewrite of <if {cond}> ... (<else> ...)? </if> into block HEEx.
     * Handles nesting and maps assigns.* to @*.
     */
    public static function rewriteControlTags(s:String):String {
        if (s == null || s.indexOf("<if") == -1) return s;
        var out = new StringBuf();
        var i = 0;
        while (i < s.length) {
            var idx = s.indexOf("<if", i);
            if (idx == -1) { out.add(s.substr(i)); break; }
            out.add(s.substr(i, idx - i));
            var j = idx + 3; // after '<if'
            while (j < s.length && ~/^\s$/.match(s.charAt(j))) j++;
            if (j >= s.length || s.charAt(j) != '{') { out.add("<if"); i = idx + 3; continue; }
            var braceStart = j; j++;
            var braceDepth = 1;
            while (j < s.length && braceDepth > 0) {
                var ch = s.charAt(j);
                if (ch == '{') braceDepth++; else if (ch == '}') braceDepth--; j++;
            }
            if (braceDepth != 0) { out.add(s.substr(idx)); break; }
            var braceEnd = j - 1;
            while (j < s.length && ~/^\s$/.match(s.charAt(j))) j++;
            if (j >= s.length || s.charAt(j) != '>') { out.add(s.substr(idx, j - idx)); i = j; continue; }
            var openEnd = j + 1;
            var cond = StringTools.trim(s.substr(braceStart + 1, braceEnd - (braceStart + 1)));
            cond = StringTools.replace(cond, "assigns.", "@");
            // find matching </if>
            var k = openEnd;
            var depth = 1;
            var elsePos = -1;
            while (k < s.length && depth > 0) {
                var nextIf = s.indexOf("<if", k);
                var nextElse = s.indexOf("<else>", k);
                var nextClose = s.indexOf("</if>", k);
                var next = -1;
                var tag = 0;
                if (nextIf != -1) { next = nextIf; tag = 1; }
                if (nextElse != -1 && (next == -1 || nextElse < next)) { next = nextElse; tag = 2; }
                if (nextClose != -1 && (next == -1 || nextClose < next)) { next = nextClose; tag = 3; }
                if (next == -1) break;
                if (tag == 1) { depth++; k = next + 3; }
                else if (tag == 2 && depth == 1 && elsePos == -1) { elsePos = next; k = next + 6; }
                else if (tag == 3) { depth--; k = next + 5; }
                else k = next + 1;
            }
            if (depth != 0) { out.add(s.substr(idx)); break; }
            var closeIdx = k - 5;
            var thenStart = openEnd;
            var thenEnd = elsePos != -1 ? elsePos : closeIdx;
            var elseStart = elsePos != -1 ? (elsePos + 6) : -1;
            var elseEnd = closeIdx;
            var thenHtml = s.substr(thenStart, thenEnd - thenStart);
            var elseHtml = elseStart != -1 ? s.substr(elseStart, elseEnd - elseStart) : null;
            out.add('<%= if ' + cond + ' do %>');
            out.add(thenHtml);
            if (elseHtml != null && StringTools.trim(elseHtml) != "") { out.add('<% else %>'); out.add(elseHtml); }
            out.add('<% end %>');
            var afterClose = s.indexOf('>', closeIdx + 1);
            i = (afterClose == -1) ? s.length : afterClose + 1;
        }
        return out.toString();
    }

    static function indexOfTopLevel(s:String, token:String):Int {
        var depth = 0;
        var inS = false, inD = false;
        for (i in 0...s.length - token.length + 1) {
            var ch = s.charAt(i);
            if (!inS && ch == '"' && !inD) { inD = true; continue; }
            else if (inD && ch == '"') { inD = false; continue; }
            if (!inD && ch == '\'' && !inS) { inS = true; continue; }
            else if (inS && ch == '\'') { inS = false; continue; }
            if (inS || inD) continue;
            if (ch == '(' || ch == '{' || ch == '[') depth++;
            else if (ch == ')' || ch == '}' || ch == ']') depth--;
            if (depth != 0) continue;
            if (s.substr(i, token.length) == token) return i;
        }
        return -1;
    }
    
    /**
     * Collect template argument for function calls within templates
     */
    public static function collectTemplateArgument(ast: ElixirAST): String {
        return switch(ast.def) {
            case EString(s): '"' + s + '"';
            case EVar(name): name;
            case EAtom(a): ":" + a;
            case EInteger(i): Std.string(i);
            case EFloat(f): Std.string(f);
            case EBoolean(b): b ? "true" : "false";
            case ENil: "nil";
            case EField(obj, field):
                switch(obj.def) {
                    case EVar(v): v + "." + field;
                    default: "[complex]." + field;
                }
            default: "[complex arg]";
        };
    }
    
    /**
     * Check if an expression is an HXX module access
     * 
     * Detects patterns like HXX.hxx() or hxx.HXX.hxx()
     */
    public static function isHXXModule(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(m):
                // Check if this is the HXX module
                var moduleName = moduleTypeToString(m);
                #if debug_hxx_transformation
                #if debug_ast_builder
                trace('[HXX] Checking module: $moduleName against "HXX"');
                #end
                #end
                moduleName == "HXX";
            default: 
                #if debug_hxx_transformation
                #if debug_ast_builder
                trace('[HXX] Not a TTypeExpr, expr type: ${expr.expr}');
                #end
                #end
                false;
        };
    }
    
    /**
     * Convert a ModuleType to string representation
     * Helper function for isHXXModule
     */
    static function moduleTypeToString(m: ModuleType): String {
        return switch (m) {
            case TClassDecl(c):
                var cls = c.get();
                if (cls.pack.length > 0) {
                    cls.pack.join(".") + "." + cls.name;
                } else {
                    cls.name;
                }
            case TEnumDecl(e):
                var enm = e.get();
                if (enm.pack.length > 0) {
                    enm.pack.join(".") + "." + enm.name;
                } else {
                    enm.name;
                }
            case TAbstract(a):
                var abs = a.get();
                if (abs.pack.length > 0) {
                    abs.pack.join(".") + "." + abs.name;
                } else {
                    abs.name;
                }
            case TTypeDecl(t):
                var typ = t.get();
                if (typ.pack.length > 0) {
                    typ.pack.join(".") + "." + typ.name;
                } else {
                    typ.name;
                }
        };
    }
}

#end
</file>

<file path="src/reflaxe/elixir/ast/ElixirASTTransformer.hx">
package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import haxe.macro.Expr.Position;
import reflaxe.elixir.ast.ASTUtils;
import reflaxe.elixir.ast.ElixirAST.VarOrigin;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTBuilder;
import reflaxe.elixir.ast.naming.ElixirAtom;
import reflaxe.elixir.ast.transformers.GuardConditionFlattener;
import reflaxe.elixir.ast.transformers.LoopVariableRestorer;
import reflaxe.elixir.ast.transformers.PatternMatchingTransforms;
import reflaxe.elixir.ast.transformers.StructUpdateTransform;

using StringTools;

/**
 * Transformation pass function type
 * Takes an AST node and returns a transformed node
 *
 * WHY: Stateless transformations that don't need compilation context
 * WHEN: Use for passes that only need AST structure (pattern matching, syntax cleanup)
 */
typedef TransformPass = (ast: ElixirAST) -> ElixirAST;

/**
 * Contextual transformation pass function type
 * Takes an AST node and compilation context, returns a transformed node
 *
 * WHY: Enable passes to access shared compilation state (variable mappings, metadata)
 * WHEN: Use for passes that need:
 *   - Variable rename information (tempVarRenameMap)
 *   - Cross-expression state tracking
 *   - Coordination with builder phase decisions
 *
 * ARCHITECTURE:
 * - Context provides authoritative source of truth for variable naming
 * - Passes read from and write to context.tempVarRenameMap
 * - Ensures consistency between builder and transformer phases
 *
 * EXAMPLE: HygieneTransforms.usageAnalysisPass uses context to:
 *   - Read variable renames from builder phase
 *   - Apply consistent underscore prefixes
 *   - Ensure declarations match references
 */
typedef ContextualTransformPass = (ast: ElixirAST, context: reflaxe.elixir.CompilationContext) -> ElixirAST;

/**
 * Pass configuration
 *
 * WHY: Hybrid pattern supporting both stateless and contextual passes
 * WHAT: Each pass can provide either or both variants
 * HOW: transform() checks for contextualPass first, falls back to pass
 *
 * BACKWARD COMPATIBILITY:
 * - Existing passes continue to work with only 'pass' field
 * - New passes can use 'contextualPass' when context needed
 * - Migration is gradual, pass by pass
 */
typedef PassConfig = {
    name: String,
    description: String,
    enabled: Bool,
    pass: TransformPass,
    /**
     * Optional contextual variant of the pass (receives CompilationContext)
     */
    ?contextualPass: ContextualTransformPass,
    /**
     * Optional phase tag used for coarse ordering groups (e.g., "early", "post_interpolate").
     * When omitted, the pass remains in its original relative position unless constrained
     * by runAfter/runBefore.
     */
    ?phase: String,
    /**
     * Optional hard ordering constraints. Each entry indicates a pass name that this
     * pass must run AFTER. Multiple entries are allowed. Names not present in the registry
     * are ignored to keep ordering robust across optional builds.
     */
    ?runAfter: Array<String>,
    /**
     * Optional hard ordering constraints. Each entry indicates a pass name that this
     * pass must run BEFORE. Multiple entries are allowed. Unknown names are ignored.
     */
    ?runBefore: Array<String>
};

/**
 * ElixirASTTransformer: AST-to-AST Transformation Engine (Transformation Phase)
 * 
 * WHY: Central transformation phase for converting Haxe patterns to idiomatic Elixir
 * - Separates transformation logic from parsing and generation
 * - Enables multiple optimization and idiom conversion passes
 * - Makes transformations testable and composable
 * - Allows gradual addition of new transformations without breaking existing ones
 * 
 * WHAT: Applies a series of transformation passes to ElixirAST
 * - Each pass focuses on one specific transformation
 * - Passes can be enabled/disabled independently
 * - Transformations preserve semantics while improving idiomaticity
 * - Handles imperative‚Üífunctional, mutable‚Üíimmutable, loops‚Üícomprehensions
 * 
 * HOW: Pass-based architecture with recursive AST traversal
 * - Identity transformation as base (pass-through unchanged)
 * - Each pass is a separate function that pattern matches on AST nodes
 * - Passes are composed in a specific order for correctness
 * - Metadata preserved and enriched through transformations
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Each pass has one transformation goal
 * - Open/Closed: New passes can be added without modifying existing
 * - Composability: Passes can be combined and reordered
 * - Debuggability: Each pass can be tested in isolation
 * - Performance: Only enabled passes are executed
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTTransformer {
    // Public aliases for local transform passes (for registry access)
    public static var alias_abstractMethodThisPass: TransformPass = abstractMethodThisPass;
    public static var alias_arrayLengthFieldToFunctionPass: TransformPass = arrayLengthFieldToFunctionPass;
    public static var alias_bitwiseImportPass: TransformPass = bitwiseImportPass;
    public static var alias_comprehensionConversionPass: TransformPass = comprehensionConversionPass;
    public static var alias_conditionalReassignmentPass: TransformPass = conditionalReassignmentPass;
    public static var alias_constantFoldingPass: TransformPass = constantFoldingPass;
    public static var alias_ectoQueryRequirePass: TransformPass = ectoQueryRequirePass;
    public static var alias_fixBareConcatenationsPass: TransformPass = fixBareConcatenationsPass;
    public static var alias_fluentApiOptimizationPass: TransformPass = fluentApiOptimizationPass;
    public static var alias_functionReferenceTransformPass: TransformPass = functionReferenceTransformPass;
    public static var alias_guardGroupingPass: TransformPass = guardGroupingPass;
    public static var alias_heexContentInlinePass: TransformPass = heexContentInlinePass;
    public static var alias_identityPass: TransformPass = identityPass;
    public static var alias_idiomaticEnumPatternMatchingPass: TransformPass = idiomaticEnumPatternMatchingPass;
    public static var alias_immutabilityTransformPass: TransformPass = immutabilityTransformPass;
    public static var alias_instanceMethodTransformPass: TransformPass = instanceMethodTransformPass;
    public static var alias_listEffectLiftingPass: TransformPass = listEffectLiftingPass;
    public static var alias_liveViewCoreComponentsImportPass: TransformPass = liveViewCoreComponentsImportPass;
    public static var alias_loopTransformationPass: TransformPass = loopTransformationPass;
    public static var alias_nullCoalescingInlinePass: TransformPass = nullCoalescingInlinePass;
    public static var alias_numericNoOpCleanupPass: TransformPass = numericNoOpCleanupPass;
    public static var alias_otpChildSpecTransformPass: TransformPass = otpChildSpecTransformPass;
    public static var alias_phoenixComponentImportPass: TransformPass = phoenixComponentImportPass;
    public static var alias_phoenixFunctionMappingPass: TransformPass = phoenixFunctionMappingPass;
    public static var alias_pipelineOptimizationPass: TransformPass = pipelineOptimizationPass;
    public static var alias_prefixUnusedParametersPass: TransformPass = prefixUnusedParametersPass;
    public static var alias_removeRedundantEnumExtractionPass: TransformPass = removeRedundantEnumExtractionPass;
    public static var alias_removeRedundantNilInitPass: TransformPass = removeRedundantNilInitPass;
    public static var alias_selfReferenceTransformPass: TransformPass = selfReferenceTransformPass;
    public static var alias_statementContextTransformPass: TransformPass = statementContextTransformPass;
    public static var alias_stringInterpolationPass: TransformPass = stringInterpolationPass;
    public static var alias_stringMethodTransformPass: TransformPass = stringMethodTransformPass;
    public static var alias_structFieldAssignmentTransformPass: TransformPass = structFieldAssignmentTransformPass;
    public static var alias_supervisorOptionsTransformPass: TransformPass = supervisorOptionsTransformPass;
    public static var alias_throwStatementTransformPass: TransformPass = throwStatementTransformPass;
    public static var alias_tupleElemFieldToFunctionPass: TransformPass = tupleElemFieldToFunctionPass;
    public static var alias_underscoreVariableCleanupPass: TransformPass = underscoreVariableCleanupPass;

    // Public aliases for local transform passes (for registry access)

    // Public aliases for local transform passes (for registry access)

    
    /**
     * Main entry point: Apply all transformation passes
     *
     * WHY: Single interface for all AST transformations with optional context support
     * WHAT: Applies enabled passes in order, using contextual variant when available
     * HOW: Iterates through pass list, selecting appropriate variant for each pass
     *
     * CONTEXTUAL PASS SUPPORT:
     * - If pass has contextualPass AND context provided ‚Üí Use contextual variant
     * - Otherwise ‚Üí Use stateless pass (backward compatible)
     * - Enables passes to access compilation state (variable mappings, metadata)
     * - Ensures consistency between builder and transformer phases
     *
     * @param ast The AST to transform
     * @param context Optional compilation context for contextual passes
     * @return Transformed AST
     */
    public static function transform(ast: ElixirAST, ?context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_ast_transformer
        #if sys
        Sys.println('[XRay AST Transformer] Starting transformation pipeline');
        #else
        trace('[XRay AST Transformer] Starting transformation pipeline');
        #end
        trace('[XRay AST Transformer] AST type: ${Type.enumConstructor(ast.def)}');
        trace('[XRay AST Transformer] AST metadata: ${ast.metadata}');
        #end
        #if debug_unrolled_comprehension
        trace('[DEBUG Transform] ElixirASTTransformer.transform() called');
        #end
        
        #if debug_ast_structure
        // Print AST structure for debugging
        switch(ast.def) {
            case EModule(name, _, _):
                trace('[XRay AST Structure] Module: $name');
            default:
                trace('[XRay AST Structure] Root: ${ast.def}');
        }
        #end
        
        var passes = getEnabledPasses();
        var result = ast;
        #if hxx_instrument_sys
        var __pipelineStart = haxe.Timer.stamp();
        #end
        
        for (passConfig in passes) {
            #if debug_ast_transformer
            #if sys
            Sys.println('[XRay AST Transformer] Applying pass: ${passConfig.name}');
            #else
            trace('[XRay AST Transformer] Applying pass: ${passConfig.name}');
            #end
            #end

            /**
             * PassMetrics (debug_pass_metrics)
             *
             * WHAT
             * - Optional, flag‚Äëgated per‚Äëpass change detector that reports when a pass
             *   modifies the AST during the main transformation loop.
             *
             * WHY
             * - Speeds up diagnosis of "which pass changed this?" without heavy logging
             *   or snapshotting. Helps avoid circular debugging by pinpointing impact.
             *
             * HOW
             * - Before running a pass, render the current AST to a string using the printer.
             * - After the pass, render again and compare. If different, emit a concise
             *   line: `#[PassMetrics] Changed by: <passName>`.
             * - Guarded by `-D debug_pass_metrics`; zero cost and zero output otherwise.
             *
             * EXAMPLES
             * - Build with: `-D debug_pass_metrics` to get a per‚Äëpass change trace.
             * - Typical output:
             *   `#[PassMetrics] Changed by: FilterQueryConsolidate`
             */
            #if debug_pass_metrics
            var __beforePrint: String = null;
            try __beforePrint = reflaxe.elixir.ast.ElixirASTPrinter.print(result, 0) catch (e: Dynamic) {}
            #end

            // CONTEXTUAL PASS SELECTION LOGIC
            // WHY: Enable passes to access compilation context when needed
            // WHAT: Check for contextualPass variant first, fall back to regular pass
            // HOW: Conditional logic based on contextualPass availability and context presence
            //
            // ARCHITECTURE:
            // 1. If contextualPass exists AND context provided ‚Üí Use contextual variant
            // 2. Otherwise ‚Üí Use stateless pass variant (backward compatible)
            //
            // This ensures:
            // - Contextual passes get access to tempVarRenameMap for consistency
            // - Non-contextual passes continue working unchanged
            // - No null pointer errors when context not provided
            #if hxx_instrument_sys
            var __t0 = haxe.Timer.stamp();
            #end
            if (passConfig.contextualPass != null && context != null) {
                #if debug_contextual_passes
                trace('[XRay Contextual Pass] Using contextual variant for: ${passConfig.name}');
                trace('[XRay Contextual Pass] Context available: ${context != null}');
                trace('[XRay Contextual Pass] Variable mappings: ${context.tempVarRenameMap.keys()}');
                #end

                result = passConfig.contextualPass(result, context);
            } else {
                #if debug_contextual_passes
                trace('[XRay Contextual Pass] Using stateless variant for: ${passConfig.name}');
                trace('[XRay Contextual Pass] Contextual variant available: ${passConfig.contextualPass != null}');
                trace('[XRay Contextual Pass] Context provided: ${context != null}');
                #end

                result = passConfig.pass(result);
            }
            #if hxx_instrument_sys
            var __elapsedPass = (haxe.Timer.stamp() - __t0) * 1000.0;
            #if sys
            Sys.println('[PassTiming] name=' + passConfig.name + ' ms=' + Std.int(__elapsedPass));
            #else
            trace('[PassTiming] name=' + passConfig.name + ' ms=' + Std.int(__elapsedPass));
            #end
            #end

            #if debug_ast_snapshots
            // Per‚Äëpass function snapshot: when debug_ast_snapshots_func is set,
            // dump the target function after each pass to tmp/ast_flow/passes.
            try {
                PerPassSnapshot.emitFunctionAfterPass(result, passConfig.name);
            } catch (e: Dynamic) {
                #if sys Sys.println('[AST Snapshot] PerPass failed for ' + passConfig.name + ': ' + Std.string(e)); #end
            }
            #end

            #if debug_pass_metrics
            var __afterPrint: String = null;
            var __changed: Bool = false;
            try {
                __afterPrint = reflaxe.elixir.ast.ElixirASTPrinter.print(result, 0);
                __changed = (__beforePrint != __afterPrint);
            } catch (e: Dynamic) {}
            if (__changed) {
                #if sys Sys.println('#[PassMetrics] Changed by: ' + passConfig.name); #else trace('#[PassMetrics] Changed by: ' + passConfig.name); #end
            }
            #end
        }
        
        #if hxx_instrument_sys
        var __pipelineElapsed = (haxe.Timer.stamp() - __pipelineStart) * 1000.0;
        #if sys
        Sys.println('[PassTiming] name=ElixirASTTransformer.total ms=' + Std.int(__pipelineElapsed));
        #else
        trace('[PassTiming] name=ElixirASTTransformer.total ms=' + Std.int(__pipelineElapsed));
        #end
        #end

        #if debug_ast_transformer
        trace('[XRay AST Transformer] Transformation complete');
        #end

        // ------------------------------------------------------------------
        // AbsoluteFinal Snapshot (debug_ast_snapshots)
        //
        // WHAT
        // - Optional, flag‚Äëgated AST snapshot immediately before printing.
        // - Captures only the then‚Äëbranch of the main guard `if` inside
        //   filter_todos/3 for the todo‚Äëapp to minimize noise.
        //
        // WHY
        // - We need to confirm the final shape of the filter branch:
        //   either a named binder `query = String.downcase(search_query)`
        //   precedes Enum.filter, or the downcased query is inlined within
        //   the filter predicate (EFn/ERaw). Pass ordering and rescue/final
        //   rewrites make late shape shifts hard to reason about via logs.
        //
        // HOW
        // - When `-D debug_ast_snapshots` is set, traverse the transformed
        //   AST, find `filter_todos/3` (EDef/EDefp name "filter_todos" with
        //   arity 3), locate the first top‚Äëlevel EIf within its body, and
        //   print its thenBranch to `tmp/ast_flow/AbsoluteFinal_filter_todos_then_branch.ex`.
        // - Optional defines (if provided) allow function‚Äëlevel selection:
        //   `-D debug_ast_snapshots_func=filter_todos/3`
        //   `-D debug_ast_snapshots_module=TodoAppWeb.TodoLive`
        //   These are best‚Äëeffort; default targets filter_todos/3 globally.
        //
        // EXAMPLES
        // Haxe (goal):
        //   if (searchQuery != "") {
        //     final query = String.downcase(searchQuery);
        //     return Enum.filter(todos, (t) -> String.contains(String.downcase(t.title), query));
        //   } else {
        //     todos;
        //   }
        // Elixir snapshot (then‚Äëbranch):
        //   query = String.downcase(search_query)
        //   Enum.filter(todos, fn t -> String.contains?(String.downcase(t.title), query) end)
        //   # or inline: Enum.filter(..., fn t -> String.contains?(String.downcase(t.title), String.downcase(search_query)) end)
        // ------------------------------------------------------------------
        #if debug_ast_snapshots
        try {
            AbsoluteFinalSnapshot.emitFilterTodosThenBranch(result);
        } catch (e: Dynamic) {
            #if sys Sys.println('[AST Snapshot] Failed: ' + Std.string(e)); #else trace('[AST Snapshot] Failed: ' + Std.string(e)); #end
        }
        #end

        #if debug_ast_transformer
        trace('[XRay AST Transformer] Transformation complete');
        #end
        return result;
    }
    
    /**
     * Get list of enabled transformation passes
     */
    static function getEnabledPasses(): Array<PassConfig> {
        return reflaxe.elixir.ast.transformers.registry.ElixirASTPassRegistry.getEnabledPasses();
    }

    // (debug_ast_snapshots helper moved to a top-level private class below)


    /**
     * Guard Condition Grouping Pass
     * 
     * WHY: When Haxe switch statements contain multiple cases with the same pattern but different 
     * guard conditions, the compiler was generating nested if-else statements with undefined variables.
     * This pass transforms these patterns into idiomatic Elixir `cond` statements.
     * 
     * WHAT: Transforms multiple case clauses with identical patterns but different guards into
     * a single clause with a `cond` expression in the body.
     * 
     * Example transformation:
     *   case color do
     *     {:rgb, r, g, b} when r > 200 -> "red dominant"
     *     {:rgb, r, g, b} when g > 200 -> "green dominant"  
     *     {:rgb, r, g, b} when b > 200 -> "blue dominant"
     *     {:rgb, r, g, b} -> "balanced"
     *   end
     * 
     * Becomes:
     *   case color do
     *     {:rgb, r, g, b} ->
     *       cond do
     *         r > 200 -> "red dominant"
     *         g > 200 -> "green dominant"
     *         b > 200 -> "blue dominant"
     *         true -> "balanced"
     *       end
     *   end
     * 
     * HOW: Uses metadata attached by ElixirASTBuilder (patternKey, boundVars, hasGuard)
     * to detect groupable clauses and transform them.
     */
    public static function guardGroupingPass(ast: ElixirAST): ElixirAST {
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Starting guard grouping pass with three-phase flattener');
        if (ast != null && ast.def != null) {
            trace('[XRay GuardGrouping] Processing node type: ' + ast.def);
        }
        #end
        
        // Handle null nodes
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EParen(inner):
                // Check if the parentheses wrap a case expression
                #if debug_guard_grouping
                trace("[XRay GuardGrouping] Found EParen, checking inner content");
                #end
                
                switch(inner?.def) {
                    case ECase(target, clauses):
                        #if debug_guard_grouping
                        trace("[XRay GuardGrouping] Found ECase inside EParen, transforming");
                        #end
                        
                        // Transform the case expression
                        var transformedClauses = [];
                        for (clause in clauses) {
                            var transformedClause = transformClauseWithGuards(clause);
                            transformedClauses.push(transformedClause);
                        }
                        
                        // Return the transformed case WITHOUT parentheses
                        // (parentheses around case are usually not needed)
                        makeASTWithMeta(
                            ECase(transformAST(target, guardGroupingPass), transformedClauses),
                            ast.metadata,
                            ast.pos
                        );
                        
                    default:
                        // Not a case inside parentheses, recurse normally
                        makeASTWithMeta(
                            EParen(transformAST(inner, guardGroupingPass)),
                            ast.metadata,
                            ast.pos
                        );
                }
                
            case ECase(target, clauses):
                #if debug_guard_grouping
                trace("[XRay GuardGrouping] Found direct ECase with " + clauses.length + " clauses");
                #end
                
                // Transform each clause individually
                var transformedClauses = [];
                
                for (clause in clauses) {
                    // Check if the clause body is a nested if-else chain (guards compiled by Haxe)
                    var transformedClause = transformClauseWithGuards(clause);
                    transformedClauses.push(transformedClause);
                }
                
                makeASTWithMeta(
                    ECase(transformAST(target, guardGroupingPass), transformedClauses),
                    ast.metadata,
                    ast.pos
                );
                
            default:
                // For nodes we don't handle, use transformAST to recursively transform children
                transformAST(ast, guardGroupingPass);
        };
    }
    
    /**
     * Transform a case clause that has guards compiled as nested if-else
     * Uses the three-phase GuardConditionFlattener for robust transformation
     */
    static function transformClauseWithGuards(clause: ECaseClause): ECaseClause {
        #if debug_guard_grouping
        trace("[XRay GuardGrouping] Examining clause with three-phase flattener");
        if (clause.pattern != null) {
            trace("[XRay GuardGrouping] Pattern type: " + Type.typeof(clause.pattern));
        }
        if (clause.body != null) {
            trace("[XRay GuardGrouping] Body def: " + clause.body.def);
        }
        #end
        
        // Phase 1: Collect all guard conditions from nested if-else chains
        var guardBranches = GuardConditionCollector.collectAllGuardConditions(clause.body);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 1 - Collected ${guardBranches.length} guard branches');
        #end
        
        // If no guard conditions found, just transform recursively
        if (guardBranches.length == 0) {
            return {
                pattern: clause.pattern,
                guard: clause.guard,
                body: transformAST(clause.body, guardGroupingPass)
            };
        }
        
        // Phase 2: Validate that conditions can be grouped
        // Extract bound variables from the pattern for validation
        var boundVars = extractBoundVariablesFromPattern(clause.pattern);
        var validationResult = GuardGroupValidator.validateGuardGroup(guardBranches, boundVars);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 2 - Validation result: canGroup=${validationResult.canGroup}, reason="${validationResult.reason}"');
        #end
        
        // If validation fails, fall back to recursive transformation
        if (!validationResult.canGroup) {
            #if debug_guard_grouping
            trace('[XRay GuardGrouping] Validation failed: ${validationResult.reason}');
            #end
            return {
                pattern: clause.pattern,
                guard: clause.guard,
                body: transformAST(clause.body, guardGroupingPass)
            };
        }
        
        // Phase 3: Reconstruct as a flat cond expression
        var flatCond = GuardConditionReconstructor.buildFlatCond(guardBranches, boundVars, clause.pattern);
        
        #if debug_guard_grouping
        trace('[XRay GuardGrouping] Phase 3 - Built flat cond expression');
        #end
        
        return {
            pattern: clause.pattern,
            guard: null,
            body: flatCond
        };
    }
    
    /**
     * Extract bound variable names from a pattern
     */
    static function extractBoundVariablesFromPattern(pattern: EPattern): Array<String> {
        var vars = [];
        
        function extract(p: EPattern): Void {
            switch(p) {
                case PVar(name): 
                    vars.push(name);
                case PTuple(patterns):
                    // Tuples can contain variables (like enum constructors)
                    for (subPattern in patterns) {
                        extract(subPattern);
                    }
                case PList(patterns):
                    for (subPattern in patterns) {
                        extract(subPattern);
                    }
                case PAlias(varName, pattern):
                    vars.push(varName);
                    extract(pattern);
                case PCons(head, tail):
                    extract(head);
                    extract(tail);
                default:
                    // Other patterns don't bind variables
            }
        }
        
        if (pattern != null) {
            extract(pattern);
        }
        
        return vars;
    }
    
    /**
     * Remove nil assignments for generated variables (r2 = nil, b3 = nil, etc.)
     * These are created by Haxe's guard compilation but are not needed
     */
    static function removeNilAssignments(ast: ElixirAST): ElixirAST {
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EBlock(exprs):
                #if debug_guard_grouping
                trace('[XRay RemoveNil] Processing EBlock with ${exprs.length} expressions');
                #end
                // Filter out nil assignments for generated variables
                var filtered = [];
                for (expr in exprs) {
                    var isGeneratedNilAssignment = switch(expr.def) {
                        case EMatch(PVar(varName), rhs) if (rhs != null):
                            #if debug_guard_grouping
                            trace('[XRay RemoveNil] Checking match for variable: $varName');
                            trace('[XRay RemoveNil] RHS type: ' + Type.enumConstructor(rhs.def));
                            #end
                            switch(rhs.def) {
                                case EAtom(a):
                                    var atomStr = (a:String);
                                    #if debug_guard_grouping
                                    trace('[XRay RemoveNil] Atom value: "$atomStr"');
                                    #end
                                    if (atomStr == "nil") {
                                        // Check if variable name ends with digit (r2, b3, etc.)
                                        var isGenerated = ~/^[a-z]+\d+$/.match(varName);
                                        #if debug_guard_grouping
                                        trace('[XRay RemoveNil] Is generated variable: $isGenerated for $varName');
                                        #end
                                        isGenerated;
                                    } else {
                                        false;
                                    }
                                default: false;
                            }
                        default: false;
                    };
                    
                    if (!isGeneratedNilAssignment) {
                        // Recursively clean the expression
                        filtered.push(removeNilAssignments(expr));
                    }
                }
                
                // Return simplified block or single expression
                if (filtered.length == 0) {
                    null;
                } else if (filtered.length == 1) {
                    filtered[0];
                } else {
                    makeASTWithMeta(EBlock(filtered), ast.metadata, ast.pos);
                }
                
            default:
                // Recursively transform children
                transformAST(ast, removeNilAssignments);
        };
    }
    
    /**
     * Fix undefined variable references in guard conditions
     * Maps suffixed variables (g2, r2, b2) back to their original names (g, r, b)
     */
    static function fixUndefinedVariables(ast: ElixirAST): ElixirAST {
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EVar(name):
                // More comprehensive pattern to fix various undefined variables
                // Patterns to fix:
                // - Single letter with number: g2 -> g, r3 -> r, b4 -> b
                // - Names with number suffix: l2 -> l, h2 -> h, s2 -> s
                // - Multi-letter names: r2 -> r, g2 -> g, b2 -> b
                
                // Check for common patterns from the test output
                var fixedName = name;
                
                // Pattern 1: Single letter followed by digit(s)
                if (~/^[a-z]\d+$/.match(name)) {
                    fixedName = name.charAt(0);
                }
                // Pattern 2: Common variable names with numeric suffixes
                else if (~/^(r|g|b|h|s|l)\d+$/.match(name)) {
                    fixedName = ~/^([a-z]+)\d+$/.replace(name, "$1");
                }
                // Pattern 3: More general - any word followed by digits
                else if (~/^(\w+?)\d+$/.match(name)) {
                    var base = ~/^(\w+?)\d+$/.replace(name, "$1");
                    // Only fix if it looks like a generated variable
                    if (base.length <= 2) {
                        fixedName = base;
                    }
                }
                
                if (fixedName != name) {
                    #if debug_guard_grouping
                    trace('[XRay GuardGrouping] Fixing variable: $name -> $fixedName');
                    #end
                    makeASTWithMeta(EVar(fixedName), ast.metadata, ast.pos);
                } else {
                    ast;
                }
                
            case EBinary(op, left, right):
                // Fix both sides of binary operations
                var fixedLeft = fixUndefinedVariables(left);
                var fixedRight = fixUndefinedVariables(right);
                makeASTWithMeta(EBinary(op, fixedLeft, fixedRight), ast.metadata, ast.pos);
                
            case ECall(expr, method, args):
                // Fix function calls and their arguments
                var fixedExpr = fixUndefinedVariables(expr);
                var fixedArgs = args.map(fixUndefinedVariables);
                makeASTWithMeta(ECall(fixedExpr, method, fixedArgs), ast.metadata, ast.pos);
                
            case EIf(cond, thenBranch, elseBranch):
                // Fix all parts of if expressions
                var fixedCond = fixUndefinedVariables(cond);
                var fixedThen = fixUndefinedVariables(thenBranch);
                var fixedElse = elseBranch != null ? fixUndefinedVariables(elseBranch) : null;
                makeASTWithMeta(EIf(fixedCond, fixedThen, fixedElse), ast.metadata, ast.pos);
                
            case EParen(inner):
                // Fix inside parentheses
                var fixedInner = fixUndefinedVariables(inner);
                makeASTWithMeta(EParen(fixedInner), ast.metadata, ast.pos);
                
            default:
                // For other node types, recursively fix children
                transformAST(ast, fixUndefinedVariables);
        };
    }
    
    /**
     * Extract cond branches from nested if-else chain
     */
    static function extractCondBranches(ast: ElixirAST): Array<{condition: ElixirAST, body: ElixirAST}> {
        var branches = [];
        
        function extract(node: ElixirAST, depth: Int = 0) {
            if (node == null) return;
            
            #if debug_guard_grouping
            trace("[XRay ExtractBranches] Depth " + depth + ", node type: " + (node.def != null ? Type.enumConstructor(node.def) : "null"));
            #end
            
            // Clean up nil assignments first
            var cleanedNode = removeNilAssignments(node);
            if (cleanedNode == null) return;
            
            // Recursively unwrap blocks and parentheses after cleaning
            var nodeToProcess = cleanedNode;
            var unwrapping = true;
            while (unwrapping && nodeToProcess != null) {
                switch(nodeToProcess.def) {
                    case EBlock(exprs) if (exprs.length == 1):
                        nodeToProcess = exprs[0];
                    case EParen(inner):
                        nodeToProcess = inner;
                    default:
                        unwrapping = false;
                }
            }
            
            switch(nodeToProcess.def) {
                case EIf(cond, thenBranch, elseBranch):
                    // Fix variables in both the condition and body
                    var fixedCond = fixUndefinedVariables(cond);
                    var fixedBody = fixUndefinedVariables(thenBranch);
                    
                    branches.push({
                        condition: fixedCond,
                        body: fixedBody  // Don't transform here, will be done later
                    });
                    
                    #if debug_guard_grouping
                    trace("[XRay ExtractBranches] Added branch at depth " + depth);
                    #end
                    
                    // Recursively process else branch
                    if (elseBranch != null) {
                        extract(elseBranch, depth + 1);
                    }
                    
                case _:
                    // This is the final else case (or a single expression)
                    var fixedNode = fixUndefinedVariables(nodeToProcess);
                    branches.push({
                        condition: makeAST(EBoolean(true)),
                        body: fixedNode
                    });
                    
                    #if debug_guard_grouping
                    trace("[XRay ExtractBranches] Added final branch at depth " + depth);
                    #end
            }
        }
        
        extract(ast);
        return branches;
    }
    

    /**
     * InlineTempBindingInExpr: Collapse simple temp-binding EBlock into a single expression
     * 
     * TERMINOLOGY:
     * - "Collapse" means to transform a two-statement block into a single expression by
     *   inlining a temporary variable. For example:
     *   BEFORE: (tmp = Date.now(); DateTime.to_unix(tmp, :millisecond))
     *   AFTER:  DateTime.to_unix(Date.now(), :millisecond)
     *   The temporary variable 'tmp' is eliminated by substituting its value directly.
     * 
     * WHY: Abstract method inlining sometimes produces blocks like:
     *   %{:online_at => (tmp = Date.now(); DateTime.to_unix(tmp, :millisecond))}
     * which is invalid in map field position. We collapse to a single expression:
     *   %{:online_at => DateTime.to_unix(Date.now(), :millisecond)}
     * 
     * WHAT: Detect EBlock([EMatch(PVar(tmp), exprA), exprB]) where exprB contains EVar(tmp)
     * and replace all occurrences of tmp in exprB with exprA, eliminating the temp variable.
     * 
     * HOW: Two-phase approach to avoid infinite recursion:
     * 1. Build a parent map to track expression vs statement contexts
     * 2. Single bottom-up transformation pass that collapses only in expression contexts
     * 
     * EDGE CASES:
     * - Only collapse in expression contexts (map values, function args, etc.)
     * - Skip collapsing in statement contexts (case clause bodies, function bodies)
     * - Only collapse if the temp variable is actually used
     * - Preserve precedence by wrapping substituted expressions in parentheses
     */
    
    /**
     * Throw statement transformation pass
     * 
     * WHY: Complex expressions in throw statements can generate invalid Elixir syntax
     *      when string concatenation includes conditionals or function calls
     * WHAT: Transforms throw expressions with complex string concatenation
     * HOW: Wraps complex expressions in parentheses to ensure valid syntax
     */
    static function throwStatementTransformPass(ast: ElixirAST): ElixirAST {
        if (ast == null || ast.def == null) return ast;
        return switch(ast.def) {
            case EThrow(value):
                // Transform the throw value to ensure it's a valid single expression
                var transformedValue = transformThrowValue(value);
                {
                    def: EThrow(transformedValue),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
            default:
                // Recursively transform children using the standard transformer
                transformAST(ast, throwStatementTransformPass);
        };
    }
    
    /**
     * Transform throw value to ensure it generates valid Elixir syntax
     */
    static function transformThrowValue(expr: ElixirAST): ElixirAST {
        return switch(expr.def) {
            case EBinary(StringConcat, left, right):
                // For string concatenation, ensure both sides are properly formatted
                var leftTransformed = transformThrowValue(left);
                var rightTransformed = transformThrowValue(right);
                
                // If right side is complex, wrap it in parentheses
                var rightWrapped = switch(rightTransformed.def) {
                    case EIf(_, _, _):
                        {
                            def: EParen(rightTransformed),
                            metadata: rightTransformed.metadata,
                            pos: rightTransformed.pos
                        };
                    case ECall(_, _, _) if (hasConditionalInCall(rightTransformed)):
                        {
                            def: EParen(rightTransformed),
                            metadata: rightTransformed.metadata,
                            pos: rightTransformed.pos
                        };
                    default:
                        rightTransformed;
                };
                
                {
                    def: EBinary(StringConcat, leftTransformed, rightWrapped),
                    metadata: expr.metadata,
                    pos: expr.pos
                };
                
            case EIf(cond, then, els):
                // Wrap if expressions in parentheses when used in throw
                {
                    def: EParen(expr),
                    metadata: expr.metadata,
                    pos: expr.pos
                };
                
            default:
                expr;
        };
    }
    
    /**
     * Check if a call expression contains conditionals that might cause syntax issues
     */
    static function hasConditionalInCall(expr: ElixirAST): Bool {
        return switch(expr.def) {
            case ECall(_, _, args):
                Lambda.exists(args, function(arg) {
                    return switch(arg.def) {
                        case EIf(_, _, _): true;
                        default: false;
                    };
                });
            default: false;
        };
    }
    
    /**
     * Identity pass - returns AST unchanged
     * Base pass that ensures transformer works even with no transformations
     */
    static function identityPass(ast: ElixirAST): ElixirAST {
        return ast;
    }
    
    /**
     * Resolve Clause Locals Pass
     * 
     * WHY: Variables in case clause bodies need to match the names used in patterns.
     * When Haxe generates temporary variables (_g, g, etc.) for enum parameters,
     * but our patterns use the actual parameter names (value, reason, etc.),
     * we need to resolve these references.
     * 
     * WHAT: Looks for nodes with varIdToName metadata and rewrites EVar nodes
     * within them to use the mapped names based on their sourceVarId.
     * 
     * HOW: When we encounter a node with varIdToName metadata, we walk its
     * subtree and rewrite any EVar that has a sourceVarId matching an entry
     * in the varIdToName map.
     * 
     * EDGE CASES:
     * - Nested case expressions: Each case should have its own varIdToName scope
     * - String interpolation: Variables inside __elixir__() injections need resolution
     * - Anonymous functions: May reference outer scope variables
     */

    /**
     * Remove Redundant Enum Extraction Pass
     *
     * WHY: Elixir pattern matching already extracts values, but Haxe generates redundant elem() calls
     * WHAT: Removes assignments like `g = elem(result, 1)` after pattern `{:ok, g}`
     * HOW: Detects and removes redundant extraction statements in case bodies
     *
     * EXAMPLE:
     * Before:
     *   {:ok, g} ->
     *     g = elem(result, 1)  # Redundant!
     *     value = g
     *     value
     *
     * After:
     *   {:ok, g} ->
     *     value = g
     *     value
     */
    static function removeRedundantEnumExtractionPass(ast: ElixirAST): ElixirAST {
        #if debug_redundant_extraction
        trace('[RemoveRedundantEnumExtraction] Debug mode enabled');
        #end

        // Track the case target variable name for nested detection
        var caseTargetVar: String = null;
        // Track whether the current case has an enum binding plan
        var currentCaseHasBindingPlan: Bool = false;

        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ECase(target, clauses):
                    // Enhanced debug for ChangesetUtils issue
                    var targetDebug = switch(target.def) {
                        case EVar(v): 'variable: $v';
                        case EParen(inner): switch(inner.def) {
                            case EVar(v): 'variable in parens: $v';
                            default: 'complex expression';
                        };
                        default: 'complex expression';
                    };
                    #if debug_redundant_extraction
                    trace('[RemoveRedundantEnumExtraction] Processing ECase with ${clauses.length} clauses, target: $targetDebug');
                    #end
                    // Check if this case has an enum binding plan
                    currentCaseHasBindingPlan = node.metadata != null && node.metadata.hasEnumBindingPlan == true;
                    #if debug_enum_extraction
                    if (currentCaseHasBindingPlan) {
                        trace('[RemoveRedundantEnumExtraction] Found ECase with hasEnumBindingPlan flag');
                    }
                    #end

                    // Extract the case target variable name
                    switch(target.def) {
                        case EVar(v): caseTargetVar = v;
                        case EParen(inner):
                            switch(inner.def) {
                                case EVar(v): caseTargetVar = v;
                                default:
                            }
                        default:
                    }

                    // trace('[RemoveRedundantEnumExtraction] Processing case with target: $caseTargetVar');
                    // Process each case clause
                    var newClauses = [];
                    for (i in 0...clauses.length) {
                        var clause = clauses[i];
                        // ECaseClause is a typedef with pattern, guard, and body fields
                        var pattern = clause.pattern;
                        var guard = clause.guard;
                        var body = clause.body;

                        // Debug pattern to understand ChangesetUtils issue
                        #if debug_redundant_extraction
                        var patternDebug = switch(pattern) {
                            case PTuple(elements):
                                var elemStrs = [for (e in elements) switch(e) {
                                    case PLiteral(ast):
                                        switch(ast.def) {
                                            case EAtom(a): ':$a';
                                            default: '?';
                                        }
                                    case PVar(v): v;
                                    default: '?';
                                }];
                                '{${elemStrs.join(", ")}}';
                            default: 'other pattern';
                        };
                        trace('[RemoveRedundantEnumExtraction] Clause $i pattern: $patternDebug');
                        #end

                        // Propagate the binding plan flag to the clause body
                        if (currentCaseHasBindingPlan && body != null) {
                            if (body.metadata == null) body.metadata = {};
                            body.metadata.parentHasBindingPlan = true;
                        }

                        // Check if body contains redundant extraction (guard for null bodies)
                        var newBody = if (body == null) null else switch(body.def) {
                            case EBlock(exprs):
                                // M0 FIX: Track variable renames when removing redundant assignments
                                var varRenames: Map<String, String> = new Map();

                                // First pass: Filter out redundant elem() assignments and track renames
                                var filtered = [];
                                for (i in 0...exprs.length) {
                                    var expr = exprs[i];

                                    // Skip null expressions (these are filtered assignments from TEnumParameter)
                                    if (expr == null) {
                                        continue;
                                    }

                                    var isRedundant = false;

                                    // Check if marked as redundant via metadata
                                    if (expr.metadata != null && expr.metadata.redundantEnumExtraction == true) {
                                        isRedundant = true;
                                        #if debug_redundant_extraction
                                        trace('[RemoveRedundantEnumExtraction] Found node marked as redundant via metadata');
                                        #end
                                    }

                                    // Check if this is a redundant extraction
                                    switch(expr.def) {
                                        case EMatch(PVar(varName), rhs):
                                            // Enhanced debug for ChangesetUtils issues
                                            if (rhs != null) {
                                                var rhsDebug = switch(rhs.def) {
                                                    case EVar(v): 'EVar($v)';
                                                    case ECall(_, fn, _): 'ECall($fn)';
                                                    default: Type.enumConstructor(rhs.def);
                                                };
                                                #if debug_redundant_extraction
                                                trace('[RemoveRedundantEnumExtraction] Found assignment: $varName = ... (RHS: $rhsDebug, caseTarget: $caseTargetVar)');
                                                #end
                                            } else {
                                                #if debug_redundant_extraction
                                                trace('[RemoveRedundantEnumExtraction] Found assignment: $varName = null (skipped assignment)');
                                                #end
                                                // Mark this as redundant since it has no RHS
                                                isRedundant = true;
                                            }

                                            // Check for self-assignment first (e.g., content = content)
                                        if (varName == switch(rhs.def) {
                                            case EVar(v): v;
                                            default: null;
                                        }) {
                                            isRedundant = true;
                                            #if debug_redundant_extraction
                                            trace('[RemoveRedundantEnumExtraction] Removing self-assignment: $varName = $varName');
                                            #end
                                        }
                                        // Check if the target variable itself is a temp pattern var
                                        else if (reflaxe.elixir.ast.ElixirASTBuilder.isTempPatternVarName(varName)) {
                                            isRedundant = true;
                                            #if debug_redundant_extraction
                                            trace('[RemoveRedundantEnumExtraction] Removing temp-var assignment: $varName = ...');
                                            #end
                                        }
                                        // Check if RHS is a reference to a temp variable (g, g1, g2, _g, etc.)
                                        else switch(rhs.def) {
                                            case EVar(v):
                                                // Check if this is an assignment from a temp variable
                                                    // Handle both "g" and "_g" patterns
                                                    // CRITICAL FIX: For idiomatic enums, the pattern uses the actual variable names
                                                    // (like {:ok, value}) instead of temp vars (like {:ok, g}).
                                                    // This means assignments like "value = g" are trying to assign from a
                                                    // non-existent variable 'g'. These MUST be removed unconditionally.
                                                    //
                                                    // Enhanced: For idiomatic enums with canonical pattern names,
                                                    // ANY assignment where RHS is "g" or a temp var should be removed
                                                    // because patterns already extract the values

                                                    // First, check if RHS is "g" (regardless of what LHS is)
                                                    // This catches "value = g" in idiomatic enums
                                                    if (v == "g" || v == "_g") {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent temp var)');
                                                        #end
                                                    }
                                                    // Check for numbered temp vars in RHS: g1, g2, etc.
                                                    else if (v.length > 1 && v.charAt(0) == "g" &&
                                                             v.length == 2 && v.charAt(1) >= '0' && v.charAt(1) <= '9') {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent numbered temp var)');
                                                        #end
                                                    }
                                                    // Check for underscore-prefixed numbered temp vars: _g1, _g2, etc.
                                                    else if (v.length == 3 && v.charAt(0) == "_" && v.charAt(1) == "g" &&
                                                             v.charAt(2) >= '0' && v.charAt(2) <= '9') {
                                                        isRedundant = true;
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] Removing assignment: $varName = $v (non-existent underscore temp var)');
                                                        #end
                                                    }
                                                    // Also check for "g = result" pattern where result is case target
                                                    // This is ALWAYS wrong and should be removed - the pattern already extracted g
                                                    else if (v == caseTargetVar) {
                                                        // Remove assignments like "g = result" where g is a temp var
                                                        // The pattern {:error, g} already binds g to the error value
                                                        // So "g = result" would incorrectly assign the whole tuple
                                                        if (varName == "g" || varName == "_g" ||
                                                            (varName.length == 2 && varName.charAt(0) == "g" &&
                                                             varName.charAt(1) >= '0' && varName.charAt(1) <= '9') ||
                                                            (varName.length == 3 && varName.charAt(0) == "_" &&
                                                             varName.charAt(1) == "g" && varName.charAt(2) >= '0' &&
                                                             varName.charAt(2) <= '9')) {
                                                            isRedundant = true;
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction] Removing incorrect assignment: $varName = $v (pattern already extracted value)');
                                                            #end
                                                        }
                                                    }

                                                case ECall(targetExpr, funcName, args) if (funcName == "elem" && args.length == 1):
                                                    #if debug_redundant_extraction
                                                    trace('[RemoveRedundantEnumExtraction]   - Found elem() call');
                                                    #end
                                                    // Check if elem is extracting from the case target
                                                    var isTargetMatch = switch(targetExpr.def) {
                                                        case EVar(v):
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction]   - elem() target: $v, case target: $caseTargetVar');
                                                            #end
                                                            // Check if this matches the case target variable
                                                            v == caseTargetVar;
                                                        default:
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction]   - elem() target is not a simple variable');
                                                            #end
                                                            false;
                                                    };

                                                    if (isTargetMatch) {
                                                        // Check if this variable was already extracted by the pattern
                                                        // Pattern variables like 'g', 'g1', 'g2' are extracted
                                                        if (varName == "g" ||
                                                            (varName.length > 1 && varName.charAt(0) == "g" &&
                                                             varName.charAt(1) >= '0' && varName.charAt(1) <= '9')) {
                                                            isRedundant = true;
                                                            #if debug_redundant_extraction
                                                            #end
                                                        } else {
                                                            #if debug_redundant_extraction
                                                            trace('[RemoveRedundantEnumExtraction] Not redundant - varName: $varName does not match g pattern');
                                                            #end
                                                        }
                                                    } else {
                                                        #if debug_redundant_extraction
                                                        trace('[RemoveRedundantEnumExtraction] elem() not extracting from case target');
                                                        #end
                                                    }
                                                default:
                                            }
                                        default:
                                    }

                                    if (!isRedundant) {
                                        filtered.push(expr);
                                    }
                                }

                                // Return filtered block or single expression if only one left
                                // CRITICAL FIX: Must actually evaluate to a value, not just execute expressions
                                // ALSO: Ensure immutability by creating new AST nodes
                                if (filtered.length == 0) {
                                    makeAST(ENil);
                                } else if (filtered.length == 1) {
                                    // Recursively transform the single expression to ensure complete immutability
                                    transformNode(filtered[0], function(n) { return n; });
                                } else {
                                    // Recursively transform each filtered expression to ensure immutability
                                    var transformedFiltered = filtered.map(function(expr) {
                                        return transformNode(expr, function(n) { return n; });
                                    });
                                    // Preserve metadata when creating new block
                                    makeASTWithMeta(EBlock(transformedFiltered), body.metadata, body.pos);
                                };

                            default:
                                body; // Not a block, keep as-is
                        };

                        // Create new clause with updated body
                        // IMPORTANT: Recursively transform the new body to ensure all nested structures are processed
                        var fullyTransformedBody = transformNode(newBody, function(n) { return n; });
                        newClauses.push({
                            pattern: pattern,
                            guard: guard,
                            body: fullyTransformedBody
                        });
                    }

                    // Create new ECase node preserving original metadata and position
                    return makeASTWithMeta(ECase(target, newClauses), node.metadata, node.pos);

                default:
                    return node;
            }
        });
    }

    /**
     * Function Reference Transform Pass
     *
     * WHY: When passing functions as references in Elixir, they need the capture operator
     * WHAT: Transforms Module.function__FUNC_REF__N to &Module.function/N
     * HOW: Looks for EField nodes with __FUNC_REF__ marker and converts to capture syntax
     */
    static function functionReferenceTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EField(target, field):
                    // Check if this has the function reference marker
                    if (field.indexOf("__FUNC_REF__") != -1) {
                        #if debug_function_reference
                        trace('[FunctionRef] Found marked field: $field');
                        #end
                        
                        // Extract the actual field name and arity
                        var parts = field.split("__FUNC_REF__");
                        var actualField = parts[0];
                        var arity = parts.length > 1 ? Std.parseInt(parts[1]) : 0;
                        if (arity == null) arity = 0;
                        
                        #if debug_function_reference
                        trace('[FunctionRef] Transforming to capture: &Module.$actualField/$arity');
                        #end
                        
                        // Create the clean field access without the marker
                        var cleanField = makeAST(EField(target, actualField));
                        
                        // Transform to capture syntax: &Module.function/arity
                        return makeAST(ECapture(cleanField, arity));
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Null Coalescing Inline Pass
     * 
     * Transforms null coalescing blocks into inline if expressions.
     * Detects pattern: var x = {tmp = expr; if (tmp != nil) tmp else default}
     * Transforms to: var x = if (tmp = expr) != nil, do: tmp, else: default
     */
    static function nullCoalescingInlinePass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_null_coalescing
            switch(node.def) {
                case EMatch(PVar(name), value):
                    trace('[NullCoalescing] Found EMatch with name: $name');
                    if (value != null) {
                        switch(value.def) {
                            case EBlock(exprs):
                                trace('[NullCoalescing] Found block with ${exprs.length} expressions');
                            default:
                                trace('[NullCoalescing] Value is not a block: ${value.def}');
                        }
                    }
                default:
            }
            #end
            
            return switch(node.def) {
                case EMatch(PVar(name), value) if (value != null):
                    // Check if value is a block with null coalescing pattern
                    switch(value.def) {
                        case EBlock([assign, ifExpr]) if (assign != null && ifExpr != null):
                            // Check if this matches the null coalescing pattern
                            switch(assign.def) {
                                case EMatch(PVar(tmpName), expr) if (tmpName != null && tmpName.indexOf("tmp") >= 0):
                                    // Check if the if expression uses the same tmp variable
                                    switch(ifExpr.def) {
                                        case EIf(condition, thenBranch, elseBranch):
                                            // Check if condition is comparing tmp to nil
                                            switch(condition.def) {
                                                case EBinary(NotEqual, tmpVar, nilExpr):
                                                    switch(tmpVar.def) {
                                                        case EVar(checkName) if (checkName == tmpName):
                                                            // This is the null coalescing pattern!
                                                            // Transform to inline if with assignment in condition
                                                            // Create: name = if (tmp = expr) != nil, do: tmp, else: default
                                                            var assignExpr = makeAST(EMatch(PVar(tmpName), expr));
                                                            var inlineCondition = makeAST(EBinary(
                                                                NotEqual,
                                                                makeAST(EParen(assignExpr)),
                                                                makeAST(ENil)
                                                            ));
                                                            makeAST(EMatch(PVar(name), makeAST(EIf(inlineCondition, thenBranch, elseBranch))));
                                                        default:
                                                            node; // Not using the same tmp variable
                                                    }
                                                default:
                                                    node; // Not a nil comparison
                                            }
                                        default:
                                            node; // Not an if expression
                                    }
                                default:
                                    node; // Not a temp variable assignment
                            }
                        default:
                            node; // Not a null coalescing block
                    }
                default:
                    node; // Not a variable declaration or no transformation needed
            };
        });
    }
    
    /**
     * Self reference transformation pass - converts self/this references to struct parameter
     * In Elixir, instance methods receive the struct as their first parameter
     * 
     * For inheritance: Haxe's super.method() becomes delegation to parent module
     * Example: super.toString() -> ParentModule.to_string(struct)
     */
    static function selfReferenceTransformPass(ast: ElixirAST): ElixirAST {
        // First pass: collect module metadata for context
        var moduleMetadata: ElixirMetadata = null;
        
        function collectModuleMetadata(node: ElixirAST): Void {
            if (node == null || node.def == null) return;
            
            switch(node.def) {
                case EModule(_, _, _):
                    if (node.metadata != null) {
                        moduleMetadata = node.metadata;
                        #if debug_super_handling
                        trace("[SuperTransform] Collected module metadata: parentModule=" + 
                              (moduleMetadata.parentModule != null ? moduleMetadata.parentModule : "null"));
                        #end
                    }
                default:
                    // Continue traversing
                    iterateAST(node, collectModuleMetadata);
            }
        }
        
        collectModuleMetadata(ast);
        
        // Second pass: transform with context
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Transform method calls on super
                // Note: In ElixirASTBuilder, super.toString() becomes:
                // ECall(target=null, methodName="call", args=[EField(EVar("super"), "to_string"), ...])
                // But we need to check for the direct case too:
                // ECall(target=EField(EVar("super"), "to_string"), methodName="call", args)
                case ECall(target, methodName, args):
                    #if debug_super_handling
                    trace("[SuperTransform] Processing ECall:");
                    trace("  target = " + target);
                    trace("  methodName = " + methodName);
                    trace("  args = " + args);
                    #end
                    // Handle synthetic super calls marker, if any
                    if (methodName == "__super__") {
                        return makeAST(ENil);
                    }
                    
                    // First check if this is a call where the first arg is super.field access
                    if (methodName == "call" && args.length > 0) {
                        switch(args[0].def) {
                            case EField(superVar, fieldName):
                                if (superVar.def.match(EVar("super"))) {
                                    #if debug_super_handling
                                    trace("[SuperTransform] Found super." + fieldName + " as first argument");
                                    #end
                                    if (fieldName == "to_string" || fieldName == "toString") {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Transforming super.toString() call to empty string");
                                        #end
                                        return makeAST(EString(""));
                                    }
                                }
                            default:
                        }
                    }
                    
                    // Also check if target itself is super.field or just super
                    if (target != null) {
                        switch(target.def) {
                            case EVar("super"):
                                // Direct super.method() call where super is the target
                                #if debug_super_handling
                                trace("[SuperTransform] Direct super as target detected!");
                                trace("  methodName = " + methodName);
                                trace("  node.metadata = " + node.metadata);
                                #end
                                
                                // Look for parent module in metadata
                                var parentModule = if (node.metadata != null && node.metadata.parentModule != null) {
                                    node.metadata.parentModule;
                                } else if (moduleMetadata != null && moduleMetadata.parentModule != null) {
                                    // Use collected module metadata
                                    moduleMetadata.parentModule;
                                } else {
                                    // No parent module available
                                    null;
                                };
                                
                                if (parentModule != null) {
                                    // Special handling for Exception parent (it's a behaviour, not a module with methods)
                                    if (parentModule == "Exception" && (methodName == "toString" || methodName == "to_string")) {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Special handling for Exception.toString()");
                                        #end
                                        // For Exception base class, use Kernel.to_string on the message
                                        return makeAST(ERemoteCall(
                                            makeAST(EVar("Kernel")),
                                            "to_string",
                                            [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                        ));
                                    }
                                    
                                    // Transform super.method() to ParentModule.method(struct, args...)
                                    #if debug_super_handling
                                    trace("[SuperTransform] Delegating to parent module: " + parentModule);
                                    trace("[SuperTransform] Parent module type: " + Type.typeof(parentModule));
                                    #end
                                    
                                    // Convert method name to snake_case for Elixir
                                    var elixirMethodName = if (methodName == "toString") {
                                        "to_string";
                                    } else {
                                        NameUtils.toSnakeCase(methodName);
                                    };
                                    
                                    // Build delegation call: ParentModule.method(struct, original_args...)
                                    var delegationArgs = [makeAST(EVar("struct"))].concat(args);
                                    return makeAST(ERemoteCall(
                                        makeAST(EVar(parentModule)),  // Use EVar for module alias, not EAtom
                                        elixirMethodName,
                                        delegationArgs
                                    ));
                                } else if (methodName == "to_string" || methodName == "toString") {
                                    // Fallback for toString when parent is unknown
                                    #if debug_super_handling
                                    trace("[SuperTransform] No parent module found, handling toString for exception");
                                    #end
                                    
                                    // Check if this is an exception class
                                    var isException = (moduleMetadata != null && moduleMetadata.isException == true);
                                    
                                    if (isException) {
                                        // For exception classes, use Kernel.to_string on the message field
                                        // This properly converts the message to a string using Elixir's built-in function
                                        return makeAST(ERemoteCall(
                                            makeAST(EVar("Kernel")),
                                            "to_string",
                                            [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                        ));
                                    } else {
                                        // For non-exception classes, just return the message field
                                        return makeAST(EField(makeAST(EVar("struct")), "message"));
                                    }
                                } else {
                                    // Keep as is if we can't resolve parent
                                    #if debug_super_handling
                                    trace("[SuperTransform] No parent module found, keeping super call as is");
                                    #end
                                    node;
                                }
                                
                            case EField(superVar, fieldName):
                                #if debug_super_handling
                                trace("[SuperTransform] EField target detected:");
                                trace("  superVar.def = " + superVar.def);
                                trace("  fieldName = " + fieldName);
                                #end
                                
                                if (superVar.def.match(EVar("super"))) {
                                    #if debug_super_handling
                                    trace("[SuperTransform] Super method call detected!");
                                    #end
                                    
                                    // This is super.method() call
                                    if (fieldName == "to_string" || fieldName == "toString") {
                                        #if debug_super_handling
                                        trace("[SuperTransform] Transforming super.toString() for exception class");
                                        #end
                                        
                                        // Check if this is an exception class
                                        var isException = (moduleMetadata != null && moduleMetadata.isException == true);
                                        
                                        if (isException) {
                                            // For exception classes, use Kernel.to_string on the message field
                                            return makeAST(ERemoteCall(
                                                makeAST(EVar("Kernel")),
                                                "to_string",
                                                [makeAST(EField(makeAST(EVar("struct")), "message"))]
                                            ));
                                        } else {
                                            // Default to empty string for non-exception classes
                                            return makeAST(EString(""));
                                        }
                                    } else {
                                        // For other methods, keep as is for now
                                        node;
                                    }
                                } else {
                                    node;
                                }
                            default:
                                #if debug_super_handling
                                trace("[SuperTransform] Target is not super or field access, keeping node");
                                #end
                                node;
                        }
                    } else {
                        node;
                    }
                    
                // Transform self.field and super.field  
                case EField(target, fieldName):
                    switch(target.def) {
                        case EVar("self"):
                            // Replace 'self' with 'struct' (the conventional first parameter)
                            makeAST(EField(makeAST(EVar("struct")), fieldName));
                        case EVar("super"):
                            // Don't transform super field access here anymore - handle in ECall
                            node;
                        default:
                            node;
                    }
                    
                // Transform standalone 'self' references
                case EVar("self"):
                    makeAST(EVar("struct"));
                    
                // Transform standalone 'super' references
                // NOTE: Don't transform super to nil - this causes issues with super.method() calls
                // Super method delegation should be handled at the TCall level when super is the target
                // case EVar("super"):
                //     makeAST(ENil);
                    
                // fallthrough
                default:
                    node;
            }
        });
    }
    
    /**
     * Phoenix Component Import Pass: Add Phoenix.Component import when ~H sigil is used
     * 
     * WHY: The ~H sigil for HEEx templates requires Phoenix.Component to be imported
     * WHAT: Detects any ESigil with type "H" and adds the necessary import
     * HOW: Traverses AST looking for ~H sigils, then adds import if found
     * 
     * IMPORTANT: Skip if module already has LiveView use statement (includes Phoenix.Component)
     */
    static function phoenixComponentImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if ~H sigil is used
        var needsPhoenixComponent = false;
        
        #if debug_phoenix_component_import
        trace('[XRay PhoenixComponentImport] Starting scan for ~H sigils');
        #end
        
        // Recursive function to deeply traverse the AST
        function checkForHSigil(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            switch(node.def) {
                case ESigil(type, _, _):
                    #if debug_phoenix_component_import
                    trace('[XRay PhoenixComponentImport] Found sigil type: $type');
                    #end
                    if (type == "H") {
                        needsPhoenixComponent = true;
                    }
                case ERaw(code):
                    // Also catch ~H usage present inside raw code blocks (e.g., untyped __elixir__ "~H\"\"\"...\"\"\"")
                    if (code != null && (code.indexOf("~H\"\"\"") != -1 || code.indexOf("~H\"") != -1)) {
                        needsPhoenixComponent = true;
                    } else {
                        // Continue traversal for any nested nodes in raw if needed
                        iterateAST(node, checkForHSigil);
                    }
                default:
                    // For all other node types, recursively visit children
                    iterateAST(node, checkForHSigil);
            }
        }
        
        checkForHSigil(ast);
        
        #if debug_phoenix_component_import
        trace('[XRay PhoenixComponentImport] Needs Phoenix.Component: $needsPhoenixComponent');
        #end
        
        // Phase 2: Add import if needed
        if (!needsPhoenixComponent) return ast;
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EModule(name, attributes, body):
                    // Handle module nodes constructed via EModule (ModuleBuilder default)
                    // Inject `use Phoenix.Component` at the top of the body when ~H is present
                    var hasImport = false;
                    // Scan existing body for EUse/EImport Phoenix.Component
                    for (stmt in body) switch (stmt.def) {
                        case EUse(mod, _): if (mod == "Phoenix.Component") { hasImport = true; }
                        case EImport(mod, _, _): if (mod == "Phoenix.Component") { hasImport = true; }
                        default:
                    }
                    if (!hasImport) {
                        var importStmt = makeAST(EUse("Phoenix.Component", []));
                        var newBody = [importStmt].concat(body);
                        return makeASTWithMeta(EModule(name, attributes, newBody), node.metadata, node.pos);
                    }
                    return node;
                case EDefmodule(name, doBlock):
                    #if debug_phoenix_component_import
                    trace('[XRay PhoenixComponentImport] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            #if debug_phoenix_component_import
                            trace('[XRay PhoenixComponentImport] Defmodule has ${statements.length} statements');
                            #end
                            
                            // Check if Phoenix.Component is already imported or if LiveView is used
                            var hasImport = false;
                            var hasLiveViewUse = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):
                                        // module is a string in EImport
                                        if (module == "Phoenix.Component") {
                                            hasImport = true;
                                            break;
                                        }
                                    case EUse(module, opts):
                                        // module is a string in EUse
                                        #if debug_phoenix_component_import
                                        trace('[XRay PhoenixComponentImport] Found EUse: module=$module, opts=$opts');
                                        #end
                                        if (module == "Phoenix.Component") {
                                            hasImport = true;
                                            break;
                                        }
                                        // Check if it's a LiveView use statement (e.g., use TodoAppWeb, :live_view)
                                        if (module.indexOf("Web") != -1 && opts != null && opts.length > 0) {
                                            // Check if it has :live_view option
                                            for (opt in opts) {
                                                #if debug_phoenix_component_import
                                                trace('[XRay PhoenixComponentImport] Checking option: $opt');
                                                #end
                                                switch(opt.def) {
                                                    // Pattern matching with abstract types requires guard clause
                                                case EAtom(atom) if (atom == "live_view"):
                                                        #if debug_phoenix_component_import
                                                        trace('[XRay PhoenixComponentImport] Found :live_view option - will skip Phoenix.Component');
                                                        #end
                                                        hasLiveViewUse = true;
                                                        hasImport = true; // LiveView includes Phoenix.Component
                                                        break;
                                                    default:
                                                }
                                            }
                                        }
                                    default:
                                }
                            }
                            
                            /**
                             * LayoutContextHtmlUse Injection
                             *
                             * WHAT
                             * - For modules named `<App>Web.Layouts`, inject `use <App>Web, :html` instead of a raw
                             *   `use Phoenix.Component` so that the full Phoenix 1.7 HTML context is available.
                             *
                             * WHY
                             * - Layout modules commonly return ~H templates and rely on helpers (HTML, VerifiedRoutes,
                             *   controller conveniences). `:html` brings those into scope without app coupling.
                             *
                             * HOW
                             * - Detect EDefmodule with name ending in ".Layouts"; derive `<App>Web` from the prefix before
                             *   "Web" and prepend `use <App>Web, :html` when missing.
                             *
                             * EXAMPLES
                             *   Before:
                             *     defmodule TodoAppWeb.Layouts do
                             *       # (no imports)
                             *       def root(assigns), do: ~H"<head>...</head>"
                             *     end
                             *
                             *   After:
                             *     defmodule TodoAppWeb.Layouts do
                             *       use TodoAppWeb, :html
                             *       def root(assigns), do: ~H"<head>...</head>"
                             *     end
                             */
                            // If this is a Layouts module, ensure `use <App>Web, :html`
                            // so ~H helpers (Phoenix.Component, VerifiedRoutes, controller helpers) are in scope.
                            var isLayoutsModule = (name != null && StringTools.endsWith(name, ".Layouts"));

                            // Don't add Phoenix.Component or additional uses if LiveView is already used
                            if (hasLiveViewUse) {
                                #if debug_phoenix_component_import
                                trace('[XRay PhoenixComponentImport] Module already has LiveView use statement, skipping Phoenix.Component');
                                #end
                                return node;
                            }
                            
                            // For Layouts modules, prefer `use <App>Web, :html`
                            if (isLayoutsModule) {
                                // Derive <App> from "<App>Web.Layouts"
                                var appIdx = name.indexOf("Web");
                                var appPrefix = appIdx > 0 ? name.substr(0, appIdx) : null;
                                if (appPrefix != null) {
                                    var webModule = appPrefix + "Web";
                                    // Check if `use <App>Web, :html` already exists
                                    var hasHtmlUse = false;
                                    for (stmt in statements) switch (stmt.def) {
                                        case EUse(mod, opts):
                                            if (mod == webModule && opts != null) {
                                                for (o in opts) switch (o.def) { case EAtom(a) if (a == "html"): hasHtmlUse = true; default: }
                                            }
                                        default:
                                    }
                                    if (!hasHtmlUse) {
                                        #if debug_phoenix_component_import
                                        trace('[XRay PhoenixComponentImport] Adding use ' + webModule + ', :html for Layouts module');
                                        #end
                                        var htmlUse = makeAST(EUse(webModule, [ makeAST(EAtom("html")) ]));
                                        var newStatements = [htmlUse].concat(statements);
                                        var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                        return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                                    }
                                }
                            } else if (!hasImport) {
                                #if debug_phoenix_component_import
                                trace('[XRay PhoenixComponentImport] Adding Phoenix.Component import');
                                #end
                                // Create the import statement using EUse which takes a string
                                var importStmt = makeAST(EUse("Phoenix.Component", []));
                                // Add import at the beginning of the module body
                                var newStatements = [importStmt].concat(statements);
                                var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                            }
                            
                            return node; // Return unchanged if already has import
                            
                        default:
                            // Single expression body, wrap in block with import
                            var importStmt = makeAST(EUse("Phoenix.Component", []));
                            var newDoBlock = makeAST(EBlock([importStmt, doBlock]));
                            return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                    }
                    
                default:
                    return node;
            }
        });
    }

    /**
     * Ecto Query Require Pass
     *
     * WHAT
     * - Scans modules for calls to Ecto.Query.* (macros like from/where/order_by/preload)
     * - Injects `require Ecto.Query` at module top if missing
     *
     * WHY
     * - In Elixir, macros must be required in the caller module
     * - Our builder emits ERemoteCall(EVar("Ecto.Query"), ...), which needs `require Ecto.Query`
     *
     * HOW
     * - Traverse defmodule body; if any ERemoteCall with module EVar("Ecto.Query") found, set needsRequire
     * - Check existing statements for Kernel.require("Ecto.Query"); if missing, prepend it
     */
    static function ectoQueryRequirePass(node: ElixirAST): ElixirAST {
        // Support both EDefmodule (do/end body) and EModule (attribute + body array) shapes
        function scanForEctoCalls(x: ElixirAST, found: {needs:Bool, has:Bool}): Void {
            if (x == null || x.def == null) return;
            switch (x.def) {
                case ERemoteCall(mod, func, args):
                    switch (mod.def) {
                        case EVar(m) if (m == "Kernel" && func == "require" && args != null && args.length == 1):
                            switch (args[0].def) { case EVar(v) if (v == "Ecto.Query"): found.has = true; default: }
                        case EVar(m) if (m == "Ecto.Query"): found.needs = true;
                        default:
                    }
                    if (args != null) for (a in args) scanForEctoCalls(a, found);
                case ERaw(code):
                    // Detect remote macro usage in raw injections only when explicitly remote
                    if (code != null && code.indexOf("Ecto.Query.") != -1) found.needs = true;
                // Remote-only gating: do NOT infer from pin operator alone
                case ECall(target, _, args):
                    if (target != null) scanForEctoCalls(target, found);
                    if (args != null) for (a in args) scanForEctoCalls(a, found);
                case EBlock(es): for (e in es) scanForEctoCalls(e, found);
                case EIf(c,t,e): scanForEctoCalls(c, found); scanForEctoCalls(t, found); if (e != null) scanForEctoCalls(e, found);
                case ECase(e, cs): scanForEctoCalls(e, found); for (c in cs) { if (c.guard != null) scanForEctoCalls(c.guard, found); scanForEctoCalls(c.body, found); }
                case EBinary(_, l, r): scanForEctoCalls(l, found); scanForEctoCalls(r, found);
                case EFn(cs): for (cl in cs) scanForEctoCalls(cl.body, found);
                case EDef(_, _, _, body): scanForEctoCalls(body, found);
                case EDefp(_, _, _, body): scanForEctoCalls(body, found);
                default:
            }
        }
        
        return transformNode(node, function(n: ElixirAST): ElixirAST {
            switch (n.def) {
                case EDefmodule(name, doBlock):
                    switch (doBlock.def) {
                        case EBlock(statements) | EDo(statements):
                            var found = {needs:false, has:false};
                            for (s in statements) scanForEctoCalls(s, found);
                            if (found.needs && !found.has) {
                                #if debug_ecto_query_require
                                trace('[EctoQueryRequire] Injecting require into defmodule ' + name);
                                #end
                                var requireStmt = makeAST(ERequire("Ecto.Query", null));
                                var newStatements = [requireStmt].concat(statements);
                                var newDo: ElixirAST = switch (doBlock.def) {
                                    case EBlock(_): makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                    case EDo(_): makeASTWithMeta(EDo(newStatements), doBlock.metadata, doBlock.pos);
                                    default: doBlock;
                                };
                                return makeASTWithMeta(EDefmodule(name, newDo), n.metadata, n.pos);
                            }
                            #if debug_ecto_query_require
                            if (found.needs && found.has) trace('[EctoQueryRequire] Already has require in defmodule ' + name);
                            if (!found.needs) trace('[EctoQueryRequire] No Ecto.Query usage detected in defmodule ' + name);
                            #end
                            return n;
                        default:
                            return n;
                    }
                case EModule(name, attrs, body):
                    var found2 = {needs:false, has:false};
                    for (b in body) scanForEctoCalls(b, found2);
                    if (found2.needs && !found2.has) {
                        #if debug_ecto_query_require
                        trace('[EctoQueryRequire] Injecting require into module ' + name);
                        #end
                        var requireStmt2 = makeAST(ERequire("Ecto.Query", null));
                        var newBody = [requireStmt2].concat(body);
                        return makeASTWithMeta(EModule(name, attrs, newBody), n.metadata, n.pos);
                    }
                    #if debug_ecto_query_require
                    if (found2.needs && found2.has) trace('[EctoQueryRequire] Already has require in module ' + name);
                    if (!found2.needs) trace('[EctoQueryRequire] No Ecto.Query usage detected in module ' + name);
                    #end
                    return n;
                default:
                    return n;
            }
        });
    }

    /**
     * HeexContentInlinePass
     *
     * WHAT
     * - Replaces ~H"""<%= Phoenix.HTML.raw(content) %>""" in render(assigns) with ~H"""<html...>"""
     *   when `content` was assigned from a string literal earlier in the function.
     * - Removes the `content = "..."` intermediate assignment.
     *
     * WHY
     * - LiveView warns when templates access local variables; templates should use assigns
     *   or be self-contained. Inlining avoids variable access and keeps idiomatic ~H usage.
     *
     * HOW
     * - For EDef("render", [assigns], _, EBlock(stmts)) find:
     *   a) EMatch(PVar("content"), EString(html))
     *   b) ESigil("H", s) where s contains "Phoenix.HTML.raw(content)"
     *   Replace (b) with ESigil("H", html) and drop (a).
     */
    static function heexContentInlinePass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch (node.def) {
                case EDef(name, args, guards, body) if (name == "render"):
                    // Only handle block bodies
                    switch (body.def) {
                        case EBlock(stmts):
                            var contentHtml: Null<String> = null;
                            var contentAssignIdx: Int = -1;
                            // Find content = "..." (allow optional parentheses)
                            for (i in 0...stmts.length) {
                                switch (stmts[i].def) {
                                    case EMatch(PVar(varName), rhs) if (varName == "content"):
                                        switch (rhs.def) {
                                            case EString(s): contentHtml = s;
                                            case EParen(inner):
                                                switch (inner.def) {
                                                    case EString(s2): contentHtml = s2;
                                                    default:
                                                }
                                            default:
                                        }
                                        contentAssignIdx = i;
                                        break;
                                    default:
                                }
                            }
                            if (contentHtml == null) return node;
                            // Find ~H that references Phoenix.HTML.raw(content) (allow EParen wrapping)
                            var sigilIdx: Int = -1;
                            for (i in 0...stmts.length) {
                                switch (stmts[i].def) {
                                    case ESigil(type, content, modifiers) if (type == "H" && content.indexOf("Phoenix.HTML.raw(content)") != -1):
                                        sigilIdx = i;
                                        break;
                                    case EParen(inner):
                                        switch (inner.def) {
                                            case ESigil(type2, content2, modifiers2) if (type2 == "H" && content2.indexOf("Phoenix.HTML.raw(content)") != -1):
                                                sigilIdx = i;
                                                break;
                                            default:
                                        }
                                    default:
                                }
                            }
                            if (sigilIdx == -1) return node;
                            // Build new statements: replace sigil with literal html, drop the assignment
                            var newStmts = [];
                            for (i in 0...stmts.length) {
                                if (i == contentAssignIdx) continue; // drop assignment
                                if (i == sigilIdx) {
                                    // Preserve parentheses if original was parenthesized
                                    switch (stmts[i].def) {
                                        case EParen(_):
                                            newStmts.push(makeASTWithMeta(EParen(makeAST(ESigil("H", contentHtml, ""))), stmts[i].metadata, stmts[i].pos));
                                        default:
                                            newStmts.push(makeASTWithMeta(ESigil("H", contentHtml, ""), stmts[i].metadata, stmts[i].pos));
                                    }
                                } else {
                                    newStmts.push(stmts[i]);
                                }
                            }
                            return makeASTWithMeta(EDef(name, args, guards, makeAST(EBlock(newStmts))), node.metadata, node.pos);
                        default:
                            return node;
                    }
                default:
                    return node;
            }
        });
    }

    /**
     * NumericNoOpCleanupPass
     *
     * WHAT
     * - Removes EBinary operations with numeric literals when used as statements.
     * - Converts bare increments like `if cond, do: count + 1` into `if cond, do: count = count + 1`.
     *
     * WHY
     * - Avoids Elixir warnings and preserves intended increment semantics when missed by earlier passes.
     */
    static function numericNoOpCleanupPass(ast: ElixirAST): ElixirAST {
        function isNumericLiteral(n: ElixirAST): Bool {
            return switch (n.def) {
                case EInteger(_) | EFloat(_): true;
                default: false;
            }
        }
        function rewriteIfIncrements(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case EBinary(Add, {def: EInteger(a)}, {def: EInteger(b)}):
                    // Fold constant addition to a single literal (eliminates operator warning)
                    makeAST(EInteger(a + b));
                case EIf(cond, thenB, elseB):
                    var newThen = switch (thenB.def) {
                        case EBinary(Add, {def: EVar(v)}, rhs):
                            makeAST(EMatch(PVar(v), makeAST(EBinary(Add, makeAST(EVar(v)), rewriteIfIncrements(rhs)))));
                        case EBinary(Add, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)):
                            makeAST(ENil);
                        default:
                            rewriteIfIncrements(thenB);
                    };
                    var newElse = if (elseB != null) switch (elseB.def) {
                        case EBinary(Add, {def: EVar(v2)}, rhs2):
                            makeAST(EMatch(PVar(v2), makeAST(EBinary(Add, makeAST(EVar(v2)), rewriteIfIncrements(rhs2)))));
                        case EBinary(Add, l2, r2) if (isNumericLiteral(l2) && isNumericLiteral(r2)):
                            makeAST(ENil);
                        default:
                            rewriteIfIncrements(elseB);
                    } else null;
                    makeASTWithMeta(EIf(rewriteIfIncrements(cond), newThen, newElse), n.metadata, n.pos);
                case EBlock(stmts):
                    var out: Array<ElixirAST> = [];
                    for (idx in 0...stmts.length) {
                        var s = stmts[idx];
                        // Drop standalone numeric operations like 0 + 1, but preserve a trailing
                        // bare numeric literal as it may represent an intentional return value
                        // (e.g., final 0 in compare/2).
                        var isLast = (idx == stmts.length - 1);
                        var drop = switch (s.def) {
                            case EBinary(_, l, r) if (isNumericLiteral(l) && isNumericLiteral(r)): true;
                            case EInteger(_) if (!isLast): true; // Only drop bare integer when not last
                            default: false;
                        };
                        if (!drop) out.push(rewriteIfIncrements(s));
                    }
                    makeASTWithMeta(EBlock(out), n.metadata, n.pos);
                default:
                    n;
            }
        }
        return rewriteIfIncrements(ast);
    }
    
    /**
     * Phoenix function name mapping pass
     * 
     * WHY: Some Haxe helper functions need to be mapped to proper Phoenix functions
     * WHAT: Transforms assign_multiple to assign, and other custom names to Phoenix conventions
     * HOW: Detects function calls and remaps their names
     */
    static function phoenixFunctionMappingPass(node: ElixirAST): ElixirAST {
        return transformNode(node, function(n: ElixirAST): ElixirAST {
            switch(n.def) {
                // Transform assign_multiple(socket, map) to assign(socket, map)
                case ECall(null, "assign_multiple", args):
                    #if debug_ast_transformer
                    trace('[PhoenixFunctionMapping] Transforming assign_multiple to assign');
                    #end
                    return makeASTWithMeta(ECall(null, "assign", args), n.metadata, n.pos);
                    
                default:
                    return n;
            }
        });
    }
    
    /**
     * LiveView CoreComponents Import Pass: Add app's CoreComponents import for LiveView modules
     * 
     * WHY: LiveView modules that use component functions need to import their app's CoreComponents
     * WHAT: Detects component usage (<.button, <.input, etc.) and adds CoreComponents import
     * HOW: Looks for ~H sigils with component calls and adds appropriate import
     * 
     * NOTE: This can conflict with Phoenix.HTML.Form functions. In Phoenix apps, the CoreComponents
     * version takes precedence for dot-notation components (<.label> uses CoreComponents.label/1)
     */
    static function liveViewCoreComponentsImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if component functions are used
        var needsCoreComponents = false;
        var moduleName = "";
        
        #if debug_liveview_components
        trace('[XRay LiveViewComponents] Starting scan for component usage');
        #end
        
        // First, find the module name to determine the app name
        function findModuleName(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            switch(node.def) {
                case EDefmodule(name, _):
                    moduleName = name;
                    return;
                default:
                    iterateAST(node, findModuleName);
            }
        }
        
        findModuleName(ast);
        
        // Check if this is a LiveView module (has "Live" in name)
        if (moduleName == "" || moduleName.indexOf("Live") == -1) {
            return ast; // Not a LiveView module
        }
        
        // Recursive function to check for component usage in ~H sigils
        function checkForComponents(node: ElixirAST): Void {
            switch(node.def) {
                case ESigil(type, content, _):
                    if (type == "H") {
                        // Check if content contains component calls like <.button, <.input, etc.
                        if (content.indexOf("<.") != -1) {
                            #if debug_liveview_components
                            trace('[XRay LiveViewComponents] Found component usage in ~H sigil');
                            #end
                            needsCoreComponents = true;
                        }
                    }
                default:
                    iterateAST(node, checkForComponents);
            }
        }
        
        checkForComponents(ast);
        
        #if debug_liveview_components
        trace('[XRay LiveViewComponents] Needs CoreComponents: $needsCoreComponents');
        #end
        
        // Phase 2: Add import if needed
        if (!needsCoreComponents) return ast;
        
        // Extract app name from module name (e.g., TodoAppWeb.UserLive -> TodoAppWeb)
        var appWebName = "";
        if (moduleName.indexOf(".") != -1) {
            var parts = moduleName.split(".");
            if (parts.length > 0) {
                appWebName = parts[0]; // Get the first part (e.g., TodoAppWeb)
            }
        }
        
        if (appWebName == "") return ast; // Can't determine app name
        
        var coreComponentsModule = appWebName + ".CoreComponents";
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDefmodule(name, doBlock):
                    #if debug_liveview_components
                    trace('[XRay LiveViewComponents] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            // Check if CoreComponents is already imported
                            var hasImport = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):
                                        if (module == coreComponentsModule) {
                                            hasImport = true;
                                            break;
                                        }
                                    default:
                                }
                            }
                            
                            if (!hasImport) {
                                #if debug_liveview_components
                                trace('[XRay LiveViewComponents] Adding CoreComponents import: $coreComponentsModule');
                                #end
                                
                                // Create the import statement with specific functions to avoid conflicts
                                // Import CoreComponents but exclude label to avoid conflict with Phoenix.HTML.Form.label/1
                                // The dot-notation <.label> will still work via Phoenix.Component's component system
                                var exceptOptions: Array<EImportOption> = [{name: "label", arity: 1}];
                                var importStmt = makeAST(EImport(coreComponentsModule, null, exceptOptions));
                                
                                // Add import after use statements but before function definitions
                                var newStatements = [];
                                var importAdded = false;
                                
                                for (stmt in statements) {
                                    newStatements.push(stmt);
                                    // Add import after use statements
                                    if (!importAdded) {
                                        switch(stmt.def) {
                                            case EUse(_, _):
                                                newStatements.push(importStmt);
                                                importAdded = true;
                                            default:
                                        }
                                    }
                                }
                                
                                // If no use statements, add at the beginning
                                if (!importAdded) {
                                    newStatements = [importStmt].concat(statements);
                                }
                                
                                var newDoBlock = makeASTWithMeta(EBlock(newStatements), doBlock.metadata, doBlock.pos);
                                return makeASTWithMeta(EDefmodule(name, newDoBlock), node.metadata, node.pos);
                            }
                            
                            return node;
                            
                        default:
                            // Single expression body, unlikely for LiveView
                            return node;
                    }
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * String method transformation pass
     * 
     * WHY: Strings in Elixir don't have methods - they use the String module
     * WHAT: Transforms method calls on strings to String module calls
     * HOW: Detects ECall with string targets and converts to ERemoteCall
     * 
     * Examples:
     * - hex_chars.charAt(0) ‚Üí String.at(hex_chars, 0)
     * - str.toLowerCase() ‚Üí String.downcase(str)
     * - str.toUpperCase() ‚Üí String.upcase(str)
     */
    /**
     * Instance method transformation pass
     * Transforms instance method calls to module function calls for standard library types
     * Example: buffer.add(str) ‚Üí StringBuf.add(buffer, str)
     */
    static function instanceMethodTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_instance_methods
            switch(node.def) {
                case ECall(target, methodName, args):
                    trace('[InstanceMethodTransform] DEBUG - ECall detected:');
                    trace('  methodName: ${methodName}');
                    if (target != null) {
                        trace('  target.def: ${target.def}');
                    }
                    trace('  args.length: ${args.length}');
                default:
            }
            #end
            
            return switch(node.def) {
                // Handle instance method calls like instance.method(args)
                case ECall({def: EField(target, field), metadata: fieldMeta, pos: fieldPos}, methodName, args):
                    // This handles chained field access: struct.buffer.add()
                    // The field access (struct.buffer) becomes the target
                    // Transform to: StringBuf.add(struct.buffer, args)
                    
                    // Detect StringBuf methods
                    if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
                        #if debug_instance_methods
                        trace('[InstanceMethodTransform] Detected potential StringBuf method: ${methodName}');
                        #end
                        
                        // For now, assume it's a StringBuf if it has these methods
                        // A more sophisticated approach would track types through metadata
                        var moduleName = switch(methodName) {
                            case "add": "StringBuf";
                            case "toString" | "to_string": "StringBuf";
                            default: null;
                        };
                        
                        if (moduleName != null) {
                            // Transform instance.method(args) to Module.method(instance, args)
                            var moduleRef = makeAST(EVar(moduleName));
                            var targetField = makeASTWithMeta(EField(target, field), fieldMeta, fieldPos);
                            var newArgs = [targetField].concat(args);
                            var functionName = switch(methodName) {
                                case "toString" | "to_string": "to_string";
                                default: methodName;
                            };
                            
                            return makeASTWithMeta(
                                ERemoteCall(moduleRef, functionName, newArgs),
                                node.metadata,
                                node.pos
                            );
                        }
                    }
                    
                    // Check for other known instance types
                    // Could extend this to Map, List, etc.
                    node;
                    
                case ECall(target, methodName, args) if (target != null):
                    // Handle direct method calls (without field access chain)
                    // Check if this is a method that should be transformed
                    switch(target.def) {
                        case EVar(varName):
                            // Direct variable method call: buffer.add() or struct.write_value()
                            if (methodName == "add" || methodName == "toString" || methodName == "to_string") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Direct method call on var: ${varName}.${methodName}');
                                #end
                                
                                // Transform to module function call
                                var moduleName = "StringBuf"; // Assume StringBuf for these methods
                                var moduleRef = makeAST(EVar(moduleName));
                                var functionName = switch(methodName) {
                                    case "toString" | "to_string": "to_string";
                                    default: methodName;
                                };
                                
                                return makeASTWithMeta(
                                    ERemoteCall(moduleRef, functionName, [target].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            } else if (methodName == "write_value" || methodName == "writeValue") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Struct method call on var: ${varName}.${methodName}');
                                #end
                                
                                // Transform struct.write_value(args) to write_value(struct, args)  
                                var functionName = switch(methodName) {
                                    case "writeValue": "write_value";
                                    default: methodName;
                                };
                                
                                // Transform to local function call with struct as first argument
                                return makeASTWithMeta(
                                    ECall(null, functionName, [target].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        case EField(obj, field):
                            // Method call on field access: struct.write_value()
                            // These should become local function calls: write_value(struct, ...)
                            if (methodName == "write_value" || methodName == "writeValue") {
                                #if debug_instance_methods
                                trace('[InstanceMethodTransform] Struct method call: ${field}.${methodName}');
                                #end
                                
                                // Transform struct.method(args) to method(struct, args)
                                var functionName = switch(methodName) {
                                    case "writeValue": "write_value";
                                    default: methodName;
                                };
                                
                                // Create the target (struct.field)
                                var targetExpr = makeAST(EField(obj, field));
                                
                                // Transform to local function call with struct as first argument
                                return makeASTWithMeta(
                                    ECall(null, functionName, [targetExpr].concat(args)),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        default:
                    }
                    node;
                    
                default:
                    node;
            };
        });
    }
    
    static function stringMethodTransformPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Handle method calls that look like string.method(args)
                case ECall(target, methodName, args) if (target != null):
                    // Check if this looks like a string method call
                    // Handle both camelCase and snake_case versions
                    var stringMethod = switch(methodName) {
                        case "charAt" | "char_at": "at";
                        case "charCodeAt" | "char_code_at": "to_charlist"; 
                        case "toLowerCase" | "to_lower_case": "downcase";
                        case "toUpperCase" | "to_upper_case": "upcase";
                        case "indexOf" | "index_of": "index";
                        case "substring" | "substr": "slice";
                        case "split": "split";
                        case "trim": "trim";
                        case "length": "length";  // Handle array/string length
                        case "toString" | "to_string": "to_string";  // Handle toString method calls
                        case "lastIndexOf" | "last_index_of": null;  // Special handling needed
                        case _: null;
                    };
                    
                    if (stringMethod != null) {
                        // Transform to String module call
                        #if debug_string_methods
                        trace('[StringMethodTransform] Converting ${methodName} to String.${stringMethod}');
                        if (target != null) {
                            trace('[StringMethodTransform] Target exists');
                        }
                        trace('[StringMethodTransform] Args count: ${args.length}');
                        #end
                        
                        // Special handling for different methods
                        if (methodName == "charCodeAt" || methodName == "char_code_at") {
                            // s.charCodeAt(pos) -> :binary.at(s, pos)
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EAtom(ElixirAtom.raw("binary"))),
                                    "at",
                                    [target].concat(args)
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else if (methodName == "toString" || methodName == "to_string") {
                            // Handle toString specially based on target type
                            // For integers and other primitives, use proper conversion
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("Integer")),
                                    "to_string",
                                    [target].concat(args)
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else if (methodName == "length") {
                            // s.length -> String.length(s)
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("String")),
                                    "length",
                                    [target]
                                ),
                                node.metadata,
                                node.pos
                            );
                        } else {
                            // Prepend the target as the first argument
                            var newArgs = [target].concat(args);
                            makeASTWithMeta(
                                ERemoteCall(
                                    makeAST(EVar("String")),
                                    stringMethod,
                                    newArgs
                                ),
                                node.metadata,
                                node.pos
                            );
                        }
                    } else if (methodName == "lastIndexOf" || methodName == "last_index_of") {
                        // Special handling for lastIndexOf - no direct Elixir equivalent
                        // We can't easily transform this, so leave it as is for now
                        node;
                    } else {
                        node;
                    }
                    
                default:
                    node;
            };
        });
    }
    
    /**
     * Constant folding pass - evaluate constant expressions at compile time
     */
    static function constantFoldingPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Fold binary operations on constants
                case EBinary(op, left, right):
                    switch([left.def, right.def]) {
                        case [EInteger(l), EInteger(r)]:
                            var result = switch(op) {
                                case Add: l + r;
                                case Subtract: l - r;
                                case Multiply: l * r;
                                case Divide: Math.floor(l / r);
                                case Remainder: l % r;
                                case Less: l < r ? 1 : 0;
                                case Greater: l > r ? 1 : 0;
                                case LessEqual: l <= r ? 1 : 0;
                                case GreaterEqual: l >= r ? 1 : 0;
                                case Equal: l == r ? 1 : 0;
                                case NotEqual: l != r ? 1 : 0;
                                default: null;
                            };
                            
                            if (result != null) {
                                // For boolean results, convert to EBoolean
                                if (op == Less || op == Greater || op == LessEqual || 
                                    op == GreaterEqual || op == Equal || op == NotEqual) {
                                    makeASTWithMeta(EBoolean(result == 1), node.metadata, node.pos);
                                } else {
                                    makeASTWithMeta(EInteger(result), node.metadata, node.pos);
                                }
                            } else {
                                node; // Can't fold, return unchanged
                            }
                            
                        case [EString(l), EString(r)] if (op == StringConcat):
                            makeASTWithMeta(EString(l + r), node.metadata, node.pos);
                            
                        case [EList(l), EList(r)] if (op == Concat):
                            makeASTWithMeta(EList(l.concat(r)), node.metadata, node.pos);
                            
                        default:
                            node; // Not constant, return unchanged
                    }
                    
                // Fold unary operations on constants
                case EUnary(op, expr):
                    switch(expr.def) {
                        case EInteger(i) if (op == Negate):
                            makeASTWithMeta(EInteger(-i), node.metadata, node.pos);
                        case EBoolean(b) if (op == Not):
                            makeASTWithMeta(EBoolean(!b), node.metadata, node.pos);
                        default:
                            node;
                    }
                    
                default:
                    node; // Not a foldable expression
            }
        });
    }
    
    /**
     * String interpolation pass - convert string concatenation to idiomatic interpolation
     * 
     * WHY: Elixir's string interpolation #{} is more idiomatic and readable than concatenation
     * WHAT: Transforms EBinary(StringConcat, ...) chains into interpolated strings
     * HOW: Finds string concatenation chains and replaces them with interpolated strings
     * 
     * NOTE: We use a custom traversal instead of transformNode to avoid recursive transformation
     */
    static function stringInterpolationPass(ast: ElixirAST): ElixirAST {
        function transform(node: ElixirAST): ElixirAST {
            // Handle null nodes
            if (node == null) return null;
            
            // First check if this is a string concatenation chain at the top level
            switch(node.def) {
                case EBinary(StringConcat, l, r):
                    #if debug_string_interpolation
                    var fullNodeStr = ElixirASTPrinter.printAST(node);
                    trace('[StringInterpolation] Found concatenation pattern: ${fullNodeStr.substring(0, 200)}');
                    trace('[StringInterpolation] Left type: ${Type.enumConstructor(l.def)}');
                    trace('[StringInterpolation] Right type: ${Type.enumConstructor(r.def)}');
                    #end
                    // Collect all parts of the concatenation chain
                    var parts = [];
                    
                    function collectParts(expr: ElixirAST) {
                        switch(expr.def) {
                            case EBinary(StringConcat, l, r):
                                collectParts(l);
                                collectParts(r);
                            case EString(s):
                                parts.push({isString: true, value: s, expr: null});
                            default:
                                parts.push({isString: false, value: null, expr: expr});
                        }
                    }
                    
                    collectParts(node);
                    
                    // Check if we should convert to interpolation
                    var hasNonString = false;
                    var hasEmptyString = false;
                    for (part in parts) {
                        if (!part.isString) {
                            hasNonString = true;
                        } else if (part.value == "") {
                            hasEmptyString = true;
                        }
                    }
                    
                    // Only convert if we have non-string parts and multiple parts
                    if (hasNonString && parts.length > 1) {
                        // Build interpolated string
                        var result = '"';
                        
                        for (i in 0...parts.length) {
                            var part = parts[i];
                            if (part.isString) {
                                // Add literal string part (escape special characters)
                                var escaped = part.value;
                                escaped = escaped.split('\\').join('\\\\');
                                escaped = escaped.split('"').join('\\"');
                                escaped = escaped.split('#{').join('\\#{');  // Escape interpolation syntax
                                result += escaped;
                            } else {
                                // Add interpolated expression
                                // First recursively transform the expression
                                var transformedExpr = transform(part.expr);
                                
                                // Strip unnecessary .to_string() calls since Elixir auto-converts in interpolation
                                var exprToInterpolate = switch(transformedExpr.def) {
                                    case ECall(target, "to_string", []) if (target != null):
                                        // Remove the .to_string() wrapper, use the target directly
                                        target;
                                    default:
                                        transformedExpr;
                                };
                                
                                // Simplify common shapes for idiomatic interpolation: inspect(Map.get(obj, :field)) -> obj.field
                                function simplifyInterpolationExpr(e: ElixirAST): ElixirAST {
                                    return switch (e.def) {
                                        case ECall(null, "inspect", [inner]):
                                            switch (inner.def) {
                                                case ERemoteCall({def: EVar("Map")}, "get", args) if (args != null && args.length == 2):
                                                    switch (args[1].def) {
                                                        case EAtom(field): makeASTWithMeta(EField(args[0], field), e.metadata, e.pos);
                                                        default: e;
                                                    }
                                                default: e;
                                            }
                                        default:
                                            e;
                                    }
                                }
                                exprToInterpolate = simplifyInterpolationExpr(exprToInterpolate);
                                
                                // Sanitize inline expression for interpolation: ensure no raw multi-statement
                                // blocks appear in function arguments (e.g., Enum.join(<block>, ",")).
                                function sanitizeForInterpolation(n: ElixirAST): ElixirAST {
                                    return transformNode(n, function(x: ElixirAST): ElixirAST {
                                        return switch (x.def) {
                                            case ECall(t, name, args):
                                                var newArgs = [];
                                                for (a in args) switch (a.def) {
                                                    case EBlock(sts) if (sts != null && sts.length > 1):
                                                        newArgs.push(makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: a }])), "", [])));
                                                    default:
                                                        newArgs.push(a);
                                                }
                                                if (newArgs != args) makeAST(ECall(t, name, newArgs)) else x;
                                            case ERemoteCall(mod, fname, rargs):
                                                var newRArgs = [];
                                                for (a2 in rargs) switch (a2.def) {
                                                    case EBlock(sts2) if (sts2 != null && sts2.length > 1):
                                                        newRArgs.push(makeAST(ECall(makeAST(EFn([{ args: [], guard: null, body: a2 }])), "", [])));
                                                    default:
                                                        newRArgs.push(a2);
                                                }
                                                if (newRArgs != rargs) makeAST(ERemoteCall(mod, fname, newRArgs)) else x;
                                            default:
                                                x;
                                        }
                                    });
                                }
                                // Avoid wrapping trivial expressions (vars, literals, simple field chains)
                                function isTrivialForInterpolation(x: ElixirAST, depth:Int = 0): Bool {
                                    if (x == null || depth > 4) return false;
                                    return switch (x.def) {
                                        case EVar(_): true;
                                        case EInteger(_)|EFloat(_)|EBoolean(_)|ENil|EString(_)|EAtom(_): true;
                                        case EField(obj, _): isTrivialForInterpolation(obj, depth + 1);
                                        default: false;
                                    }
                                }
                                var sanitizedExpr = sanitizeForInterpolation(exprToInterpolate);
                                var exprStr = ElixirASTPrinter.printAST(sanitizedExpr);
                                var trivial = isTrivialForInterpolation(sanitizedExpr);
                                // Only wrap when non-trivial and the printed expression clearly spans multiple
                                // statements or contains a standalone assignment (not a comparison).
                                var needsWrapIife = !trivial && ((exprStr.indexOf('\n') != -1) || (exprStr.indexOf(' = ') != -1 && exprStr.indexOf('==') == -1));
                                var printable = needsWrapIife ? '(fn -> ' + exprStr + ' end).()' : exprStr;
                                result += '#{' + printable + '}';
                            }
                        }
                        
                        result += '"';
                        
                        #if debug_string_interpolation
                        trace('[StringInterpolation] Transformed to: $result');
                        #end
                        
                        // Return raw interpolated string
                        return makeASTWithMeta(ERaw(result), node.metadata, node.pos);
                    }
                    
                default:
                    // Not a string concatenation at top level
            }
            
            // For all other nodes, recursively transform children
            return switch(node.def) {
                case EModule(name, attributes, body):
                    makeASTWithMeta(
                        EModule(name, attributes, body.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDefmodule(name, doBlock):
                    makeASTWithMeta(
                        EDefmodule(name, transform(doBlock)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDef(name, args, guards, body):
                    makeASTWithMeta(
                        EDef(name, args, guards, transform(body)),
                        node.metadata,
                        node.pos
                    );
                    
                case EDefp(name, args, guards, body):
                    makeASTWithMeta(
                        EDefp(name, args, guards, transform(body)),
                        node.metadata,
                        node.pos
                    );
                    
                case EBlock(expressions):
                    makeASTWithMeta(
                        EBlock(expressions.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                // For other binary operations that aren't StringConcat, transform children
                case EBinary(op, left, right) if (op != StringConcat):
                    makeASTWithMeta(
                        EBinary(op, transform(left), transform(right)),
                        node.metadata,
                        node.pos
                    );
                
                // Transform function calls (e.g., Log.trace with string concatenation arguments)
                case ECall(target, method, args):
                    makeASTWithMeta(
                        ECall(
                            target != null ? transform(target) : null,
                            method,
                            args.map(transform)
                        ),
                        node.metadata,
                        node.pos
                    );
                
                // Transform remote calls (module function calls)
                case ERemoteCall(module, func, args):
                    makeASTWithMeta(
                        ERemoteCall(
                            transform(module),
                            func,
                            args.map(transform)
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform match expressions (assignments)
                case EMatch(pattern, expr):
                    makeASTWithMeta(
                        EMatch(pattern, transform(expr)),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform if expressions
                case EIf(condition, then_expr, else_expr):
                    makeASTWithMeta(
                        EIf(
                            transform(condition),
                            transform(then_expr),
                            else_expr != null ? transform(else_expr) : null
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform list literals (for array building patterns)
                case EList(items):
                    makeASTWithMeta(
                        EList(items.map(transform)),
                        node.metadata,
                        node.pos
                    );
                    
                // Transform case expressions - recurse into clauses
                case ECase(expr, clauses):
                    #if debug_string_interpolation
                    trace('[StringInterpolation] Found ECase, transforming ${clauses.length} clauses');
                    #end
                    makeASTWithMeta(
                        ECase(
                            transform(expr),
                            clauses.map(clause -> {
                                #if debug_string_interpolation
                                var bodyStr = ElixirASTPrinter.printAST(clause.body);
                                if (bodyStr.indexOf("rgb(") > -1 || bodyStr.indexOf("<>") > -1) {
                                    trace('[StringInterpolation] Clause body BEFORE transformation: ${bodyStr.substring(0, 200)}');
                                    trace('[StringInterpolation] Clause body type: ${Type.enumConstructor(clause.body.def)}');
                                }
                                #end
                                var transformedBody = transform(clause.body);
                                #if debug_string_interpolation
                                var transformedStr = ElixirASTPrinter.printAST(transformedBody);
                                if (bodyStr.indexOf("<>") > -1) {
                                    trace('[StringInterpolation] Clause body AFTER transformation: ${transformedStr.substring(0, 200)}');
                                }
                                #end
                                {
                                    pattern: clause.pattern, // Don't transform pattern
                                    guard: clause.guard != null ? transform(clause.guard) : null,
                                    body: transformedBody
                                }
                            })
                        ),
                        node.metadata,
                        node.pos
                    );
                    
                case EParen(expr):
                    // Handle parenthesized expressions - recurse into contents
                    makeASTWithMeta(
                        EParen(transform(expr)),
                        node.metadata,
                        node.pos
                    );
                    
                default:
                    // For all other nodes, return unchanged
                    // We're only transforming the specific nodes we care about
                    node;
            }
        }
        
        return transform(ast);
    }
    
    /**
     * Loop Transformation Pass
     * 
     * WHY: Haxe desugars loops into complex reduce_while(Stream.iterate(...)) patterns
     *      that are verbose and non-idiomatic in Elixir. These patterns should be
     *      transformed into clean Enum operations or comprehensions.
     * 
     * WHAT: Detects and transforms common loop patterns:
     *       - Simple iteration (0...n) ‚Üí Enum.each(0..n-1, fn i -> ... end)
     *       - Array iteration ‚Üí Enum.each(array, fn item -> ... end)
     *       - Collection building ‚Üí for comprehensions
     *       - Filtering ‚Üí Enum.filter or comprehension with guards
     * 
     * HOW: Pattern matches on Enum.reduce_while with Stream.iterate and transforms
     *      based on the loop body pattern (side effects only, collecting, filtering)
     * 
     * Example transformations:
     * From: Enum.reduce_while(Stream.iterate(0, fn n -> n + 1 end), {0}, fn _, {i} ->
     *         if (i < 5) do
     *           Log.trace(i)
     *           {:cont, {i + 1}}
     *         else
     *           {:halt, {i}}
     *         end
     *       end)
     * To: Enum.each(0..4, fn i -> Log.trace(i) end)
     */
    static function loopTransformationPass(ast: ElixirAST): ElixirAST {
        #if debug_loop_transformation
        trace("[LoopTransform] Starting loop transformation pass");
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ERemoteCall(module, funcName, args):
                    // Check for Enum.reduce_while pattern
                    switch(module.def) {
                        case EVar("Enum"):
                            if (funcName == "reduce_while" && args != null && args.length >= 3) {
                                #if debug_loop_transformation
                                trace("[LoopTransform] Found Enum.reduce_while call");
                                trace("[LoopTransform]   Args length: " + args.length);
                                if (args.length >= 3) {
                                    trace("[LoopTransform]   Third arg (reducer fn) type: " + Type.enumConstructor(args[2].def));
                                }
                                #end

                                // Check if first arg is Stream.iterate
                                var streamArg = args[0];
                                switch(streamArg.def) {
                                    case ERemoteCall(streamModule, streamFunc, streamArgs):
                                        switch(streamModule.def) {
                                            case EVar("Stream"):
                                                if (streamFunc == "iterate" && streamArgs != null && streamArgs.length >= 2) {
                                                    #if debug_loop_transformation
                                                    trace("[LoopTransform] Found Stream.iterate pattern - WILL ATTEMPT TRANSFORMATION");
                                                    #end
                                                    
                                                    // Extract the initial value and increment function
                                                    var initValue = streamArgs[0];
                                                    var incrementFunc = streamArgs[1];
                                                    
                                                    // Check if this is a simple counter (0, fn n -> n + 1 end)
                                                    var isSimpleCounter = false;
                                                    switch(initValue.def) {
                                                        case EInteger(0):
                                                            switch(incrementFunc.def) {
                                                                case EFn(clauses) if (clauses.length > 0):
                                                                    var clause = clauses[0];
                                                                    if (clause.args.length == 1) {
                                                                        // Check if body is n + 1
                                                                        switch(clause.body.def) {
                                                                            case EBinary(Add, left, right):
                                                                                switch(left.def) {
                                                                                    case EVar(varName):
                                                                                        // Get the parameter name from the pattern
                                                                                        var paramName = switch(clause.args[0]) {
                                                                                            case PVar(name): name;
                                                                                            default: null;
                                                                                        };
                                                                                        if (paramName != null && varName == paramName) {
                                                                                            switch(right.def) {
                                                                                                case EInteger(1):
                                                                                                    isSimpleCounter = true;
                                                                                                default:
                                                                                            }
                                                                                        }
                                                                                    default:
                                                                                }
                                                                            default:
                                                                        }
                                                                    }
                                                                default:
                                                            }
                                                        default:
                                                    }
                                                    
                                                    if (isSimpleCounter) {
                                                        #if debug_loop_transformation
                                                        trace("[LoopTransform] Detected simple counter loop");
                                                        #end
                                                        
                                                        // Analyze the loop function to extract the body and condition
                                                        var loopFunc = args[2];
                                                        switch(loopFunc.def) {
                                                            case EFn(clauses) if (clauses.length > 0):
                                                                var clause = clauses[0];
                                                                // Try to extract the loop bound and body
                                                                var loopInfo = analyzeLoopBody(clause.body);
                                                                if (loopInfo != null) {
                                                                    #if debug_loop_transformation
                                                                    trace("[LoopTransform] Successfully analyzed loop body");
                                                                    trace("[LoopTransform] Upper bound: " + ElixirASTPrinter.print(loopInfo.upperBound, 0));
                                                                    trace("[LoopTransform] Has side effects only: " + loopInfo.hasSideEffectsOnly);
                                                                    #end
                                                                    
                                                                    // Transform to idiomatic Elixir
                                                                    if (loopInfo.hasSideEffectsOnly) {
                                                                        // Simple iteration with side effects ‚Üí Enum.each
                                                                        var range = makeAST(ERange(
                                                                            makeAST(EInteger(0), node.pos),
                                                                            makeAST(EBinary(Subtract, loopInfo.upperBound, makeAST(EInteger(1), node.pos)), node.pos),
                                                                            false // inclusive range (0..n-1)
                                                                        ), node.pos);
                                                                        
                                                                        var eachFunc = makeAST(EFn([{
                                                                            args: [PVar(loopInfo.iteratorVar)],
                                                                            guard: null,
                                                                            body: loopInfo.loopBody
                                                                        }]), node.pos);
                                                                        
                                                                        #if debug_loop_transformation
                                                                        trace("[LoopTransform] Transforming to Enum.each");
                                                                        #end
                                                                        
                                                                        return makeAST(ERemoteCall(
                                                                            makeAST(EVar("Enum"), node.pos),
                                                                            "each",
                                                                            [range, eachFunc]
                                                                        ), node.pos);
                                                                    }
                                                                }
                                                            default:
                                                        }
                                                    }
                                                }
                                            default:
                                        }
                                    default:
                                }
                            }
                        default:
                    }
                default:
            }
            
            return node;
        });
    }
    
    /**
     * Analyze a loop body to extract iteration information
     */
    static function analyzeLoopBody(body: ElixirAST): Null<{upperBound: ElixirAST, iteratorVar: String, loopBody: ElixirAST, hasSideEffectsOnly: Bool}> {
        // Look for the if condition pattern
        switch(body.def) {
            case EIf(condition, thenBranch, elseBranch):
                // Extract the upper bound from the condition
                var upperBound: ElixirAST = null;
                var iteratorVar: String = null;
                
                switch(condition.def) {
                    case EBinary(Less, left, right):
                        // Pattern: i < upperBound
                        switch(left.def) {
                            case EVar(varName):
                                iteratorVar = varName;
                                upperBound = right;
                            default:
                        }
                    default:
                }
                
                if (upperBound != null && iteratorVar != null) {
                    // Extract the loop body from the then branch
                    var loopBody: ElixirAST = null;
                    var hasSideEffectsOnly = true;
                    
                    switch(thenBranch.def) {
                        case EBlock(exprs):
                            // Filter out the increment and continuation
                            var bodyExprs = [];
                            for (expr in exprs) {
                                switch(expr.def) {
                                    case ETuple([contAtom, _]):
                                        // Skip {:cont, ...}
                                        switch(contAtom.def) {
                                            case EAtom(cont) if (cont == "cont"):
                                                // Skip
                                            default:
                                                bodyExprs.push(expr);
                                        }
                                    case EBinary(Add, _, _):
                                        // Skip increment expressions
                                    case EInteger(_):
                                        // Skip standalone integers
                                    default:
                                        bodyExprs.push(expr);
                                }
                            }
                            
                            if (bodyExprs.length == 1) {
                                loopBody = bodyExprs[0];
                            } else if (bodyExprs.length > 1) {
                                loopBody = makeAST(EBlock(bodyExprs), body.pos);
                            }
                        default:
                    }
                    
                    if (loopBody != null) {
                        return {
                            upperBound: upperBound,
                            iteratorVar: iteratorVar,
                            loopBody: loopBody,
                            hasSideEffectsOnly: hasSideEffectsOnly
                        };
                    }
                }
            default:
        }
        
        return null;
    }
    
    /**
     * Pipeline optimization pass - convert sequential operations to pipeline
     */
    static function pipelineOptimizationPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                case EBlock(expressions):
                    // Look for pipeline patterns in blocks
                    var optimized = detectAndOptimizePipeline(expressions);
                    if (optimized != null) {
                        optimized;
                    } else {
                        node;
                    }
                    
                default:
                    node;
            }
        });
    }
    
    /**
     * Map Iterator Transformation Pass (forwarder)
     * Thin forwarder to MapAndCollectionTransforms.mapIteratorTransformPass
     */
    static function mapIteratorTransformPass(ast: ElixirAST): ElixirAST {
        return reflaxe.elixir.ast.transformers.MapAndCollectionTransforms.mapIteratorTransformPass(ast);
    }
    
    // Helper function to check if an AST contains Map iterator patterns
    // (legacy helper functions removed; implemented in MapAndCollectionTransforms)
    
    /**
     * Comprehension conversion pass - convert loops to comprehensions
     * This pass needs to handle module-level transformation to add generated functions
     */
    static function comprehensionConversionPass(ast: ElixirAST): ElixirAST {
        // Collection for generated loop functions
        var generatedFunctions: Array<ElixirAST> = [];
        var loopCounter = 0;
        
        // First pass: transform loops and collect generated functions
        function transformLoops(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Convert for loops that build lists
                case EFor(generators, filters, body, into, uniq):
                    // Already a comprehension, keep as-is
                    node;
                    
                // Convert while loops to recursive functions
                case ECall(null, "while_loop", [condition, body]):
                    // Generate unique function name
                    var funcName = "loop_" + (loopCounter++);
                    
                    // Transform condition and body recursively
                    var transformedCondition = transformNode(condition, transformLoops);
                    var transformedBody = transformNode(body, transformLoops);
                    
                    // Create recursive function definition
                    var recursiveFunc = makeAST(
                        EDefp(funcName, [], null, 
                            makeAST(EIf(
                                transformedCondition,
                                makeAST(EBlock([
                                    transformedBody,
                                    makeAST(ECall(null, funcName, []))
                                ])),
                                makeAST(EAtom(ElixirAtom.ok()))
                            ))
                        )
                    );
                    
                    // Add to generated functions collection
                    generatedFunctions.push(recursiveFunc);
                    
                    // Replace with function call
                    makeAST(ECall(null, funcName, []));
                    
                default:
                    // Return node unchanged - base case to prevent infinite recursion
                    node;
            }
        }
        
        // Apply transformation
        var transformed = transformLoops(ast);
        
        // If we're at module level and have generated functions, insert them
        if (generatedFunctions.length > 0) {
            switch(transformed.def) {
                case EModule(name, attributes, body):
                    // Insert generated functions at the end of the module body
                    var newBody = body.concat(generatedFunctions);
                    return makeAST(EModule(name, attributes, newBody));
                default:
                    // For non-module nodes, we need to wrap or handle differently
                    // This shouldn't happen in normal compilation
                    return transformed;
            }
        }
        
        return transformed;
    }
    
    /**
     * Abstract Method This Reference Fix Pass
     * 
     * WHY: In abstract methods like toDynamic(), Haxe generates parameters like "this_1"
     * but the AST builder incorrectly uses "struct" for TConst(TThis), causing reference mismatches.
     * 
     * WHAT: Fixes "struct" references in anonymous functions to match the actual parameter name.
     * - Detects anonymous functions with parameters like "this", "this_1", etc.
     * - Replaces "struct" references in the body with the actual parameter name
     * 
     * HOW: Tracks the first parameter of anonymous functions and ensures body references match
     */
    static function abstractMethodThisPass(ast: ElixirAST): ElixirAST {
        #if debug_abstract_this
        trace('[XRay AbstractThis] Starting pass');
        #end
        
        // Add debug to see what nodes we're actually getting
        #if debug_abstract_this
        function debugNode(node: ElixirAST, depth: Int = 0) {
            var indent = [for (i in 0...depth) "  "].join("");
            switch(node.def) {
                case EModule(name, _, body):
                    trace('$indent[XRay AbstractThis] Module: $name with ${body.length} definitions');
                    for (def in body) debugNode(def, depth + 1);
                case EDef(name, _, _, body):
                    trace('$indent[XRay AbstractThis] Def: $name');
                    debugNode(body, depth + 1);
                case EFn(clauses):
                    trace('$indent[XRay AbstractThis] !! Found EFn with ${clauses.length} clauses !!');
                default:
                    // Don't trace every node type, just the ones we care about
            }
        }
        debugNode(ast, 0);
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EFn(clauses):
                    #if debug_abstract_this
                    trace('[XRay AbstractThis] Processing EFn with ${clauses.length} clauses');
                    #end
                    // Check if this is an abstract method with "this" parameter
                    var fixedClauses = [];
                    var hasChanges = false;
                    
                    for (clause in clauses) {
                        if (clause.args.length > 0) {
                            switch(clause.args[0]) {
                                case PVar(paramName) if (paramName.indexOf("this") == 0 || paramName == "_struct" || paramName == "struct"):
                                    #if debug_abstract_this
                                    trace('[XRay AbstractThis] Found function with this/struct parameter: $paramName');
                                    trace('[XRay AbstractThis] Body before fix: ${ElixirASTPrinter.print(clause.body, 0)}');
                                    #end
                                    
                                    // Found a "this", "this_1", "struct", or "_struct" parameter
                                    // Replace "struct" or "this" with the actual parameter name in body
                                    var fixedBody = replaceStructWithParam(clause.body, paramName);
                                    
                                    #if debug_abstract_this
                                    trace('[XRay AbstractThis] Body after fix: ${ElixirASTPrinter.print(fixedBody, 0)}');
                                    #end
                                    
                                    hasChanges = true;
                                    fixedClauses.push({
                                        args: clause.args,
                                        guard: clause.guard,
                                        body: fixedBody
                                    });
                                default:
                                    fixedClauses.push(clause);
                            }
                        } else {
                            fixedClauses.push(clause);
                        }
                    }
                    
                    if (hasChanges) {
                        #if debug_abstract_this
                        trace('[XRay AbstractThis] Applied fix to function');
                        #end
                        return makeASTWithMeta(EFn(fixedClauses), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Helper: Replace "struct" or "this" variables with the actual parameter name
     * 
     * PROBLEM: In abstract methods, the AST builder sometimes generates incorrect variable
     * references. The parameter might be named "this_1" but the body references "this" or
     * "struct", causing compilation errors like "undefined variable this".
     * 
     * EXAMPLES:
     * - Input:  fn this_1 -> this end       // Wrong: "this" doesn't exist
     * - Output: fn this_1 -> this_1 end     // Fixed: matches parameter name
     * 
     * - Input:  fn this -> struct end       // Wrong: "struct" is internal compiler name
     * - Output: fn this -> this end         // Fixed: uses actual parameter
     * 
     * - Input:  fn this_2 -> struct.field end    // Wrong: struct not in scope
     * - Output: fn this_2 -> this_2.field end    // Fixed: correct reference
     * 
     * @param ast The AST to transform
     * @param paramName The actual parameter name to use (e.g., "this", "this_1", "this_2")
     * @return AST with all "struct" and "this" references replaced with paramName
     */
    static function replaceStructWithParam(ast: ElixirAST, paramName: String): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EVar("struct") | EVar("this"):
                    // Replace "struct" or "this" with the actual parameter name
                    return makeASTWithMeta(EVar(paramName), node.metadata, node.pos);
                default:
                    return node;
            }
        });
    }
    
    /**
     * Bitwise Import Pass
     * 
     * WHY: Elixir requires "import Bitwise" to use bitwise operators like &&&, |||, ^^^
     * but the generated code doesn't include this import automatically.
     * 
     * WHAT: Detects usage of bitwise operators and adds "import Bitwise" to the module.
     * - Scans the entire AST for bitwise operators
     * - Adds the import statement if any are found
     * 
     * HOW: Two-phase approach:
     * 1. Detection: Walk the AST to find bitwise operators
     * 2. Injection: Add import to module (handles both EModule and EDefmodule formats)
     * 
     * IMPORTANT AST STRUCTURE: Modules can be represented in two ways:
     * 
     * EDefmodule(name, doBlock): Standard Elixir "defmodule Name do ... end" format
     *   This is the most common format. The import must be added as the first 
     *   statement in the do block.
     *   
     *   Original Haxe code:
     *     class StringTools {
     *         public static function ltrim(s: String): String {
     *             // Uses bitwise operators &&&
     *         }
     *     }
     *   
     *   Example AST:
     *     EDefmodule("StringTools", 
     *       EBlock([
     *         EImport("Bitwise", null, null),  // <-- Insert here
     *         EFunction(...),
     *         EFunction(...)
     *       ])
     *     )
     * 
     * EModule(name, attributes, body): Alternative format with attributes array
     *   Less common format. The import is added to the attributes array.
     *   
     *   This format may be used internally by the compiler for certain constructs
     *   or intermediate representations. Most user-defined Haxe classes generate
     *   EDefmodule, not EModule. The exact conditions that produce EModule vs
     *   EDefmodule depend on the AST builder's internal logic.
     *   
     *   Example AST:
     *     EModule("StringTools",
     *       [
     *         EImport("Bitwise", null, null),  // <-- Insert here
     *         EAttribute(...)
     *       ],
     *       [EFunction(...), EFunction(...)]
     *     )
     * 
     * The original pass only handled EModule, which is why it wasn't working for
     * most generated code that uses EDefmodule format.
     */
    static function bitwiseImportPass(ast: ElixirAST): ElixirAST {
        // Phase 1: Detect if bitwise operators are used
        var needsBitwise = false;
        
        #if debug_bitwise_import
        trace('[XRay BitwiseImport] Starting scan for bitwise operators');
        #end
        
        // Recursive function to deeply traverse the AST
        function checkForBitwise(node: ElixirAST): Void {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return;
            }

            #if debug_bitwise_import
            var nodeType = Type.enumConstructor(node.def);
            if (nodeType == "EBinary") {
                trace('[XRay BitwiseImport] Checking EBinary node');
            }
            #end

            switch(node.def) {
                case EBinary(op, left, right):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Binary operator: $op');
                    #end
                    switch(op) {
                        case BitwiseAnd | BitwiseOr | BitwiseXor | ShiftLeft | ShiftRight:
                            #if debug_bitwise_import
                            trace('[XRay BitwiseImport] Found bitwise operator: $op');
                            #end
                            needsBitwise = true;
                        default:
                    }
                    // Recursively check child nodes
                    checkForBitwise(left);
                    checkForBitwise(right);
                case EUnary(BitwiseNot, expr):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Found BitwiseNot operator');
                    #end
                    needsBitwise = true;
                    checkForBitwise(expr);
                default:
                    // For all other node types, recursively visit children
                    iterateAST(node, checkForBitwise);
            }
        }
        
        checkForBitwise(ast);
        
        #if debug_bitwise_import
        trace('[XRay BitwiseImport] Needs bitwise: $needsBitwise');
        #end
        
        // Phase 2: Add import if needed
        if (!needsBitwise) return ast;
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDefmodule(name, doBlock):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Processing defmodule: $name');
                    #end
                    
                    // For defmodule, we need to inject the import into the do block
                    switch(doBlock.def) {
                        case EBlock(statements):
                            #if debug_bitwise_import
                            trace('[XRay BitwiseImport] Defmodule has ${statements.length} statements');
                            #end
                            
                            // Check if Bitwise is already imported
                            var hasImport = false;
                            for (stmt in statements) {
                                switch(stmt.def) {
                                    case EImport(module, _, _):  // Match all three parameters
                                        if (module == "Bitwise") {
                                            hasImport = true;
                                            break;
                                        }
                                    default:
                                }
                            }
                            
                            if (!hasImport) {
                                // Add import Bitwise at the beginning
                                var newStatements = statements.copy();
                                newStatements.insert(0, makeAST(EImport("Bitwise", null, null)));  // Provide all three parameters
                                
                                #if debug_bitwise_import
                                trace('[XRay BitwiseImport] Added import Bitwise to defmodule');
                                #end
                                
                                return makeASTWithMeta(
                                    EDefmodule(name, makeAST(EBlock(newStatements))),
                                    node.metadata,
                                    node.pos
                                );
                            }
                        default:
                    }
                    return node;
                    
                case EModule(name, attributes, body):
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Processing module: $name');
                    trace('[XRay BitwiseImport] Current attributes count: ${attributes.length}');
                    #end
                    
                    // Check if Bitwise is already imported (by checking attribute names)
                    var hasImport = false;
                    for (attr in attributes) {
                        if (attr.name == "import" && attr.value != null) {
                            // Check if it's importing Bitwise
                            switch(attr.value.def) {
                                case EAtom(atomVal) if (atomVal == "Bitwise"):
                                    hasImport = true;
                                case EVar("Bitwise"):
                                    hasImport = true;
                                default:
                            }
                        }
                    }
                    
                    #if debug_bitwise_import
                    trace('[XRay BitwiseImport] Has existing import: $hasImport');
                    #end
                    
                    if (!hasImport) {
                        // Add import Bitwise at the beginning of attributes
                        var newAttributes = attributes.copy();
                        newAttributes.insert(0, {
                            name: "import",
                            value: makeAST(EAtom(ElixirAtom.raw("Bitwise")))
                        });
                        
                        #if debug_bitwise_import
                        trace('[XRay BitwiseImport] Added import Bitwise to module');
                        #end
                        
                        return makeASTWithMeta(
                            EModule(name, newAttributes, body),
                            node.metadata,
                            node.pos
                        );
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * List Effect Lifting Pass
     * 
     * WHY: Elixir doesn't allow assignments or side-effecting expressions inside list literals.
     * The malformed pattern `g = g ++ [g = [] ...]` creates illegal syntax.
     * 
     * WHAT: Detects and lifts side-effecting expressions out of list literals.
     * - Identifies assignments and other side effects within EList elements
     * - Extracts them to statements before the list construction
     * - Replaces them with pure variable references
     * 
     * HOW: Transforms EList nodes by:
     * 1. Scanning elements for side effects (assignments, blocks)
     * 2. Extracting effects to temporary variables
     * 3. Building the list with pure expressions only
     * 
     * Example:
     * Input:  [g = [], g = g ++ [1], g]
     * Output: g = []; g = g ++ [1]; [g]
     */
    static function listEffectLiftingPass(ast: ElixirAST): ElixirAST {
        #if debug_effect_lifting
        trace('[XRay ListEffectLifting] Starting pass');
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EList(elements):
                    #if debug_effect_lifting
                    trace('[XRay ListEffectLifting] Processing list with ${elements.length} elements');
                    #end
                    
                    // Check if any element has side effects
                    var hasEffects = false;
                    var liftedStatements: Array<ElixirAST> = [];
                    var pureElements: Array<ElixirAST> = [];
                    
                    for (i in 0...elements.length) {
                        var elem = elements[i];
                        #if debug_effect_lifting
                        trace('[XRay ListEffectLifting] Checking element $i: ${ElixirASTPrinter.print(elem, 0).substring(0, 50)}');
                        #end
                        
                        switch(elem.def) {
                            case EMatch(left, right):
                                // Assignment inside list - needs lifting
                                #if debug_effect_lifting
                                trace('[XRay ListEffectLifting] Found assignment in element $i');
                                #end
                                hasEffects = true;
                                liftedStatements.push(elem);
                                // Replace with just the variable reference
                                switch(left) {
                                    case PVar(name):
                                        pureElements.push(makeAST(EVar(name)));
                                    default:
                                        // For other patterns, convert to a simple variable
                                        pureElements.push(makeAST(EVar("_lifted_var")));
                                }
                                
                            case EBlock(exprs) if (exprs.length > 0):
                                // Block inside list - extract statements, keep last expression
                                #if debug_effect_lifting
                                trace('[XRay ListEffectLifting] Found block in element $i with ${exprs.length} expressions');
                                #end
                                hasEffects = true;
                                for (j in 0...exprs.length - 1) {
                                    liftedStatements.push(exprs[j]);
                                }
                                pureElements.push(exprs[exprs.length - 1]);
                                
                            case EBinary(Concat, left, right):
                                // Check if this is a nested problematic pattern
                                switch(right.def) {
                                    case EList(innerElements) if (innerElements.length > 0):
                                        // Check if inner list has assignments
                                        var innerHasEffects = false;
                                        for (innerElem in innerElements) {
                                            switch(innerElem.def) {
                                                case EMatch(_, _) | EBlock(_):
                                                    innerHasEffects = true;
                                                    break;
                                                default:
                                            }
                                        }
                                        if (innerHasEffects) {
                                            #if debug_effect_lifting
                                            trace('[XRay ListEffectLifting] Found nested list with effects');
                                            #end
                                            // Process the inner list recursively
                                            var processedInner = listEffectLiftingPass(makeAST(right.def));
                                            switch(processedInner.def) {
                                                case EBlock(stmts) if (stmts.length > 0):
                                                    hasEffects = true;
                                                    // Add all but last statement to lifted
                                                    for (k in 0...stmts.length - 1) {
                                                        liftedStatements.push(stmts[k]);
                                                    }
                                                    // Keep the concatenation with cleaned list
                                                    pureElements.push(makeAST(EBinary(Concat, left, stmts[stmts.length - 1])));
                                                default:
                                                    pureElements.push(elem);
                                            }
                                        } else {
                                            pureElements.push(elem);
                                        }
                                    default:
                                        pureElements.push(elem);
                                }
                                
                            default:
                                // Pure expression, keep as-is
                                pureElements.push(elem);
                        }
                    }
                    
                    if (hasEffects) {
                        #if debug_effect_lifting
                        trace('[XRay ListEffectLifting] Lifting ${liftedStatements.length} statements');
                        #end
                        
                        // Return a block with lifted statements followed by pure list
                        var allStatements = liftedStatements.copy();
                        allStatements.push(makeAST(EList(pureElements)));
                        return makeAST(EBlock(allStatements));
                    }
                    
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Struct field assignment transformation pass
     * 
     * WHY: Haxe's mutable field assignments (this.field = value) need to be transformed
     *      to Elixir's immutable struct update syntax (%{struct | field: value})
     * 
     * WHAT: Detects patterns like EMatch(EField(struct_var, field), value) where struct_var
     *       is a struct parameter (like "struct" or "self"), and transforms them to return
     *       a new struct with the updated field
     * 
     * HOW: - Identifies field assignments on struct parameters
     *      - Converts them to struct update syntax
     *      - Returns the updated struct for proper threading
     * 
     * Example: struct.count = 5 ‚Üí %{struct | count: 5}
     */
    static function structFieldAssignmentTransformPass(ast: ElixirAST): ElixirAST {
        // Need to track the original struct variable for field assignments
        var structVarTracking: Map<String, String> = new Map();
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EBlock(expressions):
                    // Process block expressions looking for field assignment patterns
                    var transformed = [];
                    var i = 0;
                    
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        
                        // Look for pattern: spec = worker(...) followed by fieldName = value
                        switch(expr.def) {
                            case EMatch(PVar(varName), rhs):
                                // Track struct variable assignments from known constructors
                                switch(rhs.def) {
                                    case ECall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
                                        structVarTracking.set(varName, varName);
                                    case ERemoteCall(_, funcName, _) if (funcName == "worker" || funcName == "supervisor" || funcName == "temp_worker"):
                                        structVarTracking.set(varName, varName);
                                    default:
                                }
                                
                                // Check if this is a field assignment pattern
                                // Look ahead for the next expression to see if it's a field assignment
                                if (i + 1 < expressions.length) {
                                    var nextExpr = expressions[i + 1];
                                    switch(nextExpr.def) {
                                        case EMatch(PVar(fieldName), fieldValue):
                                            // Check if previous expression was a struct assignment we're tracking
                                            // and the field name matches common struct field patterns
                                            if (structVarTracking.exists(varName) && 
                                                (fieldName == "restart" || fieldName == "shutdown" || fieldName == "type" || 
                                                 fieldName == "strategy" || fieldName == "max_restarts" || fieldName == "max_seconds")) {
                                                // This looks like a struct field assignment pattern
                                                // Transform: fieldName = value ‚Üí spec = Map.put(spec, :fieldName, value)
                                                #if debug_ast_transformer
                                                trace('[XRay StructFieldAssignment] Found field assignment pattern: $fieldName = ...');
                                                trace('[XRay StructFieldAssignment] Transforming to Map.put($varName, :$fieldName, ...)');
                                                #end
                                                
                                                // Add the original struct assignment
                                                transformed.push(expr);
                                                
                                                // Transform the field assignment to Map.put
                                                var mapPut = makeAST(EMatch(
                                                    PVar(varName),
                                                    makeAST(ERemoteCall(
                                                        makeAST(EVar("Map")),
                                                        "put",
                                                        [
                                                            makeAST(EVar(varName)),
                                                            makeAST(EAtom(fieldName)),
                                                            fieldValue
                                                        ]
                                                    ))
                                                ));
                                                transformed.push(mapPut);
                                                
                                                // Skip the original field assignment
                                                i += 2;
                                                continue;
                                            }
                                        default:
                                    }
                                }
                                
                                // Not a field assignment pattern, keep as-is
                                transformed.push(expr);
                            default:
                                transformed.push(expr);
                        }
                        i++;
                    }
                    
                    // Return transformed block if we made changes
                    if (transformed.length > 0) {
                        return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    // Not a block, continue traversal
                    return node;
            }
        });
    }
    
    /**
     * Statement context transformation pass - add reassignments for immutable operations
     * 
     * WHY: Elixir is immutable, so operations like Map.put() return new values
     * WHAT: Detects when these operations are used as statements (value discarded)
     * HOW: Wraps them in reassignment to the original variable
     * 
     * Example transformation:
     * Map.put(params, "key", value) ‚Üí params = Map.put(params, "key", value)
     */
    static function statementContextTransformPass(ast: ElixirAST): ElixirAST {
        // Transform with context tracking
        function transformWithContext(node: ElixirAST, isStatementContext: Bool): ElixirAST {
            // Check for null node or def before processing
            if (node == null || node.def == null) {
                return node;
            }

            #if debug_ast_transformer
            trace('[XRay StatementContext] Processing node: ${node.def}, context: ${isStatementContext ? "statement" : "expression"}');
            #end

            // First, recursively transform children with appropriate context
            var transformed = switch(node.def) {
                case EDefmodule(name, doBlock):
                    // Process the module's do block in statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDefmodule: $name');
                    #end
                    makeASTWithMeta(
                        EDefmodule(name, transformWithContext(doBlock, true)),
                        node.metadata, node.pos
                    );
                    
                case EBlock(expressions):
                    // In a block, all but the last expression are in statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EBlock with ${expressions.length} expressions');
                    #end
                    var newExpressions = [];
                    for (i in 0...expressions.length) {
                        var isLast = (i == expressions.length - 1);
                        var childContext = isLast ? isStatementContext : true;
                        #if debug_ast_transformer
                        if (expressions[i] != null && expressions[i].def != null) {
                            var exprType = Type.enumConstructor(expressions[i].def);
                            trace('[XRay StatementContext] Block expr $i/${expressions.length}: $exprType, context: ${childContext ? "statement" : "expression"}');
                        }
                        #end
                        newExpressions.push(transformWithContext(expressions[i], childContext));
                    }
                    makeASTWithMeta(EBlock(newExpressions), node.metadata, node.pos);
                    
                case EDef(name, args, guards, body):
                    // Function body is a block - let it handle its own statement/expression context
                    // The block will mark all but the last expression as statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDef: $name, body type: ${body.def}');
                    #end
                    makeASTWithMeta(
                        EDef(name, args, guards, transformWithContext(body, false)),
                        node.metadata, node.pos
                    );
                    
                case EDefp(name, args, guards, body):
                    // Function body is a block - let it handle its own statement/expression context  
                    // The block will mark all but the last expression as statement context
                    #if debug_ast_transformer
                    trace('[XRay StatementContext] Processing EDefp: $name, body type: ${body.def}');
                    #end
                    makeASTWithMeta(
                        EDefp(name, args, guards, transformWithContext(body, false)),
                        node.metadata, node.pos
                    );
                    
                case EIf(condition, thenBranch, elseBranch):
                    // Both branches inherit parent context
                    makeASTWithMeta(
                        EIf(transformWithContext(condition, false),
                            transformWithContext(thenBranch, isStatementContext),
                            elseBranch != null ? transformWithContext(elseBranch, isStatementContext) : null),
                        node.metadata, node.pos
                    );
                    
                case ECase(expr, clauses):
                    // All clauses inherit parent context
                    makeASTWithMeta(
                        ECase(transformWithContext(expr, false),
                              clauses.map(c -> {
                                  pattern: c.pattern,
                                  guard: c.guard != null ? transformWithContext(c.guard, false) : null,
                                  body: transformWithContext(c.body, isStatementContext)
                              })),
                        node.metadata, node.pos
                    );
                    
                // For other nodes, recursively transform children based on node type
                default:
                    // Manually handle child transformation for other node types
                    switch(node.def) {
                        case EModule(name, attributes, body):
                            makeASTWithMeta(
                                EModule(name, attributes, body.map(e -> transformWithContext(e, true))),
                                node.metadata, node.pos
                            );
                            
                        case ECall(target, funcName, args):
                            makeASTWithMeta(
                                ECall(target != null ? transformWithContext(target, false) : null,
                                      funcName,
                                      args.map(a -> transformWithContext(a, false))),
                                node.metadata, node.pos
                            );
                            
                        case ERemoteCall(module, funcName, args):
                            makeASTWithMeta(
                                ERemoteCall(transformWithContext(module, false),
                                           funcName,
                                           args.map(a -> transformWithContext(a, false))),
                                node.metadata, node.pos
                            );
                            
                        case EBinary(op, left, right):
                            makeASTWithMeta(
                                EBinary(op,
                                       transformWithContext(left, false),
                                       transformWithContext(right, false)),
                                node.metadata, node.pos
                            );
                            
                        case EMatch(pattern, expr):
                            makeASTWithMeta(
                                EMatch(pattern, transformWithContext(expr, false)),
                                node.metadata, node.pos
                            );
                            
                        // For literals and simple nodes, return unchanged
                        default:
                            node;
                    }
            };
            
            // Now check if this node needs reassignment wrapping
            if (isStatementContext) {
                switch(transformed.def) {
                    case ERemoteCall(module, funcName, args):
                        #if debug_ast_transformer
                        trace('[XRay StatementContext] Checking ERemoteCall: module=${module.def}, func=$funcName, args=${args.length}');
                        #end
                        // Check for immutable operations that need reassignment in statement context
                        var moduleName: Null<String> = switch(module.def) {
                            case EAtom(atom): atom; // ElixirAtom implicitly converts to String
                            case EVar(name): name;  // name is already String
                            default: null;
                        };
                        
                        if (moduleName != null) {
                            #if debug_ast_transformer
                            trace('[XRay StatementContext] Found module $moduleName, checking function: $funcName');
                            #end
                            
                            // Define immutable operations for each Elixir module
                            // TODO: Future improvement - Move this metadata to Haxe source files
                            // Instead of hardcoding here, each module (Map.hx, List.hx, etc.) could
                            // use metadata annotations like @:immutable or @:reassignsVar on methods
                            // that return new instances. This would make the system more maintainable
                            // and allow custom types to opt into this behavior.
                            // Example: @:immutable function put(key: K, value: V): Map<K,V> { ... }
                            var needsReassignment = switch(moduleName) {
                                case "Map":
                                    ["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;
                                case "List":
                                    ["delete", "delete_at", "insert_at", "replace_at", "update_at", "pop_at", "flatten", "wrap"].indexOf(funcName) >= 0;
                                case "MapSet":
                                    ["put", "delete", "union", "intersection", "difference"].indexOf(funcName) >= 0;
                                case "Keyword":
                                    ["put", "delete", "merge", "update", "drop", "put_new", "put_new_lazy", "replace"].indexOf(funcName) >= 0;
                                case "String":
                                    ["replace", "trim", "upcase", "downcase", "capitalize", "reverse", "slice"].indexOf(funcName) >= 0;
                                default:
                                    false;
                            };
                            
                            if (needsReassignment && args.length >= 1) {
                                // First arg should be the variable being modified
                                switch(args[0].def) {
                                    case EVar(varName):
                                        #if debug_ast_transformer
                                        trace('[XRay StatementContext] Wrapping $moduleName.$funcName with reassignment to: $varName');
                                        #end
                                        // Transform to: varName = Module.operation(varName, ...)
                                        return makeASTWithMeta(
                                            EMatch(PVar(varName), transformed),
                                            node.metadata, node.pos
                                        );
                                    default:
                                        // Not a simple variable, can't reassign
                                }
                            }
                        }
                        
                    case EBinary(Concat, left, right):
                        // Check for list concatenation in statement context
                        switch(left.def) {
                            case EVar(varName):
                                #if debug_ast_transformer
                                trace('[XRay StatementContext] Wrapping ++ with reassignment to: $varName');
                                #end
                                // Transform to: varName = varName ++ right
                                return makeASTWithMeta(
                                    EMatch(PVar(varName), transformed),
                                    node.metadata, node.pos
                                );
                            default:
                        }
                        
                    default:
                }
            }
            
            return transformed;
        }
        
        // Start transformation with top-level as statement context
        return transformWithContext(ast, true);
    }
    
    /**
     * Immutability transformation pass - convert mutable patterns to immutable
     * 
     * ENHANCED: Now handles struct field mutations in BalancedTree and similar patterns
     */
    static function immutabilityTransformPass(ast: ElixirAST): ElixirAST {
        // First pass: Transform method bodies that mutate struct fields
        ast = transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                case EDef(name, args, guards, body) if ((name == "set" || name == "remove") && 
                                                        args.length > 0 && 
                                                        switch(args[0]) { case PVar("struct"): true; default: false; }):
                    // This is a struct method that might mutate fields
                    #if debug_ast_transformer
                    trace('[XRay ImmutabilityTransform] Found method $name with struct parameter');
                    #end
                    var updatedBody = transformStructFieldAssignments(body, args);
                    if (updatedBody != body) {
                        #if debug_ast_transformer
                        trace('[XRay ImmutabilityTransform] Transformed body for method $name');
                        #end
                        makeASTWithMeta(
                            EDef(name, args, guards, updatedBody),
                            node.metadata,
                            node.pos
                        );
                    } else {
                        #if debug_ast_transformer
                        trace('[XRay ImmutabilityTransform] No transformation needed for method $name');
                        #end
                        node;
                    }
                default:
                    node;
            }
        });
        
        // Second pass: Other immutability transformations
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            return switch(node.def) {
                // Transform increment/decrement to reassignment
                case ECall(null, "pre_inc", [expr]):
                    // x++ becomes x = x + 1
                    switch(expr.def) {
                        case EVar(name):
                            makeAST(EMatch(
                                PVar(name),
                                makeAST(EBinary(Add, expr, makeAST(EInteger(1))))
                            ));
                        default:
                            node;
                    }
                    
                case ECall(null, "pre_dec", [expr]):
                    // x-- becomes x = x - 1
                    switch(expr.def) {
                        case EVar(name):
                            makeAST(EMatch(
                                PVar(name),
                                makeAST(EBinary(Subtract, expr, makeAST(EInteger(1))))
                            ));
                        default:
                            node;
                    }
                    
                // Transform modulo operator to rem function call
                case EBinary(Remainder, left, right):
                    // x % 2 becomes rem(x, 2) - rem is a function in Elixir, not an operator
                    makeAST(ECall(
                        null,
                        "rem",
                        [left, right]
                    ));
                    
                // Transform array mutation patterns
                case ECall(target, "push", [item]):
                    // Check if this is a push on a field (either direct or via struct)
                    switch(target.def) {
                        case EField(structVar, fieldName):
                            // This is struct.field.push(item) - qualified field access
                            // Check if structVar is "struct" (the conventional instance parameter)
                            switch(structVar.def) {
                                case EVar("struct"):
                                    // GUARD: Check if fieldName is an array infrastructure variable
                                    if (StructUpdateTransform.isArrayVariable(fieldName)) {
                                        #if debug_ast_transformer
                                        trace('[XRay ImmutabilityTransform] Skipping array variable field: struct.$fieldName');
                                        #end
                                        // Regular array concatenation
                                        makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                                    } else {
                                        // Transform to struct update: %{struct | field: struct.field ++ [item]}
                                        #if debug_ast_transformer
                                        trace('[XRay ImmutabilityTransform] Transforming struct.$fieldName.push(item) to struct update');
                                        #end
                                        makeAST(EStructUpdate(
                                            structVar,
                                            [{
                                                key: fieldName,
                                                value: makeAST(EBinary(
                                                    Concat,
                                                    target,  // struct.field
                                                    makeAST(EList([item]))
                                                ))
                                            }]
                                        ));
                                    }
                                default:
                                    node;
                            }
                        case EVar(fieldName):
                            // This is field.push(item) - direct field access
                            // This happens in instance methods where fields are accessed directly

                            // GUARD: Check if this is an array infrastructure variable
                            // Pattern: g, g2, _g, _g2, etc. - these are NOT struct fields
                            if (StructUpdateTransform.isArrayVariable(fieldName)) {
                                #if debug_ast_transformer
                                trace('[XRay ImmutabilityTransform] Skipping array variable: $fieldName');
                                #end
                                // Regular array concatenation, not struct update
                                makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                            } else {
                                // We need to transform this to a struct update
                                #if debug_ast_transformer
                                trace('[XRay ImmutabilityTransform] Transforming $fieldName.push(item) to struct update');
                                #end
                                // Create the struct variable (assuming "struct" is the instance parameter)
                                var structVar = makeAST(EVar("struct"));
                                makeAST(EStructUpdate(
                                    structVar,
                                    [{
                                        key: fieldName,
                                        value: makeAST(EBinary(
                                            Concat,
                                            makeAST(EField(structVar, fieldName)),  // struct.field
                                            makeAST(EList([item]))
                                        ))
                                    }]
                                ));
                            }
                        default:
                            // Regular array.push(item) becomes array ++ [item]
                            makeAST(EBinary(Concat, target, makeAST(EList([item]))));
                    }

                case ECall(target, "pop", []):
                    // array.pop() becomes List.delete_at(array, -1)
                    makeAST(ERemoteCall(
                        makeAST(EAtom(ElixirAtom.raw("List"))),
                        "delete_at",
                        [target, makeAST(EInteger(-1))]
                    ));
                    
                    
                default:
                    node;
            }
        });
    }
    
    /**
     * Transform struct field assignments within a method body to return updated struct
     * 
     * WHY: Methods like BalancedTree.set() modify fields but need to return the updated struct
     * WHAT: Detects field assignments on "struct" parameter and adds struct return
     * HOW: Wraps body in block that returns updated struct
     */
    static function transformStructFieldAssignments(body: ElixirAST, args: Array<EPattern>): ElixirAST {
        // Check if first argument is "struct" (instance method pattern)
        var hasStructParam = args.length > 0 && switch(args[0]) {
            case PVar("struct"): true;
            default: false;
        };
        
        if (!hasStructParam) return body;
        
        #if debug_ast_transformer
        trace('[XRay transformStructFieldAssignments] Analyzing body for field assignments');
        #end
        
        // Look for field assignments in the body
        var hasFieldAssignment = false;
        var fieldUpdates: Map<String, ElixirAST> = new Map();
        
        // Analyze the body for field assignments
        function analyzeNode(node: ElixirAST): Void {
            switch(node.def) {
                case EMatch(PVar("root"), value):
                    // Found field assignment: root = ...
                    #if debug_ast_transformer
                    trace('[XRay transformStructFieldAssignments] Found root assignment');
                    #end
                    hasFieldAssignment = true;
                    fieldUpdates.set("root", value);
                case EBlock(statements):
                    for (stmt in statements) {
                        analyzeNode(stmt);
                    }
                default:
                    // Continue analyzing
            }
        }
        
        analyzeNode(body);
        
        #if debug_ast_transformer
        trace('[XRay transformStructFieldAssignments] hasFieldAssignment: $hasFieldAssignment, has root: ${fieldUpdates.exists("root")}');
        #end
        
        if (hasFieldAssignment && fieldUpdates.exists("root")) {
            // Transform the body to return updated struct
            var statements = [];
            
            // Add the original body logic
            switch(body.def) {
                case EBlock(stmts):
                    statements = stmts.copy();
                default:
                    statements = [body];
            }
            
            // Add struct update at the end
            // %{struct | root: root}
            var structUpdate = makeAST(EStructUpdate(
                makeAST(EVar("struct")),
                [{ key: "root", value: makeAST(EVar("root")) }]
            ));
            
            statements.push(structUpdate);
            
            return makeAST(EBlock(statements));
        }

        return body;
    }

    /**
     * Fluent API Optimization Pass
     *
     * WHY: Fluent API methods that return 'this' generate unnecessary intermediate assignments
     * in Elixir like `struct = %{struct | field: value}` followed by `struct`. This creates
     * "variable 'struct' is unused" warnings.
     *
     * WHAT: Detects and optimizes the pattern where a struct update is immediately returned.
     *
     * HOW: Transforms functions that have the pattern:
     * - Assignment: struct = %{struct | fields...}
     * - Return: struct
     * Into a single return of the struct update expression.
     */
    static function fluentApiOptimizationPass(ast: ElixirAST): ElixirAST {
        #if debug_fluent_api
        trace("[FluentApiOptimization] Starting optimization pass");
        #end

        return transformNode(ast, function(node) {
            switch(node.def) {
                case EDef(name, args, guards, body):
                    var optimizedBody = optimizeFluentBody(body);
                    if (optimizedBody != body) {
                        #if debug_fluent_api
                        trace('[FluentApiOptimization] Optimized function: $name');
                        #end
                        return makeAST(EDef(name, args, guards, optimizedBody));
                    }
                case EDefp(name, args, guards, body):
                    var optimizedBody = optimizeFluentBody(body);
                    if (optimizedBody != body) {
                        #if debug_fluent_api
                        trace('[FluentApiOptimization] Optimized private function: $name');
                        #end
                        return makeAST(EDefp(name, args, guards, optimizedBody));
                    }
                default:
            }
            return node;
        });
    }

    /**
     * Optimize the body of a fluent API method
     */
    static function optimizeFluentBody(body: ElixirAST): ElixirAST {
        if (body == null) return null;

        switch(body.def) {
            case EBlock(exprs) if (exprs.length == 2):
                // Check for pattern: [struct = %{struct | ...}, struct]
                var firstExpr = exprs[0];
                var secondExpr = exprs[1];

                // Check if first is assignment to 'struct'
                switch(firstExpr.def) {
                    case EMatch(PVar("struct"), updateExpr):
                        // Check if second is just returning 'struct'
                        switch(secondExpr.def) {
                            case EVar("struct"):
                                // Found the pattern! Return the update expression directly
                                #if debug_fluent_api
                                trace('[FluentApiOptimization] Found fluent pattern - optimizing');
                                #end
                                return updateExpr;
                            default:
                        }
                    default:
                }
            default:
        }

        // Pattern doesn't match, return as-is
        return body;
    }

    // ========================================================================
    // Helper Functions
    // ========================================================================
    
    /**
     * Extract parent module name from AST metadata
     * This should be set during the AST building phase when we know inheritance relationships
     * For now, we return null since metadata doesn't have a parentModule field yet
     * In the future, we should add this field to ElixirMetadata typedef
     */
    static function extractParentModule(node: ElixirAST): Null<String> {
        // TODO: Add parentModule field to ElixirMetadata typedef
        // For now, we can try to extract from sourceExpr if available
        if (node.metadata != null && node.metadata.sourceExpr != null) {
            // Could analyze the TypedExpr to find parent class info
            // For now, return null and use the fallback mechanism
        }
        return null;
    }
    
    /**
     * Array length field to function transformation pass
     * 
     * WHY: Elixir doesn't support .length property access on arrays/lists
     * WHAT: Transforms array.length field access to length(array) function calls
     * HOW: Detects EField(target, "length") and converts to ECall(null, "length", [target])
     * 
     * Example transformation:
     *   array.length -> length(array)
     *   list.length -> length(list) 
     */
    static function arrayLengthFieldToFunctionPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay ArrayLengthField] Starting array length field to function transformation');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case EField(target, "length"):
                // This is an array.length field access that needs to become length(array)
                #if debug_ast_transformer
                var targetStr = ElixirASTPrinter.printAST(target);
                trace('[XRay ArrayLengthField] Transforming ${targetStr}.length to length($targetStr)');
                #end
                {
                    def: ECall(null, "length", [
                        transformAST(target, arrayLengthFieldToFunctionPass)
                    ]),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            case ECall(expr, funcName, args):
                // Regular call, transform recursively
                {
                    def: ECall(
                        expr != null ? transformAST(expr, arrayLengthFieldToFunctionPass) : null,
                        funcName,
                        [for (arg in args) transformAST(arg, arrayLengthFieldToFunctionPass)]
                    ),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            default:
                // Recursively transform children
                transformAST(ast, arrayLengthFieldToFunctionPass);
        };
    }
    
    /**
     * Convert camelCase to snake_case for Elixir method names
     */
    static function toSnakeCase(name: String): String {
        var result = "";
        for (i in 0...name.length) {
            var char = name.charAt(i);
            if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
                result += "_";
            }
            result += char.toLowerCase();
        }
        return result;
    }
    
    /**
     * Recursively transform AST nodes with infinite recursion protection
     *
     * ## CRITICAL FIX: Infinite Recursion in Transformer (January 2025)
     *
     * ### The Problem
     * The transformer was entering infinite recursion, causing compilation hangs
     * lasting over 2 minutes. This occurred when certain nodes (especially atoms)
     * were being endlessly re-transformed.
     *
     * ### Root Cause
     * The original implementation always created new AST nodes, even when no
     * transformation occurred. This caused:
     * 1. Transformer applies to a node, returns a "new" node (same content, new object)
     * 2. Parent sees the node changed (different object reference)
     * 3. Parent re-transforms the "changed" node
     * 4. Infinite loop as nodes appear to always change
     *
     * ### The Solution: Structural Sharing Pattern
     * Only create new AST nodes when the content actually changes:
     * - If no children change, return the SAME object (not a copy)
     * - If any child changes, create a new parent with updated children
     * - Use physical equality (same object) to detect changes
     *
     * ### Special Handling for Terminal Nodes
     * Some nodes (like atoms) are terminal and should never recurse:
     * - EAtom: Always terminal, no children to transform
     * - EInteger, EFloat, EString: Terminal literal values
     * - These return immediately without recursion
     *
     * ### Implementation Details
     * - transformArray(): Helper that only copies arrays when elements change
     * - Physical equality check: `transformed != original` (object identity)
     * - Terminal node early returns prevent unnecessary recursion
     *
     * ### Impact
     * - Compilation time: 2+ minutes ‚Üí ~10 seconds
     * - Memory usage: Significantly reduced due to structural sharing
     * - Correctness: Transformations still apply correctly
     *
     * @see https://github.com/reflaxe/reflaxe.haxe.elixir/commits/transformer-recursion-fix
     */
    // Track visited nodes to detect cycles (for debugging)
    private static var visitedNodes: Map<String, Int> = new Map();
    private static var nodeVisitCounter: Int = 0;
    private static var maxNodeVisits: Int = 10000;

    // Helper to transform an array only if elements change
    private static function transformArray(arr: Array<ElixirAST>, transformer: (ElixirAST) -> ElixirAST): {array: Array<ElixirAST>, changed: Bool} {
        var changed = false;
        var result = arr;

        for (i in 0...arr.length) {
            var original = arr[i];
            var transformed = transformNode(original, transformer);
            if (transformed != original) {
                if (!changed) {
                    // First change - copy the array
                    result = arr.copy();
                    changed = true;
                }
                result[i] = transformed;
            }
        }

        return {array: result, changed: changed};
    }

    /**
     * transformNode
     *
     * WHAT
     * - Recursively traverses and rebuilds the Elixir AST while applying a node-local transformer.
     * - Includes full recursion into EDo (do/end) bodies to ensure inner statements participate in passes.
     *
     * WHY
     * - Several shape-based passes (e.g., filter query consolidation) must operate on statements
     *   placed inside if/with/do blocks. Missing recursion into EDo caused late guards to miss
     *   legitimate targets, producing undefined variable issues.
     *
     * HOW
     * - Mirrors EBlock recursion for EDo: transforms each expression, then rebuilds the enclosing node.
     * - All other nodes retain prior recursion semantics; ERaw remains non-transformable by design.
     *
     * EXAMPLES
     * Before (no EDo recursion):
     *   if cond do
     *     Enum.filter(list, fn t -> uses_query end)
     *   end
     *   # Passes did not see the inner filter call.
     *
     * After (with EDo recursion):
     *   Same input; passes visit and may promote/bind/inline query deterministically.
     */
    public static function transformNode(ast: ElixirAST, transformer: (ElixirAST) -> ElixirAST): ElixirAST {
        // Handle null AST nodes or nodes with null def
        if (ast == null || ast.def == null) {
            return ast;  // Return as-is if null
        }

        #if debug_transformer_hang
        nodeVisitCounter++;

        // Create a unique identifier for this node
        var nodeId = Type.enumConstructor(ast.def) + "_" + Std.string(ast.pos);

        // Track visit frequency
        var visits = visitedNodes.get(nodeId);
        if (visits == null) visits = 0;
        visits++;
        visitedNodes.set(nodeId, visits);

        // Log breadcrumbs
        if (nodeVisitCounter % 1000 == 0) {
            trace('[TRANSFORMER BREADCRUMB] Node ${nodeVisitCounter}: ${Type.enumConstructor(ast.def)}');
        }

        // Detect excessive visits to same node (cycle)
        if (visits > 100) {
            trace('[CYCLE DETECTED] Node ${nodeId} visited ${visits} times!');
            trace('[CYCLE DETECTED] AST def: ${ast.def}');
            throw 'Infinite recursion detected in transformer: ${nodeId}';
        }

        // Overall safety limit
        if (nodeVisitCounter > maxNodeVisits) {
            trace('[TRANSFORMER HANG] Exceeded ${maxNodeVisits} node visits');
            trace('[TRANSFORMER HANG] Last node: ${Type.enumConstructor(ast.def)}');
            throw 'Transformer exceeded maximum node visit limit';
        }
        #end

        // First transform children
        var transformed = switch(ast.def) {
            case EModule(name, attributes, body):
                var bodyResult = transformArray(body, transformer);
                if (bodyResult.changed) {
                    makeASTWithMeta(
                        EModule(name, attributes, bodyResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;  // Return original if nothing changed
                }
                
            case EDef(name, args, guards, body):
                makeASTWithMeta(
                    EDef(name, args, 
                         guards != null ? transformNode(guards, transformer) : null,
                         transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case EDefp(name, args, guards, body):
                makeASTWithMeta(
                    EDefp(name, args,
                          guards != null ? transformNode(guards, transformer) : null,
                          transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            // Blocks
            case EBlock(expressions):
                var expResult = transformArray(expressions, transformer);
                if (expResult.changed) {
                    makeASTWithMeta(
                        EBlock(expResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;  // Return original if nothing changed
                }

            // Transform do-end blocks by visiting each expression
            case EDo(body):
                var doResult = transformArray(body, transformer);
                if (doResult.changed) {
                    makeASTWithMeta(
                        EDo(doResult.array),
                        ast.metadata,
                        ast.pos
                    );
                } else {
                    ast;
                }
                
            case EIf(condition, thenBranch, elseBranch):
                makeASTWithMeta(
                    EIf(transformNode(condition, transformer),
                        transformNode(thenBranch, transformer),
                        elseBranch != null ? transformNode(elseBranch, transformer) : null),
                    ast.metadata,
                    ast.pos
                );
                
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(transformNode(expr, transformer),
                          clauses.map(c -> {
                              pattern: c.pattern,
                              guard: c.guard != null ? transformNode(c.guard, transformer) : null,
                              body: transformNode(c.body, transformer)
                          })),
                    ast.metadata,
                    ast.pos
                );
            
            // Traverse anonymous functions and clause bodies
            case EFn(clauses):
                makeASTWithMeta(
                    EFn(clauses.map(cl -> {
                        args: cl.args,
                        guard: cl.guard != null ? transformNode(cl.guard, transformer) : null,
                        body: transformNode(cl.body, transformer)
                    })),
                    ast.metadata,
                    ast.pos
                );
                
            case EBinary(op, left, right):
                makeASTWithMeta(
                    EBinary(op,
                            transformNode(left, transformer),
                            transformNode(right, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case EUnary(op, expr):
                makeASTWithMeta(
                    EUnary(op, transformNode(expr, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            case ECall(target, funcName, args):
                makeASTWithMeta(
                    ECall(target != null ? transformNode(target, transformer) : null,
                          funcName,
                          args.map(a -> transformNode(a, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case EList(elements):
                makeASTWithMeta(
                    EList(elements.map(e -> transformNode(e, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case ETuple(elements):
                makeASTWithMeta(
                    ETuple(elements.map(e -> transformNode(e, transformer))),
                    ast.metadata,
                    ast.pos
                );
                
            case EMap(pairs):
                makeASTWithMeta(
                    EMap(pairs.map(p -> {
                        key: transformNode(p.key, transformer),
                        value: transformNode(p.value, transformer)
                    })),
                    ast.metadata,
                    ast.pos
                );

            case EMatch(pattern, expr):
                // CRITICAL FIX: Transform the RHS expression
                // WHY: EMatch bindings in HygieneTransforms mark LHS as declaration
                //      but RHS may reference variables that need renaming
                // WHAT: Recursively transform expr to rename any EVar nodes
                // HOW: Pattern stays unchanged (creates new binding), expr transforms
                makeASTWithMeta(
                    EMatch(pattern, transformNode(expr, transformer)),
                    ast.metadata,
                    ast.pos
                );

            case EFor(generators, filters, body, into, uniq):
                makeASTWithMeta(
                    EFor(generators.map(g -> {
                        pattern: g.pattern,
                        expr: transformNode(g.expr, transformer)
                    }),
                         filters.map(f -> transformNode(f, transformer)),
                         transformNode(body, transformer),
                         into != null ? transformNode(into, transformer) : null,
                         uniq),
                    ast.metadata,
                    ast.pos
                );
                
            // Raw Elixir code injection - NEVER transform
            case ERaw(code):
                // ERaw nodes are sacred - they contain direct Elixir code injection
                // from __elixir__() calls and must NEVER be transformed
                // Just return the node as-is, without calling the transformer
                return ast;
                
            case EDefmodule(name, body):
                // Transform the module body recursively
                makeASTWithMeta(
                    EDefmodule(name, transformNode(body, transformer)),
                    ast.metadata,
                    ast.pos
                );
                
            // Literals and simple nodes - no children to transform
            // These have no children, so just return them as-is for the transformer to process
            default:
                ast;
        };

        // Apply the transformation to this node
        var finalResult = transformer(transformed);

        // CRITICAL FIX: Prevent infinite recursion
        // Special handling for atoms which were causing infinite loops
        switch(finalResult.def) {
            case EAtom(_):
                // Atoms are terminal nodes and should never be recursively transformed
                // Just return them immediately to break any potential loops
                return finalResult;
            default:
                // For other nodes, check if the transformation actually changed anything
                // Use standard equality check
                if (finalResult == transformed) {
                    // If the same object was returned, no transformation occurred
                    return finalResult;
                }

                // Otherwise return the transformed result
                return finalResult;
        }
    }
    
    /**
     * Detect and optimize pipeline patterns in a block
     */
    static function detectAndOptimizePipeline(expressions: Array<ElixirAST>): Null<ElixirAST> {
        // Look for patterns like:
        // x = f(x, ...)
        // x = g(x, ...)
        // x = h(x, ...)
        // Also handles remote calls like:
        // x = Module.f(x, ...)
        // x = Module.g(x, ...)
        
        if (expressions.length < 2) return null;
        
        var pipelineOps = [];
        var baseVar: String = null;
        var lastExpr: ElixirAST = null;
        
        for (expr in expressions) {
            switch(expr.def) {
                case EMatch(PVar(name), call):
                    switch(call.def) {
                        case ECall(target, func, args):
                            if (args.length > 0) {
                                switch(args[0].def) {
                                    case EVar(argName) if (argName == name):
                                        // Found a pipeline candidate
                                        if (baseVar == null) {
                                            baseVar = name;
                                        }
                                        if (baseVar == name) {
                                            pipelineOps.push({
                                                func: func,
                                                args: args.slice(1),
                                                target: target
                                            });
                                            lastExpr = expr;
                                            continue;
                                        }
                                    default:
                                }
                            }
                        case ERemoteCall(module, func, args):
                            // Handle remote calls like EctoQuery_Impl_.where(query, ...)
                            if (args.length > 0) {
                                switch(args[0].def) {
                                    case EVar(argName) if (argName == name):
                                        // Found a pipeline candidate for remote call
                                        if (baseVar == null) {
                                            baseVar = name;
                                        }
                                        if (baseVar == name) {
                                            pipelineOps.push({
                                                func: func,
                                                args: args.slice(1),
                                                target: module  // Use module as target
                                            });
                                            lastExpr = expr;
                                            continue;
                                        }
                                    default:
                                }
                            }
                        default:
                    }
                default:
            }
            
            // Pattern broken, check if we have enough for a pipeline
            if (pipelineOps.length >= 2) {
                break;
            } else {
                // Reset and continue looking
                pipelineOps = [];
                baseVar = null;
            }
        }
        
        // Create pipeline if we found a pattern
        if (pipelineOps.length >= 2) {
            var pipeline = makeAST(EVar(baseVar));
            
            for (op in pipelineOps) {
                if (op.target != null) {
                    pipeline = makeAST(EPipe(
                        pipeline,
                        makeAST(ERemoteCall(op.target, op.func, op.args))
                    ));
                } else {
                    pipeline = makeAST(EPipe(
                        pipeline,
                        makeAST(ECall(null, op.func, op.args))
                    ));
                }
            }
            
            // Create final assignment
            return makeAST(EMatch(PVar(baseVar), pipeline));
        }
        
        return null;
    }
    
    /**
     * Conditional reassignment transformation pass
     * 
     * WHY: Elixir warns when variables are reassigned (shadowing)
     * WHAT: Transform conditional reassignments to functional style
     * HOW: Make if blocks return the new value instead of reassigning
     * 
     * Example transformation:
     * ```
     * if (condition) {
     *   query = query.where(...);
     * }
     * ```
     * Becomes:
     * ```
     * query = if (condition) do
     *   query.where(...)
     * else
     *   query
     * end
     * ```
     */
    
    static function conditionalReassignmentPass(ast: ElixirAST): ElixirAST {
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EBlock(expressions):
                    // Transform each if statement in the block
                    var transformed = [];
                    for (expr in expressions) {
                        if (expr == null || expr.def == null) {
                            continue;
                        }
                        switch(expr.def) {
                            case EIf(cond, thenBranch, null):  // If without else
                                // Check if the then branch is a single reassignment
                                switch(thenBranch.def) {
                                    case EMatch(PVar(varName), value):
                                        // Check if this is reassigning to an existing variable
                                        // by looking if the value references the same variable
                                        if (referencesVariable(value, varName)) {
                                            // Transform to functional style: var = if cond do new_value else var end
                                            var newIf = makeAST(EIf(
                                                cond,
                                                value,  // Return the new value
                                                makeAST(EVar(varName))  // Return original variable
                                            ));
                                            transformed.push(makeAST(EMatch(PVar(varName), newIf)));
                                        } else {
                                            transformed.push(expr);
                                        }
                                    default:
                                        transformed.push(expr);
                                }
                            default:
                                transformed.push(expr);
                        }
                    }
                    return makeASTWithMeta(EBlock(transformed), node.metadata, node.pos);
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Check if an AST node references a specific variable
     */
    static function referencesVariable(ast: ElixirAST, varName: String): Bool {
        var found = false;
        
        function visitor(node: ElixirAST): Void {
            if (found) return;
            
            switch(node.def) {
                case EVar(name) if (name == varName):
                    found = true;
                case ERemoteCall(_, _, args):
                    // Check if first argument is the variable
                    if (args.length > 0) {
                        switch(args[0].def) {
                            case EVar(name) if (name == varName):
                                found = true;
                            default:
                                for (arg in args) {
                                    visitor(arg);
                                }
                        }
                    }
                default:
                    // Recursively visit child nodes
                    transformAST(node, function(n) { 
                        visitor(n); 
                        return n; 
                    });
            }
        }
        
        visitor(ast);
        return found;
    }
    
    /**
     * Remove redundant nil initialization pass
     * 
     * WHY: Abstract type constructors generate redundant `var = nil` followed by `var = value`
     * WHAT: Removes nil initialization when variable is immediately reassigned  
     * HOW: Detects pattern of consecutive assignments to same variable and removes first
     * 
     * Pattern detected:
     * ```elixir
     * this1 = nil
     * this1 = %{data: data, params: params}
     * ```
     * 
     * Transformed to:
     * ```elixir
     * this1 = %{data: data, params: params}
     * ```
     */
    static function removeRedundantNilInitPass(ast: ElixirAST): ElixirAST {
        // Helper function to check if an AST node represents nil
        // In Elixir, nil is represented as the atom :nil
        inline function isNilValue(ast: ElixirAST): Bool {
            if (ast == null) return false;
            return switch(ast.def) {
                case EAtom(a): a == "nil";
                case ENil: true; // Legacy support, though this shouldn't occur
                default: false;
            };
        }

        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case EDef(name, args, guards, body) if (name == "_new"):
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing _new function');
                    #end
                    // Special handling for abstract constructor _new functions
                    var transformedBody = switch(body.def) {
                        case EBlock(expressions) if (expressions.length >= 2):
                            // Look for pattern: this1 = nil; this1 = <value>; this1
                            var filteredExprs = [];
                            var i = 0;
                            while (i < expressions.length) {
                                var expr = expressions[i];
                                var shouldSkip = false;
                                
                                // Check for this1 = nil
                                switch(expr.def) {
                                    case EMatch(PVar("this1"), nilValue):
                                        if (isNilValue(nilValue)) {
                                            // Check next expression
                                            if (i + 1 < expressions.length) {
                                                switch(expressions[i + 1].def) {
                                                    case EMatch(PVar("this1"), value):
                                                        if (isNilValue(value)) {
                                                            // Don't skip if reassigning to nil
                                                        } else {
                                                            // Skip the nil assignment
                                                                    #if debug_ast_transformer
                                                                    trace('[XRay RemoveRedundantNilInit] Removing this1 = nil in _new function');
                                                                    #end
                                                                    shouldSkip = true;
                                                    }
                                                default:
                                            }
                                        }
                                    }
                                    default:
                                }
                                
                                if (!shouldSkip) {
                                    filteredExprs.push(expr);
                                }
                                i++;
                            }
                            
                            if (filteredExprs.length != expressions.length) {
                                makeASTWithMeta(EBlock(filteredExprs), body.metadata, body.pos);
                            } else {
                                body;
                            }
                        default:
                            body;
                    };
                    
                    return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EBlock(expressions):
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EBlock with ${expressions.length} expressions');
                    #end
                    var filtered = [];
                    var nilAssignments = new Map<String, Int>(); // Track nil assignments by variable name
                    var i = 0;
                    
                    // First pass: identify all nil assignments
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        // Null safety check
                        if (expr == null || expr.def == null) {
                            i++;
                            continue;
                        }
                        switch(expr.def) {
                            case EMatch(PVar(varName), nilValue):
                                if (isNilValue(nilValue)) {
                                    #if debug_ast_transformer
                                    trace('[XRay RemoveRedundantNilInit] Found nil assignment for var: $varName at index $i');
                                    #end
                                    nilAssignments.set(varName, i);
                                }
                            default:
                        }
                        i++;
                    }
                    
                    // Second pass: filter out redundant nil assignments and useless variable references
                    i = 0;
                    var varsToClean = new Map<String, Bool>(); // Track variables that need their standalone refs removed
                    while (i < expressions.length) {
                        var expr = expressions[i];
                        // Null safety check
                        if (expr == null || expr.def == null) {
                            i++;
                            continue;
                        }
                        
                        // Check if this is a useless standalone variable reference
                        switch(expr.def) {
                            case EVar(v) if (varsToClean.exists(v)):
                                // This is a standalone variable reference after an assignment, skip it
                                #if debug_ast_transformer
                                trace('[XRay RemoveRedundantNilInit] Removing standalone variable reference: $v');
                                #end
                                varsToClean.remove(v);
                                i++;
                                continue;
                            default:
                        }
                        
                        var shouldSkip = false;

                        // Check if this is a nil assignment that should be removed
                        switch(expr.def) {
                            case EMatch(PVar(varName), nilValue):
                                if (isNilValue(nilValue)) {
                                    // Special handling for 'this1' and similar abstract constructor variables
                                    // These are ALWAYS immediately reassigned in abstract constructors
                                    if (varName == "this1" || varName == "this" || varName.startsWith("this")) {
                                        #if debug_ast_transformer
                                        trace('[XRay RemoveRedundantNilInit] Found "this1" nil assignment at index $i');
                                        #end
                                        // Check immediate next expression for reassignment
                                        if (i + 1 < expressions.length) {
                                            var nextExpr = expressions[i + 1];
                                            if (nextExpr != null && nextExpr.def != null) {
                                                #if debug_ast_transformer
                                                trace('[XRay RemoveRedundantNilInit] Next expr at ${i+1}: ${nextExpr.def}');
                                                #end
                                                switch(nextExpr.def) {
                                                case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
                                                    if (isNilValue(value)) {
                                                        // Don't skip if it's another nil
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] Next assignment is also nil, not skipping');
                                                        #end
                                                    } else {
                                                        // Non-nil reassignment - skip the initial nil AND check if there's a useless variable reference after
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] REMOVING redundant nil init for abstract constructor var: $varName');
                                                        #end
                                                        shouldSkip = true;
                                                        
                                                        // CRITICAL FIX: Also check if next+1 is just a variable reference
                                                        // Pattern: this1 = nil; this1 = value; this1
                                                        if (i + 2 < expressions.length) {
                                                            var afterNext = expressions[i + 2];
                                                            if (afterNext != null && afterNext.def != null) {
                                                                switch(afterNext.def) {
                                                                    case EVar(v) if (v == varName):
                                                                        // This is the standalone variable reference that causes the warning
                                                                        #if debug_ast_transformer
                                                                        trace('[XRay RemoveRedundantNilInit] Found standalone variable reference after assignment, marking for removal');
                                                                        #end
                                                                        // Mark this variable for cleanup
                                                                        varsToClean.set(varName, true);
                                                                    default:
                                                                }
                                                            }
                                                        }
                                                    }
                                                    default:
                                                        #if debug_ast_transformer
                                                        trace('[XRay RemoveRedundantNilInit] Next expr is not a match for $varName');
                                                        #end
                                                }
                                            }
                                        }

                                        // If not skipped yet, check if this variable is assigned again later
                                        if (!shouldSkip) {
                                            var j = i + 1;
                                            while (j < expressions.length) {
                                                var checkExpr = expressions[j];
                                                if (checkExpr == null || checkExpr.def == null) {
                                                    j++;
                                                    continue;
                                                }
                                                switch(checkExpr.def) {
                                                    case EMatch(PVar(nextVarName), value) if (nextVarName == varName):
                                                        // Found reassignment - check if the value is not nil
                                                        if (isNilValue(value)) {
                                                            // Another nil assignment, keep looking
                                                        } else {
                                                            // Non-nil reassignment found - skip the initial nil
                                                                #if debug_ast_transformer
                                                                trace('[XRay RemoveRedundantNilInit] Removing redundant nil init for: $varName (reassigned at index $j)');
                                                                #end
                                                                shouldSkip = true;
                                                                break;
                                                        }
                                                    default:
                                                }
                                                j++;
                                            }
                                        }
                                    }
                                }
                            default:
                                // Not a match expression
                        }

                        if (!shouldSkip) {
                            // Recursively process the expression to handle nested structures
                            var processed = removeRedundantNilInitPass(expr);
                            filtered.push(processed);
                        } else {
                            #if debug_ast_transformer
                            trace('[XRay RemoveRedundantNilInit] Skipping redundant nil init at index $i');
                            #end
                        }
                        i++;
                    }

                    // Only create new block if we removed something
                    if (filtered.length != expressions.length) {
                        #if debug_ast_transformer
                        trace('[XRay RemoveRedundantNilInit] Removed ${expressions.length - filtered.length} redundant nil assignments from block');
                        #end
                        return makeASTWithMeta(EBlock(filtered), node.metadata, node.pos);
                    } else {
                        return node;
                    }
                    
                case EFn(clauses):
                    // Also handle anonymous function bodies
                    var transformedClauses = [for (clause in clauses) {
                        args: clause.args,
                        guard: clause.guard,
                        body: removeRedundantNilInitPass(clause.body)
                    }];
                    return makeASTWithMeta(EFn(transformedClauses), node.metadata, node.pos);
                    
                case EDef(name, args, guards, body):
                    // Handle public function definitions
                    var transformedBody = removeRedundantNilInitPass(body);
                    return makeASTWithMeta(EDef(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EDefp(name, args, guards, body):
                    // Handle private function definitions
                    var transformedBody = removeRedundantNilInitPass(body);
                    return makeASTWithMeta(EDefp(name, args, guards, transformedBody), node.metadata, node.pos);
                    
                case EIf(cond, thenBranch, elseBranch):
                    // Recursively process if branches
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EIf - recursing into branches');
                    #end
                    var processedCond = removeRedundantNilInitPass(cond);
                    var processedThen = removeRedundantNilInitPass(thenBranch);
                    var processedElse = elseBranch != null ? removeRedundantNilInitPass(elseBranch) : null;
                    return makeASTWithMeta(EIf(processedCond, processedThen, processedElse), node.metadata, node.pos);

                case ECase(expr, clauses):
                    // Recursively process case expressions
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing ECase');
                    #end
                    var processedExpr = removeRedundantNilInitPass(expr);
                    var processedClauses = [for (clause in clauses) {
                        pattern: clause.pattern,
                        guard: clause.guard != null ? removeRedundantNilInitPass(clause.guard) : null,
                        body: removeRedundantNilInitPass(clause.body)
                    }];
                    return makeASTWithMeta(ECase(processedExpr, processedClauses), node.metadata, node.pos);

                case EFor(generators, filters, body, into, uniq):
                    // Recursively process for comprehensions
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EFor');
                    #end
                    var processedGenerators = [for (gen in generators) {
                        pattern: gen.pattern,
                        expr: removeRedundantNilInitPass(gen.expr)
                    }];
                    var processedFilters = [for (filter in filters) removeRedundantNilInitPass(filter)];
                    var processedBody = removeRedundantNilInitPass(body);
                    var processedInto = into != null ? removeRedundantNilInitPass(into) : null;
                    return makeASTWithMeta(EFor(processedGenerators, processedFilters, processedBody, processedInto, uniq), node.metadata, node.pos);

                case EParen(inner):
                    // Handle parenthesized expressions (often contains this1 = nil pattern)
                    #if debug_ast_transformer
                    trace('[XRay RemoveRedundantNilInit] Processing EParen');
                    #end

                    // Check if the inner expression is a sequence with redundant nil init
                    var transformedInner = switch(inner.def) {
                        case EBlock(expressions) if (expressions.length == 3):
                            // Pattern: (this1 = nil; this1 = value; this1)
                            var hasRedundantNil = false;

                            // Check for this1 = nil as first expression
                            switch(expressions[0].def) {
                                case EMatch(PVar("this1"), nilValue):
                                    if (isNilValue(nilValue)) {
                                        // Check second expression is also assignment to this1
                                        switch(expressions[1].def) {
                                            case EMatch(PVar("this1"), _):
                                                // Check third expression is just this1
                                                switch(expressions[2].def) {
                                                    case EVar("this1"):
                                                        hasRedundantNil = true;
                                                    default:
                                                }
                                            default:
                                        }
                                    }
                                default:
                            }

                            if (hasRedundantNil) {
                                #if debug_ast_transformer
                                trace('[XRay RemoveRedundantNilInit] Removing redundant nil from EParen block');
                                #end
                                // Remove the first expression (this1 = nil)
                                makeASTWithMeta(
                                    EBlock([expressions[1], expressions[2]]),
                                    inner.metadata,
                                    inner.pos
                                );
                            } else {
                                // Recursively process the block
                                removeRedundantNilInitPass(inner);
                            }
                        default:
                            // For other patterns, process recursively
                            removeRedundantNilInitPass(inner);
                    };

                    return makeASTWithMeta(EParen(transformedInner), node.metadata, node.pos);

                default:
                    return node;
            }
        });
    }
    
    /**
     * PREFIX UNUSED PARAMETERS PASS
     * 
     * WHY: Elixir convention requires unused function parameters to be prefixed with underscore
     *      to indicate they're intentionally unused. This prevents compiler warnings.
     * 
     * WHAT: Detects unused parameters in function definitions and prefixes them with underscore.
     *       Handles EDef, EDefp, EDefmacro, EDefmacrop, and EFn (anonymous functions).
     * 
     * HOW: 1. For each function definition, collect all parameter names
     *      2. Scan the function body to find which parameters are actually used
     *      3. Prefix unused parameters with underscore
     *      4. Update all references to maintain consistency
     * 
     * EDGE CASES:
     * - Parameters already prefixed with underscore are left as-is
     * - Parameters named "_" are not modified
     * - Nested functions are handled recursively
     */
    static function prefixUnusedParametersPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay PrefixUnusedParams] PASS START');
        #end
        
        return transformNode(ast, function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                // Handle regular function definitions
                case EDef(name, args, guards, body):
                    #if debug_ast_transformer
                    trace('[XRay PrefixUnusedParams] Found EDef: $name with ${args.length} args');
                    #end
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDef: $name');
                        #end
                        return makeASTWithMeta(EDef(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefp(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefp: $name');
                        #end
                        return makeASTWithMeta(EDefp(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefmacro(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefmacro: $name');
                        #end
                        return makeASTWithMeta(EDefmacro(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                case EDefmacrop(name, args, guards, body):
                    var result = handleFunctionParameters(args, guards, body);
                    if (result.hasChanges) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EDefmacrop: $name');
                        #end
                        return makeASTWithMeta(EDefmacrop(name, result.args, guards, result.body), node.metadata, node.pos);
                    }
                    return node;
                    
                // Handle anonymous functions
                case EFn(clauses):
                    var hasAnyChange = false;
                    var newClauses = [];
                    
                    for (clause in clauses) {
                        var result = handleFunctionParameters(clause.args, clause.guard, clause.body);
                        if (result.hasChanges) {
                            hasAnyChange = true;
                            newClauses.push({
                                args: result.args,
                                guard: clause.guard,
                                body: result.body
                            });
                        } else {
                            newClauses.push(clause);
                        }
                    }
                    
                    if (hasAnyChange) {
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Updated EFn with ${clauses.length} clauses');
                        #end
                        return makeASTWithMeta(EFn(newClauses), node.metadata, node.pos);
                    }
                    return node;
                    
                default:
                    return node;
            }
        });
    }
    
    /**
     * Handle parameter detection and renaming for a function
     * Returns updated args and body if changes were made
     */
    static function handleFunctionParameters(args: Array<EPattern>, guards: Null<ElixirAST>, body: ElixirAST): {args: Array<EPattern>, body: ElixirAST, hasChanges: Bool} {
        // Extract parameter names from patterns
        var paramNames: Map<String, Bool> = new Map();
        var paramRenames: Map<String, String> = new Map();
        
        function extractParamNames(pattern: EPattern) {
            switch(pattern) {
                case PVar(name):
                    if (!name.startsWith("_")) { // Don't track already underscored params
                        paramNames.set(name, false); // false = not yet seen as used
                    }
                case PTuple(patterns):
                    for (p in patterns) extractParamNames(p);
                case PList(patterns):
                    for (p in patterns) extractParamNames(p);
                case PMap(pairs):
                    for (pair in pairs) extractParamNames(pair.value);
                case PCons(head, tail):
                    extractParamNames(head);
                    extractParamNames(tail);
                case PPin(pattern):
                    extractParamNames(pattern);
                default:
                    // Other patterns don't introduce variables
            }
        }
        
        for (arg in args) {
            extractParamNames(arg);
        }
        
        #if debug_ast_transformer
        trace('[XRay PrefixUnusedParams] Found parameters: ' + [for (name => _ in paramNames) name].join(", "));
        #end
        
        // If no parameters to check, return early
        if (Lambda.count(paramNames) == 0) {
            return {args: args, body: body, hasChanges: false};
        }
        
        // Check which parameters are used in the body (and guards if present)
        function markUsedVars(ast: ElixirAST) {
            switch(ast.def) {
                case EVar(name):
                    if (paramNames.exists(name)) {
                        paramNames.set(name, true); // Mark as used
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Found usage of param: $name');
                        #end
                    }
                case EField(target, _):
                    // Check if the target is a parameter being accessed
                    switch(target.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found field access on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(target); // Continue checking nested expressions
                    }
                case EAccess(target, key):
                    // Check if the target is a parameter being accessed
                    switch(target.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found bracket access on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(target); // Continue checking nested expressions
                    }
                    markUsedVars(key); // Also check the key expression
                case EStructUpdate(struct, fields):
                    // Check if struct being updated is a parameter
                    switch(struct.def) {
                        case EVar(name):
                            if (paramNames.exists(name)) {
                                paramNames.set(name, true); // Mark as used
                                #if debug_ast_transformer
                                trace('[XRay PrefixUnusedParams] Found struct update on param: $name');
                                #end
                            }
                        default:
                            markUsedVars(struct); // Continue checking nested expressions
                    }
                    // Also check the field values
                    for (field in fields) {
                        markUsedVars(field.value);
                    }
                case ERaw(code):
                    // Check if parameter names appear in raw Elixir code
                    // This handles __elixir__() injection where parameters are referenced
                    for (name => _ in paramNames) {
                        // Check if the parameter name appears as a word boundary in the raw code
                        // This handles cases like "Ecto.Changeset.change(data, params)"
                        var pattern = '\\b${name}\\b';
                        if (new EReg(pattern, "").match(code)) {
                            paramNames.set(name, true); // Mark as used
                            #if debug_ast_transformer
                            trace('[XRay PrefixUnusedParams] Found param usage in ERaw: $name in code: ${code.substring(0, 100)}...');
                            #end
                        }
                    }
                case EKeywordList(pairs):
                    // Check values in keyword list for parameter usage
                    for (pair in pairs) {
                        markUsedVars(pair.value);
                        #if debug_ast_transformer
                        trace('[XRay PrefixUnusedParams] Checking keyword list value for parameter usage');
                        #end
                    }
                default:
                    iterateAST(ast, markUsedVars);
            }
        }
        
        // Check guards for parameter usage
        if (guards != null) {
            markUsedVars(guards);
        }
        
        // Check body for parameter usage
        markUsedVars(body);
        
        // M0 STABILIZATION: Disable underscore prefixing temporarily
        var hasChanges = false;
        /* Disabled to prevent variable mismatches
        for (name => used in paramNames) {
            if (!used && !name.startsWith("_")) {
                var newName = "_" + name;
                paramRenames.set(name, newName);
                hasChanges = true;
                #if debug_ast_transformer
                trace('[XRay PrefixUnusedParams] Will rename unused param: $name -> $newName');
                #end
            }
        }
        */
        
        // If no changes needed, return original
        if (!hasChanges) {
            return {args: args, body: body, hasChanges: false};
        }
        
        // Apply renames to argument patterns
        function renameInPattern(pattern: EPattern): EPattern {
            switch(pattern) {
                case PVar(name):
                    if (paramRenames.exists(name)) {
                        return PVar(paramRenames.get(name));
                    }
                    return pattern;
                case PTuple(patterns):
                    return PTuple(patterns.map(renameInPattern));
                case PList(patterns):
                    return PList(patterns.map(renameInPattern));
                case PMap(pairs):
                    return PMap([for (pair in pairs) {key: pair.key, value: renameInPattern(pair.value)}]);
                case PCons(head, tail):
                    return PCons(renameInPattern(head), renameInPattern(tail));
                case PPin(p):
                    return PPin(renameInPattern(p));
                default:
                    return pattern;
            }
        }
        
        var newArgs = args.map(renameInPattern);
        
        // Apply renames to the body as well to handle cases where usage detection
        // might be incomplete (e.g., field access patterns that weren't detected)
        function renameInAST(ast: ElixirAST): ElixirAST {
            switch(ast.def) {
                case EVar(name):
                    if (paramRenames.exists(name)) {
                        return {def: EVar(paramRenames.get(name)), metadata: ast.metadata};
                    }
                    return ast;
                default:
                    return transformAST(ast, renameInAST);
            }
        }
        
        var newBody = renameInAST(body);
        
        return {args: newArgs, body: newBody, hasChanges: true};
    }
    
    /**
     * Generate unique identifier for generated code
     */
    static var uniqueCounter = 0;
    static function generateUniqueId(): String {
        return Std.string(uniqueCounter++);
    }
    
    /**
     * Helper function to iterate over AST nodes without transformation
     */
    static function iterateAST(node: ElixirAST, visitor: ElixirAST -> Void): Void {
        // Check for null node or def before processing
        if (node == null || node.def == null) {
            return;
        }

        switch(node.def) {
            case EBlock(expressions):
                for (expr in expressions) if (expr != null) visitor(expr);
            case EModule(name, attributes, body):
                for (b in body) if (b != null) visitor(b);
            case EDefmodule(name, doBlock):
                if (doBlock != null) visitor(doBlock);
            case EDef(name, args, guards, body):
                if (body != null) visitor(body);
            case EDefp(name, args, guards, body):
                if (body != null) visitor(body);
            case EIf(condition, thenBranch, elseBranch):
                if (condition != null) visitor(condition);
                if (thenBranch != null) visitor(thenBranch);
                if (elseBranch != null) visitor(elseBranch);
            case ECase(expr, clauses):
                if (expr != null) visitor(expr);
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EMatch(pattern, expr):
                if (expr != null) visitor(expr);
            case EBinary(op, left, right):
                if (left != null) visitor(left);
                if (right != null) visitor(right);
            case EUnary(op, expr):
                if (expr != null) visitor(expr);
            case ECall(target, funcName, args):
                if (target != null) visitor(target);
                for (arg in args) if (arg != null) visitor(arg);
            case EMacroCall(macroName, args, doBlock):
                for (arg in args) if (arg != null) visitor(arg);
                if (doBlock != null) visitor(doBlock);
            case ETuple(elements):
                for (elem in elements) if (elem != null) visitor(elem);
            case EList(elements):
                for (elem in elements) if (elem != null) visitor(elem);
            case EMap(pairs):
                for (pair in pairs) {
                    if (pair != null) {
                        if (pair.key != null) visitor(pair.key);
                        if (pair.value != null) visitor(pair.value);
                    }
                }
            case EStruct(name, fields):
                for (field in fields) if (field != null && field.value != null) visitor(field.value);
            case EFor(generators, filters, body, into, uniq):
                for (gen in generators) {
                    if (gen != null && gen.expr != null) visitor(gen.expr);
                }
                for (filter in filters) if (filter != null) visitor(filter);
                if (body != null) visitor(body);
                if (into != null) visitor(into);
            case EFn(clauses):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EReceive(clauses, after):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.guard != null) visitor(clause.guard);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
                if (after != null) {
                    if (after.timeout != null) visitor(after.timeout);
                    if (after.body != null) visitor(after.body);
                }
            case ERemoteCall(module, funcName, args):
                if (module != null) visitor(module);
                for (arg in args) if (arg != null) visitor(arg);
            case EParen(expr):
                if (expr != null) visitor(expr);
            case EDo(body):
                for (stmt in body) if (stmt != null) visitor(stmt);
            case ETry(body, rescue, catchClauses, afterBlock, elseBlock):
                if (body != null) visitor(body);
                if (rescue != null) {
                    for (clause in rescue) {
                        // ERescueClause structure would need checking
                        if (clause != null && clause.body != null) visitor(clause.body);
                    }
                }
                if (catchClauses != null) {
                    for (clause in catchClauses) {
                        if (clause != null && clause.body != null) visitor(clause.body);
                    }
                }
                if (afterBlock != null) visitor(afterBlock);
                if (elseBlock != null) visitor(elseBlock);
            case EWith(clauses, doBlock, elseBlock):
                for (clause in clauses) {
                    // Pattern is not an ElixirAST, only visit the expression
                    if (clause != null && clause.expr != null) visitor(clause.expr);
                }
                if (doBlock != null) visitor(doBlock);
                if (elseBlock != null) visitor(elseBlock);
            case ECond(clauses):
                for (clause in clauses) {
                    if (clause != null) {
                        if (clause.condition != null) visitor(clause.condition);
                        if (clause.body != null) visitor(clause.body);
                    }
                }
            case EField(object, field):
                if (object != null) visitor(object);
            case EModuleAttribute(name, value):
                if (value != null) visitor(value);
            case EKeywordList(pairs):
                // Visit values in keyword list
                for (pair in pairs) {
                    if (pair != null && pair.value != null) visitor(pair.value);
                }
            case _:
                // Leaf nodes - nothing to iterate
        }
    }
    
    /**
     * Helper function to transform AST nodes recursively
     */
    public static function transformAST(node: ElixirAST, transformer: ElixirAST -> ElixirAST): ElixirAST {
        if (node == null || node.def == null) {
            return null;
        }
        var transformed = switch(node.def) {
            case EBlock(expressions):
                makeASTWithMeta(EBlock(expressions.map(transformer)), node.metadata, node.pos);
            case EModule(name, attributes, body):
                makeASTWithMeta(EModule(name, attributes, body.map(transformer)), node.metadata, node.pos);
            case EDefmodule(name, doBlock):
                makeASTWithMeta(EDefmodule(name, transformer(doBlock)), node.metadata, node.pos);
            case EDef(name, args, guards, body):
                makeASTWithMeta(EDef(name, args, guards, transformer(body)), node.metadata, node.pos);
            case EDefp(name, args, guards, body):
                makeASTWithMeta(EDefp(name, args, guards, transformer(body)), node.metadata, node.pos);
            case EIf(condition, thenBranch, elseBranch):
                makeASTWithMeta(
                    EIf(transformer(condition), transformer(thenBranch),
                        elseBranch != null ? transformer(elseBranch) : null),
                    node.metadata, node.pos
                );
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(transformer(expr),
                          clauses.map(c -> {
                              pattern: c.pattern,
                              guard: c.guard != null ? transformer(c.guard) : null,
                              body: transformer(c.body)
                          })),
                    node.metadata, node.pos
                );
            case EMatch(pattern, expr):
                makeASTWithMeta(EMatch(pattern, transformer(expr)), node.metadata, node.pos);
            case EBinary(op, left, right):
                makeASTWithMeta(EBinary(op, transformer(left), transformer(right)), node.metadata, node.pos);
            case EUnary(op, expr):
                makeASTWithMeta(EUnary(op, transformer(expr)), node.metadata, node.pos);
            case ECall(target, funcName, args):
                makeASTWithMeta(ECall(target != null ? transformer(target) : null, funcName, args.map(transformer)), node.metadata, node.pos);
            case EMacroCall(macroName, args, doBlock):
                makeASTWithMeta(EMacroCall(macroName, args.map(transformer), transformer(doBlock)), node.metadata, node.pos);
            case ETuple(elements):
                makeASTWithMeta(ETuple(elements.map(transformer)), node.metadata, node.pos);
            case EList(elements):
                #if (debug_otp_child_spec && debug_otp_child_spec_verbose)
                if (elements.length > 0) {
                    trace('[XRay OTPChildSpec] Processing EList with ${elements.length} elements');
                    for (i in 0...elements.length) {
                        var elem = elements[i];
                        if (elem.metadata != null && elem.metadata.requiresIdiomaticTransform == true) {
                            trace('[XRay OTPChildSpec] Element $i has requiresIdiomaticTransform flag!');
                        }
                    }
                }
                #end
                makeASTWithMeta(EList(elements.map(transformer)), node.metadata, node.pos);
            case EMap(pairs):
                makeASTWithMeta(
                    EMap(pairs.map(p -> {key: transformer(p.key), value: transformer(p.value)})),
                    node.metadata, node.pos
                );
            case EKeywordList(pairs):
                makeASTWithMeta(
                    EKeywordList(pairs.map(p -> {key: p.key, value: transformer(p.value)})),
                    node.metadata, node.pos
                );
            case EStruct(name, fields):
                makeASTWithMeta(
                    EStruct(name, fields.map(f -> {key: f.key, value: transformer(f.value)})),
                    node.metadata, node.pos
                );
            case EFor(generators, filters, body, into, uniq):
                makeASTWithMeta(
                    EFor(generators.map(g -> {pattern: g.pattern, expr: transformer(g.expr)}),
                         filters.map(transformer),
                         transformer(body),
                         into != null ? transformer(into) : null,
                         uniq),
                    node.metadata, node.pos
                );
            case EFn(clauses):
                makeASTWithMeta(
                    EFn(clauses.map(c -> {
                        args: c.args,
                        guard: c.guard != null ? transformer(c.guard) : null,
                        body: transformer(c.body)
                    })),
                    node.metadata, node.pos
                );
            case EReceive(clauses, after):
                makeASTWithMeta(
                    EReceive(clauses.map(c -> {
                                 pattern: c.pattern,
                                 guard: c.guard != null ? transformer(c.guard) : null,
                                 body: transformer(c.body)
                             }),
                             after != null ? {timeout: transformer(after.timeout), body: transformer(after.body)} : null),
                    node.metadata, node.pos
                );
            case EModuleAttribute(name, value):
                makeASTWithMeta(EModuleAttribute(name, transformer(value)), node.metadata, node.pos);
            case ERemoteCall(module, funcName, args):
                makeASTWithMeta(
                    ERemoteCall(module != null ? transformer(module) : null, funcName, args.map(transformer)),
                    node.metadata, node.pos
                );
            case EParen(expr):
                // Transform the inner expression and preserve parentheses
                makeASTWithMeta(EParen(transformer(expr)), node.metadata, node.pos);
            case _:
                // Leaf nodes - return unchanged
                node;
        };
        return transformed;
    }
    
    /**
     * Underscore Variable Cleanup Pass
     * 
     * WHY: Haxe generates temporary variables with underscore prefixes (_g, _g_1, etc.) during
     * desugaring of switches, loops, and other complex expressions. These are actually USED
     * variables, but in Elixir, underscore-prefixed variables should not be referenced after
     * assignment, causing warnings and violating Elixir conventions.
     * 
     * WHAT: Detects and renames underscore-prefixed temporary variables that are actually used
     * - Identifies Haxe-generated temp variables (_g, _g_1, _g1, etc.)
     * - Tracks which ones are referenced after declaration
     * - Renames them consistently throughout the AST
     * - Preserves truly unused underscore variables (single underscore or unused prefixed)
     * 
     * HOW: Two-phase transformation
     * 1. Analysis phase: Collect all underscore variables and track usage
     * 2. Transformation phase: Rename used variables consistently
     */
    /**
     * Supervisor options transformation pass
     * 
     * WHY: Supervisor.start_link expects keyword lists but TObjectDecl generates maps
     * WHAT: Converts supervisor option maps to keyword lists
     * HOW: Delegates to SupervisorOptionsTransformPass
     */
    static function supervisorOptionsTransformPass(ast: ElixirAST): ElixirAST {
        return SupervisorOptionsTransformPass.transform(ast);
    }
    
    /**
     * OTP Child Spec Transformation Pass
     * 
     * WHY: Enum-based child specs generate tuples like {:PubSub, "TodoApp.PubSub"}
     * which are not valid OTP child specifications. Supervisor.start_link expects
     * either module names or proper child spec maps.
     * 
     * WHAT: Detects patterns that look like child specifications and transforms them:
     * - Simple tuples {:Atom, "String"} ‚Üí proper module references or child spec maps
     * - Lists of such tuples ‚Üí lists of proper child specs
     * - Works for any enum-based child spec pattern, not just TypeSafeChildSpec
     * 
     * HOW: Pattern matches on common OTP child spec contexts:
     * - Supervisor.start_link calls
     * - Children lists in application modules
     * - Any list containing tuple patterns that match child spec signatures
     * 
     * PATTERNS DETECTED:
     * - {:PubSub, "name"} ‚Üí {Phoenix.PubSub, name: "name"}
     * - {:Endpoint} ‚Üí MyAppWeb.Endpoint
     * - {:Telemetry} ‚Üí MyAppWeb.Telemetry
     * - {:Repo, config} ‚Üí {MyApp.Repo, config}
     */
    static function otpChildSpecTransformPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace("[XRay OTPChildSpec] Starting idiomatic enum transformation pass");
        #end
        
        var transformCount = 0;
        
        function transformIdiomaticNode(node: ElixirAST): ElixirAST {
            #if (debug_otp_child_spec && debug_otp_child_spec_verbose)
            // Very verbose - show every node being checked
            trace('[XRay OTPChildSpec] Checking node type: ${Type.enumConstructor(node.def)}');
            #end
            
            // First, recursively transform children
            var nodeWithTransformedChildren = transformAST(node, transformIdiomaticNode);
            
            // Handle null nodes
            if (nodeWithTransformedChildren == null) {
                return null;
            }
            
            // Then check if this node itself needs transformation
            if (nodeWithTransformedChildren.metadata != null && nodeWithTransformedChildren.metadata.requiresIdiomaticTransform == true) {
                #if debug_otp_child_spec
                trace('[XRay OTPChildSpec] Found node #${++transformCount} with requiresIdiomaticTransform flag');
                trace('[XRay OTPChildSpec] Node def: ${nodeWithTransformedChildren.def}');
                #end
                // Apply transformation using shared utility
                var transformed = reflaxe.elixir.ast.ElixirAST.applyIdiomaticEnumTransformation(nodeWithTransformedChildren);
                #if debug_otp_child_spec
                trace('[XRay OTPChildSpec] Transformed to: ${transformed.def}');
                #end
                return transformed;
            }
            
            return nodeWithTransformedChildren;
        }
        
        var result = transformIdiomaticNode(ast);
        
        #if debug_otp_child_spec
        trace('[XRay OTPChildSpec] Pass complete. Transformed ${transformCount} nodes');
        #end
        
        return result;
    }
    
    /**
     * Transform idiomatic enum constructors using convention-based patterns
     * 
     * WHY: Enums marked with @:elixirIdiomatic need special compilation
     * to match Elixir/OTP conventions. Instead of hardcoding specific patterns,
     * we detect structural conventions that indicate idiomatic Elixir usage.
     * 
     * WHAT: Convention-based transformations based on constructor structure:
     * 
     * 1. ZERO ARGUMENTS ‚Üí Bare atom
     *    MyConstructor() ‚Üí :my_constructor
     * 
     * 2. SINGLE ARGUMENT ‚Üí Unwrap the value
     *    ModuleRef("Phoenix.PubSub") ‚Üí Phoenix.PubSub
     *    This is common for module references in OTP
     * 
     * 3. TWO ARGUMENTS where second is keyword list ‚Üí {first, keyword_list}
     *    ModuleWithConfig("Phoenix.PubSub", [name: "MyApp"]) ‚Üí {Phoenix.PubSub, [name: "MyApp"]}
     *    This is the standard OTP child spec format
     * 
     * 4. TWO ARGUMENTS (general) ‚Üí Keep as tuple but simplified
     *    SomeConstructor(a, b) ‚Üí {a, b} (without constructor tag)
     * 
     * 5. THREE+ ARGUMENTS ‚Üí Keep standard tuple format
     *    Complex(a, b, c) ‚Üí {:complex, a, b, c}
     * 
     * HOW: Analyzes the AST structure to detect patterns:
     * - Counts arguments
     * - Detects keyword lists (EKeywordList nodes)
     * - Checks for string literals that should become atoms (module names)
     * 
     * CONVENTIONS DETECTED:
     * - Module name patterns (strings that look like Elixir modules)
     * - Keyword list patterns (for configuration)
     * - Arity patterns (zero, one, two, many)
     * 
     * @param elements The tuple elements [constructor_tag, arg1, arg2, ...]
     * @param node The original AST node with metadata
     * @return Transformed AST following Elixir idioms
     */
    /**
     * Tuple Element Field to Function Transformation Pass
     * 
     * WHY: When switch statements are compiled for Result enums, Haxe generates
     * TField expressions like tuple.elem(0) instead of function calls. These
     * become EField nodes which print as invalid Elixir syntax.
     * 
     * WHAT: Transforms EField nodes with "elem" field name into proper ECall nodes
     * for elem(tuple, index) function calls.
     * 
     * HOW: Recursively traverses AST, detects EField with "elem", and converts
     * them to ECall nodes. This enables the enum pattern matching pass to work.
     */
    static function tupleElemFieldToFunctionPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay TupleElemField] Starting tuple elem field to function transformation');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case EField(target, "elem"):
                // This is a tuple.elem field access that needs to become elem(tuple, N)
                // However, we don't have the index here - it's usually called as tuple.elem(0)
                // So we need to look for the pattern in context
                #if debug_ast_transformer
                var targetStr = ElixirASTPrinter.printAST(target);
                trace('[XRay TupleElemField] Found .elem field access on: $targetStr');
                #end
                
                // For now, we'll mark it for transformation but can't fully convert
                // without the index. The pattern matching pass will handle it.
                {
                    def: EField(transformAST(target, tupleElemFieldToFunctionPass), "elem"),
                    metadata: ast.metadata,
                    pos: ast.pos
                };
                
            case ECall(expr, funcName, args):
                if (funcName == "elem" && expr != null) {
                    // This is a method call pattern: target.elem(N)
                    // Transform to elem(target, N) for proper Elixir syntax
                    #if debug_ast_transformer
                    var targetStr = ElixirASTPrinter.printAST(expr);
                    trace('[XRay TupleElemField] Transforming ${targetStr}.elem(${args.length} args) to elem($targetStr, ...)');
                    #end
                    {
                        def: ECall(null, "elem", [
                            transformAST(expr, tupleElemFieldToFunctionPass)
                        ].concat([for (arg in args) transformAST(arg, tupleElemFieldToFunctionPass)])),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                } else {
                    // Regular call, transform recursively
                    {
                        def: ECall(
                            expr != null ? transformAST(expr, tupleElemFieldToFunctionPass) : null,
                            funcName,
                            [for (arg in args) transformAST(arg, tupleElemFieldToFunctionPass)]
                        ),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                }
                
            default:
                // Recursively transform children
                transformAST(ast, tupleElemFieldToFunctionPass);
        };
    }
    
    /**
     * Idiomatic Enum Pattern Matching Transformation Pass
     * 
     * WHY: The compiler generates low-level tuple access patterns for enum matching
     * which results in non-idiomatic Elixir code and variable naming inconsistencies.
     * Instead of case x.elem(0) with x.elem(1) extraction, we want case x with pattern matching.
     * 
     * WHAT: Transforms patterns like:
     *   case result.elem(0) do
     *     0 -> _g = result.elem(1); value = g; {:Some, value}
     *     1 -> _g = result.elem(1); :none
     *   end
     * Into:
     *   case result do
     *     {0, value} -> {:Some, value}
     *     {1, _} -> :none
     *   end
     * 
     * HOW: Detects ECase with ETupleAccess(expr, 0) and transforms the entire structure
     * to use tuple pattern matching instead of manual extraction.
     */
    static function idiomaticEnumPatternMatchingPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Starting idiomatic enum pattern matching pass');
        #end
        
        // Handle null nodes
        if (ast == null) {
            return null;
        }
        
        return switch(ast.def) {
            case ECase(expr, clauses):
                // Check if this is an enum tag check pattern (case x.elem(0))
                var isEnumTagCheck = false;
                var baseExpr = expr;
                
                switch(expr.def) {
                    case ECall(tupleExpr, "elem", [arg]):
                        switch(arg.def) {
                            case EInteger(0):
                                #if debug_ast_transformer
                                trace('[XRay EnumPatternMatching] Found enum tag check pattern on elem(0) as ECall');
                                #end
                                isEnumTagCheck = true;
                                baseExpr = tupleExpr;
                            default:
                        }
                    case EField(tupleExpr, "elem"):
                        // This is the pattern generated by switch on Result enums
                        // We detect it here but can't check for index 0 directly
                        // The transformer will need to analyze the clauses to determine this
                        #if debug_ast_transformer
                        trace('[XRay EnumPatternMatching] Found potential enum tag check pattern with .elem field access');
                        #end
                        isEnumTagCheck = true;
                        baseExpr = tupleExpr;
                    default:
                }
                
                if (isEnumTagCheck) {
                    
                    #if debug_ast_transformer
                    trace('[XRay EnumPatternMatching] Transforming enum case to idiomatic pattern matching');
                    #end
                    
                    // Transform each clause
                    var transformedClauses = [];
                    for (clause in clauses) {
                        var transformedClause = transformEnumClause(clause, baseExpr);
                        transformedClauses.push(transformedClause);
                    }
                    
                    // Return the transformed case using the base expression directly
                    {
                        def: ECase(baseExpr, transformedClauses),
                        metadata: ast.metadata,
                        pos: ast.pos
                    };
                } else {
                    // Not an enum pattern, recursively transform children
                    transformAST(ast, idiomaticEnumPatternMatchingPass);
                }
                
            default:
                // Recursively transform children
                transformAST(ast, idiomaticEnumPatternMatchingPass);
        };
    }
    
    /**
     * Transform an individual enum case clause to use pattern matching
     * 
     * WHY: Each clause needs to be transformed from tag checking to pattern matching
     * WHAT: Converts manual elem() extraction to tuple pattern destructuring  
     * HOW: Analyzes the body for elem(1) calls and creates appropriate patterns
     */
    static function transformEnumClause(clause: ECaseClause, baseExpr: ElixirAST): ECaseClause {
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Transforming clause with pattern: ${clause.pattern}');
        #end
        
        // Extract the tag value from the pattern
        var tagValue = switch(clause.pattern) {
            case PLiteral(ast):
                switch(ast.def) {
                    case EInteger(tag): tag;
                    default:
                        #if debug_ast_transformer
                        trace('[XRay EnumPatternMatching] Non-integer pattern, keeping as-is');
                        #end
                        return clause; // Can't transform non-integer patterns
                }
            default: 
                #if debug_ast_transformer
                trace('[XRay EnumPatternMatching] Non-literal pattern, keeping as-is');
                #end
                return clause; // Can't transform non-literal patterns
        };
        
        // Analyze the body to find parameter extraction patterns
        var extractedParams = analyzeEnumParameterExtraction(clause.body, baseExpr);
        
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Found ${extractedParams.length} extracted parameters');
        #end
        
        // Create tuple pattern based on extracted parameters
        var tuplePattern = if (extractedParams.length > 0) {
            // Create pattern with extracted variable names
            var patterns = [PLiteral(makeAST(EInteger(tagValue)))];
            for (param in extractedParams) {
                patterns.push(PVar(param.finalName));
            }
            PTuple(patterns);
        } else {
            // No parameters, use wildcard
            PTuple([PLiteral(makeAST(EInteger(tagValue))), PWildcard]);
        };
        
        // Clean up the body by removing extraction statements
        var cleanedBody = removeEnumParameterExtractions(clause.body, extractedParams);
        
        #if debug_ast_transformer
        trace('[XRay EnumPatternMatching] Created tuple pattern with ${extractedParams.length + 1} elements');
        #end
        
        return {
            pattern: tuplePattern,
            guard: clause.guard,
            body: cleanedBody
        };
    }
    
    /**
     * Analyze the body to find enum parameter extraction patterns
     */
    static function analyzeEnumParameterExtraction(body: ElixirAST, baseExpr: ElixirAST): Array<{tempName: String, finalName: String}> {
        var params = [];
        
        switch(body.def) {
            case EBlock(exprs):
                for (expr in exprs) {
                    switch(expr.def) {
                        case EMatch(PVar(varName), ast):
                            switch(ast.def) {
                                case ECall(tupleExpr, "elem", [arg]):
                                    switch(arg.def) {
                                        case EInteger(1):
                                            // Found pattern: _g = result.elem(1)
                                            if (astEquals(tupleExpr, baseExpr)) {
                                                // Look for subsequent assignment: value = g
                                                var finalName = findSubsequentAssignment(exprs, varName.replace("_", ""));
                                                if (finalName != null) {
                                                    params.push({tempName: varName, finalName: finalName});
                                                } else {
                                                    // Use the temp name without underscore as final name
                                                    params.push({tempName: varName, finalName: varName.replace("_", "")});
                                                }
                                            }
                                        default:
                                    }
                                default:
                            }
                        default:
                    }
                }
            default:
                // Single expression body, no extraction
        }
        
        return params;
    }
    
    /**
     * Find subsequent assignment of a temp variable
     */
    static function findSubsequentAssignment(exprs: Array<ElixirAST>, tempVarWithoutUnderscore: String): Null<String> {
        for (expr in exprs) {
            switch(expr.def) {
                case EMatch(PVar(finalName), ast):
                    switch(ast.def) {
                        case EVar(srcVar):
                            if (srcVar == tempVarWithoutUnderscore) {
                                return finalName;
                            }
                        default:
                    }
                default:
            }
        }
        return null;
    }
    
    /**
     * Remove enum parameter extraction statements from the body
     */
    static function removeEnumParameterExtractions(body: ElixirAST, extractedParams: Array<{tempName: String, finalName: String}>): ElixirAST {
        switch(body.def) {
            case EBlock(exprs):
                var cleanedExprs = [];
                var skip = false;
                
                for (i in 0...exprs.length) {
                    var expr = exprs[i];
                    var shouldSkip = false;
                    
                    // Check if this is an extraction statement
                    switch(expr.def) {
                        case EMatch(PVar(varName), ast):
                            switch(ast.def) {
                                case ECall(_, "elem", [arg]):
                                    switch(arg.def) {
                                        case EInteger(1):
                                            // Check if this matches any extracted param
                                            for (param in extractedParams) {
                                                if (varName == param.tempName) {
                                                    shouldSkip = true;
                                                    break;
                                                }
                                            }
                                        default:
                                    }
                                case EVar(srcVar):
                                    // Check if this is a reassignment from temp var
                                    for (param in extractedParams) {
                                        if (varName == param.finalName && srcVar == param.tempName.replace("_", "")) {
                                            shouldSkip = true;
                                            break;
                                        }
                                    }
                                default:
                            }
                        default:
                    }
                    
                    if (!shouldSkip) {
                        cleanedExprs.push(expr);
                    }
                }
                
                // If only one expression remains, unwrap the block
                if (cleanedExprs.length == 1) {
                    return cleanedExprs[0];
                } else if (cleanedExprs.length == 0) {
                    // Empty block, return nil
                    return makeAST(EAtom(ElixirAtom.nil()));
                } else {
                    return {
                        def: EBlock(cleanedExprs),
                        metadata: body.metadata,
                        pos: body.pos
                    };
                }
            default:
                // Not a block, return as-is
                return body;
        }
    }
    
    /**
     * Check if two AST nodes are structurally equal
     */
    static function astEquals(a: ElixirAST, b: ElixirAST): Bool {
        // Simple structural equality check for variable references
        return switch([a.def, b.def]) {
            case [EVar(name1), EVar(name2)]: name1 == name2;
            case [EField(obj1, field1), EField(obj2, field2)]: 
                field1 == field2 && astEquals(obj1, obj2);
            default: false;
        };
    }
    
    /**
     * Transform idiomatic enum constructors using shared utility
     * 
     * WHY: This wrapper delegates to the shared transformation utility in ElixirAST.hx
     * to ensure consistent transformation logic across the AST pipeline.
     * 
     * WHAT: Applies convention-based transformations for enums marked with @:elixirIdiomatic.
     * 
     * HOW: Simply delegates to the shared utility function.
     * 
     * @param elements The tuple elements to transform (unused - kept for compatibility)
     * @param node The original AST node for metadata preservation
     * @return Transformed AST following Elixir idioms
     */
    static function transformIdiomaticEnum(elements: Array<ElixirAST>, node: ElixirAST): ElixirAST {
        // Delegate to shared utility function
        return reflaxe.elixir.ast.ElixirAST.applyIdiomaticEnumTransformation(node);
    }
    
    /**
     * Check if a string looks like an Elixir module name
     * 
     * WHY: Module names in strings should be converted to atoms in idiomatic Elixir
     * WHAT: Detects patterns like "Phoenix.PubSub", "MyApp.Repo", "Elixir.MyModule"
     * HOW: Checks for capitalized segments separated by dots
     * 
     * @param s The string to check
     * @return True if it looks like a module name
     */
    static function isModuleName(s: String): Bool {
        if (s == null || s.length == 0) return false;
        
        // Module names start with uppercase or "Elixir."
        var firstChar = s.charAt(0);
        if (firstChar != firstChar.toUpperCase()) return false;
        
        // Check for module path pattern (e.g., "Phoenix.PubSub")
        var segments = s.split(".");
        for (segment in segments) {
            if (segment.length == 0) return false;
            var first = segment.charAt(0);
            // Each segment should start with uppercase
            if (first != first.toUpperCase() || first == first.toLowerCase()) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Convert a constructor name to idiomatic Elixir atom
     * 
     * WHY: Elixir atoms use snake_case, but some patterns need special handling
     * WHAT: Converts CamelCase to snake_case with special cases for common patterns
     * HOW: 
     * - "Ok" ‚Üí "ok" (common Result pattern)
     * - "Error" ‚Üí "error" (common Result pattern)  
     * - "Some" ‚Üí "ok" (Option pattern mapped to Elixir convention)
     * - "None" ‚Üí "error" (Option pattern mapped to Elixir convention)
     * - Others ‚Üí snake_case
     * 
     * @param tag The constructor tag name
     * @return Idiomatic atom name
     */
    static function toIdiomaticAtom(tag: String): String {
        // Special cases for common patterns
        switch(tag.toLowerCase()) {
            case "ok": return "ok";
            case "error": return "error";
            case "some": return "ok";  // Option.Some maps to {:ok, _} in Elixir
            case "none": return "error";  // Option.None maps to :error in Elixir
            default:
                // Convert to snake_case
                return toSnakeCase(tag);
        }
    }
    
    
    static function underscoreVariableCleanupPass(ast: ElixirAST): ElixirAST {
        #if debug_ast_transformer
        trace('[XRay UnderscoreCleanup] Starting underscore variable cleanup pass');
        #end
        
        // Phase 1: Collect underscore variables and track usage
        var underscoreVars = new Map<String, Bool>(); // var name -> is used
        var varDeclarations = new Map<String, Bool>(); // track all declarations
        var allUnderscoreVars = new Map<String, Bool>(); // track ALL underscore vars
        
        function collectPatternVars(pattern: EPattern, vars: Map<String, Bool>): Void {
            switch(pattern) {
                case PVar(name):
                    vars.set(name, true);
                    if (name.charAt(0) == "_" && name.length > 1) {
                        // Track all underscore variables (including _g_1, _g_2, etc.)
                        allUnderscoreVars.set(name, true);
                        // Initialize as unused
                        if (!underscoreVars.exists(name)) {
                            underscoreVars.set(name, false);
                        }
                    }
                case PTuple(patterns):
                    for (p in patterns) collectPatternVars(p, vars);
                case PList(patterns):
                    for (p in patterns) collectPatternVars(p, vars);
                case PCons(head, tail):
                    collectPatternVars(head, vars);
                    collectPatternVars(tail, vars);
                case PMap(pairs):
                    for (pair in pairs) collectPatternVars(pair.value, vars);
                case PStruct(name, fields):
                    for (field in fields) collectPatternVars(field.value, vars);
                case _:
                    // Other patterns don't declare variables
            }
        }
        
        function collectVariables(node: ElixirAST): Void {
            // Handle null nodes
            if (node == null) {
                return;
            }
            
            switch(node.def) {
                case EMatch(pattern, expr):
                    // Track variable declarations in patterns
                    collectPatternVars(pattern, varDeclarations);
                    // Continue collecting in expression
                    collectVariables(expr);
                    
                case EVar(name):
                    // Track variable usage (not in pattern context)
                    if (name.charAt(0) == "_" && name.length > 1) {
                        // Mark this underscore variable as used
                        underscoreVars.set(name, true);
                        allUnderscoreVars.set(name, true);
                        #if debug_ast_transformer
                        trace('[XRay UnderscoreCleanup] Found used underscore variable: $name at ${node.pos}');
                        #end
                    }
                    
                case ERemoteCall(module, funcName, args):
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Found ERemoteCall: $funcName with ${args.length} args');
                    #end
                    // Recursively collect from module and all arguments
                    if (module != null) collectVariables(module);
                    for (arg in args) {
                        collectVariables(arg);
                    }
                    
                case EFn(clauses):
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Found EFn with ${clauses.length} clauses');
                    #end
                    // Recursively collect from lambda/function bodies
                    for (clause in clauses) {
                        if (clause.guard != null) collectVariables(clause.guard);
                        collectVariables(clause.body);
                    }
                    
                case _:
                    // Recursively collect from all children
                    iterateAST(node, collectVariables);
            }
        }
        
        // Run collection phase
        collectVariables(ast);
        
        // Phase 2: Build renaming map for ALL underscore variables that are referenced
        var renameMap = new Map<String, String>();
        
        // Process all underscore variables we found
        for (varName in allUnderscoreVars.keys()) {
            // Check if this variable is actually used (referenced after declaration)
            var isUsed = underscoreVars.exists(varName) && underscoreVars.get(varName);

            if (isUsed) {
                // CRITICAL FIX: Skip infrastructure variables (_g, _g1, etc.)
                // These are Haxe-generated temporaries for switch desugaring that MUST keep their names
                // Reason: The variable declaration might be in a different scope/block than we can see
                // Example: `switch(msg.type)` desugars to `var _g = msg.type; switch(_g)`
                // If we rename `_g` to `g` in the switch but not in the declaration, we get undefined variable errors
                if (~/^_g(_?\d*)?$/.match(varName)) {
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] PRESERVING infrastructure variable: $varName (used in switch desugaring)');
                    #end
                    // DO NOT rename - keep the underscore prefix
                    continue;
                }

                // This underscore variable is used, so rename it
                if (~/^_\d+$/.match(varName)) {
                    // _1, _2 -> temp_1, temp_2 (avoid pure numeric)
                    var newName = "temp" + varName.substr(1);
                    renameMap.set(varName, newName);
                    #if debug_ast_transformer
                    trace('[XRay UnderscoreCleanup] Renaming used numeric: $varName -> $newName');
                    #end
                }
                // Other underscore variables are left as-is (might be intentional)
            } else {
                #if debug_ast_transformer
                if (varName.charAt(0) == "_" && varName.length > 1) {
                    trace('[XRay UnderscoreCleanup] Keeping unused underscore variable: $varName');
                }
                #end
            }
        }
        
        // Phase 3: Apply renaming throughout the AST
        if (renameMap.keys().hasNext()) {
            #if debug_ast_transformer
            trace('[XRay UnderscoreCleanup] Applying ${Lambda.count(renameMap)} variable renamings');
            #end
            return applyVariableRenaming(ast, renameMap);
        }
        
        #if debug_ast_transformer
        trace('[XRay UnderscoreCleanup] No underscore variables need renaming');
        #end
        return ast;
    }
    
    /**
     * Apply variable renaming throughout the AST
     */
    static function applyVariableRenaming(ast: ElixirAST, renameMap: Map<String, String>): ElixirAST {
        function renameInPattern(pattern: EPattern): EPattern {
            return switch(pattern) {
                case PVar(name):
                    renameMap.exists(name) ? PVar(renameMap.get(name)) : pattern;
                case PTuple(patterns):
                    PTuple(patterns.map(renameInPattern));
                case PList(patterns):
                    PList(patterns.map(renameInPattern));
                case PCons(head, tail):
                    PCons(renameInPattern(head), renameInPattern(tail));
                case PMap(pairs):
                    PMap(pairs.map(p -> {key: p.key, value: renameInPattern(p.value)}));
                case PStruct(name, fields):
                    PStruct(name, fields.map(f -> {key: f.key, value: renameInPattern(f.value)}));
                case _:
                    pattern;
            }
        }
        
        function renameInAST(node: ElixirAST): ElixirAST {
            var transformed = switch(node.def) {
                case EVar(name):
                    if (renameMap.exists(name)) {
                        #if debug_ast_transformer
                        trace('[XRay UnderscoreCleanup] Renaming EVar: $name -> ${renameMap.get(name)}');
                        #end
                        makeASTWithMeta(EVar(renameMap.get(name)), node.metadata, node.pos);
                    } else {
                        node;
                    }
                    
                case EMatch(pattern, expr):
                    makeASTWithMeta(
                        EMatch(renameInPattern(pattern), renameInAST(expr)),
                        node.metadata, node.pos
                    );
                    
                case ECase(expr, clauses):
                    makeASTWithMeta(
                        ECase(renameInAST(expr),
                              clauses.map(c -> {
                                  pattern: renameInPattern(c.pattern),
                                  guard: c.guard != null ? renameInAST(c.guard) : null,
                                  body: renameInAST(c.body)
                              })),
                        node.metadata, node.pos
                    );
                    
                case EReceive(clauses, after):
                    makeASTWithMeta(
                        EReceive(clauses.map(c -> {
                                     pattern: renameInPattern(c.pattern),
                                     guard: c.guard != null ? renameInAST(c.guard) : null,
                                     body: renameInAST(c.body)
                                 }),
                                 after != null ? {timeout: renameInAST(after.timeout), body: renameInAST(after.body)} : null),
                        node.metadata, node.pos
                    );
                    
                case EFn(clauses):
                    makeASTWithMeta(
                        EFn(clauses.map(c -> {
                            args: c.args.map(renameInPattern),
                            guard: c.guard != null ? renameInAST(c.guard) : null,
                            body: renameInAST(c.body)
                        })),
                        node.metadata, node.pos
                    );
                    
                case _:
                    // For all other node types, recursively transform children
                    transformAST(node, renameInAST);
            };
            return transformed;
        }
        
        return renameInAST(ast);
    }
    
    /**
     * Fix Bare Concatenations Pass
     * 
     * WHY: When array.push() is transformed to concatenation, nested blocks can contain
     *      bare concatenations like `g ++ [0]` which are invalid as statements in Elixir.
     * 
     * WHAT: Converts bare concatenation statements to assignments.
     * 
     * HOW: Detects EBinary(Concat, EVar(name), ...) in statement position and wraps
     *      them with EBinary(Match, EVar(name), ...) to create valid assignments.
     */
    static function fixBareConcatenationsPass(ast: ElixirAST): ElixirAST {
        function fixConcatenations(node: ElixirAST): ElixirAST {
            if (node == null) return null;
            return switch(node.def) {
                case EBlock(statements):
                    var fixedStatements = [];
                    for (stmt in statements) {
                        // Add null check to prevent null pointer exceptions
                        if (stmt == null) {
                            continue;
                        }
                        var fixed = switch(stmt.def) {
                            // Check for bare concatenation: var ++ [value] or struct.field ++ [value]
                            case EBinary(Concat, left, right):
                                switch(left.def) {
                                    case EVar(name):
                                        // Convert to assignment: var = var ++ [value]
                                        makeAST(EBinary(Match, left, stmt));
                                    case EField(structVar, fieldName):
                                        // This is struct.field ++ [value] - a bare concatenation that should update the struct
                                        // Transform to: struct = %{struct | field: struct.field ++ [value]}
                                        switch(structVar.def) {
                                            case EVar("struct"):
                                                // Create struct update
                                                makeAST(EBinary(
                                                    Match,
                                                    structVar,
                                                    makeAST(EStructUpdate(
                                                        structVar,
                                                        [{
                                                            key: fieldName,
                                                            value: stmt  // The concatenation itself
                                                        }]
                                                    ))
                                                ));
                                            default:
                                                // Not a struct field, keep as-is
                                                stmt;
                                        }
                                    default:
                                        // Keep as-is if not a simple variable or field
                                        stmt;
                                }
                            default:
                                // Recursively fix nested blocks
                                fixConcatenations(stmt);
                        };
                        fixedStatements.push(fixed);
                    }
                    makeAST(EBlock(fixedStatements));
                    
                case EList(elements):
                    // Fix elements inside list literals
                    var fixedElements = [for (e in elements) fixConcatenations(e)];
                    makeAST(EList(fixedElements));
                    
                default:
                    // Recursively apply to all children
                    transformAST(node, fixConcatenations);
            };
        }
        
        return fixConcatenations(ast);
    }
    
    /**
     * Unrolled Comprehension Reconstruction Pass
     * 
     * WHY: Haxe completely unrolls array comprehensions with constant ranges at compile-time,
     *      converting `[for (i in 0...3) i]` into imperative code with temp variables and 
     *      concatenations. This creates invalid Elixir with bare concatenation expressions
     *      like `g ++ [0]` appearing as statements inside list literals.
     * 
     * WHAT: Detects blocks marked with isUnrolledComprehension metadata and reconstructs
     *       them back into idiomatic Elixir `for` comprehensions.
     * 
     * HOW: 1. Looks for Block nodes with isUnrolledComprehension metadata
     *      2. Analyzes the block to extract iteration pattern (range, values)
     *      3. Reconstructs as EFor(iterVar, range, body)
     *      4. Handles nested comprehensions by recursively processing inner blocks
     * 
     * EDGE CASES:
     * - Empty comprehensions (0...0 range)
     * - Single element comprehensions (0...1)
     * - Deeply nested comprehensions (3+ levels)
     * - Mixed constant and variable ranges
     * 
     * @see docs/03-compiler-development/ARRAY_COMPREHENSION_RECONSTRUCTION.md
     */
    static function unrolledComprehensionReconstructionPass(ast: ElixirAST): ElixirAST {
        #if debug_array_comprehension
        trace('[Array Comprehension Transform] Starting reconstruction pass');
        #end
        #if debug_unrolled_comprehension
        trace('[DEBUG Transform] unrolledComprehensionReconstructionPass called');
        #end
        
        function reconstructComprehension(ast: ElixirAST): ElixirAST {
            return switch(ast.def) {
                case EBlock(stmts) if (ast.metadata != null && ast.metadata.isUnrolledComprehension == true):
                    #if debug_array_comprehension
                    trace('[Array Comprehension Transform] ‚úì Found marked block with ${stmts.length} statements');
                    trace('[Array Comprehension Transform]   Metadata: ${ast.metadata}');
                    #end
                    
                    // Analyze the block to reconstruct comprehension
                    var comprehension = analyzeAndReconstructComprehension(stmts);
                    if (comprehension != null) {
                        #if debug_array_comprehension
                        trace('[Array Comprehension Transform] ‚úì Successfully reconstructed as for comprehension');
                        #end
                        comprehension;
                    } else {
                        #if debug_array_comprehension
                        trace('[Array Comprehension Transform] ‚úó Could not reconstruct, keeping as block');
                        #end
                        ast;
                    }
                    
                case _:
                    // Recursively transform children
                    transformAST(ast, reconstructComprehension);
            };
        }
        
        return reconstructComprehension(ast);
    }
    
    /**
     * Analyze an unrolled comprehension block and reconstruct as EFor
     * 
     * Pattern to detect:
     * - g = []                    (initialization)
     * - g = g ++ [...]           (accumulation statements)
     * - g                        (return value)
     * 
     * Reconstructs as: for i <- 0..n, do: expression
     */
    static function analyzeAndReconstructComprehension(stmts: Array<ElixirAST>): Null<ElixirAST> {
        if (stmts.length < 3) return null;
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform] Analyzing block for reconstruction');
        #end
        
        // Check first statement: should be g = []
        var iterVar = switch(stmts[0].def) {
            case EBinary(Match, {def: EVar(varName)}, {def: EList([])}):
                varName;
            case _:
                return null;
        };
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Found initialization: $iterVar = []');
        #end
        
        // Extract elements from accumulation statements
        var elements = [];
        for (i in 1...stmts.length - 1) {
            switch(stmts[i].def) {
                case EBinary(Match, {def: EVar(v)}, {def: EBinary(Concat, {def: EVar(v2)}, {def: EList([elem])})}) if (v == iterVar && v2 == iterVar):
                    // g = g ++ [element]
                    elements.push(elem);
                case EBinary(Concat, {def: EVar(v)}, {def: EList([elem])}) if (v == iterVar):
                    // Bare concatenation: g ++ [element] (shouldn't happen after fix, but handle it)
                    elements.push(elem);
                case _:
                    // Unknown pattern
                    #if debug_array_comprehension
                    trace('[Array Comprehension Transform]   Unknown statement pattern: ${stmts[i].def}');
                    #end
            }
        }
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Extracted ${elements.length} elements');
        #end
        
        // Check last statement: should return the variable
        var returnsVar = switch(stmts[stmts.length - 1].def) {
            case EVar(v) if (v == iterVar): true;
            case _: false;
        };
        
        if (!returnsVar || elements.length == 0) return null;
        
        // Determine the range from element count
        var rangeEnd = elements.length - 1;
        
        // Check if elements are simple integers (0, 1, 2...) or nested comprehensions
        var isSimpleRange = true;
        var hasNestedComprehensions = false;
        
        for (i in 0...elements.length) {
            switch(elements[i].def) {
                case EInteger(val):
                    // Check if it's the expected integer
                    if (val != i) {
                        isSimpleRange = false;
                    }
                case EList(_):
                    // Nested list - likely a nested comprehension
                    hasNestedComprehensions = true;
                    isSimpleRange = false;
                case _:
                    isSimpleRange = false;
            }
        }
        
        #if debug_array_comprehension
        trace('[Array Comprehension Transform]   Simple range: $isSimpleRange, Nested: $hasNestedComprehensions');
        #end
        
        // Generate appropriate comprehension
        if (isSimpleRange) {
            // Simple range comprehension: for i <- 0..n, do: i
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("i"),
                expr: range
            };
            var body = makeAST(EVar("i")); // Simple case: just return the iterator
            
            return makeAST(EFor([generator], [], body, null, null));
        } else if (hasNestedComprehensions) {
            // Nested comprehension: for i <- 0..n, do: for j <- 0..m, do: expr
            // For now, reconstruct the outer comprehension
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("i"),
                expr: range
            };
            
            // Use the first element as template for the body (should be consistent)
            var body = elements[0];
            
            // If the body is a list, check if it can be reconstructed as a nested comprehension
            switch(body.def) {
                case EList(innerElements):
                    // Check if inner elements follow a pattern
                    var innerComprehension = tryReconstructInnerComprehension(innerElements);
                    if (innerComprehension != null) {
                        body = innerComprehension;
                    }
                case _:
            }
            
            return makeAST(EFor([generator], [], body, null, null));
        } else {
            // Complex pattern - keep as-is for now
            #if debug_array_comprehension
            trace('[Array Comprehension Transform]   Complex pattern, not reconstructing');
            #end
            return null;
        }
    }
    
    /**
     * Try to reconstruct an inner comprehension from a list of elements
     */
    static function tryReconstructInnerComprehension(elements: Array<ElixirAST>): Null<ElixirAST> {
        if (elements.length == 0) return null;
        
        // Check if elements follow a simple numeric pattern
        var isSimpleRange = true;
        for (i in 0...elements.length) {
            switch(elements[i].def) {
                case EInteger(val):
                    if (val != i) {
                        isSimpleRange = false;
                        break;
                    }
                case _:
                    isSimpleRange = false;
                    break;
            }
        }
        
        if (isSimpleRange) {
            // Reconstruct as: for j <- 0..n, do: j
            var rangeEnd = elements.length - 1;
            var range = makeAST(ERange(makeAST(EInteger(0)), makeAST(EInteger(rangeEnd)), false));
            var generator: EGenerator = {
                pattern: PVar("j"),
                expr: range
            };
            var body = makeAST(EVar("j"));
            
            return makeAST(EFor([generator], [], body, null, null));
        }
        
        return null;
    }
}

/**
 * SupervisorOptionsTransformPass: Convert supervisor options from map to keyword list
 * 
 * WHY: Supervisor.start_link expects options as a keyword list [strategy: :one_for_one, ...]
 *      but TObjectDecl generates EMap %{strategy: :one_for_one, ...}
 * 
 * WHAT: Detects supervisor option patterns and converts EMap to EKeywordList
 * 
 * HOW: Looks for maps with supervisor option keys (strategy, max_restarts, max_seconds)
 *      being passed to Supervisor.start_link and converts them to keyword lists
 */
class SupervisorOptionsTransformPass {
    
    /**
     * Transform supervisor options from maps to keyword lists
     */
    public static function transform(ast: ElixirAST, ?context: reflaxe.elixir.CompilationContext): ElixirAST {
        #if debug_ast_transformer
        trace("[XRay SupervisorOptions] Starting supervisor options transformation");
        switch(ast.def) {
            case EDefmodule(name, _):
                trace('[XRay SupervisorOptions] Processing module: $name');
            case _:
                trace('[XRay SupervisorOptions] Processing non-module AST');
        }
        #end
        
        return transformSupervisorCalls(ast);
    }
    
    /**
     * Find and transform Supervisor.start_link calls
     */
    static function transformSupervisorCalls(ast: ElixirAST): ElixirAST {
        return ElixirASTTransformer.transformNode(ast, function(node: ElixirAST): ElixirAST {
            #if debug_ast_transformer
            switch(node.def) {
                case EMatch(PVar(name), _):
                    trace('[XRay SupervisorOptions] Found variable assignment in transformSupervisorCalls: $name');
                case EMap(_):
                    trace('[XRay SupervisorOptions] Found map in transformSupervisorCalls');
                case _:
            }
            #end
            
            switch(node.def) {
                case ERemoteCall(module, "start_link", args) if (args.length == 2):
                    // Check if this is Supervisor.start_link(children, opts)
                    var isSupervisor = switch(module.def) {
                        case EVar("Supervisor"): true;
                        case _: false;
                    };
                    
                    if (isSupervisor) {
                        #if debug_ast_transformer
                        trace("[XRay SupervisorOptions] Found Supervisor.start_link call");
                        #end
                        
                        // Transform the second argument (options) if it's a map
                        var children = args[0];
                        var opts = transformSupervisorOptions(args[1]);
                        
                        return makeASTWithMeta(
                            ERemoteCall(module, "start_link", [children, opts]),
                            node.metadata,
                            node.pos
                        );
                    }
                    
                case EMatch(pattern, expr):
                    // Check if we're assigning to a variable named "opts" or similar
                    var varName = switch(pattern) {
                        case PVar(name): name;
                        case _: null;
                    };
                    
                    #if debug_ast_transformer
                    if (varName != null) {
                        trace('[XRay SupervisorOptions] Found variable assignment: $varName');
                    }
                    #end
                    
                    if (varName != null && (varName == "opts" || varName.indexOf("option") != -1 || varName.indexOf("config") != -1)) {
                        // This might be supervisor options
                        #if debug_ast_transformer
                        trace('[XRay SupervisorOptions] Variable $varName looks like options, checking if it\'s a map...');
                        #end
                        
                        var transformedExpr = transformSupervisorOptions(expr);
                        if (transformedExpr != expr) {
                            #if debug_ast_transformer
                            trace('[XRay SupervisorOptions] ‚úì Transformed options assignment for variable: $varName');
                            #end
                            return makeASTWithMeta(
                                EMatch(pattern, transformedExpr),
                                node.metadata,
                                node.pos
                            );
                        }
                    }
                    
                case _:
                    // Not a supervisor call
            }
            
            return node;
        });
    }
    
    /**
     * Transform supervisor options from map to keyword list if needed
     */
    static function transformSupervisorOptions(expr: ElixirAST): ElixirAST {
        return switch(expr.def) {
            case EMap(pairs):
                #if debug_ast_transformer
                trace('[XRay SupervisorOptions] Analyzing map with ${pairs.length} pairs');
                #end
                
                // Check if this looks like supervisor options
                var hasStrategy = false;
                var hasMaxRestarts = false;
                var hasMaxSeconds = false;
                var hasName = false;
                
                for (pair in pairs) {
                    var keyName: Null<String> = switch(pair.key.def) {
                        case EAtom(atom): atom; // ElixirAtom implicitly converts to String
                        case _: null;
                    };
                    
                    if (keyName != null) {
                        // Check both snake_case and original field names (before transformation)
                        // since this pass might run at different stages
                        switch(keyName.toLowerCase()) {
                            case "strategy": hasStrategy = true;
                            case "max_restarts" | "maxrestarts": hasMaxRestarts = true;
                            case "max_seconds" | "maxseconds": hasMaxSeconds = true;
                            case "name": hasName = true;
                        }
                        
                        #if debug_ast_transformer
                        trace('[XRay SupervisorOptions] Checking key: $keyName (hasStrategy=$hasStrategy, hasMaxRestarts=$hasMaxRestarts)');
                        #end
                    }
                }
                
                // If it has at least strategy (required) and one other supervisor field, convert it
                if (hasStrategy && (hasMaxRestarts || hasMaxSeconds || hasName)) {
                    #if debug_ast_transformer
                    trace("[XRay SupervisorOptions] Converting map to keyword list for supervisor options");
                    #end
                    
                    // Convert EMapPair to EKeywordPair with normalization for strategy atom
                    var keywordPairs: Array<EKeywordPair> = [];
                    for (pair in pairs) {
                        var key = switch(pair.key.def) {
                            case EAtom(name): name;
                            case _: continue; // Skip non-atom keys
                        };
                        var value = pair.value;
                        // Normalize strategy value to a clean atom without a leading colon
                        if (key == "strategy") {
                            switch (value.def) {
                                case EAtom(a):
                                    var aStr:String = a;
                                    if (aStr != null && aStr.length > 0 && aStr.charAt(0) == ':') {
                                        var trimmed = aStr.substr(1);
                                        value = makeAST(EAtom(ElixirAtom.raw(trimmed)));
                                    }
                                case EString(s):
                                    if (s != null && s.length > 0 && s.charAt(0) == ':') {
                                        var trimmed2 = s.substr(1);
                                        value = makeAST(EAtom(ElixirAtom.raw(trimmed2)));
                                    }
                                default:
                            }
                        }
                        
                        // Note: Snake_case conversion for atoms is handled systematically
                        // in ElixirASTBuilder.toElixirAtomName(), not here
                        keywordPairs.push({key: key, value: value});
                    }
                    
                    return makeASTWithMeta(
                        EKeywordList(keywordPairs),
                        expr.metadata,
                        expr.pos
                    );
                }
                
                expr; // Not supervisor options
                
            case _:
                expr; // Not a map
        };
    }
    
    /**
     * Helper to create AST node with metadata
     */
    static function makeASTWithMeta(def: ElixirASTDef, ?metadata: ElixirMetadata, ?pos: haxe.macro.Expr.Position): ElixirAST {
        return {
            def: def,
            metadata: metadata != null ? metadata : {},
            pos: pos
        };
    }

    /**
     * Pattern Variable Origin Analysis Pass
     *
     * WHY: Distinguish between legitimate user variables named "g" (like in RGB patterns)
     *      and Haxe's temp extraction variables (g, g1, g2). Without this, legitimate
     *      variables get incorrectly prefixed with underscores.
     *
     * WHAT: Uses VarOrigin metadata to determine which variables should get underscore
     *       prefixes and ensures correct variable usage in pattern matching.
     *
     * HOW:
     * - Analyzes case patterns and their bodies for variable usage
     * - Checks varOrigin metadata to distinguish PatternBinder vs ExtractionTemp
     * - Updates pattern variables to use underscores only for truly unused variables
     * - Ensures consistency between pattern declaration and usage
     *
     * EXAMPLE:
     * Before: {:rgb, _g, _g1, _b} with reference to undefined 'g'
     * After: {:rgb, r, g, b} with correct references
     */
    static function patternVariableOriginAnalysisPass(ast: ElixirAST): ElixirAST {
        #if debug_pattern_variable_origin
        trace('[XRay PatternVariableOrigin] Starting analysis pass');
        #end

        // Forward declarations for recursive functions
        var analyzeAndTransform: ElixirAST -> ElixirAST = null;
        var analyzeClause: (ECaseClause, ElixirMetadata) -> ECaseClause = null;
        var collectPatternVars: (EPattern, Map<String, VarOrigin>, VarOrigin) -> Void = null;
        var analyzeUsage: (ElixirAST, Map<String, Bool>) -> Void = null;
        var updatePatternWithUsage: (EPattern, Map<String, VarOrigin>, Map<String, Bool>) -> EPattern = null;

        analyzeAndTransform = function(node: ElixirAST): ElixirAST {
            switch(node.def) {
                case ECase(expr, clauses):
                    #if debug_pattern_variable_origin
                    trace('[XRay PatternVariableOrigin] Analyzing case expression');
                    #end

                    // Transform each clause
                    var newClauses = [];
                    for (clause in clauses) {
                        var transformedClause = analyzeClause(clause, node.metadata);
                        newClauses.push(transformedClause);
                    }

                    return makeASTWithMeta(
                        ECase(analyzeAndTransform(expr), newClauses),
                        node.metadata,
                        node.pos
                    );

                default:
                    // Recursively transform other nodes
                    return ElixirASTTransformer.transformAST(node, analyzeAndTransform);
            }
        };

        analyzeClause = function(clause: ECaseClause, caseMetadata: ElixirMetadata): ECaseClause {
            #if debug_pattern_variable_origin
            trace('[XRay PatternVariableOrigin] Analyzing clause pattern');
            #end

            // Get variable origin info from metadata if available
            var varOrigin = caseMetadata != null && caseMetadata.varOrigin != null ?
                caseMetadata.varOrigin : null;
            var tempToBinderMap = caseMetadata != null && caseMetadata.tempToBinderMap != null ?
                caseMetadata.tempToBinderMap : null;

            // Collect variables from the pattern and their origins
            var patternVars: Map<String, VarOrigin> = new Map();
            collectPatternVars(clause.pattern, patternVars, varOrigin);

            // Analyze usage in the clause body
            var usedVars: Map<String, Bool> = new Map();
            analyzeUsage(clause.body, usedVars);

            // Update pattern based on usage and origin
            var updatedPattern = updatePatternWithUsage(clause.pattern, patternVars, usedVars);

            return {
                pattern: updatedPattern,
                guard: clause.guard != null ? analyzeAndTransform(clause.guard) : null,
                body: analyzeAndTransform(clause.body)
            };
        };

        collectPatternVars = function(pattern: EPattern, vars: Map<String, VarOrigin>, defaultOrigin: VarOrigin): Void {
            switch(pattern) {
                case PVar(name):
                    // Use the origin from metadata if available, otherwise use default
                    var origin = defaultOrigin != null ? defaultOrigin : UserDefined;

                    // Special handling for known temp variable patterns
                    if (name == "g" || (name.startsWith("g") && name.length > 1 &&
                        name.charAt(1) >= '0' && name.charAt(1) <= '9')) {
                        // This looks like a temp extraction variable
                        origin = ExtractionTemp;
                    }

                    vars.set(name, origin);

                case PTuple(elements):
                    for (elem in elements) {
                        collectPatternVars(elem, vars, defaultOrigin);
                    }

                case PList(elements):
                    for (elem in elements) {
                        collectPatternVars(elem, vars, defaultOrigin);
                    }

                case PCons(head, tail):
                    collectPatternVars(head, vars, defaultOrigin);
                    collectPatternVars(tail, vars, defaultOrigin);

                default:
                    // Other patterns don't introduce variables
            }
        };

        analyzeUsage = function(ast: ElixirAST, usedVars: Map<String, Bool>): Void {
            switch(ast.def) {
                case EVar(name):
                    // Mark this variable as used (remove underscore prefix if present for comparison)
                    var cleanName = name.startsWith("_") ? name.substring(1) : name;
                    usedVars.set(cleanName, true);
                    usedVars.set(name, true); // Also mark the exact name

                case EMatch(pattern, expr):
                    // Analyze the expression for usage
                    analyzeUsage(expr, usedVars);
                    // Don't analyze the pattern - it's a declaration

                default:
                    // Recursively analyze children
                    // TODO: Need to properly iterate through AST children
                    // This pass is disabled anyway, so commenting out for now
                    // iterateAST(ast, function(child) {
                    //     analyzeUsage(child, usedVars);
                    // });
            }
        };

        updatePatternWithUsage = function(pattern: EPattern, patternVars: Map<String, VarOrigin>, usedVars: Map<String, Bool>): EPattern {
            switch(pattern) {
                case PVar(name):
                    var origin = patternVars.get(name);
                    var isUsed = usedVars.exists(name) && usedVars.get(name);

                    #if debug_pattern_variable_origin
                    trace('[XRay PatternVariableOrigin] Variable "$name" - Origin: $origin, Used: $isUsed');
                    #end

                    // Special case: legitimate user variables named "g" should NOT get underscores
                    // Only add underscore if:
                    // 1. Variable is not used AND
                    // 2. It's definitely an extraction temp (not a user's "g" in RGB)
                    if (!isUsed && !name.startsWith("_")) {
                        // Check if this is definitely a temp extraction variable
                        // For now, we're conservative - only prefix if we're sure it's unused
                        if (origin == ExtractionTemp) {
                            // But wait - if it's named just "g" in an RGB pattern, it might be legitimate
                            // This is where we'd need more context to decide
                            // For now, leave it as-is to avoid false positives
                            return pattern;
                        }
                    }
                    return pattern;

                case PTuple(elements):
                    return PTuple(elements.map(e -> updatePatternWithUsage(e, patternVars, usedVars)));

                case PList(elements):
                    return PList(elements.map(e -> updatePatternWithUsage(e, patternVars, usedVars)));

                case PCons(head, tail):
                    return PCons(
                        updatePatternWithUsage(head, patternVars, usedVars),
                        updatePatternWithUsage(tail, patternVars, usedVars)
                    );

                default:
                    return pattern;
            }
        };

        return analyzeAndTransform(ast);
    }
}

#if debug_ast_snapshots
private class AbsoluteFinalSnapshot {
    public static function emitFilterTodosThenBranch(ast: ElixirAST): Void {
        // Optional narrowing: module and func can be provided via defines.
        var wantFunc = getDefineString('debug_ast_snapshots_func');
        var wantModule = getDefineString('debug_ast_snapshots_module');

        // Default target if none provided
        if (wantFunc == null || wantFunc == '') wantFunc = 'filter_todos/3';

        var targetName = extractFuncName(wantFunc);
        var targetArity = extractArity(wantFunc);

        var thenBranch: ElixirAST = null;
        var seenFuncs: Array<String> = [];

        traverse(ast, function(node) {
            // Attempt capture from any function node we see
            tryCaptureFromDef(node, targetName, targetArity, function(b) thenBranch = b);
            if (thenBranch != null) return; // short‚Äëcircuit
            // Optional module narrowing: no‚Äëop unless set
            switch (node.def) {
                case EModule(modName, _, _):
                    #if sys Sys.println('[AST Snapshot] In module: ' + modName); #end
                    if (wantModule != null && wantModule != '' && modName != wantModule) {
                        // Note: we don't prune traversal here to avoid skipping nested defs
                    }
                case EDef(name, args, _, _) | EDefp(name, args, _, _):
                    if (seenFuncs.indexOf(name + '/' + (args != null ? args.length : 0)) == -1)
                        seenFuncs.push(name + '/' + (args != null ? args.length : 0));
                default:
            }
        });

        if (thenBranch != null) {
            var code = safePrint(thenBranch);
            writeSnapshot('tmp/ast_flow', 'AbsoluteFinal_filter_todos_then_branch.ex', code);
            #if sys Sys.println('[AST Snapshot] Wrote then‚Äëbranch to tmp/ast_flow/AbsoluteFinal_filter_todos_then_branch.ex'); #else trace('[AST Snapshot] Wrote then‚Äëbranch'); #end
            // If module name filter is set, dump observed functions for debugging
            if (wantModule != null && wantModule != '') {
                var fnDump = seenFuncs.join("\n");
                writeSnapshot('tmp/ast_flow', 'AbsoluteFinal_' + targetName + '_observed_functions.txt', fnDump);
            }
        } else {
            #if sys Sys.println('[AST Snapshot] filter_todos/3 then‚Äëbranch not found'); #else trace('[AST Snapshot] then‚Äëbranch not found'); #end
        }
    }

    static function tryCaptureFromDef(node: ElixirAST, targetName: String, targetArity: Int, onFound: ElixirAST -> Void): Void {
        switch (node.def) {
            case EDef(name, args, _, body) | EDefp(name, args, _, body):
                #if sys Sys.println('[AST Snapshot] Saw def ' + name + '/' + (args != null ? args.length : 0)); #end
                if (name == targetName && args != null && args.length == targetArity) {
                    var firstIf = findFirstIf(body);
                    if (firstIf != null) onFound(firstIf.thenBranch);
                }
            default:
        }
    }

    static function findFirstIf(node: ElixirAST): { condition: ElixirAST, thenBranch: ElixirAST, elseBranch: Null<ElixirAST> } {
        var found: { condition: ElixirAST, thenBranch: ElixirAST, elseBranch: Null<ElixirAST> } = null;
        traverse(node, function(n) {
            if (found != null) return; // short‚Äëcircuit
            switch (n.def) {
                case EIf(cond, thenB, elseB):
                    found = { condition: cond, thenBranch: thenB, elseBranch: elseB };
                default:
            }
        });
        return found;
    }

    static function traverse(node: ElixirAST, f: ElixirAST -> Void): Void {
        if (node == null) return;
        function visitor(n: ElixirAST): Void {
            if (n == null) return;
            f(n);
            // Recursively visit child nodes via transformAST with identity
            ElixirASTTransformer.transformAST(n, function(child) {
                visitor(child);
                return child;
            });
        }
        visitor(node);
    }

    static function safePrint(node: ElixirAST): String {
        try {
            return reflaxe.elixir.ast.ElixirASTPrinter.print(node, 0);
        } catch (e: Dynamic) {
            return '// <printer error> ' + Std.string(e);
        }
    }

    static function extractFuncName(spec: String): String {
        var idx = spec.lastIndexOf('/');
        return idx >= 0 ? spec.substr(0, idx) : spec;
    }

    static function extractArity(spec: String): Int {
        var idx = spec.lastIndexOf('/');
        if (idx < 0) return 0;
        var s = spec.substr(idx + 1);
        return Std.parseInt(s);
    }

    static function getDefineString(name: String): Null<String> {
        #if macro
        try return haxe.macro.Context.definedValue(name) catch (_:Dynamic) return null;
        #else
        return null;
        #end
    }

    static function writeSnapshot(dir: String, file: String, content: String): Void {
        #if sys
        if (!sys.FileSystem.exists(dir)) sys.FileSystem.createDirectory(dir);
        var full = dir + '/' + file;
        sys.io.File.saveContent(full, content);
        #end
    }
}
#end // debug_ast_snapshots

#if debug_ast_snapshots
private class PerPassSnapshot {
    static var passIndex:Int = 0;

    public static function emitFunctionAfterPass(ast: ElixirAST, passName:String):Void {
        var spec = getDefineString('debug_ast_snapshots_func');
        if (spec == null || spec == '') return;
        var targetName = extractFuncName(spec);
        var targetArity = extractArity(spec);
        var fnNode: Null<ElixirAST> = null;
        traverse(ast, function(n) {
            switch (n.def) {
                case EDef(name, args, _, _) | EDefp(name, args, _, _):
                    if (name == targetName && args != null && args.length == targetArity) fnNode = n;
                default:
            }
        });
        if (fnNode == null) { passIndex++; return; }
        var code = safePrint(fnNode);
        var dir = 'tmp/ast_flow/passes';
        #if sys if (!sys.FileSystem.exists(dir)) sys.FileSystem.createDirectory(dir); #end
        var file = dir + '/' + Std.string(passIndex) + '_' + sanitize(passName) + '.ex';
        #if sys sys.io.File.saveContent(file, code); #end
        passIndex++;
    }

    static function sanitize(s:String):String {
        if (s == null) return 'pass';
        return s.split(' ').join('_').split('/').join('_');
    }
    static function getDefineString(name: String): Null<String> {
        #if macro
        try return haxe.macro.Context.definedValue(name) catch (_:Dynamic) return null;
        #else
        return null;
        #end
    }
    static function extractFuncName(spec: String): String {
        var idx = spec.lastIndexOf('/');
        return idx >= 0 ? spec.substr(0, idx) : spec;
    }
    static function extractArity(spec: String): Int {
        var idx = spec.lastIndexOf('/');
        if (idx < 0) return 0;
        var s = spec.substr(idx + 1);
        return Std.parseInt(s);
    }

    static function traverse(node: ElixirAST, f: ElixirAST -> Void): Void {
        if (node == null) return;
        function visitor(n: ElixirAST): Void {
            if (n == null) return;
            f(n);
            ElixirASTTransformer.transformAST(n, function(child) {
                visitor(child);
                return child;
            });
        }
        visitor(node);
    }

    static function safePrint(node: ElixirAST): String {
        try {
            return reflaxe.elixir.ast.ElixirASTPrinter.print(node, 0);
        } catch (e: Dynamic) {
            return '// <printer error> ' + Std.string(e);
        }
    }
}
#end // debug_ast_snapshots

#end // (macro || reflaxe_runtime)
</file>

<file path="scripts/qa-sentinel.sh">
#!/usr/bin/env bash
set -euo pipefail
# Disable job control notifications to avoid background job status lines like "Killed: 9"
set +m

# ============================================================================
# QA Sentinel: Non‚ÄëBlocking Phoenix App Validation (Haxe‚ÜíElixir‚ÜíRuntime)
# ============================================================================
# WHAT
# - Builds the project (Haxe‚ÜíElixir), resolves Mix deps, compiles Elixir,
#   launches Phoenix in the background, probes readiness, curls endpoints, and
#   scans logs for errors ‚Äî with strict non‚Äëblocking behavior.
#
# WHY
# - Agents shouldn‚Äôt block on long compilation/runtime tasks. This script provides
#   robust timeouts, visible progress, and an async mode that returns immediately
#   while the full validation runs in the background with logs you can tail.
#
# USAGE
#   scripts/qa-sentinel.sh [--app PATH] [--port N] [--keep-alive] [--verbose] [--async] [--deadline SECS]
#
# FLAGS
#   --app PATH       Default: examples/todo-app
#   --port N         Default: 4001 (auto-detect Phoenix-reported port fallback)
#   --env NAME       Mix environment (dev|test|e2e|prod). Default: dev
#   --reuse-db       For non-dev envs, do not drop DB; ensure created + migrate only
#   --seeds PATH     Run a seeds script after migrations (e.g., priv/repo/seeds.e2e.exs)
#   --keep-alive     Do not kill Phoenix on exit; print PHX_PID and PORT
#   --verbose|-v     Print shell commands and tail logs during probes
#   --async          Dispatch pipeline to background and return immediately
#   --deadline SECS  Hard cap: watchdog kills background job after SECS
#   --playwright       After readiness, run Playwright tests (defaults to e2e under --app)
#   --e2e-spec ARG     Playwright spec selector (relative to --app), e.g. e2e or e2e/*.spec.ts
#                       NOTE: pass globs UNQUOTED so the shell expands them: --e2e-spec e2e/*.spec.ts
#   --e2e-workers NUM  Playwright workers to use (default: 1 for determinism in extended runs)
#
# QA LAYERS (Mapping)
#   Layer 1 ‚Äì Compiler snapshot tests (Haxe)
#     - Outside this script; run: `make -C test summary` (and `summary-negative`)
#     - Validates AST‚ÜíElixir printer shapes and transforms deterministically.
#   Layer 2 ‚Äì Integration (compiler‚ÜíPhoenix runtime)
#     - This script Steps 1‚Äì6: Haxe build ‚Üí deps ‚Üí mix compile ‚Üí boot ‚Üí readiness ‚Üí GET / + log scan
#     - Examples:
#         Quick: `scripts/qa-sentinel.sh --app examples/todo-app --port 4001`
#         Async: `scripts/qa-sentinel.sh --app examples/todo-app --port 4001 --async --deadline 300`
#         Keep:  `scripts/qa-sentinel.sh --app examples/todo-app --port 4001 --keep-alive -v`
#   Layer 3 ‚Äì App E2E (browser)
#     - Optional Step 7 when `--playwright` is used
#     - Use a dedicated env `--env e2e` (separate DB, server=true, PORT honored)
#     - Run entire E2E via sentinel: `scripts/qa-sentinel.sh --app examples/todo-app --env e2e --port 4011 --playwright --e2e-spec "e2e/*.spec.ts" --deadline 600`
#     - Or standalone against a keep-alive server: `BASE_URL=http://localhost:$PORT npx -C examples/todo-app playwright test`
#   Testing Trophy Guidance
#     - Most coverage via Haxe-authored ExUnit (LiveView/ConnTest)
#     - Keep Playwright a thin smoke/regression layer (<1 minute total)
#
# TDD LOOP (Recommended)
#   1) Write/adjust a Playwright spec in examples/todo-app/e2e/ to describe the user-visible behavior.
#   2) Start server non-blocking: scripts/qa-sentinel.sh --app examples/todo-app --env e2e --port 4011 --keep-alive -v
#   3) Run: BASE_URL=http://localhost:4001 npx -C examples/todo-app playwright test e2e/<spec>.ts
#   4) Implement the fix generically (no app-coupling) and re-run with --playwright:
#      scripts/qa-sentinel.sh --app examples/todo-app --env e2e --port 4011 --playwright --e2e-spec "e2e/<spec>.ts" --deadline 600
#   --playwright     After readiness, run Playwright tests (examples/todo-app/e2e/*.spec.ts by default)
#   --e2e-spec GLOB  Playwright spec or glob (relative to --app); default: e2e/*.spec.ts
#
# ENV (timeouts/probes)
#   BUILD_TIMEOUT      Haxe build timeout (default: 300s)
#   DEPS_TIMEOUT       mix deps.get timeout (default: 300s)
#   COMPILE_TIMEOUT    mix compile timeout (default: 300s)
#   READY_PROBES       Readiness probes (default: 60) at 0.5s interval
#   PROGRESS_INTERVAL  Heartbeat interval in seconds (default: 10)
#
# OUTPUT / LOGS
#   /tmp/qa-haxe.log         Haxe build output
#   /tmp/qa-mix-deps.log     Mix deps.get output
#   /tmp/qa-mix-compile.log  Mix compile output
#   /tmp/qa-phx.log          Phoenix server output (background)
#   /tmp/qa-index.html       GET / response on success
#   Async mode main log: /tmp/qa-sentinel.<RUN_ID>.log
#
# NON‚ÄëBLOCKING DESIGN
#   - Per‚Äëstep timeouts guard against hangs.
#   - Heartbeat prints progress every PROGRESS_INTERVAL seconds.
#   - Async mode returns immediately with PIDs + log paths; optional watchdog.
#   - Background server is torn down unless --keep-alive is used.
#
# EXAMPLES
#   scripts/qa-sentinel.sh --verbose --async --deadline 120
#   BUILD_TIMEOUT=420s COMPILE_TIMEOUT=420s READY_PROBES=120 \
#     scripts/qa-sentinel.sh --verbose --async --deadline 300
#   PROGRESS_INTERVAL=5 scripts/qa-sentinel.sh --verbose
#
# TROUBLESHOOTING
#   - Haxe stalls:  tail -n 80 /tmp/qa-haxe.log
#   - Mix errors:   tail -n 80 /tmp/qa-mix-*.log
#   - Phoenix boot: tail -n 80 /tmp/qa-phx.log
#   - Kill async:   kill -TERM $QA_SENTINEL_PID
# ============================================================================

# Resolve script dir to reference repo-root tools regardless of cwd
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APP_DIR="examples/todo-app"
PORT=4001
ENV_NAME="dev"
REUSE_DB=0
SEEDS_FILE=""
KEEP_ALIVE=0
VERBOSE=0
# Noise control
NO_HEARTBEAT=0
QUIET=0
# Non-blocking options
ASYNC=0
DEADLINE=""
# Optional E2E
RUN_PLAYWRIGHT=0
E2E_WORKERS=1
# Default to fast, stable smoke specs; override with --e2e-spec as needed
E2E_SPEC="e2e/basic.spec.ts e2e/search.spec.ts e2e/create_todo.spec.ts"
# Timeouts and probe counts (sane defaults; configurable via env)
BUILD_TIMEOUT=${BUILD_TIMEOUT:-300s}
# Optional prewarm to reduce first-build times using the Haxe compilation server
PREWARM_TIMEOUT=${PREWARM_TIMEOUT:-0}
DEPS_TIMEOUT=${DEPS_TIMEOUT:-300s}
COMPILE_TIMEOUT=${COMPILE_TIMEOUT:-300s}
READY_PROBES=${READY_PROBES:-60}
# Heartbeat interval while long steps run (seconds)
PROGRESS_INTERVAL=${PROGRESS_INTERVAL:-10}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --app) APP_DIR="$2"; shift 2 ;;
    --port) PORT="$2"; shift 2 ;;
    --env) ENV_NAME="$2"; shift 2 ;;
    --reuse-db) REUSE_DB=1; shift 1 ;;
    --seeds) SEEDS_FILE="$2"; shift 2 ;;
    --keep-alive) KEEP_ALIVE=1; shift 1 ;;
    --verbose|-v) VERBOSE=1; shift 1 ;;
    --async) ASYNC=1; shift 1 ;;
    --playwright) RUN_PLAYWRIGHT=1; shift 1 ;;
    --e2e-spec) E2E_SPEC="$2"; shift 2 ;;
    --e2e-workers) E2E_WORKERS="$2"; shift 2 ;;
    --no-heartbeat) NO_HEARTBEAT=1; shift 1 ;;
    --quiet|-q) QUIET=1; VERBOSE=0; shift 1 ;;
    --deadline) DEADLINE="$2"; shift 2 ;;
    *) echo "Unknown arg: $1"; exit 2 ;;
  esac
done

# If Playwright is requested and no explicit env provided (still 'dev'),
# default to e2e for proper DB isolation and server settings
if [[ "$RUN_PLAYWRIGHT" -eq 1 && "$ENV_NAME" == "dev" ]]; then
  ENV_NAME="e2e"
fi

ts() { date "+%Y-%m-%d %H:%M:%S"; }
log() { if [[ "${QUIET:-0}" -eq 0 ]]; then echo "[$(ts)] $*"; fi }
run() { if [[ "$VERBOSE" -eq 1 ]]; then set -x; fi; "$@"; local rc=$?; if [[ "$VERBOSE" -eq 1 ]]; then set +x; fi; return $rc; }

# Wrapper to run a command with optional timeout and tee to logfile.
# Usage: run_step "Desc" timeout_secs cmd...  logfile
run_step_with_log() {
  local desc="$1"; shift
  local timeout_val="$1"; shift
  local logfile="$1"; shift
  local cmd="$*"
  local start_ts=$(date +%s)
  log "[QA] ${desc} (timeout=${timeout_val})"
  # Always start with a fresh logfile to avoid surfacing stale lines from prior runs
  : > "$logfile"
  # Start a heartbeat so callers always see forward progress even if the command is quiet
  local heartbeat_pid=""
  if [[ "$NO_HEARTBEAT" -eq 0 ]]; then
    ( while true; do sleep "$PROGRESS_INTERVAL"; log "[QA] .. ${desc} still running"; done ) >/dev/null 2>&1 &
    heartbeat_pid=$!
    # Ensure the heartbeat is always stopped when this function returns without noisy job messages
    local __hb="$heartbeat_pid"
    trap 'if [[ -n "$__hb" ]] && kill -0 "$__hb" 2>/dev/null; then kill "$__hb" 2>/dev/null || true; wait "$__hb" 2>/dev/null || true; fi' RETURN
  fi

  # Prefer our robust PGID/session killer first, then GNU timeout variants, else manual fallback
  local WRAP_TIMEOUT="$SCRIPT_DIR/with-timeout.sh"
  if [[ -x "$WRAP_TIMEOUT" ]]; then
    # Extract numeric seconds (e.g., 300s -> 300) for our wrapper
    local secs
    secs=$(echo "$timeout_val" | sed -E 's/[^0-9]//g')
    if [[ -z "$secs" ]]; then secs=300; fi
    if [[ "$QUIET" -eq 1 ]]; then
      ( "$WRAP_TIMEOUT" --secs "$secs" --cwd "$(pwd)" -- bash -lc "$cmd" >>"$logfile" 2>&1 ); rc=$?
    else
      # tee will write fresh because we truncated above
      ( "$WRAP_TIMEOUT" --secs "$secs" --cwd "$(pwd)" -- bash -lc "$cmd" 2>&1 | tee -a "$logfile" ); rc=${PIPESTATUS[0]:-0}
    fi
  elif command -v timeout >/dev/null 2>&1; then
    if [[ "$QUIET" -eq 1 ]]; then
      ( timeout "$timeout_val" bash -lc "$cmd" >>"$logfile" 2>&1 ); rc=$?
    else
      ( timeout "$timeout_val" bash -lc "$cmd" 2>&1 | tee -a "$logfile" ); rc=${PIPESTATUS[0]:-0}
    fi
  elif command -v gtimeout >/dev/null 2>&1; then
    if [[ "$QUIET" -eq 1 ]]; then
      ( gtimeout "$timeout_val" bash -lc "$cmd" >>"$logfile" 2>&1 ); rc=$?
    else
      ( gtimeout "$timeout_val" bash -lc "$cmd" 2>&1 | tee -a "$logfile" ); rc=${PIPESTATUS[0]:-0}
    fi
  else
    # Manual watchdog fallback (portable): background command and kill after timeout
    # Parse numeric seconds from timeout_val (e.g., 300s -> 300)
    local secs
    secs=$(echo "$timeout_val" | sed -E 's/[^0-9]//g')
    if [[ -z "$secs" ]]; then secs=300; fi
    : > "$logfile"
    # Run command in background; capture PID of the shell, not tee
    # Stream output to logfile; print progress lines if VERBOSE
    set +e
    bash -lc "$cmd" >> "$logfile" 2>&1 &
    local cmd_pid=$!
    local elapsed=0
    while kill -0 "$cmd_pid" >/dev/null 2>&1; do
      sleep 1
      elapsed=$((elapsed+1))
      if (( elapsed % 10 == 0 )); then log "[QA] .. ${desc} running (${elapsed}s/${secs}s)"; fi
      if [[ "$elapsed" -ge "$secs" ]]; then
        log "[QA] ‚è≥ Timeout reached for '${desc}' (${secs}s). Terminating PID $cmd_pid"
        kill -TERM "$cmd_pid" >/dev/null 2>&1 || true
        sleep 1
        kill -KILL "$cmd_pid" >/dev/null 2>&1 || true
        rc=124
        break
      fi
    done
    if [[ "${rc:-0}" -eq 0 ]]; then
      wait "$cmd_pid"; rc=$?
    fi
    set -e
    # Mirror output to console on failure or verbose
    if [[ "$VERBOSE" -eq 1 || ( "$QUIET" -eq 0 && "$rc" -ne 0 ) ]]; then tail -n +1 "$logfile" | tail -n 200; fi
  fi

  local end_ts=$(date +%s)
  local dur=$(( end_ts - start_ts ))
  # Stop heartbeat once step finishes (in addition to RETURN trap)
  if kill -0 "$heartbeat_pid" 2>/dev/null; then kill "$heartbeat_pid" >/dev/null 2>&1 || true; wait "$heartbeat_pid" 2>/dev/null || true; fi
  # Clear the RETURN trap for subsequent calls
  trap - RETURN
  if [[ "$rc" -ne 0 ]]; then
    log "[QA] ‚ùå ${desc} failed (rc=$rc, ${dur}s). Last 100 lines:"
    tail -n 100 "$logfile" || true
    return "$rc"
  fi
  log "[QA] ‚úÖ ${desc} OK (${dur}s)"
  return 0
}

# Best-effort variant: never fails the pipeline; logs informative status
run_step_best_effort() {
  local desc="$1"; shift
  local timeout_val="$1"; shift
  local logfile="$1"; shift
  local cmd="$*"
  # Run the normal step but in a subshell to capture rc without exiting callers
  run_step_with_log "$desc" "$timeout_val" "$logfile" "$cmd" || true
  return 0
}

# Async launcher: re-invoke this script in background and return immediately
if [[ "${ASYNC}" -eq 1 && "${ASYNC_CHILD:-0}" -eq 0 ]]; then
  RUN_ID=$(date +%s)
  LOG_MAIN="/tmp/qa-sentinel.${RUN_ID}.log"
  # Reconstruct flags (omit --async to avoid recursion)
  CHILD_FLAGS=("--app" "$APP_DIR" "--port" "$PORT" "--env" "$ENV_NAME")
  if [[ "$REUSE_DB" -eq 1 ]]; then CHILD_FLAGS+=("--reuse-db"); fi
  if [[ "$KEEP_ALIVE" -eq 1 ]]; then CHILD_FLAGS+=("--keep-alive"); fi
  if [[ "$VERBOSE" -eq 1 ]]; then CHILD_FLAGS+=("--verbose"); fi
  if [[ "$RUN_PLAYWRIGHT" -eq 1 ]]; then CHILD_FLAGS+=("--playwright"); fi
  log "[QA] Async mode: dispatching background sentinel (RUN_ID=$RUN_ID)"
  # Launch background child fully detached; prefer setsid, fallback to nohup
  if command -v setsid >/dev/null 2>&1; then
    setsid env ASYNC_CHILD=1 E2E_SPEC="$E2E_SPEC" BUILD_TIMEOUT="$BUILD_TIMEOUT" DEPS_TIMEOUT="$DEPS_TIMEOUT" COMPILE_TIMEOUT="$COMPILE_TIMEOUT" READY_PROBES="$READY_PROBES" PROGRESS_INTERVAL="$PROGRESS_INTERVAL" PORT="$PORT" APP_DIR="$APP_DIR" KEEP_ALIVE="$KEEP_ALIVE" VERBOSE="$VERBOSE" NO_HEARTBEAT="$NO_HEARTBEAT" QUIET="$QUIET" bash -lc "'$0' ${CHILD_FLAGS[*]}" </dev/null >"$LOG_MAIN" 2>&1 &
  else
    nohup env ASYNC_CHILD=1 E2E_SPEC="$E2E_SPEC" BUILD_TIMEOUT="$BUILD_TIMEOUT" DEPS_TIMEOUT="$DEPS_TIMEOUT" COMPILE_TIMEOUT="$COMPILE_TIMEOUT" READY_PROBES="$READY_PROBES" PROGRESS_INTERVAL="$PROGRESS_INTERVAL" PORT="$PORT" APP_DIR="$APP_DIR" KEEP_ALIVE="$KEEP_ALIVE" VERBOSE="$VERBOSE" NO_HEARTBEAT="$NO_HEARTBEAT" QUIET="$QUIET" bash -lc "'$0' ${CHILD_FLAGS[*]}" </dev/null >"$LOG_MAIN" 2>&1 &
  fi
  SENTINEL_PID=$!
  # Disown the child so shells never warn/wait on background jobs
  { disown "$SENTINEL_PID" 2>/dev/null || true; } >/dev/null 2>&1
  if [[ -n "$DEADLINE" ]]; then
    ( sleep "$DEADLINE"; kill -TERM "$SENTINEL_PID" >/dev/null 2>&1 || true; sleep 1; kill -KILL "$SENTINEL_PID" >/dev/null 2>&1 || true ) </dev/null >/dev/null 2>&1 &
    WATCHDOG_PID=$!
    { disown "$WATCHDOG_PID" 2>/dev/null || true; } >/dev/null 2>&1
    log "[QA] Async watchdog enabled: DEADLINE=$DEADLINE (PID=$WATCHDOG_PID)"
  fi
  echo "QA_SENTINEL_PID=$SENTINEL_PID"
  echo "QA_SENTINEL_RUN_ID=$RUN_ID"
  echo "QA_SENTINEL_LOG=$LOG_MAIN"
  echo "TIP: View logs without blocking: scripts/qa-logpeek.sh --run-id $RUN_ID --last 200 --follow 30" >&2
  exit 0
fi

on_exit() {
  local rc=$?
  # Only report DONE for the actual runner (not the async launcher)
  # ASYNC_CHILD=1 is set for the background process; or ASYNC=0 for sync mode
  if [[ "${ASYNC_CHILD:-0}" -eq 1 || "${ASYNC}" -eq 0 ]]; then
    echo "[$(ts)] [QA] DONE status=${rc}"
  fi
}

trap on_exit EXIT

log "[QA] Starting QA Sentinel in $APP_DIR"
log "[QA] Plan:"
log "[QA]  1) Haxe build (BUILD_TIMEOUT=$BUILD_TIMEOUT)"
log "[QA]  2) mix deps.get (DEPS_TIMEOUT=$DEPS_TIMEOUT)"
log "[QA]  3) mix compile (COMPILE_TIMEOUT=$COMPILE_TIMEOUT)"
log "[QA]  4) Start Phoenix (background, non-blocking)"
log "[QA]  5) Readiness probe (READY_PROBES=$READY_PROBES, 0.5s interval)"
log "[QA]  6) GET /, scan logs, teardown (unless --keep-alive)"
if [[ "$RUN_PLAYWRIGHT" -eq 1 ]]; then
  log "[QA]  7) Run Playwright E2E (spec: ${E2E_SPEC:-e2e}, workers: ${E2E_WORKERS})"
fi
log "[QA] Config: PORT=$PORT ENV=$ENV_NAME KEEP_ALIVE=$KEEP_ALIVE VERBOSE=$VERBOSE"

# Optional overall deadline for synchronous mode too
if [[ -n "${DEADLINE}" && "${ASYNC}" -eq 0 ]]; then
  log "[QA] Overall deadline enabled: ${DEADLINE} (synchronous watchdog)"
  (
    # Use a subshell watchdog to terminate this script if deadline elapses
    sleep "${DEADLINE}" || true
    echo "[$(ts)] [QA] ‚è≥ Overall deadline reached (${DEADLINE}). Collecting logs and terminating."
    # Print last lines of known logs to aid debugging
    for f in /tmp/qa-haxe.log /tmp/qa-mix-deps.log /tmp/qa-mix-compile.log /tmp/qa-phx.log; do
      if [[ -s "$f" ]]; then
        echo "[$(ts)] [QA] --- Tail of ${f} ---"; tail -n 80 "$f"; echo
      fi
    done
    # Send TERM to the main shell to trigger cleanup trap
    kill -TERM $$ >/dev/null 2>&1 || true
  ) &
  OVERALL_WATCHDOG_PID=$!
  # Don‚Äôt keep a disowned child that shells may whine about
  { disown "$OVERALL_WATCHDOG_PID" 2>/dev/null || true; } >/dev/null 2>&1
fi
pushd "$APP_DIR" >/dev/null

# Use a unique build root to avoid lock contention with other shells/editors
RUN_TAG=${RUN_TAG:-$(date +%s)}
QA_BUILD_ROOT=/tmp/qa-build.${RUN_TAG}
mkdir -p "$QA_BUILD_ROOT" >/dev/null 2>&1 || true
# Ensure these are visible to all nested shells invoked via bash -lc
export QA_BUILD_ROOT
export ENV_NAME

# Prefer explicit override, else system haxe, else npx
if [[ -n "${HAXE_CMD:-}" ]]; then
  HAXE_CMD="$HAXE_CMD"
elif command -v haxe >/dev/null 2>&1; then
  HAXE_CMD="haxe"
else
  HAXE_CMD="npx -y haxe"
fi

# Optional: Haxe compilation server for faster repeated builds (warm cache)
HAXE_SERVER_PORT=${HAXE_SERVER_PORT:-6116}
# Default off to avoid hangs on systems without a running server
# Default ON to leverage incremental cache between passes; falls back to direct
# haxe if the server fails to start or connect.
HAXE_USE_SERVER=${HAXE_USE_SERVER:-1}
if [[ "$HAXE_USE_SERVER" -eq 1 ]] && command -v haxe >/dev/null 2>&1; then
  # Best-effort start of the Haxe compilation server; do not rely on nc
  ( nohup haxe --wait "$HAXE_SERVER_PORT" >/tmp/qa-haxe-server.log 2>&1 & echo $! > /tmp/qa-haxe-server.pid ) >/dev/null 2>&1 || true
  # Keep using plain HAXE_CMD unless caller explicitly set HAXE_USE_SERVER=1
  HAXE_CMD="$HAXE_CMD --connect $HAXE_SERVER_PORT"
  # Quick readiness probe (bounded). If the server is not reachable quickly,
  # fall back to direct haxe to avoid spending the entire BUILD_TIMEOUT on a failed handshake.
  # Try for up to ~5s, short polls, then fall back to direct haxe
  READY=0; for i in 1 2 3 4 5; do
    if bash -lc "$HAXE_CMD -version" >/dev/null 2>&1; then READY=1; break; fi
    sleep 0.2
  done
  if [[ "$READY" -ne 1 ]]; then HAXE_CMD="haxe"; fi
fi

# Optional: quick prewarm cycle to populate the server cache so the main build
# reliably fits under the BUILD_TIMEOUT cap on cold environments. This runs the
# same build command but is strictly time-bounded; whatever compiles stays cached.
if [[ "$HAXE_USE_SERVER" -eq 1 && -n "$PREWARM_TIMEOUT" && "$PREWARM_TIMEOUT" != "0" ]]; then
  # Multi-shot prewarm: several short runs to stay under caps while priming cache
  PREWARM_SHOTS=${PREWARM_SHOTS:-6}
  PREWARM_PER_SHOT=${PREWARM_PER_SHOT:-10s}
  for i in $(seq 1 "$PREWARM_SHOTS"); do
    if [[ -f "build-prewarm-fast.hxml" && "$i" -eq 1 ]]; then
      # First shot primes std as fast as possible (JS target); best-effort
      run_step_best_effort "Step 0.${i}: Haxe prewarm (fast std js)" "$PREWARM_PER_SHOT" /tmp/qa-haxe-prewarm.log "$HAXE_CMD build-prewarm-fast.hxml"
    elif [[ -f "build-prewarm.hxml" ]]; then
      # Subsequent shots prime Elixir target macros/compiler cache; best-effort
      run_step_best_effort "Step 0.${i}: Haxe prewarm (elixir target)" "$PREWARM_PER_SHOT" /tmp/qa-haxe-prewarm.log "$HAXE_CMD build-prewarm.hxml"
    else
      run_step_best_effort "Step 0.${i}: Haxe prewarm ($HAXE_CMD build-server.hxml)" "$PREWARM_PER_SHOT" /tmp/qa-haxe-prewarm.log "$HAXE_CMD build-server.hxml"
    fi
  done
fi

# Optional: dependency prewarm to avoid first-time rebar/make latency for
# heavy Erlang deps (best-effort, bounded). Useful on macOS where erlang.mk
# projects like cowlib may trigger additional setup on the first run.
if [[ -n "$PREWARM_TIMEOUT" && "$PREWARM_TIMEOUT" != "0" ]]; then
  run_step_best_effort "Step 1.pre: deps prewarm (cowlib)" "$PREWARM_TIMEOUT" /tmp/qa-deps-prewarm.log "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix deps.compile cowlib --force"
fi

# Generate .ex files. Prefer a fast hxml if available; else, if pass files
# exist, run in two bounded passes to respect strict per-step caps.
if ls build-server-pass*.hxml >/dev/null 2>&1; then
  i=0
  for h in $(ls -1 build-server-pass*.hxml | sort); do
    i=$((i+1))
    # Use the compilation server for all micro‚Äëpasses so later passes reuse cache
    run_step_with_log "Step 1.${i}: Haxe build pass ($HAXE_CMD $h)" "$BUILD_TIMEOUT" "/tmp/qa-haxe-pass${i}.log" "$HAXE_CMD $h" || exit 1
  done
  # Consolidated tail for convenience
  : > /tmp/qa-haxe.log; for h in /tmp/qa-haxe-pass*.log; do tail -n 60 "$h" >> /tmp/qa-haxe.log 2>/dev/null || true; echo >> /tmp/qa-haxe.log; done
elif [[ -f "build-server-fast.hxml" ]]; then
  run_step_with_log "Step 1: Haxe build (fast) ($HAXE_CMD build-server-fast.hxml)" "$BUILD_TIMEOUT" /tmp/qa-haxe.log "$HAXE_CMD build-server-fast.hxml" || exit 1
else
  run_step_with_log "Step 1: Haxe build ($HAXE_CMD build-server.hxml)" "$BUILD_TIMEOUT" /tmp/qa-haxe.log "$HAXE_CMD build-server.hxml" || exit 1
fi

# Optional: dependency prewarm to avoid first-time rebar/make latency for
# heavy Erlang deps (best-effort, bounded). Useful on macOS where erlang.mk
# projects like cowlib may trigger additional setup on the first run.
if [[ -n "$PREWARM_TIMEOUT" && "$PREWARM_TIMEOUT" != "0" ]]; then
  run_step_best_effort "Step 1.pre: deps prewarm (cowlib)" "$PREWARM_TIMEOUT" /tmp/qa-deps-prewarm.log "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix deps.compile cowlib --force"
fi

# Generate .ex files. Prefer a fast hxml if available; else, if pass files
# exist, run in two bounded passes to respect strict per-step caps.
# Optionally skip Haxe generation entirely when sources are unchanged.
if [[ -n "${QA_SKIP_HAXE:-}" ]]; then
  log "[QA] Step 1: Skipping Haxe build (QA_SKIP_HAXE set)"
  : > /tmp/qa-haxe.log
elif [[ -n "${QA_FORCE_FAST_BUILD:-}" ]] && [[ -f "build-server-fast.hxml" ]]; then
  run_step_with_log "Step 1: Haxe build (fast) ($HAXE_CMD build-server-fast.hxml)" "$BUILD_TIMEOUT" /tmp/qa-haxe.log "$HAXE_CMD build-server-fast.hxml" || exit 1
elif ls build-server-pass*.hxml >/dev/null 2>&1; then
  i=0
  for h in $(ls -1 build-server-pass*.hxml | sort); do
    i=$((i+1))
    # Use the compilation server for all micro‚Äëpasses so later passes reuse cache
    run_step_with_log "Step 1.${i}: Haxe build pass ($HAXE_CMD $h)" "$BUILD_TIMEOUT" "/tmp/qa-haxe-pass${i}.log" "$HAXE_CMD $h" || exit 1
  done
  # Consolidated tail for convenience
  : > /tmp/qa-haxe.log; for h in /tmp/qa-haxe-pass*.log; do tail -n 60 "$h" >> /tmp/qa-haxe.log 2>/dev/null || true; echo >> /tmp/qa-haxe.log; done
elif [[ -f "build-server-fast.hxml" ]]; then
  run_step_with_log "Step 1: Haxe build (fast) ($HAXE_CMD build-server-fast.hxml)" "$BUILD_TIMEOUT" /tmp/qa-haxe.log "$HAXE_CMD build-server-fast.hxml" || exit 1
else
  run_step_with_log "Step 1: Haxe build ($HAXE_CMD build-server.hxml)" "$BUILD_TIMEOUT" /tmp/qa-haxe.log "$HAXE_CMD build-server.hxml" || exit 1
fi

run_step_with_log "Step 2: mix deps.get" "$DEPS_TIMEOUT" /tmp/qa-mix-deps.log "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix deps.get" || exit 1

# Workaround for cowlib hex packaging without rebar.config on some systems:
# if deps/cowlib/rebar.config is missing, create a minimal one that includes
# the local include/ dir so rebar3 passes -I include to erlc.
if [[ -d "deps/cowlib" && ! -f "deps/cowlib/rebar.config" ]]; then
  echo "{erl_opts, [{i, \"include\"}]}."> "deps/cowlib/rebar.config"
fi

# Precompile critical Erlang deps to avoid include path races during main compile
run_step_with_log "Step 2.1: deps precompile (cowboy)" 180s /tmp/qa-deps-precompile.log "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix deps.compile cowboy --force" || exit 1

# Prepare database and runtime after compile. Robust deps compile to avoid
# rebar include_lib issues under per-run MIX_BUILD_ROOT.
# Always compile deps in the default root (unset MIX_BUILD_ROOT), then mirror to per-run root.
run_step_with_log "Step 2.1: deps compile (default root)" 240s /tmp/qa-deps-compile-default.log "bash -lc 'unset MIX_BUILD_ROOT; MIX_ENV=$ENV_NAME mix deps.compile --force'" || exit 1
# Mirror artifacts with symlink dereference so priv/include are real files in MIX_BUILD_ROOT
run_step_with_log "Step 2.2: mirror deps to MIX_BUILD_ROOT" 60s /tmp/qa-deps-mirror.log "bash -lc 'mkdir -p \"$QA_BUILD_ROOT/$ENV_NAME/lib\" && rsync -aL --delete \"_build/$ENV_NAME/lib/\" \"$QA_BUILD_ROOT/$ENV_NAME/lib/\"'" || exit 1

# Compile first so DB tasks do not incur compile cost repeatedly
# Compile application only (skip deps recompile inside per-run root to avoid rebar include_lib issues)
if ! run_step_with_log "Step 3: mix compile (no deps)" "$COMPILE_TIMEOUT" /tmp/qa-mix-compile.log "HAXE_NO_COMPILE=1 HAXE_NO_SERVER=1 MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix compile --no-deps-check"; then
  # As a bounded fallback, attempt normal compile once more
  run_step_with_log "Step 3 (retry): mix compile" "$COMPILE_TIMEOUT" /tmp/qa-mix-compile.log "HAXE_NO_COMPILE=1 HAXE_NO_SERVER=1 MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix compile" || exit 1
fi
if [[ "$ENV_NAME" != "dev" ]]; then
  if [[ "$REUSE_DB" -eq 1 ]]; then
    run_step_with_log "DB ensure ($ENV_NAME)" 120s /tmp/qa-mix-db-ensure.log "MIX_ENV=$ENV_NAME mix ecto.create --quiet" || true
    run_step_with_log "DB migrate ($ENV_NAME)" 300s /tmp/qa-mix-db-migrate.log "MIX_ENV=$ENV_NAME mix ecto.migrate" || exit 1
  else
    run_step_with_log "DB drop ($ENV_NAME)" 120s /tmp/qa-mix-db-drop.log "MIX_ENV=$ENV_NAME mix ecto.drop --quiet" || true
    run_step_with_log "DB create ($ENV_NAME)" 120s /tmp/qa-mix-db-create.log "MIX_ENV=$ENV_NAME mix ecto.create --quiet" || true
    run_step_with_log "DB migrate ($ENV_NAME)" 300s /tmp/qa-mix-db-migrate.log "MIX_ENV=$ENV_NAME mix ecto.migrate" || exit 1
  fi
  if [[ -n "$SEEDS_FILE" ]]; then
    run_step_with_log "DB seeds ($ENV_NAME)" 180s /tmp/qa-mix-db-seeds.log "MIX_ENV=$ENV_NAME mix run '$SEEDS_FILE'" || exit 1
  fi
fi

# Build static assets (JS/CSS) so LiveView client and UI interactions are available
run_step_with_log "Assets build ($ENV_NAME)" 300s /tmp/qa-assets-build.log "MIX_ENV=$ENV_NAME mix assets.build" || true

# Ensure no stale Phoenix server is occupying the target port (or default :4000)
for P in "$PORT" 4000; do
  if command -v lsof >/dev/null 2>&1; then
    PIDLIST=$(lsof -ti tcp:"$P" -sTCP:LISTEN || true)
    if [ -n "$PIDLIST" ]; then
      echo "[QA] Detected process on :$P ‚Üí killing: $PIDLIST"
      kill -9 $PIDLIST >/dev/null 2>&1 || true
      sleep 0.5
    fi
  elif command -v ss >/dev/null 2>&1; then
    PIDS=$(ss -ltnp 2>/dev/null | awk -v p=":$P" '$4 ~ p {print $6}' | sed -E 's/.*pid=([0-9]+),.*/\1/' | sort -u)
    if [ -n "$PIDS" ]; then
      echo "[QA] Detected process on :$P ‚Üí killing: $PIDS"
      kill -9 $PIDS >/dev/null 2>&1 || true
      sleep 0.5
    fi
  fi
done

log "[QA] Step 4: Starting Phoenix server on :$PORT (background, non-blocking)"
export PORT="$PORT"
# Start Phoenix in the background, detached when possible, and capture PID/PGID
# Prefer setsid; on macOS where `setsid` may not exist, fall back to perl POSIX::setsid;
# if neither available, start normally but ensure cleanup never targets our own PGID.
if command -v setsid >/dev/null 2>&1; then
  setsid sh -c "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix phx.server" >/tmp/qa-phx.log 2>&1 &
elif command -v perl >/dev/null 2>&1; then
  # Create a new session via perl; then exec a shell to run the server
  nohup perl -MPOSIX -e 'POSIX::setsid() or die "setsid failed: $!"; exec @ARGV' \
    sh -c "MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix phx.server" >/tmp/qa-phx.log 2>&1 &
else
  # Fallback: still background, but guard cleanup to avoid killing our own process group
  nohup env MIX_ENV=$ENV_NAME MIX_BUILD_ROOT=$QA_BUILD_ROOT mix phx.server >/tmp/qa-phx.log 2>&1 &
fi
PHX_PID=$!
PGID=$(ps -o pgid= "$PHX_PID" 2>/dev/null | tr -d ' ' || true)
# Our own process group (for safety checks during cleanup)
MY_PGID=$(ps -o pgid= $$ 2>/dev/null | tr -d ' ' || true)
log "[QA] Phoenix started: PHX_PID=$PHX_PID PGID=$PGID (logs: /tmp/qa-phx.log)"

cleanup() {
  # Prefer killing the Phoenix process group when it is distinct from our own.
  # This prevents terminating the host CLI when the server wasn't started in a new session.
  if [[ -n "$PGID" && -n "$MY_PGID" && "$PGID" != "$MY_PGID" ]]; then
    kill -TERM -"$PGID" >/dev/null 2>&1 || true
    sleep 0.5
    kill -KILL -"$PGID" >/dev/null 2>&1 || true
  fi
  # Always try to terminate the server PID directly
  kill "$PHX_PID" >/dev/null 2>&1 || true
  # Extra safety: kill anything still listening on the port
  if command -v lsof >/dev/null 2>&1; then
    PIDS=$(lsof -ti tcp:"$PORT" -sTCP:LISTEN || true)
    if [[ -n "$PIDS" ]]; then kill -9 $PIDS >/dev/null 2>&1 || true; fi
  elif command -v ss >/dev/null 2>&1; then
    PIDS=$(ss -ltnp 2>/dev/null | awk -v p=":$PORT" '$4 ~ p {print $6}' | sed -E 's/.*pid=([0-9]+),.*/\1/' | sort -u)
    if [[ -n "$PIDS" ]]; then kill -9 $PIDS >/dev/null 2>&1 || true; fi
  fi
}

if [[ "$KEEP_ALIVE" -eq 0 ]]; then
  trap cleanup EXIT
fi

log "[QA] Step 5: Waiting for server readiness (probes=$READY_PROBES)"
READY=0
for i in $(seq 1 "$READY_PROBES"); do
  if curl -fsS "http://localhost:$PORT" >/dev/null 2>&1; then
    READY=1; break
  fi
  # If not ready, see if endpoint reported a different port
  DETECTED_PORT=$(grep -Eo 'http://localhost:[0-9]+' /tmp/qa-phx.log 2>/dev/null | tail -n1 | sed -E 's/.*:([0-9]+)/\1/' || true)
  if [[ -z "$DETECTED_PORT" ]]; then
    DETECTED_PORT=$(grep -Eo '127\.0\.0\.1:[0-9]+' /tmp/qa-phx.log 2>/dev/null | tail -n1 | sed -E 's/.*:([0-9]+)/\1/' || true)
  fi
  if [[ -n "$DETECTED_PORT" ]] && curl -fsS "http://localhost:$DETECTED_PORT" >/dev/null 2>&1; then
    PORT="$DETECTED_PORT"; READY=1; break
  fi
  log "[QA] Probe $i/$READY_PROBES: not ready yet (PORT=$PORT)."
  if [[ "$VERBOSE" -eq 1 ]]; then
    log "[QA] Last 20 phoenix log lines:"; tail -n 20 /tmp/qa-phx.log || true
  fi
  sleep 0.5
done

if [[ "$READY" -ne 1 ]]; then
  log "[QA] ‚ùå Server did not become ready. Last 200 log lines:"
  tail -n 200 /tmp/qa-phx.log || true
  cleanup || true
  exit 1
fi

log "[QA] Step 6: GET / (strict 2xx)"
if ! curl -fsS "http://localhost:$PORT/" >/tmp/qa-index.html 2>/dev/null; then
  log "[QA] ‚ùå GET / did not return 2xx. Last 200 log lines:"
  tail -n 200 /tmp/qa-phx.log || true
  cleanup || true
  exit 1
fi

# Optional: probe /todos if route exists
curl -fsS "http://localhost:$PORT/todos" >/dev/null 2>&1 || true

# Scan logs for runtime errors
if command -v rg >/dev/null 2>&1; then
  if rg -n "(CompileError|UndefinedFunctionError|ArgumentError|FunctionClauseError|KeyError|RuntimeError|\(EXIT\)|\bError\b)" /tmp/qa-phx.log >/dev/null 2>&1; then
    log "[QA] ‚ùå Runtime errors detected in logs"
    rg -n "(CompileError|UndefinedFunctionError|ArgumentError|FunctionClauseError|KeyError|RuntimeError|\(EXIT\)|\bError\b)" /tmp/qa-phx.log | tail -n 100
    cleanup || true
    exit 1
  fi
else
  if grep -E "CompileError|UndefinedFunctionError|ArgumentError|FunctionClauseError|KeyError|RuntimeError|\(EXIT\)|\bError\b" /tmp/qa-phx.log >/dev/null 2>&1; then
    log "[QA] ‚ùå Runtime errors detected in logs"
    tail -n 100 /tmp/qa-phx.log
    cleanup || true
    exit 1
  fi
fi

log "[QA] OK: build + runtime smoke passed with zero warnings (WAE)"

# Optional: run Playwright tests after readiness
if [[ "$RUN_PLAYWRIGHT" -eq 1 ]]; then
  log "[QA] Step 7: Running Playwright tests (${E2E_SPEC:-e2e}, workers: ${E2E_WORKERS})"
  # Install dependencies and browsers for Playwright in the app dir
  run_step_with_log "Playwright npm install" 180s /tmp/qa-playwright-install.log "npm -C . install --no-audit --no-fund" || { cleanup || true; exit 1; }
  run_step_with_log "Playwright browsers install" 600s /tmp/qa-playwright-browsers.log "npx -C . playwright install" || { cleanup || true; exit 1; }
  # Important: do NOT quote the spec so that shell globs expand (e.g., e2e/*.spec.ts)
  SPEC_ARG=${E2E_SPEC:-e2e}
  if ! BASE_URL="http://localhost:$PORT" bash -lc "npx -C . playwright test ${SPEC_ARG} --workers=${E2E_WORKERS}" >/tmp/qa-playwright-run.log 2>&1; then
    log "[QA] ‚ùå Playwright tests failed. Last 120 lines:"
    tail -n 120 /tmp/qa-playwright-run.log || true
    cleanup || true
    exit 1
  fi
  log "[QA] ‚úÖ Playwright tests passed"
fi

if [[ "$KEEP_ALIVE" -eq 1 ]]; then
  log "[QA] KEEP-ALIVE enabled. Phoenix continues running."
  echo "PHX_PID=$PHX_PID"
  echo "PORT=$PORT"
fi
popd >/dev/null
</file>

</files>
