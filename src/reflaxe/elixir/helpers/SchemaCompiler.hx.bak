package reflaxe.elixir.helpers;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import reflaxe.BaseCompiler;
import reflaxe.elixir.helpers.NamingHelper;

using reflaxe.helpers.NullHelper;
using reflaxe.helpers.NameMetaHelper;
using reflaxe.helpers.SyntaxHelper;
using reflaxe.helpers.TypedExprHelper;
using StringTools;

/**
 * Schema and Changeset Compiler for Reflaxe.Elixir
 * 
 * WHY: Ecto schemas and changesets are fundamental to Phoenix applications.
 * This compiler provides type-safe generation of Ecto schemas with automatic
 * changeset functions, validations, and associations.
 * 
 * WHAT: Handles compilation of classes annotated with:
 * - @:schema - Generates Ecto schema modules with fields and types
 * - @:changeset - Generates changeset functions with validations
 * - Field metadata for types, defaults, and validations
 * - Association definitions (has_many, belongs_to, etc.)
 * 
 * HOW:
 * 1. Extract schema metadata and field annotations
 * 2. Generate Ecto schema definition with proper types
 * 3. Create changeset functions with validations
 * 4. Handle associations and embedded schemas
 * 5. Generate query helpers and custom functions
 * 
 * @see documentation/ECTO_INTEGRATION.md - Complete Ecto integration guide
 */
@:nullSafety(Off)
class SchemaCompiler {
    
    var compiler: reflaxe.elixir.ElixirCompiler; // ElixirCompiler reference
    
    /**
     * Create a new schema compiler
     * 
     * @param compiler The main ElixirCompiler instance
     */
    public function new(compiler: reflaxe.elixir.ElixirCompiler) {
        this.compiler = compiler;
    }
    
    /**
     * Compile a class annotated with @:schema
     * 
     * WHY: Ecto schemas need specific module structure with use Ecto.Schema,
     * field definitions, and changeset functions.
     * 
     * WHAT: Generates a complete Ecto schema module including:
     * - Module definition with use Ecto.Schema
     * - Schema block with field definitions
     * - Changeset function with validations
     * - Timestamps and associations
     * - Query helpers and custom functions
     * 
     * HOW:
     * 1. Extract table name from metadata or class name
     * 2. Process each field for type and options
     * 3. Generate schema block with proper syntax
     * 4. Create changeset with validations
     * 5. Add custom functions from class methods
     * 
     * @param classType The class type information
     * @param varFields Variable fields (schema fields)
     * @param funcFields Function fields (custom methods)
     * @return Generated Ecto schema module code
     */
    public function compileSchemaClass(
        classType: ClassType, 
        varFields: Array<Dynamic>, // ClassVarData
        funcFields: Array<Dynamic>  // ClassFuncData
    ): String {
        
        #if debug_schema
        trace('[SchemaCompiler] Compiling schema class: ${classType.name}');
        trace('[SchemaCompiler] Fields: ${varFields.length}, Functions: ${funcFields.length}');
        #end
        
        var moduleName = compiler.getModuleName(classType);
        var tableName = extractTableName(classType);
        
        // Generate module header
        var result = 'defmodule ${moduleName} do\n';
        result += '  use Ecto.Schema\n';
        result += '  import Ecto.Changeset\n\n';
        
        // Generate schema block
        result += '  schema "${tableName}" do\n';
        result += generateSchemaFields(varFields);
        result += '\n    timestamps()\n';
        result += '  end\n\n';
        
        // Generate changeset function
        result += generateChangesetFunction(classType, varFields);
        
        // Generate custom functions
        for (funcField in funcFields) {
            if (!isSpecialFunction(funcField.name)) {
                result += '\n' + compiler.compileFunction(funcField, true);
            }
        }
        
        result += 'end\n';
        
        #if debug_schema
        trace('[SchemaCompiler] Generated schema module: ${result.substring(0, 200)}...');
        #end
        
        return result;
    }
    
    /**
     * Compile a class annotated with @:changeset
     * 
     * WHY: Some classes need custom changeset logic beyond the default
     * 
     * WHAT: Generates a module focused on changeset operations:
     * - Multiple changeset functions for different contexts
     * - Complex validations and transformations
     * - Custom error handling
     * 
     * @param classType The class type information
     * @param varFields Variable fields
     * @param funcFields Function fields (changeset methods)
     * @return Generated changeset module code
     */
    public function compileChangesetClass(
        classType: ClassType,
        varFields: Array<Dynamic>,
        funcFields: Array<Dynamic>
    ): String {
        
        #if debug_schema
        trace('[SchemaCompiler] Compiling changeset class: ${classType.name}');
        #end
        
        var moduleName = compiler.getModuleName(classType);
        
        var result = 'defmodule ${moduleName} do\n';
        result += '  import Ecto.Changeset\n\n';
        
        // Compile each changeset function
        for (funcField in funcFields) {
            result += compiler.compileFunction(funcField, true) + '\n';
        }
        
        result += 'end\n';
        
        return result;
    }
    
    // ================== Private Helper Methods ==================
    
    /**
     * Extract table name from class metadata or generate from class name
     */
    private function extractTableName(classType: ClassType): String {
        var tableMeta = classType.meta.extract(":table");
        if (tableMeta != null && tableMeta.length > 0) {
            return switch (tableMeta[0].params[0].expr) {
                case EConst(CString(s)): s;
                default: pluralizeTableName(classType.name);
            };
        }
        return pluralizeTableName(classType.name);
    }
    
    /**
     * Simple pluralization for table names
     */
    private function pluralizeTableName(name: String): String {
        var snakeName = NamingHelper.toSnakeCase(name);
        // Simple pluralization rules
        if (snakeName.endsWith("y")) {
            return snakeName.substring(0, snakeName.length - 1) + "ies";
        } else if (snakeName.endsWith("s") || snakeName.endsWith("x") || snakeName.endsWith("ch")) {
            return snakeName + "es";
        } else {
            return snakeName + "s";
        }
    }
    
    /**
     * Generate schema field definitions
     */
    private function generateSchemaFields(varFields: Array<Dynamic>): String {
        var fields: Array<String> = [];
        
        for (varField in varFields) {
            var fieldName = NamingHelper.toSnakeCase(varField.name);
            var fieldType = mapHaxeTypeToEcto(varField.type);
            var options = extractFieldOptions(varField);
            
            if (options.length > 0) {
                fields.push('    field :${fieldName}, ${fieldType}, ${options.join(", ")}');
            } else {
                fields.push('    field :${fieldName}, ${fieldType}');
            }
        }
        
        return fields.join("\n") + (fields.length > 0 ? "\n" : "");
    }
    
    /**
     * Map Haxe types to Ecto field types
     */
    private function mapHaxeTypeToEcto(type: Type): String {
        return switch (type) {
            case TInst(t, _):
                switch (t.get().name) {
                    case "String": ":string";
                    case "Date": ":utc_datetime";
                    case "Array": ":array";
                    default: ":string";
                }
            case TAbstract(t, _):
                switch (t.get().name) {
                    case "Int": ":integer";
                    case "Float": ":float";
                    case "Bool": ":boolean";
                    default: ":string";
                }
            default: ":string";
        };
    }
    
    /**
     * Extract field options from metadata
     */
    private function extractFieldOptions(varField: Dynamic): Array<String> {
        var options: Array<String> = [];
        
        // Check for :default metadata
        if (varField.meta != null) {
            var defaultMeta = varField.meta.extract(":default");
            if (defaultMeta != null && defaultMeta.length > 0) {
                options.push('default: ${compiler.compileExpr(defaultMeta[0].params[0])}');
            }
            
            // Check for :nullable
            var nullableMeta = varField.meta.extract(":nullable");
            if (nullableMeta != null && nullableMeta.length > 0) {
                options.push('nullable: true');
            }
        }
        
        return options;
    }
    
    /**
     * Generate the default changeset function
     */
    private function generateChangesetFunction(classType: ClassType, varFields: Array<Dynamic>): String {
        var schemaVar = NamingHelper.toSnakeCase(classType.name);
        var requiredFields: Array<String> = [];
        var optionalFields: Array<String> = [];
        
        // Categorize fields
        for (varField in varFields) {
            var fieldName = NamingHelper.toSnakeCase(varField.name);
            if (isRequiredField(varField)) {
                requiredFields.push(':${fieldName}');
            } else {
                optionalFields.push(':${fieldName}');
            }
        }
        
        var allFields = requiredFields.concat(optionalFields);
        
        var result = '  def changeset(${schemaVar}, attrs) do\n';
        result += '    ${schemaVar}\n';
        result += '    |> cast(attrs, [${allFields.join(", ")}])\n';
        
        if (requiredFields.length > 0) {
            result += '    |> validate_required([${requiredFields.join(", ")}])\n';
        }
        
        // Add custom validations from metadata
        result += generateValidations(classType, varFields);
        
        result += '  end\n';
        
        return result;
    }
    
    /**
     * Check if a field is required
     */
    private function isRequiredField(varField: Dynamic): Bool {
        if (varField.meta == null) return false;
        var requiredMeta = varField.meta.extract(":required");
        return requiredMeta != null && requiredMeta.length > 0;
    }
    
    /**
     * Generate validation pipeline from metadata
     */
    private function generateValidations(classType: ClassType, varFields: Array<Dynamic>): String {
        var validations: Array<String> = [];
        
        for (varField in varFields) {
            if (varField.meta == null) continue;
            
            var fieldName = NamingHelper.toSnakeCase(varField.name);
            
            // Length validation
            var lengthMeta = varField.meta.extract(":length");
            if (lengthMeta != null && lengthMeta.length > 0) {
                validations.push('    |> validate_length(:${fieldName}, ${compiler.compileExpr(lengthMeta[0].params[0])})');
            }
            
            // Format validation
            var formatMeta = varField.meta.extract(":format");
            if (formatMeta != null && formatMeta.length > 0) {
                validations.push('    |> validate_format(:${fieldName}, ${compiler.compileExpr(formatMeta[0].params[0])})');
            }
            
            // Unique constraint
            var uniqueMeta = varField.meta.extract(":unique");
            if (uniqueMeta != null && uniqueMeta.length > 0) {
                validations.push('    |> unique_constraint(:${fieldName})');
            }
        }
        
        return validations.join("\n") + (validations.length > 0 ? "\n" : "");
    }
    
    /**
     * Check if a function is a special schema function
     */
    private function isSpecialFunction(name: String): Bool {
        return name == "new" || name == "changeset" || name == "__construct";
    }
}

#end