package reflaxe.elixir.helpers;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import reflaxe.BaseCompiler;
import reflaxe.elixir.helpers.NamingHelper;

using reflaxe.helpers.NullHelper;
using reflaxe.helpers.NameMetaHelper;
using reflaxe.helpers.SyntaxHelper;
using reflaxe.helpers.TypedExprHelper;

/**
 * Migration Compiler for Reflaxe.Elixir
 * 
 * WHY: Database migrations are critical for Phoenix applications.
 * This compiler enables type-safe migration definitions in Haxe that
 * compile to proper Ecto migration modules.
 * 
 * WHAT: Handles compilation of classes annotated with @:migration:
 * - Generates Ecto.Migration modules with up/down functions
 * - Table creation, modification, and deletion
 * - Index and constraint management
 * - Column operations with type mapping
 * - Execute raw SQL support
 * 
 * HOW:
 * 1. Extract migration metadata and version
 * 2. Generate module with use Ecto.Migration
 * 3. Compile up() and down() functions
 * 4. Transform Haxe migration DSL to Ecto DSL
 * 5. Handle timestamps and references
 * 
 * @see documentation/ECTO_MIGRATION.md - Complete migration guide
 */
@:nullSafety(Off)
class MigrationCompiler {
    
    var compiler: reflaxe.elixir.ElixirCompiler; // ElixirCompiler reference
    
    /**
     * Create a new migration compiler
     * 
     * @param compiler The main ElixirCompiler instance
     */
    public function new(compiler: reflaxe.elixir.ElixirCompiler) {
        this.compiler = compiler;
    }
    
    /**
     * Compile a class annotated with @:migration
     * 
     * WHY: Ecto migrations need specific module structure with
     * use Ecto.Migration and up/down functions.
     * 
     * WHAT: Generates a complete migration module including:
     * - Module definition with timestamp prefix
     * - use Ecto.Migration directive
     * - up() function for forward migration
     * - down() function for rollback
     * - Helper functions for complex migrations
     * 
     * HOW:
     * 1. Extract migration name and options
     * 2. Generate module with proper naming
     * 3. Find and compile up/down functions
     * 4. Add helper methods if present
     * 5. Ensure reversible operations
     * 
     * @param classType The class type information
     * @param varFields Variable fields (usually empty for migrations)
     * @param funcFields Function fields (up, down, helpers)
     * @return Generated Ecto migration module code
     */
    public function compileMigrationClass(
        classType: ClassType,
        varFields: Array<Dynamic>, // ClassVarData
        funcFields: Array<Dynamic>  // ClassFuncData
    ): String {
        
        #if debug_migration
        trace('[MigrationCompiler] Compiling migration class: ${classType.name}');
        trace('[MigrationCompiler] Functions: ${funcFields.length}');
        #end
        
        var moduleName = compiler.getModuleName(classType);
        
        // Generate module header
        var result = 'defmodule ${moduleName} do\n';
        result += '  use Ecto.Migration\n\n';
        
        // Find and compile up/down functions
        var upFunction = findFunction(funcFields, "up");
        var downFunction = findFunction(funcFields, "down");
        
        if (upFunction != null) {
            result += compileMigrationFunction(upFunction, "up");
        } else {
            // Generate default empty up function
            result += '  def up do\n    # Migration up logic here\n  end\n\n';
        }
        
        if (downFunction != null) {
            result += compileMigrationFunction(downFunction, "down");
        } else {
            // Generate default empty down function
            result += '  def down do\n    # Migration down logic here\n  end\n\n';
        }
        
        // Compile helper functions
        for (funcField in funcFields) {
            var name = funcField.name;
            if (name != "up" && name != "down" && name != "new") {
                result += compiler.compileFunction(funcField, true) + '\n';
            }
        }
        
        result += 'end\n';
        
        #if debug_migration
        trace('[MigrationCompiler] Generated migration: ${result.substring(0, 200)}...');
        #end
        
        return result;
    }
    
    // ================== Private Helper Methods ==================
    
    /**
     * Find a function by name in the function fields
     */
    private function findFunction(funcFields: Array<Dynamic>, name: String): Dynamic {
        for (funcField in funcFields) {
            if (funcField.name == name) {
                return funcField;
            }
        }
        return null;
    }
    
    /**
     * Compile a migration function (up or down)
     */
    private function compileMigrationFunction(funcField: Dynamic, name: String): String {
        // Special handling for migration DSL methods
        return '  def ${name} do\n' +
               compileMigrationBody(funcField.expr) +
               '  end\n\n';
    }
    
    /**
     * Compile the body of a migration function
     */
    private function compileMigrationBody(expr: TypedExpr): String {
        // This would need special handling for migration DSL
        // For now, delegate to main compiler
        var body = compiler.compileExpression(expr);
        
        // Indent the body
        var lines = body.split('\n');
        return lines.map(line -> '    ' + line).join('\n') + '\n';
    }
}

#end