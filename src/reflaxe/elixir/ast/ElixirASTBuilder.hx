package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import haxe.macro.Context;
import reflaxe.elixir.ast.ElixirAST;
using reflaxe.helpers.TypedExprHelper;
using reflaxe.helpers.TypeHelper;
using StringTools;

/**
 * ElixirASTBuilder: TypedExpr to ElixirAST Converter (Analysis Phase)
 * 
 * WHY: Bridge between Haxe's TypedExpr and our ElixirAST representation
 * - Preserves all semantic information from Haxe's type system
 * - Enriches nodes with metadata for later transformation phases
 * - Separates AST construction from string generation
 * - Enables multiple transformation passes on strongly-typed structure
 * 
 * WHAT: Converts Haxe TypedExpr nodes to corresponding ElixirAST nodes
 * - Handles all expression types (literals, variables, operations, calls)
 * - Captures type information and source positions
 * - Detects patterns that need special handling (e.g., array operations)
 * - Maintains context through metadata enrichment
 * 
 * HOW: Recursive pattern matching on TypedExpr with metadata preservation
 * - Each TypedExpr constructor maps to one or more ElixirAST nodes
 * - Metadata carries context through the entire pipeline
 * - Complex expressions decomposed into simpler AST nodes
 * - Pattern detection integrated into conversion process
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Only converts AST formats, no code generation
 * - Open/Closed: Easy to add new node types without modifying existing
 * - Testability: Can test AST conversion independently of generation
 * - Maintainability: Clear separation from transformation and printing
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTBuilder {
    
    // Counter for generating unique loop function names
    static var loopCounter: Int = 0;
    
    // Map for renaming temporary underscore variables generated by Haxe
    // Key is the TVar.id (as String), value is the renamed variable name
    public static var tempVarRenameMap: Map<String, String> = new Map();
    
    // Set of function parameter IDs to avoid collision detection on them
    // These are intentional parameter names, not collision-renamed variables
    public static var functionParameterIds: Map<String, Bool> = new Map();
    
    // Flag to indicate we're building a class method body
    // When true, don't convert camelCase parameters to snake_case
    public static var isInClassMethodContext: Bool = false;
    
    /**
     * Main entry point: Convert TypedExpr to ElixirAST
     * 
     * WHY: Single entry point for all AST conversion
     * WHAT: Recursively converts TypedExpr tree to ElixirAST tree
     * HOW: Pattern matches on expr type and delegates to specific handlers
     */
    /**
     * Replace TLocal references to a temp var with inline null coalescing pattern
     */
    static function replaceNullCoalVar(expr: TypedExpr, varId: Int, initExpr: TypedExpr): TypedExpr {
        return switch(expr.expr) {
            case TBinop(OpNullCoal, {expr: TLocal(v)}, defaultExpr) if (v.id == varId):
                // Replace with inline null coalescing that includes the init expression
                {
                    expr: TBinop(OpNullCoal, initExpr, defaultExpr),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case TVar(v, init) if (init != null):
                // Variable declaration with initialization - recurse into init
                {
                    expr: TVar(v, replaceNullCoalVar(init, varId, initExpr)),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case TObjectDecl(fields):
                // Object declaration - recurse into field values
                var newFields = [for (field in fields) {
                    name: field.name,
                    expr: replaceNullCoalVar(field.expr, varId, initExpr)
                }];
                {
                    expr: TObjectDecl(newFields),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case _:
                // No transformation needed
                expr;
        }
    }
    
    public static function buildFromTypedExpr(expr: TypedExpr): ElixirAST {
        #if debug_ast_builder
        trace('[XRay AST Builder] Converting TypedExpr: ${expr.expr}');
        #end
        
        var metadata = createMetadata(expr);
        var astDef = convertExpression(expr);
        
        // ONLY mark metadata - NO transformation in builder!
        switch(expr.expr) {
            case TCall(e, _) if (e != null && isEnumConstructor(e) && hasIdiomaticMetadata(e)):
                metadata.requiresIdiomaticTransform = true;
                metadata.idiomaticEnumType = getEnumTypeName(e);
                #if debug_ast_builder
                trace('[AST Builder] Marked enum tuple for transformer: ${getEnumTypeName(e)}');
                #end
            default:
        }
        
        var result = makeASTWithMeta(astDef, metadata, expr.pos);
        
        #if debug_ast_builder
        trace('[XRay AST Builder] Generated AST: ${astDef}');
        #end
        
        return result;
    }
    
    /**
     * Convert TypedExprDef to ElixirASTDef
     */
    static function convertExpression(expr: TypedExpr): ElixirASTDef {
        return switch(expr.expr) {
            // ================================================================
            // Literals and Constants
            // ================================================================
            case TConst(TInt(i)):
                EInteger(i);
                
            case TConst(TFloat(f)):
                EFloat(Std.parseFloat(f));
                
            case TConst(TString(s)):
                EString(s);
                
            case TConst(TBool(b)):
                EBoolean(b);
                
            case TConst(TNull):
                ENil;
                
            case TConst(TThis):
                // In Elixir, 'this' refers to the first parameter of instance methods (usually 'struct')
                // This will be handled by the transformer or the function compiler
                // For now, use a placeholder that will be replaced
                EVar("struct");
                
            case TConst(TSuper):
                // Elixir doesn't have super - this needs special handling
                // Generally should not appear in valid code
                // For now, just return nil since super isn't supported in Elixir
                ENil;
                
            // ================================================================
            // Variables and Binding
            // ================================================================
            case TLocal(v):
                // Check if this is a renamed parameter (e.g., priority2 -> priority)
                var varName = v.name;
                var idKey = Std.string(v.id);
                var wasMapped = false;
                
                // Always debug variables that might be renamed
                #if debug_ast_pipeline
                if (varName.indexOf("priority") >= 0 || varName.indexOf("_") >= 0 || ~/\d$/.match(varName) || varName.indexOf("this") >= 0 || varName.indexOf("struct") >= 0) {
                    trace('[AST Builder] TLocal variable: name="${varName}", id=${v.id}, pos=${expr.pos}');
                }
                #end
                
                // Check if this variable has been registered as a function parameter
                // or has an explicit mapping (from TFunction processing)
                if (tempVarRenameMap.exists(idKey)) {
                    // Use the explicitly mapped name - it's already in Elixir format (snake_case)
                    varName = tempVarRenameMap.get(idKey);
                    wasMapped = true;
                    
                    #if debug_ast_pipeline
                    trace('[AST Builder] Using mapped name for id=${v.id}: ${v.name} -> ${varName}');
                    #end
                }
                // Handle Haxe-generated temp variables that start with underscore
                // These are variables like _g, _g1, etc. that Haxe generates during desugaring
                // In Elixir, underscore-prefixed variables should not be used after assignment
                // So we create a mapping to rename them consistently
                else if (varName.charAt(0) == "_" && varName.length > 1) {
                    // Create a new non-underscore name for this temp variable
                    var newName = if (~/^_g\d*$/.match(varName)) {
                        // _g, _g1, _g2 -> g, g1, g2
                        varName.substr(1);
                    } else if (~/^_\d+$/.match(varName)) {
                        // _1, _2 -> temp1, temp2
                        "temp" + varName.substr(1);
                    } else {
                        // Other underscore variables - keep as is for now
                        varName;
                    };
                    
                    if (newName != varName) {
                        tempVarRenameMap.set(idKey, newName);
                        varName = newName;
                        #if debug_ast_pipeline
                        trace('[AST Builder] Registering temp var rename: ${v.name} (id=${v.id}) -> ${newName}');
                        #end
                    }
                }
                // Handle collision-renamed variables (priority2 -> priority) 
                // BUT NEVER for function parameters or abstract method parameters (this1, struct1)
                else if (!functionParameterIds.exists(idKey) && 
                         varName != "this1" && varName != "struct1" && // Never rename these
                         ~/^(.+?)(\d+)$/.match(varName)) {
                    var regex = ~/^(.+?)(\d+)$/;
                    if (regex.match(varName)) {
                        var baseName = regex.matched(1);
                        var suffix = regex.matched(2);
                        
                        // Only strip suffix if it's a small number (1-9) which indicates collision renaming
                        // Don't strip from intentional names like "base64" or "sha256"
                        if (suffix.length == 1 && baseName != "_g") {
                            #if debug_ast_pipeline  
                            trace('[AST Builder] Collision-renamed variable detected: ${varName} -> ${baseName}');
                            #end
                            varName = baseName;
                        }
                    }
                }
                
                // Only apply toElixirVarName if the variable wasn't already mapped
                // Mapped variables are already in Elixir format (e.g., "this_1")
                // TODO: Architectural improvement - store the Elixir-formatted name in tempVarRenameMap 
                // during TFunction processing instead of converting here. This would eliminate the need
                // for the wasMapped flag and make the conversion happen at definition time rather than
                // reference time, following the single responsibility principle.
                
                // Convert variable names to snake_case for Elixir
                // Unless they were explicitly mapped (function parameters are pre-mapped)
                var finalName = if (wasMapped) {
                    // Use the mapped name (already in snake_case for parameters)
                    varName;
                } else {
                    // Convert to snake_case for Elixir conventions
                    toElixirVarName(varName);
                };
                EVar(finalName);
                
            case TVar(v, init):
                #if debug_null_coalescing
                trace('[AST Builder] TVar: ${v.name}, init type: ${init != null ? init.expr : "null"}');
                #end
                // Apply same underscore variable renaming as in TLocal
                var varName = v.name;
                if (varName.charAt(0) == "_" && varName.length > 1) {
                    var idKey = Std.string(v.id);
                    if (!tempVarRenameMap.exists(idKey)) {
                        // Create a new non-underscore name for this temp variable
                        var newName = if (~/^_g\d*$/.match(varName)) {
                            // _g, _g1, _g2 -> g, g1, g2
                            varName.substr(1);
                        } else if (~/^_\d+$/.match(varName)) {
                            // _1, _2 -> temp1, temp2
                            "temp" + varName.substr(1);
                        } else {
                            // Other underscore variables - keep as is for now
                            varName;
                        };
                        tempVarRenameMap.set(idKey, newName);
                        #if debug_ast_pipeline
                        trace('[AST Builder] Registering temp var rename in TVar: ${varName} (id=${v.id}) -> ${newName}');
                        #end
                    }
                    varName = tempVarRenameMap.get(idKey);
                }
                
                // For renamed temp variables, use the name directly without further conversion
                // Otherwise apply toElixirVarName for CamelCase conversion
                var finalVarName = if (v.name.charAt(0) == "_" && tempVarRenameMap.exists(Std.string(v.id))) {
                    varName; // Already renamed, use as-is
                } else {
                    toElixirVarName(varName); // Apply CamelCase to snake_case conversion
                };
                
                if (init != null) {
                    EMatch(
                        PVar(finalVarName),
                        buildFromTypedExpr(init)
                    );
                } else {
                    // Uninitialized variable - use nil
                    EMatch(
                        PVar(finalVarName),
                        makeAST(ENil)
                    );
                }
                
            // ================================================================
            // Binary Operations
            // ================================================================
            case TBinop(op, e1, e2):
                var left = buildFromTypedExpr(e1);
                var right = buildFromTypedExpr(e2);
                
                switch(op) {
                    case OpAdd: EBinary(Add, left, right);
                    case OpSub: EBinary(Subtract, left, right);
                    case OpMult: EBinary(Multiply, left, right);
                    case OpDiv: EBinary(Divide, left, right);
                    case OpMod: EBinary(Remainder, left, right);
                    
                    case OpEq: EBinary(Equal, left, right);
                    case OpNotEq: EBinary(NotEqual, left, right);
                    case OpLt: EBinary(Less, left, right);
                    case OpLte: EBinary(LessEqual, left, right);
                    case OpGt: EBinary(Greater, left, right);
                    case OpGte: EBinary(GreaterEqual, left, right);
                    
                    case OpBoolAnd: EBinary(AndAlso, left, right);
                    case OpBoolOr: EBinary(OrElse, left, right);
                    
                    case OpAssign: EMatch(extractPattern(e1), right);
                    case OpAssignOp(op2): 
                        // a += b becomes a = a + b
                        var innerOp = convertAssignOp(op2);
                        EMatch(extractPattern(e1), makeAST(EBinary(innerOp, left, right)));
                    
                    case OpAnd: EBinary(BitwiseAnd, left, right);
                    case OpOr: EBinary(BitwiseOr, left, right);
                    case OpXor: EBinary(BitwiseXor, left, right);
                    case OpShl: EBinary(ShiftLeft, left, right);
                    case OpShr: EBinary(ShiftRight, left, right);
                    case OpUShr: EBinary(ShiftRight, left, right); // No unsigned in Elixir
                    
                    case OpInterval: ERange(left, right, false);
                    case OpArrow: EFn([{
                        args: [PVar("_arrow")], // Placeholder, will be transformed
                        body: right
                    }]);
                    case OpIn: EBinary(In, left, right);
                    case OpNullCoal: 
                        // a ?? b needs special handling to avoid double evaluation
                        // Generate inline: if (a) != nil, do: a, else: b
                        // The printer will handle making this inline
                        EIf(
                            makeAST(EBinary(NotEqual, left, makeAST(ENil))),
                            left,
                            right
                        );
                }
                
            // ================================================================
            // Unary Operations
            // ================================================================
            case TUnop(op, postFix, e):
                var expr = buildFromTypedExpr(e).def;
                
                switch(op) {
                    case OpNot: EUnary(Not, makeAST(expr));
                    case OpNeg: EUnary(Negate, makeAST(expr));
                    case OpNegBits: EUnary(BitwiseNot, makeAST(expr));
                    case OpIncrement, OpDecrement:
                        // Elixir is immutable, so we convert increment/decrement to addition/subtraction
                        // Note: This doesn't handle the assignment side-effect, which needs to be handled in context
                        var one = makeAST(EInteger(1));
                        var value = makeAST(expr);
                        if (op == OpIncrement) {
                            EBinary(Add, value, one);
                        } else {
                            EBinary(Subtract, value, one);
                        };
                    case OpSpread:
                        // Spread operator for destructuring
                        EUnquoteSplicing(makeAST(expr));
                }
                
            // ================================================================
            // Function Calls
            // ================================================================
            case TCall(e, el):
                // Check if this is an enum constructor call first
                if (e != null && isEnumConstructor(e)) {
                    // ONLY BUILD - NO TRANSFORMATION!
                    var tag = extractEnumTag(e);
                    var args = [for (arg in el) buildFromTypedExpr(arg)];
                    
                    // Just create the raw tuple - transformer will handle it
                    ETuple([makeAST(EAtom(tag))].concat(args));
                } else {
                    // Regular function call
                    var target = e != null ? buildFromTypedExpr(e) : null;
                    var args = [for (arg in el) buildFromTypedExpr(arg)];
                    
                    // Detect special call patterns
                    switch(e.expr) {
                        case TField(obj, fa):
                            var fieldName = extractFieldName(fa);
                            var objAst = buildFromTypedExpr(obj);
                            
                            // Check for HXX.hxx() template calls
                            if (fieldName == "hxx" && isHXXModule(obj)) {
                                // HXX.hxx() returns a processed template string that needs ~H sigil
                                // The macro already processed the template, we just need to wrap it
                                if (args.length == 1) {
                                    // Extract the processed template string and wrap in ~H sigil
                                    switch(args[0].def) {
                                        case EString(content):
                                            // Wrap the processed template in HEEx sigil
                                            ESigil("H", content, "");
                                        default:
                                            // Non-string argument, compile as regular call
                                            ECall(objAst, fieldName, args);
                                    }
                                } else {
                                    // Wrong number of arguments, compile as regular call
                                    ECall(objAst, fieldName, args);
                                }
                            }
                            // Check for module calls
                            else if (isModuleCall(obj)) {
                                // Convert method name to snake_case for Elixir
                                var elixirFuncName = toSnakeCase(fieldName);
                                ERemoteCall(objAst, elixirFuncName, args);
                            } else {
                                // Check for array/list concatenation
                                if (fieldName == "concat" && isArrayType(obj.t)) {
                                    // Convert array.concat(other) to array ++ other in Elixir
                                    if (args.length == 1) {
                                        EBinary(Concat, objAst, args[0]);
                                    } else {
                                        // Fallback for invalid concat calls
                                        ECall(objAst, fieldName, args);
                                    }
                                } 
                                // Check for Map operations that need transformation
                                else if (isMapType(obj.t)) {
                                    // Transform Map methods to Elixir Map module functions
                                    switch(fieldName) {
                                        case "set" if (args.length == 2):
                                            // map.set(key, value) → Map.put(map, key, value)
                                            ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args));
                                        case "get" if (args.length == 1):
                                            // map.get(key) → Map.get(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));
                                        case "remove" if (args.length == 1):
                                            // map.remove(key) → Map.delete(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));
                                        case "exists" if (args.length == 1):
                                            // map.exists(key) → Map.has_key?(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));
                                        case "keys" if (args.length == 0):
                                            // map.keys() → Map.keys(map)
                                            ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);
                                        case "values" if (args.length == 0):
                                            // map.values() → Map.values(map)
                                            ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);
                                        default:
                                            // Fallback for other Map methods
                                            ECall(objAst, fieldName, args);
                                    }
                                } else {
                                    // Instance method call
                                    ECall(objAst, fieldName, args);
                                }
                            }
                        case TLocal(v):
                            // Check if this is a function variable (needs .() syntax in Elixir)
                            // Function variables in Elixir require .() syntax for invocation
                            var isFunctionVar = switch(v.t) {
                                case TFun(_, _): true;
                                case TAbstract(t, _):
                                    var abs = t.get();
                                    abs.name == "Function" || abs.name == "Fn";
                                default: false;
                            };
                            
                            if (isFunctionVar) {
                                // Function variable call - needs special handling for .() syntax
                                // We'll create a special marker that the printer will recognize
                                ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
                            } else {
                                // Regular local function call
                                ECall(null, toElixirVarName(v.name), args);
                            }
                        default:
                            if (target != null) {
                                // Complex target expression
                                ECall(target, "call", args);
                            } else {
                                // Should not happen
                                ECall(null, "unknown_call", args);
                            }
                    }
                }
                
            // ================================================================
            // Field Access
            // ================================================================
            case TField(e, fa):
                // Check for enum constructor references
                switch(fa) {
                    case FEnum(enumType, ef):
                        // Enum constructor reference (no arguments)
                        // Keep original Haxe name - snake_case conversion happens at print time
                        EAtom(ef.name);
                    default:
                        // Regular field access
                        var target = buildFromTypedExpr(e);
                        var fieldName = extractFieldName(fa);
                        
                        // Detect map/struct access patterns
                        if (isMapAccess(e.t)) {
                            EAccess(target, makeAST(EAtom(fieldName)));
                        } else {
                            EField(target, fieldName);
                        }
                }
                
            // ================================================================
            // Array Operations
            // ================================================================
            case TArrayDecl(el):
                var elements = [for (e in el) buildFromTypedExpr(e)];
                EList(elements);
                
            case TArray(e, index):
                var target = buildFromTypedExpr(e);
                var key = buildFromTypedExpr(index);
                EAccess(target, key);
                
            // ================================================================
            // Control Flow (Basic)
            // ================================================================
            case TIf(econd, eif, eelse):
                var condition = buildFromTypedExpr(econd);
                var thenBranch = buildFromTypedExpr(eif);
                var elseBranch = eelse != null ? buildFromTypedExpr(eelse) : null;
                EIf(condition, thenBranch, elseBranch);
                
            case TBlock(el):
                #if debug_null_coalescing
                trace('[AST Builder] TBlock with ${el.length} expressions');
                for (i in 0...el.length) {
                    trace('[AST Builder]   Block[$i]: ${el[i].expr}');
                }
                #end
                
                // Check for null coalescing pattern: TVar followed by expr that uses it
                if (el.length == 2) {
                    switch([el[0].expr, el[1].expr]) {
                        case [TVar(tmpVar, init), expr] if (tmpVar.name.charAt(0) == "_" && init != null):
                            // Check if the second expression uses this temp var in null coalescing
                            var usesInNullCoal = false;
                            function checkForNullCoal(e: TypedExpr): Bool {
                                switch(e.expr) {
                                    case TBinop(OpNullCoal, {expr: TLocal(v)}, _) if (v.id == tmpVar.id):
                                        usesInNullCoal = true;
                                        return true;
                                    case TVar(v2, init2) if (init2 != null):
                                        return checkForNullCoal(init2);
                                    case TObjectDecl(fields):
                                        for (field in fields) {
                                            if (checkForNullCoal(field.expr)) return true;
                                        }
                                    case _:
                                }
                                return false;
                            }
                            
                            if (checkForNullCoal(el[1])) {
                                // Transform: replace TLocal(tmpVar) with the init expression in null coalescing
                                var transformed = replaceNullCoalVar(el[1], tmpVar.id, init);
                                return buildFromTypedExpr(transformed).def;
                            }
                        case _:
                    }
                }
                
                var expressions = [for (e in el) buildFromTypedExpr(e)];
                EBlock(expressions);
                
            case TReturn(e):
                if (e != null) {
                    buildFromTypedExpr(e).def; // Return value is implicit in Elixir
                } else {
                    ENil; // Explicit nil return
                }
                
            case TBreak:
                EThrow(makeAST(EAtom("break"))); // Will be transformed
                
            case TContinue:
                EThrow(makeAST(EAtom("continue"))); // Will be transformed
                
            // ================================================================
            // Pattern Matching (Switch/Case)
            // ================================================================
            case TSwitch(e, cases, edef):
                var expr = buildFromTypedExpr(e).def;
                var clauses = [];
                
                // Check if this is a topic_to_string-style temp variable switch
                // These need special handling for return context
                var needsTempVar = false;
                var tempVarName = "temp_result";
                
                // Detect if switch is in return context
                var isReturnContext = false; // TODO: Will be set via metadata
                
                for (c in cases) {
                    var patterns = [for (v in c.values) convertPattern(v)];
                    var body = buildFromTypedExpr(c.expr);
                    
                    // Multiple patterns become multiple clauses
                    for (pattern in patterns) {
                        clauses.push({
                            pattern: pattern,
                            guard: null, // Guards will be added in transformation
                            body: body
                        });
                    }
                }
                
                // Default case
                if (edef != null) {
                    clauses.push({
                        pattern: PWildcard,
                        guard: null,
                        body: buildFromTypedExpr(edef)
                    });
                }
                
                // Create the case expression
                var caseASTDef = ECase(makeAST(expr), clauses);
                
                // If in return context and needs temp var, wrap in assignment
                if (isReturnContext && needsTempVar) {
                    EBlock([
                        makeAST(EMatch(PVar(tempVarName), makeAST(caseASTDef))),
                        makeAST(EVar(tempVarName))
                    ]);
                } else {
                    caseASTDef;
                }
                
            // ================================================================
            // Try/Catch
            // ================================================================
            case TTry(e, catches):
                var body = buildFromTypedExpr(e);
                var rescueClauses = [];
                
                for (c in catches) {
                    var pattern = PVar(toElixirVarName(c.v.name));
                    var catchBody = buildFromTypedExpr(c.expr);
                    
                    rescueClauses.push({
                        pattern: pattern,
                        body: catchBody
                    });
                }
                
                ETry(body, rescueClauses, [], null, null);
                
            // ================================================================
            // Lambda/Anonymous Functions
            // ================================================================
            case TFunction(f):
                // Debug: Check for abstract method "this" parameter issue
                #if debug_ast_pipeline
                for (arg in f.args) {
                    trace('[AST Builder] TFunction arg: ${arg.v.name} (id=${arg.v.id})');
                }
                #end
                
                var args = [];
                var paramRenaming = new Map<String, String>();
                
                // First, collect all parameter mappings BEFORE building the body
                // This is crucial for abstract methods where "this1" becomes a parameter
                for (arg in f.args) {
                    var originalName = arg.v.name;
                    
                    // Convert to snake_case for Elixir conventions
                    var elixirName = toElixirVarName(originalName);
                    
                    // Track all parameter mappings, especially for abstract "this" parameters
                    if (originalName != elixirName) {
                        paramRenaming.set(originalName, elixirName);
                        #if debug_ast_pipeline
                        trace('[AST Builder] Function parameter will be renamed: $originalName -> $elixirName');
                        #end
                    }
                    
                    // Also need to handle the collision-renamed case
                    // If the parameter is "this1", we need to ensure the body uses "this_1" not "this"
                    if (originalName == "this1") {
                        // The body might try to rename this1 -> this due to collision detection
                        // We need to prevent that and use the parameter name instead
                        paramRenaming.set("this", elixirName); // Map "this" to "this_1" as well
                        #if debug_ast_pipeline
                        trace('[AST Builder] Abstract this parameter detected, mapping both this1 and this to: $elixirName');
                        #end
                    }
                    
                    args.push(PVar(elixirName));
                }
                
                // Now build the body with awareness of parameter mappings
                // We need to temporarily override the collision detection for these parameters
                var oldTempVarRenameMap = tempVarRenameMap;
                tempVarRenameMap = new Map();
                for (key in oldTempVarRenameMap.keys()) {
                    tempVarRenameMap.set(key, oldTempVarRenameMap.get(key));
                }
                
                // Register parameter names to prevent collision renaming
                for (arg in f.args) {
                    var idKey = Std.string(arg.v.id);
                    
                    // Check if this parameter was already registered
                    // This happens when ElixirCompiler processes class methods
                    if (!tempVarRenameMap.exists(idKey)) {
                        var originalName = arg.v.name;
                        
                        // Convert to snake_case for Elixir conventions
                        var elixirName = toElixirVarName(originalName);
                        
                        tempVarRenameMap.set(idKey, elixirName);
                    }
                    
                    functionParameterIds.set(idKey, true); // Mark as function parameter
                    #if debug_ast_pipeline
                    trace('[AST Builder] Registering parameter in rename map: id=$idKey');
                    #end
                }
                
                var body = buildFromTypedExpr(f.expr);
                
                // Restore the original map and clean up function parameter tracking
                tempVarRenameMap = oldTempVarRenameMap;
                for (arg in f.args) {
                    functionParameterIds.remove(Std.string(arg.v.id));
                }
                
                // Apply any remaining parameter renaming if needed
                if (paramRenaming.keys().hasNext()) {
                    #if debug_ast_pipeline
                    trace('[AST Builder] Applying parameter renaming to function body');
                    #end
                    body = applyParameterRenaming(body, paramRenaming);
                }
                
                EFn([{
                    args: args,
                    guard: null,
                    body: body
                }]);
                
            // ================================================================
            // Object/Anonymous Structure
            // ================================================================
            case TObjectDecl(fields):
                var pairs = [];
                for (field in fields) {
                    var key = makeAST(EAtom(field.name));
                    
                    // Check if the field value is a TBlock with null coalescing pattern
                    var fieldValue = switch(field.expr.expr) {
                        case TBlock([{expr: TVar(tmpVar, init)}, expr]) 
                            if (tmpVar.name.charAt(0) == "_" && init != null):
                            // Check if expr uses tmpVar in null coalescing
                            function hasNullCoal(e: TypedExpr): Bool {
                                return switch(e.expr) {
                                    case TBinop(OpNullCoal, {expr: TLocal(v)}, _) if (v.id == tmpVar.id): true;
                                    case _: false;
                                }
                            }
                            
                            if (hasNullCoal(expr)) {
                                // Transform inline: replace temp var reference with init expr
                                var transformed = replaceNullCoalVar(expr, tmpVar.id, init);
                                buildFromTypedExpr(transformed);
                            } else {
                                buildFromTypedExpr(field.expr);
                            }
                            
                        case _:
                            buildFromTypedExpr(field.expr);
                    };
                    
                    pairs.push({key: key, value: fieldValue});
                }
                EMap(pairs);
                
            // ================================================================
            // Type Operations
            // ================================================================
            case TTypeExpr(m):
                // Check if this is an extern class with @:native annotation
                var moduleName = moduleTypeToString(m);
                
                // Check if this module has @:native metadata indicating it's an Elixir module
                var isNativeModule = switch(m) {
                    case TClassDecl(c):
                        var cl = c.get();
                        // Check if it's an extern class with @:native
                        if (cl.isExtern && cl.meta.has(":native")) {
                            // Get the native name from metadata
                            var nativeMeta = cl.meta.extract(":native");
                            if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
                                switch(nativeMeta[0].params[0].expr) {
                                    case EConst(CString(s, _)):
                                        moduleName = s;
                                        true;
                                    default:
                                        false;
                                }
                            } else {
                                false;
                            }
                        } else {
                            false;
                        }
                    default:
                        false;
                };
                
                // Module references should always be EVar (no colon prefix)
                // This applies to both native Elixir modules and compiled Haxe classes
                EVar(moduleName);  // Module references are just capitalized identifiers
                
            case TCast(e, m):
                // Casts are mostly compile-time in Haxe
                buildFromTypedExpr(e).def;
                
            case TParenthesis(e):
                EParen(buildFromTypedExpr(e));
                
            case TMeta(m, e):
                // Metadata wrapping - preserve the expression
                buildFromTypedExpr(e).def;
                
            // ================================================================
            // Special Cases
            // ================================================================
            case TNew(c, _, el):
                // Constructor call - should call ModuleName.new() for classes with instance methods
                var classType = c.get();
                var className = classType.name;
                var args = [for (e in el) buildFromTypedExpr(e)];
                
                // Check if this is a Map type (StringMap, IntMap, etc.)
                // Maps should generate regular Elixir maps %{}, not structs
                if (className == "StringMap" || className == "Map" || className.endsWith("Map")) {
                    // Generate empty map for Map constructors
                    EMap([]);
                } else {
                    // Check if this class has instance methods (not just a data class)
                    var hasInstanceMethods = false;
                    for (field in classType.fields.get()) {
                        // Instance methods are FMethod that are not in the statics list
                        if (field.kind.match(FMethod(_))) {
                            // Check if this field is NOT in the statics array
                            var isStatic = false;
                            for (staticField in classType.statics.get()) {
                                if (staticField.name == field.name) {
                                    isStatic = true;
                                    break;
                                }
                            }
                            if (!isStatic) {
                                hasInstanceMethods = true;
                                break;
                            }
                        }
                    }
                    
                    // Also check if it has a constructor
                    var hasConstructor = classType.constructor != null;
                    
                    if (hasInstanceMethods || hasConstructor) {
                        // Call the module's new function: ModuleName.new(args)
                        // In Elixir, this is a module function call
                        var moduleRef = makeAST(EVar(className));
                        ECall(moduleRef, "new", args);
                    } else {
                        // Simple data class - create as struct
                        EStruct(className, []);
                    }
                }
                
            case TFor(v, e1, e2):
                // For loop becomes comprehension
                var pattern = PVar(toElixirVarName(v.name));
                var expr = buildFromTypedExpr(e1);
                var body = buildFromTypedExpr(e2);
                
                EFor([{pattern: pattern, expr: expr}], [], body, null, false);
                
            case TWhile(econd, e, normalWhile):
                // While loops compile to recursive functions
                // We need to generate them inline since Elixir doesn't have while loops
                
                var condition = buildFromTypedExpr(econd);
                var body = buildFromTypedExpr(e);
                
                // For now, just create a call that will be handled by the transformer
                // The transformer's comprehensionConversionPass will convert this
                ECall(null, "while_loop", [condition, body]);
                
            case TThrow(e):
                EThrow(buildFromTypedExpr(e));
                
            case TEnumParameter(e, ef, index):
                // Enum field access
                var exprAST = buildFromTypedExpr(e);
                var field = ef.name;
                
                // Will be transformed to proper pattern extraction
                ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]); // +1 for tag
                
            case TEnumIndex(e):
                // Get enum tag index
                var exprAST = buildFromTypedExpr(e);
                ECall(exprAST, "elem", [makeAST(EInteger(0))]);
                
            case TIdent(s):
                // Identifier reference
                EVar(toElixirVarName(s));
        }
    }
    
    /**
     * Create metadata from TypedExpr
     */
    static function createMetadata(expr: TypedExpr): ElixirMetadata {
        return {
            sourceExpr: expr,
            sourceLine: expr.pos != null ? Context.getPosInfos(expr.pos).min : 0,
            sourceFile: expr.pos != null ? Context.getPosInfos(expr.pos).file : null,
            type: expr.t,
            elixirType: typeToElixir(expr.t),
            purity: isPure(expr),
            tailPosition: false, // Will be set by transformer
            async: false, // Will be detected by transformer
            requiresReturn: false, // Will be set by context
            requiresTempVar: false, // Will be set by transformer
            inPipeline: false, // Will be set by transformer
            inComprehension: false, // Will be set by context
            inGuard: false, // Will be set by context
            canInline: canBeInlined(expr),
            isConstant: isConstant(expr),
            sideEffects: hasSideEffects(expr)
        };
    }
    
    /**
     * Convert Haxe values to patterns
     * 
     * WHY: Switch case values need to be converted to Elixir patterns
     * WHAT: Handles literals, enum constructors, variables, and complex patterns
     * HOW: Analyzes the TypedExpr structure and generates appropriate pattern
     */
    static function convertPattern(value: TypedExpr): EPattern {
        return switch(value.expr) {
            // Literals
            case TConst(TInt(i)): 
                PLiteral(makeAST(EInteger(i)));
            case TConst(TFloat(f)): 
                PLiteral(makeAST(EFloat(Std.parseFloat(f))));
            case TConst(TString(s)): 
                PLiteral(makeAST(EString(s)));
            case TConst(TBool(b)): 
                PLiteral(makeAST(EBoolean(b)));
            case TConst(TNull): 
                PLiteral(makeAST(ENil));
                
            // Variables (for pattern matching)
            case TLocal(v):
                PVar(toElixirVarName(v.name));
                
            // Enum constructors
            case TEnumParameter(e, ef, index):
                // This represents matching against enum constructor arguments
                // We'll need to handle this in the context of the full pattern
                PVar("_enum_param_" + index);
                
            case TEnumIndex(e):
                // Matching against enum index (for switch on elem(tuple, 0))
                PLiteral(makeAST(EInteger(0))); // Will be refined based on actual enum
                
            // Array patterns
            case TArrayDecl(el):
                PList([for (e in el) convertPattern(e)]);
                
            // Tuple patterns (for enum matching)
            case TCall(e, el) if (isEnumConstructor(e)):
                // Enum constructor pattern
                var tag = extractEnumTag(e);
                var args = [for (arg in el) convertPattern(arg)];
                // Create tuple pattern {:tag, arg1, arg2, ...}
                // Keep original name - conversion happens at print time
                PTuple([PLiteral(makeAST(EAtom(tag)))].concat(args));
                
            // Field access (for enum constructors)
            case TField(e, FEnum(_, ef)):
                // Direct enum constructor reference
                if (ef.params.length == 0) {
                    // No-argument constructor
                    // Keep original name - conversion happens at print time
                    PLiteral(makeAST(EAtom(ef.name)));
                } else {
                    // Constructor with arguments - needs to be a tuple pattern
                    // This will be {:Constructor, _, _, ...} with wildcards for args
                    var wildcards = [for (i in 0...ef.params.length) PWildcard];
                    // Keep original name - conversion happens at print time
                    PTuple([PLiteral(makeAST(EAtom(ef.name)))].concat(wildcards));
                }
                
            // Default/wildcard
            default: 
                PWildcard;
        }
    }
    
    /**
     * Check if an expression is an enum constructor call
     * 
     * Handles both:
     * - TField access: ChildSpecFormat.ModuleWithConfig
     * - Direct constructors: ModuleWithConfig (when imported/in scope)
     * - TTypeExpr references to enum constructors
     */
    static function isEnumConstructor(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TField(_, FEnum(_, _)): true;
            case TTypeExpr(TEnumDecl(_)): true;  // Direct enum type reference
            case TConst(TString(s)) if (s.charAt(0) >= 'A' && s.charAt(0) <= 'Z'): 
                // Heuristic: capitalized identifiers might be enum constructors
                // This is a fallback for cases where Haxe doesn't provide clear type info
                true;
            default: 
                // Check the type - if it's an enum function type, it's a constructor
                switch(expr.t) {
                    case TFun(_, ret):
                        switch(ret) {
                            case TEnum(_, _): true;
                            default: false;
                        }
                    case TEnum(_, _): true;
                    default: false;
                }
        }
    }
    
    /**
     * Check if an enum has @:elixirIdiomatic metadata
     */
    static function hasIdiomaticMetadata(expr: TypedExpr): Bool {
        // First try the direct field access case
        switch(expr.expr) {
            case TField(_, FEnum(enumRef, _)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for ${enumType.name}: $hasIt');
                #end
                return hasIt;
            case TTypeExpr(TEnumDecl(enumRef)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for enum type expr: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        // Check the return type if this is a function that returns an enum
        switch(expr.t) {
            case TFun(_, ret):
                switch(ret) {
                    case TEnum(enumRef, _):
                        var enumType = enumRef.get();
                        var hasIt = enumType.meta.has(":elixirIdiomatic");
                        #if debug_ast_builder
                        trace('[AST Builder] Checking @:elixirIdiomatic via return type: $hasIt');
                        #end
                        return hasIt;
                    default:
                }
            case TEnum(enumRef, _):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic via direct enum type: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        return false;
    }
    
    // REMOVED buildEnumConstructor - Builder should NOT transform, only build!
    
    /**
     * Get the enum type name for pattern detection
     */
    static function getEnumTypeName(expr: TypedExpr): String {
        return switch(expr.expr) {
            case TField(_, FEnum(enumRef, _)):
                var enumType = enumRef.get();
                enumType.name;
            default: "";
        }
    }
    
    /**
     * Convert Haxe identifier to Elixir atom name
     * 
     * GENERAL RULE: When Haxe identifiers become Elixir atoms,
     * they should follow Elixir naming conventions (snake_case).
     * This ensures generated code looks idiomatic.
     * 
     * Examples:
     * - OneForOne → one_for_one
     * - RestForOne → rest_for_one
     * - SimpleOneForOne → simple_one_for_one
     */
    static function toElixirAtomName(name: String): String {
        var result = [];
        for (i in 0...name.length) {
            var c = name.charAt(i);
            if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
                result.push("_");
                result.push(c.toLowerCase());
            } else {
                result.push(c.toLowerCase());
            }
        }
        return result.join("");
    }
    
    /**
     * Check if type is an array type
     */
    static function isArrayType(t: Type): Bool {
        return switch(t) {
            case TInst(c, _):
                var cl = c.get();
                cl.name == "Array";
            case TAbstract(a, _):
                var abs = a.get();
                abs.name == "Array";
            default: false;
        }
    }
    
    /**
     * Check if type is a Map type
     */
    static function isMapType(t: Type): Bool {
        return switch(t) {
            case TInst(c, _):
                var cl = c.get();
                cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || 
                cl.name == "Map" || cl.name.endsWith("Map");
            case TAbstract(a, params):
                var abs = a.get();
                abs.name == "Map" || abs.name.endsWith("Map");
            default: false;
        }
    }
    
    /**
     * Extract enum constructor tag name
     */
    static function extractEnumTag(expr: TypedExpr): String {
        return switch(expr.expr) {
            case TField(_, FEnum(_, ef)): ef.name;
            default: "unknown";
        }
    }
    
    /**
     * Extract pattern from left-hand side expression
     */
    static function extractPattern(expr: TypedExpr): EPattern {
        return switch(expr.expr) {
            case TLocal(v): PVar(toElixirVarName(v.name));
            case TField(e, fa): 
                // Map/struct field pattern
                PVar(extractFieldName(fa));
            default: PWildcard;
        }
    }
    
    /**
     * Convert assignment operator to binary operator
     */
    static function convertAssignOp(op: Binop): EBinaryOp {
        return switch(op) {
            case OpAdd: Add;
            case OpSub: Subtract;
            case OpMult: Multiply;
            case OpDiv: Divide;
            case OpMod: Remainder;
            case OpAnd: BitwiseAnd;
            case OpOr: BitwiseOr;
            case OpXor: BitwiseXor;
            case OpShl: ShiftLeft;
            case OpShr: ShiftRight;
            default: Add; // Fallback
        }
    }
    
    /**
     * Apply parameter renaming to an AST node
     * This is used when function parameters are renamed (e.g., "this" -> "this_1")
     * to ensure the body references the correct parameter names
     */
    static function applyParameterRenaming(ast: ElixirAST, renaming: Map<String, String>): ElixirAST {
        return switch(ast.def) {
            case EVar(name):
                if (renaming.exists(name)) {
                    makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
                } else {
                    ast;
                }
            
            // Recursively apply to all child nodes
            case EBlock(exprs):
                makeASTWithMeta(EBlock(exprs.map(e -> applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);
            
            case ECall(target, func, args):
                makeASTWithMeta(
                    ECall(
                        target != null ? applyParameterRenaming(target, renaming) : null,
                        func,
                        args.map(a -> applyParameterRenaming(a, renaming))
                    ),
                    ast.metadata, ast.pos
                );
            
            case EBinary(op, left, right):
                makeASTWithMeta(
                    EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)),
                    ast.metadata, ast.pos
                );
            
            case EUnary(op, expr):
                makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);
            
            case EIf(cond, then, else_):
                makeASTWithMeta(
                    EIf(
                        applyParameterRenaming(cond, renaming),
                        applyParameterRenaming(then, renaming),
                        else_ != null ? applyParameterRenaming(else_, renaming) : null
                    ),
                    ast.metadata, ast.pos
                );
                
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(
                        applyParameterRenaming(expr, renaming),
                        clauses.map(c -> {
                            pattern: c.pattern,  // Don't rename in patterns
                            guard: c.guard != null ? applyParameterRenaming(c.guard, renaming) : null,
                            body: applyParameterRenaming(c.body, renaming)
                        })
                    ),
                    ast.metadata, ast.pos
                );
            
            // For other node types, return as-is (can be extended as needed)
            default:
                ast;
        }
    }
    
    /**
     * Convert variable name to Elixir convention
     * Preserves special Elixir constants like __MODULE__, __FILE__, __ENV__
     */
    /**
     * Check if a variable name looks like a camelCase parameter
     * These are typically function parameters that should remain as-is
     */
    static function isCamelCaseParameter(name: String): Bool {
        if (name.length < 2) return false;
        
        // Check if it starts with lowercase and has uppercase letters
        var firstChar = name.charAt(0);
        if (firstChar != firstChar.toLowerCase()) return false;
        
        // Check if it contains uppercase letters (indicating camelCase)
        for (i in 1...name.length) {
            var char = name.charAt(i);
            if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
                return true; // Found uppercase letter, it's camelCase
            }
        }
        
        return false;
    }
    
    static function toElixirVarName(name: String): String {
        // Special Elixir constants should be preserved
        var specialConstants = ["__MODULE__", "__FILE__", "__ENV__", "__DIR__", "__CALLER__"];
        if (specialConstants.indexOf(name) >= 0) {
            return name;
        }
        
        // Simple snake_case conversion for regular variables
        var result = "";
        for (i in 0...name.length) {
            var char = name.charAt(i);
            if (i > 0 && char == char.toUpperCase() && char != "_") {
                result += "_" + char.toLowerCase();
            } else {
                result += char.toLowerCase();
            }
        }
        return result;
    }
    
    /**
     * Extract field name from FieldAccess
     */
    public static function extractFieldName(fa: FieldAccess): String {
        return switch(fa) {
            case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
                cf.get().name;
            case FDynamic(s):
                s;
            case FEnum(_, ef):
                ef.name;
        }
    }
    
    /**
     * Convert camelCase to snake_case
     */
    static function toSnakeCase(s: String): String {
        // Handle empty string
        if (s.length == 0) return s;
        
        var result = new StringBuf();
        for (i in 0...s.length) {
            var char = s.charAt(i);
            if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
                // Insert underscore before uppercase letter (except at start)
                result.add("_");
                result.add(char.toLowerCase());
            } else {
                result.add(char.toLowerCase());
            }
        }
        return result.toString();
    }
    
    /**
     * Check if expression is the HXX module (for Phoenix HEEx template processing)
     * 
     * WHY: HXX.hxx() is a compile-time macro that processes JSX-like template strings
     *      and converts them to Phoenix HEEx format. After macro expansion, we get a 
     *      processed string that needs to be wrapped in a ~H sigil for LiveView.
     * 
     * WHAT: Detects when a TTypeExpr refers to the HXX module class, which indicates
     *       we're about to handle an HXX.hxx() template call that needs special treatment.
     * 
     * HOW: Checks if the module type expression resolves to "HXX" by name.
     * 
     * Example: HXX.hxx("<div>Hello <%= @name %></div>") → ~H"""<div>Hello <%= @name %></div>"""
     */
    static function isHXXModule(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(m):
                // Check if this is the HXX module
                moduleTypeToString(m) == "HXX";
            default: false;
        }
    }
    
    /**
     * Check if expression is a module call
     */
    static function isModuleCall(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(_): true;
            default: false;
        }
    }
    
    /**
     * Check if type represents a map/struct
     */
    static function isMapAccess(t: Type): Bool {
        return switch(t) {
            case TAnonymous(_): true;
            case TInst(_.get() => ct, _): ct.isInterface || ct.name.endsWith("Map");
            default: false;
        }
    }
    
    /**
     * Convert module type to string
     */
    static function moduleTypeToString(m: ModuleType): String {
        return switch(m) {
            case TClassDecl(c): c.get().name;
            case TEnumDecl(e): e.get().name;
            case TTypeDecl(t): t.get().name;
            case TAbstract(a): a.get().name;
        }
    }
    
    /**
     * Convert Haxe type to Elixir type string
     */
    static function typeToElixir(t: Type): String {
        return switch(t) {
            case TInst(_.get() => {name: "String"}, _): "binary";
            case TInst(_.get() => {name: "Array"}, _): "list";
            case TAbstract(_.get() => {name: "Int"}, _): "integer";
            case TAbstract(_.get() => {name: "Float"}, _): "float";
            case TAbstract(_.get() => {name: "Bool"}, _): "boolean";
            case TDynamic(_): "any";
            default: "term";
        }
    }
    
    /**
     * Check if expression is pure (no side effects)
     */
    static function isPure(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_) | TTypeExpr(_): true;
            case TBinop(_, e1, e2): isPure(e1) && isPure(e2);
            case TUnop(_, _, e): isPure(e);
            case TField(e, _): isPure(e);
            case TParenthesis(e): isPure(e);
            default: false;
        }
    }
    
    /**
     * Check if expression can be inlined
     */
    static function canBeInlined(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_): true;
            case TBinop(_, e1, e2): canBeInlined(e1) && canBeInlined(e2);
            case TUnop(_, _, e): canBeInlined(e);
            default: false;
        }
    }
    
    /**
     * Check if expression is constant
     */
    static function isConstant(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_): true;
            default: false;
        }
    }
    
    /**
     * Check if expression has side effects
     */
    static function hasSideEffects(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TCall(_, _) | TNew(_, _, _) | TVar(_, _): true;
            case TBinop(OpAssign | OpAssignOp(_), _, _): true;
            case TUnop(OpIncrement | OpDecrement, _, _): true;
            case TThrow(_): true;
            default: false;
        }
    }
}

#end