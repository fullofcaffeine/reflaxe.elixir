package reflaxe.elixir.ast;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Expr;
import haxe.macro.Context;
import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTPatterns;
using reflaxe.helpers.TypedExprHelper;
using reflaxe.helpers.TypeHelper;
using StringTools;

/**
 * ElixirASTBuilder: TypedExpr to ElixirAST Converter (Analysis Phase)
 * 
 * WHY: Bridge between Haxe's TypedExpr and our ElixirAST representation
 * - Preserves all semantic information from Haxe's type system
 * - Enriches nodes with metadata for later transformation phases
 * - Separates AST construction from string generation
 * - Enables multiple transformation passes on strongly-typed structure
 * 
 * WHAT: Converts Haxe TypedExpr nodes to corresponding ElixirAST nodes
 * - Handles all expression types (literals, variables, operations, calls)
 * - Captures type information and source positions
 * - Detects patterns that need special handling (e.g., array operations)
 * - Maintains context through metadata enrichment
 * 
 * HOW: Recursive pattern matching on TypedExpr with metadata preservation
 * - Each TypedExpr constructor maps to one or more ElixirAST nodes
 * - Metadata carries context through the entire pipeline
 * - Complex expressions decomposed into simpler AST nodes
 * - Pattern detection integrated into conversion process
 * 
 * ARCHITECTURE BENEFITS:
 * - Single Responsibility: Only converts AST formats, no code generation
 * - Open/Closed: Easy to add new node types without modifying existing
 * - Testability: Can test AST conversion independently of generation
 * - Maintainability: Clear separation from transformation and printing
 * 
 * @see docs/03-compiler-development/INTERMEDIATE_AST_REFACTORING_PRD.md
 */
class ElixirASTBuilder {
    
    // Counter for generating unique loop function names
    static var loopCounter: Int = 0;
    
    // Map for renaming temporary underscore variables generated by Haxe
    // Key is the TVar.id (as String), value is the renamed variable name
    public static var tempVarRenameMap: Map<String, String> = new Map();
    
    // Set of function parameter IDs to avoid collision detection on them
    // These are intentional parameter names, not collision-renamed variables
    public static var functionParameterIds: Map<String, Bool> = new Map();
    
    // Flag to indicate we're building a class method body
    // When true, don't convert camelCase parameters to snake_case
    public static var isInClassMethodContext: Bool = false;
    
    // Counter for generating unique while loop function names
    static var whileLoopCounter: Int = 0;
    
    // Current module being compiled (for detecting same-module static calls)
    public static var currentModule: String = null;
    
    // Variable usage map for context-aware naming
    // Maps variable ID to whether it's used (true) or unused (false)
    public static var variableUsageMap: Null<Map<Int, Bool>> = null;
    
    /**
     * Main entry point: Convert TypedExpr to ElixirAST
     * 
     * WHY: Single entry point for all AST conversion
     * WHAT: Recursively converts TypedExpr tree to ElixirAST tree
     * HOW: Pattern matches on expr type and delegates to specific handlers
     */
    /**
     * Replace TLocal references to a temp var with inline null coalescing pattern
     */
    static function replaceNullCoalVar(expr: TypedExpr, varId: Int, initExpr: TypedExpr): TypedExpr {
        return switch(expr.expr) {
            case TBinop(OpNullCoal, {expr: TLocal(v)}, defaultExpr) if (v.id == varId):
                // Replace with inline null coalescing that includes the init expression
                {
                    expr: TBinop(OpNullCoal, initExpr, defaultExpr),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case TVar(v, init) if (init != null):
                // Variable declaration with initialization - recurse into init
                {
                    expr: TVar(v, replaceNullCoalVar(init, varId, initExpr)),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case TObjectDecl(fields):
                // Object declaration - recurse into field values
                var newFields = [for (field in fields) {
                    name: field.name,
                    expr: replaceNullCoalVar(field.expr, varId, initExpr)
                }];
                {
                    expr: TObjectDecl(newFields),
                    pos: expr.pos,
                    t: expr.t
                };
                
            case _:
                // No transformation needed
                expr;
        }
    }
    
    public static function buildFromTypedExpr(expr: TypedExpr, ?usageMap: Map<Int, Bool>): ElixirAST {
        // Store the usage map for context-aware variable naming
        // If no usage map provided but we don't have one stored, analyze now
        if (usageMap != null) {
            variableUsageMap = usageMap;
        } else if (variableUsageMap == null) {
            // Analyze usage for this expression if not already done
            variableUsageMap = reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(expr);
        }
        
        #if debug_ast_builder
        trace('[XRay AST Builder] Converting TypedExpr: ${expr.expr}');
        if (variableUsageMap != null) {
            trace('[XRay AST Builder] Using variable usage map with ${Lambda.count(variableUsageMap)} entries');
        }
        #end
        
        var metadata = createMetadata(expr);
        var astDef = convertExpression(expr);
        
        // ONLY mark metadata - NO transformation in builder!
        // Check both direct enum constructor calls AND function calls that return idiomatic enums
        switch(expr.expr) {
            case TCall(e, _) if (e != null && isEnumConstructor(e) && hasIdiomaticMetadata(e)):
                // Direct enum constructor call (e.g., ModuleRef("MyModule"))
                metadata.requiresIdiomaticTransform = true;
                metadata.idiomaticEnumType = getEnumTypeName(e);
                #if debug_ast_builder
                trace('[AST Builder] Marked direct enum constructor for transformer: ${getEnumTypeName(e)}');
                #end
            case TCall(_, _):
                // Function call - check if it returns an idiomatic enum
                switch(expr.t) {
                    case TEnum(enumRef, _):
                        var enumType = enumRef.get();
                        if (enumType.meta.has(":elixirIdiomatic")) {
                            metadata.requiresIdiomaticTransform = true;
                            metadata.idiomaticEnumType = enumType.name;
                            #if debug_ast_builder
                            trace('[AST Builder] Marked function return value as idiomatic enum: ${enumType.name}');
                            #end
                        }
                    default:
                }
            default:
        }
        
        var result = makeASTWithMeta(astDef, metadata, expr.pos);
        
        #if debug_ast_builder
        trace('[XRay AST Builder] Generated AST: ${astDef}');
        #end
        
        return result;
    }
    
    /**
     * Convert TypedExprDef to ElixirASTDef
     */
    static function convertExpression(expr: TypedExpr): ElixirASTDef {
        return switch(expr.expr) {
            // ================================================================
            // Literals and Constants
            // ================================================================
            case TConst(TInt(i)):
                EInteger(i);
                
            case TConst(TFloat(f)):
                EFloat(Std.parseFloat(f));
                
            case TConst(TString(s)):
                EString(s);
                
            case TConst(TBool(b)):
                EBoolean(b);
                
            case TConst(TNull):
                ENil;
                
            case TConst(TThis):
                // In Elixir, 'this' refers to the first parameter of instance methods (usually 'struct')
                // This will be handled by the transformer or the function compiler
                // For now, use a placeholder that will be replaced
                EVar("struct");
                
            case TConst(TSuper):
                // Elixir doesn't have super - this needs special handling
                // Generally should not appear in valid code
                // For now, just return nil since super isn't supported in Elixir
                ENil;
                
            // ================================================================
            // Variables and Binding
            // ================================================================
            case TLocal(v):
                // Check if this is a renamed parameter (e.g., priority2 -> priority)
                var varName = v.name;
                var idKey = Std.string(v.id);
                var wasMapped = false;
                
                // Always debug variables that might be renamed
                #if debug_ast_pipeline
                if (varName.indexOf("priority") >= 0 || varName.indexOf("_") >= 0 || ~/\d$/.match(varName) || varName.indexOf("this") >= 0 || varName.indexOf("struct") >= 0 || varName == "p") {
                    trace('[AST Builder] TLocal variable: name="${varName}", id=${v.id}, pos=${expr.pos}');
                }
                #end
                
                // Check if this variable has been registered as a function parameter
                // or has an explicit mapping (from TFunction processing)
                if (tempVarRenameMap.exists(idKey)) {
                    // Use the explicitly mapped name - it's already in Elixir format (snake_case)
                    varName = tempVarRenameMap.get(idKey);
                    wasMapped = true;
                    
                    #if debug_ast_pipeline
                    trace('[AST Builder] Using mapped name for id=${v.id}: ${v.name} -> ${varName}');
                    #end
                }
                // Apply consistent underscore removal for compiler-generated variables
                // This ensures both declarations and references use the same name
                // EXCEPT for _g variables which should be preserved as-is
                else if (varName.charAt(0) == "_" && varName.charAt(1) != "g" && varName.length > 1) {
                    // For underscore-prefixed variables OTHER than _g, _g1, etc.
                    // We need to apply the same transformation as toElixirVarName
                    // to ensure consistency
                    varName = varName.substr(1); // Remove the underscore
                }
                // REMOVED: Collision-rename detection was incorrectly stripping suffixes from
                // user-defined variables like pos1, pos2. Since we cannot reliably distinguish
                // between user-defined variables with numbers (pos1, test2) and compiler-generated
                // collision renames, we're removing this logic entirely. 
                // Variables should keep their original names unless explicitly mapped.
                
                // Only apply toElixirVarName if the variable wasn't already mapped
                // Mapped variables are already in Elixir format (e.g., "this_1")
                // TODO: Architectural improvement - store the Elixir-formatted name in tempVarRenameMap 
                // during TFunction processing instead of converting here. This would eliminate the need
                // for the wasMapped flag and make the conversion happen at definition time rather than
                // reference time, following the single responsibility principle.
                
                // Convert variable names to snake_case for Elixir
                // Unless they were explicitly mapped (function parameters are pre-mapped)
                var finalName = if (wasMapped) {
                    // Use the mapped name (already in snake_case for parameters)
                    varName;
                } else {
                    // Check if this variable is unused (for consistent naming with declaration)
                    var isUsed = if (variableUsageMap != null) {
                        variableUsageMap.exists(v.id) && variableUsageMap.get(v.id);
                    } else {
                        true; // Conservative default: assume used if no usage map
                    };
                    
                    #if debug_variable_usage
                    if (varName == "g" || varName == "g2" || varName.startsWith("_g")) {
                        trace('[TLocal] Variable ${varName} (id=${v.id}): isUsed=$isUsed, in map=${variableUsageMap != null ? Std.string(variableUsageMap.exists(v.id)) : "no map"}');
                    }
                    #end
                    
                    // CRITICAL FIX: Don't add underscore to 'g' variables in TLocal
                    // The variable was declared as 'g', not '_g', so we should reference it as 'g'
                    // Only preserve existing underscores, don't add new ones
                    var preserveUnderscore = false; // Never preserve underscore in TLocal - use exact declared name
                    
                    // Convert to snake_case for Elixir conventions
                    // TLocal should NOT add underscore prefixes - that's done at declaration (TVar)
                    // Just use the same conversion logic as the declaration
                    toElixirVarName(varName, preserveUnderscore);
                };
                EVar(finalName);
                
            case TVar(v, init):
                #if debug_variable_usage
                if (v.name == "value" || v.name == "msg" || v.name == "err") {
                    trace('[AST Builder] Processing TVar: ${v.name} (id: ${v.id})');
                }
                #end
                
                #if debug_null_coalescing
                trace('[AST Builder] TVar: ${v.name}, init type: ${init != null ? Type.enumConstructor(init.expr) : "null"}');
                #end
                
                #if debug_assignment_context
                trace('[XRay AssignmentContext] TVar: ${v.name}');
                if (init != null) {
                    trace('[XRay AssignmentContext] Init expr: ${Type.enumConstructor(init.expr)}');
                    switch(init.expr) {
                        case TField(e, _):
                            trace('[XRay AssignmentContext] TField access detected - likely in expression context');
                        case _:
                    }
                }
                #end
                
                #if debug_ast_pipeline
                if (v.name == "p1" || v.name == "p2" || v.name == "p" || v.name == "p_1" || v.name == "p_2") {
                    trace('[AST Builder] TVar declaration: name="${v.name}", id=${v.id}');
                }
                #end
                
                #if debug_array_patterns
                if (init != null) {
                    trace('[XRay ArrayPattern] TVar ${v.name} init: ${Type.enumConstructor(init.expr)}');
                    // Check if this is an array map/filter initialization
                    switch(init.expr) {
                        case TBlock(exprs):
                            trace('[XRay ArrayPattern] TVar contains TBlock with ${exprs.length} expressions');
                        case _:
                    }
                }
                #end
                
                // Special handling for enum extraction patterns
                // When Haxe compiles case Ok(value), it generates:
                // 1. TVar(_g, TEnumParameter(...)) - extracts to temp
                // 2. TVar(value, TLocal(_g)) - assigns temp to actual variable
                // We need to check if the final variable is used
                var isEnumExtraction = false;
                var extractedFromTemp = "";
                if (init != null) {
                    switch(init.expr) {
                        case TEnumParameter(_, _, _):
                            // This is the temp extraction: _g = result.elem(1)
                            isEnumExtraction = true;
                        case TLocal(tempVar) if (tempVar.name.startsWith("_g") || tempVar.name == "g" || 
                                                 ~/^g\d+$/.match(tempVar.name)):
                            // This is assignment from temp: value = g (or _g, g1, g2, etc.)
                            extractedFromTemp = tempVar.name;
                        case _:
                    }
                }
                
                // DON'T rename underscore variables in TVar - keep them as-is
                // The underscore indicates they are compiler-generated temporaries
                // and should be preserved to maintain consistency
                var varName = v.name;
                var idKey = Std.string(v.id);
                
                // Don't trust Reflaxe's unused metadata for TVar declarations
                // It's often incorrect for variables used in complex expressions
                //
                // EXAMPLE: In BalancedTree.balance(), variables like this:
                //   var k = match.k;  // TVar declaration, marked as -reflaxe.unused
                //   var v = match.v;  // TVar declaration, marked as -reflaxe.unused
                //   return new Node(k, v, left, right);  // Used here in TNew!
                //
                // The variables ARE used in the Node constructor call, but Reflaxe's
                // MarkUnusedVariablesImpl only detects TLocal references, missing TNew usage.
                // This causes incorrect underscore prefixing (_k, _v) while references
                // remain as (k, v), resulting in undefined variable errors.
                //
                // SOLUTION: We need the full function body context to properly detect usage,
                // which we don't have at TVar declaration time. That's why we handle this
                // in TFunction (lines 1100+) where we have access to the complete body
                // and can use our UsageDetector to accurately determine unused parameters.
                //
                var isUnused = false; // Disabled - proper detection happens at function level
                
                // For renamed temp variables, use the name directly without further conversion
                // Otherwise apply toElixirVarName for CamelCase conversion
                var baseName = if (tempVarRenameMap.exists(idKey)) {
                    tempVarRenameMap.get(idKey); // Use mapped name
                } else {
                    // Check if we have usage information from VariableUsageAnalyzer
                    var isUsed = if (variableUsageMap != null) {
                        variableUsageMap.exists(v.id) && variableUsageMap.get(v.id);
                    } else {
                        true; // Conservative default: assume used if no usage map
                    };
                    
                    // For _g variables from Haxe, always strip the underscore
                    // Haxe generates _g, _g1, etc. for temporaries but in Elixir we want g, g1
                    // This keeps the names consistent between declaration and reference
                    if (varName.charAt(0) == "_" && varName.charAt(1) == "g") {
                        // Always strip underscore from _g variables for consistency
                        toElixirVarName(varName, false); // false = strip underscore
                    } else {
                        // For non-_g variables, normal conversion
                        toElixirVarName(varName, false);
                    }
                };
                
                // Check if variable is used
                var isActuallyUsed = if (variableUsageMap != null && variableUsageMap.exists(v.id)) {
                    variableUsageMap.get(v.id);
                } else {
                    true; // Conservative: assume used if not in map
                };
                
                // If this variable is unused, prefix it with underscore to prevent Elixir warnings
                // This applies to:
                // 1. Variables extracted from enum parameters (value = g)
                // 2. Direct enum parameter extractions (g = result.elem(1))
                // 3. Any other unused variables detected by the analyzer
                var finalVarName = if (!isActuallyUsed) {
                    #if debug_variable_usage
                    trace('[TVar] Variable ${v.name} (id=${v.id}) is UNUSED, adding underscore prefix');
                    #end
                    "_" + baseName;
                } else {
                    baseName;
                };
                
                
                // Handle variable initialization
                var matchNode = if (init != null) {
                    // Check if init is a TBlock with null coalescing pattern
                    var initValue = switch(init.expr) {
                        case TBlock([{expr: TVar(tmpVar, tmpInit)}, {expr: TBinop(OpNullCoal, {expr: TLocal(localVar)}, defaultExpr)}])
                            if (localVar.id == tmpVar.id && tmpInit != null):
                            // This is null coalescing pattern: generate inline if expression
                            var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
                            var initAst = buildFromTypedExpr(tmpInit, variableUsageMap);
                            var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
                            
                            // Generate: if (tmp = init) != nil, do: tmp, else: default
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, 
                                    makeAST(EMatch(PVar(tmpVarName), initAst)),
                                    makeAST(ENil)
                                )),
                                makeAST(EVar(tmpVarName)),
                                defaultAst
                            ));
                            // Mark as inline for null coalescing
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            ifExpr;
                            
                        case _:
                            // Regular init expression
                            var builtInit = buildFromTypedExpr(init, variableUsageMap);
                            
                            
                            builtInit;
                    };
                    
                    var result = makeAST(EMatch(
                        PVar(finalVarName),
                        initValue
                    ));
                    
                    
                    result;
                } else {
                    // Uninitialized variable - use nil
                    makeAST(EMatch(
                        PVar(finalVarName),
                        makeAST(ENil)
                    ));
                };
                
                
                matchNode.def;
                
            // ================================================================
            // Binary Operations
            // ================================================================
            case TBinop(op, e1, e2):
                // Check if either operand is an inline expansion block
                var left = switch(e1.expr) {
                    case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
                        makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));
                    case _:
                        buildFromTypedExpr(e1, variableUsageMap);
                };
                
                var right = switch(e2.expr) {
                    case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
                        makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));
                    case _:
                        buildFromTypedExpr(e2, variableUsageMap);
                };
                
                switch(op) {
                    /**
                     * ADDITION AND STRING CONCATENATION OPERATOR
                     * 
                     * WHY: Elixir distinguishes between numeric addition and string concatenation
                     * - Numbers use + operator for addition
                     * - Strings use <> operator for concatenation
                     * - Using + on strings causes compilation errors in Elixir
                     * 
                     * WHAT: Type-aware operator selection for addition operations
                     * - Detect String types through type inspection
                     * - Generate StringConcat for string operations
                     * - Generate Add for numeric operations
                     * 
                     * HOW: Examine left operand type to determine operation
                     * - TInst with name "String": String class instance
                     * - TAbstract with name "String": String abstract type
                     * - All other types: Numeric addition
                     * 
                     * EXAMPLES:
                     * - Haxe: `"hello" + "world"` → Elixir: `"hello" <> "world"`
                     * - Haxe: `5 + 3` → Elixir: `5 + 3`
                     * - Haxe: `str1 + str2` → Elixir: `str1 <> str2` (if str1 is String)
                     */
                    case OpAdd: 
                        // Detect string concatenation based on left operand type
                        var isStringConcat = switch(e1.t) {
                            case TInst(_.get() => {name: "String"}, _): true;      // String class instance
                            case TAbstract(_.get() => {name: "String"}, _): true;  // String abstract type
                            default: false;
                        };
                        
                        // Generate appropriate binary operation
                        if (isStringConcat) {
                            EBinary(StringConcat, left, right);  // String concatenation: <>
                        } else {
                            EBinary(Add, left, right);           // Numeric addition: +
                        }
                    case OpSub: EBinary(Subtract, left, right);
                    case OpMult: EBinary(Multiply, left, right);
                    case OpDiv: EBinary(Divide, left, right);
                    case OpMod: EBinary(Remainder, left, right);
                    
                    case OpEq: EBinary(Equal, left, right);
                    case OpNotEq: EBinary(NotEqual, left, right);
                    case OpLt: EBinary(Less, left, right);
                    case OpLte: EBinary(LessEqual, left, right);
                    case OpGt: EBinary(Greater, left, right);
                    case OpGte: EBinary(GreaterEqual, left, right);
                    
                    case OpBoolAnd: EBinary(AndAlso, left, right);
                    case OpBoolOr: EBinary(OrElse, left, right);
                    
                    case OpAssign: EMatch(extractPattern(e1), right);
                    
                    /**
                     * COMPOUND ASSIGNMENT OPERATOR HANDLING
                     * 
                     * WHY: Elixir strings are immutable, requiring special handling for string concatenation
                     * - Numeric types use standard operators: +=, -=, *=, etc.
                     * - String concatenation MUST use <> operator, not +
                     * - Haxe's += on strings needs conversion to Elixir's <> operator
                     * 
                     * WHAT: Transform compound assignments (a += b) into expanded form (a = a op b)
                     * - Detect when the target variable is a String type
                     * - Use StringConcat operator for string concatenation
                     * - Use standard arithmetic operators for numeric types
                     * 
                     * HOW: Type-based operator selection
                     * 1. Check if operator is OpAdd (potential string concatenation)
                     * 2. Examine the type of the left-hand expression
                     * 3. Select StringConcat for String types, Add for numeric types
                     * 4. Generate EMatch with expanded binary operation
                     * 
                     * EXAMPLES:
                     * - Haxe: `result += "\\n"` → Elixir: `result = result <> "\\n"`
                     * - Haxe: `count += 1` → Elixir: `count = count + 1`
                     * - Haxe: `buffer += content` → Elixir: `buffer = buffer <> content` (if buffer is String)
                     * 
                     * EDGE CASES:
                     * - Dynamic types: Falls back to Add operator (may cause runtime errors)
                     * - Mixed types: Relies on Haxe's type checking for correctness
                     * - Null strings: Handled by Elixir's <> operator semantics
                     */
                    case OpAssignOp(op2): 
                        // Transform compound assignment: a += b becomes a = a + b
                        // Special handling for string concatenation in Elixir
                        var innerOp = if (op2 == OpAdd) {
                            // Detect string concatenation based on left-hand expression type
                            var isStringConcat = switch(e1.t) {
                                case TInst(_.get() => {name: "String"}, _): true;      // String class instance
                                case TAbstract(_.get() => {name: "String"}, _): true;  // String abstract type
                                default: false;
                            };
                            // Select appropriate operator: <> for strings, + for numbers
                            isStringConcat ? StringConcat : Add;
                        } else {
                            // Non-addition operators: -, *, /, %, &, |, ^, <<, >>
                            convertAssignOp(op2);
                        }
                        // Generate assignment with expanded binary operation
                        EMatch(extractPattern(e1), makeAST(EBinary(innerOp, left, right)));
                    
                    case OpAnd: EBinary(BitwiseAnd, left, right);
                    case OpOr: EBinary(BitwiseOr, left, right);
                    case OpXor: EBinary(BitwiseXor, left, right);
                    case OpShl: EBinary(ShiftLeft, left, right);
                    case OpShr: EBinary(ShiftRight, left, right);
                    case OpUShr: EBinary(ShiftRight, left, right); // No unsigned in Elixir
                    
                    case OpInterval: ERange(left, right, false);
                    case OpArrow: EFn([{
                        args: [PVar("_arrow")], // Placeholder, will be transformed
                        body: right
                    }]);
                    case OpIn: EBinary(In, left, right);
                    case OpNullCoal: 
                        // a ?? b needs special handling to avoid double evaluation
                        // For complex expressions, we need a temp variable in the condition
                        // Generate: if (tmp = a) != nil, do: tmp, else: b
                        
                        // Check if left is a simple variable that can be referenced multiple times
                        var isSimple = switch(left.def) {
                            case EVar(_): true;
                            case ENil: true;
                            case EBoolean(_): true;
                            case EInteger(_): true;
                            case EString(_): true;
                            case _: false;
                        };
                        
                        if (isSimple) {
                            // Simple expression can be used directly
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, left, makeAST(ENil))),
                                left,
                                right
                            ));
                            // Mark as inline for null coalescing
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            ifExpr.def;
                        } else {
                            // Complex expression needs temp variable to avoid double evaluation
                            // Generate: if (tmp = expr) != nil, do: tmp, else: default
                            var tmpVar = makeAST(EVar("tmp"));
                            var assignment = makeAST(EMatch(PVar("tmp"), left));
                            
                            // Mark this if expression to stay inline when assigned
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, assignment, makeAST(ENil))),
                                tmpVar,
                                right
                            ));
                            // Set metadata to indicate this should stay inline
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            ifExpr.def;
                        }
                }
                
            // ================================================================
            // Unary Operations
            // ================================================================
            case TUnop(op, postFix, e):
                // Special handling for OpNot with TBlock
                // This happens when Haxe desugars complex expressions like !map.exists(key)
                switch(op) {
                    case OpNot:
                        switch(e.expr) {
                            case TBlock([]):
                                // Empty block - just return not(nil)
                                EUnary(Not, makeAST(ENil));
                            case TBlock(exprs) if (exprs.length == 1):
                                // Single expression block - unwrap it
                                EUnary(Not, buildFromTypedExpr(exprs[0], variableUsageMap));
                            case TBlock(exprs):
                                // Multiple expressions - this is the problematic case
                                // Extract all but the last expression as statements
                                var statements = [];
                                for (i in 0...exprs.length - 1) {
                                    statements.push(buildFromTypedExpr(exprs[i], variableUsageMap));
                                }
                                // Apply not to the last expression
                                var lastExpr = buildFromTypedExpr(exprs[exprs.length - 1], variableUsageMap);
                                statements.push(makeAST(EUnary(Not, lastExpr)));
                                // Return a block with statements
                                EBlock(statements);
                            default:
                                // Normal case - just apply not
                                var expr = buildFromTypedExpr(e, variableUsageMap).def;
                                EUnary(Not, makeAST(expr));
                        }
                    case OpNeg: 
                        var expr = buildFromTypedExpr(e, variableUsageMap).def;
                        EUnary(Negate, makeAST(expr));
                    case OpNegBits:
                        var expr = buildFromTypedExpr(e, variableUsageMap).def;
                        EUnary(BitwiseNot, makeAST(expr));
                    case OpIncrement, OpDecrement:
                        // Elixir is immutable, so we need to generate an assignment
                        // When used as a statement, convert to: var = var + 1 or var = var - 1
                        var one = makeAST(EInteger(1));
                        var builtExpr = buildFromTypedExpr(e, variableUsageMap);
                        var operation = if (op == OpIncrement) {
                            makeAST(EBinary(Add, builtExpr, one));
                        } else {
                            makeAST(EBinary(Subtract, builtExpr, one));
                        };
                        
                        // If this is a standalone statement (not part of another expression),
                        // we need to generate an assignment
                        // Check if the original expression is a local variable that can be assigned
                        switch(e.expr) {
                            case TLocal(v):
                                // Generate: var = var +/- 1
                                EBinary(Match, builtExpr, operation);
                            default:
                                // For complex expressions, just return the operation
                                // (this may not work correctly for all cases)
                                operation.def;
                        };
                    case OpSpread:
                        // Spread operator for destructuring
                        var builtExpr = buildFromTypedExpr(e, variableUsageMap);
                        EUnquoteSplicing(builtExpr);
                }
                
            // ================================================================
            // Function Calls
            // ================================================================
            case TCall(e, el):
                // Check if this is an enum constructor call first
                if (e != null && isEnumConstructor(e)) {
                    // ONLY BUILD - NO TRANSFORMATION!
                    var tag = extractEnumTag(e);
                    
                    // For idiomatic enums, convert constructor names to snake_case
                    // This ensures Result.Ok becomes :ok and Result.Error becomes :error
                    if (hasIdiomaticMetadata(e)) {
                        tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
                    }
                    
                    var args = [for (arg in el) buildFromTypedExpr(arg, variableUsageMap)];
                    
                    // Create the tuple AST definition
                    var tupleDef = ETuple([makeAST(EAtom(tag))].concat(args));
                    
                    #if debug_ast_builder
                    if (hasIdiomaticMetadata(e)) {
                        trace('[AST Builder] Building idiomatic enum tuple: ${tag} with ${args.length} args');
                        trace('[AST Builder] Enum type: ${getEnumTypeName(e)}');
                    }
                    #end
                    
                    // The metadata will be set by the outer buildFromTypedExpr function
                    tupleDef;
                } else {
                    // Regular function call
                    var args = [for (arg in el) buildFromTypedExpr(arg, variableUsageMap)];
                    
                    /**
                     * CRITICAL FIX PART 2: Handle Static Extern Method Calls (2025-09-05)
                     * 
                     * This is the second part of the fix for static methods on extern classes.
                     * When we detect a call to a static method on an extern class with @:native,
                     * we generate a proper ERemoteCall instead of a regular ECall.
                     * 
                     * DETECTION: Check if the target is TField with FStatic on an extern class
                     * - The class must be extern
                     * - The class must have @:native annotation with module name
                     * - The field access must be FStatic
                     * 
                     * TRANSFORMATION:
                     * Instead of: ECall(EField(...), args) which would print as "list(args)"  
                     * We generate: ERemoteCall(module, method, args) which prints as "Module.method(args)"
                     * 
                     * This ensures all static methods on extern classes with @:native annotations
                     * are properly qualified with their module names in the generated Elixir code.
                     */
                    // Check if this is a static method call on an extern class
                    if (e != null) {
                        switch(e.expr) {
                            case TField(_, FStatic(classRef, cf)):
                                var classType = classRef.get();
                                if (classType.isExtern && classType.meta.has(":native")) {
                                    // Extract the native module name
                                    var nativeModuleName = "";
                                    var nativeMeta = classType.meta.extract(":native");
                                    if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
                                        switch(nativeMeta[0].params[0].expr) {
                                            case EConst(CString(s, _)):
                                                nativeModuleName = s;
                                            default:
                                        }
                                    }
                                    
                                    if (nativeModuleName != "") {
                                        // Generate remote call with full module qualification
                                        var methodName = cf.get().name;
                                        return ERemoteCall(makeAST(EVar(nativeModuleName)), methodName, args);
                                    }
                                }
                            default:
                        }
                    }
                    
                    // Build target normally for other cases
                    var target = e != null ? buildFromTypedExpr(e, variableUsageMap) : null;
                    
                    // Detect special call patterns
                    switch(e.expr) {
                        case TIdent("__elixir__"):
                            // Handle __elixir__ injection
                            if (args.length > 0) {
                                switch(args[0].def) {
                                    case EString(code):
                                        // Process parameter substitution if needed
                                        var processedCode = code;
                                        if (args.length > 1) {
                                            // Substitute parameters in the code string
                                            for (i in 1...args.length) {
                                                // Convert AST to string for substitution
                                                var paramStr = ElixirASTPrinter.printAST(args[i]);
                                                // Replace {i-1} placeholder with the parameter
                                                var placeholder = '{${i-1}}';
                                                processedCode = StringTools.replace(processedCode, placeholder, paramStr);
                                            }
                                        }
                                        // Return raw Elixir code
                                        ERaw(processedCode);
                                    default:
                                        // Not a string constant, can't inject
                                        ECall(target, "call", args);
                                }
                            } else {
                                // No arguments to __elixir__
                                ECall(target, "call", args);
                            }
                        case TField(obj, fa):
                            var fieldName = extractFieldName(fa);
                            var objAst = buildFromTypedExpr(obj, variableUsageMap);
                            
                            // Special handling for tuple.elem(N) -> elem(tuple, N)
                            if (fieldName == "elem" && args.length == 1) {
                                // Transform to Elixir's elem(tuple, index) function
                                return ECall(null, "elem", [objAst, args[0]]);
                            }
                            
                            // Check for Assert class calls (ExUnit assertions)
                            if (isAssertClass(obj)) {
                                // This is an Assert.method() call - compile to ExUnit assertion
                                var assertAst = reflaxe.elixir.ast.builders.ExUnitCompiler.compileAssertion(fieldName, args);
                                return assertAst.def;
                            }
                            // Check for HXX.hxx() template calls
                            else if (fieldName == "hxx" && isHXXModule(obj)) {
                                // HXX.hxx() returns a processed template string that needs ~H sigil
                                // The macro already processed the template, we just need to wrap it
                                if (args.length == 1) {
                                    // Extract the processed template string and wrap in ~H sigil
                                    switch(args[0].def) {
                                        case EString(content):
                                            // Wrap the processed template in HEEx sigil
                                            ESigil("H", content, "");
                                        default:
                                            // Non-string argument, compile as regular call
                                            ECall(objAst, fieldName, args);
                                    }
                                } else {
                                    // Wrong number of arguments, compile as regular call
                                    ECall(objAst, fieldName, args);
                                }
                            }
                            // Check for module calls
                            else if (isModuleCall(obj)) {
                                // Check if this is an extern static method with its own @:native
                                var hasNativeMetadata = false;
                                var nativeName: String = null;
                                
                                switch(fa) {
                                    case FStatic(_, cf):
                                        var classField = cf.get();
                                        if (classField.meta.has(":native")) {
                                            var nativeMeta = classField.meta.extract(":native");
                                            if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
                                                switch(nativeMeta[0].params[0].expr) {
                                                    case EConst(CString(s, _)):
                                                        hasNativeMetadata = true;
                                                        nativeName = s;
                                                    default:
                                                }
                                            }
                                        }
                                    default:
                                }
                                
                                if (hasNativeMetadata && nativeName != null) {
                                    // Method has its own @:native, use it directly
                                    // Split the native name to get module and function
                                    var parts = nativeName.split(".");
                                    if (parts.length > 1) {
                                        var module = parts.slice(0, parts.length - 1).join(".");
                                        var funcName = parts[parts.length - 1];
                                        ERemoteCall(makeAST(EVar(module)), funcName, args);
                                    } else {
                                        // Just a function name, use with the module
                                        ERemoteCall(objAst, nativeName, args);
                                    }
                                } else {
                                    // Regular module call - convert method name to snake_case for Elixir
                                    var elixirFuncName = toSnakeCase(fieldName);
                                    
                                    // Check if this is a same-module call
                                    if (currentModule != null) {
                                        switch(obj.expr) {
                                            case TTypeExpr(m):
                                                var moduleName = moduleTypeToString(m);
                                                #if debug_same_module_calls
                                                trace('[Same Module Check] Current: $currentModule, Called: $moduleName, Method: $elixirFuncName');
                                                #end
                                                if (moduleName == currentModule) {
                                                    // Same module call - just use the function name without module prefix
                                                    ECall(null, elixirFuncName, args);
                                                } else {
                                                    // Different module - use remote call
                                                    ERemoteCall(objAst, elixirFuncName, args);
                                                }
                                            default:
                                                // Not a module type expression, use remote call
                                                ERemoteCall(objAst, elixirFuncName, args);
                                        }
                                    } else {
                                        // No current module context, use remote call
                                        #if debug_same_module_calls
                                        switch(obj.expr) {
                                            case TTypeExpr(m):
                                                var moduleName = moduleTypeToString(m);
                                                trace('[Same Module Check] No context set! Module: $moduleName, Method: $elixirFuncName');
                                            default:
                                        }
                                        #end
                                        ERemoteCall(objAst, elixirFuncName, args);
                                    }
                                }
                            } else {
                                // Check if this is a method call that contains __elixir__() injection
                                var methodHasElixirInjection = false;
                                var expandedElixir: ElixirAST = null;
                                
                                // Try to get the method body to check for __elixir__
                                switch(fa) {
                                    case FInstance(_, _, cf):
                                        var classField = cf.get();
                                        var methodExpr = classField.expr();
                                        #if debug_ast_builder
                                        trace('[AST Builder] Checking method ${fieldName}, has expr: ${methodExpr != null}');
                                        #end
                                        if (methodExpr != null) {
                                            // Check if the method body contains __elixir__()
                                            expandedElixir = tryExpandElixirInjection(methodExpr, obj, el);
                                            methodHasElixirInjection = (expandedElixir != null);
                                            #if debug_ast_builder
                                            trace('[AST Builder] Method ${fieldName} has __elixir__: $methodHasElixirInjection');
                                            #end
                                        }
                                    default:
                                }
                                
                                if (methodHasElixirInjection && expandedElixir != null) {
                                    // Method contains __elixir__(), use the expanded version
                                    return expandedElixir.def;
                                } else if (isArrayType(obj.t)) {
                                    // Check for array/list operations that come from loop desugaring
                                    // These need special handling because Haxe desugars loops into array operations
                                    switch(fieldName) {
                                        case "filter" if (args.length == 1):
                                            // Loop desugaring often generates array.filter()
                                            // Transform: array.filter(fn) → Enum.filter(array, fn)
                                            ERemoteCall(makeAST(EVar("Enum")), "filter", [objAst, args[0]]);
                                            
                                        case "map" if (args.length == 1):
                                            // Loop desugaring often generates array.map()
                                            // Transform: array.map(fn) → Enum.map(array, fn)
                                            ERemoteCall(makeAST(EVar("Enum")), "map", [objAst, args[0]]);
                                            
                                        case "push" if (args.length == 1):
                                            // Array push operations from comprehension desugaring
                                            // Transform: array.push(value) → array ++ [value]
                                            // Note: This creates a new list, doesn't mutate
                                            EBinary(Concat, objAst, makeAST(EList([args[0]])));
                                            
                                        default:
                                            // All other array methods use standard call generation
                                            ECall(objAst, fieldName, args);
                                    }
                                }
                                // Check for Map operations that need transformation
                                else if (isMapType(obj.t)) {
                                    // Transform Map methods to Elixir Map module functions
                                    switch(fieldName) {
                                        case "set" if (args.length == 2):
                                            // map.set(key, value) → Map.put(map, key, value)
                                            ERemoteCall(makeAST(EVar("Map")), "put", [objAst].concat(args));
                                        case "get" if (args.length == 1):
                                            // map.get(key) → Map.get(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "get", [objAst].concat(args));
                                        case "remove" if (args.length == 1):
                                            // map.remove(key) → Map.delete(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "delete", [objAst].concat(args));
                                        case "exists" if (args.length == 1):
                                            // map.exists(key) → Map.has_key?(map, key)
                                            ERemoteCall(makeAST(EVar("Map")), "has_key?", [objAst].concat(args));
                                        case "keys" if (args.length == 0):
                                            // map.keys() → Map.keys(map)
                                            ERemoteCall(makeAST(EVar("Map")), "keys", [objAst]);
                                        case "values" if (args.length == 0):
                                            // map.values() → Map.values(map)
                                            ERemoteCall(makeAST(EVar("Map")), "values", [objAst]);
                                        default:
                                            // Fallback for other Map methods
                                            ECall(objAst, fieldName, args);
                                    }
                                } else {
                                    // Instance method call
                                    ECall(objAst, fieldName, args);
                                }
                            }
                        case TLocal(v):
                            // Check if this is a function variable (needs .() syntax in Elixir)
                            // Function variables in Elixir require .() syntax for invocation
                            var isFunctionVar = switch(v.t) {
                                case TFun(_, _): true;
                                case TAbstract(t, params):
                                    var abs = t.get();
                                    // Check for Function or Fn abstracts
                                    if (abs.name == "Function" || abs.name == "Fn") {
                                        true;
                                    } else if (abs.name == "Null" && params.length == 1) {
                                        // Check for Null<Function> (optional function parameters)
                                        switch(params[0]) {
                                            case TFun(_, _): true;
                                            default: false;
                                        }
                                    } else {
                                        false;
                                    }
                                default: false;
                            };
                            
                            #if debug_lambda_function_calls
                            trace('[AST Builder] TLocal call: ${v.name}, type: ${v.t}, isFunctionVar: ${isFunctionVar}');
                            #end
                            
                            if (isFunctionVar) {
                                // Function variable call - needs special handling for .() syntax
                                // We'll create a special marker that the printer will recognize
                                ECall(makeAST(EVar(toElixirVarName(v.name))), "", args);
                            } else {
                                // Regular local function call
                                ECall(null, toElixirVarName(v.name), args);
                            }
                        default:
                            if (target != null) {
                                // Complex target expression
                                ECall(target, "call", args);
                            } else {
                                // Should not happen
                                ECall(null, "unknown_call", args);
                            }
                    }
                }
                
            // ================================================================
            // Field Access
            // ================================================================
            case TField(e, fa):
                // Check for enum constructor references
                switch(fa) {
                    case FEnum(enumType, ef):
                        // Enum constructor reference (no arguments)
                        // Convert CamelCase to snake_case for Elixir atoms
                        var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(ef.name);
                        EAtom(atomName);
                    case FStatic(classRef, cf):
                        // Regular static field access
                        // The TCall handler will detect if this needs special handling for extern classes
                        var target = buildFromTypedExpr(e, variableUsageMap);
                        var fieldName = extractFieldName(fa);
                        EField(target, fieldName);
                    case FAnon(cf):
                        // Anonymous field access - check for tuple pattern
                        var fieldName = cf.get().name;
                        var target = buildFromTypedExpr(e, variableUsageMap);
                        
                        if (~/^_\d+$/.match(fieldName)) {
                            // This is a tuple field access like tuple._1, tuple._2
                            // Convert to elem(tuple, index) where index is 0-based
                            var index = Std.parseInt(fieldName.substr(1)) - 1; // _1 -> 0, _2 -> 1
                            ECall(null, "elem", [target, makeAST(EInteger(index))]);
                        } else {
                            // Regular anonymous field access
                            EField(target, fieldName);
                        }
                    default:
                        // Regular field access
                        var target = buildFromTypedExpr(e, variableUsageMap);
                        var fieldName = extractFieldName(fa);
                        
                        #if debug_ast_pipeline
                        // Debug field access on p1/p2 variables
                        switch(e.expr) {
                            case TLocal(v) if (v.name == "p1" || v.name == "p2"):
                                trace('[AST Builder] Field access: ${v.name}.${fieldName} (id=${v.id})');
                            default:
                        }
                        #end
                        
                        // Special handling for tuple.elem(N) field access
                        // This occurs when switch statements on Result enums generate field access
                        // We need to prepare for transformation to elem(tuple, N) function calls
                        if (fieldName == "elem") {
                            // Mark this as a tuple element access for later transformation
                            // The transformer will convert this to proper elem() calls
                            EField(target, fieldName);
                        } else if (isMapAccess(e.t)) {
                            // Detect map/struct access patterns
                            EAccess(target, makeAST(EAtom(fieldName)));
                        } else {
                            EField(target, fieldName);
                        }
                }
                
            // ================================================================
            // Array Operations
            // ================================================================
            case TArrayDecl(el):
                // Check if this array contains idiomatic enum constructors or function calls returning them
                var hasIdiomaticEnums = false;
                for (e in el) {
                    switch(e.expr) {
                        case TCall(callTarget, _) if (callTarget != null && isEnumConstructor(callTarget) && hasIdiomaticMetadata(callTarget)):
                            hasIdiomaticEnums = true;
                            break;
                        case TCall(_, _):
                            // Check if function call returns idiomatic enum
                            switch(e.t) {
                                case TEnum(enumRef, _) if (enumRef.get().meta.has(":elixirIdiomatic")):
                                    hasIdiomaticEnums = true;
                                    break;
                                default:
                            }
                        default:
                    }
                }
                
                #if debug_ast_builder
                if (hasIdiomaticEnums) {
                    trace('[AST Builder] Building array with idiomatic enum elements');
                }
                #end
                
                var elements = [for (e in el) buildFromTypedExpr(e, variableUsageMap)];
                EList(elements);
                
            case TArray(e, index):
                var target = buildFromTypedExpr(e, variableUsageMap);
                var key = buildFromTypedExpr(index, variableUsageMap);
                EAccess(target, key);
                
            // ================================================================
            // Control Flow (Basic)
            // ================================================================
            case TIf(econd, eif, eelse):
                // Check if the condition is an inline expansion block
                var condition = switch(econd.expr) {
                    case TBlock(el) if (ElixirASTPatterns.isInlineExpansionBlock(el)):
                        #if debug_inline_expansion
                        trace('[XRay InlineExpansion] Detected inline expansion in if condition');
                        #end
                        makeAST(ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name)));
                    case _:
                        buildFromTypedExpr(econd, variableUsageMap);
                };
                var thenBranch = buildFromTypedExpr(eif, variableUsageMap);
                var elseBranch = eelse != null ? buildFromTypedExpr(eelse, variableUsageMap) : null;
                EIf(condition, thenBranch, elseBranch);
                
            case TBlock(el):
                #if debug_null_coalescing
                trace('[AST Builder] TBlock with ${el.length} expressions');
                for (i in 0...el.length) {
                    trace('[AST Builder]   Block[$i]: ${Type.enumConstructor(el[i].expr)}');
                }
                #end
                
                // CRITICAL: Check for array building pattern FIRST
                // Haxe desugars array.map() into a TBlock containing:
                // 1. var _g = []
                // 2. var _g1 = 0  
                // 3. var _g2 = sourceArray
                // 4. while(_g1 < _g2.length) { ... }
                // 5. _g (return value)
                if (el.length >= 5) {
                    var hasEmptyArray = false;
                    var hasZeroInit = false;
                    var hasSourceAssign = false;
                    var hasWhileLoop = false;
                    var returnsResult = false;
                    var sourceArray: TypedExpr = null;
                    var whileBody: TypedExpr = null;
                    var resultVarName: String = null;
                    
                    for (i in 0...el.length) {
                        switch(el[i].expr) {
                            case TVar(v, init) if (init != null && v.name.startsWith("_g")):
                                switch(init.expr) {
                                    case TArrayDecl([]): 
                                        hasEmptyArray = true;
                                        resultVarName = v.name;
                                    case TConst(TInt(i)) if (i == 0): 
                                        hasZeroInit = true;
                                    case TLocal(_): 
                                        hasSourceAssign = true;
                                        sourceArray = init;
                                    case _:
                                }
                            case TWhile(_, body, _):
                                hasWhileLoop = true;
                                whileBody = body;
                            case TLocal(v) if (v.name == resultVarName && i == el.length - 1):
                                returnsResult = true;
                            case _:
                        }
                    }
                    
                    var isArrayPattern = hasEmptyArray && hasZeroInit && hasSourceAssign && hasWhileLoop && returnsResult;
                    
                    #if debug_array_patterns
                    trace('[XRay ArrayPattern] TBlock check: empty=$hasEmptyArray, zero=$hasZeroInit, source=$hasSourceAssign, while=$hasWhileLoop, returns=$returnsResult');
                    #end
                    
                    if (isArrayPattern && sourceArray != null && whileBody != null) {
                        var operation = ElixirASTPatterns.detectArrayOperationPattern(whileBody);
                        
                        #if debug_array_patterns
                        trace('[XRay ArrayPattern] Detected operation: $operation');
                        #end
                        
                        if (operation != null) {
                            // Generate idiomatic Enum call instead of the block
                            return generateIdiomaticEnumCall(sourceArray, operation, whileBody);
                        }
                    }
                }
                
                // Check for null coalescing pattern: TVar followed by TBinop(OpNullCoal) using that var
                // This pattern is generated by Haxe when the left side of ?? isn't simple
                if (el.length == 2) {
                    switch([el[0].expr, el[1].expr]) {
                        case [TVar(tmpVar, init), TBinop(OpNullCoal, {expr: TLocal(v)}, defaultExpr)] 
                            if (v.id == tmpVar.id && init != null):
                            // This is the null coalescing pattern with temp variable
                            // Don't generate a block - generate inline if expression
                            var initAst = buildFromTypedExpr(init, variableUsageMap);
                            var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
                            var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
                            
                            // Generate: if (tmp = init) != nil, do: tmp, else: default
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, 
                                    makeAST(EMatch(PVar(tmpVarName), initAst)),
                                    makeAST(ENil)
                                )),
                                makeAST(EVar(tmpVarName)),
                                defaultAst
                            ));
                            // Mark as inline for null coalescing
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            return ifExpr.def;
                        case _:
                            // Not the null coalescing pattern
                    }
                }
                
                // Check for inline expansion pattern at TypedExpr level
                if (ElixirASTPatterns.isInlineExpansionBlock(el)) {
                    return ElixirASTPatterns.transformInlineExpansion(el, function(e) return buildFromTypedExpr(e, variableUsageMap), function(name) return toElixirVarName(name));
                }
                
                // Special handling for TBlock in expression contexts
                // When Haxe desugars expressions like !map.exists(key), it creates:
                // TBlock([TVar(tmp, key), map.has_key(tmp)])
                // In expression contexts, this needs special handling to avoid invalid syntax
                if (el.length == 2) {
                    switch([el[0].expr, el[1].expr]) {
                        case [TVar(v, init), expr] if (init != null):
                            // This is a temporary variable pattern
                            // Check if the variable is unused and add underscore prefix
                            var isUsed = if (variableUsageMap != null && variableUsageMap.exists(v.id)) {
                                variableUsageMap.get(v.id);
                            } else {
                                true; // Conservative: assume used if not in map
                            };
                            
                            // Build the assignment
                            var baseName = toElixirVarName(v.name);
                            var varName = if (!isUsed) {
                                #if debug_variable_usage
                                trace('[TBlock] Variable ${v.name} (id=${v.id}) is UNUSED, adding underscore prefix');
                                #end
                                "_" + baseName;
                            } else {
                                baseName;
                            };
                            
                            var initExpr = buildFromTypedExpr(init, variableUsageMap);
                            var bodyExpr = buildFromTypedExpr(el[1], variableUsageMap);
                            
                            // Generate a block with the assignment extracted
                            // This will be handled by the assignment extraction pass
                            return EBlock([
                                makeAST(EMatch(PVar(varName), initExpr)),
                                bodyExpr
                            ]);
                        default:
                            // Not the pattern we're looking for
                    }
                }
                
                // Build all expressions
                var expressions = [for (e in el) buildFromTypedExpr(e, variableUsageMap)];
                
                // Check if we need to combine inline expansions
                // Look for patterns like: c = index = expr; obj.method(index)
                var needsCombining = false;
                for (i in 0...expressions.length - 1) {
                    var current = expressions[i];
                    var next = expressions[i + 1];
                    
                    // Check for assignment followed by method call pattern
                    switch([current.def, next.def]) {
                        case [EMatch(_, _), ECall(_, _, _)]:
                            needsCombining = true;
                            break;
                        case _:
                    }
                }
                
                if (needsCombining) {
                    // Use the existing InlineExpansionTransforms to combine split patterns
                    // This handles cases where inline expansions are created during AST building
                    var combinedBlock = makeAST(EBlock(expressions));
                    var transformed = reflaxe.elixir.ast.transformers.InlineExpansionTransforms.inlineMethodCallCombinerPass(combinedBlock);
                    
                    // Return the transformed block's definition
                    transformed.def;
                } else {
                    // No combining needed, return regular block
                    EBlock(expressions);
                }
                
            case TReturn(e):
                if (e != null) {
                    buildFromTypedExpr(e, variableUsageMap).def; // Return value is implicit in Elixir
                } else {
                    ENil; // Explicit nil return
                }
                
            case TBreak:
                EThrow(makeAST(EAtom("break"))); // Will be transformed
                
            case TContinue:
                EThrow(makeAST(EAtom("continue"))); // Will be transformed
                
            // ================================================================
            // Pattern Matching (Switch/Case)
            // ================================================================
            case TSwitch(e, cases, edef):
                var expr = buildFromTypedExpr(e, variableUsageMap).def;
                var clauses = [];
                
                // Check if this is a topic_to_string-style temp variable switch
                // These need special handling for return context
                var needsTempVar = false;
                var tempVarName = "temp_result";
                
                // Detect if switch is in return context
                var isReturnContext = false; // TODO: Will be set via metadata
                
                for (c in cases) {
                    var patterns = [for (v in c.values) convertPattern(v)];
                    
                    // Analyze the case body for enum parameter usage
                    var body = buildFromTypedExpr(c.expr, variableUsageMap);
                    
                    // processEnumCaseBody is disabled - we use VariableUsageAnalyzer instead
                    // which provides more accurate detection across the entire function scope
                    
                    // Multiple patterns become multiple clauses
                    for (pattern in patterns) {
                        clauses.push({
                            pattern: pattern,
                            guard: null, // Guards will be added in transformation
                            body: body
                        });
                    }
                }
                
                // Default case
                if (edef != null) {
                    clauses.push({
                        pattern: PWildcard,
                        guard: null,
                        body: buildFromTypedExpr(edef, variableUsageMap)
                    });
                }
                
                // Create the case expression
                var caseASTDef = ECase(makeAST(expr), clauses);
                
                // If in return context and needs temp var, wrap in assignment
                if (isReturnContext && needsTempVar) {
                    EBlock([
                        makeAST(EMatch(PVar(tempVarName), makeAST(caseASTDef))),
                        makeAST(EVar(tempVarName))
                    ]);
                } else {
                    caseASTDef;
                }
                
            // ================================================================
            // Try/Catch
            // ================================================================
            case TTry(e, catches):
                var body = buildFromTypedExpr(e);
                var rescueClauses = [];
                
                for (c in catches) {
                    var pattern = PVar(toElixirVarName(c.v.name));
                    var catchBody = buildFromTypedExpr(c.expr);
                    
                    rescueClauses.push({
                        pattern: pattern,
                        body: catchBody
                    });
                }
                
                ETry(body, rescueClauses, [], null, null);
                
            // ================================================================
            // Lambda/Anonymous Functions
            // ================================================================
            case TFunction(f):
                // Debug: Check for abstract method "this" parameter issue
                #if debug_ast_pipeline
                for (arg in f.args) {
                    trace('[AST Builder] TFunction arg: ${arg.v.name} (id=${arg.v.id})');
                }
                #end
                
                var args = [];
                var paramRenaming = new Map<String, String>();
                
                // Now build the body with awareness of parameter mappings
                // We need to temporarily override the collision detection for these parameters
                var oldTempVarRenameMap = tempVarRenameMap;
                tempVarRenameMap = new Map();
                for (key in oldTempVarRenameMap.keys()) {
                    tempVarRenameMap.set(key, oldTempVarRenameMap.get(key));
                }
                
                // Process all parameters: handle naming, unused prefixing, and registration
                for (arg in f.args) {
                    var originalName = arg.v.name;
                    var idKey = Std.string(arg.v.id);
                    
                    // Use our enhanced usage detection instead of trusting Reflaxe metadata
                    var isActuallyUnused = if (f.expr != null) {
                        reflaxe.elixir.helpers.UsageDetector.isParameterUnused(arg.v, f.expr);
                    } else {
                        false; // If no body, consider parameter as potentially used
                    };
                    
                    // Convert to snake_case for Elixir conventions
                    var baseName = ElixirASTHelpers.toElixirVarName(originalName);
                    
                    // Debug: Check if reserved keyword
                    #if debug_reserved_keywords
                    if (isElixirReservedKeyword(baseName)) {
                        trace('[AST Builder] Reserved keyword detected in parameter: $baseName -> ${baseName}_param');
                    }
                    #end
                    
                    // Apply underscore prefix only if our comprehensive check confirms it's unused
                    var finalName = if (isActuallyUnused && !baseName.startsWith("_")) {
                        "_" + baseName;
                    } else {
                        baseName;
                    };
                    
                    // Register the mapping for TLocal references in the body
                    if (!tempVarRenameMap.exists(idKey)) {
                        tempVarRenameMap.set(idKey, finalName);
                    }
                    
                    // Track parameter mappings for collision detection
                    if (originalName != finalName) {
                        paramRenaming.set(originalName, finalName);
                        #if debug_ast_pipeline
                        trace('[AST Builder] Function parameter will be renamed: $originalName -> $finalName');
                        #end
                    }
                    
                    // Handle special case for abstract "this" parameters
                    if (originalName == "this1") {
                        // The body might try to rename this1 -> this due to collision detection
                        // We need to prevent that and use the parameter name instead
                        paramRenaming.set("this", finalName); // Map "this" to final name as well
                        #if debug_ast_pipeline
                        trace('[AST Builder] Abstract this parameter detected, mapping both this1 and this to: $finalName');
                        #end
                    }
                    
                    // Add the parameter to the function signature
                    args.push(PVar(finalName));
                    
                    functionParameterIds.set(idKey, true); // Mark as function parameter
                    #if debug_ast_pipeline
                    trace('[AST Builder] Registering parameter in rename map: id=$idKey');
                    #end
                }
                
                // Analyze variable usage in the function body
                // This is critical for proper underscore prefixing of unused variables
                var functionUsageMap = if (f.expr != null) {
                    reflaxe.elixir.helpers.VariableUsageAnalyzer.analyzeUsage(f.expr);
                } else {
                    null;
                };
                
                var body = buildFromTypedExpr(f.expr, functionUsageMap);
                
                // Restore the original map and clean up function parameter tracking
                tempVarRenameMap = oldTempVarRenameMap;
                for (arg in f.args) {
                    functionParameterIds.remove(Std.string(arg.v.id));
                }
                
                // Apply any remaining parameter renaming if needed
                if (paramRenaming.keys().hasNext()) {
                    #if debug_ast_pipeline
                    trace('[AST Builder] Applying parameter renaming to function body');
                    #end
                    body = applyParameterRenaming(body, paramRenaming);
                }
                
                EFn([{
                    args: args,
                    guard: null,
                    body: body
                }]);
                
            // ================================================================
            // Object/Anonymous Structure
            // ================================================================
            /**
             * Handles TObjectDecl conversion to either EMap or EKeywordList based on usage context.
             * 
             * Two special patterns are detected and handled:
             * 
             * 1. SUPERVISOR OPTIONS PATTERN:
             *    When an object contains OTP supervisor configuration fields (strategy, max_restarts, max_seconds),
             *    it's compiled to a keyword list instead of a map. This is required because Supervisor.start_link/2
             *    expects options as a keyword list, not a map.
             * 
             *    Example:
             *    ```haxe
             *    // Haxe source
             *    var opts = {strategy: OneForOne, max_restarts: 3, max_seconds: 5};
             *    ```
             *    
             *    ```elixir
             *    # Generated Elixir (keyword list, not map)
             *    opts = [strategy: :OneForOne, max_restarts: 3, max_seconds: 5]
             *    ```
             * 
             * 2. NULL COALESCING IN OBJECT FIELDS:
             *    Haxe generates a specific AST pattern for null coalescing operators (??) in object field values.
             *    This pattern is detected and transformed into idiomatic Elixir inline if-expressions.
             * 
             *    Example:
             *    ```haxe
             *    // Haxe source
             *    {field: someValue ?? defaultValue}
             *    ```
             *    
             *    ```elixir
             *    # Generated Elixir
             *    %{field: if (tmp = some_value) != nil, do: tmp, else: default_value}
             *    ```
             * 
             * @param fields Array of object field declarations from Haxe's TypedExpr
             * @return Either EKeywordList for supervisor options or EMap for regular objects
             */
            case TObjectDecl(fields):
                // First, check if this is a tuple pattern (anonymous structure with _1, _2, etc. fields)
                var isTuplePattern = true;
                var maxTupleIndex = 0;
                
                // Check if all fields follow the tuple naming pattern _1, _2, _3...
                for (field in fields) {
                    if (!~/^_\d+$/.match(field.name)) {
                        isTuplePattern = false;
                        break;
                    }
                    var index = Std.parseInt(field.name.substr(1));
                    if (index > maxTupleIndex) {
                        maxTupleIndex = index;
                    }
                }
                
                // If it's a tuple pattern, generate an Elixir tuple
                if (isTuplePattern && fields.length > 0) {
                    // Sort fields by index to ensure correct order
                    var sortedFields = fields.copy();
                    sortedFields.sort(function(a, b) {
                        var aIndex = Std.parseInt(a.name.substr(1));
                        var bIndex = Std.parseInt(b.name.substr(1));
                        return aIndex - bIndex;
                    });
                    
                    // Build tuple elements in order
                    var tupleElements = [];
                    for (field in sortedFields) {
                        tupleElements.push(buildFromTypedExpr(field.expr));
                    }
                    
                    return ETuple(tupleElements);
                }
                
                // Detect supervisor options pattern by checking for characteristic fields
                var hasStrategy = false;
                var hasMaxRestarts = false; 
                var hasMaxSeconds = false;
                
                // Detect child spec pattern
                var hasId = false;
                var hasStart = false;
                var hasType = false;
                
                for (field in fields) {
                    switch(field.name) {
                        case "strategy": hasStrategy = true;
                        case "max_restarts": hasMaxRestarts = true;
                        case "max_seconds": hasMaxSeconds = true;
                        case "id": hasId = true;
                        case "start": hasStart = true;
                        case "type": hasType = true;
                        case _:
                    }
                }
                
                // Supervisor options require keyword list format for Supervisor.start_link/2
                if (hasStrategy && (hasMaxRestarts || hasMaxSeconds)) {
                    var keywordPairs: Array<EKeywordPair> = [];
                    for (field in fields) {
                        // Convert field names to snake_case for idiomatic Elixir atoms
                        var atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(field.name);
                        var fieldValue = buildFromTypedExpr(field.expr);
                        keywordPairs.push({key: atomName, value: fieldValue});
                    }
                    EKeywordList(keywordPairs);
                } else if (hasId && hasStart) {
                    // Child spec pattern - needs special handling for the start field
                    var pairs = [];
                    for (field in fields) {
                        var key = makeAST(EAtom(field.name));
                        
                        // Special handling for the start field in child specs
                        var fieldValue = if (field.name == "start") {
                            // Check if start is an object with module/func/args
                            switch(field.expr.expr) {
                                case TObjectDecl(startFields):
                                    var moduleField = null;
                                    var funcField = null;
                                    var argsField = null;
                                    
                                    for (sf in startFields) {
                                        switch(sf.name) {
                                            case "module": moduleField = sf;
                                            case "func": funcField = sf;
                                            case "args": argsField = sf;
                                            case _:
                                        }
                                    }
                                    
                                    if (moduleField != null && funcField != null && argsField != null) {
                                        // Convert to tuple format {Module, :func, args}
                                        var moduleAst = switch(moduleField.expr.expr) {
                                            case TConst(TString(s)):
                                                // Convert string module name to atom
                                                makeAST(EVar(s));
                                            case _:
                                                buildFromTypedExpr(moduleField.expr);
                                        };
                                        
                                        var funcAst = switch(funcField.expr.expr) {
                                            case TConst(TString(s)):
                                                // Convert string function name to atom
                                                makeAST(EAtom(s));
                                            case _:
                                                buildFromTypedExpr(funcField.expr);
                                        };
                                        
                                        var argsAst = buildFromTypedExpr(argsField.expr);
                                        
                                        // Create tuple {Module, :func, args}
                                        makeAST(ETuple([moduleAst, funcAst, argsAst]));
                                    } else {
                                        // Not the expected format, compile normally
                                        buildFromTypedExpr(field.expr);
                                    }
                                    
                                case _:
                                    // Not an object, compile normally
                                    buildFromTypedExpr(field.expr);
                            }
                        } else if (field.name == "type" || field.name == "restart" || field.name == "shutdown") {
                            // These fields should be atoms when they're strings
                            switch(field.expr.expr) {
                                case TConst(TString(s)):
                                    makeAST(EAtom(s));
                                case _:
                                    buildFromTypedExpr(field.expr);
                            }
                        } else {
                            // Standard field value compilation
                            buildFromTypedExpr(field.expr);
                        };
                        
                        pairs.push({key: key, value: fieldValue});
                    }
                    EMap(pairs);
                } else {
                    // Regular object - generate as map
                    var pairs = [];
                    for (field in fields) {
                        var key = makeAST(EAtom(field.name));
                        
                        /**
                         * Detect and transform null coalescing pattern in object field values.
                         * 
                         * Haxe compiles `field: value ?? default` into a TBlock containing:
                         * 1. TVar(tmpVar, init) - temporary variable assignment
                         * 2. TBinop(OpNullCoal, TLocal(v), defaultExpr) - null coalescing operation
                         * 
                         * This pattern is transformed into Elixir's inline if-expression:
                         * `if (tmp = value) != nil, do: tmp, else: default`
                         */
                        var fieldValue = switch(field.expr.expr) {
                        case TBlock([{expr: TVar(tmpVar, init)}, {expr: TBinop(OpNullCoal, {expr: TLocal(v)}, defaultExpr)}]) 
                            if (v.id == tmpVar.id && init != null):
                            // Transform null coalescing pattern to idiomatic Elixir
                            var initAst = buildFromTypedExpr(init, variableUsageMap);
                            var defaultAst = buildFromTypedExpr(defaultExpr, variableUsageMap);
                            var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
                            
                            var ifExpr = makeAST(EIf(
                                makeAST(EBinary(NotEqual, 
                                    makeAST(EMatch(PVar(tmpVarName), initAst)),
                                    makeAST(ENil)
                                )),
                                makeAST(EVar(tmpVarName)),
                                defaultAst
                            ));
                            // Mark for inline rendering to maintain compact syntax
                            if (ifExpr.metadata == null) ifExpr.metadata = {};
                            ifExpr.metadata.keepInlineInAssignment = true;
                            ifExpr;
                            
                        case _:
                            // Standard field value compilation
                            buildFromTypedExpr(field.expr);
                    };
                    
                    pairs.push({key: key, value: fieldValue});
                    }
                    EMap(pairs);
                }
                
            // ================================================================
            // Type Operations
            // ================================================================
            case TTypeExpr(m):
                // Check if this is an extern class with @:native annotation
                var moduleName = moduleTypeToString(m);
                
                // Check if this module has @:native metadata indicating it's an Elixir module
                var isNativeModule = switch(m) {
                    case TClassDecl(c):
                        var cl = c.get();
                        // Check if it's an extern class with @:native
                        if (cl.isExtern && cl.meta.has(":native")) {
                            // Get the native name from metadata
                            var nativeMeta = cl.meta.extract(":native");
                            if (nativeMeta.length > 0 && nativeMeta[0].params != null && nativeMeta[0].params.length > 0) {
                                switch(nativeMeta[0].params[0].expr) {
                                    case EConst(CString(s, _)):
                                        moduleName = s;
                                        true;
                                    default:
                                        false;
                                }
                            } else {
                                false;
                            }
                        } else {
                            false;
                        }
                    default:
                        false;
                };
                
                // Module references should always be EVar (no colon prefix)
                // This applies to both native Elixir modules and compiled Haxe classes
                EVar(moduleName);  // Module references are just capitalized identifiers
                
            case TCast(e, m):
                // Casts are mostly compile-time in Haxe
                buildFromTypedExpr(e).def;
                
            case TParenthesis(e):
                EParen(buildFromTypedExpr(e));
                
            case TMeta(m, e):
                // Metadata wrapping - preserve the expression
                // Special handling for :mergeBlock which wraps null coalescing patterns
                if (m.name == ":mergeBlock") {
                    // Check if this is a null coalescing pattern
                    switch(e.expr) {
                        case TBlock([{expr: TVar(tmpVar, init)}, secondExpr]) if (init != null):
                            // Check if the second expression uses the temp variable
                            switch(secondExpr.expr) {
                                case TIf(condition, thenBranch, elseBranch):
                                    // Check if this is testing the temp variable for null
                                    var isNullCheck = switch(condition.expr) {
                                        case TParenthesis({expr: TBinop(OpNotEq, {expr: TLocal(v)}, {expr: TConst(TNull)})}):
                                            v.id == tmpVar.id;
                                        default: false;
                                    };
                                    
                                    if (isNullCheck) {
                                        // This is null coalescing! Generate inline if expression
                                        var tmpVarName = toElixirVarName(tmpVar.name.charAt(0) == "_" ? tmpVar.name.substr(1) : tmpVar.name);
                                        var initAst = buildFromTypedExpr(init, variableUsageMap);
                                        var elseAst = buildFromTypedExpr(elseBranch);
                                        
                                        // Generate: if (tmp = init) != nil, do: tmp, else: default
                                        var ifExpr = makeAST(EIf(
                                            makeAST(EBinary(NotEqual, 
                                                makeAST(EParen(makeAST(EMatch(PVar(tmpVarName), initAst)))),
                                                makeAST(ENil)
                                            )),
                                            makeAST(EVar(tmpVarName)),
                                            elseAst
                                        ));
                                        // Mark as inline for null coalescing
                                        if (ifExpr.metadata == null) ifExpr.metadata = {};
                                        ifExpr.metadata.keepInlineInAssignment = true;
                                        return ifExpr.def;
                                    }
                                default:
                            }
                        default:
                    }
                }
                buildFromTypedExpr(e).def;
                
            // ================================================================
            // Special Cases
            // ================================================================
            case TNew(c, _, el):
                // Constructor call - should call ModuleName.new() for classes with instance methods
                var classType = c.get();
                var className = classType.name;
                var args = [for (e in el) buildFromTypedExpr(e)];
                
                // Check if this is a Map type (StringMap, IntMap, etc.)
                // Maps should generate regular Elixir maps %{}, not structs
                if (className == "StringMap" || className == "Map" || className.endsWith("Map")) {
                    // Generate empty map for Map constructors
                    EMap([]);
                } else {
                    // Check if this class has instance methods (not just a data class)
                    var hasInstanceMethods = false;
                    for (field in classType.fields.get()) {
                        // Instance methods are FMethod that are not in the statics list
                        if (field.kind.match(FMethod(_))) {
                            // Check if this field is NOT in the statics array
                            var isStatic = false;
                            for (staticField in classType.statics.get()) {
                                if (staticField.name == field.name) {
                                    isStatic = true;
                                    break;
                                }
                            }
                            if (!isStatic) {
                                hasInstanceMethods = true;
                                break;
                            }
                        }
                    }
                    
                    // Also check if it has a constructor
                    var hasConstructor = classType.constructor != null;
                    
                    if (hasInstanceMethods || hasConstructor) {
                        // Call the module's new function: ModuleName.new(args)
                        // In Elixir, this is a module function call
                        var moduleRef = makeAST(EVar(className));
                        ECall(moduleRef, "new", args);
                    } else {
                        // Simple data class - create as struct
                        EStruct(className, []);
                    }
                }
                
            case TFor(v, e1, e2):
                #if debug_for_loop
                trace('[XRay ForLoop] Processing TFor');
                trace('[XRay ForLoop] Variable: ${v.name} (id=${v.id})');
                trace('[XRay ForLoop] Iteration expr type: ${Type.enumConstructor(e1.expr)}');
                trace('[XRay ForLoop] Body expr type: ${Type.enumConstructor(e2.expr)}');
                // Analyze body structure
                switch(e2.expr) {
                    case TBlock(exprs):
                        trace('[XRay ForLoop] Body is TBlock with ${exprs.length} expressions');
                        for (i in 0...exprs.length) {
                            trace('[XRay ForLoop]   [${i}] ${Type.enumConstructor(exprs[i].expr)}');
                        }
                    case _:
                        trace('[XRay ForLoop] Body is single expression');
                }
                #end
                
                // Convert the loop variable name to Elixir conventions
                var elixirVarName = toElixirVarName(v.name);
                
                // Track the variable renaming so TLocal references use the correct name
                // This is critical for underscore variables like "_" which become "item"
                var idKey = Std.string(v.id);
                var oldMapping = tempVarRenameMap.get(idKey);
                if (v.name != elixirVarName) {
                    tempVarRenameMap.set(idKey, elixirVarName);
                    #if debug_for_loop
                    trace('[XRay ForLoop] Registering variable rename: ${v.name} (id=$idKey) -> $elixirVarName');
                    #end
                }
                
                // Build the pattern with the converted name
                var pattern = PVar(elixirVarName);
                var expr = buildFromTypedExpr(e1);
                
                // Build the body with the variable mapping active
                var body = buildFromTypedExpr(e2);
                
                // Restore old mapping if it existed
                if (oldMapping != null) {
                    tempVarRenameMap.set(idKey, oldMapping);
                } else {
                    tempVarRenameMap.remove(idKey);
                }
                
                EFor([{pattern: pattern, expr: expr}], [], body, null, false);
                
            case TWhile(econd, e, normalWhile):
                // CRITICAL: Detect array iteration patterns and generate idiomatic Enum calls
                // This prevents Y-combinator pattern generation for array operations
                
                // Haxe desugars array.map(fn) into:
                // var _g = []; var _g1 = 0; var _g2 = array; 
                // while(_g1 < _g2.length) { var v = _g2[_g1]; _g1++; _g.push(transformation); }
                
                #if debug_array_patterns
                trace('[XRay ArrayPattern] TWhile detected');
                trace('[XRay ArrayPattern] Condition: ${econd.expr}');
                #end
                
                // Check if this is an array iteration pattern
                var isArrayLoop = false;
                var arrayRef: TypedExpr = null;
                
                // Look for _g1 < _g2.length pattern
                switch(econd.expr) {
                    case TBinop(OpLt, {expr: TLocal(indexVar)}, {expr: TField(arr, FInstance(_, _, cf))}) 
                        if (indexVar.name.startsWith("_g") && cf.get().name == "length"):
                        
                        #if debug_array_patterns
                        trace('[XRay ArrayPattern] FOUND array iteration pattern!');
                        trace('[XRay ArrayPattern] Index var: ${indexVar.name}');
                        trace('[XRay ArrayPattern] Array ref: ${arr.expr}');
                        #end
                        
                        // Found the pattern, arr is either the array or a variable holding it
                        isArrayLoop = true;
                        arrayRef = arr;
                        
                    case _:
                        #if debug_array_patterns
                        trace('[XRay ArrayPattern] Not an array pattern, condition is: ${econd.expr}');
                        #end
                }
                
                if (isArrayLoop && arrayRef != null) {
                    // Analyze the loop body to determine what kind of operation this is
                    var pattern = ElixirASTPatterns.detectArrayOperationPattern(e);
                    
                    if (pattern != null) {
                        return generateIdiomaticEnumCall(arrayRef, pattern, e);
                    }
                }
                
                // Not an array pattern or couldn't optimize
                // Generate a named recursive function instead of Y-combinator pattern
                // 
                // IDIOMATIC ELIXIR LOOP PATTERNS:
                // 
                // 1. For collection iteration → Enum.each/map/filter
                //    Haxe: for (item in array) { process(item); }
                //    Elixir: Enum.each(array, &process/1)
                //
                // 2. For numeric ranges → Enum.each with range
                //    Haxe: for (i in 0...10) { trace(i); }
                //    Elixir: Enum.each(0..9, &IO.inspect/1)
                //
                // 3. While loops → Stream.unfold or recursive function
                //    Haxe: while (condition) { body; }
                //    Elixir: Stream.unfold(initial_state, fn state ->
                //              if condition(state) do
                //                {nil, new_state}
                //              else
                //                nil
                //              end
                //            end) |> Stream.run()
                //
                // 4. Complex iterations → for comprehension
                //    Haxe: nested loops with conditions
                //    Elixir: for i <- 0..9, j <- 0..9, i != j, do: {i, j}
                //
                // CURRENT LIMITATION: We're in the builder phase and don't have
                // enough context to determine the best idiomatic pattern.
                // The transformer pass should detect these patterns and convert them.
                //
                // Generate idiomatic Elixir patterns directly
                var condition = buildFromTypedExpr(econd);
                var body = buildFromTypedExpr(e);
                
                // For now, generate a simple recursive anonymous function
                // This avoids Y-combinator pattern but needs improvement
                // to use Enum.reduce_while or Stream.unfold for true idiomaticity
                //
                // Generated pattern:
                //   loop = fn loop ->
                //     if condition do
                //       body
                //       loop.(loop)
                //     else
                //       :ok
                //     end
                //   end
                //   loop.(loop)
                
                // Generate unique loop name
                var loopName = "loop_" + (whileLoopCounter++);
                
                // Generate a Stream.unfold pattern for idiomatic Elixir
                // This avoids Y-combinator and generates clean, functional code
                // Stream.unfold(true, fn
                //   false -> nil
                //   true -> if condition do {nil, true} else {nil, false} end
                // end) |> Stream.run()
                
                // STATE THREADING IMPLEMENTATION
                // Detect variables that are mutated in the loop body
                var mutatedVars = reflaxe.elixir.helpers.MutabilityDetector.detectMutatedVariables(e);
                
                // ALSO check which variables are used in the condition!
                // If the condition uses variables that are mutated in the body,
                // we need to include them in state threading
                var conditionVars = new Map<Int, TVar>();
                function findConditionVars(expr: TypedExpr): Void {
                    if (expr == null) return;
                    switch(expr.expr) {
                        case TLocal(v):
                            conditionVars.set(v.id, v);
                        default:
                            haxe.macro.TypedExprTools.iter(expr, findConditionVars);
                    }
                }
                findConditionVars(econd);
                
                // Add ALL condition variables to the state threading
                // Even if they're not mutated, they need to be accessible in the reduce_while callback
                for (v in conditionVars) {
                    if (!mutatedVars.exists(v.id)) {
                        #if debug_state_threading
                        trace('[State Threading] Adding condition variable to state threading: ${v.name} (id: ${v.id})');
                        #end
                        mutatedVars.set(v.id, v);
                    }
                }
                
                #if debug_state_threading
                trace('[State Threading] While loop detected, state-threaded vars: ${[for (v in mutatedVars) v.name]}');
                #end
                
                // If there are variables to thread (mutated or used in condition), use reduce_while
                if (Lambda.count(mutatedVars) > 0) {
                    // Build the initial accumulator tuple with all mutable variables
                    var initialAccValues: Array<ElixirAST> = [];
                    var accPattern: Array<EPattern> = [];
                    var accVarNames: Array<String> = [];
                    
                    for (v in mutatedVars) {
                        var varName = toElixirVarName(v.name);
                        initialAccValues.push(makeAST(EVar(varName)));
                        // Use acc_ prefix to avoid shadowing outer variables
                        accPattern.push(PVar("acc_" + varName));
                        accVarNames.push(varName);
                    }
                    
                    // Add the original accumulator at the end
                    initialAccValues.push(makeAST(EAtom("ok")));
                    accPattern.push(PVar("acc_state"));
                    
                    var initialAccumulator = makeAST(ETuple(initialAccValues));
                    var accPatternTuple = PTuple(accPattern);
                    
                    // Build the updated accumulator for {:cont, ...}
                    var contAccValues: Array<ElixirAST> = [];
                    for (varName in accVarNames) {
                        contAccValues.push(makeAST(EVar(varName)));
                    }
                    contAccValues.push(makeAST(EVar("acc_state")));
                    var contAccumulator = makeAST(ETuple(contAccValues));
                    
                    // Build the variable mapping for transformations
                    var varMapping = new Map<String, String>();
                    for (varName in accVarNames) {
                        varMapping.set(varName, "acc_" + varName);
                    }
                    
                    #if debug_state_threading
                    trace('[State Threading] Condition before transformation: ${ElixirASTPrinter.printAST(condition)}');
                    if (condition != null) {
                        trace('[State Threading] Condition AST def type: ${Type.typeof(condition.def)}');
                    }
                    trace('[State Threading] VarMapping: ${[for (k in varMapping.keys()) '$k => ${varMapping.get(k)}']}');
                    #end
                    
                    // Transform condition and body to use acc_ variables BEFORE building the function
                    var transformedCondition = transformVariableReferences(condition, varMapping);
                    var transformedBody = transformVariableReferences(body, varMapping);
                    
                    // Check if the body contains early returns that need special handling
                    var bodyHasReturn = checkForEarlyReturns(transformedBody);
                    
                    #if debug_state_threading
                    if (transformedCondition != null) {
                        trace('[State Threading] Condition BEFORE transformation: ${ElixirASTPrinter.printAST(condition)}');
                        trace('[State Threading] Condition AFTER transformation: ${ElixirASTPrinter.printAST(transformedCondition)}');
                    } else {
                        trace('[State Threading] ERROR: transformedCondition is null!');
                    }
                    trace('[State Threading] Body has early return: $bodyHasReturn');
                    #end
                    
                    // Generate the reduce_while with state threading
                    var reduceResult = ERemoteCall(
                        makeAST(EVar("Enum")),
                        "reduce_while",
                        [
                            // Use Stream.iterate for infinite sequence
                            makeAST(ERemoteCall(
                                makeAST(EVar("Stream")),
                                "iterate",
                                [
                                    makeAST(EInteger(0)),
                                    makeAST(EFn([{
                                        args: [PVar("n")],
                                        guard: null,
                                        body: makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1))))
                                    }]))
                                ]
                            )),
                            initialAccumulator,
                            makeAST(EFn([
                                {
                                    args: [PWildcard, accPatternTuple],
                                    guard: null,
                                    body: {
                                        // Build updated accumulator for continuation
                                        // Use the acc_ prefixed variables which may have been updated in the body
                                        var updatedContAccValues: Array<ElixirAST> = [];
                                        for (varName in accVarNames) {
                                            updatedContAccValues.push(makeAST(EVar("acc_" + varName)));
                                        }
                                        updatedContAccValues.push(makeAST(EVar("acc_state")));
                                        var updatedContAccumulator = makeAST(ETuple(updatedContAccValues));
                                        
                                        // Build the body using the pre-transformed condition and body
                                        // If the body contains early returns, they need to be transformed to {:halt, value}
                                        var wrappedBody = if (bodyHasReturn) {
                                            // Transform returns in the body to halt tuples
                                            transformReturnsToHalts(transformedBody, updatedContAccumulator);
                                        } else {
                                            // Normal body without early returns
                                            makeAST(EBlock([
                                                transformedBody,
                                                makeAST(ETuple([makeAST(EAtom("cont")), updatedContAccumulator]))
                                            ]));
                                        };
                                        
                                        makeAST(EIf(
                                            transformedCondition,
                                            wrappedBody,
                                            makeAST(ETuple([makeAST(EAtom("halt")), updatedContAccumulator]))
                                        ));
                                    }
                                }
                            ]))
                        ]
                    );
                    
                    // The reduce_while returns the final accumulator
                    // For now, we don't destructure it since most while loops with mutated
                    // variables are just using them as loop counters that aren't needed after
                    // TODO: Analyze if variables are used after the loop and only destructure then
                    reduceResult;
                } else {
                    // No mutated variables, use simpler form
                    ERemoteCall(
                        makeAST(EVar("Enum")),  
                        "reduce_while",
                        [
                            // Use Stream.iterate for infinite sequence
                            makeAST(ERemoteCall(
                                makeAST(EVar("Stream")),
                                "iterate",
                                [
                                    makeAST(EInteger(0)),
                                    makeAST(EFn([{
                                        args: [PVar("n")],
                                        guard: null,
                                        body: makeAST(EBinary(Add, makeAST(EVar("n")), makeAST(EInteger(1))))
                                    }]))
                                ]
                            )),
                            makeAST(EAtom("ok")),
                            makeAST(EFn([
                                {
                                    args: [PWildcard, PVar("acc")],
                                    guard: null,
                                    body: makeAST(EIf(
                                        condition,  // Use original condition - no mutations to transform
                                        makeAST(EBlock([
                                            body,    // Use original body - no mutations to transform
                                            makeAST(ETuple([makeAST(EAtom("cont")), makeAST(EVar("acc"))]))
                                        ])),
                                        makeAST(ETuple([makeAST(EAtom("halt")), makeAST(EVar("acc"))]))
                                    ))
                                }
                            ]))
                        ]
                    );
                }
                
            case TThrow(e):
                EThrow(buildFromTypedExpr(e));
                
            case TEnumParameter(e, ef, index):
                // Enum field access
                var exprAST = buildFromTypedExpr(e);
                var field = ef.name;
                
                // Will be transformed to proper pattern extraction
                ECall(exprAST, "elem", [makeAST(EInteger(index + 1))]); // +1 for tag
                
            case TEnumIndex(e):
                // Get enum tag index
                var exprAST = buildFromTypedExpr(e);
                ECall(exprAST, "elem", [makeAST(EInteger(0))]);
                
            case TIdent(s):
                // Identifier reference
                EVar(toElixirVarName(s));
        }
    }
    
    /**
     * Try to detect and optimize array iteration patterns
     * 
     * WHY: Haxe desugars array.map/filter into while loops with index counters
     * WHAT: Detects these patterns and generates idiomatic Enum calls instead
     * HOW: Analyzes condition and body to identify map/filter/reduce patterns
     * 
     * @param econd The while loop condition
     * @param ebody The while loop body
     * @return Optimized ElixirAST using Enum functions, or null if no pattern detected
     */
    static function tryOptimizeArrayPattern(econd: TypedExpr, ebody: TypedExpr): Null<ElixirAST> {
        // Debug: Print the condition to understand its structure
        #if debug_array_patterns
        trace("[Array Pattern] Checking condition: " + haxe.macro.ExprTools.toString(Context.getTypedExpr(econd)));
        #end
        
        // Simple pattern check for _g1 < _g2.length
        // When Haxe desugars array.map, it creates: _g1 = 0; _g2 = array; while(_g1 < _g2.length)
        var isArrayPattern = false;
        var arrayVarName = "";
        var indexVarName = "";
        
        switch(econd.expr) {
            case TBinop(OpLt, e1, e2):
                switch(e1.expr) {
                    case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
                        switch(e2.expr) {
                            case TField(arrayRef, FInstance(_, _, cf)) if (cf.get().name == "length"):
                                // We have _gX < something.length
                                switch(arrayRef.expr) {
                                    case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
                                        // Pattern: _g1 < _g2.length
                                        isArrayPattern = true;
                                        indexVarName = indexVar.name;
                                        arrayVarName = arrayVar.name;
                                        #if debug_array_patterns
                                        trace("[Array Pattern] DETECTED: " + indexVarName + " < " + arrayVarName + ".length");
                                        #end
                                    case _:
                                        // Direct array: _g < array.length
                                        isArrayPattern = true;
                                        indexVarName = indexVar.name;
                                }
                            case _:
                        }
                    case _:
                }
            case _:
        }
        
        if (!isArrayPattern) {
            #if debug_array_patterns
            trace("[Array Pattern] No array pattern detected");
            #end
            return null;
        }
        
        // Analyze the loop body to determine the pattern type
        var bodyAnalysis = analyzeLoopBody(ebody);
        
        // For _g2 pattern, we need to generate a reference to the actual array variable
        // The actual array should be available as a local variable named _g2
        var arrayExpr = makeAST(EVar(toElixirVarName(arrayVarName.length > 0 ? arrayVarName : "_g2")));
        
        // Generate appropriate Enum call based on pattern
        if (bodyAnalysis.hasMapPattern) {
            return generateEnumMapSimple(arrayExpr, bodyAnalysis, ebody);
        } else if (bodyAnalysis.hasFilterPattern) {
            return generateEnumFilterSimple(arrayExpr, bodyAnalysis, ebody);
        } else if (bodyAnalysis.hasReducePattern) {
            // Reduce patterns are more complex, skip for now
            return null;
        }
        
        // No clear pattern detected, return null to use regular while loop
        return null;
    }
    
    /**
     * Detect array iteration pattern in condition
     */
    static function detectArrayIterationPattern(econd: TypedExpr): Null<{arrayExpr: TypedExpr, indexVar: String}> {
        return switch(econd.expr) {
            case TBinop(OpLt, e1, e2):
                // Debug what we're comparing
                #if debug_array_patterns
                trace("[Array Pattern] e1: " + Type.enumConstructor(e1.expr));
                trace("[Array Pattern] e2: " + Type.enumConstructor(e2.expr));
                #end
                
                // Check for _g1 < _g2.length pattern
                switch(e2.expr) {
                    case TField(arrayExpr, FInstance(_, _, cf)):
                        // Check if accessing .length field
                        if (cf.get().name == "length") {
                            // Check what arrayExpr is
                            #if debug_array_patterns
                            trace("[Array Pattern] Found .length access on: " + Type.enumConstructor(arrayExpr.expr));
                            #end
                            
                            // Handle _g2 being a local variable holding the array
                            switch(arrayExpr.expr) {
                                case TLocal(arrayVar) if (arrayVar.name.startsWith("_g")):
                                    // _g2 is a variable holding the array reference
                                    switch(e1.expr) {
                                        case TLocal(indexVar) if (indexVar.name.startsWith("_g")):
                                            #if debug_array_patterns
                                            trace("[Array Pattern] MATCHED: " + indexVar.name + " < " + arrayVar.name + ".length");
                                            #end
                                            // We have the pattern, but _g2 is a variable, not the actual array
                                            // For now, return this and we'll handle it differently
                                            return {arrayExpr: arrayExpr, indexVar: indexVar.name};
                                        case _:
                                            null;
                                    }
                                case _:
                                    // Direct array.length access
                                    switch(e1.expr) {
                                        case TLocal(v) if (v.name.startsWith("_g")):
                                            #if debug_array_patterns
                                            trace("[Array Pattern] Detected direct: " + v.name + " < array.length");
                                            #end
                                            return {arrayExpr: arrayExpr, indexVar: v.name};
                                        case _:
                                            null;
                                    }
                            }
                        }
                        null;
                    case _:
                        null;
                }
                null;
            case _:
                null;
        };
        return null;
    }
    
    /**
     * Analyze loop body to identify pattern type
     */
    static function analyzeLoopBody(ebody: TypedExpr): {
        hasMapPattern: Bool,
        hasFilterPattern: Bool,
        hasReducePattern: Bool,
        loopVar: Null<TVar>,
        pushTarget: Null<String>
    } {
        var result = {
            hasMapPattern: false,
            hasFilterPattern: false,
            hasReducePattern: false,
            loopVar: null,
            pushTarget: null
        };
        
        // Look for common patterns in the body
        function analyze(expr: TypedExpr): Void {
            switch(expr.expr) {
                case TBlock(exprs):
                    for (e in exprs) analyze(e);
                    
                case TVar(v, init):
                    // Look for: var v = array[index]
                    if (init != null) {
                        switch(init.expr) {
                            case TArray(_, _):
                                result.loopVar = v;
                            case _:
                        }
                    }
                    
                case TCall(e, args):
                    // Look for: result.push(transformation)
                    switch(e.expr) {
                        case TField(target, FInstance(_, _, cf)):
                            if (cf.get().name == "push") {
                                result.hasMapPattern = true;
                                // Extract push target variable name
                                switch(target.expr) {
                                    case TLocal(v):
                                        result.pushTarget = v.name;
                                    case _:
                                }
                            }
                        case _:
                    }
                    
                case TIf(cond, thenExpr, elseExpr):
                    // Check for filter pattern (conditional push)
                    analyze(thenExpr);
                    if (elseExpr != null) analyze(elseExpr);
                    
                    // If there's a push in the then branch, it's a filter
                    if (result.hasMapPattern) {
                        result.hasFilterPattern = true;
                        result.hasMapPattern = false; // Filter takes precedence
                    }
                    
                case TBinop(OpAssignOp(OpAdd), _, _):
                    // Accumulation pattern (reduce)
                    result.hasReducePattern = true;
                    
                case _:
                    // Recursively analyze other expressions using Haxe's built-in iterator
                    haxe.macro.TypedExprTools.iter(expr, analyze);
            }
        }
        
        analyze(ebody);
        return result;
    }
    
    /**
     * Generate Enum.map call (simplified version)
     */
    static function generateEnumMapSimple(arrayExpr: ElixirAST, analysis: Dynamic, ebody: TypedExpr): ElixirAST {
        // Find the loop variable and transformation
        var loopVar = analysis.loopVar != null ? toElixirVarName(analysis.loopVar.name) : "item";
        
        // Extract the transformation expression from the push call
        var transformation = extractMapTransformation(ebody, analysis.loopVar);
        
        // Create lambda: fn item -> transformation end
        var lambda = makeAST(EFn([{
            args: [PVar(loopVar)],
            guard: null,
            body: transformation
        }]));
        
        // Return Enum.map(array, lambda)
        return makeAST(ECall(null, "Enum.map", [arrayExpr, lambda]));
    }
    
    /**
     * Generate Enum.filter call (simplified version)
     */
    static function generateEnumFilterSimple(arrayExpr: ElixirAST, analysis: Dynamic, ebody: TypedExpr): ElixirAST {
        var loopVar = analysis.loopVar != null ? toElixirVarName(analysis.loopVar.name) : "item";
        
        // Extract the filter condition
        var condition = extractFilterCondition(ebody);
        
        // Create lambda: fn item -> condition end
        var lambda = makeAST(EFn([{
            args: [PVar(loopVar)],
            guard: null,
            body: condition
        }]));
        
        // Return Enum.filter(array, lambda)
        return makeAST(ECall(null, "Enum.filter", [arrayExpr, lambda]));
    }
    
    /**
     * Generate Enum.map call (original TypedExpr version - kept for compatibility)
     */
    static function generateEnumMap(arrayExpr: TypedExpr, analysis: Dynamic, ebody: TypedExpr): ElixirAST {
        // Extract the transformation from the loop body
        var arrayAST = buildFromTypedExpr(arrayExpr);
        
        // Find the loop variable and transformation
        var loopVar = analysis.loopVar != null ? toElixirVarName(analysis.loopVar.name) : "item";
        
        // Extract the transformation expression from the push call
        var transformation = extractMapTransformation(ebody, analysis.loopVar);
        
        // Create lambda: fn item -> transformation end
        var lambda = makeAST(EFn([{
            args: [PVar(loopVar)],
            guard: null,
            body: transformation
        }]));
        
        // Return Enum.map(array, lambda)
        return makeAST(ECall(null, "Enum.map", [arrayAST, lambda]));
    }
    
    /**
     * Generate Enum.filter call
     */
    static function generateEnumFilter(arrayExpr: TypedExpr, analysis: Dynamic, ebody: TypedExpr): ElixirAST {
        var arrayAST = buildFromTypedExpr(arrayExpr);
        var loopVar = analysis.loopVar != null ? toElixirVarName(analysis.loopVar.name) : "item";
        
        // Extract the filter condition
        var condition = extractFilterCondition(ebody);
        
        // Create lambda: fn item -> condition end
        var lambda = makeAST(EFn([{
            args: [PVar(loopVar)],
            guard: null,
            body: condition
        }]));
        
        // Return Enum.filter(array, lambda)
        return makeAST(ECall(null, "Enum.filter", [arrayAST, lambda]));
    }
    
    /**
     * Generate Enum.reduce call
     */
    static function generateEnumReduce(arrayExpr: TypedExpr, analysis: Dynamic, ebody: TypedExpr): ElixirAST {
        // For now, return null to use regular while loop
        // Reduce patterns are more complex and need more analysis
        return null;
    }
    
    /**
     * Extract the transformation expression from a map pattern
     */
    static function extractMapTransformation(ebody: TypedExpr, loopVar: Null<TVar>): ElixirAST {
        // Look for the push call and extract its argument
        function findPushArg(expr: TypedExpr): Null<TypedExpr> {
            return switch(expr.expr) {
                case TBlock(exprs):
                    for (e in exprs) {
                        var result = findPushArg(e);
                        if (result != null) return result;
                    }
                    null;
                    
                case TCall(e, [arg]):
                    switch(e.expr) {
                        case TField(_, FInstance(_, _, cf)):
                            if (cf.get().name == "push") {
                                return arg;
                            }
                            null;
                        case _:
                            null;
                    }
                    null;
                    
                case _:
                    null;
            }
        }
        
        var pushArg = findPushArg(ebody);
        if (pushArg != null) {
            // Build the transformation with variable substitution
            return buildFromTypedExprWithSubstitution(pushArg, loopVar);
        }
        
        // Fallback: just return the item
        return makeAST(EVar("item"));
    }
    
    /**
     * Extract filter condition from loop body
     */
    static function extractFilterCondition(ebody: TypedExpr): ElixirAST {
        // Look for the if condition that guards the push
        function findIfCondition(expr: TypedExpr): Null<TypedExpr> {
            return switch(expr.expr) {
                case TBlock(exprs):
                    for (e in exprs) {
                        var result = findIfCondition(e);
                        if (result != null) return result;
                    }
                    null;
                    
                case TIf(cond, thenExpr, _):
                    // Check if the then branch contains a push
                    if (containsPush(thenExpr)) {
                        return cond;
                    }
                    null;
                    
                case _:
                    null;
            }
        }
        
        var cond = findIfCondition(ebody);
        if (cond != null) {
            return buildFromTypedExpr(cond);
        }
        
        // Fallback: always true
        return makeAST(EBoolean(true));
    }
    
    /**
     * Check if an expression contains a push call
     */
    static function containsPush(expr: TypedExpr): Bool {
        var hasPush = false;
        
        function check(e: TypedExpr): Void {
            switch(e.expr) {
                case TCall(target, _):
                    switch(target.expr) {
                        case TField(_, FInstance(_, _, cf)):
                            if (cf.get().name == "push") {
                                hasPush = true;
                            }
                        case _:
                    }
                case _:
                    if (!hasPush) {
                        haxe.macro.TypedExprTools.iter(e, check);
                    }
            }
        }
        
        check(expr);
        return hasPush;
    }
    
    /**
     * Process enum case body to detect and handle unused extracted variables
     * 
     * WHY: When Haxe compiles patterns like case Ok(value), it generates extraction code
     * even if 'value' is never used, leading to unused variable warnings in Elixir.
     * 
     * WHAT: Detects variables extracted from enum patterns that are never used in the body
     * and prefixes them with underscore to suppress warnings.
     * 
     * HOW: Analyzes the case body for TVar nodes with TEnumParameter initialization,
     * checks if the variable is used, and modifies the variable name if unused.
     */
    static function processEnumCaseBody(caseExpr: TypedExpr, builtBody: ElixirAST): ElixirAST {
        // Check if the case body contains enum parameter extraction
        // Pattern: TBlock([TVar(v, TEnumParameter(...)), ...])
        switch(caseExpr.expr) {
            case TBlock(exprs):
                var modifiedExprs = [];
                var unusedVars = new Map<String, Bool>();
                
                // First pass: identify extracted enum parameters
                for (expr in exprs) {
                    switch(expr.expr) {
                        case TVar(v, init) if (init != null):
                            switch(init.expr) {
                                case TEnumParameter(_, _, _):
                                    // Found an enum parameter extraction
                                    // Check if this variable is used in the rest of the block
                                    var isUsed = false;
                                    for (i in (exprs.indexOf(expr) + 1)...exprs.length) {
                                        if (reflaxe.elixir.helpers.UsageDetector.isVariableUsed(v.id, exprs[i])) {
                                            isUsed = true;
                                            break;
                                        }
                                    }
                                    if (!isUsed) {
                                        unusedVars.set(v.name, true);
                                    }
                                default:
                            }
                        default:
                    }
                }
                
                // If we found unused extracted variables, we need to rebuild the body
                // with prefixed variable names
                if (Lambda.count(unusedVars) > 0) {
                    // The body has already been built, but we need to modify it
                    // to prefix unused variables with underscore
                    return prefixUnusedVariablesInAST(builtBody, unusedVars);
                }
            default:
        }
        
        return builtBody;
    }
    
    /**
     * Prefix unused variables with underscore in an already-built AST
     */
    static function prefixUnusedVariablesInAST(ast: ElixirAST, unusedVars: Map<String, Bool>): ElixirAST {
        // This is a simplified version - in practice we'd need to traverse
        // the AST and modify variable names. For now, return as-is
        // since the actual fix needs to happen during initial building
        return ast;
    }
    
    /**
     * Build AST with variable substitution for lambda parameters
     */
    static function buildFromTypedExprWithSubstitution(expr: TypedExpr, loopVar: Null<TVar>): ElixirAST {
        // For now, just use the regular build function
        // TODO: Implement proper variable substitution
        return buildFromTypedExpr(expr);
    }
    
    /**
     * Create metadata from TypedExpr
     */
    static function createMetadata(expr: TypedExpr): ElixirMetadata {
        return {
            sourceExpr: expr,
            sourceLine: expr.pos != null ? Context.getPosInfos(expr.pos).min : 0,
            sourceFile: expr.pos != null ? Context.getPosInfos(expr.pos).file : null,
            type: expr.t,
            elixirType: typeToElixir(expr.t),
            purity: isPure(expr),
            tailPosition: false, // Will be set by transformer
            async: false, // Will be detected by transformer
            requiresReturn: false, // Will be set by context
            requiresTempVar: false, // Will be set by transformer
            inPipeline: false, // Will be set by transformer
            inComprehension: false, // Will be set by context
            inGuard: false, // Will be set by context
            canInline: canBeInlined(expr),
            isConstant: isConstant(expr),
            sideEffects: hasSideEffects(expr)
        };
    }
    
    /**
     * Convert Haxe values to patterns
     * 
     * WHY: Switch case values need to be converted to Elixir patterns
     * WHAT: Handles literals, enum constructors, variables, and complex patterns
     * HOW: Analyzes the TypedExpr structure and generates appropriate pattern
     */
    static function convertPattern(value: TypedExpr): EPattern {
        return switch(value.expr) {
            // Literals
            case TConst(TInt(i)): 
                PLiteral(makeAST(EInteger(i)));
            case TConst(TFloat(f)): 
                PLiteral(makeAST(EFloat(Std.parseFloat(f))));
            case TConst(TString(s)): 
                PLiteral(makeAST(EString(s)));
            case TConst(TBool(b)): 
                PLiteral(makeAST(EBoolean(b)));
            case TConst(TNull): 
                PLiteral(makeAST(ENil));
                
            // Variables (for pattern matching)
            case TLocal(v):
                PVar(toElixirVarName(v.name));
                
            // Enum constructors
            case TEnumParameter(e, ef, index):
                // This represents matching against enum constructor arguments
                // We'll need to handle this in the context of the full pattern
                PVar("_enum_param_" + index);
                
            case TEnumIndex(e):
                // Matching against enum index (for switch on elem(tuple, 0))
                PLiteral(makeAST(EInteger(0))); // Will be refined based on actual enum
                
            // Array patterns
            case TArrayDecl(el):
                PList([for (e in el) convertPattern(e)]);
                
            // Tuple patterns (for enum matching)
            case TCall(e, el) if (isEnumConstructor(e)):
                // Enum constructor pattern
                var tag = extractEnumTag(e);
                
                // For idiomatic enums, convert to snake_case
                if (hasIdiomaticMetadata(e)) {
                    tag = reflaxe.elixir.ast.NameUtils.toSnakeCase(tag);
                }
                
                var args = [for (arg in el) convertPattern(arg)];
                // Create tuple pattern {:tag, arg1, arg2, ...}
                PTuple([PLiteral(makeAST(EAtom(tag)))].concat(args));
                
            // Field access (for enum constructors)
            case TField(e, FEnum(enumRef, ef)):
                // Direct enum constructor reference
                var atomName = ef.name;
                
                // Check if the enum is idiomatic
                var isIdiomatic = enumRef.get().meta.has(":elixirIdiomatic");
                if (isIdiomatic) {
                    atomName = reflaxe.elixir.ast.NameUtils.toSnakeCase(atomName);
                }
                
                if (ef.params.length == 0) {
                    // No-argument constructor
                    PLiteral(makeAST(EAtom(atomName)));
                } else {
                    // Constructor with arguments - needs to be a tuple pattern
                    // This will be {:Constructor, _, _, ...} with wildcards for args
                    var wildcards = [for (i in 0...ef.params.length) PWildcard];
                    PTuple([PLiteral(makeAST(EAtom(atomName)))].concat(wildcards));
                }
                
            // Default/wildcard
            default: 
                PWildcard;
        }
    }
    
    /**
     * Check if an expression is an enum constructor call
     * 
     * Handles both:
     * - TField access: ChildSpecFormat.ModuleWithConfig
     * - Direct constructors: ModuleWithConfig (when imported/in scope)
     * - TTypeExpr references to enum constructors
     */
    static function isEnumConstructor(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TField(_, FEnum(_, _)): true;  // Actual enum constructor field
            case TTypeExpr(TEnumDecl(_)): true;  // Direct enum type reference
            
            // DO NOT treat static methods that return enums as enum constructors!
            // Email.parse() returns Result but parse is NOT an enum constructor
            case TField(_, FStatic(_, _)): false;
            
            case TConst(TString(s)) if (s.charAt(0) >= 'A' && s.charAt(0) <= 'Z'): 
                // Heuristic: capitalized identifiers might be enum constructors
                // This is a fallback for cases where Haxe doesn't provide clear type info
                true;
            default: 
                // Only check for enum types that aren't function types
                // This avoids treating regular functions that return enums as constructors
                switch(expr.t) {
                    case TEnum(_, _): true;  // Direct enum value
                    case TFun(_, _): false;  // Functions are NOT enum constructors
                    default: false;
                }
        }
    }
    
    /**
     * Check if an enum has @:elixirIdiomatic metadata
     */
    static function hasIdiomaticMetadata(expr: TypedExpr): Bool {
        // First try the direct field access case
        switch(expr.expr) {
            case TField(_, FEnum(enumRef, _)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for ${enumType.name}: $hasIt');
                #end
                return hasIt;
            case TTypeExpr(TEnumDecl(enumRef)):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic for enum type expr: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        // Check the return type if this is a function that returns an enum
        switch(expr.t) {
            case TFun(_, ret):
                switch(ret) {
                    case TEnum(enumRef, _):
                        var enumType = enumRef.get();
                        var hasIt = enumType.meta.has(":elixirIdiomatic");
                        #if debug_ast_builder
                        trace('[AST Builder] Checking @:elixirIdiomatic via return type: $hasIt');
                        #end
                        return hasIt;
                    default:
                }
            case TEnum(enumRef, _):
                var enumType = enumRef.get();
                var hasIt = enumType.meta.has(":elixirIdiomatic");
                #if debug_ast_builder
                trace('[AST Builder] Checking @:elixirIdiomatic via direct enum type: $hasIt');
                #end
                return hasIt;
            default:
        }
        
        return false;
    }
    
    // REMOVED buildEnumConstructor - Builder should NOT transform, only build!
    
    /**
     * Get the enum type name for pattern detection
     */
    static function getEnumTypeName(expr: TypedExpr): String {
        return switch(expr.expr) {
            case TField(_, FEnum(enumRef, _)):
                var enumType = enumRef.get();
                enumType.name;
            default: "";
        }
    }
    
    /**
     * Convert Haxe identifier to Elixir atom name
     * 
     * GENERAL RULE: When Haxe identifiers become Elixir atoms,
     * they should follow Elixir naming conventions (snake_case).
     * This ensures generated code looks idiomatic.
     * 
     * Examples:
     * - OneForOne → one_for_one
     * - RestForOne → rest_for_one
     * - SimpleOneForOne → simple_one_for_one
     */
    static function toElixirAtomName(name: String): String {
        var result = [];
        for (i in 0...name.length) {
            var c = name.charAt(i);
            if (i > 0 && c == c.toUpperCase() && c != c.toLowerCase()) {
                result.push("_");
                result.push(c.toLowerCase());
            } else {
                result.push(c.toLowerCase());
            }
        }
        return result.join("");
    }
    
    /**
     * Check if type is an array type
     */
    static function isArrayType(t: Type): Bool {
        return switch(t) {
            case TInst(c, _):
                var cl = c.get();
                cl.name == "Array";
            case TAbstract(a, _):
                var abs = a.get();
                abs.name == "Array";
            default: false;
        }
    }
    
    /**
     * Try to expand __elixir__() injection from a method body
     * 
     * WHY: When Array methods contain __elixir__(), we want to inline them
     * to generate idiomatic Elixir instead of method calls
     * 
     * @param methodExpr The method body expression
     * @param thisExpr The 'this' object (the array)
     * @param args The arguments passed to the method
     * @return The expanded Elixir AST or null if no __elixir__ found
     */
    static function tryExpandElixirInjection(methodExpr: TypedExpr, thisExpr: TypedExpr, args: Array<TypedExpr>): Null<ElixirAST> {
        #if debug_ast_builder
        trace('[AST Builder] tryExpandElixirInjection examining: ${Type.enumConstructor(methodExpr.expr)}');
        #end
        
        // First check if this is a function, and if so, extract its body
        switch(methodExpr.expr) {
            case TFunction(tfunc):
                // Method is a function, check its body
                if (tfunc.expr != null) {
                    return tryExpandElixirInjection(tfunc.expr, thisExpr, args);
                }
            default:
        }
        
        // Look for return statement with __elixir__()
        switch(methodExpr.expr) {
            case TReturn(retOpt):
                // Check if there's a return value
                if (retOpt != null) {
                    return tryExpandElixirCall(retOpt, thisExpr, args);
                }
                
            case TBlock(exprs):
                // Check the last expression (implicit return)
                if (exprs.length > 0) {
                    var lastExpr = exprs[exprs.length - 1];
                    return tryExpandElixirCall(lastExpr, thisExpr, args);
                }
                
            case TIf(cond, ifExpr, elseExpr):
                // Handle conditional __elixir__() calls (like in slice method)
                // We need to evaluate the condition and choose the right branch
                // For now, we'll try to detect if both branches have __elixir__
                var ifResult = tryExpandElixirCall(ifExpr, thisExpr, args);
                if (ifResult != null) {
                    // Both branches likely have __elixir__, create conditional
                    var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, args) : null;
                    if (elseResult != null) {
                        // Build conditional with expanded branches
                        var condAst = buildFromTypedExpr(cond);
                        return makeAST(EIf(condAst, ifResult, elseResult));
                    }
                    // Only if branch has __elixir__
                    return ifResult;
                }
                
            case TCall(_):
                // Direct call, check if it's __elixir__
                return tryExpandElixirCall(methodExpr, thisExpr, args);
                
            default:
        }
        return null;
    }
    
    /**
     * Try to expand a specific __elixir__() call
     */
    static function tryExpandElixirCall(expr: TypedExpr, thisExpr: TypedExpr, methodArgs: Array<TypedExpr>): Null<ElixirAST> {
        #if debug_elixir_injection
        trace("[XRay] tryExpandElixirCall checking expr type: " + expr.expr);
        #end
        
        switch(expr.expr) {
            // Handle return statements that wrap the actual call
            case TReturn(retExpr) if (retExpr != null):
                #if debug_elixir_injection
                trace("[XRay] Found TReturn wrapper, checking inner: " + retExpr.expr);
                #end
                return tryExpandElixirCall(retExpr, thisExpr, methodArgs);
                
            // Handle untyped __elixir__() calls (wrapped in metadata)
            case TMeta({name: ":untyped"}, untypedExpr):
                #if debug_elixir_injection
                trace("[XRay] Found untyped metadata, checking inner: " + untypedExpr.expr);
                #end
                return tryExpandElixirCall(untypedExpr, thisExpr, methodArgs);
                
            // Handle if-else statements with __elixir__() in branches
            case TIf(cond, ifExpr, elseExpr):
                #if debug_elixir_injection
                trace("[XRay] Found TIf in tryExpandElixirCall");
                #end
                var ifResult = tryExpandElixirCall(ifExpr, thisExpr, methodArgs);
                var elseResult = elseExpr != null ? tryExpandElixirCall(elseExpr, thisExpr, methodArgs) : null;
                if (ifResult != null && elseResult != null) {
                    // Both branches have __elixir__, create conditional
                    var condAst = buildFromTypedExpr(cond);
                    return makeAST(EIf(condAst, ifResult, elseResult));
                } else if (ifResult != null) {
                    return ifResult;
                } else if (elseResult != null) {
                    return elseResult;
                }
                
            case TCall(e, callArgs):
                #if debug_elixir_injection
                trace("[XRay] TCall with target: " + e.expr);
                #end
                switch(e.expr) {
                    case TIdent("__elixir__"):
                        #if debug_elixir_injection
                        trace("[XRay] Found __elixir__() call!");
                        #end
                        // Found __elixir__() call!
                        if (callArgs.length > 0) {
                            // First argument should be the code string
                            switch(callArgs[0].expr) {
                                case TConst(TString(code)):
                                    #if debug_elixir_injection
                                    trace('[XRay] Expanding __elixir__ with code: $code');
                                    #end
                                    // Process the injection with parameter substitution
                                    var processedCode = code;
                                    
                                    // Substitute {0} with 'this' (the array)
                                    var thisAst = buildFromTypedExpr(thisExpr);
                                    var thisStr = ElixirASTPrinter.printAST(thisAst);
                                    processedCode = StringTools.replace(processedCode, "{0}", thisStr);
                                    
                                    // Substitute other parameters
                                    for (i in 1...callArgs.length) {
                                        // Map callArgs[i] to the appropriate method argument
                                        // Usually callArgs[1] refers to the first method parameter
                                        if (i - 1 < methodArgs.length) {
                                            var argAst = buildFromTypedExpr(methodArgs[i - 1]);
                                            var argStr = ElixirASTPrinter.printAST(argAst);
                                            var placeholder = '{$i}';
                                            processedCode = StringTools.replace(processedCode, placeholder, argStr);
                                        }
                                    }
                                    
                                    #if debug_elixir_injection
                                    trace('[XRay] Processed code: $processedCode');
                                    #end
                                    
                                    // Return the expanded raw Elixir code
                                    return makeAST(ERaw(processedCode));
                                    
                                default:
                                    #if debug_elixir_injection
                                    trace("[XRay] First arg is not TString: " + callArgs[0].expr);
                                    #end
                            }
                        }
                    default:
                        #if debug_elixir_injection
                        trace("[XRay] Not __elixir__, it's: " + e.expr);
                        #end
                }
            default:
                #if debug_elixir_injection
                trace("[XRay] Not a call, it's: " + expr.expr);
                #end
        }
        return null;
    }
    
    /**
     * Check if type is a Map type
     */
    static function isMapType(t: Type): Bool {
        return switch(t) {
            case TInst(c, _):
                var cl = c.get();
                cl.name == "StringMap" || cl.name == "IntMap" || cl.name == "ObjectMap" || 
                cl.name == "Map" || cl.name.endsWith("Map");
            case TAbstract(a, params):
                var abs = a.get();
                abs.name == "Map" || abs.name.endsWith("Map");
            default: false;
        }
    }
    
    /**
     * Extract enum constructor tag name
     * 
     * For static method calls that return enums (like TypeSafeChildSpec.pubSub),
     * we use the method name as a proxy for the enum constructor
     */
    static function extractEnumTag(expr: TypedExpr): String {
        return switch(expr.expr) {
            case TField(_, FEnum(_, ef)): 
                // Direct enum constructor reference
                ef.name;
            case TField(_, FStatic(_, cf)):
                // Static method call - use the method name (e.g., "pubSub" -> "PubSub")
                var methodName = cf.get().name;
                // Capitalize first letter for enum-like naming
                methodName.charAt(0).toUpperCase() + methodName.substr(1);
            default: 
                // For unknown cases, generate a placeholder that will be transformed
                "ModuleRef";
        }
    }
    
    /**
     * Extract pattern from left-hand side expression
     */
    static function extractPattern(expr: TypedExpr): EPattern {
        return switch(expr.expr) {
            case TLocal(v): PVar(toElixirVarName(v.name));
            case TField(e, fa): 
                // Map/struct field pattern
                PVar(extractFieldName(fa));
            default: PWildcard;
        }
    }
    
    /**
     * Convert assignment operator to binary operator
     */
    static function convertAssignOp(op: Binop): EBinaryOp {
        return switch(op) {
            case OpAdd: Add;
            case OpSub: Subtract;
            case OpMult: Multiply;
            case OpDiv: Divide;
            case OpMod: Remainder;
            case OpAnd: BitwiseAnd;
            case OpOr: BitwiseOr;
            case OpXor: BitwiseXor;
            case OpShl: ShiftLeft;
            case OpShr: ShiftRight;
            default: Add; // Fallback
        }
    }
    
    /**
     * Apply parameter renaming to an AST node
     * This is used when function parameters are renamed (e.g., "this" -> "this_1")
     * to ensure the body references the correct parameter names
     */
    static function applyParameterRenaming(ast: ElixirAST, renaming: Map<String, String>): ElixirAST {
        return switch(ast.def) {
            case EVar(name):
                if (renaming.exists(name)) {
                    makeASTWithMeta(EVar(renaming.get(name)), ast.metadata, ast.pos);
                } else {
                    ast;
                }
            
            // Recursively apply to all child nodes
            case EBlock(exprs):
                makeASTWithMeta(EBlock(exprs.map(e -> applyParameterRenaming(e, renaming))), ast.metadata, ast.pos);
            
            case ECall(target, func, args):
                makeASTWithMeta(
                    ECall(
                        target != null ? applyParameterRenaming(target, renaming) : null,
                        func,
                        args.map(a -> applyParameterRenaming(a, renaming))
                    ),
                    ast.metadata, ast.pos
                );
            
            case EBinary(op, left, right):
                makeASTWithMeta(
                    EBinary(op, applyParameterRenaming(left, renaming), applyParameterRenaming(right, renaming)),
                    ast.metadata, ast.pos
                );
            
            case EUnary(op, expr):
                makeASTWithMeta(EUnary(op, applyParameterRenaming(expr, renaming)), ast.metadata, ast.pos);
            
            case EIf(cond, then, else_):
                makeASTWithMeta(
                    EIf(
                        applyParameterRenaming(cond, renaming),
                        applyParameterRenaming(then, renaming),
                        else_ != null ? applyParameterRenaming(else_, renaming) : null
                    ),
                    ast.metadata, ast.pos
                );
                
            case ECase(expr, clauses):
                makeASTWithMeta(
                    ECase(
                        applyParameterRenaming(expr, renaming),
                        clauses.map(c -> {
                            pattern: c.pattern,  // Don't rename in patterns
                            guard: c.guard != null ? applyParameterRenaming(c.guard, renaming) : null,
                            body: applyParameterRenaming(c.body, renaming)
                        })
                    ),
                    ast.metadata, ast.pos
                );
            
            // For other node types, return as-is (can be extended as needed)
            default:
                ast;
        }
    }
    
    /**
     * Convert variable name to Elixir convention
     * Preserves special Elixir constants like __MODULE__, __FILE__, __ENV__
     */
    /**
     * Check if a variable name looks like a camelCase parameter
     * These are typically function parameters that should remain as-is
     */
    static function isCamelCaseParameter(name: String): Bool {
        if (name.length < 2) return false;
        
        // Check if it starts with lowercase and has uppercase letters
        var firstChar = name.charAt(0);
        if (firstChar != firstChar.toLowerCase()) return false;
        
        // Check if it contains uppercase letters (indicating camelCase)
        for (i in 1...name.length) {
            var char = name.charAt(i);
            if (char == char.toUpperCase() && char != "_" && char != char.toLowerCase()) {
                return true; // Found uppercase letter, it's camelCase
            }
        }
        
        return false;
    }
    
    static function toElixirVarName(name: String, ?preserveUnderscore: Bool = false): String {
        // Special Elixir constants should be preserved
        var specialConstants = ["__MODULE__", "__FILE__", "__ENV__", "__DIR__", "__CALLER__"];
        if (specialConstants.indexOf(name) >= 0) {
            return name;
        }
        
        // Handle single underscore (common in for loops for ignored values)
        // Convert to a meaningful name since Elixir doesn't allow single underscore as variable
        if (name == "_") {
            return "item"; // Convert single underscore to "item"
        }
        
        // Transform compiler-generated temporary variables like _g, _g1, etc.
        // These are created by Haxe's desugaring and should be cleaned up
        // to remove the underscore prefix ONLY if they're actually used variables
        // If preserveUnderscore is true, keep the underscore (for unused variables)
        if (name.charAt(0) == "_" && name.charAt(1) == "g" && !preserveUnderscore) {
            // Remove the underscore but keep the rest for uniqueness
            // _g -> g, _g1 -> g1, _g_1 -> g_1
            return name.substr(1);
        }
        
        // Handle other underscore-prefixed variables (like _item)
        // Keep them as-is since they indicate unused variables in Elixir
        if (name.charAt(0) == "_" && name.length > 1) {
            // Convert the part after underscore to snake_case
            var baseName = name.substr(1);
            var converted = "";
            for (i in 0...baseName.length) {
                var char = baseName.charAt(i);
                var isUpperLetter = char == char.toUpperCase() && char != char.toLowerCase() && char != "_";
                if (i > 0 && isUpperLetter) {
                    converted += "_" + char.toLowerCase();
                } else {
                    converted += char.toLowerCase();
                }
            }
            return "_" + converted;
        }
        
        // Simple snake_case conversion for regular variables
        var result = "";
        for (i in 0...name.length) {
            var char = name.charAt(i);
            // Check if it's an uppercase letter (not a number or underscore)
            // Numbers should NOT trigger underscore insertion
            var isUpperLetter = char == char.toUpperCase() && char != char.toLowerCase() && char != "_";
            if (i > 0 && isUpperLetter) {
                result += "_" + char.toLowerCase();
            } else {
                result += char.toLowerCase();
            }
        }
        
        // Check if the result is a reserved keyword and escape it
        if (isElixirReservedKeyword(result)) {
            // Append underscore to escape reserved keywords
            result = result + "_param";
            #if debug_ast_pipeline
            trace('[toElixirVarName] Escaped reserved keyword: ${name} -> ${result}');
            #end
        }
        
        return result;
    }
    
    /**
     * Check if a name is an Elixir reserved keyword
     * 
     * WHY: Elixir has reserved keywords that cannot be used as variable/parameter names
     * WHAT: Returns true if the name is a reserved keyword in Elixir
     * HOW: Checks against a complete list of Elixir reserved words
     */
    public static function isElixirReservedKeyword(name: String): Bool {
        // Complete list of Elixir reserved keywords
        var reservedKeywords = [
            "true", "false", "nil",           // Boolean/null atoms
            "and", "or", "not", "in", "when", // Operators
            "fn",                              // Anonymous function definition
            "do", "end",                       // Block delimiters
            "catch", "rescue", "after", "else", // Exception handling
            "__MODULE__", "__FILE__", "__DIR__", "__ENV__", "__CALLER__", // Special forms
            "alias", "case", "cond",           // Control structures
            "def", "defp", "defmodule",        // Module/function definition
            "defmacro", "defmacrop",           // Macro definition
            "defprotocol", "defimpl",          // Protocol definition
            "defstruct", "defexception",       // Struct/exception definition
            "defoverridable", "defdelegate",   // Override/delegation
            "for", "if", "import",              // Control/import
            "quote", "unquote", "unquote_splicing", // Metaprogramming
            "receive", "require",               // Process/module loading
            "super", "throw", "try", "unless",  // Control flow
            "use", "with"                       // Module/context management
        ];
        
        return reservedKeywords.indexOf(name) >= 0;
    }
    
    /**
     * Extract field name from FieldAccess
     */
    public static function extractFieldName(fa: FieldAccess): String {
        return switch(fa) {
            case FInstance(_, _, cf) | FStatic(_, cf) | FAnon(cf) | FClosure(_, cf):
                cf.get().name;
            case FDynamic(s):
                s;
            case FEnum(_, ef):
                ef.name;
        }
    }
    
    /**
     * Convert camelCase to snake_case
     */
    static function toSnakeCase(s: String): String {
        // Handle empty string
        if (s.length == 0) return s;
        
        var result = new StringBuf();
        for (i in 0...s.length) {
            var char = s.charAt(i);
            if (i > 0 && char == char.toUpperCase() && char != char.toLowerCase()) {
                // Insert underscore before uppercase letter (except at start)
                result.add("_");
                result.add(char.toLowerCase());
            } else {
                result.add(char.toLowerCase());
            }
        }
        return result.toString();
    }
    
    /**
     * Check if expression is the HXX module (for Phoenix HEEx template processing)
     * 
     * WHY: HXX.hxx() is a compile-time macro that processes JSX-like template strings
     *      and converts them to Phoenix HEEx format. After macro expansion, we get a 
     *      processed string that needs to be wrapped in a ~H sigil for LiveView.
     * 
     * WHAT: Detects when a TTypeExpr refers to the HXX module class, which indicates
     *       we're about to handle an HXX.hxx() template call that needs special treatment.
     * 
     * HOW: Checks if the module type expression resolves to "HXX" by name.
     * 
     * Example: HXX.hxx("<div>Hello <%= @name %></div>") → ~H"""<div>Hello <%= @name %></div>"""
     */
    static function isHXXModule(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(m):
                // Check if this is the HXX module
                moduleTypeToString(m) == "HXX";
            default: false;
        }
    }
    
    /**
     * Check if expression is the Assert class (for ExUnit assertions)
     */
    static function isAssertClass(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(TClassDecl(classRef)):
                // Check if this is haxe.test.Assert
                var classType = classRef.get();
                var pack = classType.pack.join(".");
                var name = classType.name;
                pack == "haxe.test" && name == "Assert";
            default: false;
        }
    }
    
    /**
     * Check if expression is a module call
     */
    static function isModuleCall(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TTypeExpr(_): true;
            default: false;
        }
    }
    
    /**
     * Check if type represents a map/struct
     */
    static function isMapAccess(t: Type): Bool {
        return switch(t) {
            case TAnonymous(_): true;
            case TInst(_.get() => ct, _): ct.isInterface || ct.name.endsWith("Map");
            default: false;
        }
    }
    
    /**
     * Convert module type to string
     * Handles package-based module naming (e.g., ecto.Query → Ecto.Query)
     */
    static function moduleTypeToString(m: ModuleType): String {
        // Get the basic name first
        var name = switch(m) {
            case TClassDecl(c): c.get().name;
            case TEnumDecl(e): e.get().name;
            case TTypeDecl(t): t.get().name;
            case TAbstract(a): a.get().name;
        }
        
        // Get the package information
        var pack = switch(m) {
            case TClassDecl(c): c.get().pack;
            case TEnumDecl(e): e.get().pack;
            case TTypeDecl(t): t.get().pack;
            case TAbstract(a): a.get().pack;
        }
        
        // Special handling for framework packages that should use proper Elixir module names
        if (pack.length > 0) {
            switch(pack[0]) {
                case "ecto":
                    // ecto.Query should become Ecto.Query (capitalize package name)
                    return "Ecto." + name;
                case "phoenix":
                    // phoenix.LiveView should become Phoenix.LiveView
                    return "Phoenix." + name;
                case "plug":
                    // plug.Conn should become Plug.Conn
                    return "Plug." + name;
                default:
                    // Other packages keep their structure
            }
        }
        
        return name;
    }
    
    /**
     * Convert Haxe type to Elixir type string
     */
    static function typeToElixir(t: Type): String {
        return switch(t) {
            case TInst(_.get() => {name: "String"}, _): "binary";
            case TInst(_.get() => {name: "Array"}, _): "list";
            case TAbstract(_.get() => {name: "Int"}, _): "integer";
            case TAbstract(_.get() => {name: "Float"}, _): "float";
            case TAbstract(_.get() => {name: "Bool"}, _): "boolean";
            case TDynamic(_): "any";
            default: "term";
        }
    }
    
    /**
     * Check if expression is pure (no side effects)
     */
    static function isPure(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_) | TTypeExpr(_): true;
            case TBinop(_, e1, e2): isPure(e1) && isPure(e2);
            case TUnop(_, _, e): isPure(e);
            case TField(e, _): isPure(e);
            case TParenthesis(e): isPure(e);
            default: false;
        }
    }
    
    /**
     * Check if expression can be inlined
     */
    static function canBeInlined(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_) | TLocal(_): true;
            case TBinop(_, e1, e2): canBeInlined(e1) && canBeInlined(e2);
            case TUnop(_, _, e): canBeInlined(e);
            default: false;
        }
    }
    
    /**
     * Check if expression is constant
     */
    static function isConstant(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TConst(_): true;
            default: false;
        }
    }
    
    /**
     * Check if expression has side effects
     */
    static function hasSideEffects(expr: TypedExpr): Bool {
        return switch(expr.expr) {
            case TCall(_, _) | TNew(_, _, _) | TVar(_, _): true;
            case TBinop(OpAssign | OpAssignOp(_), _, _): true;
            case TUnop(OpIncrement | OpDecrement, _, _): true;
            case TThrow(_): true;
            default: false;
        }
    }
    
    /**
     * Detect array operation pattern in while loop body
     * 
     * WHY: Haxe desugars array operations (map/filter) into imperative while loops
     * that manually build arrays with push operations. We need to detect these
     * patterns to generate idiomatic Elixir Enum calls instead of Y-combinator loops.
     * 
     * WHAT: Analyzes the loop body to determine if it's a map, filter, or other
     * array transformation operation.
     * 
     * HOW: Looks for characteristic patterns like:
     * - var v = array[index]; index++; result.push(transform(v)) -> map
     * - var v = array[index]; index++; if(condition) result.push(v) -> filter
     * 
     * @return The type of array operation detected, or null if not an array pattern
     */
    static function detectArrayOperationPattern(body: TypedExpr): Null<String> {
        // Look for the characteristic patterns in the loop body
        switch(body.expr) {
            case TBlock(exprs) if (exprs.length >= 3):
                // Typical pattern has at least 3 expressions:
                // 1. var v = _g2[_g1] (array element access)
                // 2. _g1++ (index increment)  
                // 3. _g.push(...) (result building)
                
                var hasArrayAccess = false;
                var hasIncrement = false;
                var hasPush = false;
                var isFilter = false;
                
                for (expr in exprs) {
                    switch(expr.expr) {
                        case TVar(tvar, init):
                            // Check for array element access: var v = _g2[_g1]
                            if (init != null) {
                                switch(init.expr) {
                                    case TArray(_, _):
                                        hasArrayAccess = true;
                                    case _:
                                }
                            }
                            
                        case TUnop(OpIncrement, _, _) | TUnop(OpDecrement, _, _):
                            hasIncrement = true;
                            
                        case TCall({expr: TField(_, FInstance(_, _, cf))}, args) if (cf.get().name == "push"):
                            hasPush = true;
                            
                        case TIf(_, thenExpr, _):
                            // Check if the push is inside an if (filter pattern)
                            switch(thenExpr.expr) {
                                case TCall({expr: TField(_, FInstance(_, _, cf))}, _) if (cf.get().name == "push"):
                                    hasPush = true;
                                    isFilter = true;
                                case TBlock([{expr: TCall({expr: TField(_, FInstance(_, _, cf))}, _)}]) if (cf.get().name == "push"):
                                    hasPush = true;
                                    isFilter = true;
                                case _:
                            }
                            
                        case _:
                    }
                }
                
                if (hasArrayAccess && hasIncrement && hasPush) {
                    return isFilter ? "filter" : "map";
                }
                
            case _:
        }
        
        return null;
    }
    
    /**
     * Generate idiomatic Enum call for array operation
     * 
     * WHY: Instead of generating Y-combinator recursive functions for array operations,
     * we want to generate clean, idiomatic Elixir Enum.map/filter/reduce calls.
     * 
     * WHAT: Transforms the detected array pattern into the appropriate Enum call.
     * 
     * HOW: Extracts the transformation/filter function from the loop body and
     * generates the corresponding Enum call with a lambda function.
     * 
     * @param arrayRef The array being iterated over (_g2 in the pattern)
     * @param operation The type of operation ("map", "filter", etc.)
     * @param body The loop body containing the transformation logic
     * @return ElixirASTDef for the Enum call
     */
    // TODO: Future version - Use ElixirAST directly to build Enum calls instead of string manipulation
    // This would allow us to properly construct ERemoteCall(EAtom("Enum"), "map", [array, lambda])
    // with proper EFn nodes for the lambda functions, giving us better control over the output
    static function generateIdiomaticEnumCall(arrayRef: TypedExpr, operation: String, body: TypedExpr): ElixirASTDef {
        // Extract the actual array from the reference
        // arrayRef is the _g2 variable that holds the array
        var arrayAST = buildFromTypedExpr(arrayRef);
        
        // Extract the transformation from the loop body
        var lambdaBody: ElixirAST = null;
        var itemVar = "v"; // Default lambda parameter name
        
        // Analyze the body to extract the transformation
        switch(body.expr) {
            case TBlock(exprs):
                for (expr in exprs) {
                    switch(expr.expr) {
                        case TVar(tvar, _):
                            // Found the loop variable (e.g., var v = _g2[_g1])
                            itemVar = tvar.name;
                            
                        case TCall({expr: TField(_, FInstance(_, _, cf))}, [arg]) if (cf.get().name == "push"):
                            // Found the push operation - extract what's being pushed
                            lambdaBody = buildFromTypedExpr(arg);
                            
                        case TIf(cond, thenExpr, _) if (operation == "filter"):
                            // For filter, extract the condition
                            lambdaBody = buildFromTypedExpr(cond);
                            
                        case _:
                    }
                }
                
            case _:
        }
        
        // If we couldn't extract a proper transformation, fall back to identity
        if (lambdaBody == null) {
            lambdaBody = makeAST(EVar(itemVar));
        }
        
        // Create the lambda function
        var lambda = makeAST(EFn([{
            args: [PVar(itemVar)],
            guard: null,
            body: lambdaBody
        }]));
        
        // Generate the appropriate Enum call
        switch(operation) {
            case "map":
                return ERemoteCall(
                    makeAST(EAtom("Enum")),
                    "map",
                    [arrayAST, lambda]
                );
                
            case "filter":
                return ERemoteCall(
                    makeAST(EAtom("Enum")),
                    "filter",
                    [arrayAST, lambda]
                );
                
            default:
                // Fallback to map if operation is unknown
                return ERemoteCall(
                    makeAST(EAtom("Enum")),
                    "map",
                    [arrayAST, lambda]
                );
        }
    }
    
    /**
     * Check if an array of AST nodes uses a specific variable
     */
    static function usesVariable(nodes: Array<ElixirAST>, varName: String): Bool {
        for (node in nodes) {
            if (usesVariableInNode(node, varName)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Check if an AST node uses a specific variable
     */
    static function usesVariableInNode(node: ElixirAST, varName: String): Bool {
        return switch(node.def) {
            case EVar(name): name == varName;
            case ECall(target, _, args): 
                (target != null && usesVariableInNode(target, varName)) || 
                usesVariable(args, varName);
            case EMatch(_, expr): usesVariableInNode(expr, varName);
            case EBinary(_, left, right): 
                usesVariableInNode(left, varName) || usesVariableInNode(right, varName);
            case _: false;
        };
    }
    
    /**
     * Transform variable references in an AST node
     * Replaces variable names according to the provided mapping
     * Used to avoid variable shadowing in reduce_while loops
     */
    static function transformVariableReferences(ast: ElixirAST, varMapping: Map<String, String>): ElixirAST {
        if (ast == null) return null;
        
        return switch(ast.def) {
            case EVar(name):
                if (varMapping.exists(name)) {
                    // Replace with mapped name
                    #if debug_state_threading
                    trace('[Transform] Replacing variable: $name => ${varMapping.get(name)}');
                    #end
                    makeAST(EVar(varMapping.get(name)));
                } else {
                    #if debug_state_threading
                    trace('[Transform] Variable not in mapping: $name');
                    #end
                    ast;
                }
                
            case EMatch(pattern, value):
                // Transform the value but be careful with patterns
                // We need to handle assignments like "node = node.left"
                var transformedValue = transformVariableReferences(value, varMapping);
                
                // For patterns, we need special handling
                var transformedPattern = switch(pattern) {
                    case PVar(name) if (varMapping.exists(name)):
                        // This is an assignment to a tracked variable
                        // Replace with acc_ version
                        PVar(varMapping.get(name));
                    case _:
                        pattern;
                };
                
                makeAST(EMatch(transformedPattern, transformedValue));
                
            case EBlock(exprs):
                makeAST(EBlock([for (expr in exprs) transformVariableReferences(expr, varMapping)]));
                
            case EIf(cond, thenExpr, elseExpr):
                makeAST(EIf(
                    transformVariableReferences(cond, varMapping),
                    transformVariableReferences(thenExpr, varMapping),
                    elseExpr != null ? transformVariableReferences(elseExpr, varMapping) : null
                ));
                
            case ECall(fn, name, args):
                makeAST(ECall(
                    fn != null ? transformVariableReferences(fn, varMapping) : null,
                    name,
                    [for (arg in args) transformVariableReferences(arg, varMapping)]
                ));
                
            case ERemoteCall(module, fn, args):
                makeAST(ERemoteCall(
                    transformVariableReferences(module, varMapping),
                    fn,
                    [for (arg in args) transformVariableReferences(arg, varMapping)]
                ));
                
            case EField(expr, field):
                makeAST(EField(transformVariableReferences(expr, varMapping), field));
                
            case ETuple(items):
                makeAST(ETuple([for (item in items) transformVariableReferences(item, varMapping)]));
                
            case EList(items):
                makeAST(EList([for (item in items) transformVariableReferences(item, varMapping)]));
                
            case EMap(items):
                makeAST(EMap([for (item in items) {
                    key: transformVariableReferences(item.key, varMapping),
                    value: transformVariableReferences(item.value, varMapping)
                }]));
                
            case EBinary(op, left, right):
                #if debug_state_threading
                trace('[Transform] Processing EBinary: ${ElixirASTPrinter.printAST(left)} ${op} ${ElixirASTPrinter.printAST(right)}');
                #end
                makeAST(EBinary(
                    op,
                    transformVariableReferences(left, varMapping),
                    transformVariableReferences(right, varMapping)
                ));
                
            case EUnary(op, expr):
                makeAST(EUnary(op, transformVariableReferences(expr, varMapping)));
                
            case EParen(expr):
                // Handle parentheses - transform the inner expression
                #if debug_state_threading
                trace('[Transform] Processing EParen wrapper');
                #end
                makeAST(EParen(transformVariableReferences(expr, varMapping)));
                
            case ECase(expr, clauses):
                makeAST(ECase(
                    transformVariableReferences(expr, varMapping),
                    [for (clause in clauses) {
                        pattern: clause.pattern, // Don't transform patterns
                        guard: clause.guard != null ? transformVariableReferences(clause.guard, varMapping) : null,
                        body: transformVariableReferences(clause.body, varMapping)
                    }]
                ));
                
            case _:
                // For other node types, return as-is
                // This includes literals, atoms, etc.
                ast;
        };
    }
    
    /**
     * Check if an AST node contains early returns that need special handling in loops
     * 
     * WHY: Early returns in loops need to be transformed to {:halt, value} in reduce_while
     * WHAT: Recursively checks if the AST contains any return-like expressions
     * HOW: Traverses the AST looking for expressions that would cause early loop exit
     * 
     * NOTE: This is currently disabled as the pattern detection is too complex
     * and was causing incorrect transformations. Early returns in loops are 
     * not common in the Haxe stdlib patterns we're compiling.
     */
    static function checkForEarlyReturns(ast: ElixirAST): Bool {
        // DISABLED: The early return detection was too aggressive and causing
        // incorrect transformations. Since the Haxe standard library doesn't
        // actually use early returns in the loops we're compiling (they use
        // the __elixir__ approach instead), we can safely disable this for now.
        return false;
    }
    
    /**
     * Transform return values in loop bodies to {:halt, value} tuples
     * 
     * WHY: Early returns in reduce_while loops must use {:halt, value} to stop iteration
     * WHAT: Transforms expressions that return values into proper halt tuples
     * HOW: Wraps return values with {:halt, ...} and adds {:cont, ...} for normal flow
     */
    static function transformReturnsToHalts(body: ElixirAST, accumulator: ElixirAST): ElixirAST {
        if (body == null) return null;
        
        return switch(body.def) {
            case EIf(cond, thenBranch, elseBranch):
                // Transform both branches
                makeAST(EIf(
                    cond,
                    wrapWithHaltIfNeeded(thenBranch, accumulator),
                    wrapWithHaltIfNeeded(elseBranch, accumulator)
                ));
                
            case EBlock(exprs):
                // Transform the block expressions
                var transformedExprs = [];
                for (i in 0...exprs.length) {
                    if (i == exprs.length - 1) {
                        // Last expression might be a return value
                        transformedExprs.push(wrapWithHaltIfNeeded(exprs[i], accumulator));
                    } else {
                        transformedExprs.push(transformReturnsToHalts(exprs[i], accumulator));
                    }
                }
                makeAST(EBlock(transformedExprs));
                
            case ECase(expr, clauses):
                // Transform each clause body
                makeAST(ECase(
                    expr,
                    [for (clause in clauses) {
                        pattern: clause.pattern,
                        guard: clause.guard,
                        body: wrapWithHaltIfNeeded(clause.body, accumulator)
                    }]
                ));
                
            case _:
                // For other expressions, wrap with halt if it's a return value
                wrapWithHaltIfNeeded(body, accumulator);
        };
    }
    
    /**
     * Wrap an expression with {:halt, value} if it's a return value
     */
    static function wrapWithHaltIfNeeded(expr: ElixirAST, accumulator: ElixirAST): ElixirAST {
        if (expr == null) return null;
        
        return switch(expr.def) {
            case ETuple([atom, _]):
                // Already a tuple, check if it's cont/halt
                switch(atom.def) {
                    case EAtom("cont") | EAtom("halt"):
                        expr; // Already properly wrapped
                    case _:
                        // Other tuple, treat as return value
                        makeAST(ETuple([makeAST(EAtom("halt")), expr]));
                }
            case EBlock([]):
                // Empty block, add continuation
                makeAST(ETuple([makeAST(EAtom("cont")), accumulator]));
            case _:
                // Any other value is treated as an early return
                makeAST(ETuple([makeAST(EAtom("halt")), expr]));
        };
    }
}

#end