package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirAST.makeAST;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.ElixirASTTransformer;

/**
 * ReduceBodySanitizeTransforms
 *
 * WHAT
 * - Sanitizes Enum.reduce anonymous function bodies produced by earlier lowerings:
 *   - Replace head extraction assignments like `x = some_list[0]` with `x = binder`.
 *   - Normalize accumulator rebinds `tmp = Enum.concat(tmp, [expr])` to
 *     `acc = Enum.concat(acc, [expr])` using the declared accumulator name.
 *   - Drop stray arithmetic-only statements (e.g., a bare `+`) with no effect.
 *
 * WHY
 * - Some transformations leave vestigial artifacts inside reduce bodies that cause
 *   compilation errors and non-idiomatic code (e.g., undefined vars, bare operators).
 * - This pass enforces the canonical binder/accumulator structure without heuristics.
 *
 * HOW
 * - Targets only ERemoteCall(Enum, "reduce", [list, init, fn]) nodes.
 * - Introspects the reducer function to detect binder and accumulator names and
 *   rewrites specific mis-shapes by structure (index access to 0, self-concat on temp).
 */
/**
 * ReduceBodySanitizeTransforms
 *
 * WHAT
 * - Sanitizes bodies of `Enum.reduce/3` anonymous functions generated by lowerings to restore
 *   idiomatic, valid Elixir. Specifically fixes three problematic artifacts seen after earlier
 *   transformations:
 *   1) Head extraction through indexed access: `x = some_list[0]` → `x = binder`
 *   2) Accumulator self-concat rebinds: `tmp = Enum.concat(tmp, [expr])` → `acc = Enum.concat(acc, [expr])`
 *   3) Stray arithmetic-only statements: standalone `+` (emitted as an `EBinary(Add, _, _)`) are dropped
 *
 * WHY
 * - During complex lowerings (loops → reduce, comprehension-like rewrites), intermediate artifacts can
 *   leak into reducer bodies:
 *   - Access-based head extraction (`list[0]`) is a byproduct of earlier aliasing. In reducers the first
 *     parameter already is the current element — referencing `list[0]` is both non-idiomatic and fragile.
 *   - Assigning to a temporary accumulator (`tmp = Enum.concat(tmp, ...)`) breaks the canonical reduce
 *     contract where the accumulator must be the second argument. This causes undefined-variable and WAE
 *     failures when `tmp` is not bound in all paths.
 *   - An orphan `+` statement has no effect and is invalid inside a match context, triggering compile errors.
 * - Fixing these at the reducer-body level is the least invasive, shape-based correction that preserves
 *   semantics and adheres to the “no name heuristics” rule.
 *
 * HOW
 * - Scope/Guards (shape-based, name-agnostic):
 *   - Applies only to `ERemoteCall(Enum, "reduce", [list, init, fn])` nodes.
 *   - Requires a 2-parameter reducer function `fn binder, acc -> ... end` so we can reliably identify
 *     both the current element (binder) and the accumulator (acc).
 *   - Within the reducer body, operates statement-by-statement using structural checks:
 *     (a) Head extraction fix:
 *         - Matches `EBinary(Match, lhs, EAccess(_, EInteger(0)))` and rewrites RHS to `EVar(binder)`
 *         - Safe because inside a reducer, the current element is always provided by the binder param
 *     (b) Accumulator rebind fix:
 *         - Matches `EBinary(Match, EVar(lhs), ERemoteCall(_, "concat", [EVar(lhs), listOne]))`
 *         - Rewrites to `acc = Enum.concat(acc, listOne)`, where `acc` is the second reducer parameter
 *         - Ignores module alias on concat (shape-based), enforces Enum in the replacement for clarity
 *     (c) Stray arithmetic drop:
 *         - Matches `EBinary(Add, _, _)` statements and replaces them with 0, immediately filtered out
 *           from the reconstructed block to avoid literal warnings
 * - Limitations and Safety:
 *   - Does not rewrite expressions that are not inside a 2-arg reducer.
 *   - Does not guess names: `binder` and `acc` are taken from reducer params; all other names are left intact.
 *   - Only index 0 access is treated as head extraction; higher indices remain untouched by this pass.
 *
 * EXAMPLES
 * Haxe (shape-similar pseudocode):
 *   var list = Map.values(tags);
 *   Enum.reduce(list, [], (entry, acc) -> {
 *     tag = list[0];
 *     + // stray arithmetic artifact
 *     tag_elements = Enum.concat(tag_elements, [render(tag)]);
 *     acc;
 *   });
 *
 * Elixir (before):
 *   Enum.reduce(Map.values(tags), [], fn entry, acc ->
 *     tag = tags[0]
 *      +
 *     tag_elements = Enum.concat(tag_elements, [render(tag)])
 *     acc
 *   end)
 *
 * Elixir (after):
 *   Enum.reduce(Map.values(tags), [], fn entry, acc ->
 *     tag = entry
 *     acc = Enum.concat(acc, [render(tag)])
 *     acc
 *   end)
 *
 * Notes
 * - This pass does not alter control flow or add new temps; it only corrects reducer-local statement shapes.
 * - It is intentionally late in the pipeline (ReduceBodySanitize(Final)) so earlier rewrites have settled,
 *   allowing purely structural clean-up without interfering with other transforms.
 */
class ReduceBodySanitizeTransforms {
    #if debug_reduce_body_sanitize
    static var reducerCount:Int = 0;
    static inline var REDUCER_WARN_THRESHOLD:Int = 2000;
    #end

    public static function transformPass(ast: ElixirAST): ElixirAST {
        return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
            return switch (n.def) {
                case ERemoteCall(modRef, "reduce", args) if (args.length == 3):
                    var listExpr = args[0];
                    var init = args[1];
                    var fnNode = args[2];
                    switch (fnNode.def) {
                        case EFn(clauses) if (clauses.length == 1):
                            var cl = clauses[0];
                            // Expect two-arg reducer: fn binder, acc -> ... end
                            var binderName:Null<String> = null;
                            var accName:Null<String> = null;
                            if (cl.args.length >= 1) switch (cl.args[0]) { case PVar(n): binderName = n; default: }
                            if (cl.args.length >= 2) switch (cl.args[1]) { case PVar(n2): accName = n2; default: }
                            if (binderName == null || accName == null) return n;

                            var bodyStmts:Array<ElixirAST> = switch (cl.body.def) { case EBlock(ss): ss; default: [cl.body]; };
                            #if debug_reduce_body_sanitize
                            reducerCount++;
                            if (reducerCount % 50 == 0) {
                                Sys.println('[ReduceBodySanitize] processed ' + reducerCount + ' reducer bodies so far');
                            }
                            Sys.println('[ReduceBodySanitize] reducer clauses=' + clauses.length + ', binder=' + binderName + ', acc=' + accName);
                            if (reducerCount > REDUCER_WARN_THRESHOLD) {
                                Sys.println('[ReduceBodySanitize] WARNING: reducerCount exceeded ' + REDUCER_WARN_THRESHOLD + ' – possible transform loop.');
                            }
                            #end

                            var newBody:Array<ElixirAST> = [];

                            for (stmt in bodyStmts) {
                                var rewritten = stmt;
                                rewritten = switch (rewritten.def) {
                                    // Normalize push sentinels to acc = Enum.concat(acc, [value])
                                    // Handles both push(value) and zero-arg push() by using the binder
                                    case ECall(func, method, args) if (func == null && method == "push"):
                                        var valueExpr: ElixirAST = (args != null && args.length >= 1) ? args[0] : makeAST(EVar(binderName));
                                        var concatRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [ makeAST(EVar(accName)), makeAST(EList([ valueExpr ])) ]));
                                        makeASTWithMeta(EBinary(Match, makeAST(EVar(accName)), concatRight), rewritten.metadata, rewritten.pos);
                                    // x = something[0]  → x = binder
                                    case EBinary(Match, left, rhs):
                                        switch (rhs.def) {
                                            case EAccess(_, key):
                                                var isZero = switch (key.def) { case EInteger(v) if (v == 0): true; default: false; };
                                                if (isZero) makeASTWithMeta(EBinary(Match, left, makeAST(EVar(binderName))), rewritten.metadata, rewritten.pos) else rewritten;
                                            case ERemoteCall(_, "concat", cargs) if (cargs.length == 2):
                                                // temp = Enum.concat(temp, [expr])  → acc = Enum.concat(acc, [expr])
                                                var lhs:Null<String> = switch (left.def) { case EVar(nm): nm; default: null; };
                                                var isSelf = switch (cargs[0].def) { case EVar(nm2): (lhs != null && nm2 == lhs); default: false; };
                                                #if debug_reduce_body_sanitize
                                                Sys.println('[ReduceBodySanitize] concat lhs=' + (lhs == null ? 'null' : lhs) + ', arg0=' + (switch (cargs[0].def) { case EVar(n): n; default: '<non-var>'; }) + ', isSelf=' + isSelf);
                                                #end
                                                if (isSelf) {
                                                    var replLeft = makeAST(EVar(accName));
                                                    var replRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [makeAST(EVar(accName)), cargs[1]]));
                                                    makeASTWithMeta(EBinary(Match, replLeft, replRight), rewritten.metadata, rewritten.pos);
                                                 } else rewritten;
                                             default:
                                                 rewritten;
                                         }
                                    // pattern match variant: x = something[0] → x = binder
                                    case EMatch(pat, rhsM):
                                        switch (rhsM.def) {
                                            case EAccess(_, keyM):
                                                var isZeroM = switch (keyM.def) { case EInteger(v) if (v == 0): true; default: false; };
                                                if (isZeroM) makeASTWithMeta(EMatch(pat, makeAST(EVar(binderName))), rewritten.metadata, rewritten.pos) else rewritten;
                                            case ERemoteCall(_, "concat", cargsM) if (cargsM.length == 2):
                                                // tmp = Enum.concat(tmp, [expr]) → acc = Enum.concat(acc, [expr])
                                                var lhsNameM:Null<String> = switch (pat) { case PVar(nm): nm; default: null; };
                                                var isSelfM = switch (cargsM[0].def) { case EVar(nm2): (lhsNameM != null && nm2 == lhsNameM); default: false; };
                                                #if debug_reduce_body_sanitize
                                                Sys.println('[ReduceBodySanitize] ematch concat lhs=' + (lhsNameM == null ? 'null' : lhsNameM) + ', arg0=' + (switch (cargsM[0].def) { case EVar(n): n; default: '<non-var>'; }) + ', isSelf=' + isSelfM);
                                                #end
                                                if (isSelfM) {
                                                    var newLeft = makeAST(EVar(accName));
                                                    var newRight = makeAST(ERemoteCall(makeAST(EVar("Enum")), "concat", [makeAST(EVar(accName)), cargsM[1]]));
                                                    makeASTWithMeta(EBinary(Match, newLeft, newRight), rewritten.metadata, rewritten.pos);
                                                } else rewritten;
                                            default:
                                                rewritten;
                                        }
                                    // Drop bare arithmetic statements inside body
                                    case EBinary(Add, _, _):
                                        // Drop entirely by replacing with a zero literal (later cleanup),
                                        // and also allow the outer loop to skip pushing it if desired
                                        makeAST(EInteger(0));
                                    default:
                                        rewritten;
                                };
                                // Skip zero sentinels here to avoid lingering literal warnings
                                switch (rewritten.def) {
                                    case EInteger(v) if (v == 0):
                                        // skip
                                    default:
                                        newBody.push(rewritten);
                                }
                            }

                            // Fast path: if nothing changed, return original node to avoid churn.
                            var changed = (newBody.length != bodyStmts.length);
                            if (!changed) {
                                for (i in 0...newBody.length) {
                                    if (newBody[i] != bodyStmts[i]) {
                                        changed = true;
                                        break;
                                    }
                                }
                            }
                            if (!changed) return n;

                            var finalBody:ElixirAST = makeAST(EBlock(newBody));
                            var newFn = makeAST( EFn([{ args: cl.args, guard: cl.guard, body: finalBody }]) );
                            makeASTWithMeta(ERemoteCall(makeAST(EVar("Enum")), "reduce", [listExpr, init, newFn]), n.metadata, n.pos);
                        default:
                            n;
                    }
                default:
                    n;
            }
        });
    }
}

#end
