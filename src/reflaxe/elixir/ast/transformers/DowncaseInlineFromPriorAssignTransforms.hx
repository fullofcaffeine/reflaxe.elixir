package reflaxe.elixir.ast.transformers;

#if (macro || reflaxe_runtime)

import reflaxe.elixir.ast.ElixirAST;
import reflaxe.elixir.ast.ElixirASTTransformer;
import reflaxe.elixir.ast.ElixirAST.makeASTWithMeta;
import reflaxe.elixir.ast.analyzers.OptimizedVarUseAnalyzer;

/**
 * DowncaseInlineFromPriorAssignTransforms
 *
 * WHAT
 * - If a block contains an earlier assignment `v = rhs` and later we see
 *   `String.downcase(v)` with no intervening rebind of `v` and `v` is not used
 *   elsewhere, inline to `String.downcase(rhs)` and drop the earlier assign.
 * - Also handles ERaw nodes containing `String.downcase(_var)` patterns
 *   (generated by String.cross.hx's toLowerCase() via __elixir__)
 *
 * WHY
 * - Eliminates "underscored variable _this is used" warnings by inlining
 *   temporary variables directly into the downcase call.
 */
class DowncaseInlineFromPriorAssignTransforms {
  public static function pass(ast: ElixirAST): ElixirAST {
    return ElixirASTTransformer.transformNode(ast, function(n: ElixirAST): ElixirAST {
      return switch (n.def) {
        case EBlock(stmts): makeASTWithMeta(EBlock(rewrite(stmts)), n.metadata, n.pos);
        case EDo(doStatements): makeASTWithMeta(EDo(rewrite(doStatements)), n.metadata, n.pos);
        default: n;
      }
    });
  }

  static function rewrite(stmts:Array<ElixirAST>):Array<ElixirAST> {
    if (stmts == null) return stmts;
    var useIndex = OptimizedVarUseAnalyzer.buildExact(stmts);
    var out:Array<ElixirAST> = [];
    var assigns:Map<String, { idx:Int, rhs:ElixirAST } > = new Map();
    for (i in 0...stmts.length) {
      var s = stmts[i];
      var replaced:Null<ElixirAST> = null;
      switch (s.def) {
        case EBinary(Match, left, rhs):
          switch (left.def) { case EVar(v): assigns.set(v, {idx: out.length, rhs: rhs}); default: }
        case ERemoteCall({def: EVar("String")}, "downcase", args) if (args != null && args.length == 1):
          switch (args[0].def) {
            case EVar(vname) if (assigns.exists(vname) && !usedBetween(out, stmts, assigns.get(vname).idx+1, i, vname) && !OptimizedVarUseAnalyzer.usedLater(useIndex, i + 1, vname)):
              var rec = assigns.get(vname);
              // remove earlier assign from out
              out = out.slice(0, rec.idx).concat(out.slice(rec.idx+1));
              replaced = makeASTWithMeta(ERemoteCall(makeASTWithMeta(EVar("String"), s.metadata, s.pos), "downcase", [rec.rhs]), s.metadata, s.pos);
            default:
          }
        // Handle ERaw containing String.downcase(_var) patterns (from __elixir__)
        case ERaw(code) if (code != null && code.indexOf("String.downcase(") >= 0):
          var vname = extractVarFromDowncase(code);
          if (vname != null && assigns.exists(vname) && !usedBetween(out, stmts, assigns.get(vname).idx+1, i, vname) && !OptimizedVarUseAnalyzer.usedLater(useIndex, i + 1, vname)) {
            var rec = assigns.get(vname);
            var rhsStr = simpleASTToString(rec.rhs);
            if (rhsStr != null) {
              // remove earlier assign from out
              out = out.slice(0, rec.idx).concat(out.slice(rec.idx+1));
              // substitute var in ERaw
              var newCode = substituteInRaw(code, vname, rhsStr);
              replaced = makeASTWithMeta(ERaw(newCode), s.metadata, s.pos);
            }
          }
        default:
      }
      out.push(replaced != null ? replaced : s);
    }
    return out;
  }

  static function usedBetween(out:Array<ElixirAST>, stmts:Array<ElixirAST>, start:Int, endIdx:Int, name:String): Bool {
    var found = false;
    for (j in start...endIdx) if (!found) {
      var node = j < out.length ? out[j] : stmts[j];
      reflaxe.elixir.ast.ASTUtils.walk(node, function(x:ElixirAST){
        switch (x.def) { case EVar(v) if (v == name): found = true; default: }
      });
    }
    return found;
  }

  /**
   * Extract variable name from String.downcase(_var) pattern in raw code.
   * Example: "String.downcase(_this)" -> "_this"
   */
  static function extractVarFromDowncase(code:String):Null<String> {
    var startIdx = code.indexOf("String.downcase(");
    if (startIdx == -1) return null;
    startIdx += "String.downcase(".length;
    var endIdx = code.indexOf(")", startIdx);
    if (endIdx == -1) return null;
    var varName = code.substring(startIdx, endIdx);
    // Validate it looks like a variable name
    if (varName.length == 0) return null;
    var firstChar = varName.charCodeAt(0);
    // Must start with letter or underscore
    if (!((firstChar >= 65 && firstChar <= 90) || (firstChar >= 97 && firstChar <= 122) || firstChar == 95)) {
      return null;
    }
    return varName;
  }

  /**
   * Convert simple AST to string for ERaw substitution.
   */
  static function simpleASTToString(ast:ElixirAST):Null<String> {
    if (ast == null || ast.def == null) return null;
    return switch (ast.def) {
      case EVar(name): name;
      case EField(obj, field):
        var objStr = simpleASTToString(obj);
        if (objStr != null) '${objStr}.${field}' else null;
      case EAtom(name): ':${name}';
      case EInteger(val): Std.string(val);
      case EFloat(val): Std.string(val);
      case EString(val): '"${val}"';
      case EBoolean(val): val ? "true" : "false";
      case ENil: "nil";
      default: null;
    };
  }

  /**
   * Substitute variable name in raw code with token boundary detection.
   */
  static function substituteInRaw(code:String, from:String, to:String):String {
    inline function isIdentChar(c:String):Bool {
      if (c == null || c.length == 0) return false;
      var ch = c.charCodeAt(0);
      return (ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) || c == "_";
    }

    var result = new StringBuf();
    var idx = 0;
    var lastEnd = 0;

    while (idx < code.length) {
      var pos = code.indexOf(from, idx);
      if (pos == -1) break;

      var before = pos > 0 ? code.charAt(pos - 1) : "";
      var afterIdx = pos + from.length;
      var after = afterIdx < code.length ? code.charAt(afterIdx) : "";

      if (!isIdentChar(before) && !isIdentChar(after)) {
        result.add(code.substring(lastEnd, pos));
        result.add(to);
        lastEnd = afterIdx;
        idx = afterIdx;
      } else {
        idx = pos + 1;
      }
    }

    if (lastEnd > 0) {
      result.add(code.substring(lastEnd));
      return result.toString();
    }
    return code;
  }
}

#end
