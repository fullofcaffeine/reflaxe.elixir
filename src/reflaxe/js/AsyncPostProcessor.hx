package reflaxe.js;

#if macro
import haxe.macro.Compiler;
import haxe.macro.Context;
import haxe.macro.JSGenApi;
import sys.io.File;

/**
 * Minimal JavaScript post-processor for async/await support.
 * 
 * This custom JS generator delegates all work to the default Haxe JS generator,
 * then post-processes the output to add async keywords where needed.
 * 
 * Approach:
 * 1. Let Haxe generate JavaScript normally
 * 2. Intercept the final output
 * 3. Add async keywords to marked functions
 * 4. Save the modified JavaScript
 */
class AsyncPostProcessor {
    
    /**
     * Register this post-processor as the custom JS generator.
     */
    public static function use() {
        Compiler.setCustomJSGenerator(generate);
    }
    
    /**
     * Generate JavaScript with async support.
     * 
     * Strategy: We can't easily intercept the default generator's output,
     * so we read the file after Haxe writes it, modify it, and write it back.
     * 
     * Alternative approach: Use onAfterGenerate callback to post-process.
     */
    static function generate(api: JSGenApi) {
        // Store the output file path for post-processing
        var outputFile = api.outputFile;
        
        // We need to let the default generator run first
        // The trick is to NOT actually generate here, but register a callback
        // for after generation completes
        
        // Unfortunately, we can't easily delegate to the default generator
        // from within setCustomJSGenerator. Instead, let's generate
        // a minimal valid JS file that we'll replace in onAfterGenerate
        
        // For now, write a placeholder
        File.saveContent(outputFile, "// Async post-processing pending...\n");
        
        // Register our post-processor to run after all generation
        Context.onAfterGenerate(function() {
            // Now read what Haxe would have generated
            // But wait - we replaced the generator, so Haxe didn't generate anything!
            // We need a different approach...
            
            // Actually, we need to generate the JS ourselves using the API
            generateWithAsync(api);
        });
    }
    
    /**
     * Actually generate the JavaScript with async support.
     */
    static function generateWithAsync(api: JSGenApi) {
        var buf = new StringBuf();
        
        // Generate clean ES6 code
        buf.add("// Generated by Haxe ");
        buf.add(Context.definedValue("haxe") != null ? Context.definedValue("haxe") : "4.3.7");
        buf.add("\n");
        buf.add("(function ($global) { \"use strict\";\n");
        
        // Let the API generate each type
        for (type in api.types) {
            var typeStr = api.generateType(type);
            if (typeStr != null && typeStr != "") {
                buf.add(typeStr);
                buf.add("\n");
            }
        }
        
        // Add main
        if (api.main != null) {
            var mainStr = api.generateValue(api.main);
            if (mainStr != null && mainStr != "") {
                buf.add(mainStr);
                buf.add(";\n");
            }
        }
        
        // Close wrapper
        buf.add("})({});\n");
        
        // Post-process to add async keywords
        var js = buf.toString();
        js = postProcessAsync(js);
        
        // Write final output
        File.saveContent(api.outputFile, js);
    }
    
    /**
     * Post-process JavaScript to add async keywords.
     * 
     * Looks for specific patterns that indicate async functions:
     * - Functions with __async_marker__ variable
     * - Functions preceded by /*async*/ comment
     */
    static function postProcessAsync(js: String): String {
        // Pattern 1: Anonymous functions with __async_marker__
        // function() { var __async_marker__ = true; ... } -> async function() { ... }
        var pattern = ~/function\s*\(([^)]*)\)\s*\{\s*var\s+__async_marker__\s*=\s*true;/g;
        js = pattern.replace(js, "async function($1) {");
        
        // Pattern 2: Clean up the marker variable itself
        js = StringTools.replace(js, "var __async_marker__ = true;", "");
        js = StringTools.replace(js, "var __async_marker__ = true;", ""); // In case of duplicates
        
        // Pattern 3: Method functions marked with /*async*/
        // /*async*/ function name() -> async function name()
        var methodPattern = ~/\/\*async\*\/\s*function\s+/g;
        js = methodPattern.replace(js, "async function ");
        
        // Pattern 4: Arrow functions marked with /*async*/  
        // /*async*/ () => -> async () =>
        var arrowPattern = ~/\/\*async\*\/\s*\(([^)]*)\)\s*=>/g;
        js = arrowPattern.replace(js, "async ($1) =>");
        
        // Clean up any remaining async comments
        js = StringTools.replace(js, "/*async*/", "");
        
        return js;
    }
}
#end