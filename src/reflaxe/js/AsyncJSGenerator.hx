package reflaxe.js;

#if macro
import haxe.macro.JSGenApi;
import haxe.macro.Type;
import haxe.macro.TypedExprTools;
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.io.Path;
import sys.io.File;

using haxe.macro.TypedExprTools;

/**
 * Custom JavaScript generator that adds support for async/await syntax.
 * 
 * This generator processes the TypedExpr AST and generates proper 
 * ES6 async functions with the async keyword for functions marked
 * with @:jsAsync metadata.
 * 
 * Usage:
 * --macro reflaxe.js.AsyncJSGenerator.use()
 */
class AsyncJSGenerator {
    var api: JSGenApi;
    var buf: StringBuf;
    var indent: Int = 0;
    var asyncMode: Bool = false;
    
    public function new(api: JSGenApi) {
        this.api = api;
        this.buf = new StringBuf();
    }
    
    /**
     * Register this generator to be used for async functions.
     */
    public static function use() {
        // Set up a custom JS generator
        haxe.macro.Compiler.setCustomJSGenerator(function(api: JSGenApi) {
            new AsyncJSGenerator(api).generate();
        });
    }
    
    /**
     * Main generation function.
     */
    public function generate() {
        buf = new StringBuf();
        
        // Generate opening
        buf.add("// Generated by Haxe with async support\n");
        buf.add("(function ($global) { \"use strict\";\n");
        
        // Process each type
        for (type in api.types) {
            generateType(type);
        }
        
        // Generate main if present
        if (api.main != null) {
            buf.add("\n// Main\n");
            generateExpr(api.main);
            buf.add(";\n");
        }
        
        // Close wrapper
        buf.add("})({});\n");
        
        // Write output
        File.saveContent(api.outputFile, buf.toString());
    }
    
    /**
     * Generate code for a type.
     */
    function generateType(type: Type) {
        switch (type) {
            case TInst(c, params):
                generateClass(c.get(), params);
            case TEnum(e, params):
                generateEnum(e.get(), params);
            case TAbstract(a, params):
                // Abstracts are usually inlined
            case TType(t, params):
                // Type aliases don't generate code
            case _:
        }
    }
    
    /**
     * Generate a class with async support.
     */
    function generateClass(c: ClassType, params: Array<Type>) {
        buf.add('class ${c.name} ');
        
        // Handle superclass
        if (c.superClass != null) {
            buf.add('extends ${getTypePath(TInst(c.superClass.t, c.superClass.params))} ');
        }
        
        buf.add("{\n");
        indent++;
        
        // Constructor
        if (c.constructor != null) {
            generateClassField(c.constructor.get(), false);
        }
        
        // Instance fields
        for (field in c.fields.get()) {
            generateClassField(field, false);
        }
        
        // Static fields
        for (field in c.statics.get()) {
            generateClassField(field, true);
        }
        
        indent--;
        buf.add("}\n");
    }
    
    /**
     * Generate a class field (method or property).
     */
    function generateClassField(field: ClassField, isStatic: Bool) {
        // Check for async metadata
        var isAsync = hasAsyncMeta(field.meta.get());
        
        writeIndent();
        if (isStatic) buf.add("static ");
        
        switch (field.kind) {
            case FMethod(_):
                // Generate method
                if (isAsync) buf.add("async ");
                buf.add('${field.name}');
                
                // Get the function expression
                switch (field.expr()) {
                    case TFunction(f):
                        generateFunction(f, isAsync);
                    case _:
                        // Not a function?
                        buf.add("() {}");
                }
                
            case FVar(_, _):
                // Generate field
                buf.add('${field.name} = ');
                if (field.expr() != null) {
                    generateExpr(field.expr());
                } else {
                    buf.add("null");
                }
                buf.add(";");
        }
        buf.add("\n");
    }
    
    /**
     * Generate a function with proper async handling.
     */
    function generateFunction(f: TFunc, isAsync: Bool) {
        // Parameters
        buf.add("(");
        var first = true;
        for (arg in f.args) {
            if (!first) buf.add(", ");
            buf.add(arg.v.name);
            first = false;
        }
        buf.add(") ");
        
        // Body
        buf.add("{\n");
        indent++;
        
        // Set async mode for expression generation
        var oldAsync = asyncMode;
        asyncMode = isAsync;
        
        generateExpr(f.expr);
        
        asyncMode = oldAsync;
        
        indent--;
        writeIndent();
        buf.add("}");
    }
    
    /**
     * Generate an expression.
     */
    function generateExpr(e: TypedExpr) {
        switch (e.expr) {
            case TFunction(f):
                // Check if this is an async function
                var meta = TypedExprTools.iter(e, function(e2) {
                    // Look for metadata
                });
                buf.add("function");
                generateFunction(f, false);
                
            case TCall(e, el):
                // Handle await calls if in async mode
                if (asyncMode && isAwaitCall(e)) {
                    buf.add("await ");
                    generateExpr(el[0]);
                } else {
                    // Normal call
                    generateExpr(e);
                    buf.add("(");
                    var first = true;
                    for (arg in el) {
                        if (!first) buf.add(", ");
                        generateExpr(arg);
                        first = false;
                    }
                    buf.add(")");
                }
                
            case TVar(v, e):
                writeIndent();
                buf.add('let ${v.name}');
                if (e != null) {
                    buf.add(" = ");
                    generateExpr(e);
                }
                buf.add(";\n");
                
            case TBlock(el):
                for (e in el) {
                    generateExpr(e);
                }
                
            case TConst(c):
                generateConst(c);
                
            case TLocal(v):
                buf.add(v.name);
                
            case TField(e, fa):
                generateExpr(e);
                buf.add(".");
                buf.add(getFieldName(fa));
                
            case _:
                // Use the default generator for other cases
                buf.add(api.generateValue(e));
        }
    }
    
    /**
     * Check if expression is an await call.
     */
    function isAwaitCall(e: TypedExpr): Bool {
        return switch (e.expr) {
            case TField(_, FStatic(c, cf)) if (cf.get().name == "await"):
                true;
            case _:
                false;
        };
    }
    
    /**
     * Generate a constant.
     */
    function generateConst(c: TConstant) {
        switch (c) {
            case TString(s): buf.add('"' + StringTools.replace(s, '"', '\\"') + '"');
            case TInt(i): buf.add(Std.string(i));
            case TFloat(f): buf.add(f);
            case TBool(b): buf.add(b ? "true" : "false");
            case TNull: buf.add("null");
            case _: buf.add("undefined");
        }
    }
    
    /**
     * Helper to get field name.
     */
    function getFieldName(fa: FieldAccess): String {
        return switch (fa) {
            case FInstance(_, _, cf) | FStatic(_, cf) | FClosure(_, cf): cf.get().name;
            case FAnon(cf): cf.get().name;
            case FDynamic(s): s;
            case FEnum(_, ef): ef.name;
        };
    }
    
    /**
     * Get type path as string.
     */
    function getTypePath(t: Type): String {
        return api.generateValue(TypedExprTools.mk(TConst(TNull), t, null));
    }
    
    /**
     * Write indentation.
     */
    function writeIndent() {
        for (i in 0...indent) {
            buf.add("\t");
        }
    }
    
    /**
     * Check for async metadata.
     */
    function hasAsyncMeta(meta: Metadata): Bool {
        for (m in meta) {
            if (m.name == ":jsAsync" || m.name == "jsAsync") {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Generate enum (simplified).
     */
    function generateEnum(e: EnumType, params: Array<Type>) {
        // Enums in JS are usually objects
        buf.add('const ${e.name} = {\n');
        for (name => ctor in e.constructs) {
            buf.add('\t${name}: "${name}",\n');
        }
        buf.add('};\n');
    }
}
#end