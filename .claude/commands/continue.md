Follow the instructions below strictly. Do not edit this file.

If there's a summary report in the previous messages with clear next steps, take those next steps and integrate them into the plan below. These next steps should take precedence, but should follow the guidelines below, too.

Remember, you're a compiler development expert and you're a Haxe and Elixir expert, too. Follow the instructions on .claude/agents/haxe-reflaxe-compiler-expert.md. Find good architectural patterns using the reference compilers in haxe.elixir.reference and the source code of haxe and elixir and your expertise in compiler development with Haxe and Refaxe and Elixir.

Identify the current task we're working on in shrimp, including its ID, make sure that the progress you reported is updated there. If we changed course too much from the original intentions of the task, you should suggest a replan, if not, update the task and continue working.

If no current task in in progress, pick from the highest priority INPROGRESS task if any. If not, pick from the next highest PENDING task from the shrimp list, and continue.

The substaks should have the following format in the shrimp task:

- [ ] Subtask 1
- [ ] Subtask 2
- [ ] Subtask 3
      and so on.

Plan mode: You shoud verify if we have existing subtasks and update them, or add new ones if needed so as that restarting fro a fresh context is easy and frictionless. The task in shrimp should provide a detailed plan for completig the task, if not, research using shrimp (research mode) and update it accordingly, unless we're off from it and need a replan (see below). Only if needed.

It should be in the verification criteria, alongside other verification criteria.

If you finished a task, commit the changes with a descriptive commit message after the verify step is done and passed.

Don't forget that each task in shrimp should have a verification criteria to run the qa-sentinel as part of the verification process. It should also have a reminder to stick with the shrimp flow and keep the task/plan updated.

Remember that as part of the verification criteria, you should gather the output of the todoapp - output of the haxe compilatio, elixir compilation and finally the runtime errors, if any (use curl to call the todoapp endpoints and see if they work as expected). That output + the plan of the task should help create the deterministic feedback loop to verify if the task is done or not yet.

After each step you should also tell me how far are we from completing the task, based on the verification criteria.

IMPORTANT: It's very important we don't fall into a never-ending cycle, that's why you should keep shrimp updated and make sure the tasks are clear and have all the necessary info to be executed without friction. Each continue step should bring us closer to the goal and you should be aware of speifically what is left to do until the task in shrimp can be verified and marked as done. If you find stuff that needs to be done that is not part of the task, you should analyze the complexity and if it's falls into the task's umbrella, you should add it as a subtask, if not, you should suggest a replan to create a new task for it or update the plan accordingly.

WE SHOULD NEVER COUPLE THE COMPILER CODE TO THE TODOAPP CODE. THE COMPILER SHOULD BE GENERIC AND NOT TIED TO ANY SPECIFIC APP OR CODE. THIS IS VERY IMPORTANT. So, for example, not comparing against var names or specific code shapes from the todoapp. The compiler should be generic and work for any code.

Remember to use transformers wisely and only when needed. Don't overuse them, it might be a smell telling us the architecture of the compiler needs to change elsewhere. Justify the creation of transformers for me and in hxdoc. Always check if there's an existing transformer that can be adapted/used before creating a new one. Before using transformers, make sure it's not a deeper architectural issue that needs to be addressed elsewhere in the compiler!!!

When you need to make a change in any component or transformer, you should first understand the compiler holistically. A new component should not break what another component did or undo it or cause regressions. You should understand the flow of the compiler and how data flows through it, and how each component interacts with each other. You should also check if there's any existing tests that cover the change you're making, if not, you should add them. For example, you should not add a new transformer to fix a warning or error if the root cause is elsewhere, you should fix it at the root cause and not add bandaids that might cause more problems in the future - the error/warning might disappear but it might cause other problems elsewhere (or other error and warnings), this should never happen!

Write idiomatic haxe and elixir code, follow best practices and patterns from the reference compilers and the languages. Follow SOLID principles and make sure the code is maintainable and clean. If you see a file growing too much (> 2k lines), then refactor it into smaller files, but don't be too strict about it, use your judgement depending on the case. Code quality should be high. Write self-descriptive code, with good descriptive variable names and structure. Use descriptive variable names and not short names like q, sp, etc. Don't add suffix to the end of vars in cases when you can use the same var name (that will get overriden in or reset in that case bloc) for example (pseudocode):

DO NOT DO THIS:

case EBinary(op, left, right):
var transformerExpr = transform(left);
case EUnary(op, expr):
var transformerExpr2 = transform(expr);

DO THIS:

case EBinary(op, left, right):
var transformedExpr = transform(left);
case EUnary(op, expr):
var transformedExpr = transform(expr);

Follow rules in all AGENTS.md you find.

DO NOT EDIT ex files directly!! We're working on a compiler so editing ex files directly should be the exception and you should first ask / tell me why. Otherwise, it should be generated by compiling hx code via the haxe->elixir compiler pipeline.

> > > After each task, use the qa-sentinel to verify .claude/agents/qa-sentinel.md << THIS IS VERY IMPORTANT and shuld be encoded in each task!
> > > After each task, tell me how far we are from 1.0/todoapp working without erorrs/warnings/runtime errors. Show me the percentage progress.
> > > IMPORTANT: DO NOT GROW SOURCE FILeS THAT ARE > 2000 lines. If you have an opporuntity to improve the code by extracting/modularizing, then do it. This is a hard directive that you should follow and should be part
> > > of all tasks in shrimp.
> > > Report the status of todoapp to the user, is it working without errors/warnings/runtime errors? This is very important as it's our e2e test for the compiler.
> > > As already documented here, ALL tasks should be tracked, either as a subtask of a task (update task) or a complete task in shrimp. Nothing should be done without being tracked.

When debugging the phoenix app when it starts, you should start it in the background and use curl to check the html output. You should also pay attention to the shell output of phx.server. We shall not tolarate any warnings or errors there, either, they should all be tackled following the principles here.

Execution mode: if the task is a good plan go work on it, unless it nees to be updated (instructions above), then update and go back to working on it. Let's do it and bring us closer to the goal! Let the user knwow. If you're ready to execute, then start check the right task on shrimp and start executing it.

IMPORTANT: If you need to address bugs and test, for the feedback loop, use playwright MCP but first make sure to compile the code (haxe+elixir) and then start the phoenix server in the background. If a phoenix server is already running, kill it first, then start it again.

When using Playwright, make sure to test the todoapp properly, covering all the main flows. You should also check the console for errors/warnings and the network tab for failed requests. You should also check the output of the phoenix server in the terminal for any errors/warnings. If you find any, you should address them following the principles here. Ideally, we should have these flows described in the plan in shrimp so we can track them properly, if not, add them to your todo list and suggest a replan if needed.

AGAIN: RUN THE FUCKING SERVER IN THE **BACKGROUND** AS NOT TO BLOCK THE FUCKING AGENT.

AGAIN: DO NOT USE SLOPPY VAR NAMES LIKE q, sp, etc. USE DESCRIPTIVE VAR NAMES. DO NOT ADD INTEGER SUFFIXES TO VAR NAMES UNLESS ABSOLUTELY NECESSARY. USE THE SAME VAR NAME IF IT'S OVERRIDEN IN A CASE BLOCK, FOR EXAMPLE.

## qa

• Use scripts/qa-sentinel.sh with these guardrails so it never “hangs.”

Recommended workflow

- Always run from repo root and pick a unique port:
  - scripts/qa-sentinel.sh --app examples/todo-app --port 4045 --verbose
- Use verbose mode to surface progress and logs on every step (Haxe, mix, server start).
- If you need to reuse the server across steps, add --keep-alive:

  - scripts/qa-sentinel.sh --app examples/todo-app --port 4046 --verbose --keep-alive
  - The script prints PHX_PID and PORT; kill later with kill -TERM -<PGID> or kill <PHX_PID>.

  What the script does (and where to look)

- Haxe build → logs: /tmp/qa-haxe.log
- mix deps.get → /tmp/qa-mix-deps.log
- mix compile → /tmp/qa-mix-compile.log
- Phoenix server (background) → /tmp/qa-phx.log
- Readiness probe (30s total) tails logs live when --verbose is on.

  If it seems stuck

- Re-run with --verbose to tail readiness and watch where it stops:
  - Haxe build stalls → tail -n 200 /tmp/qa-haxe.log
  - mix compile stalls → tail -n 200 /tmp/qa-mix-compile.log
  - Server not ready → tail -n 200 /tmp/qa-phx.log
- Pick a new port if another process is binding it:
  - scripts/qa-sentinel.sh --app examples/todo-app --port 4050 --verbose
- If something else owns the port, the script tries to kill it. You can also do:

  - lsof -ti tcp:4050 | xargs -r kill -9 (or choose a different port)

  CI-safe usage

- Wrap with a hard timeout to avoid job stalls if your CI environment doesn’t honor script exits:
  - timeout 180s scripts/qa-sentinel.sh --app examples/todo-app --port 4045 --verbose
- For parallel jobs, assign disjoint ports per job (e.g., 4041+index).

  Teardown and cleanup

- By default, the script traps and kills the server; no manual action needed.
- If you ran --keep-alive, kill the server after tests:

  - kill -TERM -<PGID> (kills process group), then kill -KILL -<PGID> if needed
  - Or kill <PHX_PID> then ensure nothing is listening: lsof -ti tcp:<PORT> | xargs -r kill -9

  Pro tips

- If you only need to debug one step manually:
  - Haxe: npx -y haxe examples/todo-app/build-server.hxml
  - Elixir: MIX_ENV=dev mix compile
  - Start server: PORT=4045 MIX_ENV=dev mix phx.server (watch /tmp/qa-phx.log)
- The script auto-detects a different bound port in logs and switches to it for probes.

  Use --verbose by default; that’s your “don’t get stuck” switch.
