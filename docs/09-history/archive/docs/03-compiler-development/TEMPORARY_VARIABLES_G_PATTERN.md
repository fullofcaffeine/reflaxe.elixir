# Understanding Haxe's Temporary 'g' Variables

## Overview

When examining generated Elixir code, you'll frequently encounter variables named `g`, `g1`, `g2`, `_g`, etc. These are **NOT** created by the Reflaxe.Elixir compiler - they are generated by Haxe itself during its internal compilation process.

## Why These Variables Exist

### Haxe's Internal Transformation

When Haxe compiles certain expressions, especially switch expressions that return values, it creates temporary variables to ensure:
- **Evaluation order**: The expression is evaluated exactly once
- **Pattern matching**: A stable reference for complex patterns
- **Side effect prevention**: Avoids evaluating expressions multiple times
- **Optimization**: Enables various compiler optimizations

### Example Transformation

```haxe
// Original Haxe code written by developer:
var result = switch(TodoPubSub.parseMessage(msg)) {
    case Some(parsedMsg): handleMessage(parsedMsg);
    case None: defaultValue;
}

// Haxe internally transforms this to:
var _g = TodoPubSub.parseMessage(msg);  // Temporary variable
var result = switch(_g) {
    case Some(parsedMsg): handleMessage(parsedMsg);
    case None: defaultValue;
}

// Which generates Elixir:
g = TodoPubSub.parse_message(msg)
result = case (g) do
  {:some, parsed_msg} -> handle_message(parsed_msg)
  :none -> default_value
end
```

## The Naming Pattern

Haxe uses a consistent naming scheme for these temporaries:
- `g` - First temporary in a scope
- `g1`, `g2`, `g3`, ... - Additional temporaries when multiple are needed
- `_g` - Underscore variant (sometimes for values that might be unused)
- `_g1`, `_g2`, ... - Additional underscore variants

## Why We Don't Rename Them

### 1. No Original Name to Preserve
In many cases, there is no "original" variable name:
```haxe
// This expression has no variable name
switch(computeValue() + 42) {
    case x: ...
}
// Haxe must create a temporary to hold the result
```

### 2. Risk of Name Collisions
Renaming to "meaningful" names could conflict with user variables:
```haxe
// If we renamed 'g' to 'switch_target', it might conflict:
var switch_target = userValue;  // User's variable
var switch_target = ...;        // Our renamed temporary - COLLISION!
```

### 3. Haxe Ecosystem Expectations
- Other Haxe compilation passes may look for these patterns
- Haxe developers recognize 'g' as compiler-generated
- Tools and debuggers understand this convention

### 4. No Semantic Meaning
These variables are purely mechanical - they exist only to satisfy compilation requirements, not to convey meaning about the program logic.

## Implementation in Reflaxe.Elixir

### Detection Function
The compiler uses `ElixirASTBuilder.isTempPatternVarName()` to identify these variables:
```haxe
public static function isTempPatternVarName(name: String): Bool {
    // Checks for patterns: g, _g, g1, g2, _g1, _g2, etc.
}
```

### Critical Handling in ElixirASTPrinter
The printer must **always** generate assignments for these variables:
```elixir
# CORRECT - Variable defined before use
g = TodoPubSub.parse_message(msg)
case (g) do
  ...
end

# WRONG - Would cause "undefined variable 'g'" error
case (g) do  # Error: g is not defined!
  ...
end
```

## Common Issues and Solutions

### Issue: Undefined Variable 'g'
**Symptom**: Elixir compilation error "undefined variable 'g'"
**Cause**: The AST printer was skipping the assignment
**Solution**: Ensure EMatch nodes for temporary variables are always printed

### Issue: Redundant Self-Assignments
**Symptom**: Generated code like `x = x`
**Cause**: Over-eager assignment generation
**Solution**: Skip only true self-assignments, not temporary variables

## Best Practices

1. **Don't fight Haxe's compilation model** - Accept these temporaries as necessary
2. **Generate them correctly** - Always ensure proper initialization
3. **Consider adding comments** in generated code:
   ```elixir
   # Compiler-generated temporary for switch expression
   g = parse_message(msg)
   ```
4. **Test with complex expressions** - Nested switches often reveal issues

## Testing Temporary Variables

When testing the compiler, ensure:
1. Simple switch expressions generate correct temporaries
2. Nested switch expressions handle multiple temporaries (g, g1, g2)
3. Pattern matching preserves temporary variable initialization
4. No undefined variable errors in generated Elixir code

## Historical Context

This issue was discovered and fixed in September 2025 when TodoLive was generating undefined 'g' variables. The fix involved modifying ElixirASTPrinter to properly handle these Haxe-generated temporaries.

## References

- Haxe Compiler Internals Documentation
- `ElixirASTBuilder.isTempPatternVarName()` - Detection function
- `ElixirASTPrinter` EMatch case - Where assignments are generated
- Issue fix commit: [Reference to the fix commit]