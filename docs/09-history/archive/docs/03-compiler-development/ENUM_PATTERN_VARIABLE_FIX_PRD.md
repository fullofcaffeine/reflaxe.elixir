# Enum Pattern Variable Mapping Fix - Product Requirements Document

## Problem Statement

Pattern variables in enum switch cases (like `config` in `case Repo(config):`) are being incorrectly assigned from `g_array` instead of the extracted enum parameters (`g_param_0`). This causes undefined variable errors in generated Elixir code.

### Current Buggy Output
```elixir
case spec do
  1 -> g_param_0 = elem(spec, 1)  # Extraction happens correctly
  config = g_array                 # WRONG: should be config = g_param_0
  # ... rest of case body
end
```

### Expected Correct Output
```elixir
case spec do
  1 -> 
    g_param_0 = elem(spec, 1)      # Extraction
    config = g_param_0              # CORRECT: pattern variable uses extraction
    # ... rest of case body
end
```

## Root Cause Analysis

### The AST Flow

When Haxe compiles enum pattern matching, it generates a specific AST structure:

```
Original Haxe: case Repo(config): doSomething(config)

Haxe AST:
TSwitch(spec, [
  Case {
    values: [TEnumParameter(spec, Repo, 0)],  // Pattern match
    expr: TBinop(OpAssignOp,                   // UPDATED: Not TBlock!
      TLocal(temp_result),
      TConst(nil)
    )
  }
])
```

### The Compilation Problem

1. **TEnumParameter** compiles to: `g_param_0 = elem(spec, 1)` ✅
2. **TVar(config, TLocal(_g))** compiles to: `config = g_array` ❌

The issue: `TLocal(_g)` gets mapped to `g_array` through `currentFunctionParameterMap` which was set up for loop desugaring, not enum patterns.

### Critical Discovery: Context Loss Issue

**DEBUG FINDINGS (2024-08-29)**:
When compiling TLocal variables in enum switch cases:
```
[XRay VariableCompiler] currentSwitchCaseBody: false  ← PROBLEM!
[XRay VariableCompiler] enumExtractionVars: 18 items
[XRay VariableCompiler] variableIdMap[37621] = g_array
```

**The Context Loss Problem**:
1. `currentSwitchCaseBody` is set to the case body at PatternMatchingCompiler.hx:897
2. But when VariableCompiler processes TLocal nodes, `currentSwitchCaseBody` is **false**
3. This prevents the existing fix (lines 1385-1392 of VariableCompiler.hx) from activating
4. Result: `g` maps to `g_array` instead of `g_param_0`

**Why Context is Lost**:
- The compilation is NOT recursive - VariableCompiler is called AFTER PatternMatchingCompiler
- By the time VariableCompiler runs, the context has been cleared
- Setting `currentSwitchCaseBody = null` at line 1022 happens before nested compilation

### Why Previous Fixes Failed

1. **Context detection is unreliable** - `currentSwitchCaseBody` is false when needed
2. **Timing issues** - Context is set and cleared before variable compilation
3. **Non-recursive compilation** - VariableCompiler runs in a different phase
4. **Band-aid approaches** - Detecting and overriding instead of fixing the root cause

## Solution Design

### Core Principle: Direct Pattern Variable Mapping

Instead of trying to detect context and override mappings, we'll:
1. **Track pattern variables directly** when we see them in the AST
2. **Filter out redundant TVar expressions** that Haxe generates
3. **Inject correct assignments** using our tracked mappings

### Implementation Architecture

```
PatternMatchingCompiler
├── Detects pattern variables in case values
├── Tracks mapping: patternVar -> extractionVar
├── Filters redundant TVar from case body
└── Injects correct assignments at case start

VariableCompiler
└── Simplified - no more enum context detection needed

EnumIntrospectionCompiler  
└── Continues generating extractions as before
```

## Detailed Implementation Steps

### Step 1: Track Pattern Variables in PatternMatchingCompiler

In `compileStandardCase`, when processing case values:

```haxe
// Around line 850 in PatternMatchingCompiler.hx
for (value in caseData.values) {
    switch(value.expr) {
        case TEnumParameter(e, ef, index):
            // This is a pattern with extraction
            // Track that we need pattern variable at this index
            patternVars.set(index, getPatternVarName(ef, index));
            
            // Also track the extraction variable name
            var extractionVar = 'g_param_${index}';
            patternExtractionMap.set(patternVarName, extractionVar);
    }
}
```

### Step 2: Filter Redundant TVar Expressions

In `filterExpressionRecursive` (around line 1440):

```haxe
case TVar(tvar, expr) if (expr != null):
    switch(expr.expr) {
        case TLocal(v) if (v.name == "g" || v.name == "_g"):
            // This is a pattern variable assignment generated by Haxe
            // Check if we have a tracked pattern variable for this
            if (patternExtractionMap.exists(tvar.name)) {
                // Filter it out - we'll inject correct assignment
                return null;
            }
    }
```

### Step 3: Generate Correct Assignments

In case body compilation (around line 920):

```haxe
// Generate correct pattern variable assignments
var patternAssignments = [];
for (varName in patternExtractionMap.keys()) {
    var extractionVar = patternExtractionMap.get(varName);
    patternAssignments.push('${varName} = ${extractionVar}');
}

// Prepend to case body
if (patternAssignments.length > 0) {
    compiledBody = patternAssignments.join("\n") + "\n" + compiledBody;
}
```

### Step 4: Clean Up Redundant Code

Remove from VariableCompiler:
- Lines 1105-1163: Enum context detection in TVar compilation
- Lines 1384-1393: g_array override logic in compileVariableReference
- Lines 1414-1427: Enum context checking for g variables

Remove from EnumIntrospectionCompiler:
- Complex context checking that's no longer needed
- Duplicate mapping management

## Testing Plan

### 1. Primary Test: Todo-App
```bash
cd examples/todo-app
npx haxe build-server.hxml
# Check generated TypeSafeChildSpecTools.ex for correct pattern variables
mix compile --force
mix phx.server
```

### 2. Verify Generated Code
Check that `lib/elixir/otp/type_safe_child_spec_tools.ex` contains:
```elixir
1 -> g_param_0 = elem(spec, 1)
config = g_param_0  # NOT g_array
```

### 3. Regression Testing
```bash
npm test  # All tests must pass
```

## Success Criteria

1. ✅ Pattern variables use extracted parameters, not g_array
2. ✅ Todo-app compiles without undefined variable errors
3. ✅ Generated Elixir code is clean and idiomatic
4. ✅ No regressions in test suite
5. ✅ Simplified architecture with single source of truth

## Benefits of This Approach

1. **Root cause fix** - Not a band-aid or workaround
2. **Clean architecture** - Single place handles pattern variables
3. **Removes complexity** - Eliminates multiple context detection attempts
4. **Maintainable** - Clear separation of concerns
5. **Type safe** - Maintains strong typing throughout

## Files to Modify

1. `src/reflaxe/elixir/helpers/PatternMatchingCompiler.hx`
   - Add pattern variable tracking (lines 850-870)
   - Filter redundant TVar (lines 1440-1460)
   - Inject correct assignments (lines 920-950)

2. `src/reflaxe/elixir/helpers/VariableCompiler.hx`
   - Remove enum context detection (lines 1105-1163)
   - Remove g_array override logic (lines 1384-1427)

3. `src/reflaxe/elixir/helpers/EnumIntrospectionCompiler.hx`
   - Simplify by removing complex context checks

## Risk Assessment

**Low Risk**: This fix is targeted and doesn't affect loop compilation or other systems.

**Mitigation**: Extensive testing with todo-app and full test suite ensures no regressions.

## Timeline

1. Implementation: 1-2 hours
2. Testing: 30 minutes
3. Documentation updates: 30 minutes

Total: ~2-3 hours

---

*Document created: 2024*  
*Status: Ready for implementation*