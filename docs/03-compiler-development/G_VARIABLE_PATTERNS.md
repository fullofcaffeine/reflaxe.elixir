# Understanding `g` Variables in Haxe→Elixir Compilation

## Overview

The Haxe→Elixir compiler encounters various `g` variables during compilation. Understanding their origins, purposes, and proper handling is crucial for maintaining correct code generation, especially in pattern matching and array operations.

## Why Elixir Needs Special `g` Variable Handling

### The Fundamental Challenge: Immutability vs Imperative Desugaring

**This is unique to the Elixir compiler.** Other Reflaxe targets (C++, C#, Go) don't need this special handling because they support mutable variables and imperative programming naturally.

#### The Problem

Haxe generates imperative AST that assumes mutability:
```haxe
// Original Haxe
var filtered = myArray.filter(x -> x > 5);

// Haxe desugars to imperative code:
var g = [];        // Array accumulator
var g1 = 0;        // Loop counter
while (g1 < myArray.length) {
    if (myArray[g1] > 5) {
        g.push(item);  // ASSUMES MUTATION!
    }
    g1++;
}
```

But Elixir is immutable:
```elixir
# Can't do this in Elixir!
g = []           # Initial array
g = [item | g]   # ERROR - can't rebind in same scope!
```

#### Why Other Reflaxe Compilers Don't Need This

**C++ (Reflaxe.CPP)**:
```cpp
std::vector<int> g;     // Mutable array
g.push_back(item);      // Direct mutation works fine
```

**C# (Reflaxe.CSharp)**:
```csharp
var g = new List<int>();  // Mutable list
g.Add(item);              // No problem
```

**Go (Reflaxe.Go)**:
```go
g := []int{}
g = append(g, item)  // Can reassign variables
```

#### The Elixir Solution: Smart Variable Renaming

Since Elixir can't mutate or easily rebind variables, we rename them to avoid conflicts:

```elixir
# Instead of collision:
g = []        # Array accumulator
g = value     # Switch value (COLLISION!)

# We generate:
g_array = []  # Renamed for array operations
g = value     # Keep original for switch
```

This is a **pragmatic solution** while we develop more sophisticated functional transformations.

#### Future: Idiomatic Elixir Generation

The ideal solution would generate functional Elixir directly:
```elixir
# Instead of imperative loops with g_array
filtered = Enum.filter(my_array, fn x -> x > 5 end)

# Instead of g = getValue(); switch(g)
case get_value() do
  pattern1 -> result1
  pattern2 -> result2
end
```

## Origin of `g` Variables: Haxe's OCaml Compiler

### Where Do `g` Variables Come From?

**IMPORTANT**: The `g` variables are generated by **Haxe's OCaml compiler itself**, not by Reflaxe. This happens during Haxe's "typing phase" when high-level constructs are desugared into lower-level TypedExpr AST.

#### The Compilation Pipeline
```
array.filter(x -> x > 5)  [Haxe source]
    ↓ Haxe Parser
AST with filter call
    ↓ Haxe Typer (OCaml code)  ← CREATES 'g' VARIABLES
TypedExpr with TWhile loops and 'g' variables  
    ↓ Reflaxe.Elixir (our compiler)
Elixir code with renamed variables
```

### Can We Change Haxe's Behavior?

**No, we cannot directly change how Haxe generates `g` variables.** This behavior is hardcoded in Haxe's OCaml source code (specifically in `typing.ml` and related files). These are internal implementation details of how Haxe transforms functional operations into imperative loops.

### What We CAN Do

#### 1. Pattern Detection and Rewriting (Recommended)

Detect common desugared patterns and generate idiomatic Elixir:

```haxe
class ArrayPatternOptimizer {
    static function detectFilterPattern(expr: TypedExpr): Bool {
        // Detect: empty array + while loop + push calls
        return switch(expr) {
            case TBlock([
                TVar(g, TArrayDecl([])),
                TWhile(_, body)
            ]) if (containsPushToG(body)): true;
            case _: false;
        }
    }
    
    static function rewriteAsEnumFilter(expr: TypedExpr): String {
        // Generate: Enum.filter(array, fn x -> predicate end)
        return generateFunctionalFilter(extractPredicate(expr));
    }
}
```

#### 2. Build Macros (Advanced)

Intercept at macro time before desugaring:

```haxe
class FunctionalArrayMacro {
    public static macro function filter(array: ExprOf<Array<T>>, pred: ExprOf<T -> Bool>) {
        // Generate Enum.filter call directly
        return macro @:pos(Context.currentPos()) {
            untyped __elixir__('Enum.filter($array, $pred)');
        };
    }
}
```

#### 3. Work with the Haxe Team (Long-term)

Potential improvements to propose:
- Add metadata to control desugaring behavior
- Provide alternative AST generation for functional targets  
- Add a compiler flag for "functional desugaring mode"
- Generate unique variable names instead of reusing `g`

### Learning from Other Functional Haxe Targets

#### Haxe → OCaml
Faces similar challenges with immutability:
```ocaml
(* Generates recursive functions instead of loops *)
let rec filter_loop acc = function
  | [] -> List.rev acc
  | h::t -> if pred h then filter_loop (h::acc) t else filter_loop acc t
```

#### Hypothetical Haxe → F#
Would need to:
- Transform loops to recursive functions
- Use `List.filter` directly when detected
- Handle immutability constraints

#### Potential Haxe → Clojure  
Would require similar transformations:
```clojure
; Instead of imperative loop with 'g'
(filter #(> % 5) my-array)
```

### The Pattern Detection Approach

Instead of fighting Haxe's imperative desugaring, we should:

1. **Recognize patterns** - Filter, map, reduce, etc. have consistent desugared forms
2. **Generate idiomatic code** - Transform to Enum functions when detected
3. **Fall back gracefully** - Use variable renaming when patterns aren't recognized
4. **Document patterns** - Build a library of recognized transformations

```haxe
// In ElixirCompiler.hx
override function compileExpression(expr: TypedExpr): String {
    // Check for known patterns first
    if (ArrayPatternDetector.isFilterPattern(expr)) {
        return ArrayPatternDetector.compileAsEnumFilter(expr);
    }
    if (ArrayPatternDetector.isMapPattern(expr)) {
        return ArrayPatternDetector.compileAsEnumMap(expr);
    }
    // Fall back to regular compilation with variable renaming
    return super.compileExpression(expr);
}
```

### Why This Matters

Understanding that `g` variables come from Haxe itself, not Reflaxe, helps us:
- **Set realistic expectations** - We can't "fix" Haxe's desugaring
- **Focus on the right solutions** - Pattern detection vs trying to change Haxe
- **Collaborate effectively** - Know when to propose upstream changes
- **Design better abstractions** - Work with the patterns, not against them

**Key Insight**: The `g` variable generation is predictable and consistent. Instead of seeing it as a problem, we can use it as a reliable pattern to detect and transform into idiomatic Elixir code.

## The `g` Variable Family

### 1. Plain `g` Variable

**Origin**: Generated by the Haxe compiler during AST desugaring  
**Source**: Haxe's internal optimization passes  
**Purpose**: Temporary storage for intermediate values in expressions  

**When Generated**:
- Switch expression evaluation: `switch(func())` → `g = func(); switch(g)`
- Complex pattern matching scenarios
- Array method desugaring (map, filter, etc.)

**Example Transformation**:
```haxe
// Original Haxe code
switch(parseMessage(msg)) {
    case Some(parsedMsg): ...
}

// After Haxe desugaring
var g = parseMessage(msg);
switch(g) {
    case Some(parsedMsg): ...
}
```

**Elixir Output**:
```elixir
g = parse_message(msg)
case g do
  {:ok, parsed_msg} -> ...
end
```

### 2. `g_array` Variable

**Origin**: Created by Reflaxe.Elixir compiler (NOT Haxe)  
**Source**: `VariableCompiler.hx` lines 764-777  
**Purpose**: Disambiguate when `g` is used for both array accumulator AND loop counter  

**When Generated**:
- During array method desugaring when `g` would conflict
- When detecting `TArrayDecl([])` initialization for a `g` variable

**Problem It Solves**:
```haxe
// Haxe desugars array.filter() to:
var g = [];        // Array accumulator
var g = 0;         // Loop counter (COLLISION!)
```

**Solution**:
```elixir
g_array = []       # Array accumulator (renamed)
g_counter = 0      # Loop counter (renamed)
```

### 3. `g_param_0`, `g_param_1`, etc.

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 701-714  
**Purpose**: Store extracted enum constructor parameters  

**When Generated**:
- During `TEnumParameter` compilation
- When pattern matching extracts constructor arguments

**Example**:
```haxe
// Haxe pattern
case TodoCreated(todo): ...

// Generated extraction
g_param_0 = elem(parsed_msg, 1)  // Extract 'todo' parameter
todo = g_param_0                  // Assign to pattern variable
```

### 4. `g_counter` Variable  

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 782-783  
**Purpose**: Loop counter when `g` conflicts with array usage  

**When Generated**:
- When detecting `TConst(TInt(0))` initialization
- In desugared for/while loops

**Issue**: Sometimes incorrectly applied to enum handling contexts

### 5. `_g`, `_g2`, `_g3`, etc.

**Origin**: Generated by Haxe compiler  
**Source**: Haxe's pattern matching desugaring  
**Purpose**: Additional temporary variables for nested patterns  

**When Generated**:
- Nested switch expressions
- Multiple pattern extractions in same scope
- Complex pattern matching scenarios

## Understanding the Variable Mapping Code

### The Code in VariableCompiler.hx (lines 1318-1328)

```haxe
// SIMPLE FIX: If this is a 'g' variable and we have a mapping for it, use it
var originalName = getOriginalVarName(tvar);
if (originalName == "g" || originalName == "_g") {
    var nameMapping = compiler.currentFunctionParameterMap.get(originalName);
    if (nameMapping == "g_array") {
        return "g_array";
    }
}
```

**What This Does**: This code checks if a variable reference to `g` should be mapped to `g_array` based on context.

**Why It's Needed**: 
1. **Haxe reuses `g` for multiple purposes** - switches, arrays, loops
2. **Elixir can't rebind variables** in the same scope like imperative languages
3. **We must disambiguate** which `g` is being referenced

**The Mapping Process**:
1. When we detect `g` used for array initialization → map to `g_array`
2. When we detect `g` used for loop counter → map to `g_counter`  
3. When referencing `g` later → check mapping to use correct variable

**This is Elixir-specific** because other targets don't have immutability constraints that prevent variable reuse.

## Common Problems and Solutions

### Problem 1: Wrong Variable in Pattern Assignment

**Symptom**: `todo = g_array` instead of `todo = g_param_0`

**Root Cause**: Variable mapping confusion between contexts

**AST Flow**:
```
1. Outer: g = parseMessage(msg)          // g holds Option value
2. Mapped: g → g_array (for array ops)   // Mapping applied
3. Extract: g_param_0 = elem(parsed_msg, 1)  // Parameter extracted
4. Assign: todo = TLocal(g)              // Uses mapped g_array (WRONG!)
          todo = g_array                 // Should be g_param_0!
```

**Solution**: Track extraction context and use correct source variable

### Problem 2: Variable Name Collisions

**Symptom**: Same `g` used for different purposes

**Root Cause**: Haxe reuses variable names in desugared code

**Example**:
```elixir
# COLLISION: Both use 'g'
g = []           # Array accumulator
g = 0            # Loop counter
```

**Solution**: Rename based on usage context (g_array, g_counter)

### Problem 3: Orphaned Extractions

**Symptom**: `g_array = elem(action, 1)` generated but never used

**Root Cause**: Haxe generates TEnumParameter even for unused parameters

**Solution**: Detection via `-reflaxe.unused` metadata and suppression

## How to Debug `g` Variable Issues

### 1. Enable Debug Flags

```bash
npx haxe build.hxml \
  -D debug_variable_compiler \
  -D debug_pattern_matching \
  -D debug_enum_introspection_compiler
```

### 2. Trace Variable Flow

Look for patterns like:
```
[XRay VariableCompiler] Original name: g
[XRay VariableCompiler] Renamed to: g_array (array)
[XRay VariableCompiler] ENUM PARAMETER EXTRACTION DETECTED
[XRay VariableCompiler] Generated: g_param_0 = elem(...)
```

### 3. Check Variable Mappings

The compiler maintains several mappings:
- `variableIdMap`: TVar.id → Elixir name
- `currentFunctionParameterMap`: Original → Mapped name
- `enumExtractionVars`: Track extracted parameters
- `variableRenameMap`: Track collision renames

## Architectural Context

### Why These Variables Exist

1. **Haxe's Functional Approach**: Haxe desugars high-level constructs into simple imperative code
2. **Elixir's Immutability**: Variables can't be mutated, requiring different patterns
3. **Pattern Matching Differences**: Haxe and Elixir have different pattern matching semantics

### The Transformation Pipeline

```
Haxe Source
    ↓ (Haxe parser & typer)
TypedExpr AST with 'g' variables
    ↓ (Reflaxe.Elixir compiler)
Variable disambiguation & mapping
    ↓ (Code generation)
Elixir code with renamed variables
```

## Best Practices for Compiler Development

### 1. Always Check Context

Before renaming or mapping a `g` variable:
- Check if it's in enum extraction context
- Check if it's in array operation context  
- Check if it's in loop context

### 2. Preserve Semantic Meaning

- `g_array` clearly indicates array usage
- `g_param_N` clearly indicates parameter extraction
- `g_counter` clearly indicates loop counting

### 3. Document Variable Flows

When fixing variable-related bugs, add comments showing the flow:
```haxe
// Variable flow:
// 1. g = parseMessage(msg)     - Outer switch target
// 2. parsed_msg = elem(g, 1)   - Extract from Option
// 3. g_param_0 = elem(...)     - Extract parameter
// 4. todo = g_param_0          - Assign to pattern var
```

## Future Improvements

### 1. More Descriptive Names

Consider replacing generic `g` with semantic names:
- `switch_target` instead of `g`
- `extracted_param_0` instead of `g_param_0`
- `accumulator_array` instead of `g_array`

### 2. Context-Aware Variable Resolution

Implement a `VariableContext` system that:
- Tracks current compilation context
- Maintains separate namespaces for different uses
- Resolves variables based on usage context

### 3. Better Haxe Integration

Work with Haxe team to:
- Get more semantic variable names in desugared code
- Add metadata to indicate variable purpose
- Preserve more high-level intent in TypedExpr

## Related Files

- `src/reflaxe/elixir/helpers/VariableCompiler.hx` - Main variable compilation
- `src/reflaxe/elixir/helpers/PatternMatchingCompiler.hx` - Pattern extraction
- `src/reflaxe/elixir/helpers/EnumIntrospectionCompiler.hx` - Enum parameter handling
- `src/reflaxe/elixir/preprocessors/RemoveOrphanedEnumParametersImpl.hx` - Orphan detection

## See Also

- [AST Cleanup Patterns](AST_CLEANUP_PATTERNS.md)
- [Variable Mapping Implementation](VARIABLE_MAPPING_IMPLEMENTATION_STATUS.md)
- [Variable Substitution Patterns](variable-substitution-patterns.md)  
- [Compilation Flow](COMPILATION_FLOW.md)
- [Compiler Best Practices](COMPILER_BEST_PRACTICES.md)
