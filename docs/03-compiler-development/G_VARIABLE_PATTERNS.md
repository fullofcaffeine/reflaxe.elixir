# Understanding `g` Variables in Haxe→Elixir Compilation

## Overview

The Haxe→Elixir compiler encounters various `g` variables during compilation. Understanding their origins, purposes, and proper handling is crucial for maintaining correct code generation, especially in pattern matching and array operations.

## The `g` Variable Family

### 1. Plain `g` Variable

**Origin**: Generated by the Haxe compiler during AST desugaring  
**Source**: Haxe's internal optimization passes  
**Purpose**: Temporary storage for intermediate values in expressions  

**When Generated**:
- Switch expression evaluation: `switch(func())` → `g = func(); switch(g)`
- Complex pattern matching scenarios
- Array method desugaring (map, filter, etc.)

**Example Transformation**:
```haxe
// Original Haxe code
switch(parseMessage(msg)) {
    case Some(parsedMsg): ...
}

// After Haxe desugaring
var g = parseMessage(msg);
switch(g) {
    case Some(parsedMsg): ...
}
```

**Elixir Output**:
```elixir
g = parse_message(msg)
case g do
  {:ok, parsed_msg} -> ...
end
```

### 2. `g_array` Variable

**Origin**: Created by Reflaxe.Elixir compiler (NOT Haxe)  
**Source**: `VariableCompiler.hx` lines 764-777  
**Purpose**: Disambiguate when `g` is used for both array accumulator AND loop counter  

**When Generated**:
- During array method desugaring when `g` would conflict
- When detecting `TArrayDecl([])` initialization for a `g` variable

**Problem It Solves**:
```haxe
// Haxe desugars array.filter() to:
var g = [];        // Array accumulator
var g = 0;         // Loop counter (COLLISION!)
```

**Solution**:
```elixir
g_array = []       # Array accumulator (renamed)
g_counter = 0      # Loop counter (renamed)
```

### 3. `g_param_0`, `g_param_1`, etc.

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 701-714  
**Purpose**: Store extracted enum constructor parameters  

**When Generated**:
- During `TEnumParameter` compilation
- When pattern matching extracts constructor arguments

**Example**:
```haxe
// Haxe pattern
case TodoCreated(todo): ...

// Generated extraction
g_param_0 = elem(parsed_msg, 1)  // Extract 'todo' parameter
todo = g_param_0                  // Assign to pattern variable
```

### 4. `g_counter` Variable  

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 782-783  
**Purpose**: Loop counter when `g` conflicts with array usage  

**When Generated**:
- When detecting `TConst(TInt(0))` initialization
- In desugared for/while loops

**Issue**: Sometimes incorrectly applied to enum handling contexts

### 5. `_g`, `_g2`, `_g3`, etc.

**Origin**: Generated by Haxe compiler  
**Source**: Haxe's pattern matching desugaring  
**Purpose**: Additional temporary variables for nested patterns  

**When Generated**:
- Nested switch expressions
- Multiple pattern extractions in same scope
- Complex pattern matching scenarios

## Common Problems and Solutions

### Problem 1: Wrong Variable in Pattern Assignment

**Symptom**: `todo = g_array` instead of `todo = g_param_0`

**Root Cause**: Variable mapping confusion between contexts

**AST Flow**:
```
1. Outer: g = parseMessage(msg)          // g holds Option value
2. Mapped: g → g_array (for array ops)   // Mapping applied
3. Extract: g_param_0 = elem(parsed_msg, 1)  // Parameter extracted
4. Assign: todo = TLocal(g)              // Uses mapped g_array (WRONG!)
          todo = g_array                 // Should be g_param_0!
```

**Solution**: Track extraction context and use correct source variable

### Problem 2: Variable Name Collisions

**Symptom**: Same `g` used for different purposes

**Root Cause**: Haxe reuses variable names in desugared code

**Example**:
```elixir
# COLLISION: Both use 'g'
g = []           # Array accumulator
g = 0            # Loop counter
```

**Solution**: Rename based on usage context (g_array, g_counter)

### Problem 3: Orphaned Extractions

**Symptom**: `g_array = elem(action, 1)` generated but never used

**Root Cause**: Haxe generates TEnumParameter even for unused parameters

**Solution**: Detection via `-reflaxe.unused` metadata and suppression

## How to Debug `g` Variable Issues

### 1. Enable Debug Flags

```bash
npx haxe build.hxml \
  -D debug_variable_compiler \
  -D debug_pattern_matching \
  -D debug_enum_introspection_compiler
```

### 2. Trace Variable Flow

Look for patterns like:
```
[XRay VariableCompiler] Original name: g
[XRay VariableCompiler] Renamed to: g_array (array)
[XRay VariableCompiler] ENUM PARAMETER EXTRACTION DETECTED
[XRay VariableCompiler] Generated: g_param_0 = elem(...)
```

### 3. Check Variable Mappings

The compiler maintains several mappings:
- `variableIdMap`: TVar.id → Elixir name
- `currentFunctionParameterMap`: Original → Mapped name
- `enumExtractionVars`: Track extracted parameters
- `variableRenameMap`: Track collision renames

## Architectural Context

### Why These Variables Exist

1. **Haxe's Functional Approach**: Haxe desugars high-level constructs into simple imperative code
2. **Elixir's Immutability**: Variables can't be mutated, requiring different patterns
3. **Pattern Matching Differences**: Haxe and Elixir have different pattern matching semantics

### The Transformation Pipeline

```
Haxe Source
    ↓ (Haxe parser & typer)
TypedExpr AST with 'g' variables
    ↓ (Reflaxe.Elixir compiler)
Variable disambiguation & mapping
    ↓ (Code generation)
Elixir code with renamed variables
```

## Best Practices for Compiler Development

### 1. Always Check Context

Before renaming or mapping a `g` variable:
- Check if it's in enum extraction context
- Check if it's in array operation context  
- Check if it's in loop context

### 2. Preserve Semantic Meaning

- `g_array` clearly indicates array usage
- `g_param_N` clearly indicates parameter extraction
- `g_counter` clearly indicates loop counting

### 3. Document Variable Flows

When fixing variable-related bugs, add comments showing the flow:
```haxe
// Variable flow:
// 1. g = parseMessage(msg)     - Outer switch target
// 2. parsed_msg = elem(g, 1)   - Extract from Option
// 3. g_param_0 = elem(...)     - Extract parameter
// 4. todo = g_param_0          - Assign to pattern var
```

## Future Improvements

### 1. More Descriptive Names

Consider replacing generic `g` with semantic names:
- `switch_target` instead of `g`
- `extracted_param_0` instead of `g_param_0`
- `accumulator_array` instead of `g_array`

### 2. Context-Aware Variable Resolution

Implement a `VariableContext` system that:
- Tracks current compilation context
- Maintains separate namespaces for different uses
- Resolves variables based on usage context

### 3. Better Haxe Integration

Work with Haxe team to:
- Get more semantic variable names in desugared code
- Add metadata to indicate variable purpose
- Preserve more high-level intent in TypedExpr

## Related Files

- `src/reflaxe/elixir/helpers/VariableCompiler.hx` - Main variable compilation
- `src/reflaxe/elixir/helpers/PatternMatchingCompiler.hx` - Pattern extraction
- `src/reflaxe/elixir/helpers/EnumIntrospectionCompiler.hx` - Enum parameter handling
- `src/reflaxe/elixir/preprocessors/RemoveOrphanedEnumParametersImpl.hx` - Orphan detection

## See Also

- [Pattern Matching Compilation](PATTERN_MATCHING_PATTERNS.md)
- [AST Cleanup Patterns](AST_CLEANUP_PATTERNS.md)
- [Variable Mapping Architecture](../05-architecture/variable-mapping.md)