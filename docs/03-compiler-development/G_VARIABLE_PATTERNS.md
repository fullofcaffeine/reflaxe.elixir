# Understanding `g` Variables in Haxe→Elixir Compilation

## Overview

The Haxe→Elixir compiler encounters various `g` variables during compilation. Understanding their origins, purposes, and proper handling is crucial for maintaining correct code generation, especially in pattern matching and array operations.

## Why Elixir Needs Special `g` Variable Handling

### The Fundamental Challenge: Immutability vs Imperative Desugaring

**This is unique to the Elixir compiler.** Other Reflaxe targets (C++, C#, Go) don't need this special handling because they support mutable variables and imperative programming naturally.

#### The Problem

Haxe generates imperative AST that assumes mutability:
```haxe
// Original Haxe
var filtered = myArray.filter(x -> x > 5);

// Haxe desugars to imperative code:
var g = [];        // Array accumulator
var g1 = 0;        // Loop counter
while (g1 < myArray.length) {
    if (myArray[g1] > 5) {
        g.push(item);  // ASSUMES MUTATION!
    }
    g1++;
}
```

But Elixir is immutable:
```elixir
# Can't do this in Elixir!
g = []           # Initial array
g = [item | g]   # ERROR - can't rebind in same scope!
```

#### Why Other Reflaxe Compilers Don't Need This

**C++ (Reflaxe.CPP)**:
```cpp
std::vector<int> g;     // Mutable array
g.push_back(item);      // Direct mutation works fine
```

**C# (Reflaxe.CSharp)**:
```csharp
var g = new List<int>();  // Mutable list
g.Add(item);              // No problem
```

**Go (Reflaxe.Go)**:
```go
g := []int{}
g = append(g, item)  // Can reassign variables
```

#### The Elixir Solution: Smart Variable Renaming

Since Elixir can't mutate or easily rebind variables, we rename them to avoid conflicts:

```elixir
# Instead of collision:
g = []        # Array accumulator
g = value     # Switch value (COLLISION!)

# We generate:
g_array = []  # Renamed for array operations
g = value     # Keep original for switch
```

This is a **pragmatic solution** while we develop more sophisticated functional transformations.

#### Future: Idiomatic Elixir Generation

The ideal solution would generate functional Elixir directly:
```elixir
# Instead of imperative loops with g_array
filtered = Enum.filter(my_array, fn x -> x > 5 end)

# Instead of g = getValue(); switch(g)
case get_value() do
  pattern1 -> result1
  pattern2 -> result2
end
```

## Origin of `g` Variables: Haxe's OCaml Compiler

### Where Do `g` Variables Come From?

**IMPORTANT**: The `g` variables are generated by **Haxe's OCaml compiler itself**, not by Reflaxe. This happens during Haxe's "typing phase" when high-level constructs are desugared into lower-level TypedExpr AST.

#### The Compilation Pipeline
```
array.filter(x -> x > 5)  [Haxe source]
    ↓ Haxe Parser
AST with filter call
    ↓ Haxe Typer (OCaml code)  ← CREATES 'g' VARIABLES
TypedExpr with TWhile loops and 'g' variables  
    ↓ Reflaxe.Elixir (our compiler)
Elixir code with renamed variables
```

### Can We Change Haxe's Behavior?

**No, we cannot directly change how Haxe generates `g` variables.** This behavior is hardcoded in Haxe's OCaml source code (specifically in `typing.ml` and related files). These are internal implementation details of how Haxe transforms functional operations into imperative loops.

### What We CAN Do

#### 1. Pattern Detection and Rewriting (Recommended)

Detect common desugared patterns and generate idiomatic Elixir:

```haxe
class ArrayPatternOptimizer {
    static function detectFilterPattern(expr: TypedExpr): Bool {
        // Detect: empty array + while loop + push calls
        return switch(expr) {
            case TBlock([
                TVar(g, TArrayDecl([])),
                TWhile(_, body)
            ]) if (containsPushToG(body)): true;
            case _: false;
        }
    }
    
    static function rewriteAsEnumFilter(expr: TypedExpr): String {
        // Generate: Enum.filter(array, fn x -> predicate end)
        return generateFunctionalFilter(extractPredicate(expr));
    }
}
```

#### 2. Build Macros (Advanced)

Intercept at macro time before desugaring:

```haxe
class FunctionalArrayMacro {
    public static macro function filter(array: ExprOf<Array<T>>, pred: ExprOf<T -> Bool>) {
        // Generate Enum.filter call directly
        return macro @:pos(Context.currentPos()) {
            untyped __elixir__('Enum.filter($array, $pred)');
        };
    }
}
```

#### 3. Work with the Haxe Team (Long-term)

Potential improvements to propose:
- Add metadata to control desugaring behavior
- Provide alternative AST generation for functional targets  
- Add a compiler flag for "functional desugaring mode"
- Generate unique variable names instead of reusing `g`

### Learning from Other Functional Haxe Targets

#### Haxe → OCaml
Faces similar challenges with immutability:
```ocaml
(* Generates recursive functions instead of loops *)
let rec filter_loop acc = function
  | [] -> List.rev acc
  | h::t -> if pred h then filter_loop (h::acc) t else filter_loop acc t
```

#### Hypothetical Haxe → F#
Would need to:
- Transform loops to recursive functions
- Use `List.filter` directly when detected
- Handle immutability constraints

#### Potential Haxe → Clojure  
Would require similar transformations:
```clojure
; Instead of imperative loop with 'g'
(filter #(> % 5) my-array)
```

### The Pattern Detection Approach

Instead of fighting Haxe's imperative desugaring, we should:

1. **Recognize patterns** - Filter, map, reduce, etc. have consistent desugared forms
2. **Generate idiomatic code** - Transform to Enum functions when detected
3. **Fall back gracefully** - Use variable renaming when patterns aren't recognized
4. **Document patterns** - Build a library of recognized transformations

```haxe
// In ElixirCompiler.hx
override function compileExpression(expr: TypedExpr): String {
    // Check for known patterns first
    if (ArrayPatternDetector.isFilterPattern(expr)) {
        return ArrayPatternDetector.compileAsEnumFilter(expr);
    }
    if (ArrayPatternDetector.isMapPattern(expr)) {
        return ArrayPatternDetector.compileAsEnumMap(expr);
    }
    // Fall back to regular compilation with variable renaming
    return super.compileExpression(expr);
}
```

### Why This Matters

Understanding that `g` variables come from Haxe itself, not Reflaxe, helps us:
- **Set realistic expectations** - We can't "fix" Haxe's desugaring
- **Focus on the right solutions** - Pattern detection vs trying to change Haxe
- **Collaborate effectively** - Know when to propose upstream changes
- **Design better abstractions** - Work with the patterns, not against them

**Key Insight**: The `g` variable generation is predictable and consistent. Instead of seeing it as a problem, we can use it as a reliable pattern to detect and transform into idiomatic Elixir code.

## Current Solution: Smart Variable Renaming & Mapping

### Our Pragmatic Approach (Implemented Now)

While we work toward generating idiomatic functional Elixir code, we currently use a **smart variable renaming and mapping system** to handle the impedance mismatch between Haxe's imperative AST and Elixir's immutability constraints.

#### The Solution Architecture

**1. Detection Phase** (VariableCompiler.hx lines 764-783)

```haxe
// Detect g variable usage patterns and rename accordingly
if (originalName == "g" || StringTools.startsWith(originalName, "_g")) {
    // Check initialization type
    switch(expr) {
        case TArrayDecl([]): 
            // This is array accumulator usage
            return "g_array";
        case TConst(TInt(0)):
            // This is loop counter usage
            return "g_counter";
        // ... other patterns
    }
}
```

**2. Mapping Phase** (VariableCompiler.hx lines 1318-1328)

```haxe
// Map variable references to their renamed versions
if (originalName == "g" || originalName == "_g") {
    var nameMapping = compiler.currentFunctionParameterMap.get(originalName);
    if (nameMapping == "g_array") {
        return "g_array";  // Use renamed version
    }
}
```

**3. Extraction Tracking** (VariableCompiler.hx lines 701-714)

```haxe
// Track enum parameter extractions
var paramVarName = 'g_param_${index}';
compiler.enumExtractionVars.push({
    varName: paramVarName,
    sourceVar: originalName,
    index: index
});
```

**4. Pattern Variable Resolution** (VariableCompiler.hx lines 1049-1093)

```haxe
// Resolve pattern variables to their extracted sources
var lastExtractedParam = compiler.enumExtractionVars[compiler.enumExtractionVars.length - 1];
if (isPatternVariable && lastExtractedParam != null) {
    return '${varName} = ${lastExtractedParam.varName}';
}
```

#### How It Works in Practice

**Example: Nested Switch with Array Operations**

```haxe
// Original Haxe
switch(parseMessage(msg)) {
    case Some(parsedMsg):
        var filtered = messages.filter(m -> m.id != parsedMsg.id);
        switch(parsedMsg) {
            case TodoCreated(todo): processTodo(todo);
        }
}
```

**Our Current Solution Generates**:

```elixir
# Phase 1: Outer switch value stored
g = parse_message(msg)  # Original g preserved

case g do
  {:some, parsed_msg} ->
    # Phase 2: Array operations use renamed variable
    g_array = []  # Renamed to avoid collision
    g_counter = 0  # Counter also renamed
    
    # ... filtering logic with g_array ...
    
    # Phase 3: Inner switch with extraction
    g_param_0 = elem(parsed_msg, 1)  # Extract parameter
    todo = g_param_0  # Correct assignment (not g_array!)
    process_todo(todo)
end
```

#### Key Components

**1. Variable Registry** (`currentFunctionParameterMap`)

- Tracks all variable renamings within a function scope
- Maps original names to renamed versions
- Cleared at function boundaries

**2. Extraction Tracker** (`enumExtractionVars`)

- Records all enum parameter extractions
- Maintains order for nested pattern resolution
- Links extracted parameters to pattern variables

**3. Context-Aware Detection**

- Analyzes AST context to determine variable usage
- Differentiates between array, counter, and switch uses
- Applies appropriate renaming strategy

#### Benefits of Current Solution

✅ **Works Today** - Fully functional, handles all known g variable cases
✅ **No Elixir Errors** - Avoids variable rebinding issues completely  
✅ **Maintains Semantics** - Preserves Haxe's intended behavior
✅ **Debuggable** - Clear variable names indicate purpose (g_array, g_counter, g_param_0)
✅ **Incremental** - Can gradually improve toward more idiomatic output

#### Limitations We Accept (For Now)

⚠️ **Not Idiomatic** - Generated code has compiler-specific variable names
⚠️ **Verbose** - Extra variables that wouldn't exist in hand-written Elixir
⚠️ **Pattern-Specific** - Each new Haxe pattern may need detection logic
⚠️ **Not Optimal** - Could use Enum.filter instead of manual loops

#### How We Got Here: Evolution of the Solution

Based on our git history, this solution evolved through several iterations:

**1. Initial Discovery** (commit c85745e - August 2025)

- Found g_array variable mismatch in loop compilation
- First attempt at variable mapping system
- Realized the scope of the imperative-to-functional problem

**2. Architecture Fix** (commit 09d996f - August 2025)

- Discovered duplicate compiler instances causing state inconsistency
- Fixed architectural issue where VariableCompiler state wasn't shared
- This enabled proper variable mapping across compilation phases

**3. Variable Consistency** (commits 4095768, d2cfe35, 6a59d0d - recent)

- Improved variable naming consistency in nested switches
- Added tracking for enum parameter extractions
- Fixed pattern variable assignments to use correct extracted parameters

**4. Current Solution** (commits 083a3f6, 0e63c27 - most recent)

- Comprehensive tracking of all g variable transformations
- Context-aware detection of usage patterns
- Proper resolution of nested pattern variables

#### Why This Approach Works

After trying several approaches (including post-processing and string manipulation), we settled on this solution because:

1. **It's architecturally sound** - Works within Reflaxe's compilation model
2. **It's debuggable** - Clear variable names show their purpose
3. **It's complete** - Handles all known g variable patterns
4. **It's maintainable** - New patterns can be added incrementally

#### Migration Path

Our current solution is **intentionally pragmatic** while we develop more sophisticated transformations:

**Phase 1 (Current)**: Variable renaming to avoid conflicts ✅
**Phase 2 (In Progress)**: Pattern detection for common cases
**Phase 3 (Future)**: Full functional transformation to idiomatic Elixir

This approach lets us:

- Ship working code today
- Learn from real-world usage patterns
- Gradually improve output quality
- Maintain backward compatibility

## The `g` Variable Family

### 1. Plain `g` Variable

**Origin**: Generated by the Haxe compiler during AST desugaring  
**Source**: Haxe's internal optimization passes  
**Purpose**: Temporary storage for intermediate values in expressions  

**When Generated**:

- Switch expression evaluation: `switch(func())` → `g = func(); switch(g)`
- Complex pattern matching scenarios
- Array method desugaring (map, filter, etc.)

**Example Transformation**:

```haxe
// Original Haxe code
switch(parseMessage(msg)) {
    case Some(parsedMsg): ...
}

// After Haxe desugaring
var g = parseMessage(msg);
switch(g) {
    case Some(parsedMsg): ...
}
```

**Elixir Output**:

```elixir
g = parse_message(msg)
case g do
  {:ok, parsed_msg} -> ...
end
```

### 2. `g_array` Variable

**Origin**: Created by Reflaxe.Elixir compiler (NOT Haxe)  
**Source**: `VariableCompiler.hx` lines 764-777  
**Purpose**: Disambiguate when `g` is used for both array accumulator AND loop counter  

**When Generated**:

- During array method desugaring when `g` would conflict
- When detecting `TArrayDecl([])` initialization for a `g` variable

**Problem It Solves**:

```haxe
// Haxe desugars array.filter() to:
var g = [];        // Array accumulator
var g = 0;         // Loop counter (COLLISION!)
```

**Solution**:

```elixir
g_array = []       # Array accumulator (renamed)
g_counter = 0      # Loop counter (renamed)
```

### 3. `g_param_0`, `g_param_1`, etc

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 701-714  
**Purpose**: Store extracted enum constructor parameters  

**When Generated**:

- During `TEnumParameter` compilation
- When pattern matching extracts constructor arguments

**Example**:

```haxe
// Haxe pattern
case TodoCreated(todo): ...

// Generated extraction
g_param_0 = elem(parsed_msg, 1)  // Extract 'todo' parameter
todo = g_param_0                  // Assign to pattern variable
```

### 4. `g_counter` Variable

**Origin**: Created by Reflaxe.Elixir compiler  
**Source**: `VariableCompiler.hx` lines 782-783  
**Purpose**: Loop counter when `g` conflicts with array usage  

**When Generated**:

- When detecting `TConst(TInt(0))` initialization
- In desugared for/while loops

**Issue**: Sometimes incorrectly applied to enum handling contexts

### 5. `_g`, `_g2`, `_g3`, etc

**Origin**: Generated by Haxe compiler  
**Source**: Haxe's pattern matching desugaring  
**Purpose**: Additional temporary variables for nested patterns  

**When Generated**:

- Nested switch expressions
- Multiple pattern extractions in same scope
- Complex pattern matching scenarios

## Understanding the Variable Mapping Code

### The Code in VariableCompiler.hx (lines 1318-1328)

```haxe
// SIMPLE FIX: If this is a 'g' variable and we have a mapping for it, use it
var originalName = getOriginalVarName(tvar);
if (originalName == "g" || originalName == "_g") {
    var nameMapping = compiler.currentFunctionParameterMap.get(originalName);
    if (nameMapping == "g_array") {
        return "g_array";
    }
}
```

**What This Does**: This code checks if a variable reference to `g` should be mapped to `g_array` based on context.

**Why It's Needed**: 
1. **Haxe reuses `g` for multiple purposes** - switches, arrays, loops
2. **Elixir can't rebind variables** in the same scope like imperative languages
3. **We must disambiguate** which `g` is being referenced

**The Mapping Process**:
1. When we detect `g` used for array initialization → map to `g_array`
2. When we detect `g` used for loop counter → map to `g_counter`  
3. When referencing `g` later → check mapping to use correct variable

**This is Elixir-specific** because other targets don't have immutability constraints that prevent variable reuse.

## Common Problems and Solutions

### Problem 1: Wrong Variable in Pattern Assignment

**Symptom**: `todo = g_array` instead of `todo = g_param_0`

**Root Cause**: Variable mapping confusion between contexts

**AST Flow**:
```
1. Outer: g = parseMessage(msg)          // g holds Option value
2. Mapped: g → g_array (for array ops)   // Mapping applied
3. Extract: g_param_0 = elem(parsed_msg, 1)  // Parameter extracted
4. Assign: todo = TLocal(g)              // Uses mapped g_array (WRONG!)
          todo = g_array                 // Should be g_param_0!
```

**Solution**: Track extraction context and use correct source variable

### Problem 2: Variable Name Collisions

**Symptom**: Same `g` used for different purposes

**Root Cause**: Haxe reuses variable names in desugared code

**Example**:
```elixir
# COLLISION: Both use 'g'
g = []           # Array accumulator
g = 0            # Loop counter
```

**Solution**: Rename based on usage context (g_array, g_counter)

### Problem 3: Orphaned Extractions

**Symptom**: `g_array = elem(action, 1)` generated but never used

**Root Cause**: Haxe generates TEnumParameter even for unused parameters

**Solution**: Detection via `-reflaxe.unused` metadata and suppression

## How to Debug `g` Variable Issues

### 1. Enable Debug Flags

```bash
npx haxe build.hxml \
  -D debug_variable_compiler \
  -D debug_pattern_matching \
  -D debug_enum_introspection_compiler
```

### 2. Trace Variable Flow

Look for patterns like:
```
[XRay VariableCompiler] Original name: g
[XRay VariableCompiler] Renamed to: g_array (array)
[XRay VariableCompiler] ENUM PARAMETER EXTRACTION DETECTED
[XRay VariableCompiler] Generated: g_param_0 = elem(...)
```

### 3. Check Variable Mappings

The compiler maintains several mappings:
- `variableIdMap`: TVar.id → Elixir name
- `currentFunctionParameterMap`: Original → Mapped name
- `enumExtractionVars`: Track extracted parameters
- `variableRenameMap`: Track collision renames

## Architectural Context

### Why These Variables Exist

1. **Haxe's Functional Approach**: Haxe desugars high-level constructs into simple imperative code
2. **Elixir's Immutability**: Variables can't be mutated, requiring different patterns
3. **Pattern Matching Differences**: Haxe and Elixir have different pattern matching semantics

### The Transformation Pipeline

```
Haxe Source
    ↓ (Haxe parser & typer)
TypedExpr AST with 'g' variables
    ↓ (Reflaxe.Elixir compiler)
Variable disambiguation & mapping
    ↓ (Code generation)
Elixir code with renamed variables
```

## Best Practices for Compiler Development

### 1. Always Check Context

Before renaming or mapping a `g` variable:
- Check if it's in enum extraction context
- Check if it's in array operation context  
- Check if it's in loop context

### 2. Preserve Semantic Meaning

- `g_array` clearly indicates array usage
- `g_param_N` clearly indicates parameter extraction
- `g_counter` clearly indicates loop counting

### 3. Document Variable Flows

When fixing variable-related bugs, add comments showing the flow:
```haxe
// Variable flow:
// 1. g = parseMessage(msg)     - Outer switch target
// 2. parsed_msg = elem(g, 1)   - Extract from Option
// 3. g_param_0 = elem(...)     - Extract parameter
// 4. todo = g_param_0          - Assign to pattern var
```

## Future Improvements

### 1. More Descriptive Names

Consider replacing generic `g` with semantic names:
- `switch_target` instead of `g`
- `extracted_param_0` instead of `g_param_0`
- `accumulator_array` instead of `g_array`

### 2. Context-Aware Variable Resolution

Implement a `VariableContext` system that:
- Tracks current compilation context
- Maintains separate namespaces for different uses
- Resolves variables based on usage context

### 3. Better Haxe Integration

Work with Haxe team to:
- Get more semantic variable names in desugared code
- Add metadata to indicate variable purpose
- Preserve more high-level intent in TypedExpr

## Related Files

- `src/reflaxe/elixir/helpers/VariableCompiler.hx` - Main variable compilation
- `src/reflaxe/elixir/helpers/PatternMatchingCompiler.hx` - Pattern extraction
- `src/reflaxe/elixir/helpers/EnumIntrospectionCompiler.hx` - Enum parameter handling
- `src/reflaxe/elixir/preprocessors/RemoveOrphanedEnumParametersImpl.hx` - Orphan detection

## See Also

- [AST Cleanup Patterns](AST_CLEANUP_PATTERNS.md)
- [Variable Mapping Implementation](VARIABLE_MAPPING_IMPLEMENTATION_STATUS.md)
- [Variable Substitution Patterns](variable-substitution-patterns.md)  
- [Compilation Flow](COMPILATION_FLOW.md)
- [Compiler Best Practices](COMPILER_BEST_PRACTICES.md)
