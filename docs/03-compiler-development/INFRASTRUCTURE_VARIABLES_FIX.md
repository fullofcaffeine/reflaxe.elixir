# Infrastructure Variables Fix - TypedExprPreprocessor Implementation

## Problem Statement

Infrastructure variables (g, _g, g1, g2, etc.) were appearing in generated Elixir code, making it non-idiomatic. These variables are artifacts from Haxe's desugaring of high-level constructs like switch statements and for loops.

## Solution: TypedExprPreprocessor

### Implementation Status: PARTIAL SUCCESS ✅❌

Created `src/reflaxe/elixir/preprocessor/TypedExprPreprocessor.hx` that intercepts TypedExpr trees BEFORE AST building to eliminate infrastructure variables.

### What Works ✅

1. **Basic Switch Pattern Detection and Transformation**
   - Detects pattern: `TVar(_g, expr) + TSwitch(TLocal(_g))`
   - Transforms to: Direct `TSwitch(expr)` without intermediate variable
   - Successfully eliminates infrastructure variables from simple switch statements

2. **Variable Substitution**
   - Tracks infrastructure variables in substitution map
   - Replaces `TLocal(_g)` references with original expressions
   - Properly handles nested blocks and complex expressions

3. **Selective Processing**
   - Only processes functions containing infrastructure variable patterns
   - Uses `containsInfrastructurePattern()` to avoid unnecessary transformations
   - Pattern matches: `/^_?g[0-9]*$/` (g, _g, g1, g2, etc.)

### What Doesn't Work ❌

1. **AST-Level G Variable Generation**
   - ElixirASTBuilder still generates NEW g variables during AST construction
   - These aren't present in TypedExpr, so preprocessor can't eliminate them
   - Example: TBlock processing creates `EMatch(PVar(g), ...)` patterns

2. **TEnumParameter Orphaned Variables**
   - When extracting enum parameters, ElixirASTBuilder generates:
     ```elixir
     case {:todo_created, todo} ->
       g = todo  # Orphaned assignment
       %{type: "todo_created", todo: todo}
     ```
   - These g variables are created AFTER preprocessing, at AST building stage

3. **Complex Loop Patterns**
   - Some loop desugarings create infrastructure variables in ways the preprocessor doesn't detect
   - Would require more comprehensive pattern matching

## Architecture Analysis

### Why Preprocessing at TypedExpr Level Has Limitations

The compilation pipeline:
```
1. Haxe Parsing & Type Checking
2. TypedExpr Generation (Haxe's desugaring happens here)
3. TypedExprPreprocessor ← We intercept here
4. ElixirASTBuilder ← Creates NEW g variables here
5. ElixirAST Transformation
6. Code Printing
```

**Problem**: ElixirASTBuilder itself generates infrastructure variables during AST construction that weren't in the original TypedExpr. The preprocessor can't prevent this.

### Test Suite Impact

Running `npm test` shows many failures, but investigation reveals:
- Most failures are unrelated to infrastructure variables
- Issues include missing require_file statements, Log.trace vs IO.inspect differences
- The preprocessor isn't causing regressions, but also isn't fixing all g variable issues

## Recommendations

### Short Term
1. **Keep TypedExprPreprocessor** - It successfully handles basic switch patterns
2. **Document limitations** - Make it clear this is a partial solution
3. **Focus on AST-level fixes** - The real solution needs to be in ElixirASTBuilder

### Long Term
1. **Refactor ElixirASTBuilder** to avoid generating g variables in the first place:
   - Direct pattern matching instead of TEnumParameter extraction
   - Better TBlock handling to avoid intermediate variables
   - Context-aware variable naming

2. **Consider AST Transformation Pass** as alternative/supplement:
   - Post-process ElixirAST to remove orphaned g assignments
   - More surgical than preprocessing, can target specific patterns
   - Works on the actual generated AST, not TypedExpr

## Code Examples

### Successful Transformation
```haxe
// Haxe Input
var result = switch(msg.type) {
    case "test": msg.data;
    default: "unknown";
};

// Without Preprocessor (Non-idiomatic)
result = _g = msg.type
case (_g) do
  "test" -> msg.data
  _ -> "unknown"
end

// With Preprocessor (Idiomatic) ✅
result = case (msg.type) do
  "test" -> msg.data
  _ -> "unknown"
end
```

### Remaining Issue - TEnumParameter
```haxe
// Haxe Input
case TodoCreated(todo):
    return {type: "todo_created", todo: todo};

// Current Output (Still has orphaned g)
{:todo_created, todo} ->
  g = todo  # <-- Still generated by ElixirASTBuilder
  %{type: "todo_created", todo: todo}
```

## Files Modified

1. **Created**: `src/reflaxe/elixir/preprocessor/TypedExprPreprocessor.hx`
   - Complete implementation with documentation
   - Pattern detection and transformation logic

2. **Modified**: `src/reflaxe/elixir/ElixirCompiler.hx`
   - Line 1136: Added preprocessing before function compilation
   - Integrated preprocessor into compilation pipeline

3. **Modified**: `src/reflaxe/elixir/ast/ElixirASTTransformer.hx`
   - Removed fixEnumMapBodyPass (lines 4009-4219)
   - Cleaned up redundant infrastructure variable fixes

## Conclusion

The TypedExprPreprocessor is a valuable partial solution that improves code generation for basic switch patterns. However, a complete solution requires addressing infrastructure variable generation at the AST building level. The preprocessor serves as a good foundation and can be enhanced or supplemented with AST-level transformations in the future.