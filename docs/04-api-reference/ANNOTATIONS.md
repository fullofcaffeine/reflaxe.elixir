# Reflaxe.Elixir Annotations Reference

Complete guide to using annotations in Reflaxe.Elixir for generating Elixir/Phoenix code.

## Overview

Reflaxe.Elixir uses Haxe metadata annotations to control code generation. Annotations tell the compiler how to transform Haxe classes into specific Elixir modules and patterns.

## Supported Annotations

### @:controller - Phoenix Controller

Marks a class as a Phoenix controller for handling HTTP requests.

**Basic Usage**:
```haxe
import elixir.types.Term;

@:controller
class UserController {
    @:route({method: "GET", path: "/users"})
    public function index(): String {
        return "List all users";
    }
    
    @:route({method: "GET", path: "/users/:id"})
    public function show(id: Int): String {
        return "Show user " + id;
    }
    
    @:route({method: "POST", path: "/users"})
    public function create(user: Term): String {
        return "Create user";
    }
}
```

**Generated Elixir**:
```elixir
defmodule UserController do
  use Phoenix.Controller
  
  def index(conn) do
    conn
    |> put_status(200)
    |> json(%{message: "Action index executed"})
  end
  
  def show(conn, id) do
    conn
    |> put_status(200)
    |> json(%{message: "Action show executed"})
  end
  
  def create(conn, user) do
    conn
    |> put_status(200)
    |> json(%{message: "Action create executed"})
  end
end
```

**Route Annotations**:
- `@:route({method: "GET", path: "/path"})` - Define route with HTTP method and path
- `@:resources("resource_name")` - Generate RESTful resource routes
- `@:pipe_through([pipelines])` - Specify pipeline for authorization/plugs

### @:router - Phoenix Router Configuration

Marks a class as a Phoenix router for request routing.

**Basic Usage**:
```haxe
@:router
class AppRouter {
    @:pipeline("browser", ["fetch_session", "protect_from_forgery"])
    @:pipeline("api", ["accept_json"])
    
    @:include_controller("UserController")
    @:include_controller("ProductController")
}
```

**Generated Elixir**:
```elixir
defmodule AppRouter do
  use Phoenix.Router
  
  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end
  
  pipeline :api do
    plug :accepts, ["json"]
  end
  
  scope "/", AppRouter do
    pipe_through :browser
    
    resources "/users", UserController
    resources "/products", ProductController
  end
end
```

### @:schema - Ecto Schema Generation

Generates Ecto.Schema modules for database models.

**Basic Usage**:
```haxe
@:schema("users")
class User {
    @:primary_key
    public var id: Int;
    
    @:field({type: "string", nullable: false})
    public var name: String;
    
    @:field({type: "string", nullable: false})
    public var email: String;
    
    @:field({type: "integer"})
    public var age: Int;
    
    @:timestamps
    public var insertedAt: String;
    public var updatedAt: String;
}
```

**Generated Elixir**:
```elixir
defmodule User do
  use Ecto.Schema
  
  schema "users" do
    field :name, :string
    field :email, :string
    field :age, :integer
    
    timestamps()
  end
end
```

**Field Annotations**:
- `@:primary_key` - Primary key field
- `@:field({options})` - Regular field with options
- `@:timestamps` - Automatic timestamp fields
- `@:has_many(field, module, key)` - Has many association
- `@:belongs_to(field, module)` - Belongs to association

### @:changeset - Ecto Changeset Validation

Generates Ecto.Changeset modules for data validation.

Notes:

- The generated changeset uses **Ecto** `cast` + `validate_required` by default.
  - This `cast` is `Ecto.Changeset.cast/3` (or `/4`), not a Haxe type cast.
  - It’s the standard Ecto entry point for taking external params (often string-keyed / string values),
    whitelisting permitted fields, and casting them into the schema’s field types.

**Basic Usage**:
```haxe
import ecto.Changeset;

typedef UserParams = {
    ?name: String,
    ?email: String
}

@:native("MyApp.User")
@:schema("users")
@:timestamps
@:changeset(["name", "email"], ["name", "email"])
class User {
    @:field @:primary_key public var id: Int;
    @:field public var name: String;
    @:field public var email: String;

    // Auto-generated by the schema transformer; declare it so Haxe can call it.
    extern public static function changeset(user: User, params: UserParams): Changeset<User, UserParams>;
}
```

**Validation Annotations**:
- `@:validate_required([fields])` - Required field validation
- `@:validate_format(field, pattern)` - Format validation
- `@:validate_length(field, {min, max})` - Length validation
- `@:validate_number(field, {greater_than, less_than})` - Number validation
- `@:unique_constraint(field)` - Unique constraint validation

### @:liveview - Phoenix LiveView

Generates Phoenix LiveView modules for real-time UI.

**Basic Usage**:
```haxe
import elixir.types.Term;
import phoenix.LiveSocket;
import phoenix.Phoenix.HandleEventResult;
import phoenix.Phoenix.LiveView;
import phoenix.Phoenix.MountResult;
import phoenix.Phoenix.Socket;

typedef UserAssigns = { users: Array<User> }

@:liveview
class UserLive {
    public static function mount(_params: Term, _session: Term, socket: Socket<UserAssigns>): MountResult<UserAssigns> {
        var liveSocket: LiveSocket<UserAssigns> = cast socket;
        liveSocket = LiveView.assignMultiple(liveSocket, {users: []});
        return Ok(liveSocket);
    }
    
    @:native("handle_event")
    public static function handle_event(event: String, _params: Term, socket: Socket<UserAssigns>): HandleEventResult<UserAssigns> {
        return NoReply(socket);
    }
    
    public static function render(assigns: UserAssigns): String {
        return "<div>User LiveView</div>";
    }
}
```

**Generated Elixir**:
```elixir
defmodule UserLive do
  use Phoenix.LiveView
  
  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket}
  end
  
  @impl true
  def handle_event(event, params, socket) do
    {:noreply, socket}
  end
  
  @impl true
  def render(assigns) do
    ~H"""
    <div>User LiveView</div>
    """
  end
end
```

### @:presence - Phoenix Presence

Transforms a class into a Phoenix.Presence module for real-time presence tracking across distributed nodes.

**Purpose**: Phoenix Presence is a distributed presence tracking system that allows you to:
- Track who's online in real-time across multiple server nodes
- Synchronize user state (e.g., "typing", "editing", "idle") across all connected clients
- Handle node failures gracefully with CRDT-based conflict resolution
- Build collaborative features like "users currently viewing this page" or "users editing this document"

**How It Works**:
1. The `@:presence` annotation tells the compiler to inject `use Phoenix.Presence, otp_app: :your_app`
2. This enables the `track`, `untrack`, `update`, and `list` functions from Phoenix.Presence
3. Presence data is automatically synchronized across all nodes in your cluster
4. Each user gets a single presence entry with metadata you define

**Basic Usage**:
```haxe
@:native("TodoAppWeb.Presence")
@:presence
class TodoPresence {
    // Track a user coming online
    public static function trackUser<T>(socket: Socket<T>, user: User): Socket<T> {
        var meta = {
            onlineAt: Date.now().getTime(),
            userName: user.name,
            status: "active"
        };
        return Presence.track(socket, "users", Std.string(user.id), meta);
    }
    
    // Update user status (e.g., from "active" to "away")
    public static function updateUserStatus<T>(socket: Socket<T>, userId: Int, status: String): Socket<T> {
        var currentMeta = getUserPresence(socket, userId);
        if (currentMeta != null) {
            currentMeta.status = status;
            return Presence.update(socket, "users", Std.string(userId), currentMeta);
        }
        return socket;
    }
    
    // List all online users
    public static function listOnlineUsers<T>(socket: Socket<T>): Map<String, PresenceEntry> {
        return Presence.list(socket, "users");
    }
}
```

**Generated Elixir**:
```elixir
defmodule TodoAppWeb.Presence do
  use Phoenix.Presence, otp_app: :todo_app
  
  def track_user(socket, user) do
    meta = %{
      online_at: System.system_time(:millisecond),
      user_name: user.name,
      status: "active"
    }
    track(socket, "users", to_string(user.id), meta)
  end
  
  def update_user_status(socket, user_id, status) do
    current_meta = get_user_presence(socket, user_id)
    if current_meta do
      updated_meta = Map.put(current_meta, :status, status)
      update(socket, "users", to_string(user_id), updated_meta)
    else
      socket
    end
  end
  
  def list_online_users(socket) do
    list(socket, "users")
  end
end
```

**Common Use Cases**:
- **Online Users List**: Show who's currently online in a chat or collaboration app
- **Typing Indicators**: Show when someone is typing in real-time
- **Collaborative Editing**: Track who's editing which part of a document
- **Live Cursors**: Show other users' cursor positions in collaborative tools
- **User Status**: Display user status (active, away, busy) across the app

**Best Practices**:
1. **Single Presence Entry Per User**: Use one presence entry with all state, not multiple entries
2. **Update, Don't Track/Untrack**: Use `update` to change state instead of untrack/track cycles
3. **Minimal Metadata**: Keep presence metadata small for efficient synchronization
4. **Topic Organization**: Use meaningful topic names like "users", "document:123", etc.

### @:genserver - OTP GenServer

Generates OTP GenServer modules for stateful processes.

**Basic Usage**:
```haxe
import elixir.types.Term;
import elixir.types.GenServerCallbackResults.HandleCallResult;
import elixir.types.GenServerCallbackResults.InitResult;

@:genserver
class Counter {
    private var count: Int = 0;
    
    public static function init(_args: Term): InitResult<Int> {
        return Ok(0);
    }
    
    public static function handle_call(msg: String, _from: Term, state: Int): HandleCallResult<Int, Int> {
        return switch (msg) {
            case "get": Reply(state, state);
            case "increment": Reply(state + 1, state + 1);
            case _: Reply(state, state);
        };
    }
}
```

**Generated Elixir**:
```elixir
defmodule Counter do
  use GenServer
  
  def init(_args) do
    {:ok, 0}
  end
  
  def handle_call("get", _from, state) do
    {:reply, state, state}
  end
  
  def handle_call("increment", _from, state) do
    {:reply, state + 1, state + 1}
  end
  
  def handle_call(_, _from, state) do
    {:reply, "unknown", state}
  end
end
```

### @:migration - Ecto Migration (Experimental)

Marks a Haxe migration (built on `std/ecto/Migration.hx`) so the compiler can process it.

  > **Status (Experimental)**: Runnable via **opt-in `.exs` emission**.
  >
  > Ecto executes migrations from `priv/repo/migrations/*.exs`. Reflaxe.Elixir can emit runnable
  > migrations when you compile **only** your `@:migration` classes with:
  >
  > - `-D ecto_migrations_exs` (switch output extension to `.exs` + enable migration rewrite)
  > - `-D elixir_output=priv/repo/migrations`
  >
  > Each migration must declare a stable timestamp (used for the filename ordering):
  > `@:migration({timestamp: "YYYYMMDDHHMMSS"})`.

**Basic Usage**:
```haxe
import ecto.Migration;
import ecto.Migration.ColumnType;

  @:migration({timestamp: "20240101120000"})
  class CreateUsersTable extends Migration {
    public function new() {}

    public function up(): Void {
        createTable("users")
            .addId()
            .addColumn("name", ColumnType.String(), {nullable: false})
            .addColumn("email", ColumnType.String(), {nullable: false})
            .addColumn("age", ColumnType.Integer)
            .addTimestamps()
            .addIndex(["email"], {unique: true});
    }
    
    public function down(): Void {
        dropTable("users");
    }
}
```

### @:template - Phoenix Template

Generates Phoenix HEEx template modules.

**Basic Usage**:
```haxe
import phoenix.types.Assigns;

typedef CardAssigns = { user: User };

@:template
class UserTemplate {
    public function user_card(assigns: Assigns<CardAssigns>): String {
        return """
        <div class="user-card">
            <h3>{assigns.user.name}</h3>
            <p>{assigns.user.email}</p>
        </div>
        """;
    }
}
```

**Generated Elixir**:
```elixir
defmodule UserTemplate do
  use Phoenix.Component
  
  def user_card(assigns) do
    ~H"""
    <div class="user-card">
      <h3><%= @user.name %></h3>
      <p><%= @user.email %></p>
    </div>
    """
  end
end
```

### @:protocol - Elixir Protocol

Defines polymorphic behavior through protocols.

**Basic Usage**:
```haxe
import elixir.types.Term;

@:protocol
class Stringable {
    @:callback
    public function toString(data: Term): String {
        throw "Protocol function must be implemented";
    }
}
```

**Generated Elixir**:
```elixir
defprotocol Stringable do
  @doc "Convert data to string representation"
  def to_string(data)
end
```

### @:impl - Protocol Implementation

Implements a protocol for a specific type.

**Basic Usage**:
```haxe
@:impl("Stringable", "User")
class UserStringable {
    public function toString(user: User): String {
        return 'User: ${user.name}';
    }
}
```

**Generated Elixir**:
```elixir
defimpl Stringable, for: User do
  def to_string(user) do
    "User: #{user.name}"
  end
end
```

### @:behaviour - Elixir Behavior

Defines callback contracts for modules.

**Basic Usage**:
```haxe
import haxe.functional.Result;

typedef ProcessorConfig = { ?batchSize: Int }
typedef ProcessorState = { processedCount: Int }

@:behaviour
class DataProcessor {
    @:callback
    public function init(config: ProcessorConfig): Result<ProcessorState, String> {
        throw "Callback must be implemented";
    }
    
    @:callback
    public function process(data: elixir.types.Term): elixir.types.Term {
        throw "Callback must be implemented";
    }
    
    @:optional_callback
    public function cleanup(): Void {
        // Optional cleanup
    }
}
```

**Generated Elixir**:
```elixir
defmodule DataProcessor do
  @callback init(config :: any()) :: {:ok, any()} | {:error, String.t()}
  @callback process(data :: any()) :: any()
  
  @optional_callbacks cleanup: 0
  @callback cleanup() :: :ok
end
```

## Annotation Combinations

Some annotations can be used together:

- `@:schema` + `@:changeset` - Data model with validation
- `@:liveview` + `@:template` - LiveView with template rendering
- `@:controller` + `@:route` - Controller with route definitions
- `@:behaviour` + `@:genserver` - GenServer implementing behavior
- `@:application` + `@:appName` - OTP Application with configurable module names
- `@:appName` + Any annotation - App name configuration is compatible with all annotations

## Annotation Conflicts

The following combinations are mutually exclusive:

- `@:genserver` and `@:liveview` - Choose one behavior type
- `@:schema` and `@:migration` - Schema is runtime, migration is compile-time
- `@:protocol` and `@:behaviour` - Different polymorphism approaches

### @:application - OTP Application Module

Marks a class as an OTP Application module that defines a supervision tree.

**Basic Usage**:
```haxe
import elixir.Atom;
import elixir.types.Term;

@:application
@:native("MyApp.Application")
class MyApp {
    public static function start(type: Term, args: Term): Term {
        // Define children for supervision tree
        var children = [
            "MyApp.Repo",                              // Simple module reference
            {module: "Phoenix.PubSub", name: "MyApp.PubSub"}, // Tuple with options
            "MyAppWeb.Endpoint"                        // Simple module reference
        ];
        
        // Start supervisor with children
        var opts = {strategy: "one_for_one", name: "MyApp.Supervisor"};
        return Supervisor.startLink(children, opts);
    }
    
    public static function config_change(changed: Term, new_config: Term, removed: Term): Term {
        // Handle configuration changes
        return Atom.fromString("ok");
    }
}
```

**Generated Elixir**:
```elixir
defmodule MyApp.Application do
  @moduledoc false
  
  use Application
  
  @impl true
  def start(_type, _args) do
    children = [
      MyApp.Repo,
      {Phoenix.PubSub, name: MyApp.PubSub},
      MyAppWeb.Endpoint
    ]
    
    opts = [strategy: :one_for_one, name: MyApp.Supervisor]
    Supervisor.start_link(children, opts)
  end
  
  @impl true
  def config_change(changed, _new, removed) do
    MyAppWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end
```

**Key Features**:
- Automatically adds `use Application` directive
- Transforms child specifications into proper OTP format
- Handles Phoenix-specific modules (Repo, PubSub, Endpoint, Telemetry)
- Adds `@impl true` annotations for callbacks
- Supports config_change callback for hot reloading

**Child Specification Formats**:
- String module names become atoms: `"MyApp.Repo"` → `MyApp.Repo`
- Objects with module/name become tuples: `{module: "Phoenix.PubSub", name: "MyApp.PubSub"}` → `{Phoenix.PubSub, name: MyApp.PubSub}`
- Supervisor options converted to keyword lists

### @:elixirIdiomatic - Idiomatic Elixir Pattern Generation

Marks a user-defined enum to generate idiomatic Elixir patterns instead of literal patterns.

**Basic Usage**:
```haxe
@:elixirIdiomatic
enum UserOption<T> {
    Some(value: T);
    None;
}

@:elixirIdiomatic  
enum ApiResult<T, E> {
    Ok(value: T);
    Error(reason: E);
}
```

**Generated Elixir (with @:elixirIdiomatic)**:
```elixir
defmodule UserOption do
  @type t() ::
    {:ok, term()} |
    :error

  def some(arg0), do: {:ok, arg0}
  def none(), do: :error
end

defmodule ApiResult do
  @type t() ::
    {:ok, term()} |
    {:error, term()}

  def ok(arg0), do: {:ok, arg0}
  def error(arg0), do: {:error, arg0}
end
```

**Generated Elixir (without @:elixirIdiomatic)**:
```elixir
defmodule UserOption do
  @type t() ::
    {:some, term()} |
    :none

  def some(arg0), do: {:some, arg0}
  def none(), do: :none
end
```

**Key Differences**:
- **Idiomatic patterns**: `{:ok, value}` / `:error` (standard Elixir conventions)
- **Literal patterns**: `{:some, value}` / `:none` (direct translation from Haxe)

**When to Use @:elixirIdiomatic**:
- When integrating with Elixir libraries that expect standard `:ok` / `:error` patterns
- When building APIs that should follow BEAM ecosystem conventions
- When you want your Haxe enums to feel natural to Elixir developers

**Standard Library Behavior**:
Standard library types always use idiomatic patterns regardless of annotation:
- `haxe.ds.Option<T>` → Always generates `{:ok, value}` / `:error`
- `haxe.functional.Result<T,E>` → Always generates `{:ok, value}` / `{:error, reason}`

### @:using - Automatic Static Extensions

Automatically applies static extension methods to a type, making them globally available wherever the type is used.

**Basic Usage**:
```haxe
// Define extension methods
class ResultTools {
    public static function isOk<T, E>(result: Result<T, E>): Bool {
        return switch (result) {
            case Ok(_): true;
            case Error(_): false;
        }
    }
    
    public static function map<T, U, E>(result: Result<T, E>, transform: T -> U): Result<U, E> {
        return switch (result) {
            case Ok(value): Ok(transform(value));
            case Error(error): Error(error);
        }
    }
}

// Apply extensions automatically to the type
@:using(haxe.functional.Result.ResultTools)
enum Result<T, E> {
    Ok(value: T);
    Error(error: E);
}
```

**Usage Anywhere**:
```haxe
import haxe.functional.Result;

class UserService {
    static function validateUser(data: String): Result<User, String> {
        var result = parseUser(data);
        // Extensions automatically available - no 'using' needed
        if (result.isOk()) {
            return result.map(user -> enrichUser(user));
        }
        return result;
    }
}
```

**Comparison with `using` Keyword**:

| Pattern | Scope | Control | Maintenance |
|---------|-------|---------|-------------|
| **`@:using` metadata** | Global (automatic) | Set once on type | Low maintenance |
| **`using` keyword** | Per-file (explicit) | Manual per file | Higher maintenance |

**Example with `using` keyword**:
```haxe
// Without @:using metadata on Result type
import haxe.functional.Result;
import haxe.functional.ResultTools;
using haxe.functional.ResultTools; // Required in each file

class UserService {
    static function validateUser(data: String): Result<User, String> {
        var result = parseUser(data);
        return result.isOk() ? result.map(enrichUser) : result;
    }
}
```

**When to Use @:using**:
- **Core data types** (Option, Result, List) that always need their extension methods
- **Domain types** where extensions are fundamental to the type's usage
- **Library development** where you want extensions to be automatically available

**When to Use `using` Instead**:
- **Large projects** where explicit imports provide better clarity
- **Selective extension usage** where only some files need the extensions  
- **Testing environments** where you want precise control over available methods

**Real-World Examples**:
```haxe
// Haxe standard library pattern
@:using(haxe.ds.Option.OptionTools)
enum Option<T> {
    Some(value: T);
    None;
}

// Domain validation pattern
@:using(models.Email.EmailTools)
abstract Email(String) from String {
    public function new(value: String) this = value;
}

class EmailTools {
    public static function getDomain(email: Email): String {
        return email.toString().split("@")[1];
    }
    
    public static function isValidDomain(email: Email, domain: String): Bool {
        return email.getDomain().toLowerCase() == domain.toLowerCase();
    }
}
```

### @:repo - Ecto Repository Configuration

Configures an Ecto repository with typed database adapter settings and automatically generates companion modules.

**Purpose**: The `@:repo` annotation provides a type-safe way to configure Ecto repositories. It replaces the need for manual PostgrexTypes modules by automatically generating them based on the repository configuration.

**Basic Usage**:
```haxe
import ecto.DatabaseAdapter;

@:native("TodoApp.Repo")
@:repo({
    adapter: Postgres,
    json: Jason,
    extensions: [],
    poolSize: 10
})
extern class Repo {
    // Repository methods are provided by externs
}
```

**Generated Elixir (Repo module)**:
```elixir
defmodule TodoApp.Repo do
  use Ecto.Repo, otp_app: :todo_app, adapter: Ecto.Adapters.Postgres
end
```

**Generated Elixir (Companion PostgrexTypes module)**:
```elixir
:"Elixir.Postgrex.Types".define(TodoApp.PostgrexTypes, [], [{:json, Jason}])
```

**Configuration Options**:
```haxe
typedef RepoConfig = {
    var adapter: DatabaseAdapter;      // Required: Postgres, MySQL, SQLite3, etc.
    @:optional var json: JsonLibrary;  // Optional: Jason, Poison, None (default: Jason)
    @:optional var extensions: Array<PostgresExtension>; // Optional: PostgreSQL extensions
    @:optional var poolSize: Int;      // Optional: Connection pool size
}
```

**Supported Database Adapters**:
- `Postgres` - PostgreSQL via Ecto.Adapters.Postgres
- `MySQL` - MySQL via Ecto.Adapters.MyXQL
- `SQLite3` - SQLite via Ecto.Adapters.SQLite3
- `SQLServer` - SQL Server via Ecto.Adapters.Tds
- `InMemory` - In-memory adapter for testing

**JSON Libraries**:
- `Jason` - Fast JSON library (recommended)
- `Poison` - Alternative JSON library
- `None` - No JSON support

**PostgreSQL Extensions** (when using Postgres adapter):
- `HStore` - Key-value store
- `PostGIS` - Geographic objects
- `UUID` - UUID data type
- `LTREE` - Hierarchical tree-like data
- `Citext` - Case-insensitive text

**Key Features**:
- **Type-safe configuration**: Compile-time validation of adapter settings
- **Automatic PostgrexTypes generation**: No need for manual PostgrexTypes modules
- **Framework-agnostic**: Works with any Elixir application, not just Phoenix
- **Clean separation**: Repository configuration separate from implementation

**Why @:repo is Important**:
- **Eliminates boilerplate**: No more empty PostgrexTypes classes
- **Type safety**: Configuration errors caught at compile time
- **Convention over configuration**: Sensible defaults for common cases
- **Automatic wiring**: The compiler handles module generation and registration

**Migration from Manual Configuration**:

Before (manual PostgrexTypes):
```haxe
// Repo.hx
@:native("TodoApp.Repo")
extern class Repo {}

// PostgrexTypes.hx (code smell - empty class)
@:native("TodoApp.PostgrexTypes")
@:dbTypes({json: "Jason"})
class PostgrexTypes {}
```

After (typed @:repo):
```haxe
// Repo.hx only - PostgrexTypes generated automatically
@:native("TodoApp.Repo")
@:repo({
    adapter: Postgres,
    json: Jason
})
extern class Repo {}
```

### @:appName - Configurable Application Names

Configures the application name for Phoenix applications, enabling reusable code across different projects.

**Basic Usage**:
```haxe
import elixir.types.Term;

@:application
@:appName("BlogApp")
@:native("BlogApp.Application")
class BlogApp {
    public static function start(type: Term, args: Term): Term {
        var appName = getAppName(); // Returns "BlogApp"
        
        var children = [
            {
                id: '${appName}.Repo',
                start: {module: '${appName}.Repo', "function": "start_link", args: []}
            },
            {
                id: "Phoenix.PubSub",
                start: {
                    module: "Phoenix.PubSub", 
                    "function": "start_link",
                    args: [{name: '${appName}.PubSub'}]
                }
            },
            {
                id: '${appName}Web.Endpoint', 
                start: {module: '${appName}Web.Endpoint', "function": "start_link", args: []}
            }
        ];

        var opts = {strategy: "one_for_one", name: '${appName}.Supervisor'};
        return Supervisor.startLink(children, opts);
    }
}
```

**Generated Elixir**:
```elixir
defmodule BlogApp.Application do
  @moduledoc false
  
  use Application
  
  @impl true
  def start(_type, _args) do
    children = [
      %{id: "BlogApp.Repo", start: %{module: "BlogApp.Repo", function: "start_link", args: []}},
      %{id: "Phoenix.PubSub", start: %{module: "Phoenix.PubSub", function: "start_link", args: [%{name: "BlogApp.PubSub"}]}},
      %{id: "BlogAppWeb.Endpoint", start: %{module: "BlogAppWeb.Endpoint", function: "start_link", args: []}}
    ]
    
    opts = %{strategy: "one_for_one", name: "BlogApp.Supervisor"}
    Supervisor.start_link(children, opts)
  end
end
```

**Key Features**:
- **Dynamic Module Names**: Use `${appName}` string interpolation for configurable module references
- **Framework Compatibility**: Works with any Phoenix application naming convention
- **Compatible with All Annotations**: Can be combined with any other annotation type
- **Reusable Code**: Write once, use in multiple projects with different names
- **No Hardcoding**: Eliminates hardcoded "TodoApp" references in generated code

**Common Patterns**:
- PubSub modules: `'${appName}.PubSub'` → `"BlogApp.PubSub"`
- Web modules: `'${appName}Web.Endpoint'` → `"BlogAppWeb.Endpoint"`  
- Supervisor names: `'${appName}.Supervisor'` → `"BlogApp.Supervisor"`
- Repository modules: `'${appName}.Repo'` → `"BlogApp.Repo"`

**Why @:appName is Important**:
- Phoenix applications require app-specific module names (e.g., "BlogApp.PubSub", "ChatApp.PubSub")
- Without @:appName, all applications would hardcode "TodoApp" references
- Enables creating reusable Phoenix application templates
- Makes project renaming and rebranding straightforward

### @:exunit - ExUnit Test Module

Marks a class as an ExUnit test module for unit and integration testing.

**Purpose**: ExUnit is Elixir's built-in testing framework. The `@:exunit` annotation transforms your class into a proper ExUnit test module with all the testing capabilities.

**Basic Usage**:
```haxe
import exunit.TestCase;
import exunit.Assert.*;

@:exunit
class UserTest extends TestCase {
    @:test
    function testUserCreation(): Void {
        var user = new User("Alice", 30);
        assertEqual("Alice", user.name);
        assertEqual(30, user.age);
    }
    
    @:test
    function testUserValidation(): Void {
        var user = new User("", -5);
        assertFalse(user.isValid());
    }
}
```

**Generated Elixir**:
```elixir
defmodule UserTest do
  use ExUnit.Case
  
  test "user creation" do
    user = User.new("Alice", 30)
    assert user.name == "Alice"
    assert user.age == 30
  end
  
  test "user validation" do
    user = User.new("", -5)
    assert not user.is_valid()
  end
end
```

### ExUnit Test Annotations

These annotations work within `@:exunit` classes to provide full testing capabilities:

#### @:test - Mark Test Method

**Purpose**: Identifies a method as a test case that should be executed by ExUnit.

**How it works**: Test method names are automatically cleaned up:
- `testUserLogin` → `test "user login"`
- `testCreateOrder` → `test "create order"`
- `shouldValidateEmail` → `test "should validate email"`

```haxe
@:test
function testCalculation(): Void {
    assertEqual(4, 2 + 2);
}
```

#### @:describe - Group Related Tests

**Purpose**: Groups related tests together in describe blocks for better organization and readability.

**Why use it**: 
- Improves test output readability
- Allows running specific groups of tests
- Provides logical structure to test suites

```haxe
@:describe("User validation")
@:test
function testEmailFormat(): Void {
    assertTrue(User.isValidEmail("test@example.com"));
    assertFalse(User.isValidEmail("invalid-email"));
}

@:describe("User validation")
@:test
function testAgeRange(): Void {
    assertTrue(User.isValidAge(25));
    assertFalse(User.isValidAge(-1));
}
```

Generates:
```elixir
describe "User validation" do
  test "email format" do
    assert User.is_valid_email("test@example.com")
    assert not User.is_valid_email("invalid-email")
  end
  
  test "age range" do
    assert User.is_valid_age(25)
    assert not User.is_valid_age(-1)
  end
end
```

#### @:async - Run Tests Asynchronously

**Purpose**: Marks tests to run concurrently with other async tests for faster test execution.

**When to use**: For tests that don't share state or resources and can safely run in parallel.

```haxe
@:async
@:test
function testIndependentCalculation(): Void {
    var result = complexCalculation();
    assertNotNull(result);
}
```

**Note**: If any test in a module is marked `@:async`, the entire module becomes async: `use ExUnit.Case, async: true`

#### @:tag - Tag Tests for Selective Execution

**Purpose**: Tags tests for conditional execution, allowing you to include or exclude specific tests.

**Common uses**:
- Skip slow tests in CI: `@:tag("slow")`
- Mark integration tests: `@:tag("integration")`
- Flag external dependencies: `@:tag("external")`
- Multiple tags supported: `@:tag("slow") @:tag("database")`

```haxe
@:tag("slow")
@:test
function testDatabaseMigration(): Void {
    Database.runMigrations();
    assertTrue(Database.isReady());
}

@:tag("integration")
@:tag("external")
@:test
function testThirdPartyAPI(): Void {
    var response = ExternalAPI.fetch();
    assertNotNull(response);
}
```

Run with tags:
```bash
mix test --only slow           # Run only slow tests
mix test --exclude integration # Skip integration tests
mix test --only tag:external   # Run only external tests
```

#### @:setup - Run Before Each Test

**Purpose**: Executes setup code before each test in the module to ensure clean state.

```haxe
@:setup
function prepareDatabase(): Void {
    Database.beginTransaction();
    insertTestData();
}
```

#### @:setupAll - Run Once Before All Tests

**Purpose**: Executes expensive one-time setup before any tests in the module run.

```haxe
@:setupAll
function startServices(): Void {
    TestServer.start();
    Database.createTestDatabase();
}
```

#### @:teardown - Run After Each Test

**Purpose**: Executes cleanup code after each test to prevent test interference.

```haxe
@:teardown
function cleanupDatabase(): Void {
    Database.rollbackTransaction();
    clearTempFiles();
}
```

#### @:teardownAll - Run Once After All Tests

**Purpose**: Executes final cleanup after all tests in the module complete.

```haxe
@:teardownAll
function stopServices(): Void {
    TestServer.stop();
    Database.dropTestDatabase();
}
```

**Complete ExUnit Example**:
```haxe
@:exunit
class TodoTest extends TestCase {
    @:setupAll
    function startApp(): Void {
        TodoApp.start();
    }
    
    @:setup
    function beginTransaction(): Void {
        Database.beginTransaction();
    }
    
    @:describe("Todo CRUD")
    @:test
    function testCreateTodo(): Void {
        var todo = Todo.create("Buy milk");
        assertNotNull(todo.id);
    }
    
    @:describe("Todo CRUD")
    @:async
    @:test
    function testUpdateTodo(): Void {
        var todo = Todo.create("Buy milk");
        todo.update({completed: true});
        assertTrue(todo.completed);
    }
    
    @:tag("slow")
    @:test
    function testBulkImport(): Void {
        var todos = Todo.bulkImport(largeDataset);
        assertEqual(10000, todos.length);
    }
    
    @:teardown
    function rollback(): Void {
        Database.rollbackTransaction();
    }
    
    @:teardownAll
    function stopApp(): Void {
        TodoApp.stop();
    }
}
```

## Usage Guidelines

1. **One primary annotation per class** - Choose the main purpose of your class
2. **Use compatible combinations** - Leverage synergistic annotations together
3. **Avoid conflicts** - The compiler will error on incompatible combinations
4. **Follow conventions** - Use standard Phoenix/Ecto patterns for better integration

For more examples, see the `examples/` directory in the project repository.
