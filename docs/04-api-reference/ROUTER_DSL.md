# Router DSL Documentation

## Overview

Reflaxe.Elixir provides two approaches for defining Phoenix router routes:

1. **Manual Functions** (Legacy) - Manually write empty functions with `@:route` annotations
2. **Declarative Arrays** (Modern) - Use `@:routes` array with auto-generated functions via build macro

## Modern Declarative Syntax (Recommended)

### Type-Safe Syntax (Preferred)

```haxe
import reflaxe.elixir.macros.HttpMethod;

@:native("TodoAppWeb.Router")  // Phoenix module convention
@:router
@:build(reflaxe.elixir.macros.RouterBuildMacro.generateRoutes())
@:routes([
    {name: "root", method: HttpMethod.LIVE, path: "/", controller: server.live.TodoLive, action: server.live.TodoLive.index},
    {name: "todosIndex", method: HttpMethod.LIVE, path: "/todos", controller: server.live.TodoLive, action: server.live.TodoLive.index},
    {name: "todosShow", method: HttpMethod.LIVE, path: "/todos/:id", controller: server.live.TodoLive, action: server.live.TodoLive.show},
    {name: "apiUsers", method: HttpMethod.GET, path: "/api/users", controller: controllers.UserController, action: controllers.UserController.index},
    {name: "createUser", method: HttpMethod.POST, path: "/api/users", controller: controllers.UserController, action: controllers.UserController.create},
    {name: "dashboard", method: HttpMethod.LIVE_DASHBOARD, path: "/dev/dashboard"}
])
class TodoAppRouter {
    // Functions are auto-generated by RouterBuildMacro
    // Generates: lib/todo_app_web/router.ex with module TodoAppWeb.Router
    // Type-safe controller/action refs enable compile-time validation!
}
```

**Module Naming**: Use @:native for Phoenix conventions. Prefer controller/action type refs for compile-time validation; string literals remain supported for routing to external Elixir modules.

### Basic String Syntax (Legacy Support)

```haxe
@:native("TodoAppWeb.Router")  // Phoenix module convention
@:router
@:build(reflaxe.elixir.macros.RouterBuildMacro.generateRoutes())
@:routes([
    {name: "root", method: "LIVE", path: "/", controller: "server.live.TodoLive", action: "index"},
    {name: "todosIndex", method: "LIVE", path: "/todos", controller: "server.live.TodoLive", action: "index"},
    {name: "todosShow", method: "LIVE", path: "/todos/:id", controller: "server.live.TodoLive", action: "show"},
    {name: "apiUsers", method: "GET", path: "/api/users", controller: "controllers.UserController", action: "index"},
    {name: "createUser", method: "POST", path: "/api/users", controller: "controllers.UserController", action: "create"},
    {name: "dashboard", method: "LIVE_DASHBOARD", path: "/dev/dashboard"}
])
class TodoAppRouter {
    // Functions are auto-generated by RouterBuildMacro
    // String literals still supported but HttpMethod enum preferred
}
```

### Generated Functions

The RouterBuildMacro automatically generates functions like:

```haxe
@:route({method: "LIVE", path: "/", controller: "TodoLive", action: "index"})
public static function root(): String { 
    return "/"; 
}

@:route({method: "LIVE", path: "/todos", controller: "TodoLive", action: "index"})
public static function todosIndex(): String { 
    return "/todos"; 
}
```

### Why Generated Functions Are Needed

The generated functions serve several critical purposes:

#### 1. Type-Safe Route Helpers
Generated functions return the path as a String, enabling compile-time route construction and refactoring safety:

```haxe
var homePath = TodoAppRouter.root();      // "/"
var todoPath = TodoAppRouter.todosShow(); // "/todos/:id"
```

```haxe
// Type-safe route building
var homePath = TodoAppRouter.root();           // returns "/"
var todoPath = TodoAppRouter.todosShow();      // returns "/todos/:id"
var userPath = TodoAppRouter.apiUsers();       // returns "/api/users"

// Use in redirects, links, etc.
Phoenix.redirect(socket, to: TodoAppRouter.todosIndex());
```

#### 2. IDE Code Completion and IntelliSense
Real Haxe functions provide:
- **Autocomplete** - Functions appear in IDE suggestions
- **Type checking** - Return types are enforced  
- **Documentation** - Hover info and parameter details
- **Go-to-definition** - Navigation support
- **Refactoring** - Rename functions updates all references

#### 3. Compile-Time Validation
Functions enable the Haxe compiler to:
- **Detect typos** - Unknown route names cause compilation errors
- **Validate usage** - Ensure routes are called correctly
- **Type safety** - Prevent passing wrong argument types

> Note: Router emission is driven by `@:routes` metadata on `@:router` modules (AST pipeline). The build macro exists for helpers + validation.

### Generated Phoenix Router

The compiler reads `@:routes` metadata and generates Phoenix routes:

```elixir
defmodule TodoAppWeb.Router do
  use TodoAppWeb, :router
  
  scope "/", TodoAppWeb do
    pipe_through :browser
    
    live "/", TodoLive, :root
    live "/todos", TodoLive, :todosIndex  
    live "/todos/:id", TodoLive, :todosShow
    get "/api/users", UserController, :apiUsers
    post "/api/users", UserController, :createUser
  end
  
  # LiveDashboard routes
  if Application.compile_env(:todo_app, :dev_routes) do
    import Phoenix.LiveDashboard.Router
    scope "/dev" do
      pipe_through :browser
      live_dashboard "/dev/dashboard"
    end
  end
end
```

## Route Definition Fields

### Required Fields

- **`name`** (String) - Function name to generate
- **`method`** (String) - HTTP method or Phoenix macro
- **`path`** (String) - URL path pattern

### Optional Fields  

- **`controller`** (String) - Target controller/LiveView module
- **`action`** (String) - Action method name  
- **`pipeline`** (String) - Pipeline to use (future enhancement)

### Supported Methods

#### Type-Safe HttpMethod Enum (Recommended)

- **`HttpMethod.GET`**, **`HttpMethod.POST`**, **`HttpMethod.PUT`**, **`HttpMethod.DELETE`**, **`HttpMethod.PATCH`** - Standard HTTP methods
- **`HttpMethod.LIVE`** - Phoenix LiveView routes (`live`)
- **`HttpMethod.LIVE_DASHBOARD`** - LiveDashboard routes (special handling)

#### String Literals (Legacy Support)

- **`"GET"`**, **`"POST"`**, **`"PUT"`**, **`"DELETE"`**, **`"PATCH"`** - Standard HTTP methods
- **`"LIVE"`** - Phoenix LiveView routes (`live`)
- **`"LIVE_DASHBOARD"`** - LiveDashboard routes (special handling)

## Type Safety Benefits

### ✅ Advantages of HttpMethod Enum

1. **Compile-Time Validation** - Typos in method names cause compilation errors
2. **IDE Autocomplete** - IntelliSense suggests valid method options
3. **Refactoring Safety** - Renaming enum values updates all references
4. **No Runtime Errors** - Invalid methods caught at compile-time
5. **Type Documentation** - Method options are self-documenting

### ❌ Problems with String Literals

1. **Runtime Errors** - Typos only discovered when Phoenix tries to route
2. **No Autocomplete** - IDE can't suggest valid method names
3. **Refactoring Fragility** - Search/replace required for method changes
4. **Magic Strings** - Method names are disconnected from type system
5. **Documentation Drift** - No single source of truth for valid methods

### Comparison Example

```haxe
// Type-Safe (Recommended)
{name: "users", method: HttpMethod.GET, path: "/users"}  // ✅ Compile-time validation
{name: "users", method: HttpMethod.GTE, path: "/users"}  // ❌ Compilation error: HttpMethod.GTE doesn't exist

// String Literals (Discouraged)  
{name: "users", method: "GET", path: "/users"}           // ✅ Compiles but no validation
{name: "users", method: "GTE", path: "/users"}           // ✅ Compiles but runtime error
```

## Legacy Manual Syntax (Discouraged)

```haxe
@:router  
class TodoAppRouter {
    @:route({method: "LIVE", path: "/", controller: "TodoLive", action: "index"})
    public static function root(): Void {}  // Empty placeholder function
    
    @:route({method: "LIVE", path: "/todos", controller: "TodoLive", action: "index"})
    public static function todosIndex(): Void {}  // Empty placeholder function
}
```

### Problems with Manual Syntax

1. **Empty Functions** - Serve no runtime purpose, just metadata carriers
2. **IDE Noise** - Clutters code completion with meaningless functions
3. **Maintenance Overhead** - Must manually keep functions and routes in sync
4. **Type Safety Loss** - No compile-time route helper generation

## Migration Guide

### Step 1: Add Build Macro

Add the build macro annotation to your router class:

```haxe
@:build(reflaxe.elixir.macros.RouterBuildMacro.generateRoutes())
```

### Step 2: Convert Functions to Array

Transform your manual functions:

```haxe
// FROM: Manual functions
@:route({method: "LIVE", path: "/", controller: "TodoLive", action: "index"})  
public static function root(): Void {}

@:route({method: "GET", path: "/api/users", controller: "UserController", action: "index"})
public static function apiUsers(): Void {}

// TO: Declarative array
@:routes([
    {name: "root", method: "LIVE", path: "/", controller: "TodoLive", action: "index"},
    {name: "apiUsers", method: "GET", path: "/api/users", controller: "UserController", action: "index"}
])
```

### Step 3: Remove Manual Functions

Delete all the empty function implementations - the build macro will generate them automatically.

### Step 4: Test Compilation

Verify the generated routes are identical:

```bash
haxe build.hxml
# Check generated router.ex matches expected Phoenix routes
```

## Advanced Features

### Type-Safe Route Helpers

Generated functions return the path as a String, enabling type-safe route construction:

```haxe
var homePath = TodoAppRouter.root();        // returns "/"
var usersPath = TodoAppRouter.todosIndex(); // returns "/todos"
```

### Validation

The RouterBuildMacro performs compile-time validation:

- **Duplicate Names** - Prevents function name conflicts
- **Missing Fields** - Ensures required fields are present
- **Invalid Methods** - Warns about unknown HTTP methods
- **Duplicate Paths** - Warns about conflicting route definitions
- **Controller/Action Existence (Typed Refs Only)** - When `controller` is a type ref (not a string literal), validates the controller type and that the action exists as a static method.

### IDE Integration

The build macro generates real Haxe functions with proper signatures, providing:

- **Code Completion** - Generated functions appear in IDE autocomplete
- **Type Checking** - Return types are enforced (String for route helpers)
- **Documentation** - Auto-generated doc comments for each route function

## RouterBuildMacro Implementation

The build macro (`src/reflaxe/elixir/macros/RouterBuildMacro.hx`) operates at compile-time:

1. **Parse** `@:routes` annotation from class metadata
2. **Validate** route definitions for errors and conflicts  
3. **Generate** function fields with proper `@:route` metadata
4. **Return** enhanced field list to Haxe compiler

Phoenix router emission is produced from `@:routes` metadata during compilation (see `AnnotationTransforms.routerTransformPass`).

## Best Practices

### Route Organization

```haxe
@:routes([
    // Public pages
    {name: "home", method: "LIVE", path: "/", controller: "PageLive", action: "index"},
    {name: "about", method: "LIVE", path: "/about", controller: "PageLive", action: "about"},
    
    // Todo management
    {name: "todosIndex", method: "LIVE", path: "/todos", controller: "TodoLive", action: "index"},
    {name: "todosShow", method: "LIVE", path: "/todos/:id", controller: "TodoLive", action: "show"},
    {name: "todosEdit", method: "LIVE", path: "/todos/:id/edit", controller: "TodoLive", action: "edit"},
    
    // API endpoints
    {name: "apiTodos", method: "GET", path: "/api/todos", controller: "TodoController", action: "index"},
    {name: "apiCreateTodo", method: "POST", path: "/api/todos", controller: "TodoController", action: "create"},
    
    // Development tools
    {name: "dashboard", method: "LIVE_DASHBOARD", path: "/dev/dashboard"}
])
```

### Naming Conventions

- **Function names**: camelCase (`todosIndex`, `apiUsers`)
- **Paths**: kebab-case with parameters (`/todos/:id/edit`)
- **Controllers**: PascalCase (`TodoLive`, `UserController`)
- **Actions**: snake_case converted automatically (`index`, `show`, `edit`)

### Route Grouping

Consider splitting large routers by functionality:

```haxe
// Main application routes
@:router
class AppRouter { /* public routes */ }

// API-specific routes  
@:router
class ApiRouter { /* API endpoints */ }

// Admin interface routes
@:router 
class AdminRouter { /* admin panel */ }
```

## Framework Integration

### Phoenix LiveView Routes

```haxe
{name: "todoLive", method: "LIVE", path: "/todos/:id", controller: "TodoLive", action: "show"}
```

Generates:
```elixir
live "/todos/:id", TodoLive, :todoLive
```

### Standard HTTP Routes

```haxe
{name: "apiUsers", method: "GET", path: "/api/users", controller: "UserController", action: "index"}
```

Generates:
```elixir  
get "/api/users", UserController, :apiUsers
```

### LiveDashboard Integration

```haxe
{name: "dashboard", method: "LIVE_DASHBOARD", path: "/dev/dashboard"}
```

Generates:
```elixir
if Application.compile_env(:app, :dev_routes) do
  import Phoenix.LiveDashboard.Router
  scope "/dev" do
    pipe_through :browser
    live_dashboard "/dev/dashboard"  
  end
end
```

## Testing

Router emission is snapshot-tested under `test/snapshot/phoenix/router/`.

Run the full snapshot suite with:
```bash
make -C test summary
```

## Troubleshooting

### Build Macro Not Running

Ensure the `@:build()` annotation is present:
```haxe
@:build(reflaxe.elixir.macros.RouterBuildMacro.generateRoutes())
```

### Functions Not Generated

Check for compilation errors in the macro:
```bash
haxe build.hxml -v  # Verbose output shows macro execution
```

### Route Validation Errors

The build macro provides specific error messages:
- **"Route missing required 'name' field"** - Add missing name
- **"Duplicate route name: home"** - Use unique function names
- **"Unknown HTTP method: INVALID"** - Use valid method names

### IDE Completion Issues

- **Functions not appearing**: Ensure build macro runs during IDE compilation
- **Type errors**: Check that macro generates proper function signatures
- **Outdated completion**: Restart IDE to refresh macro-generated functions

## Future Enhancements

### Pipeline Support
```haxe
{name: "adminUsers", method: "GET", path: "/admin/users", controller: "AdminController", action: "users", pipeline: "admin"}
```

### Route Constraints
```haxe
{name: "userShow", method: "GET", path: "/users/:id", controller: "UserController", action: "show", constraints: {id: "\\d+"}}
```

### Nested Scopes
```haxe
{name: "apiV1Users", method: "GET", path: "/api/v1/users", controller: "Api.V1.UserController", action: "index", scope: "/api/v1"}
```
